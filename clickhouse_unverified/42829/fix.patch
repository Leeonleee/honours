diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index 5c6ca1a1d572..1213b866b151 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -576,6 +576,7 @@ static constexpr UInt64 operator""_GiB(unsigned long long value)
     M(UInt64, query_plan_max_optimizations_to_apply, 10000, "Limit the total number of optimizations applied to query plan. If zero, ignored. If limit reached, throw exception", 0) \
     M(Bool, query_plan_filter_push_down, true, "Allow to push down filter by predicate query plan step", 0) \
     M(Bool, query_plan_optimize_primary_key, true, "Analyze primary key using query plan (instead of AST)", 0) \
+    M(Bool, query_plan_read_in_order, true, "Use query plan for read-in-order optimisation", 0) \
     M(UInt64, regexp_max_matches_per_row, 1000, "Max matches of any single regexp per row, used to safeguard 'extractAllGroupsHorizontal' against consuming too much memory with greedy RE.", 0) \
     \
     M(UInt64, limit, 0, "Limit on read rows from the most 'end' result for select query, default 0 means no limit length", 0) \
diff --git a/src/Interpreters/ActionsDAG.cpp b/src/Interpreters/ActionsDAG.cpp
index 3dc855b93fff..e0844b2dca73 100644
--- a/src/Interpreters/ActionsDAG.cpp
+++ b/src/Interpreters/ActionsDAG.cpp
@@ -1169,6 +1169,17 @@ ActionsDAGPtr ActionsDAG::makeAddingColumnActions(ColumnWithTypeAndName column)
 
 ActionsDAGPtr ActionsDAG::merge(ActionsDAG && first, ActionsDAG && second)
 {
+    first.mergeInplace(std::move(second));
+
+    /// Drop unused inputs and, probably, some actions.
+    first.removeUnusedActions();
+
+    return std::make_shared<ActionsDAG>(std::move(first));
+}
+
+void ActionsDAG::mergeInplace(ActionsDAG && second)
+{
+    auto & first = *this;
     /// first: x (1), x (2), y ==> x (2), z, x (3)
     /// second: x (1), x (2), x (3) ==> x (3), x (2), x (1)
     /// merge: x (1), x (2), x (3), y =(first)=> x (2), z, x (4), x (3) =(second)=> x (3), x (4), x (2), z
@@ -1256,11 +1267,6 @@ ActionsDAGPtr ActionsDAG::merge(ActionsDAG && first, ActionsDAG && second)
     first.nodes.splice(first.nodes.end(), std::move(second.nodes));
 
     first.projected_output = second.projected_output;
-
-    /// Drop unused inputs and, probably, some actions.
-    first.removeUnusedActions();
-
-    return std::make_shared<ActionsDAG>(std::move(first));
 }
 
 ActionsDAG::SplitResult ActionsDAG::split(std::unordered_set<const Node *> split_nodes) const
diff --git a/src/Interpreters/ActionsDAG.h b/src/Interpreters/ActionsDAG.h
index 76273463dce2..75438025c07b 100644
--- a/src/Interpreters/ActionsDAG.h
+++ b/src/Interpreters/ActionsDAG.h
@@ -273,6 +273,11 @@ class ActionsDAG
     /// Otherwise, any two actions may be combined.
     static ActionsDAGPtr merge(ActionsDAG && first, ActionsDAG && second);
 
+    /// The result is similar to merge(*this, second);
+    /// Invariant : no nodes are removed from the first (this) DAG.
+    /// So that pointers to nodes are kept valid.
+    void mergeInplace(ActionsDAG && second);
+
     using SplitResult = std::pair<ActionsDAGPtr, ActionsDAGPtr>;
 
     /// Split ActionsDAG into two DAGs, where first part contains all nodes from split_nodes and their children.
diff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp
index 9daa42bf4991..d40d886de621 100644
--- a/src/Interpreters/ExpressionAnalyzer.cpp
+++ b/src/Interpreters/ExpressionAnalyzer.cpp
@@ -1944,7 +1944,7 @@ ExpressionAnalysisResult::ExpressionAnalysisResult(
         }
 
         optimize_read_in_order =
-            settings.optimize_read_in_order
+            settings.optimize_read_in_order && (!settings.query_plan_read_in_order)
             && storage
             && query.orderBy()
             && !query_analyzer.hasAggregation()
@@ -1952,13 +1952,6 @@ ExpressionAnalysisResult::ExpressionAnalysisResult(
             && !query.final()
             && join_allow_read_in_order;
 
-        if (storage && optimize_read_in_order)
-        {
-            Names columns_for_sorting_key = metadata_snapshot->getColumnsRequiredForSortingKey();
-            additional_required_columns_after_prewhere.insert(additional_required_columns_after_prewhere.end(),
-                columns_for_sorting_key.begin(), columns_for_sorting_key.end());
-        }
-
         /// If there is aggregation, we execute expressions in SELECT and ORDER BY on the initiating server, otherwise on the source servers.
         query_analyzer.appendSelect(chain, only_types || (need_aggregate ? !second_stage : !first_stage));
 
diff --git a/src/Interpreters/IInterpreterUnionOrSelectQuery.h b/src/Interpreters/IInterpreterUnionOrSelectQuery.h
index a1c86f9de857..6f893d4703e6 100644
--- a/src/Interpreters/IInterpreterUnionOrSelectQuery.h
+++ b/src/Interpreters/IInterpreterUnionOrSelectQuery.h
@@ -58,6 +58,8 @@ class IInterpreterUnionOrSelectQuery : public IInterpreter
     /// Add limits from external query.
     void addStorageLimits(const StorageLimitsList & limits);
 
+    ContextPtr getContext() const { return context; }
+
 protected:
     ASTPtr query_ptr;
     ContextMutablePtr context;
diff --git a/src/Interpreters/InterpreterExplainQuery.cpp b/src/Interpreters/InterpreterExplainQuery.cpp
index fb8d3c6049fa..2864b433e007 100644
--- a/src/Interpreters/InterpreterExplainQuery.cpp
+++ b/src/Interpreters/InterpreterExplainQuery.cpp
@@ -419,19 +419,23 @@ QueryPipeline InterpreterExplainQuery::executeImpl()
             auto settings = checkAndGetSettings<QueryPlanSettings>(ast.getSettings());
             QueryPlan plan;
 
+            ContextPtr context;
+
             if (getContext()->getSettingsRef().allow_experimental_analyzer)
             {
                 InterpreterSelectQueryAnalyzer interpreter(ast.getExplainedQuery(), options, getContext());
+                context = interpreter.getContext();
                 plan = std::move(interpreter).extractQueryPlan();
             }
             else
             {
                 InterpreterSelectWithUnionQuery interpreter(ast.getExplainedQuery(), getContext(), options);
                 interpreter.buildQueryPlan(plan);
+                context = interpreter.getContext();
             }
 
             if (settings.optimize)
-                plan.optimize(QueryPlanOptimizationSettings::fromContext(getContext()));
+                plan.optimize(QueryPlanOptimizationSettings::fromContext(context));
 
             if (settings.json)
             {
@@ -461,21 +465,24 @@ QueryPipeline InterpreterExplainQuery::executeImpl()
             {
                 auto settings = checkAndGetSettings<QueryPipelineSettings>(ast.getSettings());
                 QueryPlan plan;
+                ContextPtr context;
 
                 if (getContext()->getSettingsRef().allow_experimental_analyzer)
                 {
                     InterpreterSelectQueryAnalyzer interpreter(ast.getExplainedQuery(), options, getContext());
+                    context = interpreter.getContext();
                     plan = std::move(interpreter).extractQueryPlan();
                 }
                 else
                 {
                     InterpreterSelectWithUnionQuery interpreter(ast.getExplainedQuery(), getContext(), options);
                     interpreter.buildQueryPlan(plan);
+                    context = interpreter.getContext();
                 }
 
                 auto pipeline = plan.buildQueryPipeline(
-                    QueryPlanOptimizationSettings::fromContext(getContext()),
-                    BuildQueryPipelineSettings::fromContext(getContext()));
+                    QueryPlanOptimizationSettings::fromContext(context),
+                    BuildQueryPipelineSettings::fromContext(context));
 
                 if (settings.graph)
                 {
@@ -511,16 +518,18 @@ QueryPipeline InterpreterExplainQuery::executeImpl()
 
             auto settings = checkAndGetSettings<QueryPlanSettings>(ast.getSettings());
             QueryPlan plan;
+            ContextPtr context;
 
             InterpreterSelectWithUnionQuery interpreter(ast.getExplainedQuery(), getContext(), SelectQueryOptions());
             interpreter.buildQueryPlan(plan);
+            context = interpreter.getContext();
             // collect the selected marks, rows, parts during build query pipeline.
             plan.buildQueryPipeline(
-                QueryPlanOptimizationSettings::fromContext(getContext()),
-                BuildQueryPipelineSettings::fromContext(getContext()));
+                QueryPlanOptimizationSettings::fromContext(context),
+                BuildQueryPipelineSettings::fromContext(context));
 
             if (settings.optimize)
-                plan.optimize(QueryPlanOptimizationSettings::fromContext(getContext()));
+                plan.optimize(QueryPlanOptimizationSettings::fromContext(context));
             plan.explainEstimate(res_columns);
             insert_buf = false;
             break;
diff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp
index d8ac263e3d15..dd3267361e24 100644
--- a/src/Interpreters/InterpreterSelectQuery.cpp
+++ b/src/Interpreters/InterpreterSelectQuery.cpp
@@ -1447,17 +1447,12 @@ void InterpreterSelectQuery::executeImpl(QueryPlan & query_plan, std::optional<P
                         for (const auto & key_name : key_names)
                             order_descr.emplace_back(key_name);
 
+                        SortingStep::Settings sort_settings(*context);
+
                         auto sorting_step = std::make_unique<SortingStep>(
                             plan.getCurrentDataStream(),
                             std::move(order_descr),
-                            settings.max_block_size,
-                            0 /* LIMIT */,
-                            SizeLimits(settings.max_rows_to_sort, settings.max_bytes_to_sort, settings.sort_overflow_mode),
-                            settings.max_bytes_before_remerge_sort,
-                            settings.remerge_sort_lowered_memory_bytes_ratio,
-                            settings.max_bytes_before_external_sort,
-                            this->context->getTempDataOnDisk(),
-                            settings.min_free_disk_space_for_temporary_data,
+                            0 /* LIMIT */, sort_settings,
                             settings.optimize_sorting_by_input_stream_properties);
                         sorting_step->setStepDescription(fmt::format("Sort {} before JOIN", join_pos));
                         plan.addStep(std::move(sorting_step));
@@ -2617,17 +2612,13 @@ void InterpreterSelectQuery::executeWindow(QueryPlan & query_plan)
         // happens in case of `over ()`.
         if (!window.full_sort_description.empty() && (i == 0 || !sortIsPrefix(window, *windows_sorted[i - 1])))
         {
+            SortingStep::Settings sort_settings(*context);
+
             auto sorting_step = std::make_unique<SortingStep>(
                 query_plan.getCurrentDataStream(),
                 window.full_sort_description,
-                settings.max_block_size,
                 0 /* LIMIT */,
-                SizeLimits(settings.max_rows_to_sort, settings.max_bytes_to_sort, settings.sort_overflow_mode),
-                settings.max_bytes_before_remerge_sort,
-                settings.remerge_sort_lowered_memory_bytes_ratio,
-                settings.max_bytes_before_external_sort,
-                context->getTempDataOnDisk(),
-                settings.min_free_disk_space_for_temporary_data,
+                sort_settings,
                 settings.optimize_sorting_by_input_stream_properties);
             sorting_step->setStepDescription("Sorting for window '" + window.window_name + "'");
             query_plan.addStep(std::move(sorting_step));
@@ -2675,18 +2666,14 @@ void InterpreterSelectQuery::executeOrder(QueryPlan & query_plan, InputOrderInfo
 
     const Settings & settings = context->getSettingsRef();
 
+    SortingStep::Settings sort_settings(*context);
+
     /// Merge the sorted blocks.
     auto sorting_step = std::make_unique<SortingStep>(
         query_plan.getCurrentDataStream(),
         output_order_descr,
-        settings.max_block_size,
         limit,
-        SizeLimits(settings.max_rows_to_sort, settings.max_bytes_to_sort, settings.sort_overflow_mode),
-        settings.max_bytes_before_remerge_sort,
-        settings.remerge_sort_lowered_memory_bytes_ratio,
-        settings.max_bytes_before_external_sort,
-        context->getTempDataOnDisk(),
-        settings.min_free_disk_space_for_temporary_data,
+        sort_settings,
         settings.optimize_sorting_by_input_stream_properties);
 
     sorting_step->setStepDescription("Sorting for ORDER BY");
diff --git a/src/Planner/Planner.cpp b/src/Planner/Planner.cpp
index 97f82d06463c..56cc73456cef 100644
--- a/src/Planner/Planner.cpp
+++ b/src/Planner/Planner.cpp
@@ -571,17 +571,13 @@ void Planner::buildQueryPlanIfNeeded()
             if (!window_description.full_sort_description.empty() &&
                 (i == 0 || !sortDescriptionIsPrefix(window_description.full_sort_description, window_descriptions[i - 1].full_sort_description)))
             {
+                SortingStep::Settings sort_settings(*query_context);
+
                 auto sorting_step = std::make_unique<SortingStep>(
                     query_plan.getCurrentDataStream(),
                     window_description.full_sort_description,
-                    settings.max_block_size,
                     0 /*limit*/,
-                    SizeLimits(settings.max_rows_to_sort, settings.max_bytes_to_sort, settings.sort_overflow_mode),
-                    settings.max_bytes_before_remerge_sort,
-                    settings.remerge_sort_lowered_memory_bytes_ratio,
-                    settings.max_bytes_before_external_sort,
-                    query_context->getTempDataOnDisk(),
-                    settings.min_free_disk_space_for_temporary_data,
+                    sort_settings,
                     settings.optimize_sorting_by_input_stream_properties);
 
                 sorting_step->setStepDescription("Sorting for window '" + window_description.window_name + "'");
@@ -673,18 +669,14 @@ void Planner::buildQueryPlanIfNeeded()
 
         const Settings & settings = query_context->getSettingsRef();
 
+        SortingStep::Settings sort_settings(*query_context);
+
         /// Merge the sorted blocks
         auto sorting_step = std::make_unique<SortingStep>(
             query_plan.getCurrentDataStream(),
             sort_description,
-            settings.max_block_size,
             partial_sorting_limit,
-            SizeLimits(settings.max_rows_to_sort, settings.max_bytes_to_sort, settings.sort_overflow_mode),
-            settings.max_bytes_before_remerge_sort,
-            settings.remerge_sort_lowered_memory_bytes_ratio,
-            settings.max_bytes_before_external_sort,
-            query_context->getTempDataOnDisk(),
-            settings.min_free_disk_space_for_temporary_data,
+            sort_settings,
             settings.optimize_sorting_by_input_stream_properties);
 
         sorting_step->setStepDescription("Sorting for ORDER BY");
diff --git a/src/Planner/PlannerJoinTree.cpp b/src/Planner/PlannerJoinTree.cpp
index 4cb446a65a0b..4e50a20bbd69 100644
--- a/src/Planner/PlannerJoinTree.cpp
+++ b/src/Planner/PlannerJoinTree.cpp
@@ -528,17 +528,13 @@ QueryPlan buildQueryPlanForJoinNode(QueryTreeNodePtr join_tree_node,
             for (const auto & key_name : key_names)
                 sort_description.emplace_back(key_name);
 
+            SortingStep::Settings sort_settings(*query_context);
+
             auto sorting_step = std::make_unique<SortingStep>(
                 plan.getCurrentDataStream(),
                 std::move(sort_description),
-                settings.max_block_size,
                 0 /*limit*/,
-                SizeLimits(settings.max_rows_to_sort, settings.max_bytes_to_sort, settings.sort_overflow_mode),
-                settings.max_bytes_before_remerge_sort,
-                settings.remerge_sort_lowered_memory_bytes_ratio,
-                settings.max_bytes_before_external_sort,
-                query_context->getTempDataOnDisk(),
-                settings.min_free_disk_space_for_temporary_data,
+                sort_settings,
                 settings.optimize_sorting_by_input_stream_properties);
             sorting_step->setStepDescription(fmt::format("Sort {} before JOIN", join_table_side));
             plan.addStep(std::move(sorting_step));
diff --git a/src/Processors/QueryPlan/Optimizations/Optimizations.h b/src/Processors/QueryPlan/Optimizations/Optimizations.h
index 25825f2f5b93..973304b366b2 100644
--- a/src/Processors/QueryPlan/Optimizations/Optimizations.h
+++ b/src/Processors/QueryPlan/Optimizations/Optimizations.h
@@ -9,12 +9,13 @@ namespace DB
 namespace QueryPlanOptimizations
 {
 
-/// This is the main function which optimizes the whole QueryPlan tree.
-void optimizeTree(const QueryPlanOptimizationSettings & settings, QueryPlan::Node & root, QueryPlan::Nodes & nodes);
+/// Main functions which optimize QueryPlan tree.
+/// First pass (ideally) apply local idempotent operations on top of Plan.
+void optimizeTreeFirstPass(const QueryPlanOptimizationSettings & settings, QueryPlan::Node & root, QueryPlan::Nodes & nodes);
+/// Second pass is used to apply read-in-order and attach a predicate to PK.
+void optimizeTreeSecondPass(const QueryPlanOptimizationSettings & optimization_settings, QueryPlan::Node & root, QueryPlan::Nodes & nodes);
 
-void optimizePrimaryKeyCondition(QueryPlan::Node & root);
-
-/// Optimization is a function applied to QueryPlan::Node.
+/// Optimization (first pass) is a function applied to QueryPlan::Node.
 /// It can read and update subtree of specified node.
 /// It return the number of updated layers of subtree if some change happened.
 /// It must guarantee that the structure of tree is correct.
@@ -29,10 +30,10 @@ struct Optimization
     const bool QueryPlanOptimizationSettings::* const is_enabled{};
 };
 
-/// Move ARRAY JOIN up if possible.
+/// Move ARRAY JOIN up if possible
 size_t tryLiftUpArrayJoin(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes);
 
-/// Move LimitStep down if possible.
+/// Move LimitStep down if possible
 size_t tryPushDownLimit(QueryPlan::Node * parent_node, QueryPlan::Nodes &);
 
 /// Split FilterStep into chain `ExpressionStep -> FilterStep`, where FilterStep contains minimal number of nodes.
@@ -55,7 +56,14 @@ size_t tryExecuteFunctionsAfterSorting(QueryPlan::Node * parent_node, QueryPlan:
 size_t tryReuseStorageOrderingForWindowFunctions(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes);
 
 /// Reading in order from MergeTree table if DISTINCT columns match or form a prefix of MergeTree sorting key
-size_t tryDistinctReadInOrder(QueryPlan::Node * node, QueryPlan::Nodes & nodes);
+size_t tryDistinctReadInOrder(QueryPlan::Node * node);
+
+/// Put some steps under union, so that plan optimisation could be applied to union parts separately.
+/// For example, the plan can be rewritten like:
+///                      - Something -                    - Expression - Something -
+/// - Expression - Union - Something -     =>     - Union - Expression - Something -
+///                      - Something -                    - Expression - Something -
+size_t tryLiftUpUnion(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes);
 
 inline const auto & getOptimizations()
 {
@@ -67,12 +75,24 @@ inline const auto & getOptimizations()
         {tryPushDownFilter, "pushDownFilter", &QueryPlanOptimizationSettings::filter_push_down},
         {tryExecuteFunctionsAfterSorting, "liftUpFunctions", &QueryPlanOptimizationSettings::optimize_plan},
         {tryReuseStorageOrderingForWindowFunctions, "reuseStorageOrderingForWindowFunctions", &QueryPlanOptimizationSettings::optimize_plan},
-        {tryDistinctReadInOrder, "distinctReadInOrder", &QueryPlanOptimizationSettings::distinct_in_order},
+        {tryLiftUpUnion, "liftUpUnion", &QueryPlanOptimizationSettings::optimize_plan},
     }};
 
     return optimizations;
 }
 
+struct Frame
+{
+    QueryPlan::Node * node = nullptr;
+    size_t next_child = 0;
+};
+
+using Stack = std::vector<Frame>;
+
+/// Second pass optimizations
+void optimizePrimaryKeyCondition(const Stack & stack);
+void optimizeReadInOrder(QueryPlan::Node & node, QueryPlan::Nodes & nodes);
+
 }
 
 }
diff --git a/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.cpp b/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.cpp
index 2342f961751c..88c0f346e9ab 100644
--- a/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.cpp
+++ b/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.cpp
@@ -12,6 +12,7 @@ QueryPlanOptimizationSettings QueryPlanOptimizationSettings::fromSettings(const
     settings.max_optimizations_to_apply = from.query_plan_max_optimizations_to_apply;
     settings.filter_push_down = from.query_plan_filter_push_down;
     settings.distinct_in_order = from.optimize_distinct_in_order;
+    settings.read_in_order = from.optimize_read_in_order && from.query_plan_read_in_order;
     return settings;
 }
 
diff --git a/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.h b/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.h
index 0da89f28aad3..7185d2fe869c 100644
--- a/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.h
+++ b/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.h
@@ -24,6 +24,9 @@ struct QueryPlanOptimizationSettings
     /// if distinct in order optimization is enabled
     bool distinct_in_order = false;
 
+    /// If read-in-order optimisation is enabled
+    bool read_in_order = true;
+
     static QueryPlanOptimizationSettings fromSettings(const Settings & from);
     static QueryPlanOptimizationSettings fromContext(ContextPtr from);
 };
diff --git a/src/Processors/QueryPlan/Optimizations/distinctReadInOrder.cpp b/src/Processors/QueryPlan/Optimizations/distinctReadInOrder.cpp
index 38cb6f3d3c52..3677a1581c43 100644
--- a/src/Processors/QueryPlan/Optimizations/distinctReadInOrder.cpp
+++ b/src/Processors/QueryPlan/Optimizations/distinctReadInOrder.cpp
@@ -7,7 +7,7 @@
 
 namespace DB::QueryPlanOptimizations
 {
-size_t tryDistinctReadInOrder(QueryPlan::Node * parent_node, QueryPlan::Nodes &)
+size_t tryDistinctReadInOrder(QueryPlan::Node * parent_node)
 {
     /// check if it is preliminary distinct node
     DistinctStep * pre_distinct = nullptr;
@@ -22,7 +22,7 @@ size_t tryDistinctReadInOrder(QueryPlan::Node * parent_node, QueryPlan::Nodes &)
     /// walk through the plan
     /// (1) check if nodes below preliminary distinct preserve sorting
     /// (2) gather transforming steps to update their sorting properties later
-    std::vector<ITransformingStep *> steps2update;
+    std::vector<ITransformingStep *> steps_to_update;
     QueryPlan::Node * node = parent_node;
     while (!node->children.empty())
     {
@@ -34,7 +34,7 @@ size_t tryDistinctReadInOrder(QueryPlan::Node * parent_node, QueryPlan::Nodes &)
         if (!traits.preserves_sorting)
             return 0;
 
-        steps2update.push_back(step);
+        steps_to_update.push_back(step);
 
         node = node->children.front();
     }
@@ -90,11 +90,11 @@ size_t tryDistinctReadInOrder(QueryPlan::Node * parent_node, QueryPlan::Nodes &)
 
     /// update data stream's sorting properties for found transforms
     const DataStream * input_stream = &read_from_merge_tree->getOutputStream();
-    while (!steps2update.empty())
+    while (!steps_to_update.empty())
     {
-        steps2update.back()->updateInputStream(*input_stream);
-        input_stream = &steps2update.back()->getOutputStream();
-        steps2update.pop_back();
+        steps_to_update.back()->updateInputStream(*input_stream);
+        input_stream = &steps_to_update.back()->getOutputStream();
+        steps_to_update.pop_back();
     }
 
     return 0;
diff --git a/src/Processors/QueryPlan/Optimizations/liftUpUnion.cpp b/src/Processors/QueryPlan/Optimizations/liftUpUnion.cpp
new file mode 100644
index 000000000000..35d8b1a35e43
--- /dev/null
+++ b/src/Processors/QueryPlan/Optimizations/liftUpUnion.cpp
@@ -0,0 +1,65 @@
+#include <Processors/QueryPlan/Optimizations/Optimizations.h>
+#include <Processors/QueryPlan/UnionStep.h>
+#include <Processors/QueryPlan/ExpressionStep.h>
+#include <Interpreters/ActionsDAG.h>
+
+namespace DB::QueryPlanOptimizations
+{
+
+size_t tryLiftUpUnion(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes)
+{
+    if (parent_node->children.empty())
+        return 0;
+
+    QueryPlan::Node * child_node = parent_node->children.front();
+    auto & parent = parent_node->step;
+    auto & child = child_node->step;
+
+    auto * union_step = typeid_cast<UnionStep *>(child.get());
+    if (!union_step)
+        return 0;
+
+    if (auto * expression = typeid_cast<ExpressionStep *>(parent.get()))
+    {
+        /// Union does not change header.
+        /// We can push down expression and update header.
+        auto union_input_streams = child->getInputStreams();
+        for (auto & input_stream : union_input_streams)
+            input_stream.header = expression->getOutputStream().header;
+
+        ///                    - Something
+        /// Expression - Union - Something
+        ///                    - Something
+
+        child = std::make_unique<UnionStep>(union_input_streams, union_step->getMaxThreads());
+
+        std::swap(parent, child);
+        std::swap(parent_node->children, child_node->children);
+        std::swap(parent_node->children.front(), child_node->children.front());
+
+        ///       - Expression - Something
+        /// Union - Something
+        ///       - Something
+
+        for (size_t i = 1; i < parent_node->children.size(); ++i)
+        {
+            auto & expr_node = nodes.emplace_back();
+            expr_node.children.push_back(parent_node->children[i]);
+            parent_node->children[i] = &expr_node;
+
+            expr_node.step = std::make_unique<ExpressionStep>(
+                expr_node.children.front()->step->getOutputStream(),
+                expression->getExpression()->clone());
+        }
+
+        ///       - Expression - Something
+        /// Union - Expression - Something
+        ///       - Expression - Something
+
+        return 3;
+    }
+
+    return 0;
+}
+
+}
diff --git a/src/Processors/QueryPlan/Optimizations/optimizePrimaryKeyCondition.cpp b/src/Processors/QueryPlan/Optimizations/optimizePrimaryKeyCondition.cpp
index 984c76701ba6..cac4944bad7a 100644
--- a/src/Processors/QueryPlan/Optimizations/optimizePrimaryKeyCondition.cpp
+++ b/src/Processors/QueryPlan/Optimizations/optimizePrimaryKeyCondition.cpp
@@ -9,49 +9,32 @@
 namespace DB::QueryPlanOptimizations
 {
 
-void optimizePrimaryKeyCondition(QueryPlan::Node & root)
+void optimizePrimaryKeyCondition(const Stack & stack)
 {
-    struct Frame
-    {
-        QueryPlan::Node * node = nullptr;
-        size_t next_child = 0;
-    };
+    const auto & frame = stack.back();
 
-    std::vector<Frame> stack;
-    stack.push_back({.node = &root});
+    auto * read_from_merge_tree = typeid_cast<ReadFromMergeTree *>(frame.node->step.get());
+    auto * read_from_merge = typeid_cast<ReadFromMerge *>(frame.node->step.get());
 
-    while (!stack.empty())
-    {
-        auto & frame = stack.back();
+    if (!read_from_merge && !read_from_merge_tree)
+        return;
 
-        /// Traverse all children first.
-        if (frame.next_child < frame.node->children.size())
+    for (auto iter = stack.rbegin() + 1; iter != stack.rend(); ++iter)
+    {
+        if (auto * filter_step = typeid_cast<FilterStep *>(iter->node->step.get()))
         {
-            auto next_frame = Frame{.node = frame.node->children[frame.next_child]};
-            ++frame.next_child;
-            stack.push_back(next_frame);
-            continue;
+            if (read_from_merge_tree)
+                read_from_merge_tree->addFilter(filter_step->getExpression(), filter_step->getFilterColumnName());
+            if (read_from_merge)
+                read_from_merge->addFilter(filter_step->getExpression(), filter_step->getFilterColumnName());
         }
-
-        auto add_read_from_storage_filter = [&](auto & storage)
-        {
-            for (auto iter = stack.rbegin() + 1; iter != stack.rend(); ++iter)
-            {
-                if (auto * filter_step = typeid_cast<FilterStep *>(iter->node->step.get()))
-                    storage.addFilter(filter_step->getExpression(), filter_step->getFilterColumnName());
-                else if (typeid_cast<ExpressionStep *>(iter->node->step.get()))
-                    continue;
-                else
-                    break;
-            }
-        };
-
-        if (auto * read_from_merge_tree = typeid_cast<ReadFromMergeTree *>(frame.node->step.get()))
-            add_read_from_storage_filter(*read_from_merge_tree);
-        else if (auto * read_from_merge = typeid_cast<ReadFromMerge *>(frame.node->step.get()))
-            add_read_from_storage_filter(*read_from_merge);
-
-        stack.pop_back();
+        /// Note: actually, plan optimizations merge Filter and Expression steps.
+        /// Ideally, chain should look like (Expression -> ...) -> (Filter -> ...) -> ReadFromStorage,
+        /// So this is likely not needed.
+        else if (typeid_cast<ExpressionStep *>(iter->node->step.get()))
+            continue;
+        else
+            break;
     }
 }
 
diff --git a/src/Processors/QueryPlan/Optimizations/optimizeReadInOrder.cpp b/src/Processors/QueryPlan/Optimizations/optimizeReadInOrder.cpp
new file mode 100644
index 000000000000..ac131a1b67cb
--- /dev/null
+++ b/src/Processors/QueryPlan/Optimizations/optimizeReadInOrder.cpp
@@ -0,0 +1,953 @@
+#include <Parsers/ASTWindowDefinition.h>
+#include <Processors/QueryPlan/Optimizations/Optimizations.h>
+#include <Processors/QueryPlan/ITransformingStep.h>
+#include <Processors/QueryPlan/AggregatingStep.h>
+#include <Processors/QueryPlan/ExpressionStep.h>
+#include <Processors/QueryPlan/JoinStep.h>
+#include <Processors/QueryPlan/ArrayJoinStep.h>
+#include <Processors/QueryPlan/CreatingSetsStep.h>
+#include <Processors/QueryPlan/CubeStep.h>
+#include <Processors/QueryPlan/ReadFromMergeTree.h>
+#include <Processors/QueryPlan/SortingStep.h>
+#include <Processors/QueryPlan/TotalsHavingStep.h>
+#include <Processors/QueryPlan/DistinctStep.h>
+#include <Processors/QueryPlan/UnionStep.h>
+#include <Processors/QueryPlan/WindowStep.h>
+#include <Interpreters/ActionsDAG.h>
+#include <Interpreters/ArrayJoinAction.h>
+#include <Interpreters/InterpreterSelectQuery.h>
+#include <Interpreters/TableJoin.h>
+#include <Common/typeid_cast.h>
+#include <Storages/StorageMerge.h>
+#include <Functions/IFunction.h>
+#include <DataTypes/DataTypeAggregateFunction.h>
+#include <Columns/IColumn.h>
+#include <stack>
+
+
+namespace DB::QueryPlanOptimizations
+{
+
+ISourceStep * checkSupportedReadingStep(IQueryPlanStep * step)
+{
+    if (auto * reading = typeid_cast<ReadFromMergeTree *>(step))
+    {
+        /// Already read-in-order, skip.
+        if (reading->getQueryInfo().input_order_info)
+            return nullptr;
+
+        const auto & sorting_key = reading->getStorageMetadata()->getSortingKey();
+        if (sorting_key.column_names.empty())
+            return nullptr;
+
+        return reading;
+    }
+
+    if (auto * merge = typeid_cast<ReadFromMerge *>(step))
+    {
+        const auto & tables = merge->getSelectedTables();
+        if (tables.empty())
+            return nullptr;
+
+        for (const auto & table : tables)
+        {
+            auto storage = std::get<StoragePtr>(table);
+            const auto & sorting_key = storage->getInMemoryMetadataPtr()->getSortingKey();
+            if (sorting_key.column_names.empty())
+                return nullptr;
+        }
+
+        return merge;
+    }
+
+    return nullptr;
+}
+
+QueryPlan::Node * findReadingStep(QueryPlan::Node & node)
+{
+    IQueryPlanStep * step = node.step.get();
+    if (auto * reading = checkSupportedReadingStep(step))
+        return &node;
+
+    if (node.children.size() != 1)
+        return nullptr;
+
+    if (typeid_cast<ExpressionStep *>(step) || typeid_cast<FilterStep *>(step) || typeid_cast<ArrayJoinStep *>(step))
+        return findReadingStep(*node.children.front());
+
+    if (auto * distinct = typeid_cast<DistinctStep *>(step); distinct && distinct->isPreliminary())
+        return findReadingStep(*node.children.front());
+
+    return nullptr;
+}
+
+/// FixedColumns are columns which values become constants after filtering.
+/// In a query "SELECT x, y, z FROM table WHERE x = 1 AND y = 'a' ORDER BY x, y, z"
+/// Fixed columns are 'x' and 'y'.
+using FixedColumns = std::unordered_set<const ActionsDAG::Node *>;
+
+/// Right now we find only simple cases like 'and(..., and(..., and(column = value, ...), ...'
+/// Injective functions are supported here. For a condition 'injectiveFunction(x) = 5' column 'x' is fixed.
+void appendFixedColumnsFromFilterExpression(const ActionsDAG::Node & filter_expression, FixedColumns & fixed_columns)
+{
+    std::stack<const ActionsDAG::Node *> stack;
+    stack.push(&filter_expression);
+
+    while (!stack.empty())
+    {
+        const auto * node = stack.top();
+        stack.pop();
+        if (node->type == ActionsDAG::ActionType::FUNCTION)
+        {
+            const auto & name = node->function_base->getName();
+            if (name == "and")
+            {
+                for (const auto * arg : node->children)
+                    stack.push(arg);
+            }
+            else if (name == "equals")
+            {
+                const ActionsDAG::Node * maybe_fixed_column = nullptr;
+                size_t num_constant_columns = 0;
+                for (const auto & child : node->children)
+                {
+                    if (child->column)
+                        ++num_constant_columns;
+                    else
+                        maybe_fixed_column = child;
+                }
+
+                if (maybe_fixed_column && num_constant_columns + 1 == node->children.size())
+                {
+                    //std::cerr << "====== Added fixed column " << maybe_fixed_column->result_name << ' ' << static_cast<const void *>(maybe_fixed_column) << std::endl;
+                    fixed_columns.insert(maybe_fixed_column);
+
+                    /// Support injective functions chain.
+                    const ActionsDAG::Node * maybe_injective = maybe_fixed_column;
+                    while (maybe_injective->type == ActionsDAG::ActionType::FUNCTION
+                        && maybe_injective->children.size() == 1
+                        && maybe_injective->function_base->isInjective({}))
+                    {
+                        maybe_injective = maybe_injective->children.front();
+                        fixed_columns.insert(maybe_injective);
+                    }
+                }
+            }
+        }
+    }
+}
+
+void appendExpression(ActionsDAGPtr & dag, const ActionsDAGPtr & expression)
+{
+    if (dag)
+        dag->mergeInplace(std::move(*expression->clone()));
+    else
+        dag = expression->clone();
+}
+
+/// This function builds a common DAG which is a gerge of DAGs from Filter and Expression steps chain.
+/// Additionally, build a set of fixed columns.
+void buildSortingDAG(QueryPlan::Node & node, ActionsDAGPtr & dag, FixedColumns & fixed_columns, size_t & limit)
+{
+    IQueryPlanStep * step = node.step.get();
+    if (auto * reading = typeid_cast<ReadFromMergeTree *>(step))
+    {
+        if (const auto * prewhere_info = reading->getPrewhereInfo())
+        {
+            /// Should ignore limit if there is filtering.
+            limit = 0;
+
+            if (prewhere_info->prewhere_actions)
+            {
+                //std::cerr << "====== Adding prewhere " << std::endl;
+                appendExpression(dag, prewhere_info->prewhere_actions);
+                if (const auto * filter_expression = dag->tryFindInOutputs(prewhere_info->prewhere_column_name))
+                    appendFixedColumnsFromFilterExpression(*filter_expression, fixed_columns);
+            }
+        }
+        return;
+    }
+
+    if (node.children.size() != 1)
+        return;
+
+    buildSortingDAG(*node.children.front(), dag, fixed_columns, limit);
+
+    if (auto * expression = typeid_cast<ExpressionStep *>(step))
+    {
+        const auto & actions = expression->getExpression();
+
+        /// Should ignore limit because arrayJoin() can reduce the number of rows in case of empty array.
+        if (actions->hasArrayJoin())
+            limit = 0;
+
+        appendExpression(dag, actions);
+    }
+
+    if (auto * filter = typeid_cast<FilterStep *>(step))
+    {
+        /// Should ignore limit if there is filtering.
+        limit = 0;
+
+        appendExpression(dag, filter->getExpression());
+        if (const auto * filter_expression = dag->tryFindInOutputs(filter->getFilterColumnName()))
+            appendFixedColumnsFromFilterExpression(*filter_expression, fixed_columns);
+    }
+
+    if (auto * array_join = typeid_cast<ArrayJoinStep *>(step))
+    {
+        /// Should ignore limit because ARRAY JOIN can reduce the number of rows in case of empty array.
+        /// But in case of LEFT ARRAY JOIN the result number of rows is always bigger.
+        if (!array_join->arrayJoin()->is_left)
+            limit = 0;
+
+        const auto & array_joined_columns = array_join->arrayJoin()->columns;
+
+        /// Remove array joined columns from outputs.
+        /// Types are changed after ARRAY JOIN, and we can't use this columns anyway.
+        ActionsDAG::NodeRawConstPtrs outputs;
+        outputs.reserve(dag->getOutputs().size());
+
+        for (const auto & output : dag->getOutputs())
+        {
+            if (!array_joined_columns.contains(output->result_name))
+                outputs.push_back(output);
+        }
+    }
+}
+
+/// Add more functions to fixed columns.
+/// Functions result is fixed if all arguments are fixed or constants.
+void enreachFixedColumns(const ActionsDAG & dag, FixedColumns & fixed_columns)
+{
+    struct Frame
+    {
+        const ActionsDAG::Node * node;
+        size_t next_child = 0;
+    };
+
+    std::stack<Frame> stack;
+    std::unordered_set<const ActionsDAG::Node *> visited;
+    for (const auto & node : dag.getNodes())
+    {
+        if (visited.contains(&node))
+            continue;
+
+        stack.push({&node});
+        visited.insert(&node);
+        while (!stack.empty())
+        {
+            auto & frame = stack.top();
+            for (; frame.next_child < frame.node->children.size(); ++frame.next_child)
+                if (!visited.contains(frame.node->children[frame.next_child]))
+                    break;
+
+            if (frame.next_child < frame.node->children.size())
+            {
+                const auto * child = frame.node->children[frame.next_child];
+                visited.insert(child);
+                stack.push({child});
+                ++frame.next_child;
+            }
+            else
+            {
+                /// Ignore constants here, will check them separately
+                if (!frame.node->column)
+                {
+                    if (frame.node->type == ActionsDAG::ActionType::ALIAS)
+                    {
+                        if (fixed_columns.contains(frame.node->children.at(0)))
+                            fixed_columns.insert(frame.node);
+                    }
+                    else if (frame.node->type == ActionsDAG::ActionType::FUNCTION)
+                    {
+                        if (frame.node->function_base->isDeterministicInScopeOfQuery())
+                        {
+                            //std::cerr << "*** enreachFixedColumns check " << frame.node->result_name << std::endl;
+                            bool all_args_fixed_or_const = true;
+                            for (const auto * child : frame.node->children)
+                            {
+                                if (!child->column && !fixed_columns.contains(child))
+                                {
+                                    //std::cerr << "*** enreachFixedColumns fail " << child->result_name <<  ' ' << static_cast<const void *>(child) << std::endl;
+                                    all_args_fixed_or_const = false;
+                                }
+                            }
+
+                            if (all_args_fixed_or_const)
+                            {
+                                //std::cerr << "*** enreachFixedColumns add " << frame.node->result_name << ' ' << static_cast<const void *>(frame.node) << std::endl;
+                                fixed_columns.insert(frame.node);
+                            }
+                        }
+                    }
+                }
+
+                stack.pop();
+            }
+        }
+    }
+}
+
+/// This structure stores a node mapping from one DAG to another.
+/// The rule is following:
+/// * Input nodes are mapped by name.
+/// * Function is mapped to function if all children are mapped and function names are same.
+/// * Alias is mapped to it's children mapping.
+/// * Monotonic function can be mapped to it's children mapping if direct mapping does not exist.
+///   In this case, information about monotonicity is filled.
+/// * Mapped node is nullptr if there is no mapping found.
+///
+/// Overall, directly mapped nodes represent equal calculations.
+/// Notes:
+/// * Mapped DAG can contain many nodes which represent the same calculation.
+///   In this case mapping is ambiguous and only one node is mapped.
+/// * Aliases for mapped DAG are not supported.
+/// DAG for PK does not contain aliases and ambiguous nodes.
+struct MatchedTrees
+{
+    /// Monotonicity is calculated for monotonic functions chain.
+    /// Chain is not strict if there is any non-strict monotonic function.
+    struct Monotonicity
+    {
+        int direction = 1;
+        bool strict = true;
+    };
+
+    struct Match
+    {
+        const ActionsDAG::Node * node = nullptr;
+        std::optional<Monotonicity> monotonicity;
+    };
+
+    using Matches = std::unordered_map<const ActionsDAG::Node *, Match>;
+};
+
+MatchedTrees::Matches matchTrees(const ActionsDAG & inner_dag, const ActionsDAG & outer_dag)
+{
+    using Parents = std::set<const ActionsDAG::Node *>;
+    std::unordered_map<const ActionsDAG::Node *, Parents> inner_parents;
+    std::unordered_map<std::string_view, const ActionsDAG::Node *> inner_inputs;
+
+    {
+        std::stack<const ActionsDAG::Node *> stack;
+        for (const auto * out : inner_dag.getOutputs())
+        {
+            if (inner_parents.contains(out))
+                continue;
+
+            stack.push(out);
+            inner_parents.emplace(out, Parents());
+            while (!stack.empty())
+            {
+                const auto * node = stack.top();
+                stack.pop();
+
+                if (node->type == ActionsDAG::ActionType::INPUT)
+                    inner_inputs.emplace(node->result_name, node);
+
+                for (const auto * child : node->children)
+                {
+                    auto [it, inserted] = inner_parents.emplace(child, Parents());
+                    it->second.emplace(node);
+
+                    if (inserted)
+                        stack.push(child);
+                }
+            }
+        }
+    }
+
+    struct Frame
+    {
+        const ActionsDAG::Node * node;
+        ActionsDAG::NodeRawConstPtrs mapped_children;
+    };
+
+    MatchedTrees::Matches matches;
+    std::stack<Frame> stack;
+
+    for (const auto & node : outer_dag.getNodes())
+    {
+        if (matches.contains(&node))
+            continue;
+
+        stack.push(Frame{&node, {}});
+        while (!stack.empty())
+        {
+            auto & frame = stack.top();
+            frame.mapped_children.reserve(frame.node->children.size());
+
+            while (frame.mapped_children.size() < frame.node->children.size())
+            {
+                const auto * child = frame.node->children[frame.mapped_children.size()];
+                auto it = matches.find(child);
+                if (it == matches.end())
+                {
+                    /// If match map does not contain a child, it was not visited.
+                    stack.push(Frame{child, {}});
+                    break;
+                }
+                /// A node from found match may be nullptr.
+                /// It means that node is visited, but no match was found.
+                frame.mapped_children.push_back(it->second.node);
+            }
+
+            if (frame.mapped_children.size() < frame.node->children.size())
+                continue;
+
+            /// Create an empty match for current node.
+            /// natch.node will be set if match is found.
+            auto & match = matches[frame.node];
+
+            if (frame.node->type == ActionsDAG::ActionType::INPUT)
+            {
+                const ActionsDAG::Node * mapped = nullptr;
+                if (auto it = inner_inputs.find(frame.node->result_name); it != inner_inputs.end())
+                    mapped = it->second;
+
+                match.node = mapped;
+            }
+            else if (frame.node->type == ActionsDAG::ActionType::ALIAS)
+            {
+                match = matches[frame.node->children.at(0)];
+            }
+            else if (frame.node->type == ActionsDAG::ActionType::FUNCTION)
+            {
+
+                //std::cerr << "... Processing " << frame.node->function_base->getName() << std::endl;
+
+                bool found_all_children = true;
+                for (const auto * child : frame.mapped_children)
+                    if (!child)
+                        found_all_children = false;
+
+                if (found_all_children && !frame.mapped_children.empty())
+                {
+                    Parents container;
+                    Parents * intersection = &inner_parents[frame.mapped_children[0]];
+
+                    if (frame.mapped_children.size() > 1)
+                    {
+                        std::vector<Parents *> other_parents;
+                        size_t mapped_children_size = frame.mapped_children.size();
+                        other_parents.reserve(mapped_children_size);
+                        for (size_t i = 1; i < mapped_children_size; ++i)
+                            other_parents.push_back(&inner_parents[frame.mapped_children[i]]);
+
+                        for (const auto * parent : *intersection)
+                        {
+                            bool is_common = true;
+                            for (const auto * set : other_parents)
+                            {
+                                if (!set->contains(parent))
+                                {
+                                    is_common = false;
+                                    break;
+                                }
+                            }
+
+                            if (is_common)
+                                container.insert(parent);
+                        }
+
+                        intersection = &container;
+                    }
+
+                    //std::cerr << ".. Candidate parents " << intersection->size() << std::endl;
+
+                    if (!intersection->empty())
+                    {
+                        auto func_name = frame.node->function_base->getName();
+                        for (const auto * parent : *intersection)
+                        {
+                            //std::cerr << ".. candidate " << parent->result_name << std::endl;
+                            if (parent->type == ActionsDAG::ActionType::FUNCTION && func_name == parent->function_base->getName())
+                            {
+                                const auto & children = parent->children;
+                                size_t num_children = children.size();
+                                if (frame.mapped_children.size() == num_children)
+                                {
+                                    bool all_children_matched = true;
+                                    for (size_t i = 0; all_children_matched && i < num_children; ++i)
+                                        all_children_matched = frame.mapped_children[i] == children[i];
+
+                                    if (all_children_matched)
+                                    {
+                                        match.node = parent;
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+
+                if (!match.node && frame.node->function_base->hasInformationAboutMonotonicity())
+                {
+                    size_t num_const_args = 0;
+                    const ActionsDAG::Node * monotonic_child = nullptr;
+                    for (const auto * child : frame.node->children)
+                    {
+                        if (child->column)
+                            ++num_const_args;
+                        else
+                            monotonic_child = child;
+                    }
+
+                    if (monotonic_child && num_const_args + 1 == frame.node->children.size())
+                    {
+                        const auto & child_match = matches[monotonic_child];
+                        if (child_match.node)
+                        {
+                            auto info = frame.node->function_base->getMonotonicityForRange(*monotonic_child->result_type, {}, {});
+                            if (info.is_monotonic)
+                            {
+                                MatchedTrees::Monotonicity monotonicity;
+                                monotonicity.direction *= info.is_positive ? 1 : -1;
+                                monotonicity.strict = info.is_strict;
+
+                                if (child_match.monotonicity)
+                                {
+                                    monotonicity.direction *= child_match.monotonicity->direction;
+                                    if (!child_match.monotonicity->strict)
+                                        monotonicity.strict = false;
+                                }
+
+                                match.node = child_match.node;
+                                match.monotonicity = monotonicity;
+                            }
+                        }
+                    }
+                }
+            }
+
+            stack.pop();
+        }
+    }
+
+    return matches;
+}
+
+InputOrderInfoPtr buildInputOrderInfo(
+    const FixedColumns & fixed_columns,
+    const ActionsDAGPtr & dag,
+    const SortDescription & description,
+    const ActionsDAG & sorting_key_dag,
+    const Names & sorting_key_columns,
+    size_t limit)
+{
+    //std::cerr << "------- buildInputOrderInfo " << std::endl;
+    SortDescription order_key_prefix_descr;
+    order_key_prefix_descr.reserve(description.size());
+
+    MatchedTrees::Matches matches;
+    FixedColumns fixed_key_columns;
+
+    if (dag)
+    {
+        matches = matchTrees(sorting_key_dag, *dag);
+
+        for (const auto & [node, match] : matches)
+        {
+            //std::cerr << "------- matching " << static_cast<const void *>(node) << " " << node->result_name
+            //    << " to " << static_cast<const void *>(match.node) << " " << (match.node ? match.node->result_name : "") << std::endl;
+            if (!match.monotonicity || match.monotonicity->strict)
+            {
+                if (match.node && fixed_columns.contains(node))
+                    fixed_key_columns.insert(match.node);
+            }
+        }
+
+        enreachFixedColumns(sorting_key_dag, fixed_key_columns);
+    }
+
+    /// This is a result direction we will read from MergeTree
+    ///  1 - in order,
+    /// -1 - in reverse order,
+    ///  0 - usual read, don't apply optimization
+    ///
+    /// So far, 0 means any direction is possible. It is ok for constant prefix.
+    int read_direction = 0;
+    size_t next_description_column = 0;
+    size_t next_sort_key = 0;
+
+    while (next_description_column < description.size() && next_sort_key < sorting_key_columns.size())
+    {
+        const auto & sorting_key_column = sorting_key_columns[next_sort_key];
+        const auto & sort_column_description = description[next_description_column];
+
+        /// If required order depend on collation, it cannot be matched with primary key order.
+        /// Because primary keys cannot have collations.
+        if (sort_column_description.collator)
+            break;
+
+        /// Direction for current sort key.
+        int current_direction = 0;
+        bool strict_monotonic = true;
+
+        const ActionsDAG::Node * sort_column_node = sorting_key_dag.tryFindInOutputs(sorting_key_column);
+        /// This should not happen.
+        if (!sort_column_node)
+            break;
+
+        if (!dag)
+        {
+            /// This is possible if there were no Expression or Filter steps in Plan.
+            /// Example: SELECT * FROM tab ORDER BY a, b
+
+            if (sort_column_node->type != ActionsDAG::ActionType::INPUT)
+                break;
+
+            if (sort_column_description.column_name != sorting_key_column)
+                break;
+
+            current_direction = sort_column_description.direction;
+
+
+            //std::cerr << "====== (no dag) Found direct match" << std::endl;
+
+            ++next_description_column;
+            ++next_sort_key;
+        }
+        else
+        {
+            const ActionsDAG::Node * sort_node = dag->tryFindInOutputs(sort_column_description.column_name);
+             /// It is possible when e.g. sort by array joined column.
+            if (!sort_node)
+                break;
+
+            const auto & match = matches[sort_node];
+
+            //std::cerr << "====== Finding match for " << sort_column_node->result_name << ' ' << static_cast<const void *>(sort_column_node) << std::endl;
+
+            if (match.node && match.node == sort_column_node)
+            {
+                //std::cerr << "====== Found direct match" << std::endl;
+
+                /// We try to find the match first even if column is fixed. In this case, potentially more keys will match.
+                /// Example: 'table (x Int32, y Int32) ORDER BY x + 1, y + 1'
+                ///          'SELECT x, y FROM table WHERE x = 42 ORDER BY x + 1, y + 1'
+                /// Here, 'x + 1' would be a fixed point. But it is reasonable to read-in-order.
+
+                current_direction = sort_column_description.direction;
+                if (match.monotonicity)
+                {
+                    current_direction *= match.monotonicity->direction;
+                    strict_monotonic = match.monotonicity->strict;
+                }
+
+                ++next_description_column;
+                ++next_sort_key;
+            }
+            else if (fixed_key_columns.contains(sort_column_node))
+            {
+                //std::cerr << "+++++++++ Found fixed key by match" << std::endl;
+                ++next_sort_key;
+            }
+            else
+            {
+
+                //std::cerr << "====== Check for fixed const : " << bool(sort_node->column) << " fixed : " << fixed_columns.contains(sort_node) << std::endl;
+                bool is_fixed_column = sort_node->column || fixed_columns.contains(sort_node);
+                if (!is_fixed_column)
+                    break;
+
+                order_key_prefix_descr.push_back(sort_column_description);
+                ++next_description_column;
+            }
+        }
+
+        /// read_direction == 0 means we can choose any global direction.
+        /// current_direction == 0 means current key if fixed and any direction is possible for it.
+        if (current_direction && read_direction && current_direction != read_direction)
+            break;
+
+        if (read_direction == 0)
+            read_direction = current_direction;
+
+        if (current_direction)
+            order_key_prefix_descr.push_back(sort_column_description);
+
+        if (current_direction && !strict_monotonic)
+            break;
+    }
+
+    if (read_direction == 0 || order_key_prefix_descr.empty())
+        return nullptr;
+
+    return std::make_shared<InputOrderInfo>(order_key_prefix_descr, next_sort_key, read_direction, limit);
+}
+
+InputOrderInfoPtr buildInputOrderInfo(
+    ReadFromMergeTree * reading,
+    const FixedColumns & fixed_columns,
+    const ActionsDAGPtr & dag,
+    const SortDescription & description,
+    size_t limit)
+{
+    const auto & sorting_key = reading->getStorageMetadata()->getSortingKey();
+    const auto & sorting_key_columns = sorting_key.column_names;
+
+    return buildInputOrderInfo(
+        fixed_columns,
+        dag, description,
+        sorting_key.expression->getActionsDAG(), sorting_key_columns,
+        limit);
+}
+
+InputOrderInfoPtr buildInputOrderInfo(
+    ReadFromMerge * merge,
+    const FixedColumns & fixed_columns,
+    const ActionsDAGPtr & dag,
+    const SortDescription & description,
+    size_t limit)
+{
+    const auto & tables = merge->getSelectedTables();
+
+    InputOrderInfoPtr order_info;
+    for (const auto & table : tables)
+    {
+        auto storage = std::get<StoragePtr>(table);
+        const auto & sorting_key = storage->getInMemoryMetadataPtr()->getSortingKey();
+        const auto & sorting_key_columns = sorting_key.column_names;
+
+        if (sorting_key_columns.empty())
+            return nullptr;
+
+        auto table_order_info = buildInputOrderInfo(
+            fixed_columns,
+            dag, description,
+            sorting_key.expression->getActionsDAG(), sorting_key_columns,
+            limit);
+
+        if (!table_order_info)
+            return nullptr;
+
+        if (!order_info)
+            order_info = table_order_info;
+        else if (*order_info != *table_order_info)
+            return nullptr;
+    }
+
+    return order_info;
+}
+
+InputOrderInfoPtr buildInputOrderInfo(SortingStep & sorting, QueryPlan::Node & node)
+{
+    QueryPlan::Node * reading_node = findReadingStep(node);
+    if (!reading_node)
+        return nullptr;
+
+    const auto & description = sorting.getSortDescription();
+    size_t limit = sorting.getLimit();
+
+    ActionsDAGPtr dag;
+    FixedColumns fixed_columns;
+    buildSortingDAG(node, dag, fixed_columns, limit);
+
+    if (dag && !fixed_columns.empty())
+        enreachFixedColumns(*dag, fixed_columns);
+
+    if (auto * reading = typeid_cast<ReadFromMergeTree *>(reading_node->step.get()))
+    {
+
+        //std::cerr << "---- optimizeReadInOrder found mt" << std::endl;
+        auto order_info = buildInputOrderInfo(
+            reading,
+            fixed_columns,
+            dag, description,
+            limit);
+
+        if (order_info)
+            reading->requestReadingInOrder(order_info->used_prefix_of_sorting_key_size, order_info->direction, order_info->limit);
+
+        return order_info;
+    }
+    else if (auto * merge = typeid_cast<ReadFromMerge *>(reading_node->step.get()))
+    {
+        auto order_info = buildInputOrderInfo(
+            merge,
+            fixed_columns,
+            dag, description,
+            limit);
+
+        if (order_info)
+            merge->requestReadingInOrder(order_info);
+
+        return order_info;
+    }
+
+    return nullptr;
+}
+
+void optimizeReadInOrder(QueryPlan::Node & node, QueryPlan::Nodes & nodes)
+{
+    if (node.children.size() != 1)
+        return;
+
+    auto * sorting = typeid_cast<SortingStep *>(node.step.get());
+    if (!sorting)
+        return;
+
+    //std::cerr << "---- optimizeReadInOrder found sorting" << std::endl;
+
+    if (sorting->getType() != SortingStep::Type::Full)
+        return;
+
+    if (typeid_cast<UnionStep *>(node.children.front()->step.get()))
+    {
+        auto & union_node = node.children.front();
+
+        std::vector<InputOrderInfoPtr> infos;
+        const SortDescription * max_sort_descr = nullptr;
+        infos.reserve(node.children.size());
+        for (auto * child : union_node->children)
+        {
+            infos.push_back(buildInputOrderInfo(*sorting, *child));
+
+            if (infos.back() && (!max_sort_descr || max_sort_descr->size() < infos.back()->sort_description_for_merging.size()))
+                max_sort_descr = &infos.back()->sort_description_for_merging;
+        }
+
+        if (!max_sort_descr || max_sort_descr->empty())
+            return;
+
+        for (size_t i = 0; i < infos.size(); ++i)
+        {
+            const auto & info = infos[i];
+            auto & child = union_node->children[i];
+
+            QueryPlanStepPtr additional_sorting;
+
+            if (!info)
+            {
+                auto limit = sorting->getLimit();
+                /// If we have limit, it's better to sort up to full description and apply limit.
+                /// We cannot sort up to partial read-in-order description with limit cause result set can be wrong.
+                const auto & descr = limit ? sorting->getSortDescription() : *max_sort_descr;
+                additional_sorting = std::make_unique<SortingStep>(
+                    child->step->getOutputStream(),
+                    descr,
+                    limit, /// TODO: support limit with ties
+                    sorting->getSettings(),
+                    false);
+            }
+            else if (info->sort_description_for_merging.size() < max_sort_descr->size())
+            {
+                additional_sorting = std::make_unique<SortingStep>(
+                    child->step->getOutputStream(),
+                    info->sort_description_for_merging,
+                    *max_sort_descr,
+                    sorting->getSettings().max_block_size,
+                    0); /// TODO: support limit with ties
+            }
+
+            if (additional_sorting)
+            {
+                auto & sort_node = nodes.emplace_back();
+                sort_node.step = std::move(additional_sorting);
+                sort_node.children.push_back(child);
+                child = &sort_node;
+            }
+        }
+
+        sorting->convertToFinishSorting(*max_sort_descr);
+    }
+    else if (auto order_info = buildInputOrderInfo(*sorting, *node.children.front()))
+    {
+        sorting->convertToFinishSorting(order_info->sort_description_for_merging);
+    }
+}
+
+/// This optimisation is obsolete and will be removed.
+/// optimizeReadInOrder covers it.
+size_t tryReuseStorageOrderingForWindowFunctions(QueryPlan::Node * parent_node, QueryPlan::Nodes & /*nodes*/)
+{
+    /// Find the following sequence of steps, add InputOrderInfo and apply prefix sort description to
+    /// SortingStep:
+    /// WindowStep <- SortingStep <- [Expression] <- ReadFromMergeTree
+
+    auto * window_node = parent_node;
+    auto * window = typeid_cast<WindowStep *>(window_node->step.get());
+    if (!window)
+        return 0;
+    if (window_node->children.size() != 1)
+        return 0;
+
+    auto * sorting_node = window_node->children.front();
+    auto * sorting = typeid_cast<SortingStep *>(sorting_node->step.get());
+    if (!sorting)
+        return 0;
+    if (sorting_node->children.size() != 1)
+        return 0;
+
+    auto * possible_read_from_merge_tree_node = sorting_node->children.front();
+
+    if (typeid_cast<ExpressionStep *>(possible_read_from_merge_tree_node->step.get()))
+    {
+        if (possible_read_from_merge_tree_node->children.size() != 1)
+            return 0;
+
+        possible_read_from_merge_tree_node = possible_read_from_merge_tree_node->children.front();
+    }
+
+    auto * read_from_merge_tree = typeid_cast<ReadFromMergeTree *>(possible_read_from_merge_tree_node->step.get());
+    if (!read_from_merge_tree)
+    {
+        return 0;
+    }
+
+    auto context = read_from_merge_tree->getContext();
+    const auto & settings = context->getSettings();
+    if (!settings.optimize_read_in_window_order || (settings.optimize_read_in_order && settings.query_plan_read_in_order) || context->getSettingsRef().allow_experimental_analyzer)
+    {
+        return 0;
+    }
+
+    const auto & query_info = read_from_merge_tree->getQueryInfo();
+    const auto * select_query = query_info.query->as<ASTSelectQuery>();
+
+    /// TODO: Analyzer syntax analyzer result
+    if (!query_info.syntax_analyzer_result)
+        return 0;
+
+    ManyExpressionActions order_by_elements_actions;
+    const auto & window_desc = window->getWindowDescription();
+
+    for (const auto & actions_dag : window_desc.partition_by_actions)
+    {
+        order_by_elements_actions.emplace_back(
+            std::make_shared<ExpressionActions>(actions_dag, ExpressionActionsSettings::fromContext(context, CompileExpressions::yes)));
+    }
+
+    for (const auto & actions_dag : window_desc.order_by_actions)
+    {
+        order_by_elements_actions.emplace_back(
+            std::make_shared<ExpressionActions>(actions_dag, ExpressionActionsSettings::fromContext(context, CompileExpressions::yes)));
+    }
+
+    auto order_optimizer = std::make_shared<ReadInOrderOptimizer>(
+            *select_query,
+            order_by_elements_actions,
+            window->getWindowDescription().full_sort_description,
+            query_info.syntax_analyzer_result);
+
+    /// If we don't have filtration, we can pushdown limit to reading stage for optimizations.
+    UInt64 limit = (select_query->hasFiltration() || select_query->groupBy()) ? 0 : InterpreterSelectQuery::getLimitForSorting(*select_query, context);
+
+    auto order_info = order_optimizer->getInputOrder(
+            query_info.projection ? query_info.projection->desc->metadata : read_from_merge_tree->getStorageMetadata(),
+            context,
+            limit);
+
+    if (order_info)
+    {
+        read_from_merge_tree->requestReadingInOrder(order_info->used_prefix_of_sorting_key_size, order_info->direction, order_info->limit);
+        sorting->convertToFinishSorting(order_info->sort_description_for_merging);
+    }
+
+    return 0;
+}
+
+}
diff --git a/src/Processors/QueryPlan/Optimizations/optimizeTree.cpp b/src/Processors/QueryPlan/Optimizations/optimizeTree.cpp
index ff30cfd8cf34..f514e145a92f 100644
--- a/src/Processors/QueryPlan/Optimizations/optimizeTree.cpp
+++ b/src/Processors/QueryPlan/Optimizations/optimizeTree.cpp
@@ -14,7 +14,7 @@ namespace ErrorCodes
 namespace QueryPlanOptimizations
 {
 
-void optimizeTree(const QueryPlanOptimizationSettings & settings, QueryPlan::Node & root, QueryPlan::Nodes & nodes)
+void optimizeTreeFirstPass(const QueryPlanOptimizationSettings & settings, QueryPlan::Node & root, QueryPlan::Nodes & nodes)
 {
     if (!settings.optimize_plan)
         return;
@@ -98,5 +98,38 @@ void optimizeTree(const QueryPlanOptimizationSettings & settings, QueryPlan::Nod
     }
 }
 
+void optimizeTreeSecondPass(const QueryPlanOptimizationSettings & optimization_settings, QueryPlan::Node & root, QueryPlan::Nodes & nodes)
+{
+    Stack stack;
+    stack.push_back({.node = &root});
+
+    while (!stack.empty())
+    {
+        auto & frame = stack.back();
+
+        if (frame.next_child == 0)
+        {
+            if (optimization_settings.read_in_order)
+                optimizeReadInOrder(*frame.node, nodes);
+
+            if (optimization_settings.distinct_in_order)
+                tryDistinctReadInOrder(frame.node);
+        }
+
+        /// Traverse all children first.
+        if (frame.next_child < frame.node->children.size())
+        {
+            auto next_frame = Frame{.node = frame.node->children[frame.next_child]};
+            ++frame.next_child;
+            stack.push_back(next_frame);
+            continue;
+        }
+
+        optimizePrimaryKeyCondition(stack);
+
+        stack.pop_back();
+    }
+}
+
 }
 }
diff --git a/src/Processors/QueryPlan/Optimizations/reuseStorageOrderingForWindowFunctions.cpp b/src/Processors/QueryPlan/Optimizations/reuseStorageOrderingForWindowFunctions.cpp
deleted file mode 100644
index c74b5ed915b5..000000000000
--- a/src/Processors/QueryPlan/Optimizations/reuseStorageOrderingForWindowFunctions.cpp
+++ /dev/null
@@ -1,115 +0,0 @@
-#include <Parsers/ASTWindowDefinition.h>
-#include <Processors/QueryPlan/Optimizations/Optimizations.h>
-#include <Processors/QueryPlan/ITransformingStep.h>
-#include <Processors/QueryPlan/AggregatingStep.h>
-#include <Processors/QueryPlan/ExpressionStep.h>
-#include <Processors/QueryPlan/JoinStep.h>
-#include <Processors/QueryPlan/ArrayJoinStep.h>
-#include <Processors/QueryPlan/CreatingSetsStep.h>
-#include <Processors/QueryPlan/CubeStep.h>
-#include <Processors/QueryPlan/ReadFromMergeTree.h>
-#include <Processors/QueryPlan/SortingStep.h>
-#include <Processors/QueryPlan/TotalsHavingStep.h>
-#include <Processors/QueryPlan/DistinctStep.h>
-#include <Processors/QueryPlan/UnionStep.h>
-#include <Processors/QueryPlan/WindowStep.h>
-#include <Interpreters/ActionsDAG.h>
-#include <Interpreters/ArrayJoinAction.h>
-#include <Interpreters/InterpreterSelectQuery.h>
-#include <Interpreters/TableJoin.h>
-#include <Common/typeid_cast.h>
-#include <DataTypes/DataTypeAggregateFunction.h>
-#include <Columns/IColumn.h>
-
-
-namespace DB::QueryPlanOptimizations
-{
-
-size_t tryReuseStorageOrderingForWindowFunctions(QueryPlan::Node * parent_node, QueryPlan::Nodes & /*nodes*/)
-{
-    /// Find the following sequence of steps, add InputOrderInfo and apply prefix sort description to
-    /// SortingStep:
-    /// WindowStep <- SortingStep <- [Expression] <- ReadFromMergeTree
-
-    auto * window_node = parent_node;
-    auto * window = typeid_cast<WindowStep *>(window_node->step.get());
-    if (!window)
-        return 0;
-    if (window_node->children.size() != 1)
-        return 0;
-
-    auto * sorting_node = window_node->children.front();
-    auto * sorting = typeid_cast<SortingStep *>(sorting_node->step.get());
-    if (!sorting)
-        return 0;
-    if (sorting_node->children.size() != 1)
-        return 0;
-
-    auto * possible_read_from_merge_tree_node = sorting_node->children.front();
-
-    if (typeid_cast<ExpressionStep *>(possible_read_from_merge_tree_node->step.get()))
-    {
-        if (possible_read_from_merge_tree_node->children.size() != 1)
-            return 0;
-
-        possible_read_from_merge_tree_node = possible_read_from_merge_tree_node->children.front();
-    }
-
-    auto * read_from_merge_tree = typeid_cast<ReadFromMergeTree *>(possible_read_from_merge_tree_node->step.get());
-    if (!read_from_merge_tree)
-    {
-        return 0;
-    }
-
-    auto context = read_from_merge_tree->getContext();
-    if (!context->getSettings().optimize_read_in_window_order || context->getSettingsRef().allow_experimental_analyzer)
-    {
-        return 0;
-    }
-
-    const auto & query_info = read_from_merge_tree->getQueryInfo();
-    const auto * select_query = query_info.query->as<ASTSelectQuery>();
-
-    /// TODO: Analyzer syntax analyzer result
-    if (!query_info.syntax_analyzer_result)
-        return 0;
-
-    ManyExpressionActions order_by_elements_actions;
-    const auto & window_desc = window->getWindowDescription();
-
-    for (const auto & actions_dag : window_desc.partition_by_actions)
-    {
-        order_by_elements_actions.emplace_back(
-            std::make_shared<ExpressionActions>(actions_dag, ExpressionActionsSettings::fromContext(context, CompileExpressions::yes)));
-    }
-
-    for (const auto & actions_dag : window_desc.order_by_actions)
-    {
-        order_by_elements_actions.emplace_back(
-            std::make_shared<ExpressionActions>(actions_dag, ExpressionActionsSettings::fromContext(context, CompileExpressions::yes)));
-    }
-
-    auto order_optimizer = std::make_shared<ReadInOrderOptimizer>(
-            *select_query,
-            order_by_elements_actions,
-            window->getWindowDescription().full_sort_description,
-            query_info.syntax_analyzer_result);
-
-    /// If we don't have filtration, we can pushdown limit to reading stage for optimizations.
-    UInt64 limit = (select_query->hasFiltration() || select_query->groupBy()) ? 0 : InterpreterSelectQuery::getLimitForSorting(*select_query, context);
-
-    auto order_info = order_optimizer->getInputOrder(
-            query_info.projection ? query_info.projection->desc->metadata : read_from_merge_tree->getStorageMetadata(),
-            context,
-            limit);
-
-    if (order_info)
-    {
-        read_from_merge_tree->requestReadingInOrder(order_info->used_prefix_of_sorting_key_size, order_info->direction, order_info->limit);
-        sorting->convertToFinishSorting(order_info->sort_description_for_merging);
-    }
-
-    return 0;
-}
-
-}
diff --git a/src/Processors/QueryPlan/QueryPlan.cpp b/src/Processors/QueryPlan/QueryPlan.cpp
index 5a92bcb41ee6..e1662d430158 100644
--- a/src/Processors/QueryPlan/QueryPlan.cpp
+++ b/src/Processors/QueryPlan/QueryPlan.cpp
@@ -447,8 +447,8 @@ void QueryPlan::explainPipeline(WriteBuffer & buffer, const ExplainPipelineOptio
 
 void QueryPlan::optimize(const QueryPlanOptimizationSettings & optimization_settings)
 {
-    QueryPlanOptimizations::optimizeTree(optimization_settings, *root, nodes);
-    QueryPlanOptimizations::optimizePrimaryKeyCondition(*root);
+    QueryPlanOptimizations::optimizeTreeFirstPass(optimization_settings, *root, nodes);
+    QueryPlanOptimizations::optimizeTreeSecondPass(optimization_settings, *root, nodes);
 }
 
 void QueryPlan::explainEstimate(MutableColumns & columns)
diff --git a/src/Processors/QueryPlan/ReadFromMergeTree.cpp b/src/Processors/QueryPlan/ReadFromMergeTree.cpp
index b268e7deff02..59f3e094cb75 100644
--- a/src/Processors/QueryPlan/ReadFromMergeTree.cpp
+++ b/src/Processors/QueryPlan/ReadFromMergeTree.cpp
@@ -67,7 +67,7 @@ static MergeTreeReaderSettings getMergeTreeReaderSettings(
     };
 }
 
-static const PrewhereInfoPtr & getPrewhereInfo(const SelectQueryInfo & query_info)
+static const PrewhereInfoPtr & getPrewhereInfoFromQueryInfo(const SelectQueryInfo & query_info)
 {
     return query_info.projection ? query_info.projection->prewhere_info
                                  : query_info.prewhere_info;
@@ -90,7 +90,7 @@ ReadFromMergeTree::ReadFromMergeTree(
     bool enable_parallel_reading)
     : ISourceStep(DataStream{.header = MergeTreeBaseSelectProcessor::transformHeader(
         storage_snapshot_->getSampleBlockForColumns(real_column_names_),
-        getPrewhereInfo(query_info_),
+        getPrewhereInfoFromQueryInfo(query_info_),
         data_.getPartitionValueType(),
         virt_column_names_)})
     , reader_settings(getMergeTreeReaderSettings(context_, query_info_))
@@ -99,7 +99,7 @@ ReadFromMergeTree::ReadFromMergeTree(
     , virt_column_names(std::move(virt_column_names_))
     , data(data_)
     , query_info(query_info_)
-    , prewhere_info(getPrewhereInfo(query_info))
+    , prewhere_info(getPrewhereInfoFromQueryInfo(query_info))
     , actions_settings(ExpressionActionsSettings::fromContext(context_))
     , storage_snapshot(std::move(storage_snapshot_))
     , metadata_for_reading(storage_snapshot->getMetadataForQuery())
@@ -441,6 +441,25 @@ Pipe ReadFromMergeTree::spreadMarkRangesAmongStreamsWithOrder(
     if (info.sum_marks == 0)
         return {};
 
+    /// PREWHERE actions can remove some input columns (which are needed only for prewhere condition).
+    /// In case of read-in-order, PREWHERE is executed before sorting. But removed columns could be needed for sorting key.
+    /// To fix this, we prohibit removing any input in prewhere actions. Instead, projection actions will be added after sorting.
+    /// See 02354_read_in_order_prewhere.sql as an example.
+    bool have_input_columns_removed_after_prewhere = false;
+    if (prewhere_info && prewhere_info->prewhere_actions)
+    {
+        auto & outputs = prewhere_info->prewhere_actions->getOutputs();
+        std::unordered_set<const ActionsDAG::Node *> outputs_set(outputs.begin(), outputs.end());
+        for (const auto * input :  prewhere_info->prewhere_actions->getInputs())
+        {
+            if (!outputs_set.contains(input))
+            {
+                outputs.push_back(input);
+                have_input_columns_removed_after_prewhere = true;
+            }
+        }
+    }
+
     /// Let's split ranges to avoid reading much data.
     auto split_ranges = [rows_granularity = data_settings->index_granularity, max_block_size = max_block_size]
         (const auto & ranges, int direction)
@@ -567,6 +586,10 @@ Pipe ReadFromMergeTree::spreadMarkRangesAmongStreamsWithOrder(
                                         info.use_uncompressed_cache, input_order_info->limit));
     }
 
+    Block pipe_header;
+    if (!pipes.empty())
+        pipe_header = pipes.front().getHeader();
+
     if (need_preliminary_merge)
     {
         size_t prefix_size = input_order_info->used_prefix_of_sorting_key_size;
@@ -588,9 +611,6 @@ Pipe ReadFromMergeTree::spreadMarkRangesAmongStreamsWithOrder(
 
         for (auto & pipe : pipes)
         {
-            /// Drop temporary columns, added by 'sorting_key_prefix_expr'
-            out_projection = createProjection(pipe.getHeader());
-
             pipe.addSimpleTransform([sorting_key_expr](const Block & header)
             {
                 return std::make_shared<ExpressionTransform>(header, sorting_key_expr);
@@ -610,6 +630,10 @@ Pipe ReadFromMergeTree::spreadMarkRangesAmongStreamsWithOrder(
         }
     }
 
+    if (!pipes.empty() && (need_preliminary_merge || have_input_columns_removed_after_prewhere))
+        /// Drop temporary columns, added by 'sorting_key_prefix_expr'
+        out_projection = createProjection(pipe_header);
+
     return Pipe::unitePipes(std::move(pipes));
 }
 
@@ -1062,6 +1086,8 @@ void ReadFromMergeTree::requestReadingInOrder(size_t prefix_size, int direction,
     else
         query_info.input_order_info = order_info;
 
+    reader_settings.read_in_order = true;
+
     /// update sort info for output stream
     SortDescription sort_description;
     const Names & sorting_key_columns = storage_snapshot->getMetadataForQuery()->getSortingKeyColumns();
@@ -1074,14 +1100,14 @@ void ReadFromMergeTree::requestReadingInOrder(size_t prefix_size, int direction,
             break;
         sort_description.emplace_back(column_name, sort_direction);
     }
-    if (sort_description.empty())
-        throw Exception(ErrorCodes::LOGICAL_ERROR, "Sort description can't be empty when reading in order");
-
-    const size_t used_prefix_of_sorting_key_size = order_info->used_prefix_of_sorting_key_size;
-    if (sort_description.size() > used_prefix_of_sorting_key_size)
-        sort_description.resize(used_prefix_of_sorting_key_size);
-    output_stream->sort_description = std::move(sort_description);
-    output_stream->sort_scope = DataStream::SortScope::Stream;
+    if (!sort_description.empty())
+    {
+        const size_t used_prefix_of_sorting_key_size = order_info->used_prefix_of_sorting_key_size;
+        if (sort_description.size() > used_prefix_of_sorting_key_size)
+            sort_description.resize(used_prefix_of_sorting_key_size);
+        output_stream->sort_description = std::move(sort_description);
+        output_stream->sort_scope = DataStream::SortScope::Stream;
+    }
 }
 
 ReadFromMergeTree::AnalysisResult ReadFromMergeTree::getAnalysisResult() const
diff --git a/src/Processors/QueryPlan/ReadFromMergeTree.h b/src/Processors/QueryPlan/ReadFromMergeTree.h
index 15258eb6c407..808e849fe037 100644
--- a/src/Processors/QueryPlan/ReadFromMergeTree.h
+++ b/src/Processors/QueryPlan/ReadFromMergeTree.h
@@ -150,6 +150,7 @@ class ReadFromMergeTree final : public ISourceStep
     ContextPtr getContext() const { return context; }
     const SelectQueryInfo & getQueryInfo() const { return query_info; }
     StorageMetadataPtr getStorageMetadata() const { return metadata_for_reading; }
+    const PrewhereInfo * getPrewhereInfo() const { return prewhere_info.get(); }
 
     void requestReadingInOrder(size_t prefix_size, int direction, size_t limit);
 
@@ -163,7 +164,7 @@ class ReadFromMergeTree final : public ISourceStep
         return 1;
     }
 
-    const MergeTreeReaderSettings reader_settings;
+    MergeTreeReaderSettings reader_settings;
 
     MergeTreeData::DataPartsVector prepared_parts;
     Names real_column_names;
diff --git a/src/Processors/QueryPlan/SortingStep.cpp b/src/Processors/QueryPlan/SortingStep.cpp
index bb58eff2f13a..8766c0ba3356 100644
--- a/src/Processors/QueryPlan/SortingStep.cpp
+++ b/src/Processors/QueryPlan/SortingStep.cpp
@@ -23,6 +23,23 @@ namespace ErrorCodes
     extern const int LOGICAL_ERROR;
 }
 
+SortingStep::Settings::Settings(const Context & context)
+{
+    const auto & settings = context.getSettingsRef();
+    max_block_size = settings.max_block_size;
+    size_limits = SizeLimits(settings.max_rows_to_sort, settings.max_bytes_to_sort, settings.sort_overflow_mode);
+    max_bytes_before_remerge = settings.max_bytes_before_remerge_sort;
+    remerge_lowered_memory_bytes_ratio = settings.remerge_sort_lowered_memory_bytes_ratio;
+    max_bytes_before_external_sort = settings.max_bytes_before_external_sort;
+    tmp_data = context.getTempDataOnDisk();
+    min_free_disk_space = settings.min_free_disk_space_for_temporary_data;
+}
+
+SortingStep::Settings::Settings(size_t max_block_size_)
+{
+    max_block_size = max_block_size_;
+}
+
 static ITransformingStep::Traits getTraits(size_t limit)
 {
     return ITransformingStep::Traits
@@ -42,29 +59,17 @@ static ITransformingStep::Traits getTraits(size_t limit)
 SortingStep::SortingStep(
     const DataStream & input_stream,
     SortDescription description_,
-    size_t max_block_size_,
     UInt64 limit_,
-    SizeLimits size_limits_,
-    size_t max_bytes_before_remerge_,
-    double remerge_lowered_memory_bytes_ratio_,
-    size_t max_bytes_before_external_sort_,
-    TemporaryDataOnDiskScopePtr tmp_data_,
-    size_t min_free_disk_space_,
+    const Settings & settings_,
     bool optimize_sorting_by_input_stream_properties_)
     : ITransformingStep(input_stream, input_stream.header, getTraits(limit_))
     , type(Type::Full)
     , result_description(std::move(description_))
-    , max_block_size(max_block_size_)
     , limit(limit_)
-    , size_limits(size_limits_)
-    , max_bytes_before_remerge(max_bytes_before_remerge_)
-    , remerge_lowered_memory_bytes_ratio(remerge_lowered_memory_bytes_ratio_)
-    , max_bytes_before_external_sort(max_bytes_before_external_sort_)
-    , tmp_data(tmp_data_)
-    , min_free_disk_space(min_free_disk_space_)
+    , sort_settings(settings_)
     , optimize_sorting_by_input_stream_properties(optimize_sorting_by_input_stream_properties_)
 {
-    if (max_bytes_before_external_sort && tmp_data == nullptr)
+    if (sort_settings.max_bytes_before_external_sort && sort_settings.tmp_data == nullptr)
         throw Exception("Temporary data storage for external sorting is not provided", ErrorCodes::LOGICAL_ERROR);
 
     /// TODO: check input_stream is partially sorted by the same description.
@@ -82,8 +87,8 @@ SortingStep::SortingStep(
     , type(Type::FinishSorting)
     , prefix_description(std::move(prefix_description_))
     , result_description(std::move(result_description_))
-    , max_block_size(max_block_size_)
     , limit(limit_)
+    , sort_settings(max_block_size_)
 {
     /// TODO: check input_stream is sorted by prefix_description.
     output_stream->sort_description = result_description;
@@ -98,9 +103,10 @@ SortingStep::SortingStep(
     : ITransformingStep(input_stream, input_stream.header, getTraits(limit_))
     , type(Type::MergingSorted)
     , result_description(std::move(sort_description_))
-    , max_block_size(max_block_size_)
     , limit(limit_)
+    , sort_settings(max_block_size_)
 {
+    sort_settings.max_block_size = max_block_size_;
     /// TODO: check input_stream is partially sorted (each port) by the same description.
     output_stream->sort_description = result_description;
     output_stream->sort_scope = DataStream::SortScope::Global;
@@ -155,7 +161,7 @@ void SortingStep::finishSorting(
                 increase_sort_description_compile_attempts = false;
 
             return std::make_shared<FinishSortingTransform>(
-                header, input_sort_desc, result_sort_desc, max_block_size, limit_, increase_sort_description_compile_attempts_current);
+                header, input_sort_desc, result_sort_desc, sort_settings.max_block_size, limit_, increase_sort_description_compile_attempts_current);
         });
 }
 
@@ -168,7 +174,7 @@ void SortingStep::mergingSorted(QueryPipelineBuilder & pipeline, const SortDescr
             pipeline.getHeader(),
             pipeline.getNumStreams(),
             result_sort_desc,
-            max_block_size,
+            sort_settings.max_block_size,
             SortingQueueStrategy::Batch,
             limit_);
 
@@ -197,14 +203,14 @@ void SortingStep::mergeSorting(QueryPipelineBuilder & pipeline, const SortDescri
             return std::make_shared<MergeSortingTransform>(
                 header,
                 result_sort_desc,
-                max_block_size,
+                sort_settings.max_block_size,
                 limit_,
                 increase_sort_description_compile_attempts_current,
-                max_bytes_before_remerge / pipeline.getNumStreams(),
-                remerge_lowered_memory_bytes_ratio,
-                max_bytes_before_external_sort,
-                std::make_unique<TemporaryDataOnDisk>(tmp_data, CurrentMetrics::TemporaryFilesForSort),
-                min_free_disk_space);
+                sort_settings.max_bytes_before_remerge / pipeline.getNumStreams(),
+                sort_settings.remerge_lowered_memory_bytes_ratio,
+                sort_settings.max_bytes_before_external_sort,
+                std::make_unique<TemporaryDataOnDisk>(sort_settings.tmp_data, CurrentMetrics::TemporaryFilesForSort),
+                sort_settings.min_free_disk_space);
         });
 }
 
@@ -223,7 +229,7 @@ void SortingStep::fullSort(QueryPipelineBuilder & pipeline, const SortDescriptio
 
         StreamLocalLimits limits;
         limits.mode = LimitsMode::LIMITS_CURRENT; //-V1048
-        limits.size_limits = size_limits;
+        limits.size_limits = sort_settings.size_limits;
 
         pipeline.addSimpleTransform(
             [&](const Block & header, QueryPipelineBuilder::StreamType stream_type) -> ProcessorPtr
@@ -241,7 +247,7 @@ void SortingStep::fullSort(QueryPipelineBuilder & pipeline, const SortDescriptio
     if (pipeline.getNumStreams() > 1)
     {
         auto transform = std::make_shared<MergingSortedTransform>(
-            pipeline.getHeader(), pipeline.getNumStreams(), result_sort_desc, max_block_size, SortingQueueStrategy::Batch, limit_);
+            pipeline.getHeader(), pipeline.getNumStreams(), result_sort_desc, sort_settings.max_block_size, SortingQueueStrategy::Batch, limit_);
 
         pipeline.addTransform(std::move(transform));
     }
diff --git a/src/Processors/QueryPlan/SortingStep.h b/src/Processors/QueryPlan/SortingStep.h
index d8d86b8cf1da..c8b890dac902 100644
--- a/src/Processors/QueryPlan/SortingStep.h
+++ b/src/Processors/QueryPlan/SortingStep.h
@@ -11,18 +11,33 @@ namespace DB
 class SortingStep : public ITransformingStep
 {
 public:
+    enum class Type
+    {
+        Full,
+        FinishSorting,
+        MergingSorted,
+    };
+
+    struct Settings
+    {
+        size_t max_block_size;
+        SizeLimits size_limits;
+        size_t max_bytes_before_remerge = 0;
+        double remerge_lowered_memory_bytes_ratio = 0;
+        size_t max_bytes_before_external_sort = 0;
+        TemporaryDataOnDiskScopePtr tmp_data = nullptr;
+        size_t min_free_disk_space = 0;
+
+        explicit Settings(const Context & context);
+        explicit Settings(size_t max_block_size_);
+    };
+
     /// Full
     SortingStep(
         const DataStream & input_stream,
         SortDescription description_,
-        size_t max_block_size_,
         UInt64 limit_,
-        SizeLimits size_limits_,
-        size_t max_bytes_before_remerge_,
-        double remerge_lowered_memory_bytes_ratio_,
-        size_t max_bytes_before_external_sort_,
-        TemporaryDataOnDiskScopePtr tmp_data_,
-        size_t min_free_disk_space_,
+        const Settings & settings_,
         bool optimize_sorting_by_input_stream_properties_);
 
     /// FinishSorting
@@ -47,6 +62,7 @@ class SortingStep : public ITransformingStep
     void describeActions(JSONBuilder::JSONMap & map) const override;
     void describeActions(FormatSettings & settings) const override;
 
+    UInt64 getLimit() const { return limit; }
     /// Add limit or change it to lower value.
     void updateLimit(size_t limit_);
 
@@ -54,6 +70,9 @@ class SortingStep : public ITransformingStep
 
     void convertToFinishSorting(SortDescription prefix_description);
 
+    Type getType() const { return type; }
+    const Settings & getSettings() const { return sort_settings; }
+
 private:
     void updateOutputStream() override;
 
@@ -67,27 +86,14 @@ class SortingStep : public ITransformingStep
         UInt64 limit_,
         bool skip_partial_sort = false);
 
-    enum class Type
-    {
-        Full,
-        FinishSorting,
-        MergingSorted,
-    };
-
     Type type;
 
     SortDescription prefix_description;
     const SortDescription result_description;
-    const size_t max_block_size;
     UInt64 limit;
-    SizeLimits size_limits;
 
-    size_t max_bytes_before_remerge = 0;
-    double remerge_lowered_memory_bytes_ratio = 0;
-    size_t max_bytes_before_external_sort = 0;
-    TemporaryDataOnDiskScopePtr tmp_data = nullptr;
+    Settings sort_settings;
 
-    size_t min_free_disk_space = 0;
     const bool optimize_sorting_by_input_stream_properties = false;
 };
 
diff --git a/src/Storages/StorageMerge.cpp b/src/Storages/StorageMerge.cpp
index 7fb21b7e0536..3c4fa3674d28 100644
--- a/src/Storages/StorageMerge.cpp
+++ b/src/Storages/StorageMerge.cpp
@@ -364,9 +364,13 @@ void ReadFromMerge::initializePipeline(QueryPipelineBuilder & pipeline, const Bu
     size_t num_streams = static_cast<size_t>(requested_num_streams * num_streams_multiplier);
     size_t remaining_streams = num_streams;
 
-    InputOrderInfoPtr input_sorting_info;
-    if (query_info.order_optimizer)
+    if (order_info)
+    {
+         query_info.input_order_info = order_info;
+    }
+    else if (query_info.order_optimizer)
     {
+        InputOrderInfoPtr input_sorting_info;
         for (auto it = selected_tables.begin(); it != selected_tables.end(); ++it)
         {
             auto storage_ptr = std::get<1>(*it);
diff --git a/src/Storages/StorageMerge.h b/src/Storages/StorageMerge.h
index 334063211001..54f3999514d0 100644
--- a/src/Storages/StorageMerge.h
+++ b/src/Storages/StorageMerge.h
@@ -144,6 +144,10 @@ class ReadFromMerge final : public ISourceStep
         added_filter_nodes.nodes.push_back(&expression->findInOutputs(column_name));
     }
 
+    const StorageListWithLocks & getSelectedTables() const { return selected_tables; }
+
+    void requestReadingInOrder(InputOrderInfoPtr order_info_) { order_info = order_info_; }
+
 private:
     const size_t required_max_block_size;
     const size_t requested_num_streams;
@@ -165,6 +169,8 @@ class ReadFromMerge final : public ISourceStep
 
     std::string added_filter_column_name;
 
+    InputOrderInfoPtr order_info;
+
     struct AliasData
     {
         String name;
