diff --git a/dbms/src/Common/StringSearcher.h b/dbms/src/Common/StringSearcher.h
index 5e78ff23df19..25287db11f5d 100644
--- a/dbms/src/Common/StringSearcher.h
+++ b/dbms/src/Common/StringSearcher.h
@@ -1,5 +1,7 @@
 #pragma once
 
+#include <Common/Exception.h>
+#include <Common/StringUtils/StringUtils.h>
 #include <Common/UTF8Helpers.h>
 #include <Core/Defines.h>
 #include <ext/range.h>
@@ -23,6 +25,7 @@ namespace DB
 namespace ErrorCodes
 {
     extern const int UNSUPPORTED_PARAMETER;
+    extern const int BAD_ARGUMENTS;
 }
 
 
@@ -157,7 +160,7 @@ class StringSearcher<false, false> : private StringSearcherBase
 #endif
     }
 
-    ALWAYS_INLINE bool compare(const UInt8 * pos) const
+    ALWAYS_INLINE bool compare(const UInt8 * /*haystack*/, const UInt8 * /*haystack_end*/, const UInt8 * pos) const
     {
         static const Poco::UTF8Encoding utf8;
 
@@ -374,7 +377,7 @@ class StringSearcher<false, true> : private StringSearcherBase
 #endif
     }
 
-    ALWAYS_INLINE bool compare(const UInt8 * pos) const
+    ALWAYS_INLINE bool compare(const UInt8 * /*haystack*/, const UInt8 * /*haystack_end*/, const UInt8 * pos) const
     {
 #ifdef __SSE4_1__
         if (pageSafe(pos))
@@ -567,7 +570,7 @@ class StringSearcher<true, ASCII> : private StringSearcherBase
 #endif
     }
 
-    ALWAYS_INLINE bool compare(const UInt8 * pos) const
+    ALWAYS_INLINE bool compare(const UInt8 * /*haystack*/, const UInt8 * /*haystack_end*/, const UInt8 * pos) const
     {
 #ifdef __SSE4_1__
         if (pageSafe(pos))
@@ -697,11 +700,81 @@ class StringSearcher<true, ASCII> : private StringSearcherBase
     }
 };
 
+// Searches for needle surrounded by token-separators.
+// Separators are anything inside ASCII (0-128) and not alphanum.
+// Any value outside of basic ASCII (>=128) is considered a non-separator symbol, hence UTF-8 strings
+// should work just fine. But any Unicode whitespace is not considered a token separtor.
+template <typename StringSearcher>
+class TokenSearcher
+{
+    StringSearcher searcher;
+    size_t needle_size;
+
+public:
+    TokenSearcher(const char * const needle_, const size_t needle_size_)
+        : searcher{needle_, needle_size_},
+          needle_size(needle_size_)
+    {
+        if (std::any_of(reinterpret_cast<const UInt8 *>(needle_), reinterpret_cast<const UInt8 *>(needle_) + needle_size_, isTokenSeparator))
+        {
+            throw Exception{"Needle must not contain whitespace or separator characters", ErrorCodes::BAD_ARGUMENTS};
+        }
+
+    }
+
+    ALWAYS_INLINE bool compare(const UInt8 * haystack, const UInt8 * haystack_end, const UInt8 * pos) const
+    {
+        // use searcher only if pos is in the beginning of token and pos + searcher.needle_size is end of token.
+        if (isToken(haystack, haystack_end, pos))
+            return searcher.compare(haystack, haystack_end, pos);
+
+        return false;
+    }
+
+    const UInt8 * search(const UInt8 * haystack, const UInt8 * const haystack_end) const
+    {
+        // use searcher.search(), then verify that returned value is a token
+        // if it is not, skip it and re-run
+
+        const UInt8 * pos = haystack;
+        while (pos < haystack_end)
+        {
+            pos = searcher.search(pos, haystack_end);
+            if (pos == haystack_end || isToken(haystack, haystack_end, pos))
+                return pos;
+
+            // assuming that heendle does not contain any token separators.
+            pos += needle_size;
+        }
+        return haystack_end;
+    }
+
+    const UInt8 * search(const UInt8 * haystack, const size_t haystack_size) const
+    {
+        return search(haystack, haystack + haystack_size);
+    }
+
+    ALWAYS_INLINE bool isToken(const UInt8 * haystack, const UInt8 * const haystack_end, const UInt8* p) const
+    {
+        return (p == haystack || isTokenSeparator(*(p - 1)))
+             && (p + needle_size >= haystack_end || isTokenSeparator(*(p + needle_size)));
+    }
+
+    ALWAYS_INLINE static bool isTokenSeparator(const UInt8 c)
+    {
+        if (isAlphaNumericASCII(c) || !isASCII(c))
+            return false;
+
+        return true;
+    }
+};
+
 
 using ASCIICaseSensitiveStringSearcher = StringSearcher<true, true>;
 using ASCIICaseInsensitiveStringSearcher = StringSearcher<false, true>;
 using UTF8CaseSensitiveStringSearcher = StringSearcher<true, false>;
 using UTF8CaseInsensitiveStringSearcher = StringSearcher<false, false>;
+using ASCIICaseSensitiveTokenSearcher = TokenSearcher<ASCIICaseSensitiveStringSearcher>;
 
 
 /** Uses functions from libc.
diff --git a/dbms/src/Common/Volnitsky.h b/dbms/src/Common/Volnitsky.h
index 748cbe091386..c87bdd79dab2 100644
--- a/dbms/src/Common/Volnitsky.h
+++ b/dbms/src/Common/Volnitsky.h
@@ -327,6 +327,8 @@ class VolnitskyBase
     FallbackSearcher fallback_searcher;
 
 public:
+    using Searcher = FallbackSearcher;
+
     /** haystack_size_hint - the expected total size of the haystack for `search` calls. Optional (zero means unspecified).
       * If you specify it small enough, the fallback algorithm will be used,
       *  since it is considered that it's useless to waste time initializing the hash table.
@@ -373,7 +375,7 @@ class VolnitskyBase
                 const auto res = pos - (hash[cell_num] - 1);
 
                 /// pointer in the code is always padded array so we can use pagesafe semantics
-                if (fallback_searcher.compare(res))
+                if (fallback_searcher.compare(haystack, haystack_end, res))
                     return res;
             }
         }
@@ -520,7 +522,7 @@ class MultiVolnitskyBase
                     {
                         const auto res = pos - (hash[cell_num].off - 1);
                         const size_t ind = hash[cell_num].id;
-                        if (res + needles[ind].size <= haystack_end && fallback_searchers[ind].compare(res))
+                        if (res + needles[ind].size <= haystack_end && fallback_searchers[ind].compare(haystack, haystack_end, res))
                             return true;
                     }
                 }
@@ -552,7 +554,7 @@ class MultiVolnitskyBase
                     {
                         const auto res = pos - (hash[cell_num].off - 1);
                         const size_t ind = hash[cell_num].id;
-                        if (res + needles[ind].size <= haystack_end && fallback_searchers[ind].compare(res))
+                        if (res + needles[ind].size <= haystack_end && fallback_searchers[ind].compare(haystack, haystack_end, res))
                             ans = std::min(ans, ind);
                     }
                 }
@@ -590,7 +592,7 @@ class MultiVolnitskyBase
                     {
                         const auto res = pos - (hash[cell_num].off - 1);
                         const size_t ind = hash[cell_num].id;
-                        if (res + needles[ind].size <= haystack_end && fallback_searchers[ind].compare(res))
+                        if (res + needles[ind].size <= haystack_end && fallback_searchers[ind].compare(haystack, haystack_end, res))
                             ans = std::min<UInt64>(ans, res - haystack);
                     }
                 }
@@ -625,7 +627,7 @@ class MultiVolnitskyBase
                     {
                         const auto * res = pos - (hash[cell_num].off - 1);
                         const size_t ind = hash[cell_num].id;
-                        if (ans[ind] == 0 && res + needles[ind].size <= haystack_end && fallback_searchers[ind].compare(res))
+                        if (ans[ind] == 0 && res + needles[ind].size <= haystack_end && fallback_searchers[ind].compare(haystack, haystack_end, res))
                             ans[ind] = count_chars(haystack, res);
                     }
                 }
@@ -650,6 +652,8 @@ using VolnitskyUTF8 = VolnitskyBase<true, false, ASCIICaseSensitiveStringSearche
 using VolnitskyCaseInsensitive = VolnitskyBase<false, true, ASCIICaseInsensitiveStringSearcher>; /// ignores non-ASCII bytes
 using VolnitskyCaseInsensitiveUTF8 = VolnitskyBase<false, false, UTF8CaseInsensitiveStringSearcher>;
 
+using VolnitskyToken = VolnitskyBase<true, true, ASCIICaseSensitiveTokenSearcher>;
+
 using MultiVolnitsky = MultiVolnitskyBase<true, true, ASCIICaseSensitiveStringSearcher>;
 using MultiVolnitskyUTF8 = MultiVolnitskyBase<true, false, ASCIICaseSensitiveStringSearcher>;
 using MultiVolnitskyCaseInsensitive = MultiVolnitskyBase<false, true, ASCIICaseInsensitiveStringSearcher>;
diff --git a/dbms/src/Functions/FunctionsStringSearch.cpp b/dbms/src/Functions/FunctionsStringSearch.cpp
index 726eb8738afb..5d688232bd48 100644
--- a/dbms/src/Functions/FunctionsStringSearch.cpp
+++ b/dbms/src/Functions/FunctionsStringSearch.cpp
@@ -434,6 +434,74 @@ struct MultiSearchFirstIndexImpl
     }
 };
 
+/** Token search the string, means that needle must be surrounded by some separator chars, like whitespace or puctuation.
+  */
+template <bool negate_result = false>
+struct HasTokenImpl
+{
+    using ResultType = UInt8;
+
+    static void vector_constant(
+        const ColumnString::Chars & data, const ColumnString::Offsets & offsets, const std::string & pattern, PaddedPODArray<UInt8> & res)
+    {
+        if (offsets.empty())
+            return;
+
+        const UInt8 * begin = data.data();
+        const UInt8 * pos = begin;
+        const UInt8 * end = pos + data.size();
+
+        /// The current index in the array of strings.
+        size_t i = 0;
+
+        VolnitskyToken searcher(pattern.data(), pattern.size(), end - pos);
+
+        /// We will search for the next occurrence in all rows at once.
+        while (pos < end && end != (pos = searcher.search(pos, end - pos)))
+        {
+            /// Let's determine which index it refers to.
+            while (begin + offsets[i] <= pos)
+            {
+                res[i] = negate_result;
+                ++i;
+            }
+
+            /// We check that the entry does not pass through the boundaries of strings.
+            if (pos + pattern.size() < begin + offsets[i])
+                res[i] = !negate_result;
+            else
+                res[i] = negate_result;
+
+            pos = begin + offsets[i];
+            ++i;
+        }
+
+        /// Tail, in which there can be no substring.
+        if (i < res.size())
+            memset(&res[i], negate_result, (res.size() - i) * sizeof(res[0]));
+    }
+
+    static void constant_constant(const std::string & data, const std::string & pattern, UInt8 & res)
+    {
+        VolnitskyToken searcher(pattern.data(), pattern.size(), data.size());
+        const auto found = searcher.search(data.c_str(), data.size()) != data.end().base();
+        res = negate_result ^ found;
+    }
+
+    template <typename... Args>
+    static void vector_vector(Args &&...)
+    {
+        throw Exception("Function 'hasToken' does not support non-constant needle argument", ErrorCodes::ILLEGAL_COLUMN);
+    }
+
+    /// Search different needles in single haystack.
+    template <typename... Args>
+    static void constant_vector(Args &&...)
+    {
+        throw Exception("Function 'hasToken' does not support non-constant needle argument", ErrorCodes::ILLEGAL_COLUMN);
+    }
+};
+
 
 struct NamePosition
 {
@@ -516,6 +584,11 @@ struct NameMultiSearchFirstPositionCaseInsensitiveUTF8
     static constexpr auto name = "multiSearchFirstPositionCaseInsensitiveUTF8";
 };
 
+struct NameHasToken
+{
+    static constexpr auto name = "hasToken";
+};
+
 
 using FunctionPosition = FunctionsStringSearch<PositionImpl<PositionCaseSensitiveASCII>, NamePosition>;
 using FunctionPositionUTF8 = FunctionsStringSearch<PositionImpl<PositionCaseSensitiveUTF8>, NamePositionUTF8>;
@@ -542,6 +615,7 @@ using FunctionMultiSearchFirstPositionUTF8 = FunctionsMultiStringSearch<MultiSea
 using FunctionMultiSearchFirstPositionCaseInsensitive = FunctionsMultiStringSearch<MultiSearchFirstPositionImpl<PositionCaseInsensitiveASCII>, NameMultiSearchFirstPositionCaseInsensitive>;
 using FunctionMultiSearchFirstPositionCaseInsensitiveUTF8 = FunctionsMultiStringSearch<MultiSearchFirstPositionImpl<PositionCaseInsensitiveUTF8>, NameMultiSearchFirstPositionCaseInsensitiveUTF8>;
 
+using FunctionHasToken = FunctionsStringSearch<HasTokenImpl<false>, NameHasToken>;
 
 void registerFunctionsStringSearch(FunctionFactory & factory)
 {
@@ -570,6 +644,8 @@ void registerFunctionsStringSearch(FunctionFactory & factory)
     factory.registerFunction<FunctionMultiSearchFirstPositionCaseInsensitive>();
     factory.registerFunction<FunctionMultiSearchFirstPositionCaseInsensitiveUTF8>();
 
+    factory.registerFunction<FunctionHasToken>();
+
     factory.registerAlias("locate", NamePosition::name, FunctionFactory::CaseInsensitive);
 }
 }
diff --git a/dbms/src/Storages/MergeTree/MergeTreeIndexFullText.cpp b/dbms/src/Storages/MergeTree/MergeTreeIndexFullText.cpp
index 3625c6f1aa55..246ad6784b26 100644
--- a/dbms/src/Storages/MergeTree/MergeTreeIndexFullText.cpp
+++ b/dbms/src/Storages/MergeTree/MergeTreeIndexFullText.cpp
@@ -168,6 +168,19 @@ const MergeTreeConditionFullText::AtomMap MergeTreeConditionFullText::atom_map
                     return true;
                 }
         },
+        {
+                "hasToken",
+                [] (RPNElement & out, const Field & value, const MergeTreeIndexFullText & idx)
+                {
+                    out.function = RPNElement::FUNCTION_EQUALS;
+                    out.bloom_filter = std::make_unique<BloomFilter>(
+                            idx.bloom_filter_size, idx.bloom_filter_hashes, idx.seed);
+
+                    const auto & str = value.get<String>();
+                    stringToBloomFilter(str.c_str(), str.size(), idx.token_extractor_func, *out.bloom_filter);
+                    return true;
+                }
+        },
         {
                 "startsWith",
                 [] (RPNElement & out, const Field & value, const MergeTreeIndexFullText & idx)
