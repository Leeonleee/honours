{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 81600,
  "instance_id": "ClickHouse__ClickHouse-81600",
  "issue_numbers": [
    "81525"
  ],
  "base_commit": "8bd98582283ec31742aba908ffb1fa717cbe57d5",
  "patch": "diff --git a/docs/en/operations/system-tables/codecs.md b/docs/en/operations/system-tables/codecs.md\nnew file mode 100644\nindex 000000000000..c8fa3dc2cbdb\n--- /dev/null\n+++ b/docs/en/operations/system-tables/codecs.md\n@@ -0,0 +1,45 @@\n+---\n+description: 'System table containing information about codecs\n+  in queue.'\n+keywords: ['system table', 'codecs', 'compression']\n+slug: /operations/system-tables/codecs\n+title: 'system.codecs'\n+---\n+\n+Contains information about compression and encryption codecs.\n+\n+You can use this table to get information about the available compression and encryption codecs\n+\n+The `system.codecs` table contains the following columns (the column type is shown in brackets):\n+\n+- `name` ([String](../../sql-reference/data-types/string.md)) \u2014 Codec name.\n+- `method_byte` ([UInt8](/sql-reference/data-types/int-uint#integer-ranges)) \u2014 Byte which indicates codec in compressed file.\n+- `is_compression` ([UInt8](/sql-reference/data-types/int-uint#integer-ranges)) \u2014 True if this codec compresses something. Otherwise it can be just a transformation that helps compression.\n+- `is_generic_compression` ([UInt8](/sql-reference/data-types/int-uint#integer-ranges)) \u2014 The codec is a generic compression algorithm like lz4, zstd.\n+- `is_encryption` ([UInt8](/sql-reference/data-types/int-uint#integer-ranges)) \u2014 The codec encrypts the data.\n+- `is_timeseries_codec`([UInt8](/sql-reference/data-types/int-uint#integer-ranges)) \u2014 The codec is for floating-point time series data.\n+- `is_experimental` ([UInt8](/sql-reference/data-types/int-uint#integer-ranges)) \u2014 The codec is experimental.\n+- `description` ([String](../../sql-reference/data-types/string.md)) \u2014 A high-level description of the codec.\n+\n+**Example**\n+\n+Query:\n+\n+```sql\n+SELECT * FROM system.codecs WHERE name='LZ4'\n+```\n+\n+Result:\n+\n+```text\n+Row 1:\n+\u2500\u2500\u2500\u2500\u2500\u2500\n+name:                   LZ4\n+method_byte:            130\n+is_compression:         1\n+is_generic_compression: 1\n+is_encryption:          0\n+is_timeseries_codec:    0\n+is_experimental:        0\n+description:            Extremely fast; good compression; balanced speed and efficiency.\n+```\ndiff --git a/src/Compression/CompressionCodecDeflateQpl.h b/src/Compression/CompressionCodecDeflateQpl.h\nindex 74ff5a449f7a..75d3527082f5 100644\n--- a/src/Compression/CompressionCodecDeflateQpl.h\n+++ b/src/Compression/CompressionCodecDeflateQpl.h\n@@ -110,6 +110,12 @@ class CompressionCodecDeflateQpl final : public ICompressionCodec\n     bool isGenericCompression() const override { return true; }\n     bool isDeflateQpl() const override { return true; }\n \n+    std::string getDescription() const override\n+    {\n+        return \"Requires hardware support for Intel\u2019s QuickAssist Technology for DEFLATE compression; enhanced performance for specific hardware.\";\n+    }\n+\n+\n     UInt32 doCompressData(const char * source, UInt32 source_size, char * dest) const override;\n     void doDecompressData(const char * source, UInt32 source_size, char * dest, UInt32 uncompressed_size) const override;\n \ndiff --git a/src/Compression/CompressionCodecDelta.cpp b/src/Compression/CompressionCodecDelta.cpp\nindex 680f93a61b69..f3ff161eef82 100644\n--- a/src/Compression/CompressionCodecDelta.cpp\n+++ b/src/Compression/CompressionCodecDelta.cpp\n@@ -29,6 +29,12 @@ class CompressionCodecDelta : public ICompressionCodec\n     bool isGenericCompression() const override { return false; }\n     bool isDeltaCompression() const override { return true; }\n \n+    std::string getDescription() const override\n+    {\n+        return \"Preprocessor (should be followed by some compression codec). Stores difference between neighboring values; good for monotonically increasing or decreasing data.\";\n+    }\n+\n+\n private:\n     const UInt8 delta_bytes_size;\n };\ndiff --git a/src/Compression/CompressionCodecDoubleDelta.cpp b/src/Compression/CompressionCodecDoubleDelta.cpp\nindex 9c25bc76eac3..15ae8515a8ee 100644\n--- a/src/Compression/CompressionCodecDoubleDelta.cpp\n+++ b/src/Compression/CompressionCodecDoubleDelta.cpp\n@@ -138,6 +138,11 @@ class CompressionCodecDoubleDelta : public ICompressionCodec\n     bool isCompression() const override { return true; }\n     bool isGenericCompression() const override { return false; }\n     bool isDeltaCompression() const override { return true; }\n+    std::string getDescription() const override\n+    {\n+        return \"Stores difference between neighboring delta values; suitable for time series data.\";\n+    }\n+\n \n private:\n     UInt8 data_bytes_size;\ndiff --git a/src/Compression/CompressionCodecEncrypted.h b/src/Compression/CompressionCodecEncrypted.h\nindex 7971cbadab71..632294e598ee 100644\n--- a/src/Compression/CompressionCodecEncrypted.h\n+++ b/src/Compression/CompressionCodecEncrypted.h\n@@ -107,19 +107,13 @@ class CompressionCodecEncrypted final : public ICompressionCodec\n     uint8_t getMethodByte() const override;\n     void updateHash(SipHash & hash) const override;\n \n-    bool isCompression() const override\n-    {\n-        return false;\n-    }\n-\n-    bool isGenericCompression() const override\n-    {\n-        return false;\n-    }\n+    bool isCompression() const override { return false; }\n+    bool isGenericCompression() const override { return false; }\n+    bool isEncryption() const override { return true; }\n \n-    bool isEncryption() const override\n+    std::string getDescription() const override\n     {\n-        return true;\n+        return \"Encrypts and decrypts blocks with AES-128 in GCM-SIV mode (RFC-8452).\";\n     }\n protected:\n     UInt32 getMaxCompressedDataSize(UInt32 uncompressed_size) const override;\ndiff --git a/src/Compression/CompressionCodecFPC.cpp b/src/Compression/CompressionCodecFPC.cpp\nindex f52ebac47ec3..e6ba5c6c7ae2 100644\n--- a/src/Compression/CompressionCodecFPC.cpp\n+++ b/src/Compression/CompressionCodecFPC.cpp\n@@ -40,6 +40,11 @@ class CompressionCodecFPC : public ICompressionCodec\n     bool isCompression() const override { return true; }\n     bool isGenericCompression() const override { return false; }\n     bool isFloatingPointTimeSeriesCodec() const override { return true; }\n+    std::string getDescription() const override\n+    {\n+        return \"High Throughput Compression of Double-Precision Floating-Point Data.\";\n+    }\n+\n \n private:\n     static constexpr UInt32 HEADER_SIZE = 2;\ndiff --git a/src/Compression/CompressionCodecGCD.cpp b/src/Compression/CompressionCodecGCD.cpp\nindex ca7e53081447..998975e2c554 100644\n--- a/src/Compression/CompressionCodecGCD.cpp\n+++ b/src/Compression/CompressionCodecGCD.cpp\n@@ -31,6 +31,11 @@ class CompressionCodecGCD : public ICompressionCodec\n \n     bool isCompression() const override { return false; }\n     bool isGenericCompression() const override { return false; }\n+    std::string getDescription() const override\n+    {\n+        return \"Preprocessor. Greatest common divisor compression; divides values by a common divisor; effective for divisible integer sequences.\";\n+    }\n+\n \n private:\n     const UInt8 gcd_bytes_size;\ndiff --git a/src/Compression/CompressionCodecGorilla.cpp b/src/Compression/CompressionCodecGorilla.cpp\nindex 4570cb6aeb41..6a22be45e812 100644\n--- a/src/Compression/CompressionCodecGorilla.cpp\n+++ b/src/Compression/CompressionCodecGorilla.cpp\n@@ -124,6 +124,12 @@ class CompressionCodecGorilla : public ICompressionCodec\n     bool isGenericCompression() const override { return false; }\n     bool isFloatingPointTimeSeriesCodec() const override { return true; }\n \n+    std::string getDescription() const override\n+    {\n+        return \"Calculates XOR between current and previous value; suitable for slowly changing numbers.\";\n+    }\n+\n+\n private:\n     const UInt8 data_bytes_size;\n };\ndiff --git a/src/Compression/CompressionCodecLZ4.cpp b/src/Compression/CompressionCodecLZ4.cpp\nindex 597c1ba3acbe..136b7a98c838 100644\n--- a/src/Compression/CompressionCodecLZ4.cpp\n+++ b/src/Compression/CompressionCodecLZ4.cpp\n@@ -35,6 +35,10 @@ class CompressionCodecLZ4 : public ICompressionCodec\n \n     bool isCompression() const override { return true; }\n     bool isGenericCompression() const override { return true; }\n+    std::string getDescription() const override\n+    {\n+        return \"Extremely fast; good compression; balanced speed and efficiency.\";\n+    }\n \n private:\n     void doDecompressData(const char * source, UInt32 source_size, char * dest, UInt32 uncompressed_size) const override;\n@@ -52,6 +56,11 @@ class CompressionCodecLZ4HC : public CompressionCodecLZ4\n \n protected:\n     UInt32 doCompressData(const char * source, UInt32 source_size, char * dest) const override;\n+    std::string getDescription() const override\n+    {\n+        return \"LZ4 High Compression algorithm with configurable level; slower but better compression than LZ4, but decompression is still fast.\";\n+    }\n+\n \n private:\n     const int level;\ndiff --git a/src/Compression/CompressionCodecMultiple.h b/src/Compression/CompressionCodecMultiple.h\nindex 1d63fe1da55a..35cb79f3e4d6 100644\n--- a/src/Compression/CompressionCodecMultiple.h\n+++ b/src/Compression/CompressionCodecMultiple.h\n@@ -28,6 +28,12 @@ class CompressionCodecMultiple final : public ICompressionCodec\n     bool isCompression() const override;\n     bool isGenericCompression() const override { return false; }\n \n+    std::string getDescription() const override\n+    {\n+        return \"Apply multiple codecs consecutively defined by user.\";\n+    }\n+\n+\n private:\n     Codecs codecs;\n };\ndiff --git a/src/Compression/CompressionCodecNone.h b/src/Compression/CompressionCodecNone.h\nindex 0aaa973b55f1..9f41a0c6f6cc 100644\n--- a/src/Compression/CompressionCodecNone.h\n+++ b/src/Compression/CompressionCodecNone.h\n@@ -24,6 +24,12 @@ class CompressionCodecNone final : public ICompressionCodec\n     bool isCompression() const override { return false; }\n     bool isGenericCompression() const override { return false; }\n     bool isNone() const override { return true; }\n+\n+    std::string getDescription() const override\n+    {\n+        return \"No compression at all. Can be used on the columns that can not be compressed anyway.\";\n+    }\n+\n };\n \n }\ndiff --git a/src/Compression/CompressionCodecT64.cpp b/src/Compression/CompressionCodecT64.cpp\nindex e017d126294c..61c0d0c1f9fa 100644\n--- a/src/Compression/CompressionCodecT64.cpp\n+++ b/src/Compression/CompressionCodecT64.cpp\n@@ -53,6 +53,11 @@ class CompressionCodecT64 : public ICompressionCodec\n \n     bool isCompression() const override { return true; }\n     bool isGenericCompression() const override { return false; }\n+    std::string getDescription() const override\n+    {\n+        return \"Preprocessor. Crops unused high bits; puts them into a 64x64 bit matrix; optimized for 64-bit data types.\";\n+    }\n+\n \n private:\n     std::optional<TypeIndex> type_idx;\ndiff --git a/src/Compression/CompressionCodecZSTD.h b/src/Compression/CompressionCodecZSTD.h\nindex cdded9fc08a8..1c985799c98d 100644\n--- a/src/Compression/CompressionCodecZSTD.h\n+++ b/src/Compression/CompressionCodecZSTD.h\n@@ -29,6 +29,12 @@ class CompressionCodecZSTD : public ICompressionCodec\n     bool isCompression() const override { return true; }\n     bool isGenericCompression() const override { return true; }\n \n+    std::string getDescription() const override\n+    {\n+        return \"Good compression; pretty fast; best for high compression needs. Don\u2019t use levels higher than 3.\";\n+    }\n+\n+\n private:\n     const int level;\n     const bool enable_long_range;\ndiff --git a/src/Compression/CompressionCodecZSTDQAT.cpp b/src/Compression/CompressionCodecZSTDQAT.cpp\nindex 53f6473735c3..5da4ba38f8ed 100644\n--- a/src/Compression/CompressionCodecZSTDQAT.cpp\n+++ b/src/Compression/CompressionCodecZSTDQAT.cpp\n@@ -31,6 +31,12 @@ class CompressionCodecZSTDQAT : public CompressionCodecZSTD\n \n     explicit CompressionCodecZSTDQAT(int level_);\n \n+    std::string getDescription() const override\n+    {\n+        return \"Requires hardware support for QuickAssist Technology (QAT) hardware; provides accelerated compression tasks.\";\n+    }\n+\n+\n protected:\n     bool isZstdQat() const override { return true; }\n     UInt32 doCompressData(const char * source, UInt32 source_size, char * dest) const override;\ndiff --git a/src/Compression/CompressionFactory.cpp b/src/Compression/CompressionFactory.cpp\nindex 34e505b03a7e..7ab5cb4691f8 100644\n--- a/src/Compression/CompressionFactory.cpp\n+++ b/src/Compression/CompressionFactory.cpp\n@@ -10,6 +10,9 @@\n #include <Parsers/parseQuery.h>\n #include <Poco/String.h>\n \n+#include <Columns/IColumn.h>\n+#include <algorithm>\n+\n #include <boost/algorithm/string/join.hpp>\n \n #include \"config.h\"\n@@ -112,6 +115,27 @@ CompressionCodecPtr CompressionCodecFactory::get(uint8_t byte_code) const\n     return family_code_and_creator->second({}, nullptr);\n }\n \n+void CompressionCodecFactory::fillCodecDescriptions(MutableColumns & res_columns) const\n+{\n+    std::for_each(\n+        family_name_with_codec.begin(),\n+        family_name_with_codec.end(),\n+        [&](const auto &it)\n+        {\n+            const std::string &name = it.first;\n+            CompressionCodecPtr tmp = it.second({}, nullptr);\n+\n+            res_columns[0]->insert(name);\n+            res_columns[1]->insert(tmp->getMethodByte());\n+            res_columns[2]->insert(tmp->isCompression());\n+            res_columns[3]->insert(tmp->isGenericCompression());\n+            res_columns[4]->insert(tmp->isEncryption());\n+            res_columns[5]->insert(tmp->isFloatingPointTimeSeriesCodec());\n+            res_columns[6]->insert(tmp->isExperimental());\n+            res_columns[7]->insert(tmp->getDescription());\n+        }\n+    );\n+}\n \n CompressionCodecPtr CompressionCodecFactory::getImpl(const String & family_name, const ASTPtr & arguments, const IDataType * column_type) const\n {\ndiff --git a/src/Compression/CompressionFactory.h b/src/Compression/CompressionFactory.h\nindex 262eb450cdbf..395c89d91b23 100644\n--- a/src/Compression/CompressionFactory.h\n+++ b/src/Compression/CompressionFactory.h\n@@ -1,6 +1,7 @@\n #pragma once\n \n #include <Common/IFactoryWithAliases.h>\n+#include <Columns/IColumn_fwd.h>\n \n #include <functional>\n #include <memory>\n@@ -74,6 +75,9 @@ class CompressionCodecFactory final : private boost::noncopyable\n     /// Get codec by name with optional params. Example: LZ4, ZSTD(3)\n     CompressionCodecPtr get(const String & compression_codec) const;\n \n+    /// Insert codec information into MutableColumns to show in the system table\n+    void fillCodecDescriptions(MutableColumns & res_columns) const;\n+\n     /// Register codec with parameters and column type\n     void registerCompressionCodecWithType(const String & family_name, std::optional<uint8_t> byte_code, CreatorWithType creator);\n     /// Register codec with parameters\ndiff --git a/src/Compression/ICompressionCodec.h b/src/Compression/ICompressionCodec.h\nindex 359f18316d63..f391471f27ab 100644\n--- a/src/Compression/ICompressionCodec.h\n+++ b/src/Compression/ICompressionCodec.h\n@@ -127,6 +127,9 @@ class ICompressionCodec : private boost::noncopyable\n     /// If it does nothing.\n     virtual bool isNone() const { return false; }\n \n+    // Returns a string with a high level codec description.\n+    virtual std::string getDescription() const = 0;\n+\n protected:\n     /// This is used for fuzz testing\n     friend int LLVMFuzzerTestOneInput(const uint8_t * data, size_t size);\ndiff --git a/src/Storages/System/StorageSystemCodecs.cpp b/src/Storages/System/StorageSystemCodecs.cpp\nnew file mode 100644\nindex 000000000000..7fe66d71b35a\n--- /dev/null\n+++ b/src/Storages/System/StorageSystemCodecs.cpp\n@@ -0,0 +1,33 @@\n+\n+#include <Storages/System/StorageSystemCodecs.h>\n+#include <Storages/MergeTree/MergeTreeData.h>\n+#include <Columns/ColumnsNumber.h>\n+#include <Columns/ColumnString.h>\n+#include <Columns/ColumnNullable.h>\n+#include <Compression/CompressionFactory.h>\n+\n+\n+namespace DB\n+{\n+\n+ColumnsDescription StorageSystemCodecs::getColumnsDescription()\n+{\n+    return ColumnsDescription\n+    {\n+        { \"name\",                   std::make_shared<DataTypeString>(), \"Codec name.\"},\n+        { \"method_byte\",            std::make_shared<DataTypeUInt8>(), \"Byte which indicates codec in compressed file.\"},\n+        { \"is_compression\",         std::make_shared<DataTypeUInt8>(), \"True if this codec compresses something. Otherwise it can be just a transformation that helps compression.\"},\n+        { \"is_generic_compression\", std::make_shared<DataTypeUInt8>(), \"The codec is a generic compression algorithm like lz4, zstd.\"},\n+        { \"is_encryption\",          std::make_shared<DataTypeUInt8>(), \"The codec encrypts.\"},\n+        { \"is_timeseries_codec\",    std::make_shared<DataTypeUInt8>(), \"The codec is for floating point timeseries codec.\"},\n+        { \"is_experimental\",        std::make_shared<DataTypeUInt8>(), \"The codec is experimental.\"},\n+        { \"description\",            std::make_shared<DataTypeString>(), \"A high-level description of the codec.\"},\n+    };\n+}\n+\n+void StorageSystemCodecs::fillData(MutableColumns & res_columns, ContextPtr, const ActionsDAG::Node *, std::vector<UInt8>) const\n+{\n+    CompressionCodecFactory::instance().fillCodecDescriptions(res_columns);\n+}\n+\n+}\ndiff --git a/src/Storages/System/StorageSystemCodecs.h b/src/Storages/System/StorageSystemCodecs.h\nnew file mode 100644\nindex 000000000000..070611a01a83\n--- /dev/null\n+++ b/src/Storages/System/StorageSystemCodecs.h\n@@ -0,0 +1,22 @@\n+#pragma once\n+\n+#include <Storages/System/IStorageSystemOneBlock.h>\n+\n+\n+namespace DB\n+{\n+\n+/** Implements system table 'codecs', to get information for every codec.\n+ */\n+class StorageSystemCodecs final : public IStorageSystemOneBlock\n+{\n+public:\n+    std::string getName() const override { return \"SystemCodecs\"; }\n+    static ColumnsDescription getColumnsDescription();\n+\n+protected:\n+    void fillData(MutableColumns & res_columns, ContextPtr context, const ActionsDAG::Node *, std::vector<UInt8>) const override;\n+    using IStorageSystemOneBlock::IStorageSystemOneBlock;\n+};\n+\n+}\ndiff --git a/src/Storages/System/attachSystemTables.cpp b/src/Storages/System/attachSystemTables.cpp\nindex f525dd310ccf..9249fb3530b6 100644\n--- a/src/Storages/System/attachSystemTables.cpp\n+++ b/src/Storages/System/attachSystemTables.cpp\n@@ -13,6 +13,7 @@\n #include <Storages/System/StorageSystemCollations.h>\n #include <Storages/System/StorageSystemClusters.h>\n #include <Storages/System/StorageSystemColumns.h>\n+#include <Storages/System/StorageSystemCodecs.h>\n #include <Storages/System/StorageSystemDatabases.h>\n #include <Storages/System/StorageSystemDataSkippingIndices.h>\n #include <Storages/System/StorageSystemDataTypeFamilies.h>\n@@ -248,6 +249,7 @@ void attachSystemTablesServer(ContextPtr context, IDatabase & system_database, b\n         attach<StorageSystemTransactions>(context, system_database, \"transactions\", \"Contains a list of transactions and their state.\");\n \n     attach<StorageSystemLatencyBuckets>(context, system_database, \"latency_buckets\", \"Contains buckets bounds used by latency log.\");\n+    attach<StorageSystemCodecs>(context, system_database, \"codecs\", \"Contains information about system codecs.\");\n }\n \n void attachSystemTablesAsync(ContextPtr context, IDatabase & system_database, AsynchronousMetrics & async_metrics)\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01222_system_codecs.reference b/tests/queries/0_stateless/01222_system_codecs.reference\nnew file mode 100644\nindex 000000000000..cb4f6c553d4c\n--- /dev/null\n+++ b/tests/queries/0_stateless/01222_system_codecs.reference\n@@ -0,0 +1,24 @@\n+AES_128_GCM_SIV\t150\t0\t0\t1\t0\t0\tEncrypts and decrypts blocks with AES-128 in GCM-SIV mode (RFC-8452).\n+AES_256_GCM_SIV\t151\t0\t0\t1\t0\t0\tEncrypts and decrypts blocks with AES-128 in GCM-SIV mode (RFC-8452).\n+DEFLATE_QPL\t153\t1\t1\t0\t0\t0\tRequires hardware support for Intel\u2019s QuickAssist Technology for DEFLATE compression; enhanced performance for specific hardware.\n+Delta\t146\t0\t0\t0\t0\t0\tPreprocessor (should be followed by some compression codec). Stores difference between neighboring values; good for monotonically increasing or decreasing data.\n+DoubleDelta\t148\t1\t0\t0\t0\t0\tStores difference between neighboring delta values; suitable for time series data.\n+FPC\t152\t1\t0\t0\t1\t0\tHigh Throughput Compression of Double-Precision Floating-Point Data.\n+GCD\t154\t0\t0\t0\t0\t0\tPreprocessor. Greatest common divisor compression; divides values by a common divisor; effective for divisible integer sequences.\n+Gorilla\t149\t1\t0\t0\t1\t0\tCalculates XOR between current and previous value; suitable for slowly changing numbers.\n+LZ4\t130\t1\t1\t0\t0\t0\tExtremely fast; good compression; balanced speed and efficiency.\n+LZ4HC\t130\t1\t1\t0\t0\t0\tLZ4 High Compression algorithm with configurable level; slower but better compression than LZ4, but decompression is still fast.\n+Multiple\t145\t0\t0\t0\t0\t0\tApply multiple codecs consecutively defined by user.\n+NONE\t2\t0\t0\t0\t0\t0\tNo compression at all. Can be used on the columns that can not be compressed anyway.\n+T64\t147\t1\t0\t0\t0\t0\tPreprocessor. Crops unused high bits; puts them into a 64x64 bit matrix; optimized for 64-bit data types.\n+ZSTD\t144\t1\t1\t0\t0\t0\tGood compression; pretty fast; best for high compression needs. Don\u2019t use levels higher than 3.\n+ZSTD_QAT\t144\t1\t1\t0\t0\t0\tRequires hardware support for QuickAssist Technology (QAT) hardware; provides accelerated compression tasks.\n+15\n+name\n+method_byte\n+is_compression\n+is_generic_compression\n+is_encryption\n+is_timeseries_codec\n+is_experimental\n+description\ndiff --git a/tests/queries/0_stateless/01222_system_codecs.sql b/tests/queries/0_stateless/01222_system_codecs.sql\nnew file mode 100644\nindex 000000000000..cba8f0a60796\n--- /dev/null\n+++ b/tests/queries/0_stateless/01222_system_codecs.sql\n@@ -0,0 +1,7 @@\n+-- Tags: no-object-storage, no-fasttest, no-cpu-aarch64, no-cpu-s390x\n+-- no-cpu-aarch64 and no-cpu-s390x because DEFLATE_QPL is x86-only\n+select * from system.codecs order by all;\n+\n+select count() from system.codecs;\n+\n+select name from system.columns where table = 'codecs' and database = 'system'\n",
  "problem_statement": "Add a new table, `system.codecs`\n### Company or project name\n\nClickHouse\n\n### Use case\n\nIntrospect the list of codecs (see CompressionFactory), their properties, and provide a built-in documentation.\n\n### Describe the solution you'd like\n\nImplement similarly to other system tables for introspection.\n\n### Describe alternatives you've considered\n\n_No response_\n\n### Additional context\n\n_No response_\n",
  "hints_text": "Hi @alexey-milovidov :\n\nI am already implementing something similar for #59913, so I can do this one quickly. The only issue is that we don't have introspection for codec classes, so I would ask you how do you prefer this to be implemented?\n\nI think we can add these fields more or less \n\n```c++\nColumnsDescription StorageSystemCodecs::getColumnsDescription()\n{\n    return ColumnsDescription\n    {\n        { \"codec\",           std::make_shared<DataTypeString>(), \"Codec name.\"},\n        { \"method_byte\",      std::make_shared<DataTypeUInt8>(), \"Byte which indicates codec in compressed file.\"},\n        { \"is_compression\", std::make_shared<DataTypeUInt8>(), \"Flag that indicates whether the codec is a compression.\"},\n        { \"is_generic_compression\", std::make_shared<DataTypeUInt8>(), \"Flag that indicates whether the codec is a generic compression.\"},\n        { \"is_encription\", std::make_shared<DataTypeUInt8>(), \"Flag that indicates whether the codec encrypts.\"},\n        { \"is_floating_point_timeseries_codec\", std::make_shared<DataTypeUInt8>(), \"Flag that indicates whether the codec is efective for floating point timeseries codec.\"},\n        { \"is_delta_compression\", std::make_shared<DataTypeUInt8>(), \"Flag that indicates whether the codec is efective for delta compression.\"},\n        { \"is_experimental\", std::make_shared<DataTypeUInt8>(), \"Flag that indicates if the codec is experimental.\"},\n        { \"is_deflate_qpl\", std::make_shared<DataTypeUInt8>(), \"Flag that indicates if the codec the DEFLATE_QPL.\"},\n        { \"is_zstd_qat\", std::make_shared<DataTypeUInt8>(), \"Flag that indicates if the codec the ZSTD_QAT.\"},\n        { \"is_none\", std::make_shared<DataTypeUInt8>(), \"Flag that indicates if the codec does nothing.\"},\n    };\n}\n```\n\nWe can access all the codec names throw the `CompressionCodecFactory::instance()`. But we cannot call virtual methods without building instances of the codec objects.\n\nSo, or we duplicate the information in order to access them from the class type (a trait) or we build a temporal instance when iterating over all the codecs in order to access the virtual members? Do you have any preference?\n  ",
  "created_at": "2025-06-10T16:38:12Z",
  "modified_files": [
    "b/docs/en/operations/system-tables/codecs.md",
    "src/Compression/CompressionCodecDeflateQpl.h",
    "src/Compression/CompressionCodecDelta.cpp",
    "src/Compression/CompressionCodecDoubleDelta.cpp",
    "src/Compression/CompressionCodecEncrypted.h",
    "src/Compression/CompressionCodecFPC.cpp",
    "src/Compression/CompressionCodecGCD.cpp",
    "src/Compression/CompressionCodecGorilla.cpp",
    "src/Compression/CompressionCodecLZ4.cpp",
    "src/Compression/CompressionCodecMultiple.h",
    "src/Compression/CompressionCodecNone.h",
    "src/Compression/CompressionCodecT64.cpp",
    "src/Compression/CompressionCodecZSTD.h",
    "src/Compression/CompressionCodecZSTDQAT.cpp",
    "src/Compression/CompressionFactory.cpp",
    "src/Compression/CompressionFactory.h",
    "src/Compression/ICompressionCodec.h",
    "b/src/Storages/System/StorageSystemCodecs.cpp",
    "b/src/Storages/System/StorageSystemCodecs.h",
    "src/Storages/System/attachSystemTables.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01222_system_codecs.reference",
    "b/tests/queries/0_stateless/01222_system_codecs.sql"
  ]
}