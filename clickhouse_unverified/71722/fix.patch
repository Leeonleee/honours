diff --git a/docs/en/operations/system-tables/overview.md b/docs/en/operations/system-tables/overview.md
index 4270f02c6d7b..2acea79cf5d0 100644
--- a/docs/en/operations/system-tables/overview.md
+++ b/docs/en/operations/system-tables/overview.md
@@ -152,7 +152,7 @@ We can query across these tables using the [`merge`](/sql-reference/table-functi
 SELECT
     _table,
     max(event_time) AS most_recent
-FROM merge('system', '^query_log.*')
+FROM merge('system', '^query_log')
 GROUP BY _table
 ORDER BY most_recent DESC
 
@@ -230,7 +230,7 @@ Due to system table versioning this still does not represent the full data in th
 SELECT
     hostname() AS host,
     count()
-FROM clusterAllReplicas('default', merge('system', '^query_log.*'))
+FROM clusterAllReplicas('default', merge('system', '^query_log'))
 WHERE (event_time >= '2025-04-01 00:00:00') AND (event_time <= '2025-04-12 00:00:00')
 GROUP BY host SETTINGS skip_unavailable_shards = 1
 
@@ -248,4 +248,3 @@ GROUP BY host SETTINGS skip_unavailable_shards = 1
 - Blog: [System Tables and a window into the internals of ClickHouse](https://clickhouse.com/blog/clickhouse-debugging-issues-with-system-tables)
 - Blog: [Essential monitoring queries - part 1 - INSERT queries](https://clickhouse.com/blog/monitoring-troubleshooting-insert-queries-clickhouse)
 - Blog: [Essential monitoring queries - part 2 - SELECT queries](https://clickhouse.com/blog/monitoring-troubleshooting-select-queries-clickhouse)
-
diff --git a/programs/local/LocalServer.cpp b/programs/local/LocalServer.cpp
index 1ddd05809b2f..e81b4e62ab9d 100644
--- a/programs/local/LocalServer.cpp
+++ b/programs/local/LocalServer.cpp
@@ -52,6 +52,7 @@
 #include <boost/program_options/options_description.hpp>
 #include <base/argsToConfig.h>
 #include <filesystem>
+#include <Common/filesystemHelpers.h>
 
 #include "config.h"
 
@@ -280,7 +281,19 @@ static DatabasePtr createMemoryDatabaseIfNotExists(ContextPtr context, const Str
 static DatabasePtr createClickHouseLocalDatabaseOverlay(const String & name_, ContextPtr context)
 {
     auto overlay = std::make_shared<DatabasesOverlay>(name_, context);
-    overlay->registerNextDatabase(std::make_shared<DatabaseAtomic>(name_, fs::weakly_canonical(context->getPath()), UUIDHelpers::generateV4(), context));
+
+    UUID default_database_uuid;
+
+    fs::path existing_path_symlink = fs::weakly_canonical(context->getPath()) / "metadata" / "default";
+    if (FS::isSymlinkNoThrow(existing_path_symlink))
+        default_database_uuid = parse<UUID>(FS::readSymlink(existing_path_symlink).filename());
+    else
+        default_database_uuid = UUIDHelpers::generateV4();
+
+    fs::path default_database_metadata_path = fs::weakly_canonical(context->getPath()) / "store"
+        / DatabaseCatalog::getPathForUUID(default_database_uuid);
+
+    overlay->registerNextDatabase(std::make_shared<DatabaseAtomic>(name_, default_database_metadata_path, default_database_uuid, context));
     overlay->registerNextDatabase(std::make_shared<DatabaseFilesystem>(name_, "", context));
     return overlay;
 }
@@ -292,7 +305,7 @@ void LocalServer::tryInitPath()
 
     if (getClientConfiguration().has("path"))
     {
-        // User-supplied path.
+        /// User-supplied path.
         path = getClientConfiguration().getString("path");
         Poco::trimInPlace(path);
 
@@ -306,15 +319,15 @@ void LocalServer::tryInitPath()
     }
     else
     {
-        // The path is not provided explicitly - use a unique path in the system temporary directory
-        // (or in the current dir if a temporary doesn't exist)
+        /// The user requested to use a temporary path - use a unique path in the system temporary directory
+        /// (or in the current dir if a temporary doesn't exist)
         LoggerRawPtr log = &logger();
         std::filesystem::path parent_folder;
         std::filesystem::path default_path;
 
         try
         {
-            // try to guess a tmp folder name, and check if it's a directory (throw exception otherwise)
+            /// Try to guess a tmp folder name, and check if it's a directory (throw an exception otherwise).
             parent_folder = std::filesystem::temp_directory_path();
 
         }
@@ -342,7 +355,7 @@ void LocalServer::tryInitPath()
         temporary_directory_to_delete = default_path;
 
         path = default_path.string();
-        LOG_DEBUG(log, "Working directory created: {}", path);
+        LOG_DEBUG(log, "Working directory will be created as needed: {}", path);
     }
 
     global_context->setPath(fs::path(path) / "");
@@ -883,30 +896,38 @@ void LocalServer::processConfig()
 
     if (getClientConfiguration().has("path"))
     {
+        attachSystemTablesServer(global_context, *createMemoryDatabaseIfNotExists(global_context, DatabaseCatalog::SYSTEM_DATABASE), false);
+        attachInformationSchema(global_context, *createMemoryDatabaseIfNotExists(global_context, DatabaseCatalog::INFORMATION_SCHEMA));
+        attachInformationSchema(global_context, *createMemoryDatabaseIfNotExists(global_context, DatabaseCatalog::INFORMATION_SCHEMA_UPPERCASE));
+
         String path = global_context->getPath();
-        fs::create_directories(fs::path(path));
 
         /// Lock path directory before read
+        fs::create_directories(fs::path(path));
         status.emplace(fs::path(path) / "status", StatusFile::write_full_info);
 
-        LOG_DEBUG(log, "Loading metadata from {}", path);
-        auto load_system_metadata_tasks = loadMetadataSystem(global_context);
-        attachSystemTablesServer(global_context, *createMemoryDatabaseIfNotExists(global_context, DatabaseCatalog::SYSTEM_DATABASE), false);
-        attachInformationSchema(global_context, *createMemoryDatabaseIfNotExists(global_context, DatabaseCatalog::INFORMATION_SCHEMA));
-        attachInformationSchema(global_context, *createMemoryDatabaseIfNotExists(global_context, DatabaseCatalog::INFORMATION_SCHEMA_UPPERCASE));
-        waitLoad(TablesLoaderForegroundPoolId, load_system_metadata_tasks);
-
-        if (!getClientConfiguration().has("only-system-tables"))
+        if (fs::exists(fs::path(path) / "metadata"))
         {
-            DatabaseCatalog::instance().createBackgroundTasks();
-            waitLoad(loadMetadata(global_context));
-            DatabaseCatalog::instance().startupBackgroundTasks();
-        }
+            LOG_DEBUG(log, "Loading metadata from {}", path);
 
-        /// For ClickHouse local if path is not set the loader will be disabled.
-        global_context->getUserDefinedSQLObjectsStorage().loadObjects();
+            if (fs::exists(std::filesystem::path(path) / "metadata" / "system.sql"))
+            {
+                LoadTaskPtrs load_system_metadata_tasks = loadMetadataSystem(global_context);
+                waitLoad(TablesLoaderForegroundPoolId, load_system_metadata_tasks);
+            }
 
-        LOG_DEBUG(log, "Loaded metadata.");
+            if (!getClientConfiguration().has("only-system-tables"))
+            {
+                DatabaseCatalog::instance().createBackgroundTasks();
+                waitLoad(loadMetadata(global_context));
+                DatabaseCatalog::instance().startupBackgroundTasks();
+            }
+
+            /// For ClickHouse local if path is not set the loader will be disabled.
+            global_context->getUserDefinedSQLObjectsStorage().loadObjects();
+
+            LOG_DEBUG(log, "Loaded metadata.");
+        }
     }
     else if (!getClientConfiguration().has("no-system-tables"))
     {
@@ -981,7 +1002,7 @@ void LocalServer::addExtraOptions(OptionsDescription & options_description)
         ("logger.level", po::value<std::string>(), "Log level")
 
         ("no-system-tables", "do not attach system tables (better startup time)")
-        ("path", po::value<std::string>(), "Storage path")
+        ("path", po::value<std::string>(), "Storage path. If it was not specified, we will use a temporary directory, that is cleaned up on exit.")
         ("only-system-tables", "attach only system tables from specified path")
         ("top_level_domains_path", po::value<std::string>(), "Path to lists with custom TLDs")
         ;
@@ -1023,8 +1044,6 @@ void LocalServer::processOptions(const OptionsDescription &, const CommandLineOp
         getClientConfiguration().setBool("no-system-tables", true);
     if (options.count("only-system-tables"))
         getClientConfiguration().setBool("only-system-tables", true);
-    if (options.count("database"))
-        getClientConfiguration().setString("default_database", options["database"].as<std::string>());
 
     if (options.count("input-format"))
         getClientConfiguration().setString("table-data-format", options["input-format"].as<std::string>());
diff --git a/programs/server/Server.cpp b/programs/server/Server.cpp
index f2083a261911..cf8f8683a990 100644
--- a/programs/server/Server.cpp
+++ b/programs/server/Server.cpp
@@ -2400,7 +2400,7 @@ try
 
     /// Set current database name before loading tables and databases because
     /// system logs may copy global context.
-    std::string default_database = server_settings[ServerSetting::default_database].toString();
+    std::string default_database = server_settings[ServerSetting::default_database];
     if (default_database.empty())
         throw Exception(ErrorCodes::BAD_ARGUMENTS, "default_database cannot be empty");
     global_context->setCurrentDatabaseNameInGlobalContext(default_database);
diff --git a/src/Access/IAccessStorage.cpp b/src/Access/IAccessStorage.cpp
index fca30f588ee6..27ff6728d0a2 100644
--- a/src/Access/IAccessStorage.cpp
+++ b/src/Access/IAccessStorage.cpp
@@ -308,7 +308,7 @@ bool IAccessStorage::insertImpl(const UUID &, const AccessEntityPtr & entity, bo
 {
     if (isReadOnly())
         throwReadonlyCannotInsert(entity->getType(), entity->getName());
-    throw Exception(ErrorCodes::NOT_IMPLEMENTED, "insertImpl() is not implemented in {}", getStorageType());
+    throw Exception(ErrorCodes::NOT_IMPLEMENTED, "insertImpl is not implemented in {}", getStorageType());
 }
 
 
@@ -404,7 +404,7 @@ bool IAccessStorage::removeImpl(const UUID & id, bool throw_if_not_exists)
             return false;
         throwReadonlyCannotRemove(entity->getType(), entity->getName());
     }
-    throw Exception(ErrorCodes::NOT_IMPLEMENTED, "removeImpl() is not implemented in {}", getStorageType());
+    throw Exception(ErrorCodes::NOT_IMPLEMENTED, "removeImpl is not implemented in {}", getStorageType());
 }
 
 
@@ -500,7 +500,7 @@ bool IAccessStorage::updateImpl(const UUID & id, const UpdateFunc &, bool throw_
             return false;
         throwReadonlyCannotUpdate(entity->getType(), entity->getName());
     }
-    throw Exception(ErrorCodes::NOT_IMPLEMENTED, "updateImpl() is not implemented in {}", getStorageType());
+    throw Exception(ErrorCodes::NOT_IMPLEMENTED, "updateImpl is not implemented in {}", getStorageType());
 }
 
 
diff --git a/src/Access/RowPolicy.cpp b/src/Access/RowPolicy.cpp
index 5b9d8521d9a8..ef03d7c582d2 100644
--- a/src/Access/RowPolicy.cpp
+++ b/src/Access/RowPolicy.cpp
@@ -45,7 +45,7 @@ void RowPolicy::setFullName(const RowPolicyName & full_name_)
 
 void RowPolicy::setName(const String &)
 {
-    throw Exception(ErrorCodes::NOT_IMPLEMENTED, "RowPolicy::setName() is not implemented");
+    throw Exception(ErrorCodes::NOT_IMPLEMENTED, "RowPolicy::setName is not implemented");
 }
 
 
diff --git a/src/Client/LocalConnection.cpp b/src/Client/LocalConnection.cpp
index bf29d44e17d1..926fed4c1d59 100644
--- a/src/Client/LocalConnection.cpp
+++ b/src/Client/LocalConnection.cpp
@@ -616,7 +616,7 @@ bool LocalConnection::pollImpl()
 
 UInt64 LocalConnection::receivePacketType()
 {
-    throw Exception(ErrorCodes::NOT_IMPLEMENTED, "receivePacketType() is not implemented for LocalConnection");
+    throw Exception(ErrorCodes::NOT_IMPLEMENTED, "receivePacketType is not implemented for LocalConnection");
 }
 
 Packet LocalConnection::receivePacket()
diff --git a/src/DataTypes/DataTypeObjectDeprecated.h b/src/DataTypes/DataTypeObjectDeprecated.h
index e1f81caaa4fb..2975f48e6aba 100644
--- a/src/DataTypes/DataTypeObjectDeprecated.h
+++ b/src/DataTypes/DataTypeObjectDeprecated.h
@@ -30,7 +30,7 @@ class DataTypeObjectDeprecated : public IDataType
 
     Field getDefault() const override
     {
-        throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Method getDefault() is not implemented for data type {}", getName());
+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Method getDefault is not implemented for data type {}", getName());
     }
 
     bool haveSubtypes() const override { return false; }
diff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h
index ab6e31da30a4..9d201dab6377 100644
--- a/src/DataTypes/IDataType.h
+++ b/src/DataTypes/IDataType.h
@@ -362,7 +362,7 @@ class IDataType : private boost::noncopyable, public std::enable_shared_from_thi
         bool throw_if_null) const
     {
         if (throw_if_null)
-            throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Method getDynamicSubcolumnData() is not implemented for type {}", getName());
+            throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Method getDynamicSubcolumnData is not implemented for type {}", getName());
         return nullptr;
     }
 };
diff --git a/src/DataTypes/IDataTypeDummy.h b/src/DataTypes/IDataTypeDummy.h
index fcfcbe43375f..912d5c501a32 100644
--- a/src/DataTypes/IDataTypeDummy.h
+++ b/src/DataTypes/IDataTypeDummy.h
@@ -28,17 +28,17 @@ class IDataTypeDummy : public IDataType
 public:
     MutableColumnPtr createColumn() const override
     {
-        throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Method createColumn() is not implemented for data type {}", getName());
+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Method createColumn is not implemented for data type {}", getName());
     }
 
     Field getDefault() const override
     {
-        throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Method getDefault() is not implemented for data type {}", getName());
+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Method getDefault is not implemented for data type {}", getName());
     }
 
     void insertDefaultInto(IColumn &) const override
     {
-        throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Method insertDefaultInto() is not implemented for data type {}", getName());
+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Method insertDefaultInto is not implemented for data type {}", getName());
     }
 
     bool haveSubtypes() const override { return false; }
diff --git a/src/Databases/DatabaseAtomic.cpp b/src/Databases/DatabaseAtomic.cpp
index a9f10ff1b856..2dfcef80dc3b 100644
--- a/src/Databases/DatabaseAtomic.cpp
+++ b/src/Databases/DatabaseAtomic.cpp
@@ -4,9 +4,6 @@
 #include <Databases/DatabaseFactory.h>
 #include <Databases/DatabaseOnDisk.h>
 #include <Databases/DatabaseReplicated.h>
-#include <IO/ReadBufferFromFile.h>
-#include <IO/ReadHelpers.h>
-#include <Interpreters/Context.h>
 #include <Interpreters/DDLTask.h>
 #include <Interpreters/DatabaseCatalog.h>
 #include <Interpreters/ExternalDictionariesLoader.h>
@@ -14,7 +11,6 @@
 #include <Common/logger_useful.h>
 #include <Common/PoolId.h>
 #include <Common/atomicRename.h>
-#include <Common/filesystemHelpers.h>
 #include <Core/Settings.h>
 
 
@@ -54,8 +50,9 @@ class AtomicDatabaseTablesSnapshotIterator final : public DatabaseTablesSnapshot
 
 DatabaseAtomic::DatabaseAtomic(String name_, String metadata_path_, UUID uuid, const String & logger_name, ContextPtr context_)
     : DatabaseOrdinary(name_, metadata_path_, "store/", logger_name, context_)
-    , path_to_table_symlinks(fs::path("data") / escapeForFileName(name_) / "")
-    , path_to_metadata_symlink(fs::path("metadata") / escapeForFileName(name_))
+    , root_path(fs::weakly_canonical(context_->getPath()))
+    , path_to_table_symlinks(root_path / "data" / escapeForFileName(name_) / "")
+    , path_to_metadata_symlink(root_path / "metadata" / escapeForFileName(name_))
     , db_uuid(uuid)
 {
     assert(db_uuid != UUIDHelpers::Nil);
@@ -436,6 +433,8 @@ void DatabaseAtomic::setDetachedTableNotInUseForce(const UUID & uuid)
 DatabaseAtomic::DetachedTables DatabaseAtomic::cleanupDetachedTables()
 {
     DetachedTables not_in_use;
+    if (detached_tables.empty())
+        return not_in_use;
     auto it = detached_tables.begin();
     LOG_DEBUG(log, "There are {} detached tables. Start searching non used tables.", detached_tables.size());
     while (it != detached_tables.end())
@@ -573,6 +572,7 @@ void DatabaseAtomic::tryCreateSymlink(const StoragePtr & table, bool if_data_pat
 {
     if (!db_disk->isSymlinkSupported())
         return;
+
     try
     {
         String table_name = table->getStorageID().getTableName();
@@ -580,8 +580,8 @@ void DatabaseAtomic::tryCreateSymlink(const StoragePtr & table, bool if_data_pat
         if (!table->storesDataOnDisk())
             throw Exception(ErrorCodes::LOGICAL_ERROR, "Table {} doesn't have data path to create symlink", table_name);
 
-        String link = path_to_table_symlinks + escapeForFileName(table_name);
-        fs::path data = fs::weakly_canonical(table->getDataPaths()[0]);
+        String link = path_to_table_symlinks / escapeForFileName(table_name);
+        fs::path data = fs::proximate(table->getDataPaths()[0], path_to_table_symlinks);
 
         /// If it already points where needed.
         if (db_disk->equivalentNoThrow(data, link))
@@ -590,7 +590,7 @@ void DatabaseAtomic::tryCreateSymlink(const StoragePtr & table, bool if_data_pat
         if (if_data_path_exist && !db_disk->existsFileOrDirectory(data))
             return;
 
-        db_disk->createDirectoriesSymlink(data, link);
+        db_disk->createDirectorySymlink(data, link);
     }
     catch (...)
     {
@@ -605,7 +605,7 @@ void DatabaseAtomic::tryRemoveSymlink(const String & table_name)
 
     try
     {
-        String path = path_to_table_symlinks + escapeForFileName(table_name);
+        String path = path_to_table_symlinks / escapeForFileName(table_name);
         db_disk->removeFileIfExists(path);
     }
     catch (...)
@@ -621,21 +621,24 @@ void DatabaseAtomic::tryCreateMetadataSymlink()
 
     /// Symlinks in data/db_name/ directory and metadata/db_name/ are not used by ClickHouse,
     /// it's needed only for convenient introspection.
-    assert(path_to_metadata_symlink != metadata_path);
-    fs::path metadata_symlink(path_to_metadata_symlink);
-    if (db_disk->existsFileOrDirectory(metadata_symlink))
+    chassert(path_to_metadata_symlink != metadata_path);
+    if (db_disk->existsFileOrDirectory(path_to_metadata_symlink))
     {
-        if (!db_disk->isSymlink(metadata_symlink))
-            throw Exception(ErrorCodes::FILE_ALREADY_EXISTS, "Directory {} exists", path_to_metadata_symlink);
+        if (!db_disk->isSymlink(path_to_metadata_symlink))
+            throw Exception(ErrorCodes::FILE_ALREADY_EXISTS, "Directory {} already exists", path_to_metadata_symlink);
     }
     else
     {
         try
         {
             /// fs::exists could return false for broken symlink
-            if (db_disk->isSymlinkNoThrow(metadata_symlink))
-                db_disk->removeFileIfExists(metadata_symlink);
-            db_disk->createDirectoriesSymlink(metadata_path, path_to_metadata_symlink);
+            if (db_disk->isSymlinkNoThrow(path_to_metadata_symlink))
+                db_disk->removeFileIfExists(path_to_metadata_symlink);
+
+            String symlink = fs::proximate(root_path / metadata_path, path_to_metadata_symlink.parent_path());
+
+            LOG_TEST(log, "Creating directory symlink, path_to_metadata_symlink: {}, metadata_path: {}, symlink content: {}", path_to_metadata_symlink, metadata_path, symlink);
+            db_disk->createDirectorySymlink(symlink, path_to_metadata_symlink);
         }
         catch (...)
         {
@@ -670,8 +673,8 @@ void DatabaseAtomic::renameDatabase(ContextPtr query_context, const String & new
     }
 
     auto new_name_escaped = escapeForFileName(new_name);
-    auto old_database_metadata_path = fs::path("metadata") / (escapeForFileName(getDatabaseName()) + ".sql");
-    auto new_database_metadata_path = fs::path("metadata") / (new_name_escaped + ".sql");
+    auto old_database_metadata_path = root_path / "metadata" / (escapeForFileName(getDatabaseName()) + ".sql");
+    auto new_database_metadata_path = root_path / "metadata" / (new_name_escaped + ".sql");
     db_disk->moveFile(old_database_metadata_path, new_database_metadata_path);
 
     String old_path_to_table_symlinks;
@@ -699,9 +702,9 @@ void DatabaseAtomic::renameDatabase(ContextPtr query_context, const String & new
             snapshot.database = database_name;
         }
 
-        path_to_metadata_symlink = fs::path("metadata") / new_name_escaped;
+        path_to_metadata_symlink = root_path / "metadata" / new_name_escaped;
         old_path_to_table_symlinks = path_to_table_symlinks;
-        path_to_table_symlinks = fs::path("data") / new_name_escaped / "";
+        path_to_table_symlinks = root_path / "data" / new_name_escaped / "";
     }
 
     if (db_disk->isSymlinkSupported())
diff --git a/src/Databases/DatabaseAtomic.h b/src/Databases/DatabaseAtomic.h
index 7e9091286355..b63451757109 100644
--- a/src/Databases/DatabaseAtomic.h
+++ b/src/Databases/DatabaseAtomic.h
@@ -88,8 +88,9 @@ class DatabaseAtomic : public DatabaseOrdinary
     NameToPathMap table_name_to_path TSA_GUARDED_BY(mutex);
 
     DetachedTables detached_tables TSA_GUARDED_BY(mutex);
-    String path_to_table_symlinks;
-    String path_to_metadata_symlink;
+    std::filesystem::path root_path;
+    std::filesystem::path path_to_table_symlinks;
+    std::filesystem::path path_to_metadata_symlink;
     const UUID db_uuid;
 
     LoadTaskPtr startup_atomic_database_task TSA_GUARDED_BY(mutex);
diff --git a/src/Databases/DatabasesOverlay.cpp b/src/Databases/DatabasesOverlay.cpp
index e5acc48b7dbf..a0c8549b30e1 100644
--- a/src/Databases/DatabasesOverlay.cpp
+++ b/src/Databases/DatabasesOverlay.cpp
@@ -64,7 +64,7 @@ void DatabasesOverlay::createTable(ContextPtr context_, const String & table_nam
     }
     throw Exception(
         ErrorCodes::LOGICAL_ERROR,
-        "There is no databases for CREATE TABLE `{}` query in database `{}` (engine {})",
+        "There are no databases for CREATE TABLE `{}` query in database `{}` (engine {})",
         table_name,
         getDatabaseName(),
         getEngineName());
@@ -82,7 +82,7 @@ void DatabasesOverlay::dropTable(ContextPtr context_, const String & table_name,
     }
     throw Exception(
         ErrorCodes::LOGICAL_ERROR,
-        "There is no databases for DROP TABLE `{}` query in database `{}` (engine {})",
+        "There are no databases for DROP TABLE `{}` query in database `{}` (engine {})",
         table_name,
         getDatabaseName(),
         getEngineName());
@@ -105,7 +105,7 @@ void DatabasesOverlay::attachTable(
     }
     throw Exception(
         ErrorCodes::LOGICAL_ERROR,
-        "There is no databases for ATTACH TABLE `{}` query in database `{}` (engine {})",
+        "There are no databases for ATTACH TABLE `{}` query in database `{}` (engine {})",
         table_name,
         getDatabaseName(),
         getEngineName());
@@ -121,7 +121,7 @@ StoragePtr DatabasesOverlay::detachTable(ContextPtr context_, const String & tab
     }
     throw Exception(
         ErrorCodes::LOGICAL_ERROR,
-        "There is no databases for DETACH TABLE `{}` query in database `{}` (engine {})",
+        "There are no databases for DETACH TABLE `{}` query in database `{}` (engine {})",
         table_name,
         getDatabaseName(),
         getEngineName());
@@ -256,7 +256,7 @@ void DatabasesOverlay::alterTable(ContextPtr local_context, const StorageID & ta
     }
     throw Exception(
         ErrorCodes::LOGICAL_ERROR,
-        "There is no databases for ALTER TABLE `{}` query in database `{}` (engine {})",
+        "There are no databases for ALTER TABLE `{}` query in database `{}` (engine {})",
         table_id.table_name,
         getDatabaseName(),
         getEngineName());
@@ -314,4 +314,251 @@ DatabaseTablesIteratorPtr DatabasesOverlay::getTablesIterator(ContextPtr context
     return std::make_unique<DatabaseTablesSnapshotIterator>(std::move(tables), getDatabaseName());
 }
 
+bool DatabasesOverlay::canContainMergeTreeTables() const
+{
+    for (const auto & db : databases)
+        if (db->canContainMergeTreeTables())
+            return true;
+    return false;
+}
+
+bool DatabasesOverlay::canContainDistributedTables() const
+{
+    for (const auto & db : databases)
+        if (db->canContainDistributedTables())
+            return true;
+    return false;
+}
+
+void DatabasesOverlay::loadStoredObjects(ContextMutablePtr local_context, LoadingStrictnessLevel mode)
+{
+    for (auto & db : databases)
+        if (!db->isReadOnly())
+            db->loadStoredObjects(local_context, mode);
+}
+
+bool DatabasesOverlay::supportsLoadingInTopologicalOrder() const
+{
+    for (const auto & db : databases)
+        if (db->supportsLoadingInTopologicalOrder())
+            return true;
+    return false;
+}
+
+void DatabasesOverlay::beforeLoadingMetadata(ContextMutablePtr local_context, LoadingStrictnessLevel mode)
+{
+    for (auto & db : databases)
+        if (!db->isReadOnly())
+            db->beforeLoadingMetadata(local_context, mode);
+}
+
+void DatabasesOverlay::loadTablesMetadata(ContextPtr local_context, ParsedTablesMetadata & metadata, bool is_startup)
+{
+    for (auto & db : databases)
+        if (!db->isReadOnly())
+            db->loadTablesMetadata(local_context, metadata, is_startup);
+}
+
+void DatabasesOverlay::loadTableFromMetadata(
+    ContextMutablePtr local_context,
+    const String & file_path,
+    const QualifiedTableName & name,
+    const ASTPtr & ast,
+    LoadingStrictnessLevel mode)
+{
+    for (auto & db : databases)
+    {
+        if (db->isReadOnly())
+            continue;
+
+        try
+        {
+            db->loadTableFromMetadata(local_context, file_path, name, ast, mode);
+            return;
+        }
+        catch (...)
+        {
+            continue;
+        }
+    }
+    throw Exception(
+        ErrorCodes::LOGICAL_ERROR,
+        "There are no databases capable of loading table `{}` from path `{}` in database `{}` (engine {})",
+        name.table,
+        file_path,
+        getDatabaseName(),
+        getEngineName());
+}
+
+LoadTaskPtr DatabasesOverlay::loadTableFromMetadataAsync(
+    AsyncLoader & async_loader,
+    LoadJobSet load_after,
+    ContextMutablePtr local_context,
+    const String & file_path,
+    const QualifiedTableName & name,
+    const ASTPtr & ast,
+    LoadingStrictnessLevel mode)
+{
+    for (auto & db : databases)
+    {
+        if (db->isReadOnly())
+            continue;
+
+        try
+        {
+            return db->loadTableFromMetadataAsync(async_loader, load_after, local_context, file_path, name, ast, mode);
+        }
+        catch (...)
+        {
+            continue;
+        }
+    }
+    throw Exception(
+        ErrorCodes::LOGICAL_ERROR,
+        "There are no databases capable of loading table `{}` from path `{}` in database `{}` (engine {})",
+        name.table,
+        file_path,
+        getDatabaseName(),
+        getEngineName());
+}
+
+LoadTaskPtr DatabasesOverlay::startupTableAsync(
+    AsyncLoader & async_loader,
+    LoadJobSet startup_after,
+    const QualifiedTableName & name,
+    LoadingStrictnessLevel mode)
+{
+    for (auto & db : databases)
+    {
+        if (db->isReadOnly())
+            continue;
+
+        try
+        {
+            return db->startupTableAsync(async_loader, startup_after, name, mode);
+        }
+        catch (...)
+        {
+            continue;
+        }
+    }
+    throw Exception(
+        ErrorCodes::LOGICAL_ERROR,
+        "There are no databases capable of starting up table `{}` in database `{}` (engine {})",
+        name.table,
+        getDatabaseName(),
+        getEngineName());
+}
+
+LoadTaskPtr DatabasesOverlay::startupDatabaseAsync(
+    AsyncLoader & async_loader,
+    LoadJobSet startup_after,
+    LoadingStrictnessLevel mode)
+{
+    for (auto & db : databases)
+    {
+        if (db->isReadOnly())
+            continue;
+
+        try
+        {
+            return db->startupDatabaseAsync(async_loader, startup_after, mode);
+        }
+        catch (...)
+        {
+            continue;
+        }
+    }
+    throw Exception(
+        ErrorCodes::LOGICAL_ERROR,
+        "There are no databases capable of starting up asynchronously in database `{}` (engine {})",
+        getDatabaseName(),
+        getEngineName());
+}
+
+void DatabasesOverlay::waitTableStarted(const String & name) const
+{
+    for (const auto & db : databases)
+    {
+        if (db->isReadOnly())
+            continue;
+
+        try
+        {
+            db->waitTableStarted(name);
+            return;
+        }
+        catch (...)
+        {
+            continue;
+        }
+    }
+    throw Exception(
+        ErrorCodes::LOGICAL_ERROR,
+        "There are no databases capable of waiting for table startup `{}` in database `{}` (engine {})",
+        name,
+        getDatabaseName(),
+        getEngineName());
+}
+
+void DatabasesOverlay::waitDatabaseStarted() const
+{
+    for (const auto & db : databases)
+    {
+        if (db->isReadOnly())
+            continue;
+
+        try
+        {
+            db->waitDatabaseStarted();
+            return;
+        }
+        catch (...)
+        {
+            continue;
+        }
+    }
+    throw Exception(
+        ErrorCodes::LOGICAL_ERROR,
+        "There are no databases capable of waiting for startup in database `{}` (engine {})",
+        getDatabaseName(),
+        getEngineName());
+}
+
+void DatabasesOverlay::stopLoading()
+{
+    for (auto & db : databases)
+    {
+        if (db->isReadOnly())
+            continue;
+
+        try
+        {
+            db->stopLoading();
+            return;
+        }
+        catch (...)
+        {
+            continue;
+        }
+    }
+    throw Exception(
+        ErrorCodes::LOGICAL_ERROR,
+        "There are no databases capable of stop loading in database `{}` (engine {})",
+        getDatabaseName(),
+        getEngineName());
+}
+
+void DatabasesOverlay::checkMetadataFilenameAvailability(const String & table_name) const
+{
+    for (const auto & db : databases)
+    {
+        if (db->isReadOnly())
+            continue;
+        db->checkMetadataFilenameAvailability(table_name);
+        return;
+    }
+}
+
+
 }
diff --git a/src/Databases/DatabasesOverlay.h b/src/Databases/DatabasesOverlay.h
index 40c653e5cb50..2883844106c7 100644
--- a/src/Databases/DatabasesOverlay.h
+++ b/src/Databases/DatabasesOverlay.h
@@ -66,6 +66,40 @@ class DatabasesOverlay : public IDatabase, protected WithContext
 
     void shutdown() override;
 
+    bool canContainMergeTreeTables() const override;
+    bool canContainDistributedTables() const override;
+    void loadStoredObjects(ContextMutablePtr local_context, LoadingStrictnessLevel mode) override;
+    bool supportsLoadingInTopologicalOrder() const override;
+    void beforeLoadingMetadata(ContextMutablePtr local_context, LoadingStrictnessLevel mode) override;
+    void loadTablesMetadata(ContextPtr local_context, ParsedTablesMetadata & metadata, bool is_startup) override;
+    void loadTableFromMetadata(
+        ContextMutablePtr local_context,
+        const String & file_path,
+        const QualifiedTableName & name,
+        const ASTPtr & ast,
+        LoadingStrictnessLevel mode) override;
+    LoadTaskPtr loadTableFromMetadataAsync(
+        AsyncLoader & async_loader,
+        LoadJobSet load_after,
+        ContextMutablePtr local_context,
+        const String & file_path,
+        const QualifiedTableName & name,
+        const ASTPtr & ast,
+        LoadingStrictnessLevel mode) override;
+    [[nodiscard]] LoadTaskPtr startupTableAsync(
+        AsyncLoader & async_loader,
+        LoadJobSet startup_after,
+        const QualifiedTableName & name,
+        LoadingStrictnessLevel mode) override;
+    [[nodiscard]] LoadTaskPtr startupDatabaseAsync(
+        AsyncLoader & async_loader,
+        LoadJobSet startup_after,
+        LoadingStrictnessLevel mode) override;
+    void waitTableStarted(const String & name) const override;
+    void waitDatabaseStarted() const override;
+    void stopLoading() override;
+    void checkMetadataFilenameAvailability(const String & table_name) const override;
+
 protected:
     std::vector<DatabasePtr> databases;
     LoggerPtr log;
diff --git a/src/Disks/DiskLocal.cpp b/src/Disks/DiskLocal.cpp
index bc5181133f56..ea637bd62f3f 100644
--- a/src/Disks/DiskLocal.cpp
+++ b/src/Disks/DiskLocal.cpp
@@ -445,9 +445,11 @@ bool DiskLocal::isSymlinkNoThrow(const String & path) const
     return FS::isSymlinkNoThrow(fs::path(disk_path) / path);
 }
 
-void DiskLocal::createDirectoriesSymlink(const String & target, const String & link)
+void DiskLocal::createDirectorySymlink(const String & target, const String & link)
 {
-    fs::create_directory_symlink(fs::path(disk_path) / target, fs::path(disk_path) / link);
+    auto link_path_inside_disk = fs::path(disk_path) / link;
+    /// Symlinks will be relative.
+    fs::create_directory_symlink(fs::proximate(link_path_inside_disk.parent_path() / target, link_path_inside_disk.parent_path()), link_path_inside_disk);
 }
 
 String DiskLocal::readSymlink(const fs::path & path) const
diff --git a/src/Disks/DiskLocal.h b/src/Disks/DiskLocal.h
index 0ae633221270..79147eac6210 100644
--- a/src/Disks/DiskLocal.h
+++ b/src/Disks/DiskLocal.h
@@ -116,7 +116,7 @@ class DiskLocal : public IDisk
 
     bool isSymlinkNoThrow(const String & path) const override;
 
-    void createDirectoriesSymlink(const String & target, const String & link) override;
+    void createDirectorySymlink(const String & target, const String & link) override;
 
     String readSymlink(const fs::path & path) const override;
 
diff --git a/src/Disks/IDisk.h b/src/Disks/IDisk.h
index c9c598bc062e..a52c307cd8ed 100644
--- a/src/Disks/IDisk.h
+++ b/src/Disks/IDisk.h
@@ -384,22 +384,22 @@ class IDisk : public Space
     virtual bool isSymlink(const String &) const
     {
         throw Exception(
-            ErrorCodes::NOT_IMPLEMENTED, "Method isSymlink() is not implemented for disk type: {}", getDataSourceDescription().toString());
+            ErrorCodes::NOT_IMPLEMENTED, "Method isSymlink is not implemented for disk type: {}", getDataSourceDescription().toString());
     }
 
     virtual bool isSymlinkNoThrow(const String &) const
     {
         throw Exception(
             ErrorCodes::NOT_IMPLEMENTED,
-            "Method isSymlinkNothrow() is not implemented for disk type: {}",
+            "Method isSymlinkNothrow is not implemented for disk type: {}",
             getDataSourceDescription().toString());
     }
 
-    virtual void createDirectoriesSymlink(const String &, const String &)
+    virtual void createDirectorySymlink(const String &, const String &)
     {
         throw Exception(
             ErrorCodes::NOT_IMPLEMENTED,
-            "Method createDirectoriesSymlink() is not implemented for disk type: {}",
+            "Method createDirectorySymlink is not implemented for disk type: {}",
             getDataSourceDescription().toString());
     }
 
@@ -407,20 +407,20 @@ class IDisk : public Space
     {
         throw Exception(
             ErrorCodes::NOT_IMPLEMENTED,
-            "Method readSymlink() is not implemented for disk type: {}",
+            "Method readSymlink is not implemented for disk type: {}",
             getDataSourceDescription().toString());
     }
 
     virtual bool equivalent(const String &, const String &) const
     {
         throw Exception(
-            ErrorCodes::NOT_IMPLEMENTED, "Method equivalent() is not implemented for disk type: {}", getDataSourceDescription().toString());
+            ErrorCodes::NOT_IMPLEMENTED, "Method equivalent is not implemented for disk type: {}", getDataSourceDescription().toString());
     }
 
     virtual bool equivalentNoThrow(const String &, const String &) const
     {
         throw Exception(
-            ErrorCodes::NOT_IMPLEMENTED, "Method equivalent() is not implemented for disk type: {}", getDataSourceDescription().toString());
+            ErrorCodes::NOT_IMPLEMENTED, "Method equivalent is not implemented for disk type: {}", getDataSourceDescription().toString());
     }
 
     /// Truncate file to specified size.
@@ -498,7 +498,7 @@ class IDisk : public Space
     {
         throw Exception(
             ErrorCodes::NOT_IMPLEMENTED,
-            "Method getMetadataStorage() is not implemented for disk type: {}",
+            "Method getMetadataStorage is not implemented for disk type: {}",
             getDataSourceDescription().toString());
     }
 
@@ -532,7 +532,7 @@ class IDisk : public Space
     {
         throw Exception(
             ErrorCodes::NOT_IMPLEMENTED,
-            "Method getObjectStorage() is not implemented for disk type: {}",
+            "Method getObjectStorage is not implemented for disk type: {}",
             getDataSourceDescription().toString());
     }
 
@@ -543,7 +543,7 @@ class IDisk : public Space
     {
         throw Exception(
             ErrorCodes::NOT_IMPLEMENTED,
-            "Method createDiskObjectStorage() is not implemented for disk type: {}",
+            "Method createDiskObjectStorage is not implemented for disk type: {}",
             getDataSourceDescription().toString());
     }
 
@@ -565,7 +565,7 @@ class IDisk : public Space
     {
         throw Exception(
             ErrorCodes::NOT_IMPLEMENTED,
-            "Method getS3StorageClient() is not implemented for disk type: {}",
+            "Method getS3StorageClient is not implemented for disk type: {}",
             getDataSourceDescription().toString());
     }
 
diff --git a/src/Disks/ObjectStorages/IObjectStorage.cpp b/src/Disks/ObjectStorages/IObjectStorage.cpp
index ce5f06e8f25f..da10528bbedf 100644
--- a/src/Disks/ObjectStorages/IObjectStorage.cpp
+++ b/src/Disks/ObjectStorages/IObjectStorage.cpp
@@ -84,7 +84,7 @@ void IObjectStorage::copyObjectToAnotherObjectStorage( // NOLINT
 
 const std::string & IObjectStorage::getCacheName() const
 {
-    throw Exception(ErrorCodes::NOT_IMPLEMENTED, "getCacheName() is not implemented for object storage");
+    throw Exception(ErrorCodes::NOT_IMPLEMENTED, "getCacheName is not implemented for object storage");
 }
 
 ReadSettings IObjectStorage::patchSettings(const ReadSettings & read_settings) const
diff --git a/src/Disks/ObjectStorages/Local/LocalObjectStorage.cpp b/src/Disks/ObjectStorages/Local/LocalObjectStorage.cpp
index ea09f29b428d..e24732bee8c7 100644
--- a/src/Disks/ObjectStorages/Local/LocalObjectStorage.cpp
+++ b/src/Disks/ObjectStorages/Local/LocalObjectStorage.cpp
@@ -209,7 +209,7 @@ std::unique_ptr<IObjectStorage> LocalObjectStorage::cloneObjectStorage(
     const Poco::Util::AbstractConfiguration & /* config */,
     const std::string & /* config_prefix */, ContextPtr /* context */)
 {
-    throw Exception(ErrorCodes::NOT_IMPLEMENTED, "cloneObjectStorage() is not implemented for LocalObjectStorage");
+    throw Exception(ErrorCodes::NOT_IMPLEMENTED, "cloneObjectStorage is not implemented for LocalObjectStorage");
 }
 
 ObjectStorageKey
diff --git a/src/Disks/ObjectStorages/Web/WebObjectStorage.cpp b/src/Disks/ObjectStorages/Web/WebObjectStorage.cpp
index 35abc0ed0dfa..e5d47a54cebc 100644
--- a/src/Disks/ObjectStorages/Web/WebObjectStorage.cpp
+++ b/src/Disks/ObjectStorages/Web/WebObjectStorage.cpp
@@ -287,7 +287,7 @@ std::unique_ptr<IObjectStorage> WebObjectStorage::cloneObjectStorage(
     const Poco::Util::AbstractConfiguration & /* config */,
     const std::string & /* config_prefix */, ContextPtr /* context */)
 {
-    throw Exception(ErrorCodes::NOT_IMPLEMENTED, "cloneObjectStorage() is not implemented for WebObjectStorage");
+    throw Exception(ErrorCodes::NOT_IMPLEMENTED, "cloneObjectStorage is not implemented for WebObjectStorage");
 }
 
 }
diff --git a/src/Formats/NumpyDataTypes.h b/src/Formats/NumpyDataTypes.h
index 6ccdf65f4576..fbb0a11c5593 100644
--- a/src/Formats/NumpyDataTypes.h
+++ b/src/Formats/NumpyDataTypes.h
@@ -44,9 +44,9 @@ class NumpyDataType
     Endianness getEndianness() const { return endianness; }
 
     virtual NumpyDataTypeIndex getTypeIndex() const = 0;
-    virtual size_t getSize() const { throw DB::Exception(DB::ErrorCodes::NOT_IMPLEMENTED, "Function getSize() is not implemented"); }
-    virtual void setSize(size_t) { throw DB::Exception(DB::ErrorCodes::NOT_IMPLEMENTED, "Function setSize() is not implemented"); }
-    virtual String str() const { throw DB::Exception(DB::ErrorCodes::NOT_IMPLEMENTED, "Function str() is not implemented"); }
+    virtual size_t getSize() const { throw DB::Exception(DB::ErrorCodes::NOT_IMPLEMENTED, "Function getSize is not implemented"); }
+    virtual void setSize(size_t) { throw DB::Exception(DB::ErrorCodes::NOT_IMPLEMENTED, "Function setSize is not implemented"); }
+    virtual String str() const { throw DB::Exception(DB::ErrorCodes::NOT_IMPLEMENTED, "Function str is not implemented"); }
 
 protected:
     Endianness endianness;
diff --git a/src/Functions/byteSwap.cpp b/src/Functions/byteSwap.cpp
index 9594e583f89b..d9c76aada0fb 100644
--- a/src/Functions/byteSwap.cpp
+++ b/src/Functions/byteSwap.cpp
@@ -30,7 +30,7 @@ T byteSwap(T x)
 template <typename T>
 T byteSwap(T)
 {
-    throw Exception(ErrorCodes::NOT_IMPLEMENTED, "byteSwap() is not implemented for {} datatype", demangle(typeid(T).name()));
+    throw Exception(ErrorCodes::NOT_IMPLEMENTED, "byteSwap is not implemented for {} datatype", demangle(typeid(T).name()));
 }
 
 template <typename T>
diff --git a/src/IO/Archives/ZipArchiveWriter.cpp b/src/IO/Archives/ZipArchiveWriter.cpp
index df263ceb29bf..ac72c3ded02e 100644
--- a/src/IO/Archives/ZipArchiveWriter.cpp
+++ b/src/IO/Archives/ZipArchiveWriter.cpp
@@ -207,12 +207,12 @@ class ZipArchiveWriter::StreamInfo
 
     static long seekFunc(void *, void *, ZPOS64_T, int) // NOLINT(google-runtime-int)
     {
-        throw Exception(ErrorCodes::NOT_IMPLEMENTED, "StreamInfo::seek() is not implemented");
+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, "StreamInfo::seek is not implemented");
     }
 
     static unsigned long readFileFunc(void *, void *, void *, unsigned long) // NOLINT(google-runtime-int)
     {
-        throw Exception(ErrorCodes::NOT_IMPLEMENTED, "StreamInfo::readFile() is not implemented");
+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, "StreamInfo::readFile is not implemented");
     }
 
     std::unique_ptr<WriteBuffer> write_buffer;
diff --git a/src/Interpreters/DatabaseCatalog.cpp b/src/Interpreters/DatabaseCatalog.cpp
index e546271bbc6f..2d902b3c36ca 100644
--- a/src/Interpreters/DatabaseCatalog.cpp
+++ b/src/Interpreters/DatabaseCatalog.cpp
@@ -1094,6 +1094,9 @@ void DatabaseCatalog::loadMarkedAsDroppedTables()
         dropped_metadata.emplace(std::move(full_path), std::move(dropped_id));
     }
 
+    if (dropped_metadata.empty())
+        return;
+
     LOG_INFO(log, "Found {} partially dropped tables. Will load them and retry removal.", dropped_metadata.size());
 
     ThreadPoolCallbackRunnerLocal<void> runner(getDatabaseCatalogDropTablesThreadPool().get(), "DropTables");
diff --git a/src/Interpreters/loadMetadata.cpp b/src/Interpreters/loadMetadata.cpp
index 2be58620b3f4..7ade5c6031ab 100644
--- a/src/Interpreters/loadMetadata.cpp
+++ b/src/Interpreters/loadMetadata.cpp
@@ -1,5 +1,4 @@
 #include <Common/PoolId.h>
-#include <Common/ThreadPool.h>
 #include <Common/thread_local_rng.h>
 
 #include <Parsers/ParserCreateQuery.h>
@@ -18,7 +17,6 @@
 #include <Storages/StorageMaterializedView.h>
 
 #include <IO/ReadBufferFromFile.h>
-#include <IO/ReadHelpers.h>
 
 #include <Core/Settings.h>
 #include <Common/CurrentMetrics.h>
@@ -33,6 +31,7 @@
 
 #define ORDINARY_TO_ATOMIC_PREFIX ".tmp_convert."
 
+
 namespace fs = std::filesystem;
 
 namespace DB
@@ -104,6 +103,10 @@ static void loadDatabase(
     const String & database_path,
     bool force_restore_data)
 {
+    /// If it is already loaded.
+    if (DatabaseCatalog::instance().isDatabaseExist(database))
+        return;
+
     String database_attach_query;
     String database_metadata_file = database_path + ".sql";
 
@@ -198,11 +201,14 @@ LoadTaskPtrs loadMetadata(ContextMutablePtr context, const String & default_data
         }
     }
 
-
     auto metadata_dir_path = fs::path("metadata");
 
     /// Loop over databases.
     std::map<String, String> databases;
+
+    /// Some databases don't have an .sql metadata file.
+    std::map<String, String> orphan_directories_and_symlinks;
+
     for (const auto it = db_disk->iterateDirectory(metadata_dir_path); it->isValid(); it->next())
     {
         auto sub_path = fs::path(it->path());
@@ -210,17 +216,22 @@ LoadTaskPtrs loadMetadata(ContextMutablePtr context, const String & default_data
             sub_path = sub_path.parent_path();
 
         if (db_disk->isSymlinkSupported() && db_disk->isSymlink(sub_path))
+        {
+            String db_name = sub_path.filename().string();
+            if (!isSystemOrInformationSchema(db_name))
+                orphan_directories_and_symlinks.emplace(unescapeForFileName(db_name), sub_path);
             continue;
+        }
 
         if (db_disk->existsDirectory(sub_path))
             continue;
 
         const auto current_file = sub_path.filename().string();
 
-        /// TODO: DETACH DATABASE PERMANENTLY ?
         if (fs::path(current_file).extension() == ".sql")
         {
             String db_name = fs::path(current_file).stem();
+            orphan_directories_and_symlinks.erase(db_name);
             if (!isSystemOrInformationSchema(db_name))
                 databases.emplace(unescapeForFileName(db_name), metadata_dir_path / db_name);
         }
@@ -260,7 +271,13 @@ LoadTaskPtrs loadMetadata(ContextMutablePtr context, const String & default_data
         loaded_databases.insert({name, DatabaseCatalog::instance().getDatabase(name)});
     }
 
-    auto mode = getLoadingStrictnessLevel(/* attach */ true, /* force_attach */ true, has_force_restore_data_flag, /*secondary*/ false);
+    for (const auto & [name, db_path] : orphan_directories_and_symlinks)
+    {
+        loadDatabase(context, name, db_path, has_force_restore_data_flag);
+        loaded_databases.insert({name, DatabaseCatalog::instance().getDatabase(name)});
+    }
+
+    auto mode = getLoadingStrictnessLevel(/* attach */ true, /* force_attach */ true, has_force_restore_data_flag, /* secondary */ false);
     TablesLoader loader{context, std::move(loaded_databases), mode};
     auto load_tasks = loader.loadTablesAsync();
     auto startup_tasks = loader.startupTablesAsync();
@@ -292,6 +309,10 @@ LoadTaskPtrs loadMetadata(ContextMutablePtr context, const String & default_data
 
 static void loadSystemDatabaseImpl(ContextMutablePtr context, const String & database_name, const String & default_engine)
 {
+    /// If it is already loaded.
+    if (DatabaseCatalog::instance().isDatabaseExist(database_name))
+        return;
+
     auto db_disk = Context::getGlobalContextInstance()->getDatabaseDisk();
 
     String database_name_escaped = escapeForFileName(database_name);
@@ -522,7 +543,8 @@ void convertDatabasesEnginesIfNeed(const LoadTaskPtrs & load_metadata, ContextMu
 
 LoadTaskPtrs loadMetadataSystem(ContextMutablePtr context, bool async_load_system_database)
 {
-    loadSystemDatabaseImpl(context, DatabaseCatalog::SYSTEM_DATABASE, "Atomic");
+    loadSystemDatabaseImpl(context, DatabaseCatalog::SYSTEM_DATABASE,
+        context->getApplicationType() == Context::ApplicationType::SERVER ? "Atomic" : "Memory");
     loadSystemDatabaseImpl(context, DatabaseCatalog::INFORMATION_SCHEMA, "Memory");
     loadSystemDatabaseImpl(context, DatabaseCatalog::INFORMATION_SCHEMA_UPPERCASE, "Memory");
 
diff --git a/src/Processors/Transforms/WindowTransform.cpp b/src/Processors/Transforms/WindowTransform.cpp
index c64e817ffae3..98c21a341fdb 100644
--- a/src/Processors/Transforms/WindowTransform.cpp
+++ b/src/Processors/Transforms/WindowTransform.cpp
@@ -1532,7 +1532,7 @@ namespace recurrent_detail
 {
     template<typename T> T getValue(const WindowTransform * /*transform*/, size_t /*function_index*/, size_t /*column_index*/, RowNumber /*row*/)
     {
-        throw Exception(ErrorCodes::NOT_IMPLEMENTED, "recurrent_detail::getValue() is not implemented for {} type", typeid(T).name());
+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, "recurrent_detail::getValue is not implemented for {} type", typeid(T).name());
     }
 
     template<> Float64 getValue<Float64>(const WindowTransform * transform, size_t function_index, size_t column_index, RowNumber row)
@@ -1545,7 +1545,7 @@ namespace recurrent_detail
     template<typename T> void setValueToOutputColumn(const WindowTransform * /*transform*/, size_t /*function_index*/, T /*value*/)
     {
         throw Exception(ErrorCodes::NOT_IMPLEMENTED,
-                        "recurrent_detail::setValueToOutputColumn() is not implemented for {} type", typeid(T).name());
+                        "recurrent_detail::setValueToOutputColumn is not implemented for {} type", typeid(T).name());
     }
 
     template<> void setValueToOutputColumn<Float64>(const WindowTransform * transform, size_t function_index, Float64 value)
diff --git a/src/Storages/ObjectStorageQueue/ObjectStorageQueueIFileMetadata.h b/src/Storages/ObjectStorageQueue/ObjectStorageQueueIFileMetadata.h
index a970e1422b60..28a97694f2c2 100644
--- a/src/Storages/ObjectStorageQueue/ObjectStorageQueueIFileMetadata.h
+++ b/src/Storages/ObjectStorageQueue/ObjectStorageQueueIFileMetadata.h
@@ -132,7 +132,7 @@ class ObjectStorageQueueIFileMetadata
 
     virtual SetProcessingResponseIndexes prepareProcessingRequestsImpl(Coordination::Requests &)
     {
-        throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Method prepareProcesingRequestsImpl() is not implemented");
+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Method prepareProcesingRequestsImpl is not implemented");
     }
     void prepareFailedRequestsImpl(Coordination::Requests & requests, bool retriable);
 
diff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp
index 9e427aed1367..9f956c43d98c 100644
--- a/src/Storages/StorageReplicatedMergeTree.cpp
+++ b/src/Storages/StorageReplicatedMergeTree.cpp
@@ -6650,7 +6650,7 @@ void StorageReplicatedMergeTree::alter(
         if (auto txn = query_context->getZooKeeperMetadataTransaction())
         {
             /// It would be better to clone ops instead of moving, so we could retry on ZBADVERSION,
-            /// but clone() is not implemented for Coordination::Request.
+            /// but clone is not implemented for Coordination::Request.
             txn->moveOpsTo(ops);
             /// NOTE: IDatabase::alterTable(...) is called when executing ALTER_METADATA queue entry without query context,
             /// so we have to update metadata of DatabaseReplicated here.
diff --git a/src/Storages/System/StorageSystemProjections.h b/src/Storages/System/StorageSystemProjections.h
index 46e73cec6cd3..c81ac22cd7cb 100644
--- a/src/Storages/System/StorageSystemProjections.h
+++ b/src/Storages/System/StorageSystemProjections.h
@@ -12,7 +12,7 @@ class StorageSystemProjections : public IStorage
 public:
     explicit StorageSystemProjections(const StorageID & table_id_);
 
-    std::string getName() const override { return "StorageSystemProjections"; }
+    std::string getName() const override { return "SystemProjections"; }
 
     void read(
         QueryPlan & query_plan,
