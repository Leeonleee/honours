diff --git a/dbms/src/Functions/FunctionBinaryArithmetic.h b/dbms/src/Functions/FunctionBinaryArithmetic.h
index 233598370add..66eb7be01cb1 100644
--- a/dbms/src/Functions/FunctionBinaryArithmetic.h
+++ b/dbms/src/Functions/FunctionBinaryArithmetic.h
@@ -547,43 +547,54 @@ class FunctionBinaryArithmetic : public IFunction
 
     FunctionOverloadResolverPtr getFunctionForIntervalArithmetic(const DataTypePtr & type0, const DataTypePtr & type1) const
     {
+        bool first_is_date_or_datetime = isDateOrDateTime(type0);
+        bool second_is_date_or_datetime = isDateOrDateTime(type1);
+
+        /// Exactly one argument must be Date or DateTime
+        if (first_is_date_or_datetime == second_is_date_or_datetime)
+            return {};
+
         /// Special case when the function is plus or minus, one of arguments is Date/DateTime and another is Interval.
         /// We construct another function (example: addMonths) and call it.
 
-        bool function_is_plus = std::is_same_v<Op<UInt8, UInt8>, PlusImpl<UInt8, UInt8>>;
-        bool function_is_minus = std::is_same_v<Op<UInt8, UInt8>, MinusImpl<UInt8, UInt8>>;
+        static constexpr bool function_is_plus = std::is_same_v<Op<UInt8, UInt8>, PlusImpl<UInt8, UInt8>>;
+        static constexpr bool function_is_minus = std::is_same_v<Op<UInt8, UInt8>, MinusImpl<UInt8, UInt8>>;
 
         if (!function_is_plus && !function_is_minus)
             return {};
 
-        int interval_arg = 1;
-        const DataTypeInterval * interval_data_type = checkAndGetDataType<DataTypeInterval>(type1.get());
-        if (!interval_data_type)
+        const DataTypePtr & type_time = first_is_date_or_datetime ? type0 : type1;
+        const DataTypePtr & type_interval = first_is_date_or_datetime ? type1 : type0;
+
+        bool interval_is_number = isNumber(type_interval);
+
+        const DataTypeInterval * interval_data_type = nullptr;
+        if (!interval_is_number)
         {
-            interval_arg = 0;
-            interval_data_type = checkAndGetDataType<DataTypeInterval>(type0.get());
+            interval_data_type = checkAndGetDataType<DataTypeInterval>(type_interval.get());
+
+            if (!interval_data_type)
+                return {};
         }
-        if (!interval_data_type)
-            return {};
 
-        if (interval_arg == 0 && function_is_minus)
+        if (second_is_date_or_datetime && function_is_minus)
             throw Exception("Wrong order of arguments for function " + getName() + ": argument of type Interval cannot be first.",
                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
 
-        const DataTypeDate * date_data_type = checkAndGetDataType<DataTypeDate>(interval_arg == 0 ? type1.get() : type0.get());
-        const DataTypeDateTime * date_time_data_type = nullptr;
-        if (!date_data_type)
+        std::string function_name;
+        if (interval_data_type)
         {
-            date_time_data_type = checkAndGetDataType<DataTypeDateTime>(interval_arg == 0 ? type1.get() : type0.get());
-            if (!date_time_data_type)
-                throw Exception("Wrong argument types for function " + getName() + ": if one argument is Interval, then another must be Date or DateTime.",
-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+            function_name = String(function_is_plus ? "add" : "subtract") + interval_data_type->getKind().toString() + 's';
+        }
+        else
+        {
+            if (isDate(type_time))
+                function_name = function_is_plus ? "addDays" : "subtractDays";
+            else
+                function_name = function_is_plus ? "addSeconds" : "subtractSeconds";
         }
 
-        std::stringstream function_name;
-        function_name << (function_is_plus ? "add" : "subtract") << interval_data_type->getKind().toString() << 's';
-
-        return FunctionFactory::instance().get(function_name.str(), context);
+        return FunctionFactory::instance().get(function_name, context);
     }
 
     bool isAggregateMultiply(const DataTypePtr & type0, const DataTypePtr & type1) const
@@ -627,7 +638,6 @@ class FunctionBinaryArithmetic : public IFunction
 
         AggregateFunctionPtr function = column.getAggregateFunction();
 
-
         size_t size = agg_state_is_const ? 1 : input_rows_count;
 
         auto column_to = ColumnAggregateFunction::create(function);
@@ -716,7 +726,7 @@ class FunctionBinaryArithmetic : public IFunction
         ColumnNumbers new_arguments = arguments;
 
         /// Interval argument must be second.
-        if (WhichDataType(block.getByPosition(arguments[0]).type).isInterval())
+        if (WhichDataType(block.getByPosition(arguments[1]).type).isDateOrDateTime())
             std::swap(new_arguments[0], new_arguments[1]);
 
         /// Change interval argument type to its representation
@@ -776,7 +786,7 @@ class FunctionBinaryArithmetic : public IFunction
                 new_arguments[i].type = arguments[i];
 
             /// Interval argument must be second.
-            if (WhichDataType(new_arguments[0].type).isInterval())
+            if (WhichDataType(new_arguments[1].type).isDateOrDateTime())
                 std::swap(new_arguments[0], new_arguments[1]);
 
             /// Change interval argument to its representation
diff --git a/dbms/src/Functions/FunctionDateOrDateTimeAddInterval.h b/dbms/src/Functions/FunctionDateOrDateTimeAddInterval.h
index 8e57dfa23b50..fe2a163fc8ab 100644
--- a/dbms/src/Functions/FunctionDateOrDateTimeAddInterval.h
+++ b/dbms/src/Functions/FunctionDateOrDateTimeAddInterval.h
@@ -4,10 +4,11 @@
 #include <DataTypes/DataTypeDateTime.h>
 #include <DataTypes/DataTypeDateTime64.h>
 
-#include <Columns/ColumnVector.h>
+#include <Columns/ColumnsNumber.h>
 
 #include <Functions/IFunctionImpl.h>
 #include <Functions/FunctionHelpers.h>
+#include <Functions/castTypeToEither.h>
 #include <Functions/extractTimeZoneFromFunctionArguments.h>
 
 #include <IO/WriteHelpers.h>
@@ -31,7 +32,7 @@ namespace ErrorCodes
 template <typename T>
 struct AddOnDateTime64DefaultImpl
 {
-    /*explicit*/ AddOnDateTime64DefaultImpl(UInt32 scale_ = 0)
+    AddOnDateTime64DefaultImpl(UInt32 scale_ = 0)
         : scale_multiplier(DecimalUtils::scaleMultiplier<DateTime64::NativeType>(scale_))
     {}
 
@@ -40,7 +41,7 @@ struct AddOnDateTime64DefaultImpl
     {
         const auto components = DecimalUtils::splitWithScaleMultiplier(t, scale_multiplier);
 
-        const auto whole = static_cast<const T*>(this)->execute(static_cast<UInt32>(components.whole), delta, time_zone);
+        const auto whole = static_cast<const T *>(this)->execute(static_cast<UInt32>(components.whole), delta, time_zone);
         return DecimalUtils::decimalFromComponentsWithMultiplier<DateTime64>(static_cast<DateTime64::NativeType>(whole), components.fractional, scale_multiplier);
     }
 
@@ -248,23 +249,26 @@ struct Adder
     {}
 
     template <typename FromVectorType, typename ToVectorType>
-    void vector_vector(const FromVectorType & vec_from, ToVectorType & vec_to, const IColumn & delta, const DateLUTImpl & time_zone) const
+    void NO_INLINE vector_constant(const FromVectorType & vec_from, ToVectorType & vec_to, Int64 delta, const DateLUTImpl & time_zone) const
     {
         size_t size = vec_from.size();
         vec_to.resize(size);
 
         for (size_t i = 0; i < size; ++i)
-            vec_to[i] = transform.execute(vec_from[i], delta.getInt(i), time_zone);
+            vec_to[i] = transform.execute(vec_from[i], delta, time_zone);
     }
 
     template <typename FromVectorType, typename ToVectorType>
-    void vector_constant(const FromVectorType & vec_from, ToVectorType & vec_to, Int64 delta, const DateLUTImpl & time_zone) const
+    void vector_vector(const FromVectorType & vec_from, ToVectorType & vec_to, const IColumn & delta, const DateLUTImpl & time_zone) const
     {
         size_t size = vec_from.size();
         vec_to.resize(size);
 
-        for (size_t i = 0; i < size; ++i)
-            vec_to[i] = transform.execute(vec_from[i], delta, time_zone);
+        castTypeToEither<
+            ColumnUInt8, ColumnUInt16, ColumnUInt32, ColumnUInt64,
+            ColumnInt8, ColumnInt16, ColumnInt32, ColumnInt64,
+            ColumnFloat32, ColumnFloat64>(
+            &delta, [&](const auto & column){ vector_vector(vec_from, vec_to, column, time_zone, size); return true; });
     }
 
     template <typename FromType, typename ToVectorType>
@@ -273,8 +277,26 @@ struct Adder
         size_t size = delta.size();
         vec_to.resize(size);
 
+        castTypeToEither<
+            ColumnUInt8, ColumnUInt16, ColumnUInt32, ColumnUInt64,
+            ColumnInt8, ColumnInt16, ColumnInt32, ColumnInt64,
+            ColumnFloat32, ColumnFloat64>(
+            &delta, [&](const auto & column){ constant_vector(from, vec_to, column, time_zone, size); return true; });
+    }
+
+private:
+    template <typename FromVectorType, typename ToVectorType, typename DeltaColumnType>
+    void NO_INLINE vector_vector(const FromVectorType & vec_from, ToVectorType & vec_to, const DeltaColumnType & delta, const DateLUTImpl & time_zone, size_t size) const
+    {
+        for (size_t i = 0; i < size; ++i)
+            vec_to[i] = transform.execute(vec_from[i], delta.getData()[i], time_zone);
+    }
+
+    template <typename FromType, typename ToVectorType, typename DeltaColumnType>
+    void NO_INLINE constant_vector(const FromType & from, ToVectorType & vec_to, const DeltaColumnType & delta, const DateLUTImpl & time_zone, size_t size) const
+    {
         for (size_t i = 0; i < size; ++i)
-            vec_to[i] = transform.execute(from, delta.getInt(i), time_zone);
+            vec_to[i] = transform.execute(from, delta.getData()[i], time_zone);
     }
 };
 
@@ -361,7 +383,7 @@ class FunctionDateOrDateTimeAddInterval : public IFunction
         if (arguments.size() == 2)
         {
             if (!isDateOrDateTime(arguments[0].type))
-                throw Exception{"Illegal type " + arguments[0].type->getName() + " of argument of function " + getName() +
+                throw Exception{"Illegal type " + arguments[0].type->getName() + " of first argument of function " + getName() +
                     ". Should be a date or a date with time", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};
         }
         else
@@ -452,7 +474,7 @@ class FunctionDateOrDateTimeAddInterval : public IFunction
             DateTimeAddIntervalImpl<DataTypeDateTime64, TransformResultDataType<DataTypeDateTime64>, Transform>::execute(Transform{datetime64_type->getScale()}, block, arguments, result);
         }
         else
-            throw Exception("Illegal type " + block.getByPosition(arguments[0]).type->getName() + " of argument of function " + getName(),
+            throw Exception("Illegal type " + block.getByPosition(arguments[0]).type->getName() + " of first argument of function " + getName(),
                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
     }
 };
diff --git a/dbms/src/Functions/castTypeToEither.h b/dbms/src/Functions/castTypeToEither.h
index c041a4aaad09..bff4047768df 100644
--- a/dbms/src/Functions/castTypeToEither.h
+++ b/dbms/src/Functions/castTypeToEither.h
@@ -5,10 +5,8 @@
 namespace DB
 {
 
-class IDataType;
-
-template <typename... Ts, typename F>
-static bool castTypeToEither(const IDataType * type, F && f)
+template <typename... Ts, typename T, typename F>
+static bool castTypeToEither(const T * type, F && f)
 {
     /// XXX can't use && here because gcc-7 complains about parentheses around && within ||
     return ((typeid_cast<const Ts *>(type) ? f(*typeid_cast<const Ts *>(type)) : false) || ...);
