diff --git a/src/Coordination/KeeperDispatcher.cpp b/src/Coordination/KeeperDispatcher.cpp
index f6973b30fb2e..92aeac425d5e 100644
--- a/src/Coordination/KeeperDispatcher.cpp
+++ b/src/Coordination/KeeperDispatcher.cpp
@@ -296,7 +296,7 @@ bool KeeperDispatcher::putRequest(const Coordination::ZooKeeperRequestPtr & requ
     return true;
 }
 
-void KeeperDispatcher::initialize(const Poco::Util::AbstractConfiguration & config, bool standalone_keeper, bool start_async)
+void KeeperDispatcher::initialize(const Poco::Util::AbstractConfiguration & config, bool standalone_keeper, bool start_async, const MultiVersion<Macros>::Version & macros)
 {
     LOG_DEBUG(log, "Initializing storage dispatcher");
 
@@ -307,7 +307,7 @@ void KeeperDispatcher::initialize(const Poco::Util::AbstractConfiguration & conf
     responses_thread = ThreadFromGlobalPool([this] { responseThread(); });
     snapshot_thread = ThreadFromGlobalPool([this] { snapshotThread(); });
 
-    snapshot_s3.startup(config);
+    snapshot_s3.startup(config, macros);
 
     server = std::make_unique<KeeperServer>(configuration_and_settings, config, responses_queue, snapshots_queue, snapshot_s3);
 
@@ -687,7 +687,7 @@ bool KeeperDispatcher::isServerActive() const
     return checkInit() && hasLeader() && !server->isRecovering();
 }
 
-void KeeperDispatcher::updateConfiguration(const Poco::Util::AbstractConfiguration & config)
+void KeeperDispatcher::updateConfiguration(const Poco::Util::AbstractConfiguration & config, const MultiVersion<Macros>::Version & macros)
 {
     auto diff = server->getConfigurationDiff(config);
     if (diff.empty())
@@ -704,7 +704,7 @@ void KeeperDispatcher::updateConfiguration(const Poco::Util::AbstractConfigurati
             throw Exception(ErrorCodes::SYSTEM_ERROR, "Cannot push configuration update to queue");
     }
 
-    snapshot_s3.updateS3Configuration(config);
+    snapshot_s3.updateS3Configuration(config, macros);
 }
 
 void KeeperDispatcher::updateKeeperStatLatency(uint64_t process_time_ms)
diff --git a/src/Coordination/KeeperDispatcher.h b/src/Coordination/KeeperDispatcher.h
index 632e5e65e5fe..ff902d8e0366 100644
--- a/src/Coordination/KeeperDispatcher.h
+++ b/src/Coordination/KeeperDispatcher.h
@@ -15,6 +15,8 @@
 #include <Coordination/Keeper4LWInfo.h>
 #include <Coordination/KeeperConnectionStats.h>
 #include <Coordination/KeeperSnapshotManagerS3.h>
+#include <Common/MultiVersion.h>
+#include <Common/Macros.h>
 
 namespace DB
 {
@@ -109,7 +111,8 @@ class KeeperDispatcher
 
     /// Initialization from config.
     /// standalone_keeper -- we are standalone keeper application (not inside clickhouse server)
-    void initialize(const Poco::Util::AbstractConfiguration & config, bool standalone_keeper, bool start_async);
+    /// 'macros' are used to substitute macros in endpoint of disks
+    void initialize(const Poco::Util::AbstractConfiguration & config, bool standalone_keeper, bool start_async, const MultiVersion<Macros>::Version & macros);
 
     void startServer();
 
@@ -124,7 +127,8 @@ class KeeperDispatcher
 
     /// Registered in ConfigReloader callback. Add new configuration changes to
     /// update_configuration_queue. Keeper Dispatcher apply them asynchronously.
-    void updateConfiguration(const Poco::Util::AbstractConfiguration & config);
+    /// 'macros' are used to substitute macros in endpoint of disks
+    void updateConfiguration(const Poco::Util::AbstractConfiguration & config, const MultiVersion<Macros>::Version & macros);
 
     /// Shutdown internal keeper parts (server, state machine, log storage, etc)
     void shutdown();
diff --git a/src/Coordination/KeeperSnapshotManagerS3.cpp b/src/Coordination/KeeperSnapshotManagerS3.cpp
index 361265e382a0..b793cef4b94d 100644
--- a/src/Coordination/KeeperSnapshotManagerS3.cpp
+++ b/src/Coordination/KeeperSnapshotManagerS3.cpp
@@ -14,6 +14,7 @@
 #include <IO/S3/PocoHTTPClient.h>
 #include <IO/WriteHelpers.h>
 #include <IO/copyData.h>
+#include <Common/Macros.h>
 
 #include <aws/core/auth/AWSCredentials.h>
 #include <aws/s3/S3Client.h>
@@ -47,7 +48,7 @@ KeeperSnapshotManagerS3::KeeperSnapshotManagerS3()
     , uuid(UUIDHelpers::generateV4())
 {}
 
-void KeeperSnapshotManagerS3::updateS3Configuration(const Poco::Util::AbstractConfiguration & config)
+void KeeperSnapshotManagerS3::updateS3Configuration(const Poco::Util::AbstractConfiguration & config, const MultiVersion<Macros>::Version & macros)
 {
     try
     {
@@ -64,7 +65,7 @@ void KeeperSnapshotManagerS3::updateS3Configuration(const Poco::Util::AbstractCo
 
         auto auth_settings = S3::AuthSettings::loadFromConfig(config_prefix, config);
 
-        auto endpoint = config.getString(config_prefix + ".endpoint");
+        String endpoint = macros->expand(config.getString(config_prefix + ".endpoint"));
         auto new_uri = S3::URI{endpoint};
 
         {
@@ -261,9 +262,9 @@ void KeeperSnapshotManagerS3::uploadSnapshot(const std::string & path, bool asyn
     uploadSnapshotImpl(path);
 }
 
-void KeeperSnapshotManagerS3::startup(const Poco::Util::AbstractConfiguration & config)
+void KeeperSnapshotManagerS3::startup(const Poco::Util::AbstractConfiguration & config, const MultiVersion<Macros>::Version & macros)
 {
-    updateS3Configuration(config);
+    updateS3Configuration(config, macros);
     snapshot_s3_thread = ThreadFromGlobalPool([this] { snapshotS3Thread(); });
 }
 
diff --git a/src/Coordination/KeeperSnapshotManagerS3.h b/src/Coordination/KeeperSnapshotManagerS3.h
index 5b62d114aae6..197f528b1927 100644
--- a/src/Coordination/KeeperSnapshotManagerS3.h
+++ b/src/Coordination/KeeperSnapshotManagerS3.h
@@ -3,6 +3,8 @@
 #include "config.h"
 
 #include <Poco/Util/AbstractConfiguration.h>
+#include <Common/MultiVersion.h>
+#include <Common/Macros.h>
 
 #if USE_AWS_S3
 #include <Common/ConcurrentBoundedQueue.h>
@@ -21,10 +23,12 @@ class KeeperSnapshotManagerS3
 public:
     KeeperSnapshotManagerS3();
 
-    void updateS3Configuration(const Poco::Util::AbstractConfiguration & config);
+    /// 'macros' are used to substitute macros in endpoint of disks
+    void updateS3Configuration(const Poco::Util::AbstractConfiguration & config, const MultiVersion<Macros>::Version & macros);
     void uploadSnapshot(const std::string & path, bool async_upload = true);
 
-    void startup(const Poco::Util::AbstractConfiguration & config);
+    /// 'macros' are used to substitute macros in endpoint of disks
+    void startup(const Poco::Util::AbstractConfiguration & config, const MultiVersion<Macros>::Version & macros);
     void shutdown();
 private:
     using SnapshotS3Queue = ConcurrentBoundedQueue<std::string>;
@@ -56,10 +60,10 @@ class KeeperSnapshotManagerS3
 public:
     KeeperSnapshotManagerS3() = default;
 
-    void updateS3Configuration(const Poco::Util::AbstractConfiguration &) {}
+    void updateS3Configuration(const Poco::Util::AbstractConfiguration &, const MultiVersion<Macros>::Version &) {}
     void uploadSnapshot(const std::string &, [[maybe_unused]] bool async_upload = true) {}
 
-    void startup(const Poco::Util::AbstractConfiguration &) {}
+    void startup(const Poco::Util::AbstractConfiguration &, const MultiVersion<Macros>::Version &) {}
 
     void shutdown() {}
 };
diff --git a/src/Coordination/TinyContext.cpp b/src/Coordination/TinyContext.cpp
index 967e6b23d70a..47b0a48dcdaa 100644
--- a/src/Coordination/TinyContext.cpp
+++ b/src/Coordination/TinyContext.cpp
@@ -36,7 +36,12 @@ void TinyContext::initializeKeeperDispatcher([[maybe_unused]] bool start_async)
     if (config_ref.has("keeper_server"))
     {
         keeper_dispatcher = std::make_shared<KeeperDispatcher>();
-        keeper_dispatcher->initialize(config_ref, true, start_async);
+
+        MultiVersion<Macros>::Version macros;
+
+        if (config_ref.has("macros"))
+            macros = std::make_unique<Macros>(config_ref, "macros", &Poco::Logger::get("TinyContext"));
+        keeper_dispatcher->initialize(config_ref, true, start_async, macros);
     }
 }
 
@@ -71,7 +76,12 @@ void TinyContext::updateKeeperConfiguration([[maybe_unused]] const Poco::Util::A
     if (!keeper_dispatcher)
         return;
 
-    keeper_dispatcher->updateConfiguration(config_);
+    MultiVersion<Macros>::Version macros;
+
+    if (config_.has("macros"))
+        macros = std::make_unique<Macros>(config_, "macros", &Poco::Logger::get("TinyContext"));
+
+    keeper_dispatcher->updateConfiguration(config_, macros);
 }
 
 }
diff --git a/src/Disks/ObjectStorages/HDFS/registerDiskHDFS.cpp b/src/Disks/ObjectStorages/HDFS/registerDiskHDFS.cpp
index 4e4d35a07f81..db134f3dcbac 100644
--- a/src/Disks/ObjectStorages/HDFS/registerDiskHDFS.cpp
+++ b/src/Disks/ObjectStorages/HDFS/registerDiskHDFS.cpp
@@ -4,6 +4,7 @@
 #include <Disks/ObjectStorages/MetadataStorageFromDisk.h>
 #include <Disks/DiskFactory.h>
 #include <Storages/HDFS/HDFSCommon.h>
+#include <Common/Macros.h>
 
 namespace DB
 {
@@ -22,7 +23,8 @@ void registerDiskHDFS(DiskFactory & factory, bool global_skip_access_check)
         ContextPtr context,
         const DisksMap & /*map*/) -> DiskPtr
     {
-        String uri{config.getString(config_prefix + ".endpoint")};
+        String endpoint = context->getMacros()->expand(config.getString(config_prefix + ".endpoint"));
+        String uri{endpoint};
         checkHDFSURL(uri);
 
         if (uri.back() != '/')
diff --git a/src/Disks/ObjectStorages/S3/S3ObjectStorage.cpp b/src/Disks/ObjectStorages/S3/S3ObjectStorage.cpp
index d655fd374587..3c620ca819ea 100644
--- a/src/Disks/ObjectStorages/S3/S3ObjectStorage.cpp
+++ b/src/Disks/ObjectStorages/S3/S3ObjectStorage.cpp
@@ -1,5 +1,7 @@
 #include <Disks/ObjectStorages/S3/S3ObjectStorage.h>
 #include <Common/ProfileEvents.h>
+#include <Interpreters/Context.h>
+
 
 #if USE_AWS_S3
 
@@ -31,6 +33,7 @@
 #include <Common/StringUtils/StringUtils.h>
 #include <Common/logger_useful.h>
 #include <Common/MultiVersion.h>
+#include <Common/Macros.h>
 
 
 namespace ProfileEvents
@@ -634,10 +637,11 @@ std::unique_ptr<IObjectStorage> S3ObjectStorage::cloneObjectStorage(
 {
     auto new_s3_settings = getSettings(config, config_prefix, context);
     auto new_client = getClient(config, config_prefix, context, *new_s3_settings);
+    String endpoint = context->getMacros()->expand(config.getString(config_prefix + ".endpoint"));
     return std::make_unique<S3ObjectStorage>(
         std::move(new_client), std::move(new_s3_settings),
         version_id, s3_capabilities, new_namespace,
-        config.getString(config_prefix + ".endpoint"));
+        endpoint);
 }
 
 }
diff --git a/src/Disks/ObjectStorages/S3/diskSettings.cpp b/src/Disks/ObjectStorages/S3/diskSettings.cpp
index 87533a5a4e04..d5c6b03082f8 100644
--- a/src/Disks/ObjectStorages/S3/diskSettings.cpp
+++ b/src/Disks/ObjectStorages/S3/diskSettings.cpp
@@ -21,6 +21,7 @@
 #include <Disks/ObjectStorages/S3/ProxyResolverConfiguration.h>
 #include <Disks/ObjectStorages/DiskObjectStorageCommon.h>
 #include <Disks/DiskLocal.h>
+#include <Common/Macros.h>
 
 namespace DB
 {
@@ -121,7 +122,8 @@ std::unique_ptr<Aws::S3::S3Client> getClient(
         settings.request_settings.get_request_throttler,
         settings.request_settings.put_request_throttler);
 
-    S3::URI uri(config.getString(config_prefix + ".endpoint"));
+    String endpoint = context->getMacros()->expand(config.getString(config_prefix + ".endpoint"));
+    S3::URI uri(endpoint);
     if (uri.key.back() != '/')
         throw Exception("S3 path must ends with '/', but '" + uri.key + "' doesn't.", ErrorCodes::BAD_ARGUMENTS);
 
diff --git a/src/Disks/ObjectStorages/S3/registerDiskS3.cpp b/src/Disks/ObjectStorages/S3/registerDiskS3.cpp
index 236662a7b5ef..1c192a0d89cc 100644
--- a/src/Disks/ObjectStorages/S3/registerDiskS3.cpp
+++ b/src/Disks/ObjectStorages/S3/registerDiskS3.cpp
@@ -23,6 +23,7 @@
 
 #include <Storages/StorageS3Settings.h>
 #include <Core/ServerUUID.h>
+#include <Common/Macros.h>
 
 
 namespace DB
@@ -104,7 +105,8 @@ void registerDiskS3(DiskFactory & factory, bool global_skip_access_check)
         ContextPtr context,
         const DisksMap & /*map*/) -> DiskPtr
     {
-        S3::URI uri(config.getString(config_prefix + ".endpoint"));
+        String endpoint = context->getMacros()->expand(config.getString(config_prefix + ".endpoint"));
+        S3::URI uri(endpoint);
 
         if (uri.key.empty())
             throw Exception(ErrorCodes::BAD_ARGUMENTS, "No key in S3 uri: {}", uri.uri.toString());
diff --git a/src/Disks/ObjectStorages/Web/registerDiskWebServer.cpp b/src/Disks/ObjectStorages/Web/registerDiskWebServer.cpp
index 253d32ceb14a..8a54de81815a 100644
--- a/src/Disks/ObjectStorages/Web/registerDiskWebServer.cpp
+++ b/src/Disks/ObjectStorages/Web/registerDiskWebServer.cpp
@@ -5,6 +5,9 @@
 #include <Disks/ObjectStorages/Web/MetadataStorageFromStaticFilesWebServer.h>
 #include <Disks/ObjectStorages/DiskObjectStorage.h>
 #include <Common/assert_cast.h>
+#include <Common/Macros.h>
+#include <Interpreters/Context.h>
+
 
 namespace DB
 {
@@ -23,7 +26,7 @@ void registerDiskWebServer(DiskFactory & factory, bool global_skip_access_check)
         ContextPtr context,
         const DisksMap & /*map*/) -> DiskPtr
     {
-        String uri{config.getString(config_prefix + ".endpoint")};
+        String uri = context->getMacros()->expand(config.getString(config_prefix + ".endpoint"));
         bool skip_access_check = global_skip_access_check || config.getBool(config_prefix + ".skip_access_check", false);
 
         if (!uri.ends_with('/'))
diff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp
index f97fd422662f..22c1dbb09c69 100644
--- a/src/Interpreters/Context.cpp
+++ b/src/Interpreters/Context.cpp
@@ -2356,7 +2356,7 @@ void Context::initializeKeeperDispatcher([[maybe_unused]] bool start_async) cons
         }
 
         shared->keeper_dispatcher = std::make_shared<KeeperDispatcher>();
-        shared->keeper_dispatcher->initialize(config, is_standalone_app, start_async);
+        shared->keeper_dispatcher->initialize(config, is_standalone_app, start_async, getMacros());
     }
 #endif
 }
@@ -2398,7 +2398,7 @@ void Context::updateKeeperConfiguration([[maybe_unused]] const Poco::Util::Abstr
     if (!shared->keeper_dispatcher)
         return;
 
-    shared->keeper_dispatcher->updateConfiguration(config);
+    shared->keeper_dispatcher->updateConfiguration(config, getMacros());
 #endif
 }
 
