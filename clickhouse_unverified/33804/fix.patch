diff --git a/src/Dictionaries/RedisDictionarySource.cpp b/src/Dictionaries/RedisDictionarySource.cpp
index 24a14d8cc800..a1b406b3424c 100644
--- a/src/Dictionaries/RedisDictionarySource.cpp
+++ b/src/Dictionaries/RedisDictionarySource.cpp
@@ -3,26 +3,6 @@
 #include "DictionaryStructure.h"
 #include "registerDictionaries.h"
 
-namespace DB
-{
-
-void registerDictionarySourceRedis(DictionarySourceFactory & factory)
-{
-    auto create_table_source = [=](const DictionaryStructure & dict_struct,
-                                   const Poco::Util::AbstractConfiguration & config,
-                                   const String & config_prefix,
-                                   Block & sample_block,
-                                   ContextPtr /* global_context */,
-                                   const std::string & /* default_database */,
-                                   bool /* created_from_ddl */) -> DictionarySourcePtr {
-        return std::make_unique<RedisDictionarySource>(dict_struct, config, config_prefix + ".redis", sample_block);
-    };
-    factory.registerSource("redis", create_table_source);
-}
-
-}
-
-
 #include <Poco/Redis/Array.h>
 #include <Poco/Redis/Client.h>
 #include <Poco/Redis/Command.h>
@@ -33,7 +13,6 @@ void registerDictionarySourceRedis(DictionarySourceFactory & factory)
 
 #include "RedisSource.h"
 
-
 namespace DB
 {
     namespace ErrorCodes
@@ -42,34 +21,64 @@ namespace DB
         extern const int INVALID_CONFIG_PARAMETER;
         extern const int INTERNAL_REDIS_ERROR;
         extern const int LOGICAL_ERROR;
+        extern const int TIMEOUT_EXCEEDED;
     }
 
+    static RedisStorageType parseStorageType(const String & storage_type_str)
+    {
+        if (storage_type_str == "hash_map")
+            return RedisStorageType::HASH_MAP;
+        else if (!storage_type_str.empty() && storage_type_str != "simple")
+            throw Exception(ErrorCodes::INVALID_CONFIG_PARAMETER, "Unknown storage type {} for Redis dictionary", storage_type_str);
 
-    static const size_t max_block_size = 8192;
+        return RedisStorageType::SIMPLE;
+    }
+
+    void registerDictionarySourceRedis(DictionarySourceFactory & factory)
+    {
+        auto create_table_source = [=](const DictionaryStructure & dict_struct,
+                                    const Poco::Util::AbstractConfiguration & config,
+                                    const String & config_prefix,
+                                    Block & sample_block,
+                                    ContextPtr /* global_context */,
+                                    const std::string & /* default_database */,
+                                    bool /* created_from_ddl */) -> DictionarySourcePtr {
+
+            auto redis_config_prefix = config_prefix + ".redis";
+            RedisDictionarySource::Configuration configuration =
+            {
+                .host = config.getString(redis_config_prefix + ".host"),
+                .port = static_cast<UInt16>(config.getUInt(redis_config_prefix + ".port")),
+                .db_index = config.getUInt(redis_config_prefix + ".db_index", 0),
+                .password = config.getString(redis_config_prefix + ".password", ""),
+                .storage_type = parseStorageType(config.getString(redis_config_prefix + ".storage_type", "")),
+                .pool_size = config.getUInt(redis_config_prefix + ".pool_size", 16),
+            };
+
+            return std::make_unique<RedisDictionarySource>(dict_struct, configuration, sample_block);
+        };
+
+        factory.registerSource("redis", create_table_source);
+    }
+
+    static constexpr size_t REDIS_MAX_BLOCK_SIZE = DEFAULT_BLOCK_SIZE;
+    static constexpr size_t REDIS_LOCK_ACQUIRE_TIMEOUT_MS = 5000;
 
     RedisDictionarySource::RedisDictionarySource(
-            const DictionaryStructure & dict_struct_,
-            const String & host_,
-            UInt16 port_,
-            UInt8 db_index_,
-            const String & password_,
-            RedisStorageType storage_type_,
-            const Block & sample_block_)
-            : dict_struct{dict_struct_}
-            , host{host_}
-            , port{port_}
-            , db_index{db_index_}
-            , password{password_}
-            , storage_type{storage_type_}
-            , sample_block{sample_block_}
-            , client{std::make_shared<Poco::Redis::Client>(host, port)}
+        const DictionaryStructure & dict_struct_,
+        const Configuration & configuration_,
+        const Block & sample_block_)
+        : dict_struct{dict_struct_}
+        , configuration(configuration_)
+        , pool(std::make_shared<Pool>(configuration.pool_size))
+        , sample_block{sample_block_}
     {
         if (dict_struct.attributes.size() != 1)
             throw Exception(ErrorCodes::INVALID_CONFIG_PARAMETER,
                 "Invalid number of non key columns for Redis source: {}, expected 1",
                 DB::toString(dict_struct.attributes.size()));
 
-        if (storage_type == RedisStorageType::HASH_MAP)
+        if (configuration.storage_type == RedisStorageType::HASH_MAP)
         {
             if (!dict_struct.key)
                 throw Exception(ErrorCodes::INVALID_CONFIG_PARAMETER,
@@ -87,61 +96,13 @@ namespace DB
                         key.name,
                         key.type->getName());
         }
-
-        if (!password.empty())
-        {
-            RedisCommand command("AUTH");
-            command << password;
-            String reply = client->execute<String>(command);
-            if (reply != "OK")
-                throw Exception(ErrorCodes::INTERNAL_REDIS_ERROR,
-                    "Authentication failed with reason {}",
-                    reply);
-        }
-
-        if (db_index != 0)
-        {
-            RedisCommand command("SELECT");
-            command << std::to_string(db_index);
-            String reply = client->execute<String>(command);
-            if (reply != "OK")
-                throw Exception(ErrorCodes::INTERNAL_REDIS_ERROR,
-                    "Selecting database with index {} failed with reason {}",
-                    DB::toString(db_index),
-                    reply);
-        }
     }
 
-
-    RedisDictionarySource::RedisDictionarySource(
-            const DictionaryStructure & dict_struct_,
-            const Poco::Util::AbstractConfiguration & config_,
-            const String & config_prefix_,
-            Block & sample_block_)
-            : RedisDictionarySource(
-            dict_struct_,
-            config_.getString(config_prefix_ + ".host"),
-            config_.getUInt(config_prefix_ + ".port"),
-            config_.getUInt(config_prefix_ + ".db_index", 0),
-            config_.getString(config_prefix_ + ".password",""),
-            parseStorageType(config_.getString(config_prefix_ + ".storage_type", "")),
-            sample_block_)
-    {
-    }
-
-
     RedisDictionarySource::RedisDictionarySource(const RedisDictionarySource & other)
-            : RedisDictionarySource{other.dict_struct,
-                                    other.host,
-                                    other.port,
-                                    other.db_index,
-                                    other.password,
-                                    other.storage_type,
-                                    other.sample_block}
+        : RedisDictionarySource(other.dict_struct, other.configuration, other.sample_block)
     {
     }
 
-
     RedisDictionarySource::~RedisDictionarySource() = default;
 
     static String storageTypeToKeyType(RedisStorageType type)
@@ -161,24 +122,25 @@ namespace DB
 
     Pipe RedisDictionarySource::loadAll()
     {
-        if (!client->isConnected())
-            client->connect(host, port);
+        auto connection = getConnection();
 
         RedisCommand command_for_keys("KEYS");
         command_for_keys << "*";
 
         /// Get only keys for specified storage type.
-        auto all_keys = client->execute<RedisArray>(command_for_keys);
+        auto all_keys = connection->client->execute<RedisArray>(command_for_keys);
         if (all_keys.isNull())
-            return Pipe(std::make_shared<RedisSource>(client, RedisArray{}, storage_type, sample_block, max_block_size));
+            return Pipe(std::make_shared<RedisSource>(
+                std::move(connection), RedisArray{},
+                configuration.storage_type, sample_block, REDIS_MAX_BLOCK_SIZE));
 
         RedisArray keys;
-        auto key_type = storageTypeToKeyType(storage_type);
+        auto key_type = storageTypeToKeyType(configuration.storage_type);
         for (const auto & key : all_keys)
-            if (key_type == client->execute<String>(RedisCommand("TYPE").addRedisType(key)))
+            if (key_type == connection->client->execute<String>(RedisCommand("TYPE").addRedisType(key)))
                 keys.addRedisType(std::move(key));
 
-        if (storage_type == RedisStorageType::HASH_MAP)
+        if (configuration.storage_type == RedisStorageType::HASH_MAP)
         {
             RedisArray hkeys;
             for (const auto & key : keys)
@@ -186,7 +148,7 @@ namespace DB
                 RedisCommand command_for_secondary_keys("HKEYS");
                 command_for_secondary_keys.addRedisType(key);
 
-                auto secondary_keys = client->execute<RedisArray>(command_for_secondary_keys);
+                auto secondary_keys = connection->client->execute<RedisArray>(command_for_secondary_keys);
 
                 RedisArray primary_with_secondary;
                 primary_with_secondary.addRedisType(key);
@@ -194,7 +156,7 @@ namespace DB
                 {
                     primary_with_secondary.addRedisType(secondary_key);
                     /// Do not store more than max_block_size values for one request.
-                    if (primary_with_secondary.size() == max_block_size + 1)
+                    if (primary_with_secondary.size() == REDIS_MAX_BLOCK_SIZE + 1)
                     {
                         hkeys.add(primary_with_secondary);
                         primary_with_secondary.clear();
@@ -209,16 +171,16 @@ namespace DB
             keys = std::move(hkeys);
         }
 
-        return Pipe(std::make_shared<RedisSource>(client, std::move(keys), storage_type, sample_block, max_block_size));
+        return Pipe(std::make_shared<RedisSource>(
+            std::move(connection), std::move(keys),
+            configuration.storage_type, sample_block, REDIS_MAX_BLOCK_SIZE));
     }
 
-
     Pipe RedisDictionarySource::loadIds(const std::vector<UInt64> & ids)
     {
-        if (!client->isConnected())
-            client->connect(host, port);
+        auto connection = getConnection();
 
-        if (storage_type == RedisStorageType::HASH_MAP)
+        if (configuration.storage_type == RedisStorageType::HASH_MAP)
             throw Exception(ErrorCodes::UNSUPPORTED_METHOD, "Cannot use loadIds with 'hash_map' storage type");
 
         if (!dict_struct.id)
@@ -229,13 +191,14 @@ namespace DB
         for (UInt64 id : ids)
             keys << DB::toString(id);
 
-        return Pipe(std::make_shared<RedisSource>(client, std::move(keys), storage_type, sample_block, max_block_size));
+        return Pipe(std::make_shared<RedisSource>(
+            std::move(connection), std::move(keys),
+            configuration.storage_type, sample_block, REDIS_MAX_BLOCK_SIZE));
     }
 
     Pipe RedisDictionarySource::loadKeys(const Columns & key_columns, const std::vector<size_t> & requested_rows)
     {
-        if (!client->isConnected())
-            client->connect(host, port);
+        auto connection = getConnection();
 
         if (key_columns.size() != dict_struct.key->size())
             throw Exception(ErrorCodes::LOGICAL_ERROR, "The size of key_columns does not equal to the size of dictionary key");
@@ -250,7 +213,7 @@ namespace DB
                 if (isInteger(type))
                     key << DB::toString(key_columns[i]->get64(row));
                 else if (isString(type))
-                    key << get<String>((*key_columns[i])[row]);
+                    key << get<const String &>((*key_columns[i])[row]);
                 else
                     throw Exception(ErrorCodes::LOGICAL_ERROR, "Unexpected type of key in Redis dictionary");
             }
@@ -258,22 +221,65 @@ namespace DB
             keys.add(key);
         }
 
-        return Pipe(std::make_shared<RedisSource>(client, std::move(keys), storage_type, sample_block, max_block_size));
+        return Pipe(std::make_shared<RedisSource>(
+            std::move(connection), std::move(keys),
+            configuration.storage_type, sample_block, REDIS_MAX_BLOCK_SIZE));
     }
 
-
     String RedisDictionarySource::toString() const
     {
-        return "Redis: " + host + ':' + DB::toString(port);
+        return "Redis: " + configuration.host + ':' + DB::toString(configuration.port);
     }
 
-    RedisStorageType RedisDictionarySource::parseStorageType(const String & storage_type_str)
+    RedisDictionarySource::ConnectionPtr RedisDictionarySource::getConnection() const
     {
-        if (storage_type_str == "hash_map")
-            return RedisStorageType::HASH_MAP;
-        else if (!storage_type_str.empty() && storage_type_str != "simple")
-            throw Exception(ErrorCodes::INVALID_CONFIG_PARAMETER, "Unknown storage type {} for Redis dictionary", storage_type_str);
+        ClientPtr client;
+        bool ok = pool->tryBorrowObject(client,
+            [] { return std::make_unique<Poco::Redis::Client>(); },
+            REDIS_LOCK_ACQUIRE_TIMEOUT_MS);
 
-        return RedisStorageType::SIMPLE;
+        if (!ok)
+            throw Exception(ErrorCodes::TIMEOUT_EXCEEDED,
+                "Could not get connection from pool, timeout exceeded {} seconds",
+                REDIS_LOCK_ACQUIRE_TIMEOUT_MS);
+
+        if (!client->isConnected())
+        {
+            try
+            {
+                client->connect(configuration.host, configuration.port);
+
+                if (!configuration.password.empty())
+                {
+                    RedisCommand command("AUTH");
+                    command << configuration.password;
+                    String reply = client->execute<String>(command);
+                    if (reply != "OK")
+                        throw Exception(ErrorCodes::INTERNAL_REDIS_ERROR,
+                            "Authentication failed with reason {}", reply);
+                }
+
+                if (configuration.db_index != 0)
+                {
+                    RedisCommand command("SELECT");
+                    command << std::to_string(configuration.db_index);
+                    String reply = client->execute<String>(command);
+                    if (reply != "OK")
+                        throw Exception(ErrorCodes::INTERNAL_REDIS_ERROR,
+                            "Selecting database with index {} failed with reason {}",
+                            configuration.db_index, reply);
+                }
+            }
+            catch (...)
+            {
+                if (client->isConnected())
+                    client->disconnect();
+
+                pool->returnObject(std::move(client));
+                throw;
+            }
+        }
+
+        return std::make_unique<Connection>(pool, std::move(client));
     }
 }
diff --git a/src/Dictionaries/RedisDictionarySource.h b/src/Dictionaries/RedisDictionarySource.h
index eff97dede0c7..af12981f348d 100644
--- a/src/Dictionaries/RedisDictionarySource.h
+++ b/src/Dictionaries/RedisDictionarySource.h
@@ -1,6 +1,7 @@
 #pragma once
 
 #include <Core/Block.h>
+#include <base/BorrowedObjectPool.h>
 
 #include "DictionaryStructure.h"
 #include "IDictionarySource.h"
@@ -20,13 +21,13 @@ namespace Poco
     }
 }
 
-
 namespace DB
 {
-namespace ErrorCodes
-{
-    extern const int NOT_IMPLEMENTED;
-}
+    namespace ErrorCodes
+    {
+        extern const int NOT_IMPLEMENTED;
+    }
+
     enum class RedisStorageType
     {
             SIMPLE,
@@ -36,24 +37,46 @@ namespace ErrorCodes
 
     class RedisDictionarySource final : public IDictionarySource
     {
-        RedisDictionarySource(
-                const DictionaryStructure & dict_struct,
-                const std::string & host,
-                UInt16 port,
-                UInt8 db_index,
-                const std::string & password,
-                RedisStorageType storage_type,
-                const Block & sample_block);
-
     public:
         using RedisArray = Poco::Redis::Array;
         using RedisCommand = Poco::Redis::Command;
 
+        using ClientPtr = std::unique_ptr<Poco::Redis::Client>;
+        using Pool = BorrowedObjectPool<ClientPtr>;
+        using PoolPtr = std::shared_ptr<Pool>;
+
+        struct Configuration
+        {
+            const std::string host;
+            const UInt16 port;
+            const UInt32 db_index;
+            const std::string password;
+            const RedisStorageType storage_type;
+            const size_t pool_size;
+        };
+
+        struct Connection
+        {
+            Connection(PoolPtr pool_, ClientPtr client_)
+                : pool(std::move(pool_)), client(std::move(client_))
+            {
+            }
+
+            ~Connection()
+            {
+                pool->returnObject(std::move(client));
+            }
+
+            PoolPtr pool;
+            ClientPtr client;
+        };
+
+        using ConnectionPtr = std::unique_ptr<Connection>;
+
         RedisDictionarySource(
-                const DictionaryStructure & dict_struct,
-                const Poco::Util::AbstractConfiguration & config,
-                const std::string & config_prefix,
-                Block & sample_block);
+            const DictionaryStructure & dict_struct_,
+            const Configuration & configuration_,
+            const Block & sample_block_);
 
         RedisDictionarySource(const RedisDictionarySource & other);
 
@@ -81,17 +104,12 @@ namespace ErrorCodes
         std::string toString() const override;
 
     private:
-        static RedisStorageType parseStorageType(const std::string& storage_type);
+        ConnectionPtr getConnection() const;
 
         const DictionaryStructure dict_struct;
-        const std::string host;
-        const UInt16 port;
-        const UInt8 db_index;
-        const std::string password;
-        const RedisStorageType storage_type;
-        Block sample_block;
+        const Configuration configuration;
 
-        std::shared_ptr<Poco::Redis::Client> client;
+        PoolPtr pool;
+        Block sample_block;
     };
-
 }
diff --git a/src/Dictionaries/RedisSource.cpp b/src/Dictionaries/RedisSource.cpp
index ad5cf8a0977b..6089b836d98b 100644
--- a/src/Dictionaries/RedisSource.cpp
+++ b/src/Dictionaries/RedisSource.cpp
@@ -30,20 +30,22 @@ namespace DB
 
 
     RedisSource::RedisSource(
-            const std::shared_ptr<Poco::Redis::Client> & client_,
-            const RedisArray & keys_,
-            const RedisStorageType & storage_type_,
-            const DB::Block & sample_block,
-            const size_t max_block_size_)
-            : SourceWithProgress(sample_block)
-            , client(client_), keys(keys_), storage_type(storage_type_), max_block_size{max_block_size_}
+        ConnectionPtr connection_,
+        const RedisArray & keys_,
+        const RedisStorageType & storage_type_,
+        const DB::Block & sample_block,
+        size_t max_block_size_)
+        : SourceWithProgress(sample_block)
+        , connection(std::move(connection_))
+        , keys(keys_)
+        , storage_type(storage_type_)
+        , max_block_size{max_block_size_}
     {
         description.init(sample_block);
     }
 
     RedisSource::~RedisSource() = default;
 
-
     namespace
     {
         using ValueType = ExternalResultDescription::ValueType;
@@ -121,7 +123,6 @@ namespace DB
         }
     }
 
-
     Chunk RedisSource::generate()
     {
         if (keys.isNull() || description.sample_block.rows() == 0 || cursor >= keys.size())
@@ -168,7 +169,7 @@ namespace DB
                 for (const auto & elem : keys_array)
                     command_for_values.addRedisType(elem);
 
-                auto values = client->execute<RedisArray>(command_for_values);
+                auto values = connection->client->execute<RedisArray>(command_for_values);
 
                 if (keys_array.size() != values.size() + 1) // 'HMGET' primary_key secondary_keys
                     throw Exception(ErrorCodes::NUMBER_OF_COLUMNS_DOESNT_MATCH,
@@ -199,7 +200,7 @@ namespace DB
             for (size_t i = 0; i < need_values; ++i)
                 command_for_values.add(keys.get<RedisBulkString>(cursor + i));
 
-            auto values = client->execute<RedisArray>(command_for_values);
+            auto values = connection->client->execute<RedisArray>(command_for_values);
             if (values.size() != need_values)
                 throw Exception(ErrorCodes::INTERNAL_REDIS_ERROR,
                     "Inconsistent sizes of keys and values in Redis request");
diff --git a/src/Dictionaries/RedisSource.h b/src/Dictionaries/RedisSource.h
index db2e643eb4e2..24507998f581 100644
--- a/src/Dictionaries/RedisSource.h
+++ b/src/Dictionaries/RedisSource.h
@@ -24,13 +24,14 @@ namespace DB
     public:
         using RedisArray = Poco::Redis::Array;
         using RedisBulkString = Poco::Redis::BulkString;
+        using ConnectionPtr = RedisDictionarySource::ConnectionPtr;
 
         RedisSource(
-                const std::shared_ptr<Poco::Redis::Client> & client_,
-                const Poco::Redis::Array & keys_,
-                const RedisStorageType & storage_type_,
-                const Block & sample_block,
-                const size_t max_block_size);
+            ConnectionPtr connection_,
+            const Poco::Redis::Array & keys_,
+            const RedisStorageType & storage_type_,
+            const Block & sample_block,
+            size_t max_block_size);
 
         ~RedisSource() override;
 
@@ -39,7 +40,7 @@ namespace DB
     private:
         Chunk generate() override;
 
-        std::shared_ptr<Poco::Redis::Client> client;
+        ConnectionPtr connection;
         Poco::Redis::Array keys;
         RedisStorageType storage_type;
         const size_t max_block_size;
