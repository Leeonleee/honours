{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 52791,
  "instance_id": "ClickHouse__ClickHouse-52791",
  "issue_numbers": [
    "17933"
  ],
  "base_commit": "15c77afd8e2389740be5cf5120d54d11b8e4b8c2",
  "patch": "diff --git a/docs/en/operations/settings/settings.md b/docs/en/operations/settings/settings.md\nindex 8dfb6c0d2250..5ae74130dff2 100644\n--- a/docs/en/operations/settings/settings.md\n+++ b/docs/en/operations/settings/settings.md\n@@ -4578,3 +4578,28 @@ Type: Int64\n \n Default: 0\n \n+## precise_float_parsing {#precise_float_parsing}\n+\n+Switches [Float32/Float64](../../sql-reference/data-types/float.md) parsing algorithms:\n+* If the value is `1`, then precise method is used. It is slower than fast method, but it always returns a number that is the closest machine representable number to the input.\n+* Otherwise, fast method is used (default). It usually returns the same value as precise, but in rare cases result may differ by one or two least significant digits.\n+\n+Possible values: `0`, `1`.\n+\n+Default value: `0`.\n+\n+Example:\n+\n+```sql\n+SELECT toFloat64('1.7091'), toFloat64('1.5008753E7') SETTINGS precise_float_parsing = 0;\n+\n+\u250c\u2500toFloat64('1.7091')\u2500\u252c\u2500toFloat64('1.5008753E7')\u2500\u2510\n+\u2502  1.7090999999999998 \u2502       15008753.000000002 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+SELECT toFloat64('1.7091'), toFloat64('1.5008753E7') SETTINGS precise_float_parsing = 1;\n+\n+\u250c\u2500toFloat64('1.7091')\u2500\u252c\u2500toFloat64('1.5008753E7')\u2500\u2510\n+\u2502              1.7091 \u2502                 15008753 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\ndiff --git a/docs/ru/operations/settings/settings.md b/docs/ru/operations/settings/settings.md\nindex 957a917c7806..de613f97e68e 100644\n--- a/docs/ru/operations/settings/settings.md\n+++ b/docs/ru/operations/settings/settings.md\n@@ -4213,3 +4213,29 @@ SELECT *, timezone() FROM test_tz WHERE d = '2000-01-01 00:00:00' SETTINGS sessi\n - \u0417\u0430\u043f\u0440\u043e\u0441: `SELECT * FROM file('sample.csv')`\n \n \u0415\u0441\u043b\u0438 \u0447\u0442\u0435\u043d\u0438\u0435 \u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 `sample.csv` \u043f\u0440\u043e\u0448\u043b\u0438 \u0443\u0441\u043f\u0435\u0448\u043d\u043e, \u0444\u0430\u0439\u043b \u0431\u0443\u0434\u0435\u0442 \u043f\u0435\u0440\u0435\u0438\u043c\u0435\u043d\u043e\u0432\u0430\u043d \u0432 `processed_sample_1683473210851438.csv`.\n+\n+## precise_float_parsing {#precise_float_parsing}\n+\n+\u041f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u0432\u044b\u0431\u0440\u0430\u0442\u044c \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0439 \u043f\u0440\u0438 \u043f\u0430\u0440\u0441\u0438\u043d\u0433\u0435 [Float32/Float64](../../sql-reference/data-types/float.md):\n+* \u0415\u0441\u043b\u0438 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 `1`, \u0442\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0442\u043e\u0447\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434. \u041e\u043d \u0431\u043e\u043b\u0435\u0435 \u043c\u0435\u0434\u043b\u0435\u043d\u043d\u044b\u0439, \u043d\u043e \u0432\u0441\u0435\u0433\u0434\u0430 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0447\u0438\u0441\u043b\u043e, \u043d\u0430\u0438\u0431\u043e\u043b\u0435\u0435 \u0431\u043b\u0438\u0437\u043a\u043e\u0435 \u043a \u0432\u0445\u043e\u0434\u043d\u043e\u043c\u0443 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e.\n+* \u0412 \u043f\u0440\u043e\u0442\u0438\u0432\u043d\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0431\u044b\u0441\u0442\u0440\u044b\u0439 \u043c\u0435\u0442\u043e\u0434 (\u043f\u043e\u0432\u0435\u0434\u0435\u043d\u0438\u0435 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e). \u041e\u0431\u044b\u0447\u043d\u043e \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u0435\u0433\u043e \u0440\u0430\u0431\u043e\u0442\u044b \u0441\u043e\u0432\u043f\u0430\u0434\u0430\u0435\u0442 \u0441 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u043c, \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u043c \u0442\u043e\u0447\u043d\u044b\u043c \u043c\u0435\u0442\u043e\u0434\u043e\u043c, \u043e\u0434\u043d\u0430\u043a\u043e \u0432 \u0440\u0435\u0434\u043a\u0438\u0445 \u0441\u043b\u0443\u0447\u0430\u044f\u0445 \u043e\u043d \u043c\u043e\u0436\u0435\u0442 \u043e\u0442\u043b\u0438\u0447\u0430\u0442\u044c\u0441\u044f \u043d\u0430 1 \u0438\u043b\u0438 2 \u043d\u0430\u0438\u043c\u0435\u043d\u0435\u0435 \u0437\u043d\u0430\u0447\u0438\u043c\u044b\u0445 \u0446\u0438\u0444\u0440\u044b.\n+\n+\u0412\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f: `0`, `1`.\n+\n+\u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e: `0`.\n+\n+\u041f\u0440\u0438\u043c\u0435\u0440:\n+\n+```sql\n+SELECT toFloat64('1.7091'), toFloat64('1.5008753E7') SETTINGS precise_float_parsing = 0;\n+\n+\u250c\u2500toFloat64('1.7091')\u2500\u252c\u2500toFloat64('1.5008753E7')\u2500\u2510\n+\u2502  1.7090999999999998 \u2502       15008753.000000002 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+SELECT toFloat64('1.7091'), toFloat64('1.5008753E7') SETTINGS precise_float_parsing = 1;\n+\n+\u250c\u2500toFloat64('1.7091')\u2500\u252c\u2500toFloat64('1.5008753E7')\u2500\u2510\n+\u2502              1.7091 \u2502                 15008753 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex c142096ef5aa..ed3182898e25 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -1027,7 +1027,8 @@ class IColumn;\n     M(Bool, regexp_dict_allow_hyperscan, true, \"Allow regexp_tree dictionary using Hyperscan library.\", 0) \\\n     \\\n     M(Bool, dictionary_use_async_executor, false, \"Execute a pipeline for reading from a dictionary with several threads. It's supported only by DIRECT dictionary with CLICKHOUSE source.\", 0) \\\n-    M(Bool, input_format_csv_allow_variable_number_of_columns, false, \"Ignore extra columns in CSV input (if file has more columns than expected) and treat missing fields in CSV input as default values\", 0) \\\n+    M(Bool, input_format_csv_allow_variable_number_of_columns, false, \"Ignore extra columns in CSV input (if file has more columns than expected) and treat missing fields in CSV input as default values\", 0)                                                         \\\n+    M(Bool, precise_float_parsing, false, \"Prefer more precise (but slower) float parsing algorithm\", 0) \\\n \n // End of FORMAT_FACTORY_SETTINGS\n // Please add settings non-related to formats into the COMMON_SETTINGS above.\ndiff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex b272e88d17d0..79d17d8ac985 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -1040,13 +1040,21 @@ inline void convertFromTime<DataTypeDateTime>(DataTypeDateTime::FieldType & x, t\n /** Conversion of strings to numbers, dates, datetimes: through parsing.\n   */\n template <typename DataType>\n-void parseImpl(typename DataType::FieldType & x, ReadBuffer & rb, const DateLUTImpl *)\n+void parseImpl(typename DataType::FieldType & x, ReadBuffer & rb, const DateLUTImpl *, bool precise_float_parsing)\n {\n-    readText(x, rb);\n+    if constexpr (std::is_floating_point_v<typename DataType::FieldType>)\n+    {\n+        if (precise_float_parsing)\n+            readFloatTextPrecise(x, rb);\n+        else\n+            readFloatTextFast(x, rb);\n+    }\n+    else\n+        readText(x, rb);\n }\n \n template <>\n-inline void parseImpl<DataTypeDate>(DataTypeDate::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone)\n+inline void parseImpl<DataTypeDate>(DataTypeDate::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone, bool)\n {\n     DayNum tmp(0);\n     readDateText(tmp, rb, *time_zone);\n@@ -1054,7 +1062,7 @@ inline void parseImpl<DataTypeDate>(DataTypeDate::FieldType & x, ReadBuffer & rb\n }\n \n template <>\n-inline void parseImpl<DataTypeDate32>(DataTypeDate32::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone)\n+inline void parseImpl<DataTypeDate32>(DataTypeDate32::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone, bool)\n {\n     ExtendedDayNum tmp(0);\n     readDateText(tmp, rb, *time_zone);\n@@ -1064,7 +1072,7 @@ inline void parseImpl<DataTypeDate32>(DataTypeDate32::FieldType & x, ReadBuffer\n \n // NOTE: no need of extra overload of DateTime64, since readDateTimeText64 has different signature and that case is explicitly handled in the calling code.\n template <>\n-inline void parseImpl<DataTypeDateTime>(DataTypeDateTime::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone)\n+inline void parseImpl<DataTypeDateTime>(DataTypeDateTime::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone, bool)\n {\n     time_t time = 0;\n     readDateTimeText(time, rb, *time_zone);\n@@ -1072,7 +1080,7 @@ inline void parseImpl<DataTypeDateTime>(DataTypeDateTime::FieldType & x, ReadBuf\n }\n \n template <>\n-inline void parseImpl<DataTypeUUID>(DataTypeUUID::FieldType & x, ReadBuffer & rb, const DateLUTImpl *)\n+inline void parseImpl<DataTypeUUID>(DataTypeUUID::FieldType & x, ReadBuffer & rb, const DateLUTImpl *, bool)\n {\n     UUID tmp;\n     readUUIDText(tmp, rb);\n@@ -1080,7 +1088,7 @@ inline void parseImpl<DataTypeUUID>(DataTypeUUID::FieldType & x, ReadBuffer & rb\n }\n \n template <>\n-inline void parseImpl<DataTypeIPv4>(DataTypeIPv4::FieldType & x, ReadBuffer & rb, const DateLUTImpl *)\n+inline void parseImpl<DataTypeIPv4>(DataTypeIPv4::FieldType & x, ReadBuffer & rb, const DateLUTImpl *, bool)\n {\n     IPv4 tmp;\n     readIPv4Text(tmp, rb);\n@@ -1088,7 +1096,7 @@ inline void parseImpl<DataTypeIPv4>(DataTypeIPv4::FieldType & x, ReadBuffer & rb\n }\n \n template <>\n-inline void parseImpl<DataTypeIPv6>(DataTypeIPv6::FieldType & x, ReadBuffer & rb, const DateLUTImpl *)\n+inline void parseImpl<DataTypeIPv6>(DataTypeIPv6::FieldType & x, ReadBuffer & rb, const DateLUTImpl *, bool)\n {\n     IPv6 tmp;\n     readIPv6Text(tmp, rb);\n@@ -1096,16 +1104,21 @@ inline void parseImpl<DataTypeIPv6>(DataTypeIPv6::FieldType & x, ReadBuffer & rb\n }\n \n template <typename DataType>\n-bool tryParseImpl(typename DataType::FieldType & x, ReadBuffer & rb, const DateLUTImpl *)\n+bool tryParseImpl(typename DataType::FieldType & x, ReadBuffer & rb, const DateLUTImpl *, bool precise_float_parsing)\n {\n     if constexpr (std::is_floating_point_v<typename DataType::FieldType>)\n-        return tryReadFloatText(x, rb);\n+    {\n+        if (precise_float_parsing)\n+            return tryReadFloatTextPrecise(x, rb);\n+        else\n+            return tryReadFloatTextFast(x, rb);\n+    }\n     else /*if constexpr (is_integer_v<typename DataType::FieldType>)*/\n         return tryReadIntText(x, rb);\n }\n \n template <>\n-inline bool tryParseImpl<DataTypeDate>(DataTypeDate::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone)\n+inline bool tryParseImpl<DataTypeDate>(DataTypeDate::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone, bool)\n {\n     DayNum tmp(0);\n     if (!tryReadDateText(tmp, rb, *time_zone))\n@@ -1115,7 +1128,7 @@ inline bool tryParseImpl<DataTypeDate>(DataTypeDate::FieldType & x, ReadBuffer &\n }\n \n template <>\n-inline bool tryParseImpl<DataTypeDate32>(DataTypeDate32::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone)\n+inline bool tryParseImpl<DataTypeDate32>(DataTypeDate32::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone, bool)\n {\n     ExtendedDayNum tmp(0);\n     if (!tryReadDateText(tmp, rb, *time_zone))\n@@ -1125,7 +1138,7 @@ inline bool tryParseImpl<DataTypeDate32>(DataTypeDate32::FieldType & x, ReadBuff\n }\n \n template <>\n-inline bool tryParseImpl<DataTypeDateTime>(DataTypeDateTime::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone)\n+inline bool tryParseImpl<DataTypeDateTime>(DataTypeDateTime::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone, bool)\n {\n     time_t tmp = 0;\n     if (!tryReadDateTimeText(tmp, rb, *time_zone))\n@@ -1135,7 +1148,7 @@ inline bool tryParseImpl<DataTypeDateTime>(DataTypeDateTime::FieldType & x, Read\n }\n \n template <>\n-inline bool tryParseImpl<DataTypeUUID>(DataTypeUUID::FieldType & x, ReadBuffer & rb, const DateLUTImpl *)\n+inline bool tryParseImpl<DataTypeUUID>(DataTypeUUID::FieldType & x, ReadBuffer & rb, const DateLUTImpl *, bool)\n {\n     UUID tmp;\n     if (!tryReadUUIDText(tmp, rb))\n@@ -1146,7 +1159,7 @@ inline bool tryParseImpl<DataTypeUUID>(DataTypeUUID::FieldType & x, ReadBuffer &\n }\n \n template <>\n-inline bool tryParseImpl<DataTypeIPv4>(DataTypeIPv4::FieldType & x, ReadBuffer & rb, const DateLUTImpl *)\n+inline bool tryParseImpl<DataTypeIPv4>(DataTypeIPv4::FieldType & x, ReadBuffer & rb, const DateLUTImpl *, bool)\n {\n     IPv4 tmp;\n     if (!tryReadIPv4Text(tmp, rb))\n@@ -1157,7 +1170,7 @@ inline bool tryParseImpl<DataTypeIPv4>(DataTypeIPv4::FieldType & x, ReadBuffer &\n }\n \n template <>\n-inline bool tryParseImpl<DataTypeIPv6>(DataTypeIPv6::FieldType & x, ReadBuffer & rb, const DateLUTImpl *)\n+inline bool tryParseImpl<DataTypeIPv6>(DataTypeIPv6::FieldType & x, ReadBuffer & rb, const DateLUTImpl *, bool)\n {\n     IPv6 tmp;\n     if (!tryReadIPv6Text(tmp, rb))\n@@ -1336,6 +1349,16 @@ struct ConvertThroughParsing\n \n         size_t current_offset = 0;\n \n+        bool precise_float_parsing = false;\n+\n+        if (DB::CurrentThread::isInitialized())\n+        {\n+            const DB::ContextPtr query_context = DB::CurrentThread::get().getQueryContext();\n+\n+            if (query_context)\n+                precise_float_parsing = query_context->getSettingsRef().precise_float_parsing;\n+        }\n+\n         for (size_t i = 0; i < size; ++i)\n         {\n             size_t next_offset = std::is_same_v<FromDataType, DataTypeString> ? (*offsets)[i] : (current_offset + fixed_string_size);\n@@ -1402,7 +1425,7 @@ struct ConvertThroughParsing\n                                 }\n                             }\n \n-                            parseImpl<ToDataType>(vec_to[i], read_buffer, local_time_zone);\n+                            parseImpl<ToDataType>(vec_to[i], read_buffer, local_time_zone, precise_float_parsing);\n                         } while (false);\n                     }\n                 }\n@@ -1472,7 +1495,7 @@ struct ConvertThroughParsing\n                                 }\n                             }\n \n-                            parsed = tryParseImpl<ToDataType>(vec_to[i], read_buffer, local_time_zone);\n+                            parsed = tryParseImpl<ToDataType>(vec_to[i], read_buffer, local_time_zone, precise_float_parsing);\n                         } while (false);\n                     }\n                 }\ndiff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h\nindex 2636898c1b3c..6dde14cd145e 100644\n--- a/src/IO/ReadHelpers.h\n+++ b/src/IO/ReadHelpers.h\n@@ -529,6 +529,11 @@ void tryReadIntTextUnsafe(T & x, ReadBuffer & buf)\n template <typename T> void readFloatText(T & x, ReadBuffer & in);\n template <typename T> bool tryReadFloatText(T & x, ReadBuffer & in);\n \n+template <typename T> void readFloatTextPrecise(T & x, ReadBuffer & in);\n+template <typename T> bool tryReadFloatTextPrecise(T & x, ReadBuffer & in);\n+template <typename T> void readFloatTextFast(T & x, ReadBuffer & in);\n+template <typename T> bool tryReadFloatTextFast(T & x, ReadBuffer & in);\n+\n \n /// simple: all until '\\n' or '\\t'\n void readString(String & s, ReadBuffer & buf);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02813_float_parsing.reference b/tests/queries/0_stateless/02813_float_parsing.reference\nnew file mode 100644\nindex 000000000000..c83331e01384\n--- /dev/null\n+++ b/tests/queries/0_stateless/02813_float_parsing.reference\n@@ -0,0 +1,2 @@\n+1.7090999999999998\t15008753.000000002\t6.000000000000001e-9\t6.000000000000002e-9\t1.7091\t15008752\t5.9999996e-9\t5.9999996e-9\n+1.7091\t15008753\t6e-9\t6.000000000000001e-9\t1.7091\t15008753\t6e-9\t6e-9\ndiff --git a/tests/queries/0_stateless/02813_float_parsing.sql b/tests/queries/0_stateless/02813_float_parsing.sql\nnew file mode 100644\nindex 000000000000..ba57b87f191a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02813_float_parsing.sql\n@@ -0,0 +1,21 @@\n+SELECT\n+    toFloat64('1.7091'),\n+    toFloat64('1.5008753E7'),\n+    toFloat64('6e-09'),\n+    toFloat64('6.000000000000001e-9'),\n+    toFloat32('1.7091'),\n+    toFloat32('1.5008753E7'),\n+    toFloat32('6e-09'),\n+    toFloat32('6.000000000000001e-9')\n+SETTINGS precise_float_parsing = 0;\n+\n+SELECT\n+    toFloat64('1.7091'),\n+    toFloat64('1.5008753E7'),\n+    toFloat64('6e-09'),\n+    toFloat64('6.000000000000001e-9'),\n+    toFloat32('1.7091'),\n+    toFloat32('1.5008753E7'),\n+    toFloat32('6e-09'),\n+    toFloat32('6.000000000000001e-9')\n+SETTINGS precise_float_parsing = 1;\n",
  "problem_statement": "Give the ability to choose float from string parsing algorithms.[Fast/Precise]\nIn continuation of #1665\r\n\r\nIt would be useful to be able choose a float parsing algorithm, as some drivers don't support binary formats and that can be done as session setting.\r\n\r\n**Use case**\r\nClickhouse version 20.13.1.5365\r\n```\r\nSELECT\r\n    toFloat64(15008753.),\r\n    toFloat64('1.5008753E7')\r\n\r\nQuery id: b4376f9b-a74d-4442-9113-5a48ce0e32cf\r\n\r\n\u250c\u2500toFloat64(15008753.)\u2500\u252c\u2500toFloat64('1.5008753E7')\u2500\u2510\r\n\u2502             15008753 \u2502       15008753.000000002 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n**Describe alternatives you've considered**\r\nUse Decimal as a data type and later convert it to float64 (via Default for example).\r\n\n",
  "hints_text": "No one has worked on this issue.\n```\r\nSELECT toFloat64('1.7091')\r\n\r\n\r\n\r\n\u250c\u2500toFloat64('1.7091')\u2500\u2510\r\n\u2502  1.7090999999999998 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nSELECT toFloat64(1.7091)\r\n\r\nQuery id: 0be07668-f586-4e00-aba0-5aa2ddeb8193\r\n\r\n\u250c\u2500toFloat64(1.7091)\u2500\u2510\r\n\u2502            1.7091 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n@alexey-milovidov \r\n\r\nMay be it make sense to reopen this issue?\r\nBecause losing fifth position of significant digits looks a bit too much for fast but a **bit** imprecise parsing. (It's understandable that it happened due difference in `0.000000002` in opposite side compared to first example, but it's more annoying to people, especially when they try to migrate their data from another DB solution)\nThis is useful when you replicate data between 2 systems. if the formatting is different, you can not run checksums ...\n@UnamedRus how do you think this shall look like? I'm thinking of a setting like `enable_precise_float_parsing` with default value 0\nYeah, via setting",
  "created_at": "2023-07-30T17:45:43Z"
}