{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 30242,
  "instance_id": "ClickHouse__ClickHouse-30242",
  "issue_numbers": [
    "30236"
  ],
  "base_commit": "574970a852423dc88a254d162dc50994ab4a4c9b",
  "patch": "diff --git a/docs/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md b/docs/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md\nindex f525ea64aa29..30e050ef9ef3 100644\n--- a/docs/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md\n+++ b/docs/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md\n@@ -155,6 +155,60 @@ Configuration example:\n LAYOUT(COMPLEX_KEY_HASHED())\n ```\n \n+### complex_key_sparse_hashed {#complex-key-sparse-hashed}\n+\n+This type of storage is for use with composite [keys](../../../sql-reference/dictionaries/external-dictionaries/external-dicts-dict-structure.md). Similar to `sparse_hashed`.\n+\n+Configuration example:\n+\n+``` xml\n+<layout>\n+  <complex_key_sparse_hashed />\n+</layout>\n+```\n+\n+``` sql\n+LAYOUT(COMPLEX_KEY_SPARSE_HASHED())\n+```\n+\n+### hashed_array {#dicts-external_dicts_dict_layout-hashed-array}\n+\n+The dictionary is completely stored in memory. Each attribute is stored in array. Key attribute is stored in the form of hashed table where value is index in attributes array. The dictionary can contain any number of elements with any identifiers In practice, the number of keys can reach tens of millions of items.\n+\n+All types of sources are supported. When updating, data (from a file or from a table) is read in its entirety.\n+\n+Configuration example:\n+\n+``` xml\n+<layout>\n+  <hashed_array>\n+  </hashed_array>\n+</layout>\n+```\n+\n+or\n+\n+``` sql\n+LAYOUT(HASHED_ARRAY())\n+```\n+\n+### complex_key_hashed_array {#complex-key-hashed-array}\n+\n+This type of storage is for use with composite [keys](../../../sql-reference/dictionaries/external-dictionaries/external-dicts-dict-structure.md). Similar to `hashed_array`.\n+\n+Configuration example:\n+\n+``` xml\n+<layout>\n+  <complex_key_hashed_array />\n+</layout>\n+```\n+\n+``` sql\n+LAYOUT(COMPLEX_KEY_HASHED_ARRAY())\n+```\n+\n+\n ### range_hashed {#range-hashed}\n \n The dictionary is stored in memory in the form of a hash table with an ordered array of ranges and their corresponding values.\ndiff --git a/src/Dictionaries/CMakeLists.txt b/src/Dictionaries/CMakeLists.txt\nindex bc5f0dc9567d..b1b3d6d55e0a 100644\n--- a/src/Dictionaries/CMakeLists.txt\n+++ b/src/Dictionaries/CMakeLists.txt\n@@ -10,6 +10,7 @@ if (CMAKE_BUILD_TYPE_UC STREQUAL \"RELEASE\" OR CMAKE_BUILD_TYPE_UC STREQUAL \"RELW\n     set_source_files_properties(\n         FlatDictionary.cpp\n         HashedDictionary.cpp\n+        HashedArrayDictionary.cpp\n         CacheDictionary.cpp\n         RangeHashedDictionary.cpp\n         DirectDictionary.cpp\ndiff --git a/src/Dictionaries/HashedArrayDictionary.cpp b/src/Dictionaries/HashedArrayDictionary.cpp\nnew file mode 100644\nindex 000000000000..3c02f377c3e7\n--- /dev/null\n+++ b/src/Dictionaries/HashedArrayDictionary.cpp\n@@ -0,0 +1,691 @@\n+#include \"HashedArrayDictionary.h\"\n+\n+#include <Core/Defines.h>\n+#include <DataTypes/DataTypesDecimal.h>\n+#include <Columns/ColumnsNumber.h>\n+#include <Columns/ColumnNullable.h>\n+#include <Functions/FunctionHelpers.h>\n+\n+#include <Dictionaries/DictionarySource.h>\n+#include <Dictionaries/DictionaryFactory.h>\n+#include <Dictionaries/HierarchyDictionariesUtils.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int BAD_ARGUMENTS;\n+    extern const int DICTIONARY_IS_EMPTY;\n+    extern const int UNSUPPORTED_METHOD;\n+}\n+\n+template <DictionaryKeyType dictionary_key_type>\n+HashedArrayDictionary<dictionary_key_type>::HashedArrayDictionary(\n+    const StorageID & dict_id_,\n+    const DictionaryStructure & dict_struct_,\n+    DictionarySourcePtr source_ptr_,\n+    const HashedArrayDictionaryStorageConfiguration & configuration_,\n+    BlockPtr update_field_loaded_block_)\n+    : IDictionary(dict_id_)\n+    , dict_struct(dict_struct_)\n+    , source_ptr(std::move(source_ptr_))\n+    , configuration(configuration_)\n+    , update_field_loaded_block(std::move(update_field_loaded_block_))\n+{\n+    createAttributes();\n+    loadData();\n+    calculateBytesAllocated();\n+}\n+\n+template <DictionaryKeyType dictionary_key_type>\n+ColumnPtr HashedArrayDictionary<dictionary_key_type>::getColumn(\n+    const std::string & attribute_name,\n+    const DataTypePtr & result_type,\n+    const Columns & key_columns,\n+    const DataTypes & key_types [[maybe_unused]],\n+    const ColumnPtr & default_values_column) const\n+{\n+    if (dictionary_key_type == DictionaryKeyType::Complex)\n+        dict_struct.validateKeyTypes(key_types);\n+\n+    ColumnPtr result;\n+\n+    DictionaryKeysArenaHolder<dictionary_key_type> arena_holder;\n+    DictionaryKeysExtractor<dictionary_key_type> extractor(key_columns, arena_holder.getComplexKeyArena());\n+\n+    const size_t size = extractor.getKeysSize();\n+\n+    const auto & dictionary_attribute = dict_struct.getAttribute(attribute_name, result_type);\n+    const size_t attribute_index = dict_struct.attribute_name_to_index.find(attribute_name)->second;\n+    auto & attribute = attributes[attribute_index];\n+\n+    bool is_attribute_nullable = attribute.is_index_null.has_value();\n+\n+    ColumnUInt8::MutablePtr col_null_map_to;\n+    ColumnUInt8::Container * vec_null_map_to = nullptr;\n+    if (attribute.is_index_null)\n+    {\n+        col_null_map_to = ColumnUInt8::create(size, false);\n+        vec_null_map_to = &col_null_map_to->getData();\n+    }\n+\n+    auto type_call = [&](const auto & dictionary_attribute_type)\n+    {\n+        using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n+        using AttributeType = typename Type::AttributeType;\n+        using ValueType = DictionaryValueType<AttributeType>;\n+        using ColumnProvider = DictionaryAttributeColumnProvider<AttributeType>;\n+\n+        DictionaryDefaultValueExtractor<AttributeType> default_value_extractor(dictionary_attribute.null_value, default_values_column);\n+\n+        auto column = ColumnProvider::getColumn(dictionary_attribute, size);\n+\n+        if constexpr (std::is_same_v<ValueType, Array>)\n+        {\n+            auto * out = column.get();\n+\n+            getItemsImpl<ValueType, false>(\n+                attribute,\n+                extractor,\n+                [&](const size_t, const Array & value, bool) { out->insert(value); },\n+                default_value_extractor);\n+        }\n+        else if constexpr (std::is_same_v<ValueType, StringRef>)\n+        {\n+            auto * out = column.get();\n+\n+            if (is_attribute_nullable)\n+                getItemsImpl<ValueType, true>(\n+                    attribute,\n+                    extractor,\n+                    [&](size_t row, const StringRef value, bool is_null)\n+                    {\n+                        (*vec_null_map_to)[row] = is_null;\n+                        out->insertData(value.data, value.size);\n+                    },\n+                    default_value_extractor);\n+            else\n+                getItemsImpl<ValueType, false>(\n+                    attribute,\n+                    extractor,\n+                    [&](size_t, const StringRef value, bool) { out->insertData(value.data, value.size); },\n+                    default_value_extractor);\n+        }\n+        else\n+        {\n+            auto & out = column->getData();\n+\n+            if (is_attribute_nullable)\n+                getItemsImpl<ValueType, true>(\n+                    attribute,\n+                    extractor,\n+                    [&](size_t row, const auto value, bool is_null)\n+                    {\n+                        (*vec_null_map_to)[row] = is_null;\n+                        out[row] = value;\n+                    },\n+                    default_value_extractor);\n+            else\n+                getItemsImpl<ValueType, false>(\n+                    attribute,\n+                    extractor,\n+                    [&](size_t row, const auto value, bool) { out[row] = value; },\n+                    default_value_extractor);\n+        }\n+\n+        result = std::move(column);\n+    };\n+\n+    callOnDictionaryAttributeType(attribute.type, type_call);\n+\n+    if (is_attribute_nullable)\n+        result = ColumnNullable::create(std::move(result), std::move(col_null_map_to));\n+\n+    return result;\n+}\n+\n+template <DictionaryKeyType dictionary_key_type>\n+ColumnUInt8::Ptr HashedArrayDictionary<dictionary_key_type>::hasKeys(const Columns & key_columns, const DataTypes & key_types) const\n+{\n+    if (dictionary_key_type == DictionaryKeyType::Complex)\n+        dict_struct.validateKeyTypes(key_types);\n+\n+    DictionaryKeysArenaHolder<dictionary_key_type> arena_holder;\n+    DictionaryKeysExtractor<dictionary_key_type> extractor(key_columns, arena_holder.getComplexKeyArena());\n+\n+    size_t keys_size = extractor.getKeysSize();\n+\n+    auto result = ColumnUInt8::create(keys_size, false);\n+    auto & out = result->getData();\n+\n+    if (attributes.empty())\n+    {\n+        query_count.fetch_add(keys_size, std::memory_order_relaxed);\n+        return result;\n+    }\n+\n+    size_t keys_found = 0;\n+\n+    for (size_t requested_key_index = 0; requested_key_index < keys_size; ++requested_key_index)\n+    {\n+        auto requested_key = extractor.extractCurrentKey();\n+\n+        out[requested_key_index] = key_attribute.container.find(requested_key) != key_attribute.container.end();\n+\n+        keys_found += out[requested_key_index];\n+        extractor.rollbackCurrentKey();\n+    }\n+\n+    query_count.fetch_add(keys_size, std::memory_order_relaxed);\n+    found_count.fetch_add(keys_found, std::memory_order_relaxed);\n+\n+    return result;\n+}\n+\n+template <DictionaryKeyType dictionary_key_type>\n+ColumnPtr HashedArrayDictionary<dictionary_key_type>::getHierarchy(ColumnPtr key_column [[maybe_unused]], const DataTypePtr &) const\n+{\n+    if constexpr (dictionary_key_type == DictionaryKeyType::Simple)\n+    {\n+        PaddedPODArray<UInt64> keys_backup_storage;\n+        const auto & keys = getColumnVectorData(this, key_column, keys_backup_storage);\n+\n+        size_t hierarchical_attribute_index = *dict_struct.hierarchical_attribute_index;\n+\n+        const auto & dictionary_attribute = dict_struct.attributes[hierarchical_attribute_index];\n+        const auto & hierarchical_attribute = attributes[hierarchical_attribute_index];\n+\n+        const auto & key_attribute_container = key_attribute.container;\n+\n+        const UInt64 null_value = dictionary_attribute.null_value.template get<UInt64>();\n+        const AttributeContainerType<UInt64> & parent_keys_container = std::get<AttributeContainerType<UInt64>>(hierarchical_attribute.container);\n+\n+        auto is_key_valid_func = [&](auto & key) { return key_attribute_container.find(key) != key_attribute_container.end(); };\n+\n+        size_t keys_found = 0;\n+\n+        auto get_parent_func = [&](auto & hierarchy_key)\n+        {\n+            std::optional<UInt64> result;\n+\n+            auto it = key_attribute_container.find(hierarchy_key);\n+\n+            if (it != key_attribute_container.end())\n+                result = parent_keys_container[it->getMapped()];\n+\n+            keys_found += result.has_value();\n+\n+            return result;\n+        };\n+\n+        auto dictionary_hierarchy_array = getKeysHierarchyArray(keys, null_value, is_key_valid_func, get_parent_func);\n+\n+        query_count.fetch_add(keys.size(), std::memory_order_relaxed);\n+        found_count.fetch_add(keys_found, std::memory_order_relaxed);\n+\n+        return dictionary_hierarchy_array;\n+    }\n+    else\n+    {\n+        return nullptr;\n+    }\n+}\n+\n+template <DictionaryKeyType dictionary_key_type>\n+ColumnUInt8::Ptr HashedArrayDictionary<dictionary_key_type>::isInHierarchy(\n+    ColumnPtr key_column [[maybe_unused]],\n+    ColumnPtr in_key_column [[maybe_unused]],\n+    const DataTypePtr &) const\n+{\n+    if constexpr (dictionary_key_type == DictionaryKeyType::Simple)\n+    {\n+        PaddedPODArray<UInt64> keys_backup_storage;\n+        const auto & keys = getColumnVectorData(this, key_column, keys_backup_storage);\n+\n+        PaddedPODArray<UInt64> keys_in_backup_storage;\n+        const auto & keys_in = getColumnVectorData(this, in_key_column, keys_in_backup_storage);\n+\n+        size_t hierarchical_attribute_index = *dict_struct.hierarchical_attribute_index;\n+\n+        const auto & dictionary_attribute = dict_struct.attributes[hierarchical_attribute_index];\n+        auto & hierarchical_attribute = attributes[hierarchical_attribute_index];\n+\n+        const auto & key_attribute_container = key_attribute.container;\n+\n+        const UInt64 null_value = dictionary_attribute.null_value.template get<UInt64>();\n+        const AttributeContainerType<UInt64> & parent_keys_container = std::get<AttributeContainerType<UInt64>>(hierarchical_attribute.container);\n+\n+        auto is_key_valid_func = [&](auto & key) { return key_attribute_container.find(key) != key_attribute_container.end(); };\n+\n+        size_t keys_found = 0;\n+\n+        auto get_parent_func = [&](auto & hierarchy_key)\n+        {\n+            std::optional<UInt64> result;\n+\n+            auto it = key_attribute_container.find(hierarchy_key);\n+\n+            if (it != key_attribute_container.end())\n+                result = parent_keys_container[it->getMapped()];\n+\n+            keys_found += result.has_value();\n+\n+            return result;\n+        };\n+\n+        auto result = getKeysIsInHierarchyColumn(keys, keys_in, null_value, is_key_valid_func, get_parent_func);\n+\n+        query_count.fetch_add(keys.size(), std::memory_order_relaxed);\n+        found_count.fetch_add(keys_found, std::memory_order_relaxed);\n+\n+        return result;\n+    }\n+    else\n+    {\n+        return nullptr;\n+    }\n+}\n+\n+template <DictionaryKeyType dictionary_key_type>\n+ColumnPtr HashedArrayDictionary<dictionary_key_type>::getDescendants(\n+    ColumnPtr key_column [[maybe_unused]],\n+    const DataTypePtr &,\n+    size_t level [[maybe_unused]]) const\n+{\n+    if constexpr (dictionary_key_type == DictionaryKeyType::Simple)\n+    {\n+        PaddedPODArray<UInt64> keys_backup;\n+        const auto & keys = getColumnVectorData(this, key_column, keys_backup);\n+\n+        size_t hierarchical_attribute_index = *dict_struct.hierarchical_attribute_index;\n+\n+        const auto & hierarchical_attribute = attributes[hierarchical_attribute_index];\n+        const AttributeContainerType<UInt64> & parent_keys_container = std::get<AttributeContainerType<UInt64>>(hierarchical_attribute.container);\n+\n+        const auto & key_attribute_container = key_attribute.container;\n+\n+        HashMap<size_t, UInt64> index_to_key;\n+        index_to_key.reserve(key_attribute.container.size());\n+\n+        for (auto & [key, value] : key_attribute_container)\n+            index_to_key[value] = key;\n+\n+        HashMap<UInt64, PaddedPODArray<UInt64>> parent_to_child;\n+\n+        for (size_t i = 0; i < parent_keys_container.size(); ++i)\n+        {\n+            const auto * it = index_to_key.find(i);\n+            if (it == index_to_key.end())\n+                continue;\n+\n+            auto parent_key = it->getMapped();\n+            auto child_key = parent_keys_container[i];\n+            parent_to_child[parent_key].emplace_back(child_key);\n+        }\n+\n+        size_t keys_found = 0;\n+        auto result = getKeysDescendantsArray(keys, parent_to_child, level, keys_found);\n+\n+        query_count.fetch_add(keys.size(), std::memory_order_relaxed);\n+        found_count.fetch_add(keys_found, std::memory_order_relaxed);\n+\n+        return result;\n+    }\n+    else\n+    {\n+        return nullptr;\n+    }\n+}\n+\n+template <DictionaryKeyType dictionary_key_type>\n+void HashedArrayDictionary<dictionary_key_type>::createAttributes()\n+{\n+    const auto size = dict_struct.attributes.size();\n+    attributes.reserve(size);\n+\n+    for (const auto & dictionary_attribute : dict_struct.attributes)\n+    {\n+        auto type_call = [&, this](const auto & dictionary_attribute_type)\n+        {\n+            using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n+            using AttributeType = typename Type::AttributeType;\n+            using ValueType = DictionaryValueType<AttributeType>;\n+\n+            auto is_index_null = dictionary_attribute.is_nullable ? std::make_optional<std::vector<bool>>() : std::optional<std::vector<bool>>{};\n+            std::unique_ptr<Arena> string_arena = std::is_same_v<AttributeType, String> ? std::make_unique<Arena>() : nullptr;\n+            Attribute attribute{dictionary_attribute.underlying_type, AttributeContainerType<ValueType>(), std::move(is_index_null), std::move(string_arena)};\n+            attributes.emplace_back(std::move(attribute));\n+        };\n+\n+        callOnDictionaryAttributeType(dictionary_attribute.underlying_type, type_call);\n+    }\n+}\n+\n+template <DictionaryKeyType dictionary_key_type>\n+void HashedArrayDictionary<dictionary_key_type>::updateData()\n+{\n+    if (!update_field_loaded_block || update_field_loaded_block->rows() == 0)\n+    {\n+        QueryPipeline pipeline(source_ptr->loadUpdatedAll());\n+\n+        PullingPipelineExecutor executor(pipeline);\n+        Block block;\n+        while (executor.pull(block))\n+        {\n+            /// We are using this to keep saved data if input stream consists of multiple blocks\n+            if (!update_field_loaded_block)\n+                update_field_loaded_block = std::make_shared<DB::Block>(block.cloneEmpty());\n+\n+            for (size_t attribute_index = 0; attribute_index < block.columns(); ++attribute_index)\n+            {\n+                const IColumn & update_column = *block.getByPosition(attribute_index).column.get();\n+                MutableColumnPtr saved_column = update_field_loaded_block->getByPosition(attribute_index).column->assumeMutable();\n+                saved_column->insertRangeFrom(update_column, 0, update_column.size());\n+            }\n+        }\n+    }\n+    else\n+    {\n+        auto pipe = source_ptr->loadUpdatedAll();\n+        mergeBlockWithPipe<dictionary_key_type>(\n+            dict_struct.getKeysSize(),\n+            *update_field_loaded_block,\n+            std::move(pipe));\n+    }\n+\n+    if (update_field_loaded_block)\n+    {\n+        resize(update_field_loaded_block->rows());\n+        blockToAttributes(*update_field_loaded_block.get());\n+    }\n+}\n+\n+template <DictionaryKeyType dictionary_key_type>\n+void HashedArrayDictionary<dictionary_key_type>::blockToAttributes(const Block & block [[maybe_unused]])\n+{\n+    size_t skip_keys_size_offset = dict_struct.getKeysSize();\n+\n+    Columns key_columns;\n+    key_columns.reserve(skip_keys_size_offset);\n+\n+    /// Split into keys columns and attribute columns\n+    for (size_t i = 0; i < skip_keys_size_offset; ++i)\n+        key_columns.emplace_back(block.safeGetByPosition(i).column);\n+\n+    DictionaryKeysArenaHolder<dictionary_key_type> arena_holder;\n+    DictionaryKeysExtractor<dictionary_key_type> keys_extractor(key_columns, arena_holder.getComplexKeyArena());\n+    const size_t keys_size = keys_extractor.getKeysSize();\n+\n+    Field column_value_to_insert;\n+\n+    for (size_t key_index = 0; key_index < keys_size; ++key_index)\n+    {\n+        auto key = keys_extractor.extractCurrentKey();\n+\n+        auto it = key_attribute.container.find(key);\n+\n+        if (it != key_attribute.container.end())\n+        {\n+            keys_extractor.rollbackCurrentKey();\n+            continue;\n+        }\n+\n+        if constexpr (std::is_same_v<KeyType, StringRef>)\n+            key = copyKeyInArena(key);\n+\n+        key_attribute.container.insert({key, element_count});\n+\n+        for (size_t attribute_index = 0; attribute_index < attributes.size(); ++attribute_index)\n+        {\n+            const IColumn & attribute_column = *block.safeGetByPosition(skip_keys_size_offset + attribute_index).column;\n+            auto & attribute = attributes[attribute_index];\n+            bool attribute_is_nullable = attribute.is_index_null.has_value();\n+\n+            attribute_column.get(key_index, column_value_to_insert);\n+\n+            auto type_call = [&](const auto & dictionary_attribute_type)\n+            {\n+                using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n+                using AttributeType = typename Type::AttributeType;\n+                using AttributeValueType = DictionaryValueType<AttributeType>;\n+\n+                auto & attribute_container = std::get<AttributeContainerType<AttributeValueType>>(attribute.container);\n+                attribute_container.emplace_back();\n+\n+                if (attribute_is_nullable)\n+                {\n+                    attribute.is_index_null->emplace_back();\n+\n+                    if (column_value_to_insert.isNull())\n+                    {\n+                        (*attribute.is_index_null).back() = true;\n+                        return;\n+                    }\n+                }\n+\n+                if constexpr (std::is_same_v<AttributeValueType, StringRef>)\n+                {\n+                    String & value_to_insert = column_value_to_insert.get<String>();\n+                    size_t value_to_insert_size = value_to_insert.size();\n+\n+                    const char * string_in_arena = attribute.string_arena->insert(value_to_insert.data(), value_to_insert_size);\n+\n+                    StringRef string_in_arena_reference = StringRef{string_in_arena, value_to_insert_size};\n+                    attribute_container.back() = string_in_arena_reference;\n+                }\n+                else\n+                {\n+                    auto value_to_insert = column_value_to_insert.get<NearestFieldType<AttributeValueType>>();\n+                    attribute_container.back() = value_to_insert;\n+                }\n+            };\n+\n+            callOnDictionaryAttributeType(attribute.type, type_call);\n+        }\n+\n+        ++element_count;\n+        keys_extractor.rollbackCurrentKey();\n+    }\n+}\n+\n+template <DictionaryKeyType dictionary_key_type>\n+void HashedArrayDictionary<dictionary_key_type>::resize(size_t added_rows)\n+{\n+    if (unlikely(!added_rows))\n+        return;\n+\n+    key_attribute.container.reserve(added_rows);\n+}\n+\n+template <DictionaryKeyType dictionary_key_type>\n+template <typename AttributeType, bool is_nullable, typename ValueSetter, typename DefaultValueExtractor>\n+void HashedArrayDictionary<dictionary_key_type>::getItemsImpl(\n+    const Attribute & attribute,\n+    DictionaryKeysExtractor<dictionary_key_type> & keys_extractor,\n+    ValueSetter && set_value [[maybe_unused]],\n+    DefaultValueExtractor & default_value_extractor) const\n+{\n+    const auto & key_attribute_container = key_attribute.container;\n+    const auto & attribute_container = std::get<AttributeContainerType<AttributeType>>(attribute.container);\n+    const size_t keys_size = keys_extractor.getKeysSize();\n+\n+    size_t keys_found = 0;\n+\n+    for (size_t key_index = 0; key_index < keys_size; ++key_index)\n+    {\n+        auto key = keys_extractor.extractCurrentKey();\n+\n+        const auto it = key_attribute_container.find(key);\n+\n+        if (it != key_attribute_container.end())\n+        {\n+            size_t element_index = it->getMapped();\n+\n+            const auto & element = attribute_container[element_index];\n+\n+            if constexpr (is_nullable)\n+                set_value(key_index, element, (*attribute.is_index_null)[element_index]);\n+            else\n+                set_value(key_index, element, false);\n+\n+            ++keys_found;\n+        }\n+        else\n+        {\n+            if constexpr (is_nullable)\n+                set_value(key_index, default_value_extractor[key_index], default_value_extractor.isNullAt(key_index));\n+            else\n+                set_value(key_index, default_value_extractor[key_index], false);\n+        }\n+\n+        keys_extractor.rollbackCurrentKey();\n+    }\n+\n+    query_count.fetch_add(keys_size, std::memory_order_relaxed);\n+    found_count.fetch_add(keys_found, std::memory_order_relaxed);\n+}\n+\n+template <DictionaryKeyType dictionary_key_type>\n+StringRef HashedArrayDictionary<dictionary_key_type>::copyKeyInArena(StringRef key)\n+{\n+    size_t key_size = key.size;\n+    char * place_for_key = complex_key_arena.alloc(key_size);\n+    memcpy(reinterpret_cast<void *>(place_for_key), reinterpret_cast<const void *>(key.data), key_size);\n+    StringRef updated_key{place_for_key, key_size};\n+    return updated_key;\n+}\n+\n+template <DictionaryKeyType dictionary_key_type>\n+void HashedArrayDictionary<dictionary_key_type>::loadData()\n+{\n+    if (!source_ptr->hasUpdateField())\n+    {\n+        QueryPipeline pipeline;\n+        pipeline = QueryPipeline(source_ptr->loadAll());\n+\n+        PullingPipelineExecutor executor(pipeline);\n+        Block block;\n+        while (executor.pull(block))\n+        {\n+            resize(block.rows());\n+            blockToAttributes(block);\n+        }\n+    }\n+    else\n+    {\n+        updateData();\n+    }\n+\n+    if (configuration.require_nonempty && 0 == element_count)\n+        throw Exception(ErrorCodes::DICTIONARY_IS_EMPTY,\n+            \"{}: dictionary source is empty and 'require_nonempty' property is set.\",\n+            full_name);\n+}\n+\n+template <DictionaryKeyType dictionary_key_type>\n+void HashedArrayDictionary<dictionary_key_type>::calculateBytesAllocated()\n+{\n+    bytes_allocated += attributes.size() * sizeof(attributes.front());\n+\n+    bytes_allocated += key_attribute.container.size();\n+\n+    for (auto & attribute : attributes)\n+    {\n+        auto type_call = [&](const auto & dictionary_attribute_type)\n+        {\n+            using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n+            using AttributeType = typename Type::AttributeType;\n+            using ValueType = DictionaryValueType<AttributeType>;\n+\n+            const auto & container = std::get<AttributeContainerType<ValueType>>(attribute.container);\n+            bytes_allocated += sizeof(AttributeContainerType<ValueType>);\n+\n+            if constexpr (std::is_same_v<ValueType, Array>)\n+            {\n+                /// It is not accurate calculations\n+                bytes_allocated += sizeof(Array) * container.size();\n+            }\n+            else\n+            {\n+                bytes_allocated += container.allocated_bytes();\n+            }\n+\n+            bucket_count = container.capacity();\n+\n+            if constexpr (std::is_same_v<ValueType, StringRef>)\n+                bytes_allocated += sizeof(Arena) + attribute.string_arena->size();\n+        };\n+\n+        callOnDictionaryAttributeType(attribute.type, type_call);\n+\n+        if (attribute.string_arena)\n+            bytes_allocated += attribute.string_arena->size();\n+\n+        if (attribute.is_index_null.has_value())\n+            bytes_allocated += (*attribute.is_index_null).size();\n+    }\n+\n+    bytes_allocated += complex_key_arena.size();\n+\n+    if (update_field_loaded_block)\n+        bytes_allocated += update_field_loaded_block->allocatedBytes();\n+}\n+\n+template <DictionaryKeyType dictionary_key_type>\n+Pipe HashedArrayDictionary<dictionary_key_type>::read(const Names & column_names, size_t max_block_size) const\n+{\n+    PaddedPODArray<HashedArrayDictionary::KeyType> keys;\n+    keys.reserve(key_attribute.container.size());\n+\n+    for (auto & [key, _] : key_attribute.container)\n+        keys.emplace_back(key);\n+\n+    return Pipe(std::make_shared<DictionarySource>(DictionarySourceData(shared_from_this(), std::move(keys), column_names), max_block_size));\n+}\n+\n+template class HashedArrayDictionary<DictionaryKeyType::Simple>;\n+template class HashedArrayDictionary<DictionaryKeyType::Complex>;\n+\n+void registerDictionaryArrayHashed(DictionaryFactory & factory)\n+{\n+    auto create_layout = [](const std::string & full_name,\n+                             const DictionaryStructure & dict_struct,\n+                             const Poco::Util::AbstractConfiguration & config,\n+                             const std::string & config_prefix,\n+                             DictionarySourcePtr source_ptr,\n+                             DictionaryKeyType dictionary_key_type) -> DictionaryPtr\n+    {\n+        if (dictionary_key_type == DictionaryKeyType::Simple && dict_struct.key)\n+            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"'key' is not supported for simple key hashed array dictionary\");\n+        else if (dictionary_key_type == DictionaryKeyType::Complex && dict_struct.id)\n+            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"'id' is not supported for complex key hashed array dictionary\");\n+\n+        if (dict_struct.range_min || dict_struct.range_max)\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                \"{}: elements .structure.range_min and .structure.range_max should be defined only \"\n+                \"for a dictionary of layout 'range_hashed'\",\n+                full_name);\n+\n+        const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);\n+        const DictionaryLifetime dict_lifetime{config, config_prefix + \".lifetime\"};\n+        const bool require_nonempty = config.getBool(config_prefix + \".require_nonempty\", false);\n+\n+        HashedArrayDictionaryStorageConfiguration configuration{require_nonempty, dict_lifetime};\n+\n+        if (dictionary_key_type == DictionaryKeyType::Simple)\n+            return std::make_unique<HashedArrayDictionary<DictionaryKeyType::Simple>>(dict_id, dict_struct, std::move(source_ptr), configuration);\n+        else\n+            return std::make_unique<HashedArrayDictionary<DictionaryKeyType::Complex>>(dict_id, dict_struct, std::move(source_ptr), configuration);\n+    };\n+\n+    using namespace std::placeholders;\n+\n+    factory.registerLayout(\"hashed_array\",\n+        [=](auto && a, auto && b, auto && c, auto && d, DictionarySourcePtr e, ContextPtr /* global_context */, bool /*created_from_ddl*/){ return create_layout(a, b, c, d, std::move(e), DictionaryKeyType::Simple); }, false);\n+    factory.registerLayout(\"complex_key_hashed_array\",\n+        [=](auto && a, auto && b, auto && c, auto && d, DictionarySourcePtr e, ContextPtr /* global_context */, bool /*created_from_ddl*/){ return create_layout(a, b, c, d, std::move(e), DictionaryKeyType::Complex); }, true);\n+}\n+\n+}\ndiff --git a/src/Dictionaries/HashedArrayDictionary.h b/src/Dictionaries/HashedArrayDictionary.h\nnew file mode 100644\nindex 000000000000..053813bdc445\n--- /dev/null\n+++ b/src/Dictionaries/HashedArrayDictionary.h\n@@ -0,0 +1,211 @@\n+#pragma once\n+\n+#include <atomic>\n+#include <memory>\n+#include <variant>\n+#include <optional>\n+\n+#include <Common/SparseHashMap.h>\n+\n+#include <Common/HashTable/HashMap.h>\n+#include <Common/HashTable/HashSet.h>\n+#include <Core/Block.h>\n+\n+#include <Dictionaries/DictionaryStructure.h>\n+#include <Dictionaries/IDictionary.h>\n+#include <Dictionaries/IDictionarySource.h>\n+#include <Dictionaries/DictionaryHelpers.h>\n+\n+/** This dictionary stores all attributes in arrays.\n+  * Key is stored in hash table and value is index into attribute array.\n+  */\n+\n+namespace DB\n+{\n+\n+struct HashedArrayDictionaryStorageConfiguration\n+{\n+    const bool require_nonempty;\n+    const DictionaryLifetime lifetime;\n+};\n+\n+template <DictionaryKeyType dictionary_key_type>\n+class HashedArrayDictionary final : public IDictionary\n+{\n+public:\n+    using KeyType = std::conditional_t<dictionary_key_type == DictionaryKeyType::Simple, UInt64, StringRef>;\n+\n+    HashedArrayDictionary(\n+        const StorageID & dict_id_,\n+        const DictionaryStructure & dict_struct_,\n+        DictionarySourcePtr source_ptr_,\n+        const HashedArrayDictionaryStorageConfiguration & configuration_,\n+        BlockPtr update_field_loaded_block_ = nullptr);\n+\n+    std::string getTypeName() const override\n+    {\n+        if constexpr (dictionary_key_type == DictionaryKeyType::Simple)\n+            return \"HashedArray\";\n+        else\n+            return \"ComplexHashedArray\";\n+    }\n+\n+    size_t getBytesAllocated() const override { return bytes_allocated; }\n+\n+    size_t getQueryCount() const override { return query_count.load(std::memory_order_relaxed); }\n+\n+    double getFoundRate() const override\n+    {\n+        size_t queries = query_count.load(std::memory_order_relaxed);\n+        if (!queries)\n+            return 0;\n+        return static_cast<double>(found_count.load(std::memory_order_relaxed)) / queries;\n+    }\n+\n+    double getHitRate() const override { return 1.0; }\n+\n+    size_t getElementCount() const override { return element_count; }\n+\n+    double getLoadFactor() const override { return static_cast<double>(element_count) / bucket_count; }\n+\n+    std::shared_ptr<const IExternalLoadable> clone() const override\n+    {\n+        return std::make_shared<HashedArrayDictionary<dictionary_key_type>>(getDictionaryID(), dict_struct, source_ptr->clone(), configuration, update_field_loaded_block);\n+    }\n+\n+    const IDictionarySource * getSource() const override { return source_ptr.get(); }\n+\n+    const DictionaryLifetime & getLifetime() const override { return configuration.lifetime; }\n+\n+    const DictionaryStructure & getStructure() const override { return dict_struct; }\n+\n+    bool isInjective(const std::string & attribute_name) const override\n+    {\n+        return dict_struct.getAttribute(attribute_name).injective;\n+    }\n+\n+    DictionaryKeyType getKeyType() const override { return dictionary_key_type; }\n+\n+    ColumnPtr getColumn(\n+        const std::string& attribute_name,\n+        const DataTypePtr & result_type,\n+        const Columns & key_columns,\n+        const DataTypes & key_types,\n+        const ColumnPtr & default_values_column) const override;\n+\n+    ColumnUInt8::Ptr hasKeys(const Columns & key_columns, const DataTypes & key_types) const override;\n+\n+    bool hasHierarchy() const override { return dictionary_key_type == DictionaryKeyType::Simple && dict_struct.hierarchical_attribute_index.has_value(); }\n+\n+    ColumnPtr getHierarchy(ColumnPtr key_column, const DataTypePtr & hierarchy_attribute_type) const override;\n+\n+    ColumnUInt8::Ptr isInHierarchy(\n+        ColumnPtr key_column,\n+        ColumnPtr in_key_column,\n+        const DataTypePtr & key_type) const override;\n+\n+    ColumnPtr getDescendants(\n+        ColumnPtr key_column,\n+        const DataTypePtr & key_type,\n+        size_t level) const override;\n+\n+    Pipe read(const Names & column_names, size_t max_block_size) const override;\n+\n+private:\n+\n+    using KeyContainerType = std::conditional_t<\n+        dictionary_key_type == DictionaryKeyType::Simple,\n+        HashMap<UInt64, size_t>,\n+        HashMapWithSavedHash<StringRef, size_t, DefaultHash<StringRef>>>;\n+\n+    template <typename Value>\n+    using AttributeContainerType = std::conditional_t<std::is_same_v<Value, Array>, std::vector<Value>, PaddedPODArray<Value>>;\n+\n+    struct Attribute final\n+    {\n+        AttributeUnderlyingType type;\n+\n+        std::variant<\n+            AttributeContainerType<UInt8>,\n+            AttributeContainerType<UInt16>,\n+            AttributeContainerType<UInt32>,\n+            AttributeContainerType<UInt64>,\n+            AttributeContainerType<UInt128>,\n+            AttributeContainerType<UInt256>,\n+            AttributeContainerType<Int8>,\n+            AttributeContainerType<Int16>,\n+            AttributeContainerType<Int32>,\n+            AttributeContainerType<Int64>,\n+            AttributeContainerType<Int128>,\n+            AttributeContainerType<Int256>,\n+            AttributeContainerType<Decimal32>,\n+            AttributeContainerType<Decimal64>,\n+            AttributeContainerType<Decimal128>,\n+            AttributeContainerType<Decimal256>,\n+            AttributeContainerType<Float32>,\n+            AttributeContainerType<Float64>,\n+            AttributeContainerType<UUID>,\n+            AttributeContainerType<StringRef>,\n+            AttributeContainerType<Array>>\n+            container;\n+\n+        std::optional<std::vector<bool>> is_index_null;\n+        std::unique_ptr<Arena> string_arena;\n+    };\n+\n+    struct KeyAttribute final\n+    {\n+\n+        KeyContainerType container;\n+\n+    };\n+\n+    void createAttributes();\n+\n+    void blockToAttributes(const Block & block);\n+\n+    void updateData();\n+\n+    void loadData();\n+\n+    void calculateBytesAllocated();\n+\n+    template <typename AttributeType, bool is_nullable, typename ValueSetter, typename DefaultValueExtractor>\n+    void getItemsImpl(\n+        const Attribute & attribute,\n+        DictionaryKeysExtractor<dictionary_key_type> & keys_extractor,\n+        ValueSetter && set_value,\n+        DefaultValueExtractor & default_value_extractor) const;\n+\n+    template <typename GetContainerFunc>\n+    void getAttributeContainer(size_t attribute_index, GetContainerFunc && get_container_func);\n+\n+    template <typename GetContainerFunc>\n+    void getAttributeContainer(size_t attribute_index, GetContainerFunc && get_container_func) const;\n+\n+    void resize(size_t added_rows);\n+\n+    StringRef copyKeyInArena(StringRef key);\n+\n+    const DictionaryStructure dict_struct;\n+    const DictionarySourcePtr source_ptr;\n+    const HashedArrayDictionaryStorageConfiguration configuration;\n+\n+    std::vector<Attribute> attributes;\n+\n+    KeyAttribute key_attribute;\n+\n+    size_t bytes_allocated = 0;\n+    size_t element_count = 0;\n+    size_t bucket_count = 0;\n+    mutable std::atomic<size_t> query_count{0};\n+    mutable std::atomic<size_t> found_count{0};\n+\n+    BlockPtr update_field_loaded_block;\n+    Arena complex_key_arena;\n+};\n+\n+extern template class HashedArrayDictionary<DictionaryKeyType::Simple>;\n+extern template class HashedArrayDictionary<DictionaryKeyType::Complex>;\n+\n+}\ndiff --git a/src/Dictionaries/registerDictionaries.cpp b/src/Dictionaries/registerDictionaries.cpp\nindex 8d24a6ea979f..df191edd1c30 100644\n--- a/src/Dictionaries/registerDictionaries.cpp\n+++ b/src/Dictionaries/registerDictionaries.cpp\n@@ -28,6 +28,7 @@ void registerDictionaryComplexKeyHashed(DictionaryFactory & factory);\n void registerDictionaryTrie(DictionaryFactory & factory);\n void registerDictionaryFlat(DictionaryFactory & factory);\n void registerDictionaryHashed(DictionaryFactory & factory);\n+void registerDictionaryArrayHashed(DictionaryFactory & factory);\n void registerDictionaryCache(DictionaryFactory & factory);\n void registerDictionaryPolygon(DictionaryFactory & factory);\n void registerDictionaryDirect(DictionaryFactory & factory);\n@@ -60,6 +61,7 @@ void registerDictionaries()\n         registerDictionaryTrie(factory);\n         registerDictionaryFlat(factory);\n         registerDictionaryHashed(factory);\n+        registerDictionaryArrayHashed(factory);\n         registerDictionaryCache(factory);\n         registerDictionaryPolygon(factory);\n         registerDictionaryDirect(factory);\n",
  "test_patch": "diff --git a/tests/performance/hashed_array_dictionary.xml b/tests/performance/hashed_array_dictionary.xml\nnew file mode 100644\nindex 000000000000..a26e654248f4\n--- /dev/null\n+++ b/tests/performance/hashed_array_dictionary.xml\n@@ -0,0 +1,126 @@\n+<test>\n+    <create_query>\n+        CREATE TABLE simple_key_hashed_array_dictionary_source_table\n+        (\n+            id UInt64,\n+            value_int UInt64,\n+            value_string String,\n+            value_decimal Decimal64(8),\n+            value_string_nullable Nullable(String)\n+        ) ENGINE = Memory;\n+    </create_query>\n+\n+    <create_query>\n+        CREATE TABLE complex_key_hashed_array_dictionary_source_table\n+        (\n+            id UInt64,\n+            id_key String,\n+            value_int UInt64,\n+            value_string String,\n+            value_decimal Decimal64(8),\n+            value_string_nullable Nullable(String)\n+        ) ENGINE = Memory;\n+    </create_query>\n+\n+    <create_query>\n+        CREATE DICTIONARY simple_key_hashed_array_dictionary\n+        (\n+            id UInt64,\n+            value_int UInt64,\n+            value_string String,\n+            value_decimal Decimal64(8),\n+            value_string_nullable Nullable(String)\n+        )\n+        PRIMARY KEY id\n+        SOURCE(CLICKHOUSE(DB 'default' TABLE 'simple_key_hashed_array_dictionary_source_table'))\n+        LAYOUT(HASHED_ARRAY())\n+        LIFETIME(MIN 0 MAX 1000);\n+    </create_query>\n+\n+    <create_query>\n+        CREATE DICTIONARY complex_key_hashed_array_dictionary\n+        (\n+            id UInt64,\n+            id_key String,\n+            value_int UInt64,\n+            value_string String,\n+            value_decimal Decimal64(8),\n+            value_string_nullable Nullable(String)\n+        )\n+        PRIMARY KEY id, id_key\n+        SOURCE(CLICKHOUSE(DB 'default' TABLE 'complex_key_hashed_array_dictionary_source_table'))\n+        LAYOUT(COMPLEX_KEY_HASHED_ARRAY())\n+        LIFETIME(MIN 0 MAX 1000);\n+    </create_query>\n+\n+    <fill_query>\n+        INSERT INTO simple_key_hashed_array_dictionary_source_table\n+        SELECT number, number, toString(number), toDecimal64(number, 8), toString(number)\n+        FROM system.numbers\n+        LIMIT 5000000;\n+    </fill_query>\n+\n+    <fill_query>\n+        INSERT INTO complex_key_hashed_array_dictionary_source_table\n+        SELECT number, toString(number), number, toString(number), toDecimal64(number, 8), toString(number)\n+        FROM system.numbers\n+        LIMIT 5000000;\n+    </fill_query>\n+\n+    <substitutions>\n+        <substitution>\n+            <name>column_name</name>\n+            <values>\n+                <value>'value_int'</value>\n+                <value>'value_string'</value>\n+                <value>'value_decimal'</value>\n+                <value>'value_string_nullable'</value>\n+            </values>\n+        </substitution>\n+\n+        <substitution>\n+            <name>elements_count</name>\n+            <values>\n+                <value>5000000</value>\n+                <value>7500000</value>\n+            </values>\n+        </substitution>\n+    </substitutions>\n+\n+    <query>\n+        WITH rand64() % toUInt64({elements_count}) as key\n+        SELECT dictGet('default.simple_key_hashed_array_dictionary', {column_name}, key)\n+        FROM system.numbers\n+        LIMIT {elements_count}\n+        FORMAT Null;\n+    </query>\n+    <query>\n+        WITH rand64() % toUInt64({elements_count}) as key\n+        SELECT dictHas('default.simple_key_hashed_array_dictionary', key)\n+        FROM system.numbers\n+        LIMIT {elements_count}\n+        FORMAT Null;\n+    </query>\n+\n+    <query>\n+        WITH (rand64() % toUInt64({elements_count}), toString(rand64() % toUInt64({elements_count}))) as key\n+        SELECT dictGet('default.complex_key_hashed_array_dictionary', {column_name}, key)\n+        FROM system.numbers\n+        LIMIT {elements_count}\n+        FORMAT Null;\n+    </query>\n+    <query>\n+        WITH (rand64() % toUInt64({elements_count}), toString(rand64() % toUInt64({elements_count}))) as key\n+        SELECT dictHas('default.complex_key_hashed_array_dictionary', key)\n+        FROM system.numbers\n+        LIMIT {elements_count}\n+        FORMAT Null;\n+    </query>\n+\n+    <drop_query>DROP TABLE IF EXISTS simple_key_hashed_array_dictionary_source_table;</drop_query>\n+    <drop_query>DROP TABLE IF EXISTS complex_key_hashed_array_dictionary_source_table;</drop_query>\n+\n+    <drop_query>DROP DICTIONARY IF EXISTS simple_key_hashed_array_dictionary;</drop_query>\n+    <drop_query>DROP DICTIONARY IF EXISTS complex_key_hashed_array_dictionary;</drop_query>\n+\n+</test>\ndiff --git a/tests/queries/0_stateless/02098_hashed_array_dictionary_simple_key.reference b/tests/queries/0_stateless/02098_hashed_array_dictionary_simple_key.reference\nnew file mode 100644\nindex 000000000000..6e88bbad146f\n--- /dev/null\n+++ b/tests/queries/0_stateless/02098_hashed_array_dictionary_simple_key.reference\n@@ -0,0 +1,66 @@\n+Dictionary hashed_array_dictionary_simple_key_simple_attributes\n+dictGet existing value\n+value_0\tvalue_second_0\n+value_1\tvalue_second_1\n+value_2\tvalue_second_2\n+dictGet with non existing value\n+value_0\tvalue_second_0\n+value_1\tvalue_second_1\n+value_2\tvalue_second_2\n+value_first_default\tvalue_second_default\n+dictGetOrDefault existing value\n+value_0\tvalue_second_0\n+value_1\tvalue_second_1\n+value_2\tvalue_second_2\n+dictGetOrDefault non existing value\n+value_0\tvalue_second_0\n+value_1\tvalue_second_1\n+value_2\tvalue_second_2\n+default\tdefault\n+dictHas\n+1\n+1\n+1\n+0\n+select all values as input stream\n+0\tvalue_0\tvalue_second_0\n+1\tvalue_1\tvalue_second_1\n+2\tvalue_2\tvalue_second_2\n+Dictionary hashed_array_dictionary_simple_key_complex_attributes\n+dictGet existing value\n+value_0\tvalue_second_0\n+value_1\t\\N\n+value_2\tvalue_second_2\n+dictGet with non existing value\n+value_0\tvalue_second_0\n+value_1\t\\N\n+value_2\tvalue_second_2\n+value_first_default\tvalue_second_default\n+dictGetOrDefault existing value\n+value_0\tvalue_second_0\n+value_1\t\\N\n+value_2\tvalue_second_2\n+dictGetOrDefault non existing value\n+value_0\tvalue_second_0\n+value_1\t\\N\n+value_2\tvalue_second_2\n+default\tdefault\n+dictHas\n+1\n+1\n+1\n+0\n+select all values as input stream\n+0\tvalue_0\tvalue_second_0\n+1\tvalue_1\t\\N\n+2\tvalue_2\tvalue_second_2\n+Dictionary hashed_array_dictionary_simple_key_hierarchy\n+dictGet\n+0\n+0\n+1\n+1\n+2\n+dictGetHierarchy\n+[1]\n+[4,2,1]\ndiff --git a/tests/queries/0_stateless/02098_hashed_array_dictionary_simple_key.sql b/tests/queries/0_stateless/02098_hashed_array_dictionary_simple_key.sql\nnew file mode 100644\nindex 000000000000..8d7928365627\n--- /dev/null\n+++ b/tests/queries/0_stateless/02098_hashed_array_dictionary_simple_key.sql\n@@ -0,0 +1,125 @@\n+DROP TABLE IF EXISTS simple_key_simple_attributes_source_table;\n+CREATE TABLE simple_key_simple_attributes_source_table\n+(\n+   id UInt64,\n+   value_first String,\n+   value_second String\n+)\n+ENGINE = TinyLog;\n+\n+INSERT INTO simple_key_simple_attributes_source_table VALUES(0, 'value_0', 'value_second_0');\n+INSERT INTO simple_key_simple_attributes_source_table VALUES(1, 'value_1', 'value_second_1');\n+INSERT INTO simple_key_simple_attributes_source_table VALUES(2, 'value_2', 'value_second_2');\n+\n+DROP DICTIONARY IF EXISTS hashed_array_dictionary_simple_key_simple_attributes;\n+CREATE DICTIONARY hashed_array_dictionary_simple_key_simple_attributes\n+(\n+   id UInt64,\n+   value_first String DEFAULT 'value_first_default',\n+   value_second String DEFAULT 'value_second_default'\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(TABLE 'simple_key_simple_attributes_source_table'))\n+LAYOUT(HASHED_ARRAY())\n+LIFETIME(MIN 1 MAX 1000);\n+\n+SELECT 'Dictionary hashed_array_dictionary_simple_key_simple_attributes';\n+SELECT 'dictGet existing value';\n+SELECT dictGet('hashed_array_dictionary_simple_key_simple_attributes', 'value_first', number) as value_first,\n+    dictGet('hashed_array_dictionary_simple_key_simple_attributes', 'value_second', number) as value_second FROM system.numbers LIMIT 3;\n+SELECT 'dictGet with non existing value';\n+SELECT dictGet('hashed_array_dictionary_simple_key_simple_attributes', 'value_first', number) as value_first,\n+    dictGet('hashed_array_dictionary_simple_key_simple_attributes', 'value_second', number) as value_second FROM system.numbers LIMIT 4;\n+SELECT 'dictGetOrDefault existing value';\n+SELECT dictGetOrDefault('hashed_array_dictionary_simple_key_simple_attributes', 'value_first', number, toString('default')) as value_first,\n+    dictGetOrDefault('hashed_array_dictionary_simple_key_simple_attributes', 'value_second', number, toString('default')) as value_second FROM system.numbers LIMIT 3;\n+SELECT 'dictGetOrDefault non existing value';\n+SELECT dictGetOrDefault('hashed_array_dictionary_simple_key_simple_attributes', 'value_first', number, toString('default')) as value_first,\n+    dictGetOrDefault('hashed_array_dictionary_simple_key_simple_attributes', 'value_second', number, toString('default')) as value_second FROM system.numbers LIMIT 4;\n+SELECT 'dictHas';\n+SELECT dictHas('hashed_array_dictionary_simple_key_simple_attributes', number) FROM system.numbers LIMIT 4;\n+SELECT 'select all values as input stream';\n+SELECT * FROM hashed_array_dictionary_simple_key_simple_attributes ORDER BY id;\n+\n+DROP DICTIONARY hashed_array_dictionary_simple_key_simple_attributes;\n+\n+DROP TABLE simple_key_simple_attributes_source_table;\n+\n+DROP TABLE IF EXISTS simple_key_complex_attributes_source_table;\n+CREATE TABLE simple_key_complex_attributes_source_table\n+(\n+   id UInt64,\n+   value_first String,\n+   value_second Nullable(String)\n+)\n+ENGINE = TinyLog;\n+\n+INSERT INTO simple_key_complex_attributes_source_table VALUES(0, 'value_0', 'value_second_0');\n+INSERT INTO simple_key_complex_attributes_source_table VALUES(1, 'value_1', NULL);\n+INSERT INTO simple_key_complex_attributes_source_table VALUES(2, 'value_2', 'value_second_2');\n+\n+DROP DICTIONARY IF EXISTS hashed_array_dictionary_simple_key_complex_attributes;\n+CREATE DICTIONARY hashed_array_dictionary_simple_key_complex_attributes\n+(\n+   id UInt64,\n+   value_first String DEFAULT 'value_first_default',\n+   value_second Nullable(String) DEFAULT 'value_second_default'\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(TABLE 'simple_key_complex_attributes_source_table'))\n+LAYOUT(HASHED_ARRAY())\n+LIFETIME(MIN 1 MAX 1000);\n+\n+SELECT 'Dictionary hashed_array_dictionary_simple_key_complex_attributes';\n+SELECT 'dictGet existing value';\n+SELECT dictGet('hashed_array_dictionary_simple_key_complex_attributes', 'value_first', number) as value_first,\n+    dictGet('hashed_array_dictionary_simple_key_complex_attributes', 'value_second', number) as value_second FROM system.numbers LIMIT 3;\n+SELECT 'dictGet with non existing value';\n+SELECT dictGet('hashed_array_dictionary_simple_key_complex_attributes', 'value_first', number) as value_first,\n+    dictGet('hashed_array_dictionary_simple_key_complex_attributes', 'value_second', number) as value_second FROM system.numbers LIMIT 4;\n+SELECT 'dictGetOrDefault existing value';\n+SELECT dictGetOrDefault('hashed_array_dictionary_simple_key_complex_attributes', 'value_first', number, toString('default')) as value_first,\n+    dictGetOrDefault('hashed_array_dictionary_simple_key_complex_attributes', 'value_second', number, toString('default')) as value_second FROM system.numbers LIMIT 3;\n+SELECT 'dictGetOrDefault non existing value';\n+SELECT dictGetOrDefault('hashed_array_dictionary_simple_key_complex_attributes', 'value_first', number, toString('default')) as value_first,\n+    dictGetOrDefault('hashed_array_dictionary_simple_key_complex_attributes', 'value_second', number, toString('default')) as value_second FROM system.numbers LIMIT 4;\n+SELECT 'dictHas';\n+SELECT dictHas('hashed_array_dictionary_simple_key_complex_attributes', number) FROM system.numbers LIMIT 4;\n+SELECT 'select all values as input stream';\n+SELECT * FROM hashed_array_dictionary_simple_key_complex_attributes ORDER BY id;\n+\n+DROP DICTIONARY hashed_array_dictionary_simple_key_complex_attributes;\n+DROP TABLE simple_key_complex_attributes_source_table;\n+\n+DROP TABLE IF EXISTS simple_key_hierarchy_table;\n+CREATE TABLE simple_key_hierarchy_table\n+(\n+    id UInt64,\n+    parent_id UInt64\n+) ENGINE = TinyLog();\n+\n+INSERT INTO simple_key_hierarchy_table VALUES (1, 0);\n+INSERT INTO simple_key_hierarchy_table VALUES (2, 1);\n+INSERT INTO simple_key_hierarchy_table VALUES (3, 1);\n+INSERT INTO simple_key_hierarchy_table VALUES (4, 2);\n+\n+DROP DICTIONARY IF EXISTS hashed_array_dictionary_simple_key_hierarchy;\n+CREATE DICTIONARY hashed_array_dictionary_simple_key_hierarchy\n+(\n+   id UInt64,\n+   parent_id UInt64 HIERARCHICAL\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() USER 'default' TABLE 'simple_key_hierarchy_table'))\n+LAYOUT(HASHED_ARRAY())\n+LIFETIME(MIN 1 MAX 1000);\n+\n+SELECT 'Dictionary hashed_array_dictionary_simple_key_hierarchy';\n+SELECT 'dictGet';\n+SELECT dictGet('hashed_array_dictionary_simple_key_hierarchy', 'parent_id', number) FROM system.numbers LIMIT 5;\n+SELECT 'dictGetHierarchy';\n+SELECT dictGetHierarchy('hashed_array_dictionary_simple_key_hierarchy', toUInt64(1));\n+SELECT dictGetHierarchy('hashed_array_dictionary_simple_key_hierarchy', toUInt64(4));\n+\n+DROP DICTIONARY hashed_array_dictionary_simple_key_hierarchy;\n+DROP TABLE simple_key_hierarchy_table;\ndiff --git a/tests/queries/0_stateless/02099_hashed_array_dictionary_complex_key.reference b/tests/queries/0_stateless/02099_hashed_array_dictionary_complex_key.reference\nnew file mode 100644\nindex 000000000000..ec32fa72b4ef\n--- /dev/null\n+++ b/tests/queries/0_stateless/02099_hashed_array_dictionary_complex_key.reference\n@@ -0,0 +1,56 @@\n+Dictionary hashed_array_dictionary_complex_key_simple_attributes\n+dictGet existing value\n+value_0\tvalue_second_0\n+value_1\tvalue_second_1\n+value_2\tvalue_second_2\n+dictGet with non existing value\n+value_0\tvalue_second_0\n+value_1\tvalue_second_1\n+value_2\tvalue_second_2\n+value_first_default\tvalue_second_default\n+dictGetOrDefault existing value\n+value_0\tvalue_second_0\n+value_1\tvalue_second_1\n+value_2\tvalue_second_2\n+dictGetOrDefault non existing value\n+value_0\tvalue_second_0\n+value_1\tvalue_second_1\n+value_2\tvalue_second_2\n+default\tdefault\n+dictHas\n+1\n+1\n+1\n+0\n+select all values as input stream\n+0\tid_key_0\tvalue_0\tvalue_second_0\n+1\tid_key_1\tvalue_1\tvalue_second_1\n+2\tid_key_2\tvalue_2\tvalue_second_2\n+Dictionary hashed_array_dictionary_complex_key_complex_attributes\n+dictGet existing value\n+value_0\tvalue_second_0\n+value_1\t\\N\n+value_2\tvalue_second_2\n+dictGet with non existing value\n+value_0\tvalue_second_0\n+value_1\t\\N\n+value_2\tvalue_second_2\n+value_first_default\tvalue_second_default\n+dictGetOrDefault existing value\n+value_0\tvalue_second_0\n+value_1\t\\N\n+value_2\tvalue_second_2\n+dictGetOrDefault non existing value\n+value_0\tvalue_second_0\n+value_1\t\\N\n+value_2\tvalue_second_2\n+default\tdefault\n+dictHas\n+1\n+1\n+1\n+0\n+select all values as input stream\n+0\tid_key_0\tvalue_0\tvalue_second_0\n+1\tid_key_1\tvalue_1\t\\N\n+2\tid_key_2\tvalue_2\tvalue_second_2\ndiff --git a/tests/queries/0_stateless/02099_hashed_array_dictionary_complex_key.sql b/tests/queries/0_stateless/02099_hashed_array_dictionary_complex_key.sql\nnew file mode 100644\nindex 000000000000..4d2a825c8af6\n--- /dev/null\n+++ b/tests/queries/0_stateless/02099_hashed_array_dictionary_complex_key.sql\n@@ -0,0 +1,97 @@\n+DROP TABLE IF EXISTS complex_key_simple_attributes_source_table;\n+CREATE TABLE complex_key_simple_attributes_source_table\n+(\n+   id UInt64,\n+   id_key String,\n+   value_first String,\n+   value_second String\n+)\n+ENGINE = TinyLog;\n+\n+INSERT INTO complex_key_simple_attributes_source_table VALUES(0, 'id_key_0', 'value_0', 'value_second_0');\n+INSERT INTO complex_key_simple_attributes_source_table VALUES(1, 'id_key_1', 'value_1', 'value_second_1');\n+INSERT INTO complex_key_simple_attributes_source_table VALUES(2, 'id_key_2', 'value_2', 'value_second_2');\n+\n+DROP DICTIONARY IF EXISTS hashed_array_dictionary_complex_key_simple_attributes;\n+CREATE DICTIONARY hashed_array_dictionary_complex_key_simple_attributes\n+(\n+   id UInt64,\n+   id_key String,\n+   value_first String DEFAULT 'value_first_default',\n+   value_second String DEFAULT 'value_second_default'\n+)\n+PRIMARY KEY id, id_key\n+SOURCE(CLICKHOUSE(TABLE 'complex_key_simple_attributes_source_table'))\n+LIFETIME(MIN 1 MAX 1000)\n+LAYOUT(COMPLEX_KEY_HASHED_ARRAY());\n+\n+SELECT 'Dictionary hashed_array_dictionary_complex_key_simple_attributes';\n+SELECT 'dictGet existing value';\n+SELECT dictGet('hashed_array_dictionary_complex_key_simple_attributes', 'value_first', (number, concat('id_key_', toString(number)))) as value_first,\n+    dictGet('hashed_array_dictionary_complex_key_simple_attributes', 'value_second', (number, concat('id_key_', toString(number)))) as value_second FROM system.numbers LIMIT 3;\n+SELECT 'dictGet with non existing value';\n+SELECT dictGet('hashed_array_dictionary_complex_key_simple_attributes', 'value_first', (number, concat('id_key_', toString(number)))) as value_first,\n+    dictGet('hashed_array_dictionary_complex_key_simple_attributes', 'value_second', (number, concat('id_key_', toString(number)))) as value_second FROM system.numbers LIMIT 4;\n+SELECT 'dictGetOrDefault existing value';\n+SELECT dictGetOrDefault('hashed_array_dictionary_complex_key_simple_attributes', 'value_first', (number, concat('id_key_', toString(number))), toString('default')) as value_first,\n+    dictGetOrDefault('hashed_array_dictionary_complex_key_simple_attributes', 'value_second', (number, concat('id_key_', toString(number))), toString('default')) as value_second FROM system.numbers LIMIT 3;\n+SELECT 'dictGetOrDefault non existing value';\n+SELECT dictGetOrDefault('hashed_array_dictionary_complex_key_simple_attributes', 'value_first', (number, concat('id_key_', toString(number))), toString('default')) as value_first,\n+    dictGetOrDefault('hashed_array_dictionary_complex_key_simple_attributes', 'value_second', (number, concat('id_key_', toString(number))), toString('default')) as value_second FROM system.numbers LIMIT 4;\n+SELECT 'dictHas';\n+SELECT dictHas('hashed_array_dictionary_complex_key_simple_attributes', (number, concat('id_key_', toString(number)))) FROM system.numbers LIMIT 4;\n+SELECT 'select all values as input stream';\n+SELECT * FROM hashed_array_dictionary_complex_key_simple_attributes ORDER BY (id, id_key);\n+\n+DROP DICTIONARY hashed_array_dictionary_complex_key_simple_attributes;\n+\n+DROP TABLE complex_key_simple_attributes_source_table;\n+\n+DROP TABLE IF EXISTS complex_key_complex_attributes_source_table;\n+CREATE TABLE complex_key_complex_attributes_source_table\n+(\n+   id UInt64,\n+   id_key String,\n+   value_first String,\n+   value_second Nullable(String)\n+)\n+ENGINE = TinyLog;\n+\n+INSERT INTO complex_key_complex_attributes_source_table VALUES(0, 'id_key_0', 'value_0', 'value_second_0');\n+INSERT INTO complex_key_complex_attributes_source_table VALUES(1, 'id_key_1', 'value_1', NULL);\n+INSERT INTO complex_key_complex_attributes_source_table VALUES(2, 'id_key_2', 'value_2', 'value_second_2');\n+\n+DROP DICTIONARY IF EXISTS hashed_array_dictionary_complex_key_complex_attributes;\n+CREATE DICTIONARY hashed_array_dictionary_complex_key_complex_attributes\n+(\n+    id UInt64,\n+    id_key String,\n+\n+    value_first String DEFAULT 'value_first_default',\n+    value_second Nullable(String) DEFAULT 'value_second_default'\n+)\n+PRIMARY KEY id, id_key\n+SOURCE(CLICKHOUSE(TABLE 'complex_key_complex_attributes_source_table'))\n+LIFETIME(MIN 1 MAX 1000)\n+LAYOUT(COMPLEX_KEY_HASHED_ARRAY());\n+\n+SELECT 'Dictionary hashed_array_dictionary_complex_key_complex_attributes';\n+SELECT 'dictGet existing value';\n+SELECT dictGet('hashed_array_dictionary_complex_key_complex_attributes', 'value_first', (number, concat('id_key_', toString(number)))) as value_first,\n+    dictGet('hashed_array_dictionary_complex_key_complex_attributes', 'value_second', (number, concat('id_key_', toString(number)))) as value_second FROM system.numbers LIMIT 3;\n+SELECT 'dictGet with non existing value';\n+SELECT dictGet('hashed_array_dictionary_complex_key_complex_attributes', 'value_first', (number, concat('id_key_', toString(number)))) as value_first,\n+    dictGet('hashed_array_dictionary_complex_key_complex_attributes', 'value_second', (number, concat('id_key_', toString(number)))) as value_second FROM system.numbers LIMIT 4;\n+SELECT 'dictGetOrDefault existing value';\n+SELECT dictGetOrDefault('hashed_array_dictionary_complex_key_complex_attributes', 'value_first', (number, concat('id_key_', toString(number))), toString('default')) as value_first,\n+    dictGetOrDefault('hashed_array_dictionary_complex_key_complex_attributes', 'value_second', (number, concat('id_key_', toString(number))), toString('default')) as value_second FROM system.numbers LIMIT 3;\n+SELECT 'dictGetOrDefault non existing value';\n+SELECT dictGetOrDefault('hashed_array_dictionary_complex_key_complex_attributes', 'value_first', (number, concat('id_key_', toString(number))), toString('default')) as value_first,\n+    dictGetOrDefault('hashed_array_dictionary_complex_key_complex_attributes', 'value_second', (number, concat('id_key_', toString(number))), toString('default')) as value_second FROM system.numbers LIMIT 4;\n+SELECT 'dictHas';\n+SELECT dictHas('hashed_array_dictionary_complex_key_complex_attributes', (number, concat('id_key_', toString(number)))) FROM system.numbers LIMIT 4;\n+SELECT 'select all values as input stream';\n+SELECT * FROM hashed_array_dictionary_complex_key_complex_attributes ORDER BY (id, id_key);\n+\n+DROP DICTIONARY hashed_array_dictionary_complex_key_complex_attributes;\n+DROP TABLE complex_key_complex_attributes_source_table;\n",
  "problem_statement": "Ext. dictionary layout FLAT_TRANSLATED \nflat_index is an artificial autoincrement to make a demo, it does not needed, it just a flat array index for a translation table.\r\n\r\n```sql\r\ndrop dictionary if exists dict_complex_hashed;\r\ndrop dictionary if exists dict_translation;\r\ndrop dictionary if exists dict_flat;\r\ndrop table if exists dict_source;\r\n\r\ncreate table dict_source(key String, flat_index UInt64, s1 String, s2 String, s3 String, \r\ns4 String, s5 String, s6 String, s7 String, s8 String, s9 String, s10 String) Engine=Log;  \r\n\r\ninsert into dict_source select 'some key String :'||toString(cityHash64(number)), number,\r\n    (arrayMap(i->'some atribute string'||toString(number*i), range(10)) as x)[1],\r\n    x[2], x[3], x[4], x[5], x[6], x[7], x[8], x[9], x[10] from numbers(1000000);\r\n\r\ncreate dictionary dict_complex_hashed (key String, s1 String, s2 String, s3 String, \r\ns4 String, s5 String, s6 String, s7 String, s8 String, s9 String, s10 String)\r\nPRIMARY KEY key SOURCE(CLICKHOUSE(DATABASE 'default' TABLE 'dict_source')) lifetime(0)  \r\nLAYOUT(complex_key_hashed);\r\n\r\n\r\n\r\ncreate dictionary dict_translation(key String, flat_index UInt64)\r\nPRIMARY KEY key SOURCE(CLICKHOUSE(DATABASE 'default' TABLE 'dict_source')) lifetime(0)  \r\nLAYOUT(complex_key_hashed);\r\n\r\ncreate dictionary dict_flat (flat_index UInt64, s1 String, s2 String, s3 String, \r\ns4 String, s5 String, s6 String, s7 String, s8 String, s9 String, s10 String)\r\nPRIMARY KEY flat_index SOURCE(CLICKHOUSE(DATABASE 'default' TABLE 'dict_source')) lifetime(0)  \r\nLAYOUT(flat(INITIAL_ARRAY_SIZE 50000 MAX_ARRAY_SIZE 5000000));\r\n\r\n\r\nselect database, name, status, element_count, formatReadableSize(bytes_allocated) mem, loading_duration, type from system.dictionaries where name like 'dict_%';\r\n\u250c\u2500database\u2500\u252c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500status\u2500\u252c\u2500element_count\u2500\u252c\u2500mem\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500loading_duration\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 default  \u2502 dict_flat           \u2502 LOADED \u2502      10000000 \u2502 479.96 MiB \u2502            1.052 \u2502 Flat             \u2502\r\n\u2502 default  \u2502 dict_translation    \u2502 LOADED \u2502       1000000 \u2502 128.00 MiB \u2502            0.224 \u2502 ComplexKeyHashed \u2502\r\n\u2502 default  \u2502 dict_complex_hashed \u2502 LOADED \u2502      10000000 \u2502 1.59 GiB   \u2502            2.931 \u2502 ComplexKeyHashed \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n479.96 MiB + 128.00 MiB < 1.59 GiB\r\n1.052 + 0.224 < 2.931\r\n\r\nselect dictGet('dict_complex_hashed', 's8', tuple('some key String :17349973131760655344')) x ;\r\n\u250c\u2500x\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 some atribute string4406801 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nselect dictGet('dict_flat', 's8', dictGet('dict_translation', 'flat_index', tuple('some key String :17349973131760655344'))) x;\r\n\u250c\u2500x\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 some atribute string4406801 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nselect dictGet('dict_complex_hashed', 's5',  tuple('some key String :'||toString(cityHash64(number))) ) \r\nfrom numbers(1000000) format Null;\r\nElapsed: 0.166 sec. Processed 1.05 million rows\r\n\r\nselect dictGet('dict_flat', 's5', toUInt64(dictGet('dict_translation', 'flat_index', tuple('some key String :'||toString(cityHash64(number)))))) \r\nfrom numbers(1000000) format Null;\r\nElapsed: 0.180 sec. Processed 1.05 million rows\r\n```\n",
  "hints_text": "```\r\nSELECT\r\n    dictGet('dict_complex_hashed', 's5', tuple(concat('some key String :', toString(cityHash64(number))))),\r\n    dictGet('dict_complex_hashed', 's4', tuple(concat('some key String :', toString(cityHash64(number)))))\r\nFROM numbers(1000000)\r\nFORMAT `Null`\r\n\r\n0 rows in set. Elapsed: 0.755 sec. Processed 1.05 million rows, 8.38 MB (1.39 million rows/s., 11.10 MB/s.)\r\n\r\n\r\nlocaldomain :) select dictGet('dict_flat', 's5', toUInt64(dictGet('dict_translation', 'flat_index', tuple('some key String :'||toString(cityHash64(number)))))),  dictGet('dict_flat', 's4', toUInt64(dictGet('dict_translation', 'flat_index', tuple('some key String :'||toString(cityHash64(number))))))\u3000from numbers(1000000) format Null;\r\n\r\nSELECT\r\n    dictGet('dict_flat', 's5', toUInt64(dictGet('dict_translation', 'flat_index', tuple(concat('some key String :', toString(cityHash64(number))))))),\r\n    dictGet('dict_flat', 's4', toUInt64(dictGet('dict_translation', 'flat_index', tuple(concat('some key String :', toString(cityHash64(number)))))))\r\nFROM numbers(1000000)\r\nFORMAT `Null`\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.433 sec. Processed 1.05 million rows, 8.38 MB (2.42 million rows/s., 19.34 MB/s.)\r\n\r\n\r\nSELECT\r\n    dictGet('dict_complex_hashed', 's5', tuple(concat('some key String :', toString(cityHash64(number))))),\r\n    dictGet('dict_complex_hashed', 's4', tuple(concat('some key String :', toString(cityHash64(number))))),\r\n    dictGet('dict_complex_hashed', 's3', tuple(concat('some key String :', toString(cityHash64(number)))))\r\nFROM numbers(1000000)\r\nFORMAT `Null`\r\n\r\nQuery id: 5b68101d-78c6-4f89-bcd8-912b9b3eef11\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 1.078 sec. Processed 1.05 million rows, 8.38 MB (971.83 thousand rows/s., 7.77 MB/s.)\r\n\r\n\r\nSELECT\r\n    dictGet('dict_flat', 's5', toUInt64(dictGet('dict_translation', 'flat_index', tuple(concat('some key String :', toString(cityHash64(number))))))),\r\n    dictGet('dict_flat', 's4', toUInt64(dictGet('dict_translation', 'flat_index', tuple(concat('some key String :', toString(cityHash64(number))))))),\r\n    dictGet('dict_flat', 's3', toUInt64(dictGet('dict_translation', 'flat_index', tuple(concat('some key String :', toString(cityHash64(number)))))))\r\nFROM numbers(1000000)\r\nFORMAT `Null`\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.468 sec. Processed 1.05 million rows, 8.38 MB (2.24 million rows/s., 17.90 MB/s.)\r\n```\nalthough FLAT_TRANSLATED is a bad name, it's not about KEY type.",
  "created_at": "2021-10-15T15:53:55Z"
}