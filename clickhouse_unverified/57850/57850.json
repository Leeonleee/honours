{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 57850,
  "instance_id": "ClickHouse__ClickHouse-57850",
  "issue_numbers": [
    "57848"
  ],
  "base_commit": "bfd403cc8c90aeed456eb8286a6c6ba3b0434f74",
  "patch": "diff --git a/docs/en/sql-reference/table-functions/s3.md b/docs/en/sql-reference/table-functions/s3.md\nindex dc11259c6263..61a9187575dc 100644\n--- a/docs/en/sql-reference/table-functions/s3.md\n+++ b/docs/en/sql-reference/table-functions/s3.md\n@@ -16,7 +16,7 @@ When using the `s3 table function` with [`INSERT INTO...SELECT`](../../sql-refer\n **Syntax**\n \n ``` sql\n-s3(path [, NOSIGN | aws_access_key_id, aws_secret_access_key] [,format] [,structure] [,compression])\n+s3(path [, NOSIGN | aws_access_key_id, aws_secret_access_key [,session_token]] [,format] [,structure] [,compression])\n ```\n \n :::tip GCS\n@@ -38,6 +38,8 @@ For GCS, substitute your HMAC key and HMAC secret where you see `aws_access_key_\n   :::\n \n - `NOSIGN` - If this keyword is provided in place of credentials, all the requests will not be signed.\n+- `access_key_id`, `secret_access_key` \u2014 Keys that specify credentials to use with given endpoint. Optional.\n+- `session_token` - Session token to use with the given keys. Optional when passing keys.\n - `format` \u2014 The [format](../../interfaces/formats.md#formats) of the file.\n - `structure` \u2014 Structure of the table. Format `'column1_name column1_type, column2_name column2_type, ...'`.\n - `compression` \u2014 Parameter is optional. Supported values: `none`, `gzip/gz`, `brotli/br`, `xz/LZMA`, `zstd/zst`. By default, it will autodetect compression by file extension.\ndiff --git a/docs/en/sql-reference/table-functions/s3Cluster.md b/docs/en/sql-reference/table-functions/s3Cluster.md\nindex 799eb31446ae..080c98605196 100644\n--- a/docs/en/sql-reference/table-functions/s3Cluster.md\n+++ b/docs/en/sql-reference/table-functions/s3Cluster.md\n@@ -10,14 +10,15 @@ Allows processing files from [Amazon S3](https://aws.amazon.com/s3/) and Google\n **Syntax**\n \n ``` sql\n-s3Cluster(cluster_name, source, [,access_key_id, secret_access_key] [,format] [,structure])\n+s3Cluster(cluster_name, source, [,access_key_id, secret_access_key, [session_token]] [,format] [,structure])\n ```\n \n **Arguments**\n \n - `cluster_name` \u2014 Name of a cluster that is used to build a set of addresses and connection parameters to remote and local servers.\n - `source` \u2014 URL to a file or a bunch of files. Supports following wildcards in readonly mode: `*`, `**`, `?`, `{'abc','def'}` and `{N..M}` where `N`, `M` \u2014 numbers, `abc`, `def` \u2014 strings. For more information see [Wildcards In Path](../../engines/table-engines/integrations/s3.md#wildcards-in-path).\n-- `access_key_id` and `secret_access_key` \u2014 Keys that specify credentials to use with given endpoint. Optional.\n+- `access_key_id`, `secret_access_key` \u2014 Keys that specify credentials to use with given endpoint. Optional.\n+- `session_token` - Session token to use with the given keys. Optional when passing keys.\n - `format` \u2014 The [format](../../interfaces/formats.md#formats) of the file.\n - `structure` \u2014 Structure of the table. Format `'column1_name column1_type, column2_name column2_type, ...'`.\n \ndiff --git a/docs/ru/sql-reference/table-functions/s3.md b/docs/ru/sql-reference/table-functions/s3.md\nindex 7deef68f47fc..fe40cb0c5074 100644\n--- a/docs/ru/sql-reference/table-functions/s3.md\n+++ b/docs/ru/sql-reference/table-functions/s3.md\n@@ -11,7 +11,7 @@ sidebar_label: s3\n **\u0421\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441**\n \n ``` sql\n-s3(path [,aws_access_key_id, aws_secret_access_key] [,format] [,structure] [,compression])\n+s3(path [,access_key_id, secret_access_key [,session_token]] [,format] [,structure] [,compression])\n ```\n \n **A\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b**\ndiff --git a/docs/ru/sql-reference/table-functions/s3Cluster.md b/docs/ru/sql-reference/table-functions/s3Cluster.md\nindex b8f34d805ffc..b382bf5e3848 100644\n--- a/docs/ru/sql-reference/table-functions/s3Cluster.md\n+++ b/docs/ru/sql-reference/table-functions/s3Cluster.md\n@@ -11,14 +11,14 @@ sidebar_label: s3Cluster\n **\u0421\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441**\n \n ``` sql\n-s3Cluster(cluster_name, source, [,access_key_id, secret_access_key] [,format] [,structure])\n+s3Cluster(cluster_name, source, [,access_key_id, secret_access_key [,session_token]] [,format] [,structure])\n ```\n \n **\u0410\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b**\n \n -   `cluster_name` \u2014 \u0438\u043c\u044f \u043a\u043b\u0430\u0441\u0442\u0435\u0440\u0430, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0435 \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u043d\u0430\u0431\u043e\u0440\u0430 \u0430\u0434\u0440\u0435\u0441\u043e\u0432 \u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a \u0443\u0434\u0430\u043b\u0435\u043d\u043d\u044b\u043c \u0438 \u043b\u043e\u043a\u0430\u043b\u044c\u043d\u044b\u043c \u0441\u0435\u0440\u0432\u0435\u0440\u0430\u043c.\n -   `source` \u2014 URL \u0444\u0430\u0439\u043b\u0430 \u0438\u043b\u0438 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 \u0444\u0430\u0439\u043b\u043e\u0432. \u041f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u043f\u043e\u0434\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438: `*`, `?`, `{'abc','def'}` \u0438 `{N..M}`, \u0433\u0434\u0435 `N`, `M` \u2014 \u0447\u0438\u0441\u043b\u0430, `abc`, `def` \u2014 \u0441\u0442\u0440\u043e\u043a\u0438. \u041f\u043e\u0434\u0440\u043e\u0431\u043d\u0435\u0435 \u0441\u043c\u043e\u0442\u0440\u0438\u0442\u0435 \u0432 \u0440\u0430\u0437\u0434\u0435\u043b\u0435 [\u0421\u0438\u043c\u0432\u043e\u043b\u044b \u043f\u043e\u0434\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438](../../engines/table-engines/integrations/s3.md#wildcards-in-path).\n--   `access_key_id` \u0438 `secret_access_key` \u2014 \u043a\u043b\u044e\u0447\u0438, \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u044e\u0449\u0438\u0435 \u043d\u0430 \u0443\u0447\u0435\u0442\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0434\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0441 \u0442\u043e\u0447\u043a\u043e\u0439 \u043f\u0440\u0438\u0435\u043c\u0430 \u0437\u0430\u043f\u0440\u043e\u0441\u0430. \u041d\u0435\u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b.\n+-   `access_key_id`, `secret_access_key` \u0438 `session_token` \u2014 \u043a\u043b\u044e\u0447\u0438, \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u044e\u0449\u0438\u0435 \u043d\u0430 \u0443\u0447\u0435\u0442\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0434\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0441 \u0442\u043e\u0447\u043a\u043e\u0439 \u043f\u0440\u0438\u0435\u043c\u0430 \u0437\u0430\u043f\u0440\u043e\u0441\u0430. \u041d\u0435\u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b.\n -   `format` \u2014 [\u0444\u043e\u0440\u043c\u0430\u0442](../../interfaces/formats.md#formats) \u0444\u0430\u0439\u043b\u0430.\n -   `structure` \u2014 \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u0442\u0430\u0431\u043b\u0438\u0446\u044b. \u0424\u043e\u0440\u043c\u0430\u0442 `'column1_name column1_type, column2_name column2_type, ...'`.\n \ndiff --git a/docs/zh/sql-reference/table-functions/s3.md b/docs/zh/sql-reference/table-functions/s3.md\nindex a62fa9ebb191..f7384a7526e5 100644\n--- a/docs/zh/sql-reference/table-functions/s3.md\n+++ b/docs/zh/sql-reference/table-functions/s3.md\n@@ -11,7 +11,7 @@ sidebar_label: s3\n **\u8bed\u6cd5**\n \n ``` sql\n-s3(path, [aws_access_key_id, aws_secret_access_key,] format, structure, [compression])\n+s3(path [,access_key_id, secret_access_key [,session_token]] ,format, structure, [compression])\n ```\n \n **\u53c2\u6570**\ndiff --git a/src/Coordination/KeeperSnapshotManagerS3.cpp b/src/Coordination/KeeperSnapshotManagerS3.cpp\nindex d76e310f2a32..a245ccc16df6 100644\n--- a/src/Coordination/KeeperSnapshotManagerS3.cpp\n+++ b/src/Coordination/KeeperSnapshotManagerS3.cpp\n@@ -76,7 +76,7 @@ void KeeperSnapshotManagerS3::updateS3Configuration(const Poco::Util::AbstractCo\n \n         LOG_INFO(log, \"S3 configuration was updated\");\n \n-        auto credentials = Aws::Auth::AWSCredentials(auth_settings.access_key_id, auth_settings.secret_access_key);\n+        auto credentials = Aws::Auth::AWSCredentials(auth_settings.access_key_id, auth_settings.secret_access_key, auth_settings.session_token);\n         auto headers = auth_settings.headers;\n \n         static constexpr size_t s3_max_redirects = 10;\ndiff --git a/src/IO/S3Common.cpp b/src/IO/S3Common.cpp\nindex ffd6b6d711f7..96ad6413ef51 100644\n--- a/src/IO/S3Common.cpp\n+++ b/src/IO/S3Common.cpp\n@@ -109,6 +109,8 @@ AuthSettings AuthSettings::loadFromConfig(const std::string & config_elem, const\n {\n     auto access_key_id = config.getString(config_elem + \".access_key_id\", \"\");\n     auto secret_access_key = config.getString(config_elem + \".secret_access_key\", \"\");\n+    auto session_token = config.getString(config_elem + \".session_token\", \"\");\n+\n     auto region = config.getString(config_elem + \".region\", \"\");\n     auto server_side_encryption_customer_key_base64 = config.getString(config_elem + \".server_side_encryption_customer_key_base64\", \"\");\n \n@@ -133,7 +135,7 @@ AuthSettings AuthSettings::loadFromConfig(const std::string & config_elem, const\n \n     return AuthSettings\n     {\n-        std::move(access_key_id), std::move(secret_access_key),\n+        std::move(access_key_id), std::move(secret_access_key), std::move(session_token),\n         std::move(region),\n         std::move(server_side_encryption_customer_key_base64),\n         std::move(sse_kms_config),\n@@ -155,6 +157,8 @@ void AuthSettings::updateFrom(const AuthSettings & from)\n         access_key_id = from.access_key_id;\n     if (!from.secret_access_key.empty())\n         secret_access_key = from.secret_access_key;\n+    if (!from.session_token.empty())\n+        session_token = from.session_token;\n \n     headers = from.headers;\n     region = from.region;\ndiff --git a/src/IO/S3Common.h b/src/IO/S3Common.h\nindex 8c45c1c34a79..ebfc07a39767 100644\n--- a/src/IO/S3Common.h\n+++ b/src/IO/S3Common.h\n@@ -80,6 +80,7 @@ struct AuthSettings\n \n     std::string access_key_id;\n     std::string secret_access_key;\n+    std::string session_token;\n     std::string region;\n     std::string server_side_encryption_customer_key_base64;\n     ServerSideEncryptionKMSConfig server_side_encryption_kms_config;\ndiff --git a/src/Storages/StorageS3.cpp b/src/Storages/StorageS3.cpp\nindex 556b4f5655b5..096e2e88f913 100644\n--- a/src/Storages/StorageS3.cpp\n+++ b/src/Storages/StorageS3.cpp\n@@ -104,6 +104,7 @@ static const std::unordered_set<std::string_view> optional_configuration_keys =\n     \"structure\",\n     \"access_key_id\",\n     \"secret_access_key\",\n+    \"session_token\",\n     \"filename\",\n     \"use_environment_credentials\",\n     \"max_single_read_retries\",\n@@ -1460,7 +1461,7 @@ void StorageS3::Configuration::connect(ContextPtr context)\n \n     client_configuration.requestTimeoutMs = request_settings.request_timeout_ms;\n \n-    auto credentials = Aws::Auth::AWSCredentials(auth_settings.access_key_id, auth_settings.secret_access_key);\n+    auto credentials = Aws::Auth::AWSCredentials(auth_settings.access_key_id, auth_settings.secret_access_key, auth_settings.session_token);\n     client = S3::ClientFactory::instance().create(\n         client_configuration,\n         url.is_virtual_hosted_style,\n@@ -1521,11 +1522,14 @@ StorageS3::Configuration StorageS3::getConfiguration(ASTs & engine_args, Context\n         /// S3('url', NOSIGN, 'format')\n         /// S3('url', NOSIGN, 'format', 'compression')\n         /// S3('url', 'aws_access_key_id', 'aws_secret_access_key')\n+        /// S3('url', 'aws_access_key_id', 'aws_secret_access_key', 'session_token')\n         /// S3('url', 'aws_access_key_id', 'aws_secret_access_key', 'format')\n+        /// S3('url', 'aws_access_key_id', 'aws_secret_access_key', 'session_token', 'format')\n         /// S3('url', 'aws_access_key_id', 'aws_secret_access_key', 'format', 'compression')\n+        /// S3('url', 'aws_access_key_id', 'aws_secret_access_key', 'session_token', 'format', 'compression')\n         /// with optional headers() function\n \n-        if (engine_args.empty() || engine_args.size() > 5)\n+        if (engine_args.empty() || engine_args.size() > 6)\n             throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n                             \"Storage S3 requires 1 to 5 arguments: \"\n                             \"url, [NOSIGN | access_key_id, secret_access_key], name of used format and [compression_method]\");\n@@ -1541,7 +1545,7 @@ StorageS3::Configuration StorageS3::getConfiguration(ASTs & engine_args, Context\n         static std::unordered_map<size_t, std::unordered_map<std::string_view, size_t>> size_to_engine_args\n         {\n             {1, {{}}},\n-            {5, {{\"access_key_id\", 1}, {\"secret_access_key\", 2}, {\"format\", 3}, {\"compression_method\", 4}}}\n+            {6, {{\"access_key_id\", 1}, {\"secret_access_key\", 2}, {\"session_token\", 3}, {\"format\", 4}, {\"compression_method\", 5}}}\n         };\n \n         std::unordered_map<std::string_view, size_t> engine_args_to_idx;\n@@ -1577,7 +1581,8 @@ StorageS3::Configuration StorageS3::getConfiguration(ASTs & engine_args, Context\n             else\n                 engine_args_to_idx = {{\"access_key_id\", 1}, {\"secret_access_key\", 2}};\n         }\n-        /// For 4 arguments we support 2 possible variants:\n+        /// For 4 arguments we support 3 possible variants:\n+        /// - s3(source, access_key_id, secret_access_key, session_token)\n         /// - s3(source, access_key_id, secret_access_key, format)\n         /// - s3(source, NOSIGN, format, compression_method)\n         /// We can distinguish them by looking at the 2-nd argument: check if it's a NOSIGN or not.\n@@ -1590,7 +1595,32 @@ StorageS3::Configuration StorageS3::getConfiguration(ASTs & engine_args, Context\n                 engine_args_to_idx = {{\"format\", 2}, {\"compression_method\", 3}};\n             }\n             else\n-                engine_args_to_idx = {{\"access_key_id\", 1}, {\"secret_access_key\", 2}, {\"format\", 3}};\n+            {\n+                auto fourth_arg = checkAndGetLiteralArgument<String>(engine_args[3], \"session_token/format\");\n+                if (fourth_arg == \"auto\" || FormatFactory::instance().getAllFormats().contains(fourth_arg))\n+                {\n+                    engine_args_to_idx = {{\"access_key_id\", 1}, {\"secret_access_key\", 2}, {\"format\", 3}};\n+                }\n+                else\n+                {\n+                    engine_args_to_idx = {{\"access_key_id\", 1}, {\"secret_access_key\", 2}, {\"session_token\", 3}};\n+                }\n+            }\n+        }\n+        /// For 5 arguments we support 2 possible variants:\n+        /// - s3(source, access_key_id, secret_access_key, session_token, format)\n+        /// - s3(source, access_key_id, secret_access_key, format, compression)\n+        else if (engine_args.size() == 5)\n+        {\n+            auto fourth_arg = checkAndGetLiteralArgument<String>(engine_args[3], \"session_token/format\");\n+            if (fourth_arg == \"auto\" || FormatFactory::instance().getAllFormats().contains(fourth_arg))\n+            {\n+                engine_args_to_idx = {{\"access_key_id\", 1}, {\"secret_access_key\", 2}, {\"format\", 3}, {\"compression\", 4}};\n+            }\n+            else\n+            {\n+                engine_args_to_idx = {{\"access_key_id\", 1}, {\"secret_access_key\", 2}, {\"session_token\", 3}, {\"format\", 4}};\n+            }\n         }\n         else\n         {\n@@ -1612,6 +1642,10 @@ StorageS3::Configuration StorageS3::getConfiguration(ASTs & engine_args, Context\n         if (engine_args_to_idx.contains(\"secret_access_key\"))\n             configuration.auth_settings.secret_access_key = checkAndGetLiteralArgument<String>(engine_args[engine_args_to_idx[\"secret_access_key\"]], \"secret_access_key\");\n \n+        if (engine_args_to_idx.contains(\"session_token\"))\n+            configuration.auth_settings.session_token = checkAndGetLiteralArgument<String>(engine_args[engine_args_to_idx[\"session_token\"]], \"session_token\");\n+\n+\n         configuration.auth_settings.no_sign_request = no_sign_request;\n     }\n \ndiff --git a/src/TableFunctions/TableFunctionS3.cpp b/src/TableFunctions/TableFunctionS3.cpp\nindex e6ae75a5fd56..c52256fb9843 100644\n--- a/src/TableFunctions/TableFunctionS3.cpp\n+++ b/src/TableFunctions/TableFunctionS3.cpp\n@@ -71,7 +71,7 @@ void TableFunctionS3::parseArgumentsImpl(ASTs & args, const ContextPtr & context\n         if (header_it != args.end())\n             args.erase(header_it);\n \n-        if (args.empty() || args.size() > 6)\n+        if (args.empty() || args.size() > 7)\n             throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"The signature of table function {} shall be the following:\\n{}\", getName(), getSignature());\n \n         for (auto & arg : args)\n@@ -81,7 +81,7 @@ void TableFunctionS3::parseArgumentsImpl(ASTs & args, const ContextPtr & context\n         static std::unordered_map<size_t, std::unordered_map<std::string_view, size_t>> size_to_args\n         {\n             {1, {{}}},\n-            {6, {{\"access_key_id\", 1}, {\"secret_access_key\", 2}, {\"format\", 3}, {\"structure\", 4}, {\"compression_method\", 5}}}\n+            {7, {{\"access_key_id\", 1}, {\"secret_access_key\", 2}, {\"session_token\", 3}, {\"format\", 4}, {\"structure\", 5}, {\"compression_method\", 6}}}\n         };\n \n         std::unordered_map<std::string_view, size_t> args_to_idx;\n@@ -118,11 +118,12 @@ void TableFunctionS3::parseArgumentsImpl(ASTs & args, const ContextPtr & context\n             else\n                 args_to_idx = {{\"access_key_id\", 1}, {\"secret_access_key\", 2}};\n         }\n-        /// For 4 arguments we support 3 possible variants:\n+        /// For 4 arguments we support 4 possible variants:\n         /// - s3(source, format, structure, compression_method),\n-        /// - s3(source, access_key_id, access_key_id, format)\n+        /// - s3(source, access_key_id, access_key_id, format),\n+        /// - s3(source, access_key_id, access_key_id, session_token)\n         /// - s3(source, NOSIGN, format, structure)\n-        /// We can distinguish them by looking at the 2-nd argument: check if it's a format name or not.\n+        /// We can distinguish them by looking at the 2-nd and 4-th argument: check if it's a format name or not.\n         else if (args.size() == 4)\n         {\n             auto second_arg = checkAndGetLiteralArgument<String>(args[1], \"format/access_key_id/NOSIGN\");\n@@ -132,14 +133,28 @@ void TableFunctionS3::parseArgumentsImpl(ASTs & args, const ContextPtr & context\n                 args_to_idx = {{\"format\", 2}, {\"structure\", 3}};\n             }\n             else if (second_arg == \"auto\" || FormatFactory::instance().getAllFormats().contains(second_arg))\n+            {\n                 args_to_idx = {{\"format\", 1}, {\"structure\", 2}, {\"compression_method\", 3}};\n+            }\n             else\n-                args_to_idx = {{\"access_key_id\", 1}, {\"secret_access_key\", 2}, {\"format\", 3}};\n+            {\n+                auto fourth_arg = checkAndGetLiteralArgument<String>(args[3], \"format/session_token\");\n+                if (fourth_arg == \"auto\" || FormatFactory::instance().getAllFormats().contains(fourth_arg))\n+                {\n+                    args_to_idx = {{\"access_key_id\", 1}, {\"secret_access_key\", 2}, {\"format\", 3}};\n+                }\n+                else\n+                {\n+                    args_to_idx = {{\"access_key_id\", 1}, {\"secret_access_key\", 2}, {\"session_token\", 3}};\n+                }\n+            }\n         }\n-        /// For 5 arguments we support 2 possible variants:\n+        /// For 5 arguments we support 3 possible variants:\n         /// - s3(source, access_key_id, access_key_id, format, structure)\n+        /// - s3(source, access_key_id, access_key_id, session_token, format)\n         /// - s3(source, NOSIGN, format, structure, compression_method)\n-        /// We can distinguish them by looking at the 2-nd argument: check if it's a NOSIGN keyword name or not.\n+        /// We can distinguish them by looking at the 2-nd argument: check if it's a NOSIGN keyword name or no,\n+        /// and by the 4-th argument, check if it's a format name or not\n         else if (args.size() == 5)\n         {\n             auto second_arg = checkAndGetLiteralArgument<String>(args[1], \"NOSIGN/access_key_id\");\n@@ -149,7 +164,33 @@ void TableFunctionS3::parseArgumentsImpl(ASTs & args, const ContextPtr & context\n                 args_to_idx = {{\"format\", 2}, {\"structure\", 3}, {\"compression_method\", 4}};\n             }\n             else\n-                args_to_idx = {{\"access_key_id\", 1}, {\"secret_access_key\", 2}, {\"format\", 3}, {\"structure\", 4}};\n+            {\n+                auto fourth_arg = checkAndGetLiteralArgument<String>(args[3], \"format/session_token\");\n+                if (fourth_arg == \"auto\" || FormatFactory::instance().getAllFormats().contains(fourth_arg))\n+                {\n+                    args_to_idx = {{\"access_key_id\", 1}, {\"secret_access_key\", 2}, {\"format\", 3}, {\"structure\", 4}};\n+                }\n+                else\n+                {\n+                    args_to_idx = {{\"access_key_id\", 1}, {\"secret_access_key\", 2}, {\"session_token\", 3}, {\"format\", 4}};\n+                }\n+            }\n+        }\n+        // For 6 arguments we support 2 possible variants:\n+        /// - s3(source, access_key_id, access_key_id, format, structure, compression_method)\n+        /// - s3(source, access_key_id, access_key_id, session_token, format, structure)\n+        /// We can distinguish them by looking at the 4-th argument: check if it's a format name or not\n+        else if (args.size() == 6)\n+        {\n+            auto fourth_arg = checkAndGetLiteralArgument<String>(args[3], \"format/session_token\");\n+            if (fourth_arg == \"auto\" || FormatFactory::instance().getAllFormats().contains(fourth_arg))\n+            {\n+                args_to_idx = {{\"access_key_id\", 1}, {\"secret_access_key\", 2}, {\"format\", 3}, {\"structure\", 4}, {\"compression_method\", 5}};\n+            }\n+            else\n+            {\n+                args_to_idx = {{\"access_key_id\", 1}, {\"secret_access_key\", 2}, {\"session_token\", 3}, {\"format\", 4}, {\"structure\", 5}};\n+            }\n         }\n         else\n         {\n@@ -181,6 +222,9 @@ void TableFunctionS3::parseArgumentsImpl(ASTs & args, const ContextPtr & context\n         if (args_to_idx.contains(\"secret_access_key\"))\n             configuration.auth_settings.secret_access_key = checkAndGetLiteralArgument<String>(args[args_to_idx[\"secret_access_key\"]], \"secret_access_key\");\n \n+        if (args_to_idx.contains(\"session_token\"))\n+            configuration.auth_settings.session_token = checkAndGetLiteralArgument<String>(args[args_to_idx[\"session_token\"]], \"session_token\");\n+\n         configuration.auth_settings.no_sign_request = no_sign_request;\n \n         if (configuration.format == \"auto\")\ndiff --git a/src/TableFunctions/TableFunctionS3.h b/src/TableFunctions/TableFunctionS3.h\nindex fc3841760079..fa73c1d313e4 100644\n--- a/src/TableFunctions/TableFunctionS3.h\n+++ b/src/TableFunctions/TableFunctionS3.h\n@@ -22,11 +22,15 @@ class TableFunctionS3 : public ITableFunction\n     static constexpr auto signature = \" - url\\n\"\n                                       \" - url, format\\n\"\n                                       \" - url, format, structure\\n\"\n-                                      \" - url, access_key_id, secret_access_key\\n\"\n                                       \" - url, format, structure, compression_method\\n\"\n+                                      \" - url, access_key_id, secret_access_key\\n\"\n+                                      \" - url, access_key_id, secret_access_key, session_token\\n\"\n                                       \" - url, access_key_id, secret_access_key, format\\n\"\n+                                      \" - url, access_key_id, secret_access_key, session_token, format\\n\"\n                                       \" - url, access_key_id, secret_access_key, format, structure\\n\"\n+                                      \" - url, access_key_id, secret_access_key, session_token, format, structure\\n\"\n                                       \" - url, access_key_id, secret_access_key, format, structure, compression_method\\n\"\n+                                      \" - url, access_key_id, secret_access_key, session_token, format, structure, compression_method\\n\"\n                                       \"All signatures supports optional headers (specified as `headers('name'='value', 'name2'='value2')`)\";\n \n     static size_t getMaxNumberOfArguments() { return 6; }\ndiff --git a/src/TableFunctions/TableFunctionS3Cluster.h b/src/TableFunctions/TableFunctionS3Cluster.h\nindex 4fe25079cf40..718b0d90de8c 100644\n--- a/src/TableFunctions/TableFunctionS3Cluster.h\n+++ b/src/TableFunctions/TableFunctionS3Cluster.h\n@@ -35,6 +35,7 @@ class TableFunctionS3Cluster : public ITableFunctionCluster<TableFunctionS3>\n                                       \" - cluster, url, access_key_id, secret_access_key, format\\n\"\n                                       \" - cluster, url, access_key_id, secret_access_key, format, structure\\n\"\n                                       \" - cluster, url, access_key_id, secret_access_key, format, structure, compression_method\\n\"\n+                                      \" - cluster, url, access_key_id, secret_access_key, session_token, format, structure, compression_method\\n\"\n                                       \"All signatures supports optional headers (specified as `headers('name'='value', 'name2'='value2')`)\";\n \n     String getName() const override\n",
  "test_patch": "diff --git a/tests/integration/test_storage_s3/test.py b/tests/integration/test_storage_s3/test.py\nindex 161837336565..2549cb0d4738 100644\n--- a/tests/integration/test_storage_s3/test.py\n+++ b/tests/integration/test_storage_s3/test.py\n@@ -626,7 +626,7 @@ def test_wrong_s3_syntax(started_cluster):\n     instance = started_cluster.instances[\"dummy\"]  # type: ClickHouseInstance\n     expected_err_msg = \"Code: 42\"  # NUMBER_OF_ARGUMENTS_DOESNT_MATCH\n \n-    query = \"create table test_table_s3_syntax (id UInt32) ENGINE = S3('', '', '', '', '', '')\"\n+    query = \"create table test_table_s3_syntax (id UInt32) ENGINE = S3('', '', '', '', '', '', '')\"\n     assert expected_err_msg in instance.query_and_get_error(query)\n \n     expected_err_msg = \"Code: 36\"  # BAD_ARGUMENTS\n@@ -1395,6 +1395,7 @@ def test_schema_inference_from_globs(started_cluster):\n \n \n def test_signatures(started_cluster):\n+    session_token = \"session token that will not be checked by MiniIO\"\n     bucket = started_cluster.minio_bucket\n     instance = started_cluster.instances[\"dummy\"]\n \n@@ -1417,6 +1418,11 @@ def test_signatures(started_cluster):\n     )\n     assert int(result) == 1\n \n+    result = instance.query(\n+        f\"select * from s3('http://{started_cluster.minio_host}:{started_cluster.minio_port}/{bucket}/test.arrow', 'minio', 'minio123', '{session_token}')\"\n+    )\n+    assert int(result) == 1\n+\n     result = instance.query(\n         f\"select * from s3('http://{started_cluster.minio_host}:{started_cluster.minio_port}/{bucket}/test.arrow', 'Arrow', 'x UInt64', 'auto')\"\n     )\n@@ -1427,6 +1433,21 @@ def test_signatures(started_cluster):\n     )\n     assert int(result) == 1\n \n+    result = instance.query(\n+        f\"select * from s3('http://{started_cluster.minio_host}:{started_cluster.minio_port}/{bucket}/test.arrow', 'minio', 'minio123', '{session_token}', 'Arrow')\"\n+    )\n+    assert int(result) == 1\n+\n+    lt = instance.query(\n+        f\"select * from s3('http://{started_cluster.minio_host}:{started_cluster.minio_port}/{bucket}/test.arrow', 'minio', 'minio123', '{session_token}', 'Arrow', 'x UInt64')\"\n+    )\n+    assert int(result) == 1\n+\n+    lt = instance.query(\n+        f\"select * from s3('http://{started_cluster.minio_host}:{started_cluster.minio_port}/{bucket}/test.arrow', 'minio', 'minio123', '{session_token}', 'Arrow', 'x UInt64', 'auto')\"\n+    )\n+    assert int(result) == 1\n+\n \n def test_select_columns(started_cluster):\n     bucket = started_cluster.minio_bucket\n",
  "problem_statement": "S3 - Allow passing SESSION_TOKEN into S3 function in SQL\n**Use case**\r\n\r\nWe're planning on implementing integration to 3rd party ClickHouse databases (which will load data into tables directly from S3), for that we would like to pass credentials that are given from user accounts directly to ClickHouse without the user configuring ClickHouse to use those credentials by default, for easy plug-and-play.\r\n\r\n**Describe the solution you'd like**\r\n\r\nWe would like to pass (`ACCESS_KEY`, `SECRET_KEY` and `SESSION_TOKEN`) to be used in the s3 function: `s3(path, [aws_access_key_id, aws_secret_access_key,] [format, [structure, [compression]]])` as [documented here](https://clickhouse.com/docs/en/integrations/s3#s3-table-functions), but currently we can't pass `SESSION_TOKEN`.\r\n\r\nThis will allow us to issue a new temporary `ACCESS_KEY`, `SECRET_KEY` and `SESSION_TOKEN` that will expire in a few hours (which is fine, since loading data into clickhouse shouldn't be a long running operation, and it's blocking) every time we want to load data into clickhouse, without requiring from the user to modify database configuration and / or IAM settings.\r\n**Describe alternatives you've considered**\r\n\r\n- Passing an `IAM_ROLE_ARN` and `EXTERNAL_ID` is fine too, but would require from the user to configure another trusted entity in the trusted entities policies of an extisting IAM Role (This also requires a modification of the S3 method)\r\n- Letting the user configure credentials to clickhouse database with documentation, would require \"heavy\" changes such as deploying a Clickhouse Formation stack and / or changing configuration of the database (if it's on premises)\r\n\r\n\n",
  "hints_text": "",
  "created_at": "2023-12-14T08:07:36Z",
  "modified_files": [
    "docs/en/sql-reference/table-functions/s3.md",
    "docs/en/sql-reference/table-functions/s3Cluster.md",
    "docs/ru/sql-reference/table-functions/s3.md",
    "docs/ru/sql-reference/table-functions/s3Cluster.md",
    "docs/zh/sql-reference/table-functions/s3.md",
    "src/Coordination/KeeperSnapshotManagerS3.cpp",
    "src/IO/S3Common.cpp",
    "src/IO/S3Common.h",
    "src/Storages/StorageS3.cpp",
    "src/TableFunctions/TableFunctionS3.cpp",
    "src/TableFunctions/TableFunctionS3.h",
    "src/TableFunctions/TableFunctionS3Cluster.h"
  ],
  "modified_test_files": [
    "tests/integration/test_storage_s3/test.py"
  ]
}