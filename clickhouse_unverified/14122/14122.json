{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 14122,
  "instance_id": "ClickHouse__ClickHouse-14122",
  "issue_numbers": [
    "14118"
  ],
  "base_commit": "65ee7dcb187c088691a86279e22be5f7ed31fecf",
  "patch": "diff --git a/src/Functions/FunctionBinaryArithmetic.h b/src/Functions/FunctionBinaryArithmetic.h\nindex 47597594f337..241f7b2fae09 100644\n--- a/src/Functions/FunctionBinaryArithmetic.h\n+++ b/src/Functions/FunctionBinaryArithmetic.h\n@@ -1209,6 +1209,9 @@ class FunctionBinaryArithmetic : public IFunction\n #if USE_EMBEDDED_COMPILER\n     bool isCompilableImpl(const DataTypes & arguments) const override\n     {\n+        if (2 != arguments.size())\n+            return false;\n+\n         return castBothTypes(arguments[0].get(), arguments[1].get(), [&](const auto & left, const auto & right)\n         {\n             using LeftDataType = std::decay_t<decltype(left)>;\n@@ -1226,6 +1229,8 @@ class FunctionBinaryArithmetic : public IFunction\n \n     llvm::Value * compileImpl(llvm::IRBuilderBase & builder, const DataTypes & types, ValuePlaceholders values) const override\n     {\n+        assert(2 == types.size() && 2 == values.size());\n+\n         llvm::Value * result = nullptr;\n         castBothTypes(types[0].get(), types[1].get(), [&](const auto & left, const auto & right)\n         {\ndiff --git a/src/Functions/FunctionUnaryArithmetic.h b/src/Functions/FunctionUnaryArithmetic.h\nindex 963313c7dedd..5b072e5848aa 100644\n--- a/src/Functions/FunctionUnaryArithmetic.h\n+++ b/src/Functions/FunctionUnaryArithmetic.h\n@@ -216,6 +216,9 @@ class FunctionUnaryArithmetic : public IFunction\n #if USE_EMBEDDED_COMPILER\n     bool isCompilableImpl(const DataTypes & arguments) const override\n     {\n+        if (1 != arguments.size())\n+            return false;\n+\n         return castType(arguments[0].get(), [&](const auto & type)\n         {\n             using DataType = std::decay_t<decltype(type)>;\n@@ -228,6 +231,8 @@ class FunctionUnaryArithmetic : public IFunction\n \n     llvm::Value * compileImpl(llvm::IRBuilderBase & builder, const DataTypes & types, ValuePlaceholders values) const override\n     {\n+        assert(1 == types.size() && 1 == values.size());\n+\n         llvm::Value * result = nullptr;\n         castType(types[0].get(), [&](const auto & type)\n         {\ndiff --git a/src/Functions/FunctionsComparison.h b/src/Functions/FunctionsComparison.h\nindex 9b0d6e76924d..07455f945688 100644\n--- a/src/Functions/FunctionsComparison.h\n+++ b/src/Functions/FunctionsComparison.h\n@@ -1272,6 +1272,9 @@ class FunctionComparison : public IFunction\n #if USE_EMBEDDED_COMPILER\n     bool isCompilableImpl(const DataTypes & types) const override\n     {\n+        if (2 != types.size())\n+            return false;\n+\n         auto isBigInteger = &typeIsEither<DataTypeInt64, DataTypeUInt64, DataTypeUUID>;\n         auto isFloatingPoint = &typeIsEither<DataTypeFloat32, DataTypeFloat64>;\n         if ((isBigInteger(*types[0]) && isFloatingPoint(*types[1]))\n@@ -1284,6 +1287,8 @@ class FunctionComparison : public IFunction\n \n     llvm::Value * compileImpl(llvm::IRBuilderBase & builder, const DataTypes & types, ValuePlaceholders values) const override\n     {\n+        assert(2 == types.size() && 2 == values.size());\n+\n         auto & b = static_cast<llvm::IRBuilder<> &>(builder);\n         auto * x = values[0]();\n         auto * y = values[1]();\ndiff --git a/src/Functions/FunctionsLogical.h b/src/Functions/FunctionsLogical.h\nindex a8809dc34675..474831b0b6d5 100644\n--- a/src/Functions/FunctionsLogical.h\n+++ b/src/Functions/FunctionsLogical.h\n@@ -161,6 +161,8 @@ class FunctionAnyArityLogical : public IFunction\n \n     llvm::Value * compileImpl(llvm::IRBuilderBase & builder, const DataTypes & types, ValuePlaceholders values) const override\n     {\n+        assert(!types.empty() && !values.empty());\n+\n         auto & b = static_cast<llvm::IRBuilder<> &>(builder);\n         if constexpr (!Impl::isSaturable())\n         {\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01457_compile_expressions_fuzzer.reference b/tests/queries/0_stateless/01457_compile_expressions_fuzzer.reference\nnew file mode 100644\nindex 000000000000..0cfbf08886fc\n--- /dev/null\n+++ b/tests/queries/0_stateless/01457_compile_expressions_fuzzer.reference\n@@ -0,0 +1,1 @@\n+2\ndiff --git a/tests/queries/0_stateless/01457_compile_expressions_fuzzer.sql b/tests/queries/0_stateless/01457_compile_expressions_fuzzer.sql\nnew file mode 100644\nindex 000000000000..923ecf5d94a1\n--- /dev/null\n+++ b/tests/queries/0_stateless/01457_compile_expressions_fuzzer.sql\n@@ -0,0 +1,2 @@\n+SET compile_expressions = 1;\n+SELECT GREATEST(2,0);\n",
  "problem_statement": "Debug assertion with function GREATEST if compile_expressions = 1.\n```\r\nSET compile_expressions = 1\r\nSELECT GREATEST(2,0)\r\n```\r\n\n",
  "hints_text": "",
  "created_at": "2020-08-26T16:49:59Z"
}