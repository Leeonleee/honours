{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 48567,
  "instance_id": "ClickHouse__ClickHouse-48567",
  "issue_numbers": [
    "39880"
  ],
  "base_commit": "c450d72b325bb25bd6336a82721a9b35dcb90e9a",
  "patch": "diff --git a/docs/en/sql-reference/functions/string-functions.md b/docs/en/sql-reference/functions/string-functions.md\nindex f3c5b20f886e..a52ca9f53f19 100644\n--- a/docs/en/sql-reference/functions/string-functions.md\n+++ b/docs/en/sql-reference/functions/string-functions.md\n@@ -6,7 +6,7 @@ sidebar_label: Strings\n \n # Functions for Working with Strings\n \n-:::note    \n+:::note\n Functions for [searching](../../sql-reference/functions/string-search-functions.md) and [replacing](../../sql-reference/functions/string-replace-functions.md) in strings are described separately.\n :::\n \n@@ -1193,6 +1193,42 @@ Result:\n ```\n \n ## concatWithSeparatorAssumeInjective\n+\n Same as concatWithSeparator, the difference is that you need to ensure that concatWithSeparator(sep, expr1, expr2, expr3...) \u2192 result is injective, it will be used for optimization of GROUP BY.\n \n The function is named \u201cinjective\u201d if it always returns different result for different values of arguments. In other words: different arguments never yield identical result.\n+\n+## soundex\n+\n+Returns the [Soundex code](https://en.wikipedia.org/wiki/Soundex) of a string.\n+\n+**Syntax**\n+\n+``` sql\n+soundex(val)\n+```\n+\n+**Arguments**\n+\n+- `val` - Input value. [String](../data-types/string.md)\n+\n+**Returned value**\n+\n+- The Soundex code of the input value. [String](../data-types/string.md)\n+\n+**Example**\n+\n+Query:\n+\n+``` sql\n+select soundex('aksel');\n+```\n+\n+Result:\n+\n+``` text\n+\u250c\u2500soundex('aksel')\u2500\u2510\n+\u2502 A240             \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\ndiff --git a/docs/zh/sql-reference/functions/string-functions.md b/docs/zh/sql-reference/functions/string-functions.md\nindex 89d64f760745..d1914839d7cf 100644\n--- a/docs/zh/sql-reference/functions/string-functions.md\n+++ b/docs/zh/sql-reference/functions/string-functions.md\n@@ -168,3 +168,15 @@ SELECT format('{} {}', 'Hello', 'World')\n ## trimBoth(s) {#trimboths}\n \n \u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u7528\u4e8e\u5220\u9664\u4efb\u4e00\u4fa7\u7684\u7a7a\u767d\u5b57\u7b26\u3002\n+\n+## soundex(s)\n+\n+\u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\u7684soundex\u503c\u3002\u8f93\u51fa\u7c7b\u578b\u662fFixedString\uff0c\u793a\u4f8b\u5982\u4e0b\uff1a\n+\n+``` sql\n+select soundex('aksql');\n+\n+\u250c\u2500soundex('aksel')\u2500\u2510\n+\u2502 A240             \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\ndiff --git a/src/Functions/soundex.cpp b/src/Functions/soundex.cpp\nnew file mode 100644\nindex 000000000000..5318339295d5\n--- /dev/null\n+++ b/src/Functions/soundex.cpp\n@@ -0,0 +1,119 @@\n+#include <cctype>\n+\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionStringToString.h>\n+#include <Common/StringUtils/StringUtils.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_COLUMN;\n+}\n+/** Soundex algorithm, https://en.wikipedia.org/wiki/Soundex\n+  * Implemented similarly as in most SQL dialects:\n+  * 1. Save the first letter. Map all occurrences of a, e, i, o, u, y, h, w. to zero(0)\n+  * 2. Replace all consonants (include the first letter) with digits as follows:\n+  *  - b, f, p, v \u2192 1\n+  *  - c, g, j, k, q, s, x, z \u2192 2\n+  *  - d, t \u2192 3\n+  *  - l \u2192 4\n+  *  - m, n \u2192 5\n+  *  - r \u2192 6\n+  * 3. Replace all adjacent same digits with one digit, and then remove all the zero (0) digits\n+  * 4. If the saved letter's digit is the same as the resulting first digit, remove the digit (keep the letter).\n+  * 5. Append 3 zeros if result contains less than 3 digits. Remove all except first letter and 3 digits after it.\n+  */\n+\n+struct SoundexImpl\n+{\n+    static constexpr auto length = 4z;\n+    static constexpr auto soundex_map = \"01230120022455012623010202\";\n+\n+    static void calculate(const char * value, size_t value_length, char * out)\n+    {\n+        const char * cur = value;\n+        const char * const end = value + value_length;\n+        char * const out_end = out + length;\n+\n+        while (cur < end && !isAlphaASCII(*cur))\n+            ++cur;\n+\n+        char prev_code = '0';\n+        if (cur < end)\n+        {\n+            *out = toUpperIfAlphaASCII(*cur);\n+            ++out;\n+            prev_code = soundex_map[toUpperIfAlphaASCII(*cur) - 'A'];\n+            ++cur;\n+        }\n+\n+        while (cur < end && !isAlphaASCII(*cur))\n+            ++cur;\n+\n+        while (cur < end && out < out_end)\n+        {\n+            char current_code = soundex_map[toUpperIfAlphaASCII(*cur) - 'A'];\n+            if ((current_code != '0') && (current_code != prev_code))\n+            {\n+                *out = current_code;\n+                ++out;\n+            }\n+            prev_code = current_code;\n+            ++cur;\n+\n+            while (cur < end && !isAlphaASCII(*cur))\n+                ++cur;\n+        }\n+\n+        while (out < out_end)\n+        {\n+            *out = '0';\n+            ++out;\n+        }\n+    }\n+\n+    static void vector(\n+        const ColumnString::Chars & data,\n+        const ColumnString::Offsets & offsets,\n+        ColumnString::Chars & res_data,\n+        ColumnString::Offsets & res_offsets)\n+    {\n+        const size_t size = offsets.size();\n+        res_data.resize(size * (length + 1));\n+        res_offsets.resize(size);\n+\n+        size_t prev_offset = 0;\n+        for (size_t i = 0; i < size; ++i)\n+        {\n+            const char * value = reinterpret_cast<const char *>(&data[prev_offset]);\n+            const size_t value_length = offsets[i] - prev_offset - 1;\n+            const size_t out_index = i * (length + 1);\n+            calculate(value, value_length, reinterpret_cast<char *>(&res_data[out_index]));\n+            res_data[out_index + length] = '\\0';\n+            res_offsets[i] = (out_index + length + 1);\n+            prev_offset = offsets[i];\n+        }\n+    }\n+\n+    [[noreturn]] static void vectorFixed(const ColumnString::Chars &, size_t, ColumnString::Chars &)\n+    {\n+        throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Column of type FixedString is not supported by soundex function\");\n+    }\n+};\n+\n+struct NameSoundex\n+{\n+    static constexpr auto name = \"soundex\";\n+};\n+\n+REGISTER_FUNCTION(Soundex)\n+{\n+    factory.registerFunction<FunctionStringToString<SoundexImpl, NameSoundex>>(\n+        Documentation{\"Returns Soundex code of a string.\"}, FunctionFactory::CaseInsensitive);\n+}\n+\n+\n+}\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02711_soundex_function.reference b/tests/queries/0_stateless/02711_soundex_function.reference\nnew file mode 100644\nindex 000000000000..1b843e030f7a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02711_soundex_function.reference\n@@ -0,0 +1,27 @@\n+0000\n+0000\n+J523\n+A000\n+F634\n+F634\n+J525\n+J525\n+J523\n+M235\n+M235\n+S530\n+S530\n+---\n+0000\n+0000\n+J523\n+A000\n+F634\n+F634\n+J525\n+J525\n+J523\n+M235\n+M235\n+S530\n+S530\ndiff --git a/tests/queries/0_stateless/02711_soundex_function.sql b/tests/queries/0_stateless/02711_soundex_function.sql\nnew file mode 100644\nindex 000000000000..d2fe374b3414\n--- /dev/null\n+++ b/tests/queries/0_stateless/02711_soundex_function.sql\n@@ -0,0 +1,28 @@\n+SELECT soundex('');\n+SELECT soundex('12345');\n+SELECT soundex('341Jons54326ton');\n+SELECT soundex('A2222222');\n+SELECT soundex('Fairdale');\n+SELECT soundex('Faredale');\n+SELECT soundex('Jon1s2o3n');\n+SELECT soundex('Jonson');\n+SELECT soundex('Jonston');\n+SELECT soundex('M\\acDonald22321');\n+SELECT soundex('MacDonald');\n+SELECT soundex('S3344mith0000');\n+SELECT soundex('Smith');\n+\n+SELECT '---';\n+\n+-- same input strings but in a table\n+DROP TABLE IF EXISTS tab;\n+CREATE TABLE tab (col String) Engine=MergeTree ORDER BY col;\n+INSERT INTO tab VALUES ('') ('12345') ('341Jons54326ton') ('A2222222') ('Fairdale') ('Faredale') ('Jon1s2o3n') ('Jonson') ('Jonston') ('M\\acDonald22321') ('MacDonald') ('S3344mith0000') ('Smith');\n+\n+SELECT soundex(col) FROM tab;\n+\n+DROP TABLE tab;\n+\n+-- negative tests\n+SELECT soundex(toFixedString('Smith', 5)); -- { serverError ILLEGAL_COLUMN }\n+SELECT soundex(5); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n",
  "problem_statement": "SOUNDEX function\nhttps://mariadb.com/kb/en/soundex/\r\n\r\n```sql\r\nmysql> select SOUNDEX('aksel');\r\n+------------------+\r\n| SOUNDEX('aksel') |\r\n+------------------+\r\n| A240             |\r\n+------------------+\r\n1 row in set (0.00 sec)\r\n\r\nmysql> select SOUNDEX('axel');\r\n+-----------------+\r\n| SOUNDEX('axel') |\r\n+-----------------+\r\n| A240            |\r\n+-----------------+\r\n1 row in set (0.00 sec)\r\n```\r\n\r\nAlso interesting https://mariadb.com/kb/en/sounds-like/\n",
  "hints_text": "Good feature for MySQL compatibility. And it is easy to implement.\nHi, I'm interested in working on this feature. Kindly guide me for the further steps.",
  "created_at": "2023-04-09T09:02:27Z"
}