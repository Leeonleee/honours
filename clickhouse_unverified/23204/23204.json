{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 23204,
  "instance_id": "ClickHouse__ClickHouse-23204",
  "issue_numbers": [
    "16641"
  ],
  "base_commit": "a9a66f657222bb01a568707f632126318cd28298",
  "patch": "diff --git a/src/AggregateFunctions/AggregateFunctionQuantile.cpp b/src/AggregateFunctions/AggregateFunctionQuantile.cpp\nindex e8d86a03ff17..62c8a41b614b 100644\n--- a/src/AggregateFunctions/AggregateFunctionQuantile.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionQuantile.cpp\n@@ -52,6 +52,9 @@ template <typename Value, bool float_return> using FuncQuantilesTDigest = Aggreg\n template <typename Value, bool float_return> using FuncQuantileTDigestWeighted = AggregateFunctionQuantile<Value, QuantileTDigest<Value>, NameQuantileTDigestWeighted, true, std::conditional_t<float_return, Float32, void>, false>;\n template <typename Value, bool float_return> using FuncQuantilesTDigestWeighted = AggregateFunctionQuantile<Value, QuantileTDigest<Value>, NameQuantilesTDigestWeighted, true, std::conditional_t<float_return, Float32, void>, true>;\n \n+template <typename Value, bool float_return> using FuncQuantileBFloat16 = AggregateFunctionQuantile<Value, QuantileBFloat16Histogram<Value>, NameQuantileBFloat16, false, std::conditional_t<float_return, Float64, void>, false>;\n+template <typename Value, bool float_return> using FuncQuantilesBFloat16 = AggregateFunctionQuantile<Value, QuantileBFloat16Histogram<Value>, NameQuantilesBFloat16, false, std::conditional_t<float_return, Float64, void>, true>;\n+\n \n template <template <typename, bool> class Function>\n static constexpr bool supportDecimal()\n@@ -156,6 +159,9 @@ void registerAggregateFunctionsQuantile(AggregateFunctionFactory & factory)\n     factory.registerFunction(NameQuantileTDigestWeighted::name, createAggregateFunctionQuantile<FuncQuantileTDigestWeighted>);\n     factory.registerFunction(NameQuantilesTDigestWeighted::name, createAggregateFunctionQuantile<FuncQuantilesTDigestWeighted>);\n \n+    factory.registerFunction(NameQuantileBFloat16::name, createAggregateFunctionQuantile<FuncQuantileBFloat16>);\n+    factory.registerFunction(NameQuantilesBFloat16::name, createAggregateFunctionQuantile<FuncQuantilesBFloat16>);\n+\n     /// 'median' is an alias for 'quantile'\n     factory.registerAlias(\"median\", NameQuantile::name);\n     factory.registerAlias(\"medianDeterministic\", NameQuantileDeterministic::name);\n@@ -167,6 +173,7 @@ void registerAggregateFunctionsQuantile(AggregateFunctionFactory & factory)\n     factory.registerAlias(\"medianTimingWeighted\", NameQuantileTimingWeighted::name);\n     factory.registerAlias(\"medianTDigest\", NameQuantileTDigest::name);\n     factory.registerAlias(\"medianTDigestWeighted\", NameQuantileTDigestWeighted::name);\n+    factory.registerAlias(\"medianBFloat16\", NameQuantileBFloat16::name);\n }\n \n }\ndiff --git a/src/AggregateFunctions/AggregateFunctionQuantile.h b/src/AggregateFunctions/AggregateFunctionQuantile.h\nindex 209784361dd4..502905e8b48e 100644\n--- a/src/AggregateFunctions/AggregateFunctionQuantile.h\n+++ b/src/AggregateFunctions/AggregateFunctionQuantile.h\n@@ -9,6 +9,7 @@\n #include <AggregateFunctions/QuantileExactWeighted.h>\n #include <AggregateFunctions/QuantileTiming.h>\n #include <AggregateFunctions/QuantileTDigest.h>\n+#include <AggregateFunctions/QuantileBFloat16Histogram.h>\n \n #include <AggregateFunctions/IAggregateFunction.h>\n #include <AggregateFunctions/QuantilesCommon.h>\n@@ -228,4 +229,7 @@ struct NameQuantileTDigestWeighted { static constexpr auto name = \"quantileTDige\n struct NameQuantilesTDigest { static constexpr auto name = \"quantilesTDigest\"; };\n struct NameQuantilesTDigestWeighted { static constexpr auto name = \"quantilesTDigestWeighted\"; };\n \n+struct NameQuantileBFloat16 { static constexpr auto name = \"quantileBFloat16\"; };\n+struct NameQuantilesBFloat16 { static constexpr auto name = \"quantilesBFloat16\"; };\n+\n }\ndiff --git a/src/AggregateFunctions/QuantileBFloat16Histogram.h b/src/AggregateFunctions/QuantileBFloat16Histogram.h\nnew file mode 100644\nindex 000000000000..559a87a55915\n--- /dev/null\n+++ b/src/AggregateFunctions/QuantileBFloat16Histogram.h\n@@ -0,0 +1,207 @@\n+#pragma once\n+\n+#include <IO/ReadBuffer.h>\n+#include <IO/WriteBuffer.h>\n+#include <Common/HashTable/HashMap.h>\n+#include <common/types.h>\n+#include <ext/bit_cast.h>\n+\n+\n+namespace DB\n+{\n+\n+/** `bfloat16` is a 16-bit floating point data type that is the same as the corresponding most significant 16 bits of the `float`.\n+  * https://en.wikipedia.org/wiki/Bfloat16_floating-point_format\n+  *\n+  * To calculate quantile, simply convert input value to 16 bit (convert to float, then take the most significant 16 bits),\n+  * and calculate the histogram of these values.\n+  *\n+  * Hash table is the preferred way to store histogram, because the number of distinct values is small:\n+  * ```\n+  * SELECT uniq(bfloat)\n+  * FROM\n+  * (\n+  *     SELECT\n+  *         number,\n+  *         toFloat32(number) AS f,\n+  *         bitShiftRight(bitAnd(reinterpretAsUInt32(reinterpretAsFixedString(f)), 4294901760) AS cut, 16),\n+  *         reinterpretAsFloat32(reinterpretAsFixedString(cut)) AS bfloat\n+  *     FROM numbers(100000000)\n+  * )\n+  *\n+  * \u250c\u2500uniq(bfloat)\u2500\u2510\n+  * \u2502         2623 \u2502\n+  * \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+  * ```\n+  * (when increasing the range of values 1000 times, the number of distinct bfloat16 values increases just by 1280).\n+  *\n+  * Then calculate quantile from the histogram.\n+  *\n+  * This sketch is very simple and rough. Its relative precision is constant 1 / 256 = 0.390625%.\n+  */\n+template <typename Value>\n+struct QuantileBFloat16Histogram\n+{\n+    using BFloat16 = UInt16;\n+    using Weight = UInt64;\n+\n+    /// Make automatic memory for 16 elements to avoid allocations for small states.\n+    /// The usage of trivial hash is ok, because we effectively take logarithm of the values and pathological cases are unlikely.\n+    using Data = HashMapWithStackMemory<BFloat16, Weight, TrivialHash, 4>;\n+\n+    Data data;\n+\n+    void add(const Value & x)\n+    {\n+        add(x, 1);\n+    }\n+\n+    void add(const Value & x, Weight w)\n+    {\n+        if (!isNaN(x))\n+            data[toBFloat16(x)] += w;\n+    }\n+\n+    void merge(const QuantileBFloat16Histogram & rhs)\n+    {\n+        for (const auto & pair : rhs.data)\n+            data[pair.getKey()] += pair.getMapped();\n+    }\n+\n+    void serialize(WriteBuffer & buf) const\n+    {\n+        data.write(buf);\n+    }\n+\n+    void deserialize(ReadBuffer & buf)\n+    {\n+        data.read(buf);\n+    }\n+\n+    Value get(Float64 level) const\n+    {\n+        return getImpl<Value>(level);\n+    }\n+\n+    void getMany(const Float64 * levels, const size_t * indices, size_t size, Value * result) const\n+    {\n+        getManyImpl(levels, indices, size, result);\n+    }\n+\n+    Float64 getFloat(Float64 level) const\n+    {\n+        return getImpl<Float64>(level);\n+    }\n+\n+    void getManyFloat(const Float64 * levels, const size_t * indices, size_t size, Float64 * result) const\n+    {\n+        getManyImpl(levels, indices, size, result);\n+    }\n+\n+private:\n+    /// Take the most significant 16 bits of the floating point number.\n+    BFloat16 toBFloat16(const Value & x) const\n+    {\n+        return ext::bit_cast<UInt32>(static_cast<Float32>(x)) >> 16;\n+    }\n+\n+    /// Put the bits into most significant 16 bits of the floating point number and fill other bits with zeros.\n+    Float32 toFloat32(const BFloat16 & x) const\n+    {\n+        return ext::bit_cast<Float32>(x << 16);\n+    }\n+\n+    using Pair = PairNoInit<Float32, Weight>;\n+\n+    template <typename T>\n+    T getImpl(Float64 level) const\n+    {\n+        size_t size = data.size();\n+\n+        if (0 == size)\n+            return std::numeric_limits<T>::quiet_NaN();\n+\n+        std::unique_ptr<Pair[]> array_holder(new Pair[size]);\n+        Pair * array = array_holder.get();\n+\n+        Float64 sum_weight = 0;\n+        Pair * arr_it = array;\n+        for (const auto & pair : data)\n+        {\n+            sum_weight += pair.getMapped();\n+            *arr_it = {toFloat32(pair.getKey()), pair.getMapped()};\n+            ++arr_it;\n+        }\n+\n+        std::sort(array, array + size, [](const Pair & a, const Pair & b) { return a.first < b.first; });\n+\n+        Float64 threshold = std::ceil(sum_weight * level);\n+        Float64 accumulated = 0;\n+\n+        for (const Pair * p = array; p != (array + size); ++p)\n+        {\n+            accumulated += p->second;\n+\n+            if (accumulated >= threshold)\n+                return p->first;\n+        }\n+\n+        return array[size - 1].first;\n+    }\n+\n+    template <typename T>\n+    void getManyImpl(const Float64 * levels, const size_t * indices, size_t num_levels, T * result) const\n+    {\n+        size_t size = data.size();\n+\n+        if (0 == size)\n+        {\n+            for (size_t i = 0; i < num_levels; ++i)\n+                result[i] = std::numeric_limits<T>::quiet_NaN();\n+\n+            return;\n+        }\n+\n+        std::unique_ptr<Pair[]> array_holder(new Pair[size]);\n+        Pair * array = array_holder.get();\n+\n+        Float64 sum_weight = 0;\n+        Pair * arr_it = array;\n+        for (const auto & pair : data)\n+        {\n+            sum_weight += pair.getMapped();\n+            *arr_it = {toFloat32(pair.getKey()), pair.getMapped()};\n+            ++arr_it;\n+        }\n+\n+        std::sort(array, array + size, [](const Pair & a, const Pair & b) { return a.first < b.first; });\n+\n+        size_t level_index = 0;\n+        Float64 accumulated = 0;\n+        Float64 threshold = std::ceil(sum_weight * levels[indices[level_index]]);\n+\n+        for (const Pair * p = array; p != (array + size); ++p)\n+        {\n+            accumulated += p->second;\n+\n+            while (accumulated >= threshold)\n+            {\n+                result[indices[level_index]] = p->first;\n+                ++level_index;\n+\n+                if (level_index == num_levels)\n+                    return;\n+\n+                threshold = std::ceil(sum_weight * levels[indices[level_index]]);\n+            }\n+        }\n+\n+        while (level_index < num_levels)\n+        {\n+            result[indices[level_index]] = array[size - 1].first;\n+            ++level_index;\n+        }\n+    }\n+};\n+\n+}\n",
  "test_patch": "diff --git a/tests/performance/quantile.xml b/tests/performance/quantile.xml\nnew file mode 100644\nindex 000000000000..4718c129db68\n--- /dev/null\n+++ b/tests/performance/quantile.xml\n@@ -0,0 +1,29 @@\n+<test>\n+    <preconditions>\n+        <table_exists>hits_100m_single</table_exists>\n+    </preconditions>\n+\n+    <substitutions>\n+        <substitution>\n+           <name>key</name>\n+           <values>\n+               <value>SearchEngineID</value>\n+               <value>RegionID</value>\n+               <value>SearchPhrase</value>\n+               <value>ClientIP</value>\n+           </values>\n+        </substitution>\n+        <substitution>\n+           <name>func</name>\n+           <values>\n+               <value>quantile</value>\n+               <value>quantileExact</value>\n+               <value>quantileTDigest</value>\n+               <value>quantileTiming</value>\n+               <value>quantileBFloat16</value>\n+           </values>\n+       </substitution>\n+    </substitutions>\n+\n+    <query>SELECT {key} AS k, {func}(ResolutionWidth) FROM hits_100m_single GROUP BY k FORMAT Null</query>\n+</test>\ndiff --git a/tests/performance/uniq.xml b/tests/performance/uniq.xml\nindex 0ddd2321ca62..d4521961b9a0 100644\n--- a/tests/performance/uniq.xml\n+++ b/tests/performance/uniq.xml\n@@ -1,12 +1,9 @@\n <test>\n-\n     <preconditions>\n         <table_exists>hits_100m_single</table_exists>\n         <ram_size>30000000000</ram_size>\n     </preconditions>\n \n-\n-\n     <settings>\n         <max_memory_usage>30000000000</max_memory_usage>\n         <!--\n@@ -36,7 +33,7 @@\n                <value>SearchPhrase</value>\n                <value>ClientIP</value>\n            </values>\n-       </substitution>\n+        </substitution>\n         <substitution>\n            <name>func</name>\n            <values>\ndiff --git a/tests/queries/0_stateless/00753_quantile_format.reference b/tests/queries/0_stateless/00753_quantile_format.reference\nindex 04bb0000b3ed..d3503745e4b2 100644\n--- a/tests/queries/0_stateless/00753_quantile_format.reference\n+++ b/tests/queries/0_stateless/00753_quantile_format.reference\n@@ -10,7 +10,9 @@\n [30000]\n 30000\n [30000]\n-2016-06-15 23:01:04\n-['2016-06-15 23:01:04']\n-2016-06-15 23:01:04\n-['2016-06-15 23:01:04']\n+2016-06-15 23:00:16\n+['2016-06-15 23:00:16']\n+2016-06-15 23:00:16\n+['2016-06-15 23:00:16']\n+2016-04-02 17:23:12\n+['2016-04-02 17:23:12']\ndiff --git a/tests/queries/0_stateless/00753_quantile_format.sql b/tests/queries/0_stateless/00753_quantile_format.sql\nindex 24cf0e4bf902..f72ecc8a49fd 100644\n--- a/tests/queries/0_stateless/00753_quantile_format.sql\n+++ b/tests/queries/0_stateless/00753_quantile_format.sql\n@@ -1,7 +1,7 @@\n DROP TABLE IF EXISTS datetime;\n \n-CREATE TABLE datetime (d DateTime) ENGINE = Memory;\n-INSERT INTO datetime(d) VALUES(toDateTime('2016-06-15 23:00:00'));\n+CREATE TABLE datetime (d DateTime('UTC')) ENGINE = Memory;\n+INSERT INTO datetime(d) VALUES(toDateTime('2016-06-15 23:00:00', 'UTC'));\n \n SELECT quantile(0.2)(d) FROM datetime;\n SELECT quantiles(0.2)(d) FROM datetime;\n@@ -27,4 +27,7 @@ SELECT quantilesTDigest(0.2)(d) FROM datetime;\n SELECT quantileTDigestWeighted(0.2)(d, 1) FROM datetime;\n SELECT quantilesTDigestWeighted(0.2)(d, 1) FROM datetime;\n \n+SELECT quantileBFloat16(0.2)(d) FROM datetime;\n+SELECT quantilesBFloat16(0.2)(d) FROM datetime;\n+\n DROP TABLE datetime;\ndiff --git a/tests/queries/0_stateless/01813_quantileBfloat16_nans.reference b/tests/queries/0_stateless/01813_quantileBfloat16_nans.reference\nnew file mode 100644\nindex 000000000000..d00491fd7e5b\n--- /dev/null\n+++ b/tests/queries/0_stateless/01813_quantileBfloat16_nans.reference\n@@ -0,0 +1,1 @@\n+1\ndiff --git a/tests/queries/0_stateless/01813_quantileBfloat16_nans.sql b/tests/queries/0_stateless/01813_quantileBfloat16_nans.sql\nnew file mode 100644\nindex 000000000000..1f823f0b9902\n--- /dev/null\n+++ b/tests/queries/0_stateless/01813_quantileBfloat16_nans.sql\n@@ -0,0 +1,16 @@\n+SELECT DISTINCT\n+    eq\n+FROM\n+    (\n+        WITH\n+            range(2 + number % 10) AS arr, -- minimum two elements, to avoid nan result --\n+            arrayMap(x -> x = intDiv(number, 10) ? nan : x, arr) AS arr_with_nan,\n+            arrayFilter(x -> x != intDiv(number, 10), arr) AS arr_filtered\n+        SELECT\n+            number,\n+            arrayReduce('quantileBFloat16', arr_with_nan) AS q1,\n+            arrayReduce('quantileBFloat16', arr_filtered) AS q2,\n+            q1 = q2 AS eq\n+        FROM\n+            numbers(100)\n+    );\ndiff --git a/tests/queries/1_stateful/00164_quantileBfloat16.reference b/tests/queries/1_stateful/00164_quantileBfloat16.reference\nnew file mode 100644\nindex 000000000000..f0aaff5cef68\n--- /dev/null\n+++ b/tests/queries/1_stateful/00164_quantileBfloat16.reference\n@@ -0,0 +1,40 @@\n+1704509\t1384\n+732797\t1336\n+598875\t1384\n+792887\t1336\n+3807842\t1336\n+25703952\t1336\n+716829\t1384\n+59183\t1336\n+33010362\t1336\n+800784\t1336\n+1704509\t[1296,1384,1840,1960,3696]\n+732797\t[1232,1336,1840,1944,3664]\n+598875\t[1232,1384,1840,1944,3536]\n+792887\t[1296,1336,1840,1888,3696]\n+3807842\t[1232,1336,1840,1936,2032]\n+25703952\t[1012,1336,1840,1944,3696]\n+716829\t[1232,1384,1840,1944,3696]\n+59183\t[316,1336,1840,2008,2032]\n+33010362\t[1232,1336,1840,1936,2032]\n+800784\t[1232,1336,1840,1928,2032]\n+1704509\t1384\n+732797\t1336\n+598875\t1384\n+792887\t1336\n+3807842\t1336\n+25703952\t1336\n+716829\t1384\n+59183\t1336\n+33010362\t1336\n+800784\t1336\n+1704509\t[1296,1384,1840,1960,3696]\n+732797\t[1232,1336,1840,1944,3664]\n+598875\t[1232,1384,1840,1944,3536]\n+792887\t[1296,1336,1840,1888,3696]\n+3807842\t[1232,1336,1840,1936,2032]\n+25703952\t[1012,1336,1840,1944,3696]\n+716829\t[1232,1384,1840,1944,3696]\n+59183\t[316,1336,1840,2008,2032]\n+33010362\t[1232,1336,1840,1936,2032]\n+800784\t[1232,1336,1840,1928,2032]\ndiff --git a/tests/queries/1_stateful/00164_quantileBfloat16.sql b/tests/queries/1_stateful/00164_quantileBfloat16.sql\nnew file mode 100644\nindex 000000000000..b39bae3803c8\n--- /dev/null\n+++ b/tests/queries/1_stateful/00164_quantileBfloat16.sql\n@@ -0,0 +1,6 @@\n+SELECT CounterID AS k, quantileBFloat16(0.5)(ResolutionWidth) FROM test.hits GROUP BY k ORDER BY count() DESC, CounterID LIMIT 10;\n+SELECT CounterID AS k, quantilesBFloat16(0.1, 0.5, 0.9, 0.99, 0.999)(ResolutionWidth) FROM test.hits GROUP BY k ORDER BY count() DESC, CounterID LIMIT 10;\n+\n+\n+SELECT CounterID AS k, quantileBFloat16(0.5)(ResolutionWidth) FROM remote('127.0.0.{1,2}', test.hits) GROUP BY k ORDER BY count() DESC, CounterID LIMIT 10;\n+SELECT CounterID AS k, quantilesBFloat16(0.1, 0.5, 0.9, 0.99, 0.999)(ResolutionWidth) FROM remote('127.0.0.{1,2}', test.hits) GROUP BY k ORDER BY count() DESC, CounterID LIMIT 10;\n",
  "problem_statement": "Experimental quantile sketch based on bfloat16 histogram.\n`bfloat16` is a 16-bit floating point data type that is the same as the corresponding most significant 16 bits of the `float`.\r\nhttps://en.wikipedia.org/wiki/Bfloat16_floating-point_format\r\n\r\nTo calculate quantile, simply convert input value to 16 bit (convert to float, then take the most significant 16 bits), and calculate the histogram of these values.\r\n\r\nHash table is the preferred way to store histogram, because the number of distinct values is small:\r\n```\r\nSELECT uniq(bfloat)\r\nFROM \r\n(\r\n    SELECT\r\n        number,\r\n        toFloat32(number) AS f,\r\n        bitShiftRight(bitAnd(reinterpretAsUInt32(reinterpretAsFixedString(f)), 4294901760) AS cut, 16),\r\n        reinterpretAsFloat32(reinterpretAsFixedString(cut)) AS bfloat\r\n    FROM numbers(100000000)\r\n)\r\n\r\n\u250c\u2500uniq(bfloat)\u2500\u2510\r\n\u2502         2623 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n(when increasing the range of values 1000 times, the number of distinct bfloat16 values increases just by 1280).\r\n\r\nThen calculate quantile from the histogram.\r\n\r\nThis sketch is very simple and rough. Its relative precision is constant 1 / 256 = 0.390625%.\r\n\r\nLinear array of values can be used if the number of values is very small, similar to `QuantileTimingTiny`.\r\n\r\n\n",
  "hints_text": "",
  "created_at": "2021-04-16T18:18:35Z"
}