{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 47594,
  "instance_id": "ClickHouse__ClickHouse-47594",
  "issue_numbers": [
    "28335",
    "47569",
    "44864"
  ],
  "base_commit": "10f1030a149e9ae17715846bcea8e9effa8cdfb4",
  "patch": "diff --git a/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp b/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp\nindex 5ee0be5cbcea..e2acccce5166 100644\n--- a/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp\n@@ -21,18 +21,21 @@ namespace ErrorCodes\n namespace\n {\n \n-/// TODO Proper support for Decimal256.\n template <typename T, typename LimitNumberOfElements>\n struct MovingSum\n {\n-    using Data = MovingSumData<std::conditional_t<is_decimal<T>, Decimal128, NearestFieldType<T>>>;\n+    using Data = MovingSumData<std::conditional_t<is_decimal<T>,\n+        std::conditional_t<sizeof(T) <= sizeof(Decimal128), Decimal128, Decimal256>,\n+        NearestFieldType<T>>>;\n     using Function = MovingImpl<T, LimitNumberOfElements, Data>;\n };\n \n template <typename T, typename LimitNumberOfElements>\n struct MovingAvg\n {\n-    using Data = MovingAvgData<std::conditional_t<is_decimal<T>, Decimal128, Float64>>;\n+    using Data = MovingAvgData<std::conditional_t<is_decimal<T>,\n+        std::conditional_t<sizeof(T) <= sizeof(Decimal128), Decimal128, Decimal256>,\n+        Float64>>;\n     using Function = MovingImpl<T, LimitNumberOfElements, Data>;\n };\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h b/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h\nindex dc27d8ac5bf3..f9a60c0c0b48 100644\n--- a/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h\n+++ b/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h\n@@ -33,11 +33,6 @@\n namespace DB\n {\n \n-namespace ErrorCodes\n-{\n-    extern const int LOGICAL_ERROR;\n-}\n-\n struct Settings;\n \n enum class StatisticsFunctionKind\n@@ -57,7 +52,7 @@ struct StatFuncOneArg\n     using Type1 = T;\n     using Type2 = T;\n     using ResultType = std::conditional_t<std::is_same_v<T, Float32>, Float32, Float64>;\n-    using Data = std::conditional_t<is_decimal<T>, VarMomentsDecimal<Decimal128, _level>, VarMoments<ResultType, _level>>;\n+    using Data = VarMoments<ResultType, _level>;\n \n     static constexpr UInt32 num_args = 1;\n };\n@@ -89,12 +84,11 @@ class AggregateFunctionVarianceSimple final\n     explicit AggregateFunctionVarianceSimple(const DataTypes & argument_types_, StatisticsFunctionKind kind_)\n         : IAggregateFunctionDataHelper<typename StatFunc::Data, AggregateFunctionVarianceSimple<StatFunc>>(argument_types_, {}, std::make_shared<DataTypeNumber<ResultType>>())\n         , src_scale(0), kind(kind_)\n-    {}\n-\n-    AggregateFunctionVarianceSimple(const IDataType & data_type, const DataTypes & argument_types_, StatisticsFunctionKind kind_)\n-        : IAggregateFunctionDataHelper<typename StatFunc::Data, AggregateFunctionVarianceSimple<StatFunc>>(argument_types_, {}, std::make_shared<DataTypeNumber<ResultType>>())\n-        , src_scale(getDecimalScale(data_type)), kind(kind_)\n-    {}\n+    {\n+        chassert(!argument_types_.empty());\n+        if (isDecimal(argument_types_.front()))\n+            src_scale = getDecimalScale(*argument_types_.front());\n+    }\n \n     String getName() const override\n     {\n@@ -113,8 +107,9 @@ class AggregateFunctionVarianceSimple final\n         {\n             if constexpr (is_decimal<T1>)\n             {\n-                this->data(place).add(static_cast<ResultType>(\n-                    static_cast<const ColVecT1 &>(*columns[0]).getData()[row_num].value));\n+                this->data(place).add(\n+                    convertFromDecimal<DataTypeDecimal<T1>, DataTypeFloat64>(\n+                        static_cast<const ColVecT1 &>(*columns[0]).getData()[row_num], src_scale));\n             }\n             else\n                 this->data(place).add(\n@@ -142,161 +137,86 @@ class AggregateFunctionVarianceSimple final\n         const auto & data = this->data(place);\n         auto & dst = static_cast<ColVecResult &>(to).getData();\n \n-        if constexpr (is_decimal<T1>)\n+        switch (kind)\n         {\n-            switch (kind)\n+            case StatisticsFunctionKind::varPop:\n             {\n-                case StatisticsFunctionKind::varPop:\n-                {\n-                    dst.push_back(data.getPopulation(src_scale * 2));\n-                    break;\n-                }\n-                case StatisticsFunctionKind::varSamp:\n-                {\n-                    dst.push_back(data.getSample(src_scale * 2));\n-                    break;\n-                }\n-                case StatisticsFunctionKind::stddevPop:\n-                {\n-                    dst.push_back(sqrt(data.getPopulation(src_scale * 2)));\n-                    break;\n-                }\n-                case StatisticsFunctionKind::stddevSamp:\n-                {\n-                    dst.push_back(sqrt(data.getSample(src_scale * 2)));\n-                    break;\n-                }\n-                case StatisticsFunctionKind::skewPop:\n-                {\n-                    Float64 var_value = data.getPopulation(src_scale * 2);\n-\n-                    if (var_value > 0)\n-                        dst.push_back(data.getMoment3(src_scale * 3) / pow(var_value, 1.5));\n-                    else\n-                        dst.push_back(std::numeric_limits<Float64>::quiet_NaN());\n-\n-                    break;\n-                }\n-                case StatisticsFunctionKind::skewSamp:\n-                {\n-                    Float64 var_value = data.getSample(src_scale * 2);\n-\n-                    if (var_value > 0)\n-                        dst.push_back(data.getMoment3(src_scale * 3) / pow(var_value, 1.5));\n-                    else\n-                        dst.push_back(std::numeric_limits<Float64>::quiet_NaN());\n-\n-                    break;\n-                }\n-                case StatisticsFunctionKind::kurtPop:\n-                {\n-                    Float64 var_value = data.getPopulation(src_scale * 2);\n-\n-                    if (var_value > 0)\n-                        dst.push_back(data.getMoment4(src_scale * 4) / pow(var_value, 2));\n-                    else\n-                        dst.push_back(std::numeric_limits<Float64>::quiet_NaN());\n-\n-                    break;\n-                }\n-                case StatisticsFunctionKind::kurtSamp:\n-                {\n-                    Float64 var_value = data.getSample(src_scale * 2);\n-\n-                    if (var_value > 0)\n-                        dst.push_back(data.getMoment4(src_scale * 4) / pow(var_value, 2));\n-                    else\n-                        dst.push_back(std::numeric_limits<Float64>::quiet_NaN());\n-\n-                    break;\n-                }\n-                default:\n-                    throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected statistical function kind\");\n+                dst.push_back(data.getPopulation());\n+                break;\n             }\n-        }\n-        else\n-        {\n-            switch (kind)\n+            case StatisticsFunctionKind::varSamp:\n+            {\n+                dst.push_back(data.getSample());\n+                break;\n+            }\n+            case StatisticsFunctionKind::stddevPop:\n+            {\n+                dst.push_back(sqrt(data.getPopulation()));\n+                break;\n+            }\n+            case StatisticsFunctionKind::stddevSamp:\n+            {\n+                dst.push_back(sqrt(data.getSample()));\n+                break;\n+            }\n+            case StatisticsFunctionKind::skewPop:\n+            {\n+                ResultType var_value = data.getPopulation();\n+\n+                if (var_value > 0)\n+                    dst.push_back(static_cast<ResultType>(data.getMoment3() / pow(var_value, 1.5)));\n+                else\n+                    dst.push_back(std::numeric_limits<ResultType>::quiet_NaN());\n+\n+                break;\n+            }\n+            case StatisticsFunctionKind::skewSamp:\n+            {\n+                ResultType var_value = data.getSample();\n+\n+                if (var_value > 0)\n+                    dst.push_back(static_cast<ResultType>(data.getMoment3() / pow(var_value, 1.5)));\n+                else\n+                    dst.push_back(std::numeric_limits<ResultType>::quiet_NaN());\n+\n+                break;\n+            }\n+            case StatisticsFunctionKind::kurtPop:\n+            {\n+                ResultType var_value = data.getPopulation();\n+\n+                if (var_value > 0)\n+                    dst.push_back(static_cast<ResultType>(data.getMoment4() / pow(var_value, 2)));\n+                else\n+                    dst.push_back(std::numeric_limits<ResultType>::quiet_NaN());\n+\n+                break;\n+            }\n+            case StatisticsFunctionKind::kurtSamp:\n+            {\n+                ResultType var_value = data.getSample();\n+\n+                if (var_value > 0)\n+                    dst.push_back(static_cast<ResultType>(data.getMoment4() / pow(var_value, 2)));\n+                else\n+                    dst.push_back(std::numeric_limits<ResultType>::quiet_NaN());\n+\n+                break;\n+            }\n+            case StatisticsFunctionKind::covarPop:\n+            {\n+                dst.push_back(data.getPopulation());\n+                break;\n+            }\n+            case StatisticsFunctionKind::covarSamp:\n+            {\n+                dst.push_back(data.getSample());\n+                break;\n+            }\n+            case StatisticsFunctionKind::corr:\n             {\n-                case StatisticsFunctionKind::varPop:\n-                {\n-                    dst.push_back(data.getPopulation());\n-                    break;\n-                }\n-                case StatisticsFunctionKind::varSamp:\n-                {\n-                    dst.push_back(data.getSample());\n-                    break;\n-                }\n-                case StatisticsFunctionKind::stddevPop:\n-                {\n-                    dst.push_back(sqrt(data.getPopulation()));\n-                    break;\n-                }\n-                case StatisticsFunctionKind::stddevSamp:\n-                {\n-                    dst.push_back(sqrt(data.getSample()));\n-                    break;\n-                }\n-                case StatisticsFunctionKind::skewPop:\n-                {\n-                    ResultType var_value = data.getPopulation();\n-\n-                    if (var_value > 0)\n-                        dst.push_back(static_cast<ResultType>(data.getMoment3() / pow(var_value, 1.5)));\n-                    else\n-                        dst.push_back(std::numeric_limits<ResultType>::quiet_NaN());\n-\n-                    break;\n-                }\n-                case StatisticsFunctionKind::skewSamp:\n-                {\n-                    ResultType var_value = data.getSample();\n-\n-                    if (var_value > 0)\n-                        dst.push_back(static_cast<ResultType>(data.getMoment3() / pow(var_value, 1.5)));\n-                    else\n-                        dst.push_back(std::numeric_limits<ResultType>::quiet_NaN());\n-\n-                    break;\n-                }\n-                case StatisticsFunctionKind::kurtPop:\n-                {\n-                    ResultType var_value = data.getPopulation();\n-\n-                    if (var_value > 0)\n-                        dst.push_back(static_cast<ResultType>(data.getMoment4() / pow(var_value, 2)));\n-                    else\n-                        dst.push_back(std::numeric_limits<ResultType>::quiet_NaN());\n-\n-                    break;\n-                }\n-                case StatisticsFunctionKind::kurtSamp:\n-                {\n-                    ResultType var_value = data.getSample();\n-\n-                    if (var_value > 0)\n-                        dst.push_back(static_cast<ResultType>(data.getMoment4() / pow(var_value, 2)));\n-                    else\n-                        dst.push_back(std::numeric_limits<ResultType>::quiet_NaN());\n-\n-                    break;\n-                }\n-                case StatisticsFunctionKind::covarPop:\n-                {\n-                    dst.push_back(data.getPopulation());\n-                    break;\n-                }\n-                case StatisticsFunctionKind::covarSamp:\n-                {\n-                    dst.push_back(data.getSample());\n-                    break;\n-                }\n-                case StatisticsFunctionKind::corr:\n-                {\n-                    dst.push_back(data.get());\n-                    break;\n-                }\n+                dst.push_back(data.get());\n+                break;\n             }\n         }\n     }\n@@ -327,7 +247,7 @@ AggregateFunctionPtr createAggregateFunctionStatisticsUnary(\n     AggregateFunctionPtr res;\n     const DataTypePtr & data_type = argument_types[0];\n     if (isDecimal(data_type))\n-        res.reset(createWithDecimalType<FunctionTemplate>(*data_type, *data_type, argument_types, kind));\n+        res.reset(createWithDecimalType<FunctionTemplate>(*data_type, argument_types, kind));\n     else\n         res.reset(createWithNumericType<FunctionTemplate>(*data_type, argument_types, kind));\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionSum.cpp b/src/AggregateFunctions/AggregateFunctionSum.cpp\nindex 4f2a935d9e54..e393cb6dd389 100644\n--- a/src/AggregateFunctions/AggregateFunctionSum.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionSum.cpp\n@@ -19,7 +19,7 @@ namespace\n template <typename T>\n struct SumSimple\n {\n-    /// @note It uses slow Decimal128 (cause we need such a variant). sumWithOverflow is faster for Decimal32/64\n+    /// @note It uses slow Decimal128/256 (cause we need such a variant). sumWithOverflow is faster for Decimal32/64\n     using ResultType = std::conditional_t<is_decimal<T>,\n                                         std::conditional_t<std::is_same_v<T, Decimal256>, Decimal256, Decimal128>,\n                                         NearestFieldType<T>>;\ndiff --git a/src/AggregateFunctions/HelpersMinMaxAny.h b/src/AggregateFunctions/HelpersMinMaxAny.h\nindex 1af51c3f8e6d..026a206b109c 100644\n--- a/src/AggregateFunctions/HelpersMinMaxAny.h\n+++ b/src/AggregateFunctions/HelpersMinMaxAny.h\n@@ -41,6 +41,8 @@ static IAggregateFunction * createAggregateFunctionSingleValue(const String & na\n         return new AggregateFunctionTemplate<Data<SingleValueDataFixed<Decimal64>>>(argument_type);\n     if (which.idx == TypeIndex::Decimal128)\n         return new AggregateFunctionTemplate<Data<SingleValueDataFixed<Decimal128>>>(argument_type);\n+    if (which.idx == TypeIndex::Decimal256)\n+        return new AggregateFunctionTemplate<Data<SingleValueDataFixed<Decimal256>>>(argument_type);\n     if (which.idx == TypeIndex::String)\n         return new AggregateFunctionTemplate<Data<SingleValueDataString>>(argument_type);\n \n@@ -72,6 +74,8 @@ static IAggregateFunction * createAggregateFunctionArgMinMaxSecond(const DataTyp\n         return new AggregateFunctionArgMinMax<AggregateFunctionArgMinMaxData<ResData, MinMaxData<SingleValueDataFixed<Decimal64>>>>(res_type, val_type);\n     if (which.idx == TypeIndex::Decimal128)\n         return new AggregateFunctionArgMinMax<AggregateFunctionArgMinMaxData<ResData, MinMaxData<SingleValueDataFixed<Decimal128>>>>(res_type, val_type);\n+    if (which.idx == TypeIndex::Decimal256)\n+        return new AggregateFunctionArgMinMax<AggregateFunctionArgMinMaxData<ResData, MinMaxData<SingleValueDataFixed<Decimal256>>>>(res_type, val_type);\n     if (which.idx == TypeIndex::String)\n         return new AggregateFunctionArgMinMax<AggregateFunctionArgMinMaxData<ResData, MinMaxData<SingleValueDataString>>>(res_type, val_type);\n \n@@ -106,6 +110,8 @@ static IAggregateFunction * createAggregateFunctionArgMinMax(const String & name\n         return createAggregateFunctionArgMinMaxSecond<MinMaxData, SingleValueDataFixed<Decimal64>>(res_type, val_type);\n     if (which.idx == TypeIndex::Decimal128)\n         return createAggregateFunctionArgMinMaxSecond<MinMaxData, SingleValueDataFixed<Decimal128>>(res_type, val_type);\n+    if (which.idx == TypeIndex::Decimal256)\n+        return createAggregateFunctionArgMinMaxSecond<MinMaxData, SingleValueDataFixed<Decimal256>>(res_type, val_type);\n     if (which.idx == TypeIndex::String)\n         return createAggregateFunctionArgMinMaxSecond<MinMaxData, SingleValueDataString>(res_type, val_type);\n \ndiff --git a/src/AggregateFunctions/Moments.h b/src/AggregateFunctions/Moments.h\nindex 8e8bdd9f2101..a34f960794cc 100644\n--- a/src/AggregateFunctions/Moments.h\n+++ b/src/AggregateFunctions/Moments.h\n@@ -17,7 +17,6 @@ struct Settings;\n namespace ErrorCodes\n {\n     extern const int BAD_ARGUMENTS;\n-    extern const int DECIMAL_OVERFLOW;\n     extern const int LOGICAL_ERROR;\n }\n \n@@ -136,114 +135,6 @@ struct VarMoments\n     }\n };\n \n-template <typename T, size_t _level>\n-class VarMomentsDecimal\n-{\n-public:\n-    using NativeType = typename T::NativeType;\n-\n-    void add(NativeType x)\n-    {\n-        ++m0;\n-        getM(1) += x;\n-\n-        NativeType tmp;\n-        bool overflow = common::mulOverflow(x, x, tmp) || common::addOverflow(getM(2), tmp, getM(2));\n-        if constexpr (_level >= 3)\n-            overflow = overflow || common::mulOverflow(tmp, x, tmp) || common::addOverflow(getM(3), tmp, getM(3));\n-        if constexpr (_level >= 4)\n-            overflow = overflow || common::mulOverflow(tmp, x, tmp) || common::addOverflow(getM(4), tmp, getM(4));\n-\n-        if (overflow)\n-            throw Exception(ErrorCodes::DECIMAL_OVERFLOW, \"Decimal math overflow\");\n-    }\n-\n-    void merge(const VarMomentsDecimal & rhs)\n-    {\n-        m0 += rhs.m0;\n-        getM(1) += rhs.getM(1);\n-\n-        bool overflow = common::addOverflow(getM(2), rhs.getM(2), getM(2));\n-        if constexpr (_level >= 3)\n-            overflow = overflow || common::addOverflow(getM(3), rhs.getM(3), getM(3));\n-        if constexpr (_level >= 4)\n-            overflow = overflow || common::addOverflow(getM(4), rhs.getM(4), getM(4));\n-\n-        if (overflow)\n-            throw Exception(ErrorCodes::DECIMAL_OVERFLOW, \"Decimal math overflow\");\n-    }\n-\n-    void write(WriteBuffer & buf) const { writePODBinary(*this, buf); }\n-    void read(ReadBuffer & buf) { readPODBinary(*this, buf); }\n-\n-    Float64 get() const\n-    {\n-        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Variation moments should be obtained by either 'getSample' or 'getPopulation' method\");\n-    }\n-\n-    Float64 getPopulation(UInt32 scale) const\n-    {\n-        if (m0 == 0)\n-            return std::numeric_limits<Float64>::infinity();\n-\n-        NativeType tmp;\n-        if (common::mulOverflow(getM(1), getM(1), tmp) ||\n-            common::subOverflow(getM(2), NativeType(tmp / m0), tmp))\n-            throw Exception(ErrorCodes::DECIMAL_OVERFLOW, \"Decimal math overflow\");\n-        return std::max(Float64{}, DecimalUtils::convertTo<Float64>(T(tmp / m0), scale));\n-    }\n-\n-    Float64 getSample(UInt32 scale) const\n-    {\n-        if (m0 == 0)\n-            return std::numeric_limits<Float64>::quiet_NaN();\n-        if (m0 == 1)\n-            return std::numeric_limits<Float64>::infinity();\n-\n-        NativeType tmp;\n-        if (common::mulOverflow(getM(1), getM(1), tmp) ||\n-            common::subOverflow(getM(2), NativeType(tmp / m0), tmp))\n-            throw Exception(ErrorCodes::DECIMAL_OVERFLOW, \"Decimal math overflow\");\n-        return std::max(Float64{}, DecimalUtils::convertTo<Float64>(T(tmp / (m0 - 1)), scale));\n-    }\n-\n-    Float64 getMoment3(UInt32 scale) const\n-    {\n-        if (m0 == 0)\n-            return std::numeric_limits<Float64>::infinity();\n-\n-        NativeType tmp;\n-        if (common::mulOverflow(2 * getM(1), getM(1), tmp) ||\n-            common::subOverflow(3 * getM(2), NativeType(tmp / m0), tmp) ||\n-            common::mulOverflow(tmp, getM(1), tmp) ||\n-            common::subOverflow(getM(3), NativeType(tmp / m0), tmp))\n-            throw Exception(ErrorCodes::DECIMAL_OVERFLOW, \"Decimal math overflow\");\n-        return DecimalUtils::convertTo<Float64>(T(tmp / m0), scale);\n-    }\n-\n-    Float64 getMoment4(UInt32 scale) const\n-    {\n-        if (m0 == 0)\n-            return std::numeric_limits<Float64>::infinity();\n-\n-        NativeType tmp;\n-        if (common::mulOverflow(3 * getM(1), getM(1), tmp) ||\n-            common::subOverflow(6 * getM(2), NativeType(tmp / m0), tmp) ||\n-            common::mulOverflow(tmp, getM(1), tmp) ||\n-            common::subOverflow(4 * getM(3), NativeType(tmp / m0), tmp) ||\n-            common::mulOverflow(tmp, getM(1), tmp) ||\n-            common::subOverflow(getM(4), NativeType(tmp / m0), tmp))\n-            throw Exception(ErrorCodes::DECIMAL_OVERFLOW, \"Decimal math overflow\");\n-        return DecimalUtils::convertTo<Float64>(T(tmp / m0), scale);\n-    }\n-\n-private:\n-    UInt64 m0{};\n-    NativeType m[_level]{};\n-\n-    NativeType & getM(size_t i) { return m[i - 1]; }\n-    const NativeType & getM(size_t i) const { return m[i - 1]; }\n-};\n \n /**\n     Calculating multivariate central moments\ndiff --git a/src/AggregateFunctions/QuantileExactWeighted.h b/src/AggregateFunctions/QuantileExactWeighted.h\nindex 48ba253cb95a..c6a779ede61e 100644\n--- a/src/AggregateFunctions/QuantileExactWeighted.h\n+++ b/src/AggregateFunctions/QuantileExactWeighted.h\n@@ -33,7 +33,7 @@ struct QuantileExactWeighted\n \n     using Weight = UInt64;\n     using UnderlyingType = NativeType<Value>;\n-    using Hasher = std::conditional_t<std::is_same_v<Value, Decimal128>, Int128Hash, HashCRC32<UnderlyingType>>;\n+    using Hasher = HashCRC32<UnderlyingType>;\n \n     /// When creating, the hash table must be small.\n     using Map = HashMapWithStackMemory<UnderlyingType, Weight, Hasher, 4>;\ndiff --git a/src/AggregateFunctions/QuantileInterpolatedWeighted.h b/src/AggregateFunctions/QuantileInterpolatedWeighted.h\nindex eef4f5668899..5b1eb315af3e 100644\n--- a/src/AggregateFunctions/QuantileInterpolatedWeighted.h\n+++ b/src/AggregateFunctions/QuantileInterpolatedWeighted.h\n@@ -34,7 +34,7 @@ struct QuantileInterpolatedWeighted\n \n     using Weight = UInt64;\n     using UnderlyingType = NativeType<Value>;\n-    using Hasher = std::conditional_t<std::is_same_v<Value, Decimal128>, Int128Hash, HashCRC32<UnderlyingType>>;\n+    using Hasher = HashCRC32<UnderlyingType>;\n \n     /// When creating, the hash table must be small.\n     using Map = HashMapWithStackMemory<UnderlyingType, Weight, Hasher, 4>;\ndiff --git a/src/Client/QueryFuzzer.cpp b/src/Client/QueryFuzzer.cpp\nindex adcebf8a5f4f..bfcfe6599828 100644\n--- a/src/Client/QueryFuzzer.cpp\n+++ b/src/Client/QueryFuzzer.cpp\n@@ -107,8 +107,9 @@ Field QueryFuzzer::fuzzField(Field field)\n         type_index = 1;\n     }\n     else if (type == Field::Types::Decimal32\n-             || type == Field::Types::Decimal64\n-             || type == Field::Types::Decimal128)\n+        || type == Field::Types::Decimal64\n+        || type == Field::Types::Decimal128\n+        || type == Field::Types::Decimal256)\n     {\n         type_index = 2;\n     }\ndiff --git a/src/Core/PostgreSQLProtocol.cpp b/src/Core/PostgreSQLProtocol.cpp\nindex 553d195605a1..5a96ed7a500a 100644\n--- a/src/Core/PostgreSQLProtocol.cpp\n+++ b/src/Core/PostgreSQLProtocol.cpp\n@@ -37,6 +37,7 @@ ColumnTypeSpec convertTypeIndexToPostgresColumnTypeSpec(TypeIndex type_index)\n         case TypeIndex::Decimal32:\n         case TypeIndex::Decimal64:\n         case TypeIndex::Decimal128:\n+        case TypeIndex::Decimal256:\n             return {ColumnType::NUMERIC, -1};\n \n         case TypeIndex::UUID:\ndiff --git a/src/DataTypes/DataTypesDecimal.cpp b/src/DataTypes/DataTypesDecimal.cpp\nindex 2838f5868d4d..1c2a63371eea 100644\n--- a/src/DataTypes/DataTypesDecimal.cpp\n+++ b/src/DataTypes/DataTypesDecimal.cpp\n@@ -40,8 +40,10 @@ bool DataTypeDecimal<T>::equals(const IDataType & rhs) const\n template <is_decimal T>\n DataTypePtr DataTypeDecimal<T>::promoteNumericType() const\n {\n-    using PromotedType = DataTypeDecimal<Decimal128>;\n-    return std::make_shared<PromotedType>(PromotedType::maxPrecision(), this->scale);\n+    if (sizeof(T) <= sizeof(Decimal128))\n+        return std::make_shared<DataTypeDecimal<Decimal128>>(DataTypeDecimal<Decimal128>::maxPrecision(), this->scale);\n+    else\n+        return std::make_shared<DataTypeDecimal<Decimal256>>(DataTypeDecimal<Decimal256>::maxPrecision(), this->scale);\n }\n \n template <is_decimal T>\ndiff --git a/src/DataTypes/convertMySQLDataType.cpp b/src/DataTypes/convertMySQLDataType.cpp\nindex db064a7f06f6..bb848bf15261 100644\n--- a/src/DataTypes/convertMySQLDataType.cpp\n+++ b/src/DataTypes/convertMySQLDataType.cpp\n@@ -115,6 +115,8 @@ DataTypePtr convertMySQLDataType(MultiEnum<MySQLDataTypesSupport> type_support,\n             res = std::make_shared<DataTypeDecimal<Decimal64>>(precision, scale);\n         else if (precision <= DecimalUtils::max_precision<Decimal128>)\n             res = std::make_shared<DataTypeDecimal<Decimal128>>(precision, scale);\n+        else if (precision <= DecimalUtils::max_precision<Decimal256>)\n+            res = std::make_shared<DataTypeDecimal<Decimal256>>(precision, scale);\n     }\n \n     /// Also String is fallback for all unknown types.\ndiff --git a/src/DataTypes/getLeastSupertype.cpp b/src/DataTypes/getLeastSupertype.cpp\nindex b50aeb76e677..3c33289c3047 100644\n--- a/src/DataTypes/getLeastSupertype.cpp\n+++ b/src/DataTypes/getLeastSupertype.cpp\n@@ -15,11 +15,9 @@\n #include <DataTypes/DataTypeString.h>\n #include <DataTypes/DataTypeDateTime.h>\n #include <DataTypes/DataTypeDateTime64.h>\n-#include <DataTypes/DataTypeEnum.h>\n #include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/DataTypesDecimal.h>\n #include <DataTypes/DataTypeFactory.h>\n-#include <base/EnumReflection.h>\n \n \n namespace DB\n@@ -528,13 +526,14 @@ DataTypePtr getLeastSupertype(const DataTypes & types)\n         size_t have_decimal32 = type_ids.count(TypeIndex::Decimal32);\n         size_t have_decimal64 = type_ids.count(TypeIndex::Decimal64);\n         size_t have_decimal128 = type_ids.count(TypeIndex::Decimal128);\n+        size_t have_decimal256 = type_ids.count(TypeIndex::Decimal256);\n \n-        if (have_decimal32 || have_decimal64 || have_decimal128)\n+        if (have_decimal32 || have_decimal64 || have_decimal128 || have_decimal256)\n         {\n-            size_t num_supported = have_decimal32 + have_decimal64 + have_decimal128;\n+            size_t num_supported = have_decimal32 + have_decimal64 + have_decimal128 + have_decimal256;\n \n-            std::vector<TypeIndex> int_ids = {TypeIndex::Int8, TypeIndex::UInt8, TypeIndex::Int16, TypeIndex::UInt16,\n-                                              TypeIndex::Int32, TypeIndex::UInt32, TypeIndex::Int64, TypeIndex::UInt64};\n+            std::array<TypeIndex, 8> int_ids = {TypeIndex::Int8, TypeIndex::UInt8, TypeIndex::Int16, TypeIndex::UInt16,\n+                                                TypeIndex::Int32, TypeIndex::UInt32, TypeIndex::Int64, TypeIndex::UInt64};\n \n             TypeIndex max_int = TypeIndex::Nothing;\n             for (auto int_id : int_ids)\n@@ -552,8 +551,13 @@ DataTypePtr getLeastSupertype(const DataTypes & types)\n             for (const auto & type : types)\n             {\n                 auto type_id = type->getTypeId();\n-                if (type_id != TypeIndex::Decimal32 && type_id != TypeIndex::Decimal64 && type_id != TypeIndex::Decimal128)\n+                if (type_id != TypeIndex::Decimal32\n+                    && type_id != TypeIndex::Decimal64\n+                    && type_id != TypeIndex::Decimal128\n+                    && type_id != TypeIndex::Decimal256)\n+                {\n                     continue;\n+                }\n \n                 UInt32 scale = getDecimalScale(*type);\n                 if (scale > max_scale)\n@@ -571,11 +575,13 @@ DataTypePtr getLeastSupertype(const DataTypes & types)\n                     min_precision = DataTypeDecimal<Decimal64>::maxPrecision();\n             }\n \n-            if (min_precision > DataTypeDecimal<Decimal128>::maxPrecision())\n+            if (min_precision > DataTypeDecimal<Decimal256>::maxPrecision())\n                 return throwOrReturn<on_error>(types, \"because the least supertype is Decimal(\"\n                                 + toString(min_precision) + ',' + toString(max_scale) + ')',\n                                 ErrorCodes::NO_COMMON_TYPE);\n \n+            if (have_decimal256 || min_precision > DataTypeDecimal<Decimal128>::maxPrecision())\n+                return std::make_shared<DataTypeDecimal<Decimal256>>(DataTypeDecimal<Decimal256>::maxPrecision(), max_scale);\n             if (have_decimal128 || min_precision > DataTypeDecimal<Decimal64>::maxPrecision())\n                 return std::make_shared<DataTypeDecimal<Decimal128>>(DataTypeDecimal<Decimal128>::maxPrecision(), max_scale);\n             if (have_decimal64 || min_precision > DataTypeDecimal<Decimal32>::maxPrecision())\ndiff --git a/src/DataTypes/getMostSubtype.cpp b/src/DataTypes/getMostSubtype.cpp\nindex e5d529205d26..33b5735456ea 100644\n--- a/src/DataTypes/getMostSubtype.cpp\n+++ b/src/DataTypes/getMostSubtype.cpp\n@@ -11,6 +11,7 @@\n #include <DataTypes/DataTypeString.h>\n #include <DataTypes/DataTypeDate.h>\n #include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/DataTypesDecimal.h>\n \n \n namespace DB\n@@ -280,6 +281,10 @@ DataTypePtr getMostSubtype(const DataTypes & types, bool throw_if_result_is_noth\n                 minimize(min_bits_of_unsigned_integer, 32);\n             else if (typeid_cast<const DataTypeUInt64 *>(type.get()))\n                 minimize(min_bits_of_unsigned_integer, 64);\n+            else if (typeid_cast<const DataTypeUInt128 *>(type.get()))\n+                minimize(min_bits_of_unsigned_integer, 128);\n+            else if (typeid_cast<const DataTypeUInt256 *>(type.get()))\n+                minimize(min_bits_of_unsigned_integer, 256);\n             else if (typeid_cast<const DataTypeInt8 *>(type.get()))\n                 minimize(min_bits_of_signed_integer, 8);\n             else if (typeid_cast<const DataTypeInt16 *>(type.get()))\n@@ -288,6 +293,10 @@ DataTypePtr getMostSubtype(const DataTypes & types, bool throw_if_result_is_noth\n                 minimize(min_bits_of_signed_integer, 32);\n             else if (typeid_cast<const DataTypeInt64 *>(type.get()))\n                 minimize(min_bits_of_signed_integer, 64);\n+            else if (typeid_cast<const DataTypeInt128 *>(type.get()))\n+                minimize(min_bits_of_signed_integer, 128);\n+            else if (typeid_cast<const DataTypeInt256 *>(type.get()))\n+                minimize(min_bits_of_signed_integer, 256);\n             else if (typeid_cast<const DataTypeFloat32 *>(type.get()))\n                 minimize(min_mantissa_bits_of_floating, 24);\n             else if (typeid_cast<const DataTypeFloat64 *>(type.get()))\n@@ -326,6 +335,10 @@ DataTypePtr getMostSubtype(const DataTypes & types, bool throw_if_result_is_noth\n                     return std::make_shared<DataTypeUInt32>();\n                 else if (min_bits_of_unsigned_integer <= 64)\n                     return std::make_shared<DataTypeUInt64>();\n+                else if (min_bits_of_unsigned_integer <= 128)\n+                    return std::make_shared<DataTypeUInt128>();\n+                else if (min_bits_of_unsigned_integer <= 256)\n+                    return std::make_shared<DataTypeUInt256>();\n                 else\n                     throw Exception(ErrorCodes::NO_COMMON_TYPE,\n                                     \"Logical error: {} but as all data types are integers, \"\n@@ -343,6 +356,10 @@ DataTypePtr getMostSubtype(const DataTypes & types, bool throw_if_result_is_noth\n                     return std::make_shared<DataTypeInt32>();\n                 else if (min_bits_of_signed_integer <= 64)\n                     return std::make_shared<DataTypeInt64>();\n+                else if (min_bits_of_signed_integer <= 128)\n+                    return std::make_shared<DataTypeInt128>();\n+                else if (min_bits_of_signed_integer <= 256)\n+                    return std::make_shared<DataTypeInt256>();\n                 else\n                     throw Exception(ErrorCodes::NO_COMMON_TYPE,\n                                     \"Logical error: {} but as all data types are integers, \"\n@@ -351,6 +368,29 @@ DataTypePtr getMostSubtype(const DataTypes & types, bool throw_if_result_is_noth\n         }\n     }\n \n+    /// Decimals\n+    {\n+        bool all_decimals = true;\n+        UInt32 min_scale = std::numeric_limits<UInt32>::max();\n+        UInt32 min_precision = std::numeric_limits<UInt32>::max();\n+        for (const auto & type : types)\n+        {\n+            if (isDecimal(type))\n+            {\n+                min_scale = std::min(min_scale, getDecimalScale(*type));\n+                min_precision = std::min(min_precision, getDecimalPrecision(*type));\n+            }\n+            else\n+            {\n+                all_decimals = false;\n+                break;\n+            }\n+        }\n+\n+        if (all_decimals)\n+            return createDecimal<DataTypeDecimal>(min_precision, min_scale);\n+    }\n+\n     /// All other data types (UUID, AggregateFunction, Enum...) are compatible only if they are the same (checked in trivial cases).\n     return get_nothing_or_throw(\"\");\n }\ndiff --git a/src/Functions/FunctionsBinaryRepresentation.cpp b/src/Functions/FunctionsBinaryRepresentation.cpp\nindex d44323f8bf3f..c3a8f51ee4b4 100644\n--- a/src/Functions/FunctionsBinaryRepresentation.cpp\n+++ b/src/Functions/FunctionsBinaryRepresentation.cpp\n@@ -299,6 +299,7 @@ class EncodeToBinaryRepresentation : public IFunction\n             tryExecuteDecimal<Decimal32>(column, res_column) ||\n             tryExecuteDecimal<Decimal64>(column, res_column) ||\n             tryExecuteDecimal<Decimal128>(column, res_column) ||\n+            tryExecuteDecimal<Decimal256>(column, res_column) ||\n             tryExecuteUUID(column, res_column) ||\n             tryExecuteIPv4(column, res_column) ||\n             tryExecuteIPv6(column, res_column))\ndiff --git a/src/Functions/FunctionsExternalDictionaries.h b/src/Functions/FunctionsExternalDictionaries.h\nindex d3be5b1200b0..f0dd5553f5ec 100644\n--- a/src/Functions/FunctionsExternalDictionaries.h\n+++ b/src/Functions/FunctionsExternalDictionaries.h\n@@ -721,9 +721,6 @@ struct NameDictGetDateTime { static constexpr auto name = \"dictGetDateTime\"; };\n struct NameDictGetUUID { static constexpr auto name = \"dictGetUUID\"; };\n struct NameDictGetIPv4 { static constexpr auto name = \"dictGetIPv4\"; };\n struct NameDictGetIPv6 { static constexpr auto name = \"dictGetIPv6\"; };\n-struct NameDictGetDecimal32 { static constexpr auto name = \"dictGetDecimal32\"; };\n-struct NameDictGetDecimal64 { static constexpr auto name = \"dictGetDecimal64\"; };\n-struct NameDictGetDecimal128 { static constexpr auto name = \"dictGetDecimal128\"; };\n struct NameDictGetString { static constexpr auto name = \"dictGetString\"; };\n \n using FunctionDictGetUInt8 = FunctionDictGet<DataTypeUInt8, NameDictGetUInt8>;\n@@ -741,9 +738,6 @@ using FunctionDictGetDateTime = FunctionDictGet<DataTypeDateTime, NameDictGetDat\n using FunctionDictGetUUID = FunctionDictGet<DataTypeUUID, NameDictGetUUID>;\n using FunctionDictGetIPv4 = FunctionDictGet<DataTypeIPv4, NameDictGetIPv4>;\n using FunctionDictGetIPv6 = FunctionDictGet<DataTypeIPv6, NameDictGetIPv6>;\n-using FunctionDictGetDecimal32 = FunctionDictGet<DataTypeDecimal<Decimal32>, NameDictGetDecimal32>;\n-using FunctionDictGetDecimal64 = FunctionDictGet<DataTypeDecimal<Decimal64>, NameDictGetDecimal64>;\n-using FunctionDictGetDecimal128 = FunctionDictGet<DataTypeDecimal<Decimal128>, NameDictGetDecimal128>;\n using FunctionDictGetString = FunctionDictGet<DataTypeString, NameDictGetString>;\n \n template<typename DataType, typename Name>\n@@ -764,9 +758,6 @@ struct NameDictGetDateTimeOrDefault { static constexpr auto name = \"dictGetDateT\n struct NameDictGetUUIDOrDefault { static constexpr auto name = \"dictGetUUIDOrDefault\"; };\n struct NameDictGetIPv4OrDefault { static constexpr auto name = \"dictGetIPv4OrDefault\"; };\n struct NameDictGetIPv6OrDefault { static constexpr auto name = \"dictGetIPv6OrDefault\"; };\n-struct NameDictGetDecimal32OrDefault { static constexpr auto name = \"dictGetDecimal32OrDefault\"; };\n-struct NameDictGetDecimal64OrDefault { static constexpr auto name = \"dictGetDecimal64OrDefault\"; };\n-struct NameDictGetDecimal128OrDefault { static constexpr auto name = \"dictGetDecimal128OrDefault\"; };\n struct NameDictGetStringOrDefault { static constexpr auto name = \"dictGetStringOrDefault\"; };\n \n using FunctionDictGetUInt8OrDefault = FunctionDictGetOrDefault<DataTypeUInt8, NameDictGetUInt8OrDefault>;\n@@ -784,9 +775,6 @@ using FunctionDictGetDateTimeOrDefault = FunctionDictGetOrDefault<DataTypeDateTi\n using FunctionDictGetUUIDOrDefault = FunctionDictGetOrDefault<DataTypeUUID, NameDictGetUUIDOrDefault>;\n using FunctionDictGetIPv4OrDefault = FunctionDictGetOrDefault<DataTypeIPv4, NameDictGetIPv4OrDefault>;\n using FunctionDictGetIPv6OrDefault = FunctionDictGetOrDefault<DataTypeIPv6, NameDictGetIPv6OrDefault>;\n-using FunctionDictGetDecimal32OrDefault = FunctionDictGetOrDefault<DataTypeDecimal<Decimal32>, NameDictGetDecimal32OrDefault>;\n-using FunctionDictGetDecimal64OrDefault = FunctionDictGetOrDefault<DataTypeDecimal<Decimal64>, NameDictGetDecimal64OrDefault>;\n-using FunctionDictGetDecimal128OrDefault = FunctionDictGetOrDefault<DataTypeDecimal<Decimal128>, NameDictGetDecimal128OrDefault>;\n using FunctionDictGetStringOrDefault = FunctionDictGetOrDefault<DataTypeString, NameDictGetStringOrDefault>;\n \n class FunctionDictGetOrNull final : public IFunction\ndiff --git a/src/Functions/FunctionsJSON.cpp b/src/Functions/FunctionsJSON.cpp\nindex 5df0d1831af7..8bcb1f4d849d 100644\n--- a/src/Functions/FunctionsJSON.cpp\n+++ b/src/Functions/FunctionsJSON.cpp\n@@ -750,42 +750,12 @@ class JSONExtractNumericImpl\n };\n \n \n-template <typename JSONParser>\n-using JSONExtractInt8Impl = JSONExtractNumericImpl<JSONParser, Int8>;\n-template <typename JSONParser>\n-using JSONExtractUInt8Impl = JSONExtractNumericImpl<JSONParser, UInt8>;\n-template <typename JSONParser>\n-using JSONExtractInt16Impl = JSONExtractNumericImpl<JSONParser, Int16>;\n-template <typename JSONParser>\n-using JSONExtractUInt16Impl = JSONExtractNumericImpl<JSONParser, UInt16>;\n-template <typename JSONParser>\n-using JSONExtractInt32Impl = JSONExtractNumericImpl<JSONParser, Int32>;\n-template <typename JSONParser>\n-using JSONExtractUInt32Impl = JSONExtractNumericImpl<JSONParser, UInt32>;\n template <typename JSONParser>\n using JSONExtractInt64Impl = JSONExtractNumericImpl<JSONParser, Int64>;\n template <typename JSONParser>\n using JSONExtractUInt64Impl = JSONExtractNumericImpl<JSONParser, UInt64>;\n template <typename JSONParser>\n-using JSONExtractInt128Impl = JSONExtractNumericImpl<JSONParser, Int128>;\n-template <typename JSONParser>\n-using JSONExtractUInt128Impl = JSONExtractNumericImpl<JSONParser, UInt128>;\n-template <typename JSONParser>\n-using JSONExtractInt256Impl = JSONExtractNumericImpl<JSONParser, Int256>;\n-template <typename JSONParser>\n-using JSONExtractUInt256Impl = JSONExtractNumericImpl<JSONParser, UInt256>;\n-template <typename JSONParser>\n-using JSONExtractFloat32Impl = JSONExtractNumericImpl<JSONParser, Float32>;\n-template <typename JSONParser>\n using JSONExtractFloat64Impl = JSONExtractNumericImpl<JSONParser, Float64>;\n-template <typename JSONParser>\n-using JSONExtractDecimal32Impl = JSONExtractNumericImpl<JSONParser, Decimal32>;\n-template <typename JSONParser>\n-using JSONExtractDecimal64Impl = JSONExtractNumericImpl<JSONParser, Decimal64>;\n-template <typename JSONParser>\n-using JSONExtractDecimal128Impl = JSONExtractNumericImpl<JSONParser, Decimal128>;\n-template <typename JSONParser>\n-using JSONExtractDecimal256Impl = JSONExtractNumericImpl<JSONParser, Decimal256>;\n \n \n template <typename JSONParser>\ndiff --git a/src/Functions/FunctionsRound.h b/src/Functions/FunctionsRound.h\nindex 2f2a0c3a1a91..3d1028c6d351 100644\n--- a/src/Functions/FunctionsRound.h\n+++ b/src/Functions/FunctionsRound.h\n@@ -703,7 +703,8 @@ class FunctionRoundDown : public IFunction\n             && !executeNum<Float64>(in, out, boundaries)\n             && !executeDecimal<Decimal32>(in, out, boundaries)\n             && !executeDecimal<Decimal64>(in, out, boundaries)\n-            && !executeDecimal<Decimal128>(in, out, boundaries))\n+            && !executeDecimal<Decimal128>(in, out, boundaries)\n+            && !executeDecimal<Decimal256>(in, out, boundaries))\n         {\n             throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\", in->getName(), getName());\n         }\ndiff --git a/src/Functions/array/arrayAggregation.cpp b/src/Functions/array/arrayAggregation.cpp\nindex 75ea3a81a7d0..59991b7b3139 100644\n--- a/src/Functions/array/arrayAggregation.cpp\n+++ b/src/Functions/array/arrayAggregation.cpp\n@@ -38,7 +38,7 @@ enum class AggregateOperation\n  * During array aggregation we derive result type from operation.\n  * For array min or array max we use array element as result type.\n  * For array average we use Float64.\n- * For array sum for for big integers, we use same type representation, decimal numbers we use Decimal128,\n+ * For array sum for big integers, we use same type representation, decimal numbers up to 128-bit will use Decimal128, then Decimal256.\n  * for floating point numbers Float64, for numeric unsigned Int64, and for numeric signed UInt64.\n  */\n \n@@ -77,10 +77,13 @@ struct ArrayAggregateResultImpl<ArrayElement, AggregateOperation::sum>\n         std::conditional_t<std::is_same_v<ArrayElement, UInt128>, UInt128,\n         std::conditional_t<std::is_same_v<ArrayElement, Int256>, Int256,\n         std::conditional_t<std::is_same_v<ArrayElement, UInt256>, UInt256,\n-        std::conditional_t<is_decimal<ArrayElement>, Decimal128,\n+        std::conditional_t<std::is_same_v<ArrayElement, Decimal32>, Decimal128,\n+        std::conditional_t<std::is_same_v<ArrayElement, Decimal64>, Decimal128,\n+        std::conditional_t<std::is_same_v<ArrayElement, Decimal128>, Decimal128,\n+        std::conditional_t<std::is_same_v<ArrayElement, Decimal256>, Decimal256,\n         std::conditional_t<std::is_floating_point_v<ArrayElement>, Float64,\n         std::conditional_t<std::is_signed_v<ArrayElement>, Int64,\n-            UInt64>>>>>>>;\n+            UInt64>>>>>>>>>>;\n };\n \n template <typename ArrayElement, AggregateOperation operation>\n@@ -364,8 +367,11 @@ struct ArrayAggregateImpl\n             executeType<Float64>(mapped, offsets, res) ||\n             executeType<Decimal32>(mapped, offsets, res) ||\n             executeType<Decimal64>(mapped, offsets, res) ||\n-            executeType<Decimal128>(mapped, offsets, res))\n+            executeType<Decimal128>(mapped, offsets, res) ||\n+            executeType<Decimal256>(mapped, offsets, res))\n+        {\n             return res;\n+        }\n         else\n             throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Unexpected column for arraySum: {}\", mapped->getName());\n     }\n@@ -396,4 +402,3 @@ REGISTER_FUNCTION(ArrayAggregation)\n }\n \n }\n-\ndiff --git a/src/Functions/array/arrayCompact.cpp b/src/Functions/array/arrayCompact.cpp\nindex 5c899d4d97e3..15df9f0d0082 100644\n--- a/src/Functions/array/arrayCompact.cpp\n+++ b/src/Functions/array/arrayCompact.cpp\n@@ -151,7 +151,8 @@ struct ArrayCompactImpl\n             executeType<Float64>(mapped, array, res)) ||\n             executeType<Decimal32>(mapped, array, res) ||\n             executeType<Decimal64>(mapped, array, res) ||\n-            executeType<Decimal128>(mapped, array, res))\n+            executeType<Decimal128>(mapped, array, res) ||\n+            executeType<Decimal256>(mapped, array, res))\n         {\n             executeGeneric(mapped, array, res);\n         }\n@@ -168,4 +169,3 @@ REGISTER_FUNCTION(ArrayCompact)\n }\n \n }\n-\ndiff --git a/src/Functions/array/arrayCumSum.cpp b/src/Functions/array/arrayCumSum.cpp\nindex 489014ebe557..b1077bfb18b4 100644\n--- a/src/Functions/array/arrayCumSum.cpp\n+++ b/src/Functions/array/arrayCumSum.cpp\n@@ -41,7 +41,11 @@ struct ArrayCumSumImpl\n         if (which.isDecimal())\n         {\n             UInt32 scale = getDecimalScale(*expression_return);\n-            DataTypePtr nested = std::make_shared<DataTypeDecimal<Decimal128>>(DecimalUtils::max_precision<Decimal128>, scale);\n+            DataTypePtr nested;\n+            if (which.isDecimal256())\n+                nested = std::make_shared<DataTypeDecimal<Decimal256>>(DecimalUtils::max_precision<Decimal256>, scale);\n+            else\n+                nested = std::make_shared<DataTypeDecimal<Decimal128>>(DecimalUtils::max_precision<Decimal128>, scale);\n             return std::make_shared<DataTypeArray>(nested);\n         }\n \n@@ -151,7 +155,8 @@ struct ArrayCumSumImpl\n             executeType<Float64,Float64>(mapped, array, res) ||\n             executeType<Decimal32, Decimal128>(mapped, array, res) ||\n             executeType<Decimal64, Decimal128>(mapped, array, res) ||\n-            executeType<Decimal128, Decimal128>(mapped, array, res))\n+            executeType<Decimal128, Decimal128>(mapped, array, res) ||\n+            executeType<Decimal256, Decimal256>(mapped, array, res))\n             return res;\n         else\n             throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Unexpected column for arrayCumSum: {}\", mapped->getName());\n@@ -168,4 +173,3 @@ REGISTER_FUNCTION(ArrayCumSum)\n }\n \n }\n-\ndiff --git a/src/Functions/array/arrayCumSumNonNegative.cpp b/src/Functions/array/arrayCumSumNonNegative.cpp\nindex c0062fd8230d..6b20ad35afcc 100644\n--- a/src/Functions/array/arrayCumSumNonNegative.cpp\n+++ b/src/Functions/array/arrayCumSumNonNegative.cpp\n@@ -42,7 +42,11 @@ struct ArrayCumSumNonNegativeImpl\n         if (which.isDecimal())\n         {\n             UInt32 scale = getDecimalScale(*expression_return);\n-            DataTypePtr nested = std::make_shared<DataTypeDecimal<Decimal128>>(DecimalUtils::max_precision<Decimal128>, scale);\n+            DataTypePtr nested;\n+            if (which.isDecimal256())\n+                nested = std::make_shared<DataTypeDecimal<Decimal256>>(DecimalUtils::max_precision<Decimal256>, scale);\n+            else\n+                nested = std::make_shared<DataTypeDecimal<Decimal128>>(DecimalUtils::max_precision<Decimal128>, scale);\n             return std::make_shared<DataTypeArray>(nested);\n         }\n \n@@ -116,7 +120,8 @@ struct ArrayCumSumNonNegativeImpl\n             executeType<Float64,Float64>(mapped, array, res) ||\n             executeType<Decimal32, Decimal128>(mapped, array, res) ||\n             executeType<Decimal64, Decimal128>(mapped, array, res) ||\n-            executeType<Decimal128, Decimal128>(mapped, array, res))\n+            executeType<Decimal128, Decimal128>(mapped, array, res) ||\n+            executeType<Decimal256, Decimal256>(mapped, array, res))\n             return res;\n         else\n             throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Unexpected column for arrayCumSumNonNegativeImpl: {}\", mapped->getName());\n@@ -133,4 +138,3 @@ REGISTER_FUNCTION(ArrayCumSumNonNegative)\n }\n \n }\n-\ndiff --git a/src/Functions/array/arrayDifference.cpp b/src/Functions/array/arrayDifference.cpp\nindex ab7b94f98f1f..2852c5b967c6 100644\n--- a/src/Functions/array/arrayDifference.cpp\n+++ b/src/Functions/array/arrayDifference.cpp\n@@ -145,7 +145,8 @@ struct ArrayDifferenceImpl\n             executeType<Float64,Float64>(mapped, array, res) ||\n             executeType<Decimal32, Decimal32>(mapped, array, res) ||\n             executeType<Decimal64, Decimal64>(mapped, array, res) ||\n-            executeType<Decimal128, Decimal128>(mapped, array, res))\n+            executeType<Decimal128, Decimal128>(mapped, array, res) ||\n+            executeType<Decimal256, Decimal256>(mapped, array, res))\n             return res;\n         else\n             throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Unexpected column for arrayDifference: {}\", mapped->getName());\n@@ -161,4 +162,3 @@ REGISTER_FUNCTION(ArrayDifference)\n }\n \n }\n-\ndiff --git a/src/Functions/array/arrayIntersect.cpp b/src/Functions/array/arrayIntersect.cpp\nindex 5da9a2025bb1..d1bbd169513b 100644\n--- a/src/Functions/array/arrayIntersect.cpp\n+++ b/src/Functions/array/arrayIntersect.cpp\n@@ -22,7 +22,6 @@\n #include <Common/assert_cast.h>\n #include <base/TypeLists.h>\n #include <Interpreters/castColumn.h>\n-#include <base/range.h>\n \n \n namespace DB\n@@ -219,11 +218,12 @@ FunctionArrayIntersect::CastArgumentsResult FunctionArrayIntersect::castColumns(\n     const auto & type_nested = type_array->getNestedType();\n     auto type_not_nullable_nested = removeNullable(type_nested);\n \n-    const bool is_numeric_or_string = isNativeNumber(type_not_nullable_nested)\n-                                      || isDate(type_not_nullable_nested)\n-                                      || isDateTime(type_not_nullable_nested)\n-                                      || isDateTime64(type_not_nullable_nested)\n-                                      || isStringOrFixedString(type_not_nullable_nested);\n+    const bool is_numeric_or_string =\n+        isNumber(type_not_nullable_nested)\n+        || isDate(type_not_nullable_nested)\n+        || isDateTime(type_not_nullable_nested)\n+        || isDateTime64(type_not_nullable_nested)\n+        || isStringOrFixedString(type_not_nullable_nested);\n \n     DataTypePtr nullable_return_type;\n \n@@ -303,7 +303,7 @@ FunctionArrayIntersect::UnpackedArrays FunctionArrayIntersect::prepareArrays(\n \n     bool all_const = true;\n \n-    for (auto i : collections::range(0, columns_number))\n+    for (size_t i = 0; i < columns_number; ++i)\n     {\n         auto & arg = arrays.args[i];\n         const auto * argument_column = columns[i].column.get();\n@@ -313,7 +313,7 @@ FunctionArrayIntersect::UnpackedArrays FunctionArrayIntersect::prepareArrays(\n         {\n             arg.is_const = true;\n             argument_column = argument_column_const->getDataColumnPtr().get();\n-            initial_column = &typeid_cast<const ColumnConst &>(*initial_column).getDataColumn();\n+            initial_column = typeid_cast<const ColumnConst &>(*initial_column).getDataColumnPtr().get();\n         }\n \n         if (const auto * argument_column_array = typeid_cast<const ColumnArray *>(argument_column))\n@@ -330,16 +330,21 @@ FunctionArrayIntersect::UnpackedArrays FunctionArrayIntersect::prepareArrays(\n             {\n                 arg.null_map = &column_nullable->getNullMapData();\n                 arg.nested_column = &column_nullable->getNestedColumn();\n-                initial_column = &typeid_cast<const ColumnNullable &>(*initial_column).getNestedColumn();\n+\n+                if (initial_column->isNullable())\n+                    initial_column = &typeid_cast<const ColumnNullable &>(*initial_column).getNestedColumn();\n             }\n \n-            /// In case column was casted need to create overflow mask for integer types.\n+            /// In case the column was casted, we need to create an overflow mask for integer types.\n             if (arg.nested_column != initial_column)\n             {\n-                const auto & nested_init_type = typeid_cast<const DataTypeArray *>(removeNullable(initial_columns[i].type).get())->getNestedType();\n-                const auto & nested_cast_type = typeid_cast<const DataTypeArray *>(removeNullable(columns[i].type).get())->getNestedType();\n+                const auto & nested_init_type = typeid_cast<const DataTypeArray &>(*removeNullable(initial_columns[i].type)).getNestedType();\n+                const auto & nested_cast_type = typeid_cast<const DataTypeArray &>(*removeNullable(columns[i].type)).getNestedType();\n \n-                if (isInteger(nested_init_type) || isDate(nested_init_type) || isDateTime(nested_init_type) || isDateTime64(nested_init_type))\n+                if (isInteger(nested_init_type)\n+                    || isDate(nested_init_type)\n+                    || isDateTime(nested_init_type)\n+                    || isDateTime64(nested_init_type))\n                 {\n                     /// Compare original and casted columns. It seem to be the easiest way.\n                     auto overflow_mask = callFunctionNotEquals(\n@@ -347,7 +352,7 @@ FunctionArrayIntersect::UnpackedArrays FunctionArrayIntersect::prepareArrays(\n                             {initial_column->getPtr(), nested_cast_type, \"\"},\n                             context);\n \n-                    arg.overflow_mask = &typeid_cast<const ColumnUInt8 *>(overflow_mask.get())->getData();\n+                    arg.overflow_mask = &typeid_cast<const ColumnUInt8 &>(*overflow_mask).getData();\n                     arrays.column_holders.emplace_back(std::move(overflow_mask));\n                 }\n             }\n@@ -362,7 +367,7 @@ FunctionArrayIntersect::UnpackedArrays FunctionArrayIntersect::prepareArrays(\n     }\n     else\n     {\n-        for (auto i : collections::range(0, columns_number))\n+        for (size_t i = 0; i < columns_number; ++i)\n         {\n             if (arrays.args[i].is_const)\n                 continue;\n@@ -371,7 +376,7 @@ FunctionArrayIntersect::UnpackedArrays FunctionArrayIntersect::prepareArrays(\n             if (arrays.base_rows == 0 && rows > 0)\n                 arrays.base_rows = rows;\n             else if (arrays.base_rows != rows)\n-                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Non-const array columns in function {}should have same rows\", getName());\n+                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Non-const array columns in function {} should have the same number of rows\", getName());\n         }\n     }\n \n@@ -397,7 +402,6 @@ ColumnPtr FunctionArrayIntersect::executeImpl(const ColumnsWithTypeAndName & arg\n         data_types.push_back(arguments[i].type);\n \n     auto return_type_with_nulls = getMostSubtype(data_types, true, true);\n-\n     auto casted_columns = castColumns(arguments, result_type, return_type_with_nulls);\n \n     UnpackedArrays arrays = prepareArrays(casted_columns.casted, casted_columns.initial);\n@@ -501,13 +505,13 @@ ColumnPtr FunctionArrayIntersect::execute(const UnpackedArrays & arrays, Mutable\n     Map map;\n     std::vector<size_t> prev_off(args, 0);\n     size_t result_offset = 0;\n-    for (auto row : collections::range(0, rows))\n+    for (size_t row = 0; row < rows; ++row)\n     {\n         map.clear();\n \n         bool all_has_nullable = all_nullable;\n \n-        for (auto arg_num : collections::range(0, args))\n+        for (size_t arg_num = 0; arg_num < args; ++arg_num)\n         {\n             const auto & arg = arrays.args[arg_num];\n             bool current_has_nullable = false;\ndiff --git a/src/Functions/array/mapOp.cpp b/src/Functions/array/mapOp.cpp\nindex 2e13d35488f3..613fd934c41b 100644\n--- a/src/Functions/array/mapOp.cpp\n+++ b/src/Functions/array/mapOp.cpp\n@@ -10,7 +10,6 @@\n #include <DataTypes/DataTypesNumber.h>\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionHelpers.h>\n-#include <base/arithmeticOverflow.h>\n #include \"Columns/ColumnMap.h\"\n #include \"DataTypes/DataTypeMap.h\"\n \n@@ -294,6 +293,10 @@ class FunctionMapOp : public IFunction\n                 return execute2<KeyType, UInt256>(row_count, args, res_type);\n             case TypeIndex::Float64:\n                 return execute2<KeyType, Float64>(row_count, args, res_type);\n+            case TypeIndex::Decimal128:\n+                return execute2<KeyType, Decimal128>(row_count, args, res_type);\n+            case TypeIndex::Decimal256:\n+                return execute2<KeyType, Decimal256>(row_count, args, res_type);\n             default:\n                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal column type {} for values in arguments of function {}\",\n                     res_value_type->getName(), getName());\ndiff --git a/src/Interpreters/convertFieldToType.cpp b/src/Interpreters/convertFieldToType.cpp\nindex 9e4f543db43b..1e69a73e9f2e 100644\n--- a/src/Interpreters/convertFieldToType.cpp\n+++ b/src/Interpreters/convertFieldToType.cpp\n@@ -149,6 +149,8 @@ Field convertDecimalType(const Field & from, const To & type)\n         return convertDecimalToDecimalType<Decimal64>(from, type);\n     if (from.getType() == Field::Types::Decimal128)\n         return convertDecimalToDecimalType<Decimal128>(from, type);\n+    if (from.getType() == Field::Types::Decimal256)\n+        return convertDecimalToDecimalType<Decimal256>(from, type);\n \n     if (from.getType() == Field::Types::Float64)\n         return convertFloatToDecimalType<Float64>(from, type);\ndiff --git a/src/Loggers/OwnPatternFormatter.cpp b/src/Loggers/OwnPatternFormatter.cpp\nindex 02a2c2e510b3..ccf6c479b80c 100644\n--- a/src/Loggers/OwnPatternFormatter.cpp\n+++ b/src/Loggers/OwnPatternFormatter.cpp\n@@ -5,7 +5,6 @@\n #include <IO/WriteHelpers.h>\n #include <Common/HashTable/Hash.h>\n #include <Interpreters/InternalTextLogsQueue.h>\n-#include <Common/CurrentThread.h>\n #include <base/terminalColors.h>\n \n \n",
  "test_patch": "diff --git a/tests/integration/test_mysql_database_engine/test.py b/tests/integration/test_mysql_database_engine/test.py\nindex fde8c341e6f8..52a7b319551f 100644\n--- a/tests/integration/test_mysql_database_engine/test.py\n+++ b/tests/integration/test_mysql_database_engine/test.py\n@@ -396,7 +396,7 @@ def arryToString(expected_clickhouse_values):\n \n #  if expected_clickhouse_values is \"\", compare MySQL and ClickHouse query results directly\n @pytest.mark.parametrize(\n-    \"case_name, mysql_type, expected_ch_type, mysql_values, expected_clickhouse_values , setting_mysql_datatypes_support_level\",\n+    \"case_name, mysql_type, expected_ch_type, mysql_values, expected_clickhouse_values, setting_mysql_datatypes_support_level\",\n     [\n         pytest.param(\n             \"common_types\",\n@@ -725,11 +725,10 @@ def arryToString(expected_clickhouse_values):\n             \"decimal,datetime64\",\n             id=\"datetime_6_1\",\n         ),\n-        # right now precision bigger than 39 is not supported by ClickHouse's Decimal, hence fall back to String\n         pytest.param(\n             \"decimal_40_6\",\n             \"decimal(40, 6) NOT NULL\",\n-            \"String\",\n+            \"Decimal(40, 6)\",\n             decimal_values,\n             \"\",\n             \"decimal,datetime64\",\ndiff --git a/tests/queries/0_stateless/00700_decimal_aggregates.reference b/tests/queries/0_stateless/00700_decimal_aggregates.reference\nindex 159091d867ed..acf41546f5c4 100644\n--- a/tests/queries/0_stateless/00700_decimal_aggregates.reference\n+++ b/tests/queries/0_stateless/00700_decimal_aggregates.reference\n@@ -67,9 +67,9 @@\n [-50,-40,-30,-20,-10,0,10,20,30,40,50]\n [-16.66666666,-13.33333333,-10,-6.66666666,-3.33333333,0,3.33333333,6.66666666,10,13.33333333,16.66666666]\n [-10,-8,-6,-4,-2,0,2,4,6,8,10]\n-850\t94.44444438684269\t34\tFloat64\tFloat64\tFloat64\n+850\t94.4444443868427\t34.00000000000001\tFloat64\tFloat64\tFloat64\n 850\t94.4444443868427\t34.00000000000001\n-858.5\t95.38888883071111\t34.34\tFloat64\tFloat64\tFloat64\n+858.5\t95.38888883071112\t34.34\tFloat64\tFloat64\tFloat64\n 858.5\t95.38888883071112\t34.34\n 29.154759474226502\t9.718253155111915\t5.830951894845301\tFloat64\tFloat64\tFloat64\n 29.154759474226502\t9.718253155111915\t5.830951894845301\ndiff --git a/tests/queries/0_stateless/00700_decimal_empty_aggregates.reference b/tests/queries/0_stateless/00700_decimal_empty_aggregates.reference\nindex 2c29b72f50c8..20098e638d58 100644\n--- a/tests/queries/0_stateless/00700_decimal_empty_aggregates.reference\n+++ b/tests/queries/0_stateless/00700_decimal_empty_aggregates.reference\n@@ -45,11 +45,11 @@\n [0,0,0,0,0,0,0,0,0,0,0]\n [0,0,0,0,0,0,0,0,0,0,0]\n [0,0,0,0,0,0,0,0,0,0,0]\n-inf\tinf\tinf\tFloat64\tFloat64\tFloat64\n+nan\tnan\tnan\tFloat64\tFloat64\tFloat64\n nan\tnan\tnan\n nan\tnan\tnan\tFloat64\tFloat64\tFloat64\n nan\tnan\tnan\n-inf\tinf\tinf\tFloat64\tFloat64\tFloat64\n+nan\tnan\tnan\tFloat64\tFloat64\tFloat64\n nan\tnan\tnan\n nan\tnan\tnan\tFloat64\tFloat64\tFloat64\n nan\tnan\tnan\ndiff --git a/tests/queries/0_stateless/00862_decimal_in.reference b/tests/queries/0_stateless/00862_decimal_in.reference\nindex 0cd93f69c38b..f60b8081af4a 100644\n--- a/tests/queries/0_stateless/00862_decimal_in.reference\n+++ b/tests/queries/0_stateless/00862_decimal_in.reference\n@@ -16,3 +16,9 @@\n 64\t64\n 64\t64\n 64\t64\n+256\t256\n+256\t256\n+256\t256\n+256\t256\n+256\t256\n+256\t256\ndiff --git a/tests/queries/0_stateless/00862_decimal_in.sql b/tests/queries/0_stateless/00862_decimal_in.sql\nindex b5c058119a2d..3aa7bb18cb4f 100644\n--- a/tests/queries/0_stateless/00862_decimal_in.sql\n+++ b/tests/queries/0_stateless/00862_decimal_in.sql\n@@ -5,7 +5,7 @@ CREATE TABLE temp\n     y Nullable(Decimal(38, 2))\n ) ENGINE = Memory;\n \n-INSERT INTO temp VALUES (32, 32), (64, 64), (128, 128);\n+INSERT INTO temp VALUES (32, 32), (64, 64), (128, 128), (256, 256);\n \n SELECT * FROM temp WHERE x IN (toDecimal128(128, 1));\n SELECT * FROM temp WHERE x IN (toDecimal128(128, 2));\n@@ -28,7 +28,11 @@ SELECT * FROM temp WHERE y IN (toDecimal64(64, 1));\n SELECT * FROM temp WHERE y IN (toDecimal64(64, 2));\n SELECT * FROM temp WHERE y IN (toDecimal64(64, 3));\n \n-SELECT * FROM temp WHERE x IN (toDecimal256(256, 1)); -- { serverError 53 }\n-SELECT * FROM temp WHERE y IN (toDecimal256(256, 1)); -- { serverError 53 }\n+SELECT * FROM temp WHERE x IN (toDecimal256(256, 1));\n+SELECT * FROM temp WHERE x IN (toDecimal256(256, 2));\n+SELECT * FROM temp WHERE x IN (toDecimal256(256, 3));\n+SELECT * FROM temp WHERE y IN (toDecimal256(256, 1));\n+SELECT * FROM temp WHERE y IN (toDecimal256(256, 2));\n+SELECT * FROM temp WHERE y IN (toDecimal256(256, 3));\n \n DROP TABLE IF EXISTS temp;\ndiff --git a/tests/queries/0_stateless/01018_empty_aggregation_filling.reference b/tests/queries/0_stateless/01018_empty_aggregation_filling.reference\nindex c29807a7e15d..975b48c57f9e 100644\n--- a/tests/queries/0_stateless/01018_empty_aggregation_filling.reference\n+++ b/tests/queries/0_stateless/01018_empty_aggregation_filling.reference\n@@ -54,7 +54,7 @@ hello\n 2011-04-05 14:19:19\n -123.45\n -123.45\n-inf\n-inf\n+nan\n+nan\n -123.45\n -123.45\ndiff --git a/tests/queries/0_stateless/02421_decimal_in_precision_issue_41125.reference b/tests/queries/0_stateless/02421_decimal_in_precision_issue_41125.reference\nindex d3d171221e87..71c9a23879ff 100644\n--- a/tests/queries/0_stateless/02421_decimal_in_precision_issue_41125.reference\n+++ b/tests/queries/0_stateless/02421_decimal_in_precision_issue_41125.reference\n@@ -8,3 +8,6 @@\n 1\n 1\n 1\n+1\n+1\n+1\ndiff --git a/tests/queries/0_stateless/02421_decimal_in_precision_issue_41125.sql b/tests/queries/0_stateless/02421_decimal_in_precision_issue_41125.sql\nindex f5978a340618..f5d182be3e3c 100644\n--- a/tests/queries/0_stateless/02421_decimal_in_precision_issue_41125.sql\n+++ b/tests/queries/0_stateless/02421_decimal_in_precision_issue_41125.sql\n@@ -8,16 +8,16 @@ INSERT INTO dtest VALUES ('33', '44.4', '35');\n SELECT count() == 0 FROM dtest WHERE a IN toDecimal32('33.3000', 4);\n SELECT count() == 0 FROM dtest WHERE a IN toDecimal64('33.3000', 4);\n SELECT count() == 0 FROM dtest WHERE a IN toDecimal128('33.3000', 4);\n-SELECT count() == 0 FROM dtest WHERE a IN toDecimal256('33.3000', 4); -- { serverError 53 }\n+SELECT count() == 0 FROM dtest WHERE a IN toDecimal256('33.3000', 4);\n \n SELECT count() == 0 FROM dtest WHERE b IN toDecimal32('44.4000', 0);\n SELECT count() == 0 FROM dtest WHERE b IN toDecimal64('44.4000', 0);\n SELECT count() == 0 FROM dtest WHERE b IN toDecimal128('44.4000', 0);\n-SELECT count() == 0 FROM dtest WHERE b IN toDecimal256('44.4000', 0); -- { serverError 53 }\n+SELECT count() == 0 FROM dtest WHERE b IN toDecimal256('44.4000', 0);\n \n SELECT count() == 1 FROM dtest WHERE b IN toDecimal32('44.4000', 4);\n SELECT count() == 1 FROM dtest WHERE b IN toDecimal64('44.4000', 4);\n SELECT count() == 1 FROM dtest WHERE b IN toDecimal128('44.4000', 4);\n-SELECT count() == 1 FROM dtest WHERE b IN toDecimal256('44.4000', 4); -- { serverError 53 }\n+SELECT count() == 1 FROM dtest WHERE b IN toDecimal256('44.4000', 4);\n \n DROP TABLE IF EXISTS dtest;\ndiff --git a/tests/queries/0_stateless/02685_decimal256_various.reference b/tests/queries/0_stateless/02685_decimal256_various.reference\nnew file mode 100644\nindex 000000000000..848c5e0b163e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02685_decimal256_various.reference\n@@ -0,0 +1,97 @@\n+-- { echoOn }\n+\n+SELECT 1.1::Decimal(60, 30);\n+1.1\n+SELECT round(1.1::Decimal(60, 30));\n+1\n+SELECT round(1.1::Decimal(60, 30), 1);\n+1.1\n+SELECT round(1.234567890123456789012345678901::Decimal(60, 30), 1);\n+1.2\n+SELECT round(1.234567890123456789012345678901::Decimal(60, 30), 30);\n+1.234567890123456789012345678901\n+SELECT round(1.234567890123456789012345678901::Decimal(60, 30), 31);\n+1.234567890123456789012345678901\n+SELECT round(1.234567890123456789012345678901::Decimal(60, 30), 20);\n+1.23456789012345678901\n+SELECT hex(1.234567890123456789012345678901::Decimal(60, 30));\n+356C760E4FC986A2A39F1A950F00000000000000000000000000000000000000\n+SELECT bin(1.234567890123456789012345678901::Decimal(60, 30));\n+0011010101101100011101100000111001001111110010011000011010100010101000111001111100011010100101010000111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n+SELECT reinterpret(unhex(hex(1.234567890123456789012345678901::Decimal(60, 30))), 'Decimal(60, 30)');\n+1.234567890123456789012345678901\n+SELECT arraySum([1.2::Decimal(60, 30), 3.45::Decimal(61, 29)]);\n+4.65\n+SELECT arraySum([1.2::Decimal(60, 30), 3.45::Decimal(3, 2)]);\n+4.65\n+SELECT arrayMin([1.2::Decimal(60, 30), 3.45::Decimal(61, 29)]);\n+1.2\n+SELECT arrayMax([1.2::Decimal(60, 30), 3.45::Decimal(61, 29)]);\n+3.45\n+SELECT arrayAvg([1.2::Decimal(60, 30), 3.45::Decimal(61, 29)]);\n+2.325\n+SELECT round(arrayProduct([1.2::Decimal(60, 30), 3.45::Decimal(61, 29)]), 6);\n+4.14\n+SELECT toTypeName(arrayProduct([1.2::Decimal(60, 30), 3.45::Decimal(61, 29)]));\n+Float64\n+SELECT arrayCumSum([1.2::Decimal(60, 30), 3.45::Decimal(61, 29)]);\n+[1.2,4.65]\n+SELECT arrayCumSumNonNegative([1.2::Decimal(60, 30), 3.45::Decimal(61, 29)]);\n+[1.2,4.65]\n+SELECT arrayDifference([1.2::Decimal(60, 30), 3.45::Decimal(61, 29)]);\n+[0,2.25]\n+SELECT arrayCompact([1.2::Decimal(60, 30) AS x, x, x, x, 3.45::Decimal(3, 2) AS y, y, x, x]);\n+[1.2,3.45,1.2]\n+SELECT 1.2::Decimal(2, 1) IN (1.2::Decimal(60, 30), 3.4::Decimal(60, 30));\n+1\n+SELECT 1.23::Decimal(3, 2) IN (1.2::Decimal(60, 30), 3.4::Decimal(60, 30));\n+0\n+SELECT 1.2::Decimal(60, 30) IN (1.2::Decimal(2, 1));\n+1\n+SELECT toTypeName([1.2::Decimal(60, 30), 3.45::Decimal(3, 2)]);\n+Array(Decimal(76, 30))\n+SELECT toTypeName(arraySum([1.2::Decimal(60, 30), 3.45::Decimal(3, 2)]));\n+Decimal(76, 30)\n+SELECT arrayJoin(sumMap(x)) FROM (SELECT [('Hello', 1.2::Decimal256(30)), ('World', 3.4::Decimal256(30))]::Map(String, Decimal256(30)) AS x UNION ALL SELECT [('World', 5.6::Decimal256(30)), ('GoodBye', -111.222::Decimal256(30))]::Map(String, Decimal256(30))) ORDER BY 1;\n+('GoodBye',-111.222)\n+('Hello',1.2)\n+('World',9)\n+SELECT mapAdd(map('Hello', 1.2::Decimal128(30), 'World', 3.4::Decimal128(30)), map('World', 5.6::Decimal128(30), 'GoodBye', -111.222::Decimal128(30)));\n+{'GoodBye':-111.222,'Hello':1.2,'World':9}\n+SELECT mapSubtract(map('Hello', 1.2::Decimal128(30), 'World', 3.4::Decimal128(30)), map('World', 5.6::Decimal128(30), 'GoodBye', -111.222::Decimal128(30)));\n+{'GoodBye':111.222,'Hello':1.2,'World':-2.2}\n+SELECT arraySort(arrayIntersect([1, 2, 3]::Array(UInt256), [2, 3, 4]::Array(UInt256)));\n+[2,3]\n+SELECT toTypeName(arraySort(arrayIntersect([1, 2, 3]::Array(UInt256), [2, 3, 4]::Array(UInt128))));\n+Array(UInt128)\n+SELECT toTypeName(arraySort(arrayIntersect([1, 2, 3]::Array(UInt256), [2, 3, 4]::Array(Int128))));\n+Array(Int128)\n+SELECT arraySort(arrayIntersect([1, 2, 3]::Array(UInt256), [2, 3, 4]::Array(Int128)));\n+[2,3]\n+SELECT arraySort(arrayIntersect([1, 2, 3]::Array(UInt256), [2, 3, 4]::Array(Int8)));\n+[2,3]\n+SELECT toTypeName(arraySort(arrayIntersect([1, 2, 3]::Array(UInt256), [2, 3, 4]::Array(Int8))));\n+Array(Int8)\n+SELECT arraySort(arrayIntersect([1.1::Decimal256(70), 2.34::Decimal256(60), 3.456::Decimal256(50)], [2.34::Decimal256(65), 3.456::Decimal256(55), 4.5678::Decimal256(45)]));\n+[2.34,3.456]\n+SELECT arraySort(arrayIntersect([1.1::Decimal256(1)], [1.12::Decimal256(2)])); -- Note: this is correct but the semantics has to be clarified in the docs.\n+[1.1]\n+SELECT arraySort(arrayIntersect([1.1::Decimal256(2)], [1.12::Decimal256(2)]));\n+[]\n+SELECT arraySort(arrayIntersect([1.1::Decimal128(1)], [1.12::Decimal128(2)])); -- Note: this is correct but the semantics has to be clarified in the docs.\n+[1.1]\n+SELECT arraySort(arrayIntersect([1.1::Decimal128(2)], [1.12::Decimal128(2)]));\n+[]\n+select coalesce(cast('123', 'Nullable(Decimal(20, 10))'), 0);\n+123\n+select coalesce(cast('123', 'Nullable(Decimal(40, 10))'), 0);\n+123\n+select coalesce(cast('123', 'Decimal(40, 10)'), 0);\n+123\n+DROP TABLE IF EXISTS decimal_insert_cast_issue;\n+create table decimal_insert_cast_issue (a Decimal(76, 0)) engine = TinyLog;\n+SET param_param = 1;\n+INSERT INTO decimal_insert_cast_issue VALUES ({param:Nullable(Decimal(41, 0))});\n+SELECT * FROM decimal_insert_cast_issue;\n+1\n+DROP TABLE decimal_insert_cast_issue;\ndiff --git a/tests/queries/0_stateless/02685_decimal256_various.sql b/tests/queries/0_stateless/02685_decimal256_various.sql\nnew file mode 100644\nindex 000000000000..545eaefe35ef\n--- /dev/null\n+++ b/tests/queries/0_stateless/02685_decimal256_various.sql\n@@ -0,0 +1,65 @@\n+-- { echoOn }\n+\n+SELECT 1.1::Decimal(60, 30);\n+SELECT round(1.1::Decimal(60, 30));\n+SELECT round(1.1::Decimal(60, 30), 1);\n+SELECT round(1.234567890123456789012345678901::Decimal(60, 30), 1);\n+SELECT round(1.234567890123456789012345678901::Decimal(60, 30), 30);\n+SELECT round(1.234567890123456789012345678901::Decimal(60, 30), 31);\n+SELECT round(1.234567890123456789012345678901::Decimal(60, 30), 20);\n+\n+SELECT hex(1.234567890123456789012345678901::Decimal(60, 30));\n+SELECT bin(1.234567890123456789012345678901::Decimal(60, 30));\n+SELECT reinterpret(unhex(hex(1.234567890123456789012345678901::Decimal(60, 30))), 'Decimal(60, 30)');\n+\n+SELECT arraySum([1.2::Decimal(60, 30), 3.45::Decimal(61, 29)]);\n+SELECT arraySum([1.2::Decimal(60, 30), 3.45::Decimal(3, 2)]);\n+\n+SELECT arrayMin([1.2::Decimal(60, 30), 3.45::Decimal(61, 29)]);\n+SELECT arrayMax([1.2::Decimal(60, 30), 3.45::Decimal(61, 29)]);\n+SELECT arrayAvg([1.2::Decimal(60, 30), 3.45::Decimal(61, 29)]);\n+\n+SELECT round(arrayProduct([1.2::Decimal(60, 30), 3.45::Decimal(61, 29)]), 6);\n+SELECT toTypeName(arrayProduct([1.2::Decimal(60, 30), 3.45::Decimal(61, 29)]));\n+\n+SELECT arrayCumSum([1.2::Decimal(60, 30), 3.45::Decimal(61, 29)]);\n+SELECT arrayCumSumNonNegative([1.2::Decimal(60, 30), 3.45::Decimal(61, 29)]);\n+SELECT arrayDifference([1.2::Decimal(60, 30), 3.45::Decimal(61, 29)]);\n+\n+SELECT arrayCompact([1.2::Decimal(60, 30) AS x, x, x, x, 3.45::Decimal(3, 2) AS y, y, x, x]);\n+\n+SELECT 1.2::Decimal(2, 1) IN (1.2::Decimal(60, 30), 3.4::Decimal(60, 30));\n+SELECT 1.23::Decimal(3, 2) IN (1.2::Decimal(60, 30), 3.4::Decimal(60, 30));\n+SELECT 1.2::Decimal(60, 30) IN (1.2::Decimal(2, 1));\n+\n+SELECT toTypeName([1.2::Decimal(60, 30), 3.45::Decimal(3, 2)]);\n+SELECT toTypeName(arraySum([1.2::Decimal(60, 30), 3.45::Decimal(3, 2)]));\n+\n+SELECT arrayJoin(sumMap(x)) FROM (SELECT [('Hello', 1.2::Decimal256(30)), ('World', 3.4::Decimal256(30))]::Map(String, Decimal256(30)) AS x UNION ALL SELECT [('World', 5.6::Decimal256(30)), ('GoodBye', -111.222::Decimal256(30))]::Map(String, Decimal256(30))) ORDER BY 1;\n+\n+SELECT mapAdd(map('Hello', 1.2::Decimal128(30), 'World', 3.4::Decimal128(30)), map('World', 5.6::Decimal128(30), 'GoodBye', -111.222::Decimal128(30)));\n+SELECT mapSubtract(map('Hello', 1.2::Decimal128(30), 'World', 3.4::Decimal128(30)), map('World', 5.6::Decimal128(30), 'GoodBye', -111.222::Decimal128(30)));\n+\n+SELECT arraySort(arrayIntersect([1, 2, 3]::Array(UInt256), [2, 3, 4]::Array(UInt256)));\n+SELECT toTypeName(arraySort(arrayIntersect([1, 2, 3]::Array(UInt256), [2, 3, 4]::Array(UInt128))));\n+SELECT toTypeName(arraySort(arrayIntersect([1, 2, 3]::Array(UInt256), [2, 3, 4]::Array(Int128))));\n+SELECT arraySort(arrayIntersect([1, 2, 3]::Array(UInt256), [2, 3, 4]::Array(Int128)));\n+SELECT arraySort(arrayIntersect([1, 2, 3]::Array(UInt256), [2, 3, 4]::Array(Int8)));\n+SELECT toTypeName(arraySort(arrayIntersect([1, 2, 3]::Array(UInt256), [2, 3, 4]::Array(Int8))));\n+\n+SELECT arraySort(arrayIntersect([1.1::Decimal256(70), 2.34::Decimal256(60), 3.456::Decimal256(50)], [2.34::Decimal256(65), 3.456::Decimal256(55), 4.5678::Decimal256(45)]));\n+SELECT arraySort(arrayIntersect([1.1::Decimal256(1)], [1.12::Decimal256(2)])); -- Note: this is correct but the semantics has to be clarified in the docs.\n+SELECT arraySort(arrayIntersect([1.1::Decimal256(2)], [1.12::Decimal256(2)]));\n+SELECT arraySort(arrayIntersect([1.1::Decimal128(1)], [1.12::Decimal128(2)])); -- Note: this is correct but the semantics has to be clarified in the docs.\n+SELECT arraySort(arrayIntersect([1.1::Decimal128(2)], [1.12::Decimal128(2)]));\n+\n+select coalesce(cast('123', 'Nullable(Decimal(20, 10))'), 0);\n+select coalesce(cast('123', 'Nullable(Decimal(40, 10))'), 0);\n+select coalesce(cast('123', 'Decimal(40, 10)'), 0);\n+\n+DROP TABLE IF EXISTS decimal_insert_cast_issue;\n+create table decimal_insert_cast_issue (a Decimal(76, 0)) engine = TinyLog;\n+SET param_param = 1;\n+INSERT INTO decimal_insert_cast_issue VALUES ({param:Nullable(Decimal(41, 0))});\n+SELECT * FROM decimal_insert_cast_issue;\n+DROP TABLE decimal_insert_cast_issue;\ndiff --git a/tests/queries/0_stateless/02686_postgres_protocol_decimal_256.reference b/tests/queries/0_stateless/02686_postgres_protocol_decimal_256.reference\nnew file mode 100644\nindex 000000000000..5e61b14b9a16\n--- /dev/null\n+++ b/tests/queries/0_stateless/02686_postgres_protocol_decimal_256.reference\n@@ -0,0 +1,5 @@\n+ test \n+------\n+ 1.23\n+(1 row)\n+\ndiff --git a/tests/queries/0_stateless/02686_postgres_protocol_decimal_256.sh b/tests/queries/0_stateless/02686_postgres_protocol_decimal_256.sh\nnew file mode 100755\nindex 000000000000..2a94f9403270\n--- /dev/null\n+++ b/tests/queries/0_stateless/02686_postgres_protocol_decimal_256.sh\n@@ -0,0 +1,14 @@\n+#!/usr/bin/env bash\n+# Tags: no-parallel, no-fasttest\n+# Tag no-fasttest: needs psql\n+\n+CUR_DIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CUR_DIR\"/../shell_config.sh\n+\n+echo \"\n+DROP USER IF EXISTS postgresql_user;\n+CREATE USER postgresql_user HOST IP '127.0.0.1' IDENTIFIED WITH no_password;\n+\" | $CLICKHOUSE_CLIENT -n\n+\n+psql --host localhost --port ${CLICKHOUSE_PORT_POSTGRESQL} ${CLICKHOUSE_DATABASE} --user postgresql_user -c \"SELECT 1.23::Decimal256(70) AS test;\"\n",
  "problem_statement": "Type mismatch in IN or VALUES section. Expected: Decimal(76, 0). Got: Decimal256\n```\r\nclickhouse-client --query='create table decimal_insert_cast_issue ( a Decimal(76, 0)) engine = TinyLog'\r\n\r\nclickhouse-client --query='INSERT INTO decimal_insert_cast_issue VALUES ({param:Nullable(Decimal(41, 0))})' --param_param=1\r\nCode: 53. DB::Exception: Type mismatch in IN or VALUES section. Expected: Decimal(76, 0). Got: Decimal256: While processing _CAST('1', 'Nullable(Decimal(41, 0))'): While executing ValuesBlockInputFormat: data for INSERT was parsed from query. (TYPE_MISMATCH)\r\n```\nDecimal256 lacking support\nDecimal256 fields are poorly supported as of now.\r\nFor example, \r\n\r\n```sql\r\nwith [1,2]::Array(Decimal(40, 10)) as data\r\nselect arraySum(data)\r\n```\r\n\r\nFails with \r\n```\r\nReceived exception from server (version 23.2.4):\r\nCode: 44. DB::Exception: Received from localhost:9000. DB::Exception: Unexpected column for arraySum: Decimal256: While processing arraySum(CAST('[1,2]', 'Array(Decimal(40, 10))') AS data). (ILLEGAL_COLUMN)\r\n(query: with [1,2]::Array(Decimal(40, 10)) as data\r\nselect arraySum(data))\r\n```\r\n\r\nSee [fiddle](https://fiddle.clickhouse.com/a05c7e6c-f314-4e93-bd67-34a3522116ac)\r\n\r\nHowever, it should return 3.\r\nIf using Decimals with less precision, it works just fine.\r\n\r\n```sql\r\nwith [1,2]::Array(Decimal(30, 10)) as data\r\nselect arraySum(data)\r\n```\nInconsistent Nullable decimal128 and decimal256 behaviour\nWhen using Nullable Decimal256 data type, it's not considered a number (in many applications).\r\n\r\n**How to reproduce**\r\n\r\n```sql\r\nselect coalesce(cast('123', 'Nullable(Decimal(20, 10))'), 0)\r\n```\r\nThis works as expected and returns 123\r\n\r\n```sql\r\nselect coalesce(cast('123', 'Nullable(Decimal(40, 10))'), 0)\r\n```\r\nThis is expected to also return 123, but actually raises\r\n```\r\nDB::Exception: There is no supertype for types UInt8, Decimal256 because some of them \r\nare numbers and some of them are not: \r\nWhile processing coalesce(CAST('123', 'Nullable(Decimal(40, 10))'), 0). (NO_COMMON_TYPE) \r\n(version 22.11.1.1360 (official build))\r\n```\r\nStack trace below.\r\n\r\nInterestingly, with non-nullable Decimal256, this isn't an issue:\r\n\r\n```sql\r\nselect coalesce(cast('123', 'Decimal(40, 10)'), 0)\r\n```\r\nThis works just fine and returns 123 as expected\r\n\r\nClickhouse version:\r\n22.11.1.1360\r\n\r\nStack trace:\r\n\r\n```bash\r\n0. DB::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, int, bool) @ 0xda0553a in /usr/bin/clickhouse\r\n1. ? @ 0xc7dcba1 in /usr/bin/clickhouse\r\n2. ? @ 0x126c1c59 in /usr/bin/clickhouse\r\n3. ? @ 0x126c09cc in /usr/bin/clickhouse\r\n4. std::__1::shared_ptr<DB::IDataType const> DB::getLeastSupertype<(DB::LeastSupertypeOnError)0>(std::__1::vector<std::__1::shared_ptr<DB::IDataType const>, std::__1::allocator<std::__1::shared_ptr<DB::IDataType const>>> const&) @ 0x126bf94c in /usr/bin/clickhouse\r\n5. ? @ 0xa4c511f in /usr/bin/clickhouse\r\n6. ? @ 0x7daa89f in /usr/bin/clickhouse\r\n1. ? @ 0xc7dcba1 in /usr/bin/clickhouse\r\n2. ? @ 0x126c1c59 in /usr/bin/clickhouse\r\n3. ? @ 0x126c09cc in /usr/bin/clickhouse\r\n4. std::__1::shared_ptr<DB::IDataType const> DB::getLeastSupertype<(DB::LeastSupertypeOnError)0>(std::__1::vector<std::__1::shared_ptr<DB::IDataType const>, std::__1::allocator<std::__1::shared_ptr<DB::IDataType const>>> const&) @ 0x126bf94c in /usr/bin/clickhouse\r\n5. ? @ 0xa4c511f in /usr/bin/clickhouse\r\n6. ? @ 0x7daa89f in /usr/bin/clickhouse\r\n7. DB::IFunctionOverloadResolver::getReturnTypeWithoutLowCardinality(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName>> const&) const @ 0x1216bbd3 in /usr/bin/clickhouse\r\n8. DB::IFunctionOverloadResolver::getReturnType(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName>> const&) const @ 0x1216b81e in /usr/bin/clickhouse\r\n9. DB::IFunctionOverloadResolver::build(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName>> const&) const @ 0x1216c4f6 in /usr/bin/clickhouse\r\n10. DB::ActionsDAG::addFunction(std::__1::shared_ptr<DB::IFunctionOverloadResolver> const&, std::__1::vector<DB::ActionsDAG::Node const*, std::__1::allocator<DB::ActionsDAG::Node const*>>, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>) @ 0x12862af3 in /usr/bin/clickhouse\r\n11. DB::ScopeStack::addFunction(std::__1::shared_ptr<DB::IFunctionOverloadResolver> const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>> const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>) @ 0x12d41d3d in /usr/bin/clickhouse\r\n12. ? @ 0x12d4ca0f in /usr/bin/clickhouse\r\n13. DB::ActionsMatcher::visit(DB::ASTFunction const&, std::__1::shared_ptr<DB::IAST> const&, DB::ActionsMatcher::Data&) @ 0x12d4780d in /usr/bin/clickhouse\r\n14. DB::ActionsMatcher::visit(DB::ASTExpressionList&, std::__1::shared_ptr<DB::IAST> const&, DB::ActionsMatcher::Data&) @ 0x12d4ad98 in /usr/bin/clickhouse\r\n15. ? @ 0x12d277f5 in /usr/bin/clickhouse\r\n16. DB::ExpressionAnalyzer::getRootActions(std::__1::shared_ptr<DB::IAST> const&, bool, std::__1::shared_ptr<DB::ActionsDAG>&, bool) @ 0x12d088c3 in /usr/bin/clickhouse\r\n17. DB::SelectQueryExpressionAnalyzer::appendSelect(DB::ExpressionActionsChain&, bool) @ 0x12d17e65 in /usr/bin/clickhouse\r\n18. DB::ExpressionAnalysisResult::ExpressionAnalysisResult(DB::SelectQueryExpressionAnalyzer&, std::__1::shared_ptr<DB::StorageInMemoryMetadata const> const&, bool, bool, bool, std::__1::shared_ptr<DB::FilterDAGInfo> const&, std::__1::shared_ptr<DB::FilterDAGInfo> const&, DB::Block const&) @ 0x12d1ca2c in /usr/bin/clickhouse\r\n19. DB::InterpreterSelectQuery::getSampleBlockImpl() @ 0x132f9ba8 in /usr/bin/clickhouse\r\n20. ? @ 0x132f23f5 in /usr/bin/clickhouse\r\n21. DB::InterpreterSelectQuery::InterpreterSelectQuery(std::__1::shared_ptr<DB::IAST> const&, std::__1::shared_ptr<DB::Context> const&, std::__1::optional<DB::Pipe>, std::__1::shared_ptr<DB::IStorage> const&, DB::SelectQueryOptions const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>> const&, std::__1::shared_ptr<DB::StorageInMemoryMetadata const> const&, std::__1::shared_ptr<DB::PreparedSets>) @ 0x132ed209 in /usr/bin/clickhouse\r\n22. DB::InterpreterSelectWithUnionQuery::buildCurrentChildInterpreter(std::__1::shared_ptr<DB::IAST> const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>> const&) @ 0x13388a62 in /usr/bin/clickhouse\r\n23. DB::InterpreterSelectWithUnionQuery::InterpreterSelectWithUnionQuery(std::__1::shared_ptr<DB::IAST> const&, std::__1::shared_ptr<DB::Context>, DB::SelectQueryOptions const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>> const&) @ 0x13386202 in /usr/bin/clickhouse\r\n24. DB::InterpreterFactory::get(std::__1::shared_ptr<DB::IAST>&, std::__1::shared_ptr<DB::Context>, DB::SelectQueryOptions const&) @ 0x132ac85e in /usr/bin/clickhouse\r\n25. ? @ 0x13686060 in /usr/bin/clickhouse\r\n26. DB::executeQuery(DB::ReadBuffer&, DB::WriteBuffer&, bool, std::__1::shared_ptr<DB::Context>, std::__1::function<void (std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&)>, std::__1::optional<DB::FormatSettings> const&) @ 0x1368ae6b in /usr/bin/clickhouse\r\n27. DB::HTTPHandler::processQuery(DB::HTTPServerRequest&, DB::HTMLForm&, DB::HTTPServerResponse&, DB::HTTPHandler::Output&, std::__1::optional<DB::CurrentThread::QueryScope>&) @ 0x142a1af6 in /usr/bin/clickhouse\r\n28. DB::HTTPHandler::handleRequest(DB::HTTPServerRequest&, DB::HTTPServerResponse&) @ 0x142a5c2e in /usr/bin/clickhouse\r\n29. DB::HTTPServerConnection::run() @ 0x14321bb4 in /usr/bin/clickhouse\r\n30. Poco::Net::TCPServerConnection::start() @ 0x1714df54 in /usr/bin/clickhouse\r\n31. Poco::Net::TCPServerDispatcher::run() @ 0x1714f8fb in /usr/bin/clickhouse\r\n (version 22.11.1.1360 (official build))\r\n```\n",
  "hints_text": "\n\n",
  "created_at": "2023-03-14T21:21:39Z"
}