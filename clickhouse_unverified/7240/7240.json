{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 7240,
  "instance_id": "ClickHouse__ClickHouse-7240",
  "issue_numbers": [
    "7239"
  ],
  "base_commit": "e6b9f9c70b3e21b66097d529fca6435f68e6cad1",
  "patch": "diff --git a/dbms/programs/server/config.d/macros.xml b/dbms/programs/server/config.d/macros.xml\nnew file mode 100644\nindex 000000000000..1f86f5f9efdd\n--- /dev/null\n+++ b/dbms/programs/server/config.d/macros.xml\n@@ -0,0 +1,5 @@\n+<yandex>\n+    <macros>\n+        <test>Hello, world!</test>\n+    </macros>\n+</yandex>\ndiff --git a/dbms/src/Common/Macros.cpp b/dbms/src/Common/Macros.cpp\nindex 9198a72a69d9..ac64cc4ca463 100644\n--- a/dbms/src/Common/Macros.cpp\n+++ b/dbms/src/Common/Macros.cpp\n@@ -74,6 +74,13 @@ String Macros::expand(const String & s, size_t level, const String & database_na\n     return expand(res, level + 1, database_name, table_name);\n }\n \n+String Macros::getValue(const String & key) const\n+{\n+    if (auto it = macros.find(key); it != macros.end())\n+        return it->second;\n+    throw Exception(\"No macro \" + key + \" in config\", ErrorCodes::SYNTAX_ERROR);\n+}\n+\n String Macros::expand(const String & s, const String & database_name, const String & table_name) const\n {\n     return expand(s, 0, database_name, table_name);\ndiff --git a/dbms/src/Common/Macros.h b/dbms/src/Common/Macros.h\nindex 60a6bc18e4c6..c01038f9b6d7 100644\n--- a/dbms/src/Common/Macros.h\n+++ b/dbms/src/Common/Macros.h\n@@ -43,6 +43,8 @@ class Macros\n     using MacroMap = std::map<String, String>;\n     const MacroMap getMacroMap() const { return macros; }\n \n+    String getValue(const String & key) const;\n+\n private:\n     MacroMap macros;\n };\ndiff --git a/dbms/src/Functions/getMacro.cpp b/dbms/src/Functions/getMacro.cpp\nnew file mode 100644\nindex 000000000000..b3f933dc03f9\n--- /dev/null\n+++ b/dbms/src/Functions/getMacro.cpp\n@@ -0,0 +1,84 @@\n+#include <Functions/IFunction.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <DataTypes/DataTypeString.h>\n+#include <Columns/ColumnString.h>\n+#include <Interpreters/Context.h>\n+#include <Common/Macros.h>\n+#include <Core/Field.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int ILLEGAL_COLUMN;\n+}\n+\n+/** Get the value of macro from configuration file.\n+  * For example, it may be used as a sophisticated replacement for the function 'hostName' if servers have complicated hostnames\n+  *  but you still need to distinguish them by some convenient names.\n+  */\n+class FunctionGetMacro : public IFunction\n+{\n+private:\n+    MultiVersion<Macros>::Version macros;\n+\n+public:\n+    static constexpr auto name = \"getMacro\";\n+    static FunctionPtr create(const Context & context)\n+    {\n+        return std::make_shared<FunctionGetMacro>(context.getMacros());\n+    }\n+\n+    FunctionGetMacro(MultiVersion<Macros>::Version macros_) : macros(std::move(macros_)) {}\n+\n+    String getName() const override\n+    {\n+        return name;\n+    }\n+\n+    bool isDeterministic() const override { return false; }\n+\n+    bool isDeterministicInScopeOfQuery() const override\n+    {\n+        return false;\n+    }\n+\n+    size_t getNumberOfArguments() const override\n+    {\n+        return 1;\n+    }\n+\n+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    {\n+        if (!isString(arguments[0]))\n+            throw Exception(\"The argument of function \" + getName() + \" must have String type\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+        return std::make_shared<DataTypeString>();\n+    }\n+\n+    /** convertToFullColumn needed because in distributed query processing,\n+      *    each server returns its own value.\n+      */\n+    void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t input_rows_count) override\n+    {\n+        const IColumn * arg_column = block.getByPosition(arguments[0]).column.get();\n+        const ColumnString * arg_string = checkAndGetColumnConstData<ColumnString>(arg_column);\n+\n+        if (!arg_string)\n+            throw Exception(\"The argument of function \" + getName() + \" must be constant String\", ErrorCodes::ILLEGAL_COLUMN);\n+\n+        block.getByPosition(result).column = block.getByPosition(result).type->createColumnConst(\n+            input_rows_count, macros->getValue(arg_string->getDataAt(0).toString()))->convertToFullColumnIfConst();\n+    }\n+};\n+\n+\n+void registerFunctionGetMacro(FunctionFactory & factory)\n+{\n+    factory.registerFunction<FunctionGetMacro>();\n+}\n+\n+}\ndiff --git a/dbms/src/Functions/registerFunctionsMiscellaneous.cpp b/dbms/src/Functions/registerFunctionsMiscellaneous.cpp\nindex 1d95844ce9bf..418bd093e321 100644\n--- a/dbms/src/Functions/registerFunctionsMiscellaneous.cpp\n+++ b/dbms/src/Functions/registerFunctionsMiscellaneous.cpp\n@@ -50,6 +50,7 @@ void registerFunctionFilesystem(FunctionFactory &);\n void registerFunctionEvalMLMethod(FunctionFactory &);\n void registerFunctionBasename(FunctionFactory &);\n void registerFunctionTransform(FunctionFactory &);\n+void registerFunctionGetMacro(FunctionFactory &);\n \n #if USE_ICU\n void registerFunctionConvertCharset(FunctionFactory &);\n@@ -102,6 +103,7 @@ void registerFunctionsMiscellaneous(FunctionFactory & factory)\n     registerFunctionEvalMLMethod(factory);\n     registerFunctionBasename(factory);\n     registerFunctionTransform(factory);\n+    registerFunctionGetMacro(factory);\n \n #if USE_ICU\n     registerFunctionConvertCharset(factory);\n",
  "test_patch": "diff --git a/dbms/tests/config/macros.xml b/dbms/tests/config/macros.xml\nnew file mode 100644\nindex 000000000000..1f86f5f9efdd\n--- /dev/null\n+++ b/dbms/tests/config/macros.xml\n@@ -0,0 +1,5 @@\n+<yandex>\n+    <macros>\n+        <test>Hello, world!</test>\n+    </macros>\n+</yandex>\ndiff --git a/dbms/tests/queries/0_stateless/01016_macros.reference b/dbms/tests/queries/0_stateless/01016_macros.reference\nnew file mode 100644\nindex 000000000000..6ca8ba9557b3\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01016_macros.reference\n@@ -0,0 +1,2 @@\n+test\tHello, world!\n+Hello, world!\ndiff --git a/dbms/tests/queries/0_stateless/01016_macros.sql b/dbms/tests/queries/0_stateless/01016_macros.sql\nnew file mode 100644\nindex 000000000000..be00b7094cb5\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01016_macros.sql\n@@ -0,0 +1,2 @@\n+SELECT * FROM system.macros WHERE macro = 'test';\n+SELECT getMacro('test');\n",
  "problem_statement": "Add miscellaneous function `getMacro`\n**Use case**\r\n`getMacro(name)` - returns String with the value of corresponding `<macro>` on current server where the function is executed.\r\n\r\nThis function is ordered by Yandex Banner System for filtering duplicate data on distributed queries during cluster resharding.\n",
  "hints_text": "",
  "created_at": "2019-10-09T01:20:20Z"
}