{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 32862,
  "instance_id": "ClickHouse__ClickHouse-32862",
  "issue_numbers": [
    "31419"
  ],
  "base_commit": "9270b63b8dbc30ab33a4eda67e89f777e6a4b202",
  "patch": "diff --git a/src/Processors/Sinks/SinkToStorage.cpp b/src/Processors/Sinks/SinkToStorage.cpp\nindex 9ec0939f3a83..5f9f9f9b1a1a 100644\n--- a/src/Processors/Sinks/SinkToStorage.cpp\n+++ b/src/Processors/Sinks/SinkToStorage.cpp\n@@ -6,7 +6,7 @@ namespace DB\n \n SinkToStorage::SinkToStorage(const Block & header) : ExceptionKeepingTransform(header, header, false) {}\n \n-void SinkToStorage::transform(Chunk & chunk)\n+void SinkToStorage::onConsume(Chunk chunk)\n {\n     /** Throw an exception if the sizes of arrays - elements of nested data structures doesn't match.\n       * We have to make this assertion before writing to table, because storage engine may assume that they have equal sizes.\n@@ -16,8 +16,16 @@ void SinkToStorage::transform(Chunk & chunk)\n     Nested::validateArraySizes(getHeader().cloneWithColumns(chunk.getColumns()));\n \n     consume(chunk.clone());\n-    if (lastBlockIsDuplicate())\n-        chunk.clear();\n+    if (!lastBlockIsDuplicate())\n+        cur_chunk = std::move(chunk);\n+}\n+\n+SinkToStorage::GenerateResult SinkToStorage::onGenerate()\n+{\n+    GenerateResult res;\n+    res.chunk = std::move(cur_chunk);\n+    res.is_done = true;\n+    return res;\n }\n \n }\ndiff --git a/src/Processors/Sinks/SinkToStorage.h b/src/Processors/Sinks/SinkToStorage.h\nindex 01d51940d64d..023bbd8b0949 100644\n--- a/src/Processors/Sinks/SinkToStorage.h\n+++ b/src/Processors/Sinks/SinkToStorage.h\n@@ -24,7 +24,10 @@ friend class PartitionedSink;\n private:\n     std::vector<TableLockHolder> table_locks;\n \n-    void transform(Chunk & chunk) override;\n+    void onConsume(Chunk chunk) override;\n+    GenerateResult onGenerate() override;\n+\n+    Chunk cur_chunk;\n };\n \n using SinkToStoragePtr = std::shared_ptr<SinkToStorage>;\ndiff --git a/src/Processors/Transforms/CheckConstraintsTransform.cpp b/src/Processors/Transforms/CheckConstraintsTransform.cpp\nindex b7849b8a627a..50ec86f33b6f 100644\n--- a/src/Processors/Transforms/CheckConstraintsTransform.cpp\n+++ b/src/Processors/Transforms/CheckConstraintsTransform.cpp\n@@ -35,7 +35,7 @@ CheckConstraintsTransform::CheckConstraintsTransform(\n }\n \n \n-void CheckConstraintsTransform::transform(Chunk & chunk)\n+void CheckConstraintsTransform::onConsume(Chunk chunk)\n {\n     if (chunk.getNumRows() > 0)\n     {\n@@ -123,6 +123,7 @@ void CheckConstraintsTransform::transform(Chunk & chunk)\n     }\n \n     rows_written += chunk.getNumRows();\n+    cur_chunk = std::move(chunk);\n }\n \n }\ndiff --git a/src/Processors/Transforms/CheckConstraintsTransform.h b/src/Processors/Transforms/CheckConstraintsTransform.h\nindex 3198ec84198b..09833ff396be 100644\n--- a/src/Processors/Transforms/CheckConstraintsTransform.h\n+++ b/src/Processors/Transforms/CheckConstraintsTransform.h\n@@ -23,12 +23,19 @@ class CheckConstraintsTransform final : public ExceptionKeepingTransform\n \n     String getName() const override { return \"CheckConstraintsTransform\"; }\n \n-    void transform(Chunk & chunk) override;\n+    void onConsume(Chunk chunk) override;\n+    GenerateResult onGenerate() override\n+    {\n+        GenerateResult res;\n+        res.chunk = std::move(cur_chunk);\n+        return res;\n+    }\n \n private:\n     StorageID table_id;\n     const ASTs constraints_to_check;\n     const ConstraintsExpressions expressions;\n     size_t rows_written = 0;\n+    Chunk cur_chunk;\n };\n }\ndiff --git a/src/Processors/Transforms/CountingTransform.cpp b/src/Processors/Transforms/CountingTransform.cpp\nindex 88ecbe6adc3b..79b6360f22e5 100644\n--- a/src/Processors/Transforms/CountingTransform.cpp\n+++ b/src/Processors/Transforms/CountingTransform.cpp\n@@ -16,7 +16,7 @@ namespace ProfileEvents\n namespace DB\n {\n \n-void CountingTransform::transform(Chunk & chunk)\n+void CountingTransform::onConsume(Chunk chunk)\n {\n     Progress local_progress(chunk.getNumRows(), chunk.bytes(), 0);\n     progress.incrementPiecewiseAtomically(local_progress);\n@@ -39,6 +39,8 @@ void CountingTransform::transform(Chunk & chunk)\n \n     if (progress_callback)\n         progress_callback(local_progress);\n+\n+    cur_chunk = std::move(chunk);\n }\n \n }\ndiff --git a/src/Processors/Transforms/CountingTransform.h b/src/Processors/Transforms/CountingTransform.h\nindex e7100e8510ba..877f6a0a5432 100644\n--- a/src/Processors/Transforms/CountingTransform.h\n+++ b/src/Processors/Transforms/CountingTransform.h\n@@ -34,13 +34,20 @@ class CountingTransform final : public ExceptionKeepingTransform\n         return progress;\n     }\n \n-    void transform(Chunk & chunk) override;\n+    void onConsume(Chunk chunk) override;\n+    GenerateResult onGenerate() override\n+    {\n+        GenerateResult res;\n+        res.chunk = std::move(cur_chunk);\n+        return res;\n+    }\n \n protected:\n     Progress progress;\n     ProgressCallback progress_callback;\n     QueryStatus * process_elem = nullptr;\n     ThreadStatus * thread_status = nullptr;\n+    Chunk cur_chunk;\n };\n \n }\ndiff --git a/src/Processors/Transforms/ExceptionKeepingTransform.cpp b/src/Processors/Transforms/ExceptionKeepingTransform.cpp\nindex 5c968471e1ba..f2b29a45f840 100644\n--- a/src/Processors/Transforms/ExceptionKeepingTransform.cpp\n+++ b/src/Processors/Transforms/ExceptionKeepingTransform.cpp\n@@ -21,8 +21,13 @@ ExceptionKeepingTransform::ExceptionKeepingTransform(const Block & in_header, co\n \n IProcessor::Status ExceptionKeepingTransform::prepare()\n {\n-    if (!ignore_on_start_and_finish && !was_on_start_called)\n-        return Status::Ready;\n+    if (stage == Stage::Start)\n+    {\n+        if (ignore_on_start_and_finish)\n+            stage = Stage::Consume;\n+        else\n+            return Status::Ready;\n+    }\n \n     /// Check can output.\n \n@@ -43,12 +48,19 @@ IProcessor::Status ExceptionKeepingTransform::prepare()\n         return Status::PortFull;\n     }\n \n-    if (!ready_input)\n+    if (stage == Stage::Generate)\n+        return Status::Ready;\n+\n+    while (!ready_input)\n     {\n         if (input.isFinished())\n         {\n-            if (!ignore_on_start_and_finish && !was_on_finish_called && !has_exception)\n-                return Status::Ready;\n+            if (stage != Stage::Exception && stage != Stage::Finish)\n+            {\n+                stage = Stage::Finish;\n+                if (!ignore_on_start_and_finish)\n+                    return Status::Ready;\n+            }\n \n             output.finish();\n             return Status::Finished;\n@@ -63,12 +75,13 @@ IProcessor::Status ExceptionKeepingTransform::prepare()\n \n         if (data.exception)\n         {\n-            has_exception = true;\n+            stage = Stage::Exception;\n+            onException();\n             output.pushData(std::move(data));\n             return Status::PortFull;\n         }\n \n-        if (has_exception)\n+        if (stage == Stage::Exception)\n             /// In case of exception, just drop all other data.\n             /// If transform is stateful, it's state may be broken after exception from transform()\n             data.chunk.clear();\n@@ -117,40 +130,66 @@ static std::exception_ptr runStep(std::function<void()> step, ThreadStatus * thr\n \n void ExceptionKeepingTransform::work()\n {\n-    if (!ignore_on_start_and_finish && !was_on_start_called)\n+    if (stage == Stage::Start)\n     {\n-        was_on_start_called = true;\n+        stage = Stage::Consume;\n \n         if (auto exception = runStep([this] { onStart(); }, thread_status, elapsed_counter_ms))\n         {\n-            has_exception = true;\n+            stage = Stage::Exception;\n             ready_output = true;\n             data.exception = std::move(exception);\n+            onException();\n         }\n     }\n-    else if (ready_input)\n+    else if (stage == Stage::Consume || stage == Stage::Generate)\n     {\n-        ready_input = false;\n-\n-        if (auto exception = runStep([this] { transform(data.chunk); }, thread_status, elapsed_counter_ms))\n+        if (stage == Stage::Consume)\n         {\n-            has_exception = true;\n-            data.chunk.clear();\n-            data.exception = std::move(exception);\n+            ready_input = false;\n+\n+            if (auto exception = runStep([this] { onConsume(std::move(data.chunk)); }, thread_status, elapsed_counter_ms))\n+            {\n+                stage = Stage::Exception;\n+                ready_output = true;\n+                data.exception = std::move(exception);\n+                onException();\n+            }\n+            else\n+                stage = Stage::Generate;\n         }\n \n-        if (data.chunk || data.exception)\n-            ready_output = true;\n+        if (stage == Stage::Generate)\n+        {\n+            GenerateResult res;\n+            if (auto exception = runStep([this, &res] { res = onGenerate(); }, thread_status, elapsed_counter_ms))\n+            {\n+                stage = Stage::Exception;\n+                ready_output = true;\n+                data.exception = std::move(exception);\n+                onException();\n+            }\n+            else\n+            {\n+                if (res.chunk)\n+                {\n+                    data.chunk = std::move(res.chunk);\n+                    ready_output = true;\n+                }\n+\n+                if (res.is_done)\n+                    stage = Stage::Consume;\n+            }\n+        }\n     }\n-    else if (!ignore_on_start_and_finish && !was_on_finish_called)\n+    else if (stage == Stage::Finish)\n     {\n-        was_on_finish_called = true;\n-\n         if (auto exception = runStep([this] { onFinish(); }, thread_status, elapsed_counter_ms))\n         {\n-            has_exception = true;\n+            stage = Stage::Exception;\n             ready_output = true;\n             data.exception = std::move(exception);\n+            onException();\n         }\n     }\n }\ndiff --git a/src/Processors/Transforms/ExceptionKeepingTransform.h b/src/Processors/Transforms/ExceptionKeepingTransform.h\nindex 867f13bf53ae..e2bc161971ef 100644\n--- a/src/Processors/Transforms/ExceptionKeepingTransform.h\n+++ b/src/Processors/Transforms/ExceptionKeepingTransform.h\n@@ -28,18 +28,31 @@ class ExceptionKeepingTransform : public IProcessor\n     OutputPort & output;\n     Port::Data data;\n \n+    enum class Stage\n+    {\n+        Start,\n+        Consume,\n+        Generate,\n+        Finish,\n+        Exception,\n+    };\n+\n+    Stage stage = Stage::Start;\n     bool ready_input = false;\n     bool ready_output = false;\n-    bool has_exception = false;\n-\n     const bool ignore_on_start_and_finish = true;\n-    bool was_on_start_called = false;\n-    bool was_on_finish_called = false;\n \n-//protected:\n-    virtual void transform(Chunk & chunk) = 0;\n+    struct GenerateResult\n+    {\n+        Chunk chunk;\n+        bool is_done = true;\n+    };\n+\n     virtual void onStart() {}\n+    virtual void onConsume(Chunk chunk) = 0;\n+    virtual GenerateResult onGenerate() = 0;\n     virtual void onFinish() {}\n+    virtual void onException() {}\n \n public:\n     ExceptionKeepingTransform(const Block & in_header, const Block & out_header, bool ignore_on_start_and_finish_ = true);\ndiff --git a/src/Processors/Transforms/ExpressionTransform.cpp b/src/Processors/Transforms/ExpressionTransform.cpp\nindex ca788f1dd9f8..0d3341b000c9 100644\n--- a/src/Processors/Transforms/ExpressionTransform.cpp\n+++ b/src/Processors/Transforms/ExpressionTransform.cpp\n@@ -31,7 +31,7 @@ ConvertingTransform::ConvertingTransform(const Block & header_, ExpressionAction\n {\n }\n \n-void ConvertingTransform::transform(Chunk & chunk)\n+void ConvertingTransform::onConsume(Chunk chunk)\n {\n     size_t num_rows = chunk.getNumRows();\n     auto block = getInputPort().getHeader().cloneWithColumns(chunk.detachColumns());\n@@ -39,6 +39,7 @@ void ConvertingTransform::transform(Chunk & chunk)\n     expression->execute(block, num_rows);\n \n     chunk.setColumns(block.getColumns(), num_rows);\n+    cur_chunk = std::move(chunk);\n }\n \n }\ndiff --git a/src/Processors/Transforms/ExpressionTransform.h b/src/Processors/Transforms/ExpressionTransform.h\nindex a76dc733e142..ea73c8fb1da4 100644\n--- a/src/Processors/Transforms/ExpressionTransform.h\n+++ b/src/Processors/Transforms/ExpressionTransform.h\n@@ -43,10 +43,17 @@ class ConvertingTransform final : public ExceptionKeepingTransform\n     String getName() const override { return \"ConvertingTransform\"; }\n \n protected:\n-    void transform(Chunk & chunk) override;\n+    void onConsume(Chunk chunk) override;\n+    GenerateResult onGenerate() override\n+    {\n+        GenerateResult res;\n+        res.chunk = std::move(cur_chunk);\n+        return res;\n+    }\n \n private:\n     ExpressionActionsPtr expression;\n+    Chunk cur_chunk;\n };\n \n }\ndiff --git a/src/Processors/Transforms/SquashingChunksTransform.cpp b/src/Processors/Transforms/SquashingChunksTransform.cpp\nindex f5aef01463a8..908f6c0ff345 100644\n--- a/src/Processors/Transforms/SquashingChunksTransform.cpp\n+++ b/src/Processors/Transforms/SquashingChunksTransform.cpp\n@@ -11,14 +11,22 @@ SquashingChunksTransform::SquashingChunksTransform(\n {\n }\n \n-void SquashingChunksTransform::transform(Chunk & chunk)\n+void SquashingChunksTransform::onConsume(Chunk chunk)\n {\n     if (auto block = squashing.add(getInputPort().getHeader().cloneWithColumns(chunk.detachColumns())))\n     {\n-        chunk.setColumns(block.getColumns(), block.rows());\n+        cur_chunk.setColumns(block.getColumns(), block.rows());\n     }\n }\n \n+SquashingChunksTransform::GenerateResult SquashingChunksTransform::onGenerate()\n+{\n+    GenerateResult res;\n+    res.chunk = std::move(cur_chunk);\n+    res.is_done = true;\n+    return res;\n+}\n+\n void SquashingChunksTransform::onFinish()\n {\n     auto block = squashing.add({});\n@@ -27,7 +35,7 @@ void SquashingChunksTransform::onFinish()\n \n void SquashingChunksTransform::work()\n {\n-    if (has_exception)\n+    if (stage == Stage::Exception)\n     {\n         data.chunk.clear();\n         ready_input = false;\ndiff --git a/src/Processors/Transforms/SquashingChunksTransform.h b/src/Processors/Transforms/SquashingChunksTransform.h\nindex bf4a051891be..531efe0d6a2f 100644\n--- a/src/Processors/Transforms/SquashingChunksTransform.h\n+++ b/src/Processors/Transforms/SquashingChunksTransform.h\n@@ -17,12 +17,14 @@ class SquashingChunksTransform : public ExceptionKeepingTransform\n     void work() override;\n \n protected:\n-    void transform(Chunk & chunk) override;\n+    void onConsume(Chunk chunk) override;\n+    GenerateResult onGenerate() override;\n     void onFinish() override;\n \n \n private:\n     SquashingTransform squashing;\n+    Chunk cur_chunk;\n     Chunk finish_chunk;\n };\n \ndiff --git a/src/Processors/Transforms/buildPushingToViewsChain.cpp b/src/Processors/Transforms/buildPushingToViewsChain.cpp\nindex 503f34593c71..82c2a337a451 100644\n--- a/src/Processors/Transforms/buildPushingToViewsChain.cpp\n+++ b/src/Processors/Transforms/buildPushingToViewsChain.cpp\n@@ -83,11 +83,26 @@ class ExecutingInnerQueryFromViewTransform final : public ExceptionKeepingTransf\n     String getName() const override { return \"ExecutingInnerQueryFromView\"; }\n \n protected:\n-    void transform(Chunk & chunk) override;\n+    void onConsume(Chunk chunk) override;\n+    GenerateResult onGenerate() override;\n \n private:\n     ViewsDataPtr views_data;\n     ViewRuntimeData & view;\n+\n+    struct State\n+    {\n+        QueryPipeline pipeline;\n+        PullingPipelineExecutor executor;\n+\n+        explicit State(QueryPipeline pipeline_)\n+            : pipeline(std::move(pipeline_))\n+            , executor(pipeline)\n+        {\n+        }\n+    };\n+\n+    std::optional<State> state;\n };\n \n /// Insert into LiveView.\n@@ -389,7 +404,7 @@ Chain buildPushingToViewsChain(\n     return result_chain;\n }\n \n-static void process(Block & block, ViewRuntimeData & view, const ViewsData & views_data)\n+static QueryPipeline process(Block block, ViewRuntimeData & view, const ViewsData & views_data)\n {\n     const auto & context = views_data.context;\n \n@@ -400,7 +415,7 @@ static void process(Block & block, ViewRuntimeData & view, const ViewsData & vie\n     local_context->addViewSource(StorageValues::create(\n         views_data.source_storage_id,\n         views_data.source_metadata_snapshot->getColumns(),\n-        block,\n+        std::move(block),\n         views_data.source_storage->getVirtuals()));\n \n     /// We need keep InterpreterSelectQuery, until the processing will be finished, since:\n@@ -443,16 +458,7 @@ static void process(Block & block, ViewRuntimeData & view, const ViewsData & vie\n             callback(progress);\n     });\n \n-    auto query_pipeline = QueryPipelineBuilder::getPipeline(std::move(pipeline));\n-    PullingPipelineExecutor executor(query_pipeline);\n-    if (!executor.pull(block))\n-    {\n-        block.clear();\n-        return;\n-    }\n-\n-    if (executor.pull(block))\n-        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Single chunk is expected from view inner query {}\", view.query);\n+    return QueryPipelineBuilder::getPipeline(std::move(pipeline));\n }\n \n static void logQueryViews(std::list<ViewRuntimeData> & views, ContextPtr context)\n@@ -550,14 +556,33 @@ ExecutingInnerQueryFromViewTransform::ExecutingInnerQueryFromViewTransform(\n {\n }\n \n-void ExecutingInnerQueryFromViewTransform::transform(Chunk & chunk)\n+void ExecutingInnerQueryFromViewTransform::onConsume(Chunk chunk)\n {\n     auto block = getInputPort().getHeader().cloneWithColumns(chunk.getColumns());\n-    process(block, view, *views_data);\n-    chunk.setColumns(block.getColumns(), block.rows());\n+    state.emplace(process(block, view, *views_data));\n }\n \n \n+ExecutingInnerQueryFromViewTransform::GenerateResult ExecutingInnerQueryFromViewTransform::onGenerate()\n+{\n+    GenerateResult res;\n+    if (!state.has_value())\n+        return res;\n+\n+    res.is_done = false;\n+    while (!res.is_done)\n+    {\n+        res.is_done = !state->executor.pull(res.chunk);\n+        if (res.chunk)\n+            break;\n+    }\n+\n+    if (res.is_done)\n+        state.reset();\n+\n+    return res;\n+}\n+\n PushingToLiveViewSink::PushingToLiveViewSink(const Block & header, StorageLiveView & live_view_, StoragePtr storage_holder_, ContextPtr context_)\n     : SinkToStorage(header)\n     , live_view(live_view_)\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02131_mv_many_chunks_bug.reference b/tests/queries/0_stateless/02131_mv_many_chunks_bug.reference\nnew file mode 100644\nindex 000000000000..9183bf03fcca\n--- /dev/null\n+++ b/tests/queries/0_stateless/02131_mv_many_chunks_bug.reference\n@@ -0,0 +1,1 @@\n+256\ndiff --git a/tests/queries/0_stateless/02131_mv_many_chunks_bug.sql b/tests/queries/0_stateless/02131_mv_many_chunks_bug.sql\nnew file mode 100644\nindex 000000000000..736fd9242b04\n--- /dev/null\n+++ b/tests/queries/0_stateless/02131_mv_many_chunks_bug.sql\n@@ -0,0 +1,15 @@\n+drop table if exists t;\n+drop table if exists t_mv;\n+\n+create table t (x UInt64) engine = MergeTree order by x;\n+create materialized view t_mv engine = MergeTree order by tuple() as select uniq(x), bitAnd(x, 255) as y from t group by y;\n+\n+set max_bytes_before_external_group_by = 1000000000;\n+set group_by_two_level_threshold = 100;\n+set min_insert_block_size_rows = 100;\n+\n+insert into t select number from numbers(300);\n+select count() from (select y from t_mv group by y);\n+\n+drop table if exists t;\n+drop table if exists t_mv;\n",
  "problem_statement": "\"Single chunk is expected from view inner query\" error in Materialized View since 21.11 update\nHello, \r\n\r\nMy team and I were using ClickHouse 21.9 for 2 months, and we updated this weekend to 21.11.3.6, in order to fix the DivisionByZero bug with Decimal.\r\n\r\nAlmost everything is working properly after the update, except one existing MaterializedView which is throwing the following error when it is triggered: \r\n`Single chunk is expected from view inner query (LOGICAL_ERROR)`\r\nThis MV was working for 1 year, so we're a bit confused.\r\nI'm going to try to reproduce the bug in a simple example, but I can already say our MV contains a GROUP BY clause.\n",
  "hints_text": "",
  "created_at": "2021-12-16T18:15:38Z",
  "modified_files": [
    "src/Processors/Sinks/SinkToStorage.cpp",
    "src/Processors/Sinks/SinkToStorage.h",
    "src/Processors/Transforms/CheckConstraintsTransform.cpp",
    "src/Processors/Transforms/CheckConstraintsTransform.h",
    "src/Processors/Transforms/CountingTransform.cpp",
    "src/Processors/Transforms/CountingTransform.h",
    "src/Processors/Transforms/ExceptionKeepingTransform.cpp",
    "src/Processors/Transforms/ExceptionKeepingTransform.h",
    "src/Processors/Transforms/ExpressionTransform.cpp",
    "src/Processors/Transforms/ExpressionTransform.h",
    "src/Processors/Transforms/SquashingChunksTransform.cpp",
    "src/Processors/Transforms/SquashingChunksTransform.h",
    "src/Processors/Transforms/buildPushingToViewsChain.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02131_mv_many_chunks_bug.reference",
    "b/tests/queries/0_stateless/02131_mv_many_chunks_bug.sql"
  ]
}