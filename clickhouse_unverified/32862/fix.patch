diff --git a/src/Processors/Sinks/SinkToStorage.cpp b/src/Processors/Sinks/SinkToStorage.cpp
index 9ec0939f3a83..5f9f9f9b1a1a 100644
--- a/src/Processors/Sinks/SinkToStorage.cpp
+++ b/src/Processors/Sinks/SinkToStorage.cpp
@@ -6,7 +6,7 @@ namespace DB
 
 SinkToStorage::SinkToStorage(const Block & header) : ExceptionKeepingTransform(header, header, false) {}
 
-void SinkToStorage::transform(Chunk & chunk)
+void SinkToStorage::onConsume(Chunk chunk)
 {
     /** Throw an exception if the sizes of arrays - elements of nested data structures doesn't match.
       * We have to make this assertion before writing to table, because storage engine may assume that they have equal sizes.
@@ -16,8 +16,16 @@ void SinkToStorage::transform(Chunk & chunk)
     Nested::validateArraySizes(getHeader().cloneWithColumns(chunk.getColumns()));
 
     consume(chunk.clone());
-    if (lastBlockIsDuplicate())
-        chunk.clear();
+    if (!lastBlockIsDuplicate())
+        cur_chunk = std::move(chunk);
+}
+
+SinkToStorage::GenerateResult SinkToStorage::onGenerate()
+{
+    GenerateResult res;
+    res.chunk = std::move(cur_chunk);
+    res.is_done = true;
+    return res;
 }
 
 }
diff --git a/src/Processors/Sinks/SinkToStorage.h b/src/Processors/Sinks/SinkToStorage.h
index 01d51940d64d..023bbd8b0949 100644
--- a/src/Processors/Sinks/SinkToStorage.h
+++ b/src/Processors/Sinks/SinkToStorage.h
@@ -24,7 +24,10 @@ friend class PartitionedSink;
 private:
     std::vector<TableLockHolder> table_locks;
 
-    void transform(Chunk & chunk) override;
+    void onConsume(Chunk chunk) override;
+    GenerateResult onGenerate() override;
+
+    Chunk cur_chunk;
 };
 
 using SinkToStoragePtr = std::shared_ptr<SinkToStorage>;
diff --git a/src/Processors/Transforms/CheckConstraintsTransform.cpp b/src/Processors/Transforms/CheckConstraintsTransform.cpp
index b7849b8a627a..50ec86f33b6f 100644
--- a/src/Processors/Transforms/CheckConstraintsTransform.cpp
+++ b/src/Processors/Transforms/CheckConstraintsTransform.cpp
@@ -35,7 +35,7 @@ CheckConstraintsTransform::CheckConstraintsTransform(
 }
 
 
-void CheckConstraintsTransform::transform(Chunk & chunk)
+void CheckConstraintsTransform::onConsume(Chunk chunk)
 {
     if (chunk.getNumRows() > 0)
     {
@@ -123,6 +123,7 @@ void CheckConstraintsTransform::transform(Chunk & chunk)
     }
 
     rows_written += chunk.getNumRows();
+    cur_chunk = std::move(chunk);
 }
 
 }
diff --git a/src/Processors/Transforms/CheckConstraintsTransform.h b/src/Processors/Transforms/CheckConstraintsTransform.h
index 3198ec84198b..09833ff396be 100644
--- a/src/Processors/Transforms/CheckConstraintsTransform.h
+++ b/src/Processors/Transforms/CheckConstraintsTransform.h
@@ -23,12 +23,19 @@ class CheckConstraintsTransform final : public ExceptionKeepingTransform
 
     String getName() const override { return "CheckConstraintsTransform"; }
 
-    void transform(Chunk & chunk) override;
+    void onConsume(Chunk chunk) override;
+    GenerateResult onGenerate() override
+    {
+        GenerateResult res;
+        res.chunk = std::move(cur_chunk);
+        return res;
+    }
 
 private:
     StorageID table_id;
     const ASTs constraints_to_check;
     const ConstraintsExpressions expressions;
     size_t rows_written = 0;
+    Chunk cur_chunk;
 };
 }
diff --git a/src/Processors/Transforms/CountingTransform.cpp b/src/Processors/Transforms/CountingTransform.cpp
index 88ecbe6adc3b..79b6360f22e5 100644
--- a/src/Processors/Transforms/CountingTransform.cpp
+++ b/src/Processors/Transforms/CountingTransform.cpp
@@ -16,7 +16,7 @@ namespace ProfileEvents
 namespace DB
 {
 
-void CountingTransform::transform(Chunk & chunk)
+void CountingTransform::onConsume(Chunk chunk)
 {
     Progress local_progress(chunk.getNumRows(), chunk.bytes(), 0);
     progress.incrementPiecewiseAtomically(local_progress);
@@ -39,6 +39,8 @@ void CountingTransform::transform(Chunk & chunk)
 
     if (progress_callback)
         progress_callback(local_progress);
+
+    cur_chunk = std::move(chunk);
 }
 
 }
diff --git a/src/Processors/Transforms/CountingTransform.h b/src/Processors/Transforms/CountingTransform.h
index e7100e8510ba..877f6a0a5432 100644
--- a/src/Processors/Transforms/CountingTransform.h
+++ b/src/Processors/Transforms/CountingTransform.h
@@ -34,13 +34,20 @@ class CountingTransform final : public ExceptionKeepingTransform
         return progress;
     }
 
-    void transform(Chunk & chunk) override;
+    void onConsume(Chunk chunk) override;
+    GenerateResult onGenerate() override
+    {
+        GenerateResult res;
+        res.chunk = std::move(cur_chunk);
+        return res;
+    }
 
 protected:
     Progress progress;
     ProgressCallback progress_callback;
     QueryStatus * process_elem = nullptr;
     ThreadStatus * thread_status = nullptr;
+    Chunk cur_chunk;
 };
 
 }
diff --git a/src/Processors/Transforms/ExceptionKeepingTransform.cpp b/src/Processors/Transforms/ExceptionKeepingTransform.cpp
index 5c968471e1ba..f2b29a45f840 100644
--- a/src/Processors/Transforms/ExceptionKeepingTransform.cpp
+++ b/src/Processors/Transforms/ExceptionKeepingTransform.cpp
@@ -21,8 +21,13 @@ ExceptionKeepingTransform::ExceptionKeepingTransform(const Block & in_header, co
 
 IProcessor::Status ExceptionKeepingTransform::prepare()
 {
-    if (!ignore_on_start_and_finish && !was_on_start_called)
-        return Status::Ready;
+    if (stage == Stage::Start)
+    {
+        if (ignore_on_start_and_finish)
+            stage = Stage::Consume;
+        else
+            return Status::Ready;
+    }
 
     /// Check can output.
 
@@ -43,12 +48,19 @@ IProcessor::Status ExceptionKeepingTransform::prepare()
         return Status::PortFull;
     }
 
-    if (!ready_input)
+    if (stage == Stage::Generate)
+        return Status::Ready;
+
+    while (!ready_input)
     {
         if (input.isFinished())
         {
-            if (!ignore_on_start_and_finish && !was_on_finish_called && !has_exception)
-                return Status::Ready;
+            if (stage != Stage::Exception && stage != Stage::Finish)
+            {
+                stage = Stage::Finish;
+                if (!ignore_on_start_and_finish)
+                    return Status::Ready;
+            }
 
             output.finish();
             return Status::Finished;
@@ -63,12 +75,13 @@ IProcessor::Status ExceptionKeepingTransform::prepare()
 
         if (data.exception)
         {
-            has_exception = true;
+            stage = Stage::Exception;
+            onException();
             output.pushData(std::move(data));
             return Status::PortFull;
         }
 
-        if (has_exception)
+        if (stage == Stage::Exception)
             /// In case of exception, just drop all other data.
             /// If transform is stateful, it's state may be broken after exception from transform()
             data.chunk.clear();
@@ -117,40 +130,66 @@ static std::exception_ptr runStep(std::function<void()> step, ThreadStatus * thr
 
 void ExceptionKeepingTransform::work()
 {
-    if (!ignore_on_start_and_finish && !was_on_start_called)
+    if (stage == Stage::Start)
     {
-        was_on_start_called = true;
+        stage = Stage::Consume;
 
         if (auto exception = runStep([this] { onStart(); }, thread_status, elapsed_counter_ms))
         {
-            has_exception = true;
+            stage = Stage::Exception;
             ready_output = true;
             data.exception = std::move(exception);
+            onException();
         }
     }
-    else if (ready_input)
+    else if (stage == Stage::Consume || stage == Stage::Generate)
     {
-        ready_input = false;
-
-        if (auto exception = runStep([this] { transform(data.chunk); }, thread_status, elapsed_counter_ms))
+        if (stage == Stage::Consume)
         {
-            has_exception = true;
-            data.chunk.clear();
-            data.exception = std::move(exception);
+            ready_input = false;
+
+            if (auto exception = runStep([this] { onConsume(std::move(data.chunk)); }, thread_status, elapsed_counter_ms))
+            {
+                stage = Stage::Exception;
+                ready_output = true;
+                data.exception = std::move(exception);
+                onException();
+            }
+            else
+                stage = Stage::Generate;
         }
 
-        if (data.chunk || data.exception)
-            ready_output = true;
+        if (stage == Stage::Generate)
+        {
+            GenerateResult res;
+            if (auto exception = runStep([this, &res] { res = onGenerate(); }, thread_status, elapsed_counter_ms))
+            {
+                stage = Stage::Exception;
+                ready_output = true;
+                data.exception = std::move(exception);
+                onException();
+            }
+            else
+            {
+                if (res.chunk)
+                {
+                    data.chunk = std::move(res.chunk);
+                    ready_output = true;
+                }
+
+                if (res.is_done)
+                    stage = Stage::Consume;
+            }
+        }
     }
-    else if (!ignore_on_start_and_finish && !was_on_finish_called)
+    else if (stage == Stage::Finish)
     {
-        was_on_finish_called = true;
-
         if (auto exception = runStep([this] { onFinish(); }, thread_status, elapsed_counter_ms))
         {
-            has_exception = true;
+            stage = Stage::Exception;
             ready_output = true;
             data.exception = std::move(exception);
+            onException();
         }
     }
 }
diff --git a/src/Processors/Transforms/ExceptionKeepingTransform.h b/src/Processors/Transforms/ExceptionKeepingTransform.h
index 867f13bf53ae..e2bc161971ef 100644
--- a/src/Processors/Transforms/ExceptionKeepingTransform.h
+++ b/src/Processors/Transforms/ExceptionKeepingTransform.h
@@ -28,18 +28,31 @@ class ExceptionKeepingTransform : public IProcessor
     OutputPort & output;
     Port::Data data;
 
+    enum class Stage
+    {
+        Start,
+        Consume,
+        Generate,
+        Finish,
+        Exception,
+    };
+
+    Stage stage = Stage::Start;
     bool ready_input = false;
     bool ready_output = false;
-    bool has_exception = false;
-
     const bool ignore_on_start_and_finish = true;
-    bool was_on_start_called = false;
-    bool was_on_finish_called = false;
 
-//protected:
-    virtual void transform(Chunk & chunk) = 0;
+    struct GenerateResult
+    {
+        Chunk chunk;
+        bool is_done = true;
+    };
+
     virtual void onStart() {}
+    virtual void onConsume(Chunk chunk) = 0;
+    virtual GenerateResult onGenerate() = 0;
     virtual void onFinish() {}
+    virtual void onException() {}
 
 public:
     ExceptionKeepingTransform(const Block & in_header, const Block & out_header, bool ignore_on_start_and_finish_ = true);
diff --git a/src/Processors/Transforms/ExpressionTransform.cpp b/src/Processors/Transforms/ExpressionTransform.cpp
index ca788f1dd9f8..0d3341b000c9 100644
--- a/src/Processors/Transforms/ExpressionTransform.cpp
+++ b/src/Processors/Transforms/ExpressionTransform.cpp
@@ -31,7 +31,7 @@ ConvertingTransform::ConvertingTransform(const Block & header_, ExpressionAction
 {
 }
 
-void ConvertingTransform::transform(Chunk & chunk)
+void ConvertingTransform::onConsume(Chunk chunk)
 {
     size_t num_rows = chunk.getNumRows();
     auto block = getInputPort().getHeader().cloneWithColumns(chunk.detachColumns());
@@ -39,6 +39,7 @@ void ConvertingTransform::transform(Chunk & chunk)
     expression->execute(block, num_rows);
 
     chunk.setColumns(block.getColumns(), num_rows);
+    cur_chunk = std::move(chunk);
 }
 
 }
diff --git a/src/Processors/Transforms/ExpressionTransform.h b/src/Processors/Transforms/ExpressionTransform.h
index a76dc733e142..ea73c8fb1da4 100644
--- a/src/Processors/Transforms/ExpressionTransform.h
+++ b/src/Processors/Transforms/ExpressionTransform.h
@@ -43,10 +43,17 @@ class ConvertingTransform final : public ExceptionKeepingTransform
     String getName() const override { return "ConvertingTransform"; }
 
 protected:
-    void transform(Chunk & chunk) override;
+    void onConsume(Chunk chunk) override;
+    GenerateResult onGenerate() override
+    {
+        GenerateResult res;
+        res.chunk = std::move(cur_chunk);
+        return res;
+    }
 
 private:
     ExpressionActionsPtr expression;
+    Chunk cur_chunk;
 };
 
 }
diff --git a/src/Processors/Transforms/SquashingChunksTransform.cpp b/src/Processors/Transforms/SquashingChunksTransform.cpp
index f5aef01463a8..908f6c0ff345 100644
--- a/src/Processors/Transforms/SquashingChunksTransform.cpp
+++ b/src/Processors/Transforms/SquashingChunksTransform.cpp
@@ -11,14 +11,22 @@ SquashingChunksTransform::SquashingChunksTransform(
 {
 }
 
-void SquashingChunksTransform::transform(Chunk & chunk)
+void SquashingChunksTransform::onConsume(Chunk chunk)
 {
     if (auto block = squashing.add(getInputPort().getHeader().cloneWithColumns(chunk.detachColumns())))
     {
-        chunk.setColumns(block.getColumns(), block.rows());
+        cur_chunk.setColumns(block.getColumns(), block.rows());
     }
 }
 
+SquashingChunksTransform::GenerateResult SquashingChunksTransform::onGenerate()
+{
+    GenerateResult res;
+    res.chunk = std::move(cur_chunk);
+    res.is_done = true;
+    return res;
+}
+
 void SquashingChunksTransform::onFinish()
 {
     auto block = squashing.add({});
@@ -27,7 +35,7 @@ void SquashingChunksTransform::onFinish()
 
 void SquashingChunksTransform::work()
 {
-    if (has_exception)
+    if (stage == Stage::Exception)
     {
         data.chunk.clear();
         ready_input = false;
diff --git a/src/Processors/Transforms/SquashingChunksTransform.h b/src/Processors/Transforms/SquashingChunksTransform.h
index bf4a051891be..531efe0d6a2f 100644
--- a/src/Processors/Transforms/SquashingChunksTransform.h
+++ b/src/Processors/Transforms/SquashingChunksTransform.h
@@ -17,12 +17,14 @@ class SquashingChunksTransform : public ExceptionKeepingTransform
     void work() override;
 
 protected:
-    void transform(Chunk & chunk) override;
+    void onConsume(Chunk chunk) override;
+    GenerateResult onGenerate() override;
     void onFinish() override;
 
 
 private:
     SquashingTransform squashing;
+    Chunk cur_chunk;
     Chunk finish_chunk;
 };
 
diff --git a/src/Processors/Transforms/buildPushingToViewsChain.cpp b/src/Processors/Transforms/buildPushingToViewsChain.cpp
index 503f34593c71..82c2a337a451 100644
--- a/src/Processors/Transforms/buildPushingToViewsChain.cpp
+++ b/src/Processors/Transforms/buildPushingToViewsChain.cpp
@@ -83,11 +83,26 @@ class ExecutingInnerQueryFromViewTransform final : public ExceptionKeepingTransf
     String getName() const override { return "ExecutingInnerQueryFromView"; }
 
 protected:
-    void transform(Chunk & chunk) override;
+    void onConsume(Chunk chunk) override;
+    GenerateResult onGenerate() override;
 
 private:
     ViewsDataPtr views_data;
     ViewRuntimeData & view;
+
+    struct State
+    {
+        QueryPipeline pipeline;
+        PullingPipelineExecutor executor;
+
+        explicit State(QueryPipeline pipeline_)
+            : pipeline(std::move(pipeline_))
+            , executor(pipeline)
+        {
+        }
+    };
+
+    std::optional<State> state;
 };
 
 /// Insert into LiveView.
@@ -389,7 +404,7 @@ Chain buildPushingToViewsChain(
     return result_chain;
 }
 
-static void process(Block & block, ViewRuntimeData & view, const ViewsData & views_data)
+static QueryPipeline process(Block block, ViewRuntimeData & view, const ViewsData & views_data)
 {
     const auto & context = views_data.context;
 
@@ -400,7 +415,7 @@ static void process(Block & block, ViewRuntimeData & view, const ViewsData & vie
     local_context->addViewSource(StorageValues::create(
         views_data.source_storage_id,
         views_data.source_metadata_snapshot->getColumns(),
-        block,
+        std::move(block),
         views_data.source_storage->getVirtuals()));
 
     /// We need keep InterpreterSelectQuery, until the processing will be finished, since:
@@ -443,16 +458,7 @@ static void process(Block & block, ViewRuntimeData & view, const ViewsData & vie
             callback(progress);
     });
 
-    auto query_pipeline = QueryPipelineBuilder::getPipeline(std::move(pipeline));
-    PullingPipelineExecutor executor(query_pipeline);
-    if (!executor.pull(block))
-    {
-        block.clear();
-        return;
-    }
-
-    if (executor.pull(block))
-        throw Exception(ErrorCodes::LOGICAL_ERROR, "Single chunk is expected from view inner query {}", view.query);
+    return QueryPipelineBuilder::getPipeline(std::move(pipeline));
 }
 
 static void logQueryViews(std::list<ViewRuntimeData> & views, ContextPtr context)
@@ -550,14 +556,33 @@ ExecutingInnerQueryFromViewTransform::ExecutingInnerQueryFromViewTransform(
 {
 }
 
-void ExecutingInnerQueryFromViewTransform::transform(Chunk & chunk)
+void ExecutingInnerQueryFromViewTransform::onConsume(Chunk chunk)
 {
     auto block = getInputPort().getHeader().cloneWithColumns(chunk.getColumns());
-    process(block, view, *views_data);
-    chunk.setColumns(block.getColumns(), block.rows());
+    state.emplace(process(block, view, *views_data));
 }
 
 
+ExecutingInnerQueryFromViewTransform::GenerateResult ExecutingInnerQueryFromViewTransform::onGenerate()
+{
+    GenerateResult res;
+    if (!state.has_value())
+        return res;
+
+    res.is_done = false;
+    while (!res.is_done)
+    {
+        res.is_done = !state->executor.pull(res.chunk);
+        if (res.chunk)
+            break;
+    }
+
+    if (res.is_done)
+        state.reset();
+
+    return res;
+}
+
 PushingToLiveViewSink::PushingToLiveViewSink(const Block & header, StorageLiveView & live_view_, StoragePtr storage_holder_, ContextPtr context_)
     : SinkToStorage(header)
     , live_view(live_view_)
