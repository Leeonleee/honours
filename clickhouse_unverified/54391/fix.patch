diff --git a/docs/en/sql-reference/functions/array-functions.md b/docs/en/sql-reference/functions/array-functions.md
index 59af1b909caa..03cf1d9fa745 100644
--- a/docs/en/sql-reference/functions/array-functions.md
+++ b/docs/en/sql-reference/functions/array-functions.md
@@ -2118,6 +2118,80 @@ Result:
 └─────────────────────┘
 ```
 
+
+## arrayRandomSample
+
+Function `arrayRandomSample` returns a subset with `samples`-many random elements of an input array. If `samples` exceeds the size of the input array, the sample size is limited to the size of the array. In this case, all elements of the input array are returned, but the order is not guaranteed. The function can handle both flat arrays and nested arrays.
+
+**Syntax**
+
+```sql
+arrayRandomSample(arr, samples)
+```
+
+**Arguments**
+
+- `arr` — The input array from which to sample elements. This may be flat or nested arrays.
+- `samples` — An unsigned integer specifying the number of elements to include in the random sample.
+
+**Returned Value**
+
+- An array containing a random sample of elements from the input array.
+
+**Examples**
+
+Query:
+
+```sql
+SELECT arrayRandomSample(['apple', 'banana', 'cherry', 'date'], 2) as res;
+```
+
+Result:
+```
+┌─res────────────────┐
+│ ['banana','apple'] │
+└────────────────────┘
+```
+
+Query:
+
+```sql
+SELECT arrayRandomSample([[1, 2], [3, 4], [5, 6]], 2) as res;
+```
+
+Result:
+```
+┌─res───────────┐
+│ [[3,4],[5,6]] │
+└───────────────┘
+```
+
+Query:
+
+```sql
+SELECT arrayRandomSample([1, 2, 3, 4, 5], 0) as res;
+```
+
+Result:
+```
+┌─res─┐
+│ []  │
+└─────┘
+```
+
+Query:
+
+```sql
+SELECT arrayRandomSample([1, 2, 3], 5) as res;
+```
+
+Result:
+```
+┌─res─────┐
+│ [3,1,2] │
+└─────────┘
+```
+
 ## Distance functions
 
 All supported functions are described in [distance functions documentation](../../sql-reference/functions/distance-functions.md).
diff --git a/src/Functions/array/arrayRandomSample.cpp b/src/Functions/array/arrayRandomSample.cpp
new file mode 100644
index 000000000000..908ca9fa30a3
--- /dev/null
+++ b/src/Functions/array/arrayRandomSample.cpp
@@ -0,0 +1,118 @@
+#include <random>
+#include <Columns/ColumnArray.h>
+#include <DataTypes/DataTypeArray.h>
+#include <Functions/FunctionFactory.h>
+#include <Functions/FunctionHelpers.h>
+#include <Functions/IFunction.h>
+#include <Poco/Logger.h>
+#include "Columns/ColumnsNumber.h"
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int ILLEGAL_COLUMN;
+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
+}
+
+/// arrayRandomSample(arr, k) - Returns k random elements from the input array
+class FunctionArrayRandomSample : public IFunction
+{
+public:
+    static constexpr auto name = "arrayRandomSample";
+
+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionArrayRandomSample>(); }
+
+    String getName() const override { return name; }
+
+    size_t getNumberOfArguments() const override { return 2; }
+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }
+    bool useDefaultImplementationForConstants() const override { return true; }
+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
+
+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
+    {
+        FunctionArgumentDescriptors args{
+            {"array", &isArray<IDataType>, nullptr, "Array"},
+            {"samples", &isUnsignedInteger<IDataType>, isColumnConst, "const UInt*"},
+        };
+        validateFunctionArgumentTypes(*this, arguments, args);
+
+        // Return an array with the same nested type as the input array
+        const DataTypePtr & array_type = arguments[0].type;
+        const DataTypeArray * array_data_type = checkAndGetDataType<DataTypeArray>(array_type.get());
+
+        // Get the nested data type of the array
+        const DataTypePtr & nested_type = array_data_type->getNestedType();
+
+        return std::make_shared<DataTypeArray>(nested_type);
+    }
+
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override
+    {
+        const ColumnArray * column_array = checkAndGetColumn<ColumnArray>(arguments[0].column.get());
+        if (!column_array)
+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "First argument must be an array");
+
+        const IColumn * col_samples = arguments[1].column.get();
+        if (!col_samples)
+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "The second argument is empty or null, type = {}", arguments[1].type->getName());
+
+        UInt64 samples;
+        try
+        {
+            samples = col_samples->getUInt(0);
+        }
+        catch (...)
+        {
+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                "Failed to fetch UInt64 from the second argument column, type = {}",
+                arguments[1].type->getName());
+        }
+
+        std::random_device rd;
+        std::mt19937 gen(rd());
+
+        auto nested_column = column_array->getDataPtr()->cloneEmpty();
+        auto offsets_column = ColumnUInt64::create();
+
+        auto res_data = ColumnArray::create(std::move(nested_column), std::move(offsets_column));
+
+        const auto & input_offsets = column_array->getOffsets();
+        auto & res_offsets = res_data->getOffsets();
+        res_offsets.resize(input_rows_count);
+
+        UInt64 cur_samples;
+        size_t current_offset = 0;
+
+        for (size_t row = 0; row < input_rows_count; row++)
+        {
+            size_t row_size = input_offsets[row] - current_offset;
+
+            std::vector<size_t> indices(row_size);
+            std::iota(indices.begin(), indices.end(), 0);
+            std::shuffle(indices.begin(), indices.end(), gen);
+
+            cur_samples = std::min(samples, static_cast<UInt64>(row_size));
+
+            for (UInt64 j = 0; j < cur_samples; j++)
+            {
+                size_t source_index = indices[j];
+                res_data->getData().insertFrom(column_array->getData(), source_index);
+            }
+
+            res_offsets[row] = current_offset + cur_samples;
+            current_offset += cur_samples;
+        }
+
+        return res_data;
+    }
+};
+
+REGISTER_FUNCTION(ArrayRandomSample)
+{
+    factory.registerFunction<FunctionArrayRandomSample>();
+}
+
+}
diff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt
index 23d7e2876d51..a668e54d8156 100644
--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt
+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt
@@ -1061,6 +1061,7 @@ arrayPopFront
 arrayProduct
 arrayPushBack
 arrayPushFront
+arrayRandomSample
 arrayReduce
 arrayReduceInRanges
 arrayResize
