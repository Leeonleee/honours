{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 39112,
  "instance_id": "ClickHouse__ClickHouse-39112",
  "issue_numbers": [
    "38538"
  ],
  "base_commit": "c25a08222cc0e40cdfc0f1df2880edc18affca76",
  "patch": "diff --git a/src/Interpreters/ActionsVisitor.cpp b/src/Interpreters/ActionsVisitor.cpp\nindex e25a6260787e..b62690b7a3a3 100644\n--- a/src/Interpreters/ActionsVisitor.cpp\n+++ b/src/Interpreters/ActionsVisitor.cpp\n@@ -963,40 +963,24 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &\n         // Don't need to do anything more for window functions here -- the\n         // resulting column is added in ExpressionAnalyzer, similar to the\n         // aggregate functions.\n-        if (data.window_dependancy_state == WindowDependancyState::MAY_DEPEND)\n-            data.window_function_in_subtree = true;\n         return;\n     }\n     else if (node.compute_after_window_functions)\n     {\n-        // In this case we have window function call in subtree\n-        // Add this function to actions index only if Data::build_expression_with_window_functions is set.\n-        data.window_dependancy_state = WindowDependancyState::MAY_DEPEND;\n-        for (const auto & arg : node.arguments->children)\n-        {\n-            data.window_function_in_subtree = false;\n-            visit(arg, data);\n-            // There is no point to check value of window_function_in_subtree here,\n-            // because after window functions are computed, this variable is always false.\n-        }\n-        data.window_dependancy_state = WindowDependancyState::NONE;\n         if (!data.build_expression_with_window_functions)\n-            return;\n-    }\n-    else if (data.window_dependancy_state == WindowDependancyState::MAY_DEPEND)\n-    {\n-        // This function may depend on evaluation of window function.\n-        // We need to check it and add it to the index only if Data::build_expression_with_window_functions is set.\n-        bool subtree_contains_window_call = false;\n-        for (const auto & arg : node.arguments->children)\n         {\n-            data.window_function_in_subtree = false;\n-            visit(arg, data);\n-            subtree_contains_window_call = subtree_contains_window_call || data.window_function_in_subtree;\n-        }\n-        data.window_function_in_subtree = subtree_contains_window_call;\n-        if (subtree_contains_window_call && !data.build_expression_with_window_functions)\n+            for (const auto & arg : node.arguments->children)\n+            {\n+                if (auto const * function = arg->as<ASTFunction>();\n+                    function && function->name == \"lambda\")\n+                {\n+                    // Lambda function is a special case. It shouldn't be visited here.\n+                    continue;\n+                }\n+                visit(arg, data);\n+            }\n             return;\n+        }\n     }\n \n     // An aggregate function can also be calculated as a window function, but we\ndiff --git a/src/Interpreters/ActionsVisitor.h b/src/Interpreters/ActionsVisitor.h\nindex afdf2948d473..5b5a3d31da28 100644\n--- a/src/Interpreters/ActionsVisitor.h\n+++ b/src/Interpreters/ActionsVisitor.h\n@@ -121,12 +121,6 @@ class ActionsMatcher\n public:\n     using Visitor = ConstInDepthNodeVisitor<ActionsMatcher, true>;\n \n-    enum class WindowDependancyState\n-    {\n-        NONE,\n-        MAY_DEPEND,\n-    };\n-\n     struct Data : public WithContext\n     {\n         SizeLimits set_size_limit;\n@@ -150,9 +144,6 @@ class ActionsMatcher\n          */\n         int next_unique_suffix;\n \n-        WindowDependancyState window_dependancy_state = WindowDependancyState::NONE;\n-        bool window_function_in_subtree = false;\n-\n         Data(\n             ContextPtr context_,\n             SizeLimits set_size_limit_,\ndiff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp\nindex b79dc9c80e91..483ffad67b72 100644\n--- a/src/Interpreters/ExpressionAnalyzer.cpp\n+++ b/src/Interpreters/ExpressionAnalyzer.cpp\n@@ -1497,6 +1497,25 @@ void SelectQueryExpressionAnalyzer::appendExpressionsAfterWindowFunctions(Expres\n     }\n }\n \n+void SelectQueryExpressionAnalyzer::appendSelectSkipWindowExpressions(ExpressionActionsChain::Step & step, ASTPtr const & node)\n+{\n+    if (auto * function = node->as<ASTFunction>())\n+    {\n+        // Skip window function columns here -- they are calculated after\n+        // other SELECT expressions by a special step.\n+        // Also skipping lambda functions because they can't be explicitly evaluated.\n+        if (function->is_window_function || function->name == \"lambda\")\n+            return;\n+        if (function->compute_after_window_functions)\n+        {\n+            for (auto & arg : function->arguments->children)\n+                appendSelectSkipWindowExpressions(step, arg);\n+            return;\n+        }\n+    }\n+    step.addRequiredOutput(node->getColumnName());\n+}\n+\n bool SelectQueryExpressionAnalyzer::appendHaving(ExpressionActionsChain & chain, bool only_types)\n {\n     const auto * select_query = getAggregatingQuery();\n@@ -1521,18 +1540,7 @@ void SelectQueryExpressionAnalyzer::appendSelect(ExpressionActionsChain & chain,\n     getRootActions(select_query->select(), only_types, step.actions());\n \n     for (const auto & child : select_query->select()->children)\n-    {\n-        if (const auto * function = typeid_cast<const ASTFunction *>(child.get());\n-            function\n-            && (function->is_window_function || function->compute_after_window_functions))\n-        {\n-            // Skip window function columns here -- they are calculated after\n-            // other SELECT expressions by a special step.\n-            continue;\n-        }\n-\n-        step.addRequiredOutput(child->getColumnName());\n-    }\n+        appendSelectSkipWindowExpressions(step, child);\n }\n \n ActionsDAGPtr SelectQueryExpressionAnalyzer::appendOrderBy(ExpressionActionsChain & chain, bool only_types, bool optimize_read_in_order,\ndiff --git a/src/Interpreters/ExpressionAnalyzer.h b/src/Interpreters/ExpressionAnalyzer.h\nindex 167c3dfd918d..aae45482a977 100644\n--- a/src/Interpreters/ExpressionAnalyzer.h\n+++ b/src/Interpreters/ExpressionAnalyzer.h\n@@ -410,6 +410,7 @@ class SelectQueryExpressionAnalyzer : public ExpressionAnalyzer\n     void appendWindowFunctionsArguments(ExpressionActionsChain & chain, bool only_types);\n \n     void appendExpressionsAfterWindowFunctions(ExpressionActionsChain & chain, bool only_types);\n+    void appendSelectSkipWindowExpressions(ExpressionActionsChain::Step & step, ASTPtr const & node);\n \n     /// After aggregation:\n     bool appendHaving(ExpressionActionsChain & chain, bool only_types);\ndiff --git a/src/Interpreters/GetAggregatesVisitor.cpp b/src/Interpreters/GetAggregatesVisitor.cpp\nindex a9d96a6d15a4..dd958693d899 100644\n--- a/src/Interpreters/GetAggregatesVisitor.cpp\n+++ b/src/Interpreters/GetAggregatesVisitor.cpp\n@@ -17,8 +17,7 @@ struct WindowExpressionsCollectorChildInfo\n // evaluation of window functions. Expression is collected only if\n // it's not a part of another expression.\n //\n-// Also all collected AST nodes are marked as dependent on window function.\n-// This information is used during ActionsDAG building process.\n+// Information about window function dependency is used during ActionsDAG building process.\n struct WindowExpressionsCollectorMatcher\n {\n     using ChildInfo = WindowExpressionsCollectorChildInfo;\n@@ -63,11 +62,12 @@ struct WindowExpressionsCollectorMatcher\n                 result.update(subtree_result);\n             }\n \n-            // We mark functions only on the top of AST\n-            if ((!parent || !parent->as<ASTFunction>()) && result.window_function_in_subtree)\n+            // We mark functions if they should be computed after WindowStep\n+            if (result.window_function_in_subtree)\n             {\n-                expressions_with_window_functions.push_back(func);\n                 func->compute_after_window_functions = true;\n+                if ((!parent || !parent->as<ASTFunction>()))\n+                    expressions_with_window_functions.push_back(func);\n             }\n \n             return result;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02354_window_expression_with_aggregation_expression.reference b/tests/queries/0_stateless/02354_window_expression_with_aggregation_expression.reference\nnew file mode 100644\nindex 000000000000..494a1a0cd497\n--- /dev/null\n+++ b/tests/queries/0_stateless/02354_window_expression_with_aggregation_expression.reference\n@@ -0,0 +1,15 @@\n+100\n+100\n+-- { echoOn }\n+SELECT arrayMap(x -> (x + 1), groupArray(number) OVER ()) AS result\n+FROM numbers(10);\n+[1,2,3,4,5,6,7,8,9,10]\n+[1,2,3,4,5,6,7,8,9,10]\n+[1,2,3,4,5,6,7,8,9,10]\n+[1,2,3,4,5,6,7,8,9,10]\n+[1,2,3,4,5,6,7,8,9,10]\n+[1,2,3,4,5,6,7,8,9,10]\n+[1,2,3,4,5,6,7,8,9,10]\n+[1,2,3,4,5,6,7,8,9,10]\n+[1,2,3,4,5,6,7,8,9,10]\n+[1,2,3,4,5,6,7,8,9,10]\ndiff --git a/tests/queries/0_stateless/02354_window_expression_with_aggregation_expression.sql b/tests/queries/0_stateless/02354_window_expression_with_aggregation_expression.sql\nnew file mode 100644\nindex 000000000000..21da3c5f403d\n--- /dev/null\n+++ b/tests/queries/0_stateless/02354_window_expression_with_aggregation_expression.sql\n@@ -0,0 +1,16 @@\n+SELECT \n+    sum(a)*100/sum(sum(a)) OVER (PARTITION BY b) AS r\n+FROM \n+(\n+  SELECT 1 AS a, 2 AS b\n+  UNION ALL\n+  SELECT 3 AS a, 4 AS b\n+  UNION ALL\n+  SELECT 5 AS a, 2 AS b\n+\n+) AS t\n+GROUP BY b;\n+\n+-- { echoOn }\n+SELECT arrayMap(x -> (x + 1), groupArray(number) OVER ()) AS result\n+FROM numbers(10);\n",
  "problem_statement": "NOT_FOUND_COLUMN_IN_BLOCK: Not found column multiply(sum(a), 100) in block\nThis window function does not work\r\n```\r\nselect \r\n      sum(a)*100/sum(sum(a)) over\r\n          (partition by b) as r\r\nfrom \r\n(\r\n  SELECT 1 as a, 2 as b\r\n  UNION ALL\r\n  SELECT 3 as a, 4 as b\r\n  UNION ALL\r\n  SELECT 5 as a, 2 as b\r\n\r\n) as t\r\ngroup by \r\nb\r\n```\r\n\r\n```\r\nReceived exception from server (version 22.7.1):\r\nCode: 10. DB::Exception: Received from localhost:9000. DB::Exception: Not found column multiply(sum(a), 100) in block. Stack trace:\r\n\r\n0. DB::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int, bool) @ 0xb8f1c3a in /usr/bin/clickhouse\r\n1. DB::Exception::Exception<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&>(int, fmt::v8::basic_format_string<char, fmt::v8::type_identity<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&>::type>, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&) @ 0xb95e638 in /usr/bin/clickhouse\r\n2. DB::ActionsDAG::updateHeader(DB::Block) const @ 0x15a85d21 in /usr/bin/clickhouse\r\n3. DB::ExpressionTransform::transformHeader(DB::Block, DB::ActionsDAG const&) @ 0x17401fc4 in /usr/bin/clickhouse\r\n4. DB::ExpressionStep::ExpressionStep(DB::DataStream const&, std::__1::shared_ptr<DB::ActionsDAG>) @ 0x17507dc0 in /usr/bin/clickhouse\r\n5. DB::InterpreterSelectQuery::executeExpression(DB::QueryPlan&, std::__1::shared_ptr<DB::ActionsDAG> const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&) @ 0x162e1152 in /usr/bin/clickhouse\r\n6. DB::InterpreterSelectQuery::executeImpl(DB::QueryPlan&, std::__1::optional<DB::Pipe>) @ 0x162d5d31 in /usr/bin/clickhouse\r\n7. DB::InterpreterSelectQuery::buildQueryPlan(DB::QueryPlan&) @ 0x162d2f75 in /usr/bin/clickhouse\r\n8. DB::InterpreterSelectWithUnionQuery::buildQueryPlan(DB::QueryPlan&) @ 0x16317614 in /usr/bin/clickhouse\r\n9. DB::InterpreterSelectWithUnionQuery::execute() @ 0x1631894d in /usr/bin/clickhouse\r\n10. DB::executeQueryImpl(char const*, char const*, std::__1::shared_ptr<DB::Context>, bool, DB::QueryProcessingStage::Enum, DB::ReadBuffer*) @ 0x165ecab2 in /usr/bin/clickhouse\r\n11. DB::executeQuery(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::shared_ptr<DB::Context>, bool, DB::QueryProcessingStage::Enum) @ 0x165e9f75 in /usr/bin/clickhouse\r\n12. DB::TCPHandler::runImpl() @ 0x171d3c5a in /usr/bin/clickhouse\r\n13. DB::TCPHandler::run() @ 0x171e62d9 in /usr/bin/clickhouse\r\n14. Poco::Net::TCPServerConnection::start() @ 0x19e85433 in /usr/bin/clickhouse\r\n15. Poco::Net::TCPServerDispatcher::run() @ 0x19e867b1 in /usr/bin/clickhouse\r\n16. Poco::PooledThread::run() @ 0x1a037b5b in /usr/bin/clickhouse\r\n17. Poco::ThreadImpl::runnableEntry(void*) @ 0x1a035260 in /usr/bin/clickhouse\r\n18. ? @ 0x7f5406b79609 in ?\r\n19. clone @ 0x7f5406a9e163 in ?\r\n. (NOT_FOUND_COLUMN_IN_BLOCK)\r\n\r\n```\r\n\r\n\r\n\r\nThis works:\r\n```\r\nselect \r\n      sum(a)/sum(sum(a)) over\r\n          (partition by b) as r\r\nfrom \r\n(\r\n  SELECT 1 as a, 2 as b\r\n  UNION ALL\r\n  SELECT 3 as a, 4 as b\r\n  UNION ALL\r\n  SELECT 5 as a, 2 as b\r\n\r\n) as t\r\ngroup by \r\nb\r\n```\n",
  "hints_text": "",
  "created_at": "2022-07-11T23:25:01Z"
}