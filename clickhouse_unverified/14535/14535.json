{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 14535,
  "instance_id": "ClickHouse__ClickHouse-14535",
  "issue_numbers": [
    "14157"
  ],
  "base_commit": "a76d8fb96b99b35b07658114f5f813f647515d96",
  "patch": "diff --git a/src/Core/ExternalResultDescription.cpp b/src/Core/ExternalResultDescription.cpp\nindex 941ee003c94a..7165d73b7d0f 100644\n--- a/src/Core/ExternalResultDescription.cpp\n+++ b/src/Core/ExternalResultDescription.cpp\n@@ -74,6 +74,8 @@ void ExternalResultDescription::init(const Block & sample_block_)\n             types.emplace_back(ValueType::vtDecimal64, is_nullable);\n         else if (typeid_cast<const DataTypeDecimal<Decimal128> *>(type))\n             types.emplace_back(ValueType::vtDecimal128, is_nullable);\n+        else if (typeid_cast<const DataTypeDecimal<Decimal256> *>(type))\n+            types.emplace_back(ValueType::vtDecimal256, is_nullable);\n         else\n             throw Exception{\"Unsupported type \" + type->getName(), ErrorCodes::UNKNOWN_TYPE};\n     }\ndiff --git a/src/Core/ExternalResultDescription.h b/src/Core/ExternalResultDescription.h\nindex 29294fcf2c84..f8ba2a6bba26 100644\n--- a/src/Core/ExternalResultDescription.h\n+++ b/src/Core/ExternalResultDescription.h\n@@ -29,7 +29,8 @@ struct ExternalResultDescription\n         vtDateTime64,\n         vtDecimal32,\n         vtDecimal64,\n-        vtDecimal128\n+        vtDecimal128,\n+        vtDecimal256\n     };\n \n     Block sample_block;\ndiff --git a/src/Core/MySQL/MySQLReplication.cpp b/src/Core/MySQL/MySQLReplication.cpp\nindex 824440b3dd05..1179c0eb46b8 100644\n--- a/src/Core/MySQL/MySQLReplication.cpp\n+++ b/src/Core/MySQL/MySQLReplication.cpp\n@@ -195,10 +195,9 @@ namespace MySQLReplication\n                 case MYSQL_TYPE_LONGLONG:\n                 case MYSQL_TYPE_INT24:\n                 case MYSQL_TYPE_DATE:\n-                case MYSQL_TYPE_TIME:\n                 case MYSQL_TYPE_DATETIME:\n-                case MYSQL_TYPE_YEAR:\n-                case MYSQL_TYPE_NEWDATE: {\n+                case MYSQL_TYPE_NEWDATE:\n+                {\n                     /// No data here.\n                     column_meta.emplace_back(0);\n                     break;\n@@ -208,16 +207,15 @@ namespace MySQLReplication\n                 case MYSQL_TYPE_DOUBLE:\n                 case MYSQL_TYPE_TIMESTAMP2:\n                 case MYSQL_TYPE_DATETIME2:\n-                case MYSQL_TYPE_TIME2:\n-                case MYSQL_TYPE_JSON:\n                 case MYSQL_TYPE_BLOB:\n-                case MYSQL_TYPE_GEOMETRY: {\n+                {\n                     column_meta.emplace_back(UInt16(meta[pos]));\n                     pos += 1;\n                     break;\n                 }\n                 case MYSQL_TYPE_NEWDECIMAL:\n-                case MYSQL_TYPE_STRING: {\n+                case MYSQL_TYPE_STRING:\n+                {\n                     /// Big-Endian\n                     auto b0 = UInt16(meta[pos] << 8);\n                     auto b1 = UInt8(meta[pos + 1]);\n@@ -225,8 +223,6 @@ namespace MySQLReplication\n                     pos += 2;\n                     break;\n                 }\n-\n-                case MYSQL_TYPE_BIT:\n                 case MYSQL_TYPE_VARCHAR:\n                 case MYSQL_TYPE_VAR_STRING: {\n                     /// Little-Endian\n@@ -355,71 +351,65 @@ namespace MySQLReplication\n \n                 switch (field_type)\n                 {\n-                    case MYSQL_TYPE_TINY: {\n+                    case MYSQL_TYPE_TINY:\n+                    {\n                         UInt8 val = 0;\n                         payload.readStrict(reinterpret_cast<char *>(&val), 1);\n                         row.push_back(Field{UInt8{val}});\n                         break;\n                     }\n-                    case MYSQL_TYPE_SHORT: {\n+                    case MYSQL_TYPE_SHORT:\n+                    {\n                         UInt16 val = 0;\n                         payload.readStrict(reinterpret_cast<char *>(&val), 2);\n                         row.push_back(Field{UInt16{val}});\n                         break;\n                     }\n-                    case MYSQL_TYPE_INT24: {\n+                    case MYSQL_TYPE_INT24:\n+                    {\n                         Int32 val = 0;\n                         payload.readStrict(reinterpret_cast<char *>(&val), 3);\n                         row.push_back(Field{Int32{val}});\n                         break;\n                     }\n-                    case MYSQL_TYPE_LONG: {\n+                    case MYSQL_TYPE_LONG:\n+                    {\n                         UInt32 val = 0;\n                         payload.readStrict(reinterpret_cast<char *>(&val), 4);\n                         row.push_back(Field{UInt32{val}});\n                         break;\n                     }\n-                    case MYSQL_TYPE_LONGLONG: {\n+                    case MYSQL_TYPE_LONGLONG:\n+                    {\n                         UInt64 val = 0;\n                         payload.readStrict(reinterpret_cast<char *>(&val), 8);\n                         row.push_back(Field{UInt64{val}});\n                         break;\n                     }\n-                    case MYSQL_TYPE_FLOAT: {\n+                    case MYSQL_TYPE_FLOAT:\n+                    {\n                         Float32 val = 0;\n                         payload.readStrict(reinterpret_cast<char *>(&val), 4);\n                         row.push_back(Field{Float32{val}});\n                         break;\n                     }\n-                    case MYSQL_TYPE_DOUBLE: {\n+                    case MYSQL_TYPE_DOUBLE:\n+                    {\n                         Float64 val = 0;\n                         payload.readStrict(reinterpret_cast<char *>(&val), 8);\n                         row.push_back(Field{Float64{val}});\n                         break;\n                     }\n-                    case MYSQL_TYPE_TIMESTAMP: {\n+                    case MYSQL_TYPE_TIMESTAMP:\n+                    {\n                         UInt32 val = 0;\n \n                         payload.readStrict(reinterpret_cast<char *>(&val), 4);\n                         row.push_back(Field{val});\n                         break;\n                     }\n-                    case MYSQL_TYPE_TIME: {\n-                        UInt32 i24 = 0;\n-                        payload.readStrict(reinterpret_cast<char *>(&i24), 3);\n-\n-                        String time_buff;\n-                        time_buff.resize(8);\n-                        sprintf(\n-                            time_buff.data(),\n-                            \"%02d:%02d:%02d\",\n-                            static_cast<int>(i24 / 10000),\n-                            static_cast<int>(i24 % 10000) / 100,\n-                            static_cast<int>(i24 % 100));\n-                        row.push_back(Field{String{time_buff}});\n-                        break;\n-                    }\n-                    case MYSQL_TYPE_DATE: {\n+                    case MYSQL_TYPE_DATE:\n+                    {\n                         UInt32 i24 = 0;\n                         payload.readStrict(reinterpret_cast<char *>(&i24), 3);\n \n@@ -429,60 +419,12 @@ namespace MySQLReplication\n                         row.push_back(Field(date_day_number.toUnderType()));\n                         break;\n                     }\n-                    case MYSQL_TYPE_YEAR: {\n-                        Int32 val = 0;\n-                        payload.readStrict(reinterpret_cast<char *>(&val), 1);\n-\n-                        String time_buff;\n-                        time_buff.resize(4);\n-                        sprintf(time_buff.data(), \"%04d\", (val + 1900));\n-                        row.push_back(Field{String{time_buff}});\n-                        break;\n-                    }\n-                    case MYSQL_TYPE_TIME2: {\n-                        UInt32 val = 0, frac_part = 0;\n-\n-                        readBigEndianStrict(payload, reinterpret_cast<char *>(&val), 3);\n-                        if (readBits(val, 0, 1, 24) == 0)\n-                        {\n-                            val = ~val + 1;\n-                        }\n-                        UInt32 hour = readBits(val, 2, 10, 24);\n-                        UInt32 minute = readBits(val, 12, 6, 24);\n-                        UInt32 second = readBits(val, 18, 6, 24);\n-                        readTimeFractionalPart(payload, reinterpret_cast<char *>(&frac_part), meta);\n-\n-                        if (frac_part != 0)\n-                        {\n-                            String time_buff;\n-                            time_buff.resize(15);\n-                            sprintf(\n-                                time_buff.data(),\n-                                \"%02d:%02d:%02d.%06d\",\n-                                static_cast<int>(hour),\n-                                static_cast<int>(minute),\n-                                static_cast<int>(second),\n-                                static_cast<int>(frac_part));\n-                            row.push_back(Field{String{time_buff}});\n-                        }\n-                        else\n-                        {\n-                            String time_buff;\n-                            time_buff.resize(8);\n-                            sprintf(\n-                                time_buff.data(),\n-                                \"%02d:%02d:%02d\",\n-                                static_cast<int>(hour),\n-                                static_cast<int>(minute),\n-                                static_cast<int>(second));\n-                            row.push_back(Field{String{time_buff}});\n-                        }\n-                        break;\n-                    }\n-                    case MYSQL_TYPE_DATETIME2: {\n-                        Int64 val = 0, fsp = 0;\n+                    case MYSQL_TYPE_DATETIME2:\n+                    {\n+                        Int64 val = 0;\n+                        UInt32 fsp = 0;\n                         readBigEndianStrict(payload, reinterpret_cast<char *>(&val), 5);\n-                        readTimeFractionalPart(payload, reinterpret_cast<char *>(&fsp), meta);\n+                        readTimeFractionalPart(payload, fsp, meta);\n \n                         UInt32 year_month = readBits(val, 1, 17, 40);\n                         time_t date_time = DateLUT::instance().makeDateTime(\n@@ -490,138 +432,130 @@ namespace MySQLReplication\n                             , readBits(val, 23, 5, 40), readBits(val, 28, 6, 40), readBits(val, 34, 6, 40)\n                         );\n \n-                        row.push_back(Field{UInt32(date_time)});\n+                        if (!meta)\n+                            row.push_back(Field{UInt32(date_time)});\n+                        else\n+                        {\n+                            DB::DecimalUtils::DecimalComponents<DateTime64::NativeType> components{\n+                                static_cast<DateTime64::NativeType>(date_time), 0};\n+\n+                            components.fractional = fsp;\n+                            row.push_back(Field(DecimalUtils::decimalFromComponents<DateTime64>(components, meta)));\n+                        }\n+\n                         break;\n                     }\n-                    case MYSQL_TYPE_TIMESTAMP2: {\n+                    case MYSQL_TYPE_TIMESTAMP2:\n+                    {\n                         UInt32 sec = 0, fsp = 0;\n                         readBigEndianStrict(payload, reinterpret_cast<char *>(&sec), 4);\n-                        readTimeFractionalPart(payload, reinterpret_cast<char *>(&fsp), meta);\n-                        row.push_back(Field{sec});\n-                        break;\n-                    }\n-                    case MYSQL_TYPE_NEWDECIMAL: {\n-                        Int8 digits_per_integer = 9;\n-                        Int8 precision = meta >> 8;\n-                        Int8 decimals = meta & 0xff;\n-                        const char compressed_byte_map[] = {0, 1, 1, 2, 2, 3, 3, 4, 4, 4};\n-\n-                        Int8 integral = (precision - decimals);\n-                        UInt32 uncompressed_integers = integral / digits_per_integer;\n-                        UInt32 uncompressed_decimals = decimals / digits_per_integer;\n-                        UInt32 compressed_integers = integral - (uncompressed_integers * digits_per_integer);\n-                        UInt32 compressed_decimals = decimals - (uncompressed_decimals * digits_per_integer);\n-\n-                        String buff;\n-                        UInt32 bytes_to_read = uncompressed_integers * 4 + compressed_byte_map[compressed_integers]\n-                            + uncompressed_decimals * 4 + compressed_byte_map[compressed_decimals];\n-                        buff.resize(bytes_to_read);\n-                        payload.readStrict(reinterpret_cast<char *>(buff.data()), bytes_to_read);\n-\n-                        String format;\n-                        format.resize(0);\n-\n-                        bool is_negative = ((buff[0] & 0x80) == 0);\n-                        if (is_negative)\n-                        {\n-                            format += \"-\";\n-                        }\n-                        buff[0] ^= 0x80;\n+                        readTimeFractionalPart(payload, fsp, meta);\n \n-                        ReadBufferFromString reader(buff);\n-                        /// Compressed part.\n-                        if (compressed_integers != 0)\n+                        if (!meta)\n+                            row.push_back(Field{sec});\n+                        else\n                         {\n-                            Int64 val = 0;\n-                            UInt8 to_read = compressed_byte_map[compressed_integers];\n-                            readBigEndianStrict(reader, reinterpret_cast<char *>(&val), to_read);\n-                            format += std::to_string(val);\n-                        }\n+                            DB::DecimalUtils::DecimalComponents<DateTime64::NativeType> components{\n+                                static_cast<DateTime64::NativeType>(sec), 0};\n \n-                        for (auto k = 0U; k < uncompressed_integers; k++)\n-                        {\n-                            UInt32 val = 0;\n-                            readBigEndianStrict(reader, reinterpret_cast<char *>(&val), 4);\n-                            format += std::to_string(val);\n+                            components.fractional = fsp;\n+                            row.push_back(Field(DecimalUtils::decimalFromComponents<DateTime64>(components, meta)));\n                         }\n-                        format += \".\";\n-                        for (auto k = 0U; k < uncompressed_decimals; k++)\n+\n+                        break;\n+                    }\n+                    case MYSQL_TYPE_NEWDECIMAL:\n+                    {\n+                        const auto & dispatch = [](const size_t & precision, const size_t & scale, const auto & function) -> Field\n                         {\n-                            UInt32 val = 0;\n-                            reader.readStrict(reinterpret_cast<char *>(&val), 4);\n-                            format += std::to_string(val);\n-                        }\n+                            if (precision <= DecimalUtils::maxPrecision<Decimal32>())\n+                                return Field(function(precision, scale, Decimal32()));\n+                            else if (precision <= DecimalUtils::maxPrecision<Decimal64>())\n+                                return Field(function(precision, scale, Decimal64()));\n+                            else if (precision <= DecimalUtils::maxPrecision<Decimal128>())\n+                                return Field(function(precision, scale, Decimal128()));\n \n-                        /// Compressed part.\n-                        if (compressed_decimals != 0)\n+                            return Field(function(precision, scale, Decimal256()));\n+                        };\n+\n+                        const auto & read_decimal = [&](const size_t & precision, const size_t & scale, auto decimal)\n                         {\n-                            Int64 val = 0;\n-                            String compressed_buff;\n-                            UInt8 to_read = compressed_byte_map[compressed_decimals];\n-                            switch (to_read)\n+                            using DecimalType = decltype(decimal);\n+                            static constexpr size_t digits_per_integer = 9;\n+                            static const size_t compressed_bytes_map[] = {0, 1, 1, 2, 2, 3, 3, 4, 4, 4};\n+                            static const size_t compressed_integer_align_numbers[] = {\n+                                0x0, 0xFF, 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};\n+\n+                            UInt32 mask = 0;\n+                            DecimalType res(0);\n+\n+                            if ((*payload.position() & 0x80) == 0)\n+                                mask = UInt32(-1);\n+\n+                            *payload.position() ^= 0x80;\n+\n                             {\n-                                case 1: {\n-                                    reader.readStrict(reinterpret_cast<char *>(&val), 1);\n-                                    break;\n+                                size_t integral = (precision - scale);\n+                                size_t uncompressed_integers = integral / digits_per_integer;\n+                                size_t compressed_integers = integral - (uncompressed_integers * digits_per_integer);\n+\n+                                /// Compressed part.\n+                                if (compressed_integers != 0)\n+                                {\n+                                    UInt32 val = 0;\n+                                    size_t to_read = compressed_bytes_map[compressed_integers];\n+                                    readBigEndianStrict(payload, reinterpret_cast<char *>(&val), to_read);\n+                                    res += (val ^ (mask & compressed_integer_align_numbers[compressed_integers]));\n                                 }\n-                                case 2: {\n-                                    readBigEndianStrict(reader, reinterpret_cast<char *>(&val), 2);\n-                                    break;\n+\n+                                for (auto k = 0U; k < uncompressed_integers; k++)\n+                                {\n+                                    UInt32 val = 0;\n+                                    readBigEndianStrict(payload, reinterpret_cast<char *>(&val), 4);\n+                                    res *= intExp10OfSize<DecimalType>(digits_per_integer);\n+                                    res += (val ^ mask);\n                                 }\n-                                case 3: {\n-                                    readBigEndianStrict(reader, reinterpret_cast<char *>(&val), 3);\n-                                    break;\n+                            }\n+\n+                            {\n+                                size_t uncompressed_decimals = scale / digits_per_integer;\n+                                size_t compressed_decimals = scale - (uncompressed_decimals * digits_per_integer);\n+\n+                                for (auto k = 0U; k < uncompressed_decimals; k++)\n+                                {\n+                                    UInt32 val = 0;\n+                                    readBigEndianStrict(payload, reinterpret_cast<char *>(&val), 4);\n+                                    res *= intExp10OfSize<DecimalType>(digits_per_integer);\n+                                    res += (val ^ mask);\n                                 }\n-                                case 4: {\n-                                    readBigEndianStrict(reader, reinterpret_cast<char *>(&val), 4);\n-                                    break;\n+\n+                                /// Compressed part.\n+                                if (compressed_decimals != 0)\n+                                {\n+                                    UInt32 val = 0;\n+                                    size_t to_read = compressed_bytes_map[compressed_decimals];\n+\n+                                    if (to_read)\n+                                    {\n+                                        readBigEndianStrict(payload, reinterpret_cast<char *>(&val), to_read);\n+                                        res *= intExp10OfSize<DecimalType>(compressed_decimals);\n+                                        res += (val ^ (mask & compressed_integer_align_numbers[compressed_decimals]));\n+                                    }\n                                 }\n-                                default:\n-                                    break;\n-                            }\n-                            format += std::to_string(val);\n-                        }\n-                        row.push_back(Field{String{format}});\n-                        break;\n-                    }\n-                    case MYSQL_TYPE_ENUM: {\n-                        Int32 val = 0;\n-                        Int32 len = (meta & 0xff);\n-                        switch (len)\n-                        {\n-                            case 1: {\n-                                payload.readStrict(reinterpret_cast<char *>(&val), 1);\n-                                break;\n                             }\n-                            case 2: {\n-                                payload.readStrict(reinterpret_cast<char *>(&val), 2);\n-                                break;\n-                            }\n-                            default:\n-                                break;\n-                        }\n-                        row.push_back(Field{Int32{val}});\n-                        break;\n-                    }\n-                    case MYSQL_TYPE_BIT: {\n-                        UInt32 bits = ((meta >> 8) * 8) + (meta & 0xff);\n-                        UInt32 size = (bits + 7) / 8;\n \n-                        Bitmap bitmap1;\n-                        readBitmap(payload, bitmap1, size);\n-                        row.push_back(Field{UInt64{bitmap1.to_ulong()}});\n-                        break;\n-                    }\n-                    case MYSQL_TYPE_SET: {\n-                        UInt32 size = (meta & 0xff);\n+                            if (mask != 0)\n+                                res *= -1;\n+\n+                            return res;\n+                        };\n \n-                        Bitmap bitmap1;\n-                        readBitmap(payload, bitmap1, size);\n-                        row.push_back(Field{UInt64{bitmap1.to_ulong()}});\n+                        row.push_back(dispatch((meta >> 8) & 0xFF, meta & 0xFF, read_decimal));\n                         break;\n                     }\n                     case MYSQL_TYPE_VARCHAR:\n-                    case MYSQL_TYPE_VAR_STRING: {\n+                    case MYSQL_TYPE_VAR_STRING:\n+                    {\n                         uint32_t size = 0;\n                         if (meta < 256)\n                         {\n@@ -638,7 +572,8 @@ namespace MySQLReplication\n                         row.push_back(Field{String{val}});\n                         break;\n                     }\n-                    case MYSQL_TYPE_STRING: {\n+                    case MYSQL_TYPE_STRING:\n+                    {\n                         UInt32 size = 0;\n                         if (field_len < 256)\n                         {\n@@ -655,8 +590,8 @@ namespace MySQLReplication\n                         row.push_back(Field{String{val}});\n                         break;\n                     }\n-                    case MYSQL_TYPE_GEOMETRY:\n-                    case MYSQL_TYPE_BLOB: {\n+                    case MYSQL_TYPE_BLOB:\n+                    {\n                         UInt32 size = 0;\n                         switch (meta)\n                         {\n@@ -686,16 +621,6 @@ namespace MySQLReplication\n                         row.push_back(Field{String{val}});\n                         break;\n                     }\n-                    case MYSQL_TYPE_JSON: {\n-                        UInt32 size = 0;\n-                        payload.readStrict(reinterpret_cast<char *>(&size), meta);\n-\n-                        String val;\n-                        val.resize(size);\n-                        payload.readStrict(reinterpret_cast<char *>(val.data()), size);\n-                        row.push_back(Field{String{val}});\n-                        break;\n-                    }\n                     default:\n                         throw ReplicationError(\n                             \"ParseRow: Unhandled MySQL field type:\" + std::to_string(field_type), ErrorCodes::UNKNOWN_EXCEPTION);\ndiff --git a/src/Core/MySQL/MySQLReplication.h b/src/Core/MySQL/MySQLReplication.h\nindex fbcd67105ed0..6f5b4cf0a1e0 100644\n--- a/src/Core/MySQL/MySQLReplication.h\n+++ b/src/Core/MySQL/MySQLReplication.h\n@@ -36,23 +36,41 @@ namespace MySQLReplication\n         std::reverse(start, end);\n     }\n \n-    inline void readTimeFractionalPart(ReadBuffer & payload, char * to, UInt16 meta)\n+    inline void readTimeFractionalPart(ReadBuffer & payload, UInt32 & factional, UInt16 meta)\n     {\n         switch (meta)\n         {\n             case 1:\n-            case 2: {\n-                readBigEndianStrict(payload, to, 1);\n+            {\n+                readBigEndianStrict(payload, reinterpret_cast<char *>(&factional), 1);\n+                factional /= 10;\n+                break;\n+            }\n+            case 2:\n+            {\n+                readBigEndianStrict(payload, reinterpret_cast<char *>(&factional), 1);\n                 break;\n             }\n             case 3:\n-            case 4: {\n-                readBigEndianStrict(payload, to, 2);\n+            {\n+                readBigEndianStrict(payload, reinterpret_cast<char *>(&factional), 2);\n+                factional /= 10;\n+                break;\n+            }\n+            case 4:\n+            {\n+                readBigEndianStrict(payload, reinterpret_cast<char *>(&factional), 2);\n                 break;\n             }\n             case 5:\n-            case 6: {\n-                readBigEndianStrict(payload, to, 3);\n+            {\n+                readBigEndianStrict(payload, reinterpret_cast<char *>(&factional), 3);\n+                factional /= 10;\n+                break;\n+            }\n+            case 6:\n+            {\n+                readBigEndianStrict(payload, reinterpret_cast<char *>(&factional), 3);\n                 break;\n             }\n             default:\ndiff --git a/src/Databases/MySQL/MaterializeMySQLSyncThread.cpp b/src/Databases/MySQL/MaterializeMySQLSyncThread.cpp\nindex 465a7cb912a0..e26f5c2fd527 100644\n--- a/src/Databases/MySQL/MaterializeMySQLSyncThread.cpp\n+++ b/src/Databases/MySQL/MaterializeMySQLSyncThread.cpp\n@@ -9,6 +9,7 @@\n #    include <cstdlib>\n #    include <random>\n #    include <Columns/ColumnTuple.h>\n+#    include <Columns/ColumnDecimal.h>\n #    include <DataStreams/CountingBlockOutputStream.h>\n #    include <DataStreams/OneBlockInputStream.h>\n #    include <DataStreams/copyData.h>\n@@ -453,6 +454,14 @@ static void writeFieldsToColumn(\n             write_data_to_column(casted_float32_column, Float64(), Float32());\n         else if (ColumnFloat64 * casted_float64_column = typeid_cast<ColumnFloat64 *>(&column_to))\n             write_data_to_column(casted_float64_column, Float64(), Float64());\n+        else if (ColumnDecimal<Decimal32> * casted_decimal_32_column = typeid_cast<ColumnDecimal<Decimal32> *>(&column_to))\n+            write_data_to_column(casted_decimal_32_column, Decimal32(), Decimal32());\n+        else if (ColumnDecimal<Decimal64> * casted_decimal_64_column = typeid_cast<ColumnDecimal<Decimal64> *>(&column_to))\n+            write_data_to_column(casted_decimal_64_column, Decimal64(), Decimal64());\n+        else if (ColumnDecimal<Decimal128> * casted_decimal_128_column = typeid_cast<ColumnDecimal<Decimal128> *>(&column_to))\n+            write_data_to_column(casted_decimal_128_column, Decimal128(), Decimal128());\n+        else if (ColumnDecimal<Decimal256> * casted_decimal_256_column = typeid_cast<ColumnDecimal<Decimal256> *>(&column_to))\n+            write_data_to_column(casted_decimal_256_column, Decimal256(), Decimal256());\n         else if (ColumnInt32 * casted_int32_column = typeid_cast<ColumnInt32 *>(&column_to))\n         {\n             for (size_t index = 0; index < rows_data.size(); ++index)\ndiff --git a/src/Formats/MySQLBlockInputStream.cpp b/src/Formats/MySQLBlockInputStream.cpp\nindex f85680c00313..be1e254b22fa 100644\n--- a/src/Formats/MySQLBlockInputStream.cpp\n+++ b/src/Formats/MySQLBlockInputStream.cpp\n@@ -90,7 +90,8 @@ namespace\n             case ValueType::vtDateTime64:[[fallthrough]];\n             case ValueType::vtDecimal32: [[fallthrough]];\n             case ValueType::vtDecimal64: [[fallthrough]];\n-            case ValueType::vtDecimal128:\n+            case ValueType::vtDecimal128:[[fallthrough]];\n+            case ValueType::vtDecimal256:\n             {\n                 ReadBuffer buffer(const_cast<char *>(value.data()), value.size(), 0);\n                 data_type.deserializeAsWholeText(column, buffer, FormatSettings{});\n",
  "test_patch": "diff --git a/tests/integration/test_materialize_mysql_database/materialize_with_ddl.py b/tests/integration/test_materialize_mysql_database/materialize_with_ddl.py\nindex a0a3b0b1cb6e..813e72fe7a7e 100644\n--- a/tests/integration/test_materialize_mysql_database/materialize_with_ddl.py\n+++ b/tests/integration/test_materialize_mysql_database/materialize_with_ddl.py\n@@ -99,6 +99,38 @@ def dml_with_materialize_mysql_database(clickhouse_node, mysql_node, service_nam\n     mysql_node.query(\"DROP DATABASE test_database\")\n \n \n+def materialize_mysql_database_with_datetime_and_decimal(clickhouse_node, mysql_node, service_name):\n+    mysql_node.query(\"CREATE DATABASE test_database DEFAULT CHARACTER SET 'utf8'\")\n+    mysql_node.query(\"CREATE TABLE test_database.test_table_1 (`key` INT NOT NULL PRIMARY KEY, _datetime DateTime(6), _timestamp TIMESTAMP(3), _decimal DECIMAL(65, 30)) ENGINE = InnoDB;\")\n+    mysql_node.query(\"INSERT INTO test_database.test_table_1 VALUES(1, '2020-01-01 01:02:03.999999', '2020-01-01 01:02:03.999', \" + ('9' * 35) + \".\" + ('9' * 30) + \")\")\n+    mysql_node.query(\"INSERT INTO test_database.test_table_1 VALUES(2, '2020-01-01 01:02:03.000000', '2020-01-01 01:02:03.000', .\" + ('0' * 29) + \"1)\")\n+    mysql_node.query(\"INSERT INTO test_database.test_table_1 VALUES(3, '2020-01-01 01:02:03.9999', '2020-01-01 01:02:03.99', -\" + ('9' * 35) + \".\" + ('9' * 30) + \")\")\n+    mysql_node.query(\"INSERT INTO test_database.test_table_1 VALUES(4, '2020-01-01 01:02:03.9999', '2020-01-01 01:02:03.9999', -.\" + ('0' * 29) + \"1)\")\n+\n+    clickhouse_node.query(\"CREATE DATABASE test_database ENGINE = MaterializeMySQL('{}:3306', 'test_database', 'root', 'clickhouse')\".format(service_name))\n+    assert \"test_database\" in clickhouse_node.query(\"SHOW DATABASES\")\n+    check_query(clickhouse_node, \"SHOW TABLES FROM test_database FORMAT TSV\", \"test_table_1\\n\")\n+    check_query(clickhouse_node, \"SELECT * FROM test_database.test_table_1 ORDER BY key FORMAT TSV\",\n+                \"1\\t2020-01-01 01:02:03.999999\\t2020-01-01 01:02:03.999\\t\" + ('9' * 35) + \".\" + ('9' * 30) + \"\\n\"\n+                \"2\\t2020-01-01 01:02:03.000000\\t2020-01-01 01:02:03.000\\t0.\" + ('0' * 29) + \"1\\n\"\n+                \"3\\t2020-01-01 01:02:03.999900\\t2020-01-01 01:02:03.990\\t-\" + ('9' * 35) + \".\" + ('9' * 30) + \"\\n\"\n+                \"4\\t2020-01-01 01:02:03.999900\\t2020-01-01 01:02:04.000\\t-0.\" + ('0' * 29) + \"1\\n\")\n+\n+    mysql_node.query(\"CREATE TABLE test_database.test_table_2 (`key` INT NOT NULL PRIMARY KEY, _datetime DateTime(6), _timestamp TIMESTAMP(3), _decimal DECIMAL(65, 30)) ENGINE = InnoDB;\")\n+    mysql_node.query(\"INSERT INTO test_database.test_table_2 VALUES(1, '2020-01-01 01:02:03.999999', '2020-01-01 01:02:03.999', \" + ('9' * 35) + \".\" + ('9' * 30) + \")\")\n+    mysql_node.query(\"INSERT INTO test_database.test_table_2 VALUES(2, '2020-01-01 01:02:03.000000', '2020-01-01 01:02:03.000', .\" + ('0' * 29) + \"1)\")\n+    mysql_node.query(\"INSERT INTO test_database.test_table_2 VALUES(3, '2020-01-01 01:02:03.9999', '2020-01-01 01:02:03.99', -\" + ('9' * 35) + \".\" + ('9' * 30) + \")\")\n+    mysql_node.query(\"INSERT INTO test_database.test_table_2 VALUES(4, '2020-01-01 01:02:03.9999', '2020-01-01 01:02:03.9999', -.\" + ('0' * 29) + \"1)\")\n+    check_query(clickhouse_node, \"SELECT * FROM test_database.test_table_2 ORDER BY key FORMAT TSV\",\n+                \"1\\t2020-01-01 01:02:03.999999\\t2020-01-01 01:02:03.999\\t\" + ('9' * 35) + \".\" + ('9' * 30) + \"\\n\"\n+                \"2\\t2020-01-01 01:02:03.000000\\t2020-01-01 01:02:03.000\\t0.\" + ('0' * 29) + \"1\\n\"\n+                \"3\\t2020-01-01 01:02:03.999900\\t2020-01-01 01:02:03.990\\t-\" + ('9' * 35) + \".\" + ('9' * 30) + \"\\n\"\n+                \"4\\t2020-01-01 01:02:03.999900\\t2020-01-01 01:02:04.000\\t-0.\" + ('0' * 29) + \"1\\n\")\n+    clickhouse_node.query(\"DROP DATABASE test_database\")\n+    mysql_node.query(\"DROP DATABASE test_database\")\n+\n+\n+\n def drop_table_with_materialize_mysql_database(clickhouse_node, mysql_node, service_name):\n     mysql_node.query(\"CREATE DATABASE test_database DEFAULT CHARACTER SET 'utf8'\")\n     mysql_node.query(\"CREATE TABLE test_database.test_table_1 (id INT NOT NULL PRIMARY KEY) ENGINE = InnoDB;\")\ndiff --git a/tests/integration/test_materialize_mysql_database/test.py b/tests/integration/test_materialize_mysql_database/test.py\nindex c7314fb50d94..81a69dd7c543 100644\n--- a/tests/integration/test_materialize_mysql_database/test.py\n+++ b/tests/integration/test_materialize_mysql_database/test.py\n@@ -94,10 +94,13 @@ def started_mysql_8_0():\n \n def test_materialize_database_dml_with_mysql_5_7(started_cluster, started_mysql_5_7):\n     materialize_with_ddl.dml_with_materialize_mysql_database(clickhouse_node, started_mysql_5_7, \"mysql1\")\n+    materialize_with_ddl.materialize_mysql_database_with_datetime_and_decimal(clickhouse_node, started_mysql_5_7, \"mysql1\")\n \n \n def test_materialize_database_dml_with_mysql_8_0(started_cluster, started_mysql_8_0):\n     materialize_with_ddl.dml_with_materialize_mysql_database(clickhouse_node, started_mysql_8_0, \"mysql8_0\")\n+    materialize_with_ddl.materialize_mysql_database_with_datetime_and_decimal(clickhouse_node, started_mysql_8_0, \"mysql8_0\")\n+\n \n \n def test_materialize_database_ddl_with_mysql_5_7(started_cluster, started_mysql_5_7):\n",
  "problem_statement": "DB::Exception: Unsupported type Decimal(13, 4) when using MaterializeMySQL\nIt seems MaterializeMySQL doesn't support Decimal data type when doing replication.\n",
  "hints_text": "@BohuTANG @zhang2014 , need your confirmation.\ni got the same problem\r\nfirst create a table in mysql\r\n```\r\nmysql> create table dec2(a int, b decimal(10,2), primary key(a));\r\nQuery OK, 0 rows affected (0.19 sec)\r\n\r\nmysql> insert into dec2 values (1,1.2),(2,2.4);\r\nQuery OK, 2 rows affected (0.01 sec)\r\nRecords: 2  Duplicates: 0  Warnings: 0\r\n\r\nmysql> select * from dec2;\r\n+---+------+\r\n| a | b    |\r\n+---+------+\r\n| 1 | 1.20 |\r\n| 2 | 2.40 |\r\n+---+------+\r\n\r\n```\r\nthen in clickhouse\r\n```\r\nSET allow_experimental_database_materialize_mysql=1;\r\nCREATE DATABASE ckdb2 ENGINE = MaterializeMySQL('127.0.0.1:3306', 'ckdb2', 'root', 'A123b_456');\r\nSHOW TABLES;\r\n\r\n\u250c\u2500name\u2500\u2510\r\n\u2502 dec2 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n select * from dec2;\r\n\r\nReceived exception from server (version 20.8.1):\r\nCode: 50. DB::Exception: Received from localhost:9000. DB::Exception: Unsupported type Decimal(10, 2).\r\n\r\n```\nthe table is created\r\n```\r\nDESCRIBE TABLE dec2\r\n\r\n\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500default_type\u2500\u252c\u2500default_expression\u2500\u252c\u2500comment\u2500\u252c\u2500codec_expression\u2500\u252c\u2500ttl_expression\u2500\u2510\r\n\u2502 a        \u2502 Int32                    \u2502              \u2502                    \u2502         \u2502                  \u2502                \u2502\r\n\u2502 b        \u2502 Nullable(Decimal(10, 2)) \u2502              \u2502                    \u2502         \u2502                  \u2502                \u2502\r\n\u2502 _sign    \u2502 Int8                     \u2502 MATERIALIZED \u2502 1                  \u2502         \u2502                  \u2502                \u2502\r\n\u2502 _version \u2502 UInt64                   \u2502 MATERIALIZED \u2502 1                  \u2502         \u2502                  \u2502                \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n@l1t1 , table has been created, but data sync failed.\ni found two types of tables arenot supported, are there any other types more ?\r\nhttps://github.com/ClickHouse/ClickHouse/issues/14114\r\n```\r\nDB::Exception: The ckdb.dzm cannot be materialized, because there is no primary keys..\r\n\r\nDB::Exception: Sorting key cannot contain nullable columns.\r\n```\nme too. decimal type is not supported when using the MaterializeMySQL engine. @filimonov @zhang2014 @BohuTANG \r\n\r\nthe stacktrace is below:\r\n\r\n2020.08.28 00:01:42.718954 [ 7739 ] {cf4473a4-8b5a-4c3f-8aab-5f642e9bbf03} <Debug> executeQuery: (from [::ffff:127.0.0.1]:33014) select * from price_print;\r\n2020.08.28 00:01:42.719716 [ 7739 ] {cf4473a4-8b5a-4c3f-8aab-5f642e9bbf03} <Error> executeQuery: Code: 50, e.displayText() = DB::Exception: Unsupported type Decimal(12, 2) (version 20.8.1.4447 (official build)) (from [::ffff:127.0.0.1]:33014) (in query: select * from price_print;), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. Poco::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int) @ 0x1a708040 in /usr/bin/clickhouse\r\n1. DB::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int) @ 0xff0e78d in /usr/bin/clickhouse\r\n2. ? @ 0x16e33687 in /usr/bin/clickhouse\r\n3. DB::MySQLBlockInputStream::MySQLBlockInputStream(mysqlxx::Pool::Entry const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, DB::Block const&, unsigned long, bool) @ 0x17dab3d8 in /usr/bin/clickhouse\r\n4. ? @ 0x172a88ea in /usr/bin/clickhouse\r\n5. ? @ 0x172a9e23 in /usr/bin/clickhouse\r\n6. DB::commitMetadata(std::__1::function<void ()> const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&) @ 0x172de629 in /usr/bin/clickhouse\r\n7. DB::MaterializeMetadata::transaction(DB::MySQLReplication::Position const&, std::__1::function<void ()> const&) @ 0x172e061a in /usr/bin/clickhouse\r\n8. DB::MaterializeMySQLSyncThread::prepareSynchronized(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&) @ 0x172a2fa1 in /usr/bin/clickhouse\r\n9. DB::MaterializeMySQLSyncThread::synchronization(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&) @ 0x172a6c5b in /usr/bin/clickhouse\r\n10. ? @ 0x172a7176 in /usr/bin/clickhouse\r\n11. ThreadPoolImpl<std::__1::thread>::worker(std::__1::__list_iterator<std::__1::thread, void*>) @ 0xff3e4a7 in /usr/bin/clickhouse\r\n12. ? @ 0xff3cae3 in /usr/bin/clickhouse\r\n13. start_thread @ 0x7dd5 in /usr/lib64/libpthread-2.17.so\r\n14. __clone @ 0xfdead in /usr/lib64/libc-2.17.so\r\n\r\n2020.08.28 00:01:42.719942 [ 7739 ] {cf4473a4-8b5a-4c3f-8aab-5f642e9bbf03} <Debug> MemoryTracker: Peak memory usage (for query): 0.00 B.\n@Enmk is working on this https://github.com/ClickHouse/ClickHouse/pull/11512\r\n\n@BohuTANG \uff0cI have one question, suppose we need to replicate 2 DB from same MySQL, will the bin log read twice by ClickHouse, for each of the DB?\n> @BohuTANG \uff0cI have one question, suppose we need to replicate 2 DB from same MySQL, will the bin log read twice by ClickHouse, for each of the DB?\r\n\r\nYes, each database replication channel is a full streaming binlog network.\r\nFor multiple databases from the same MySQL maybe we can do it in MaterializeMySQL settings.",
  "created_at": "2020-09-07T09:46:03Z"
}