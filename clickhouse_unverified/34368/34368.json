{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 34368,
  "instance_id": "ClickHouse__ClickHouse-34368",
  "issue_numbers": [
    "33982"
  ],
  "base_commit": "f63455b7a201190c77c165afb7715e3c4cf194d1",
  "patch": "diff --git a/src/Functions/FunctionStartsEndsWith.h b/src/Functions/FunctionStartsEndsWith.h\nindex 5a3aba62f26c..bbe1631fdf98 100644\n--- a/src/Functions/FunctionStartsEndsWith.h\n+++ b/src/Functions/FunctionStartsEndsWith.h\n@@ -1,4 +1,6 @@\n #pragma once\n+#include <base/map.h>\n+\n #include <Functions/FunctionHelpers.h>\n #include <Functions/GatherUtils/GatherUtils.h>\n #include <Functions/GatherUtils/Sources.h>\n@@ -7,7 +9,9 @@\n #include <Functions/TargetSpecific.h>\n #include <DataTypes/DataTypeString.h>\n #include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/getLeastSupertype.h>\n #include <Columns/ColumnString.h>\n+#include <Interpreters/castColumn.h>\n \n namespace DB\n {\n@@ -17,6 +21,7 @@ using namespace GatherUtils;\n namespace ErrorCodes\n {\n     extern const int ILLEGAL_COLUMN;\n+    extern const int LOGICAL_ERROR;\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n }\n \n@@ -59,16 +64,65 @@ class FunctionStartsEndsWith : public IFunction\n \n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n-        if (!isStringOrFixedString(arguments[0]))\n-            throw Exception(\"Illegal type \" + arguments[0]->getName() + \" of argument of function \" + getName(), ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+        if (isStringOrFixedString(arguments[0]) && isStringOrFixedString(arguments[1]))\n+            return std::make_shared<DataTypeUInt8>();\n \n-        if (!isStringOrFixedString(arguments[1]))\n-            throw Exception(\"Illegal type \" + arguments[1]->getName() + \" of argument of function \" + getName(), ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+        if (isArray(arguments[0]) && isArray(arguments[1]))\n+            return std::make_shared<DataTypeUInt8>();\n \n-        return std::make_shared<DataTypeUInt8>();\n+        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+            \"Illegal types {} {} of arguments of function {}. Both must be String or Array\",\n+            arguments[0]->getName(), arguments[1]->getName(), getName());\n     }\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        auto data_type = arguments[0].type;\n+        if (isStringOrFixedString(*data_type))\n+            return executeImplString(arguments, {}, input_rows_count);\n+        if (isArray(data_type))\n+            return executeImplArray(arguments, {}, input_rows_count);\n+        return {};\n+    }\n+\n+private:\n+    ColumnPtr executeImplArray(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const\n+    {\n+        DataTypePtr common_type = getLeastSupertype(collections::map(arguments, [](auto & arg) { return arg.type; }));\n+\n+        Columns preprocessed_columns(2);\n+        for (size_t i = 0; i < 2; ++i)\n+            preprocessed_columns[i] = castColumn(arguments[i], common_type);\n+\n+        std::vector<std::unique_ptr<GatherUtils::IArraySource>> sources;\n+        for (auto & argument_column : preprocessed_columns)\n+        {\n+            bool is_const = false;\n+\n+            if (const auto * argument_column_const = typeid_cast<const ColumnConst *>(argument_column.get()))\n+            {\n+                is_const = true;\n+                argument_column = argument_column_const->getDataColumnPtr();\n+            }\n+\n+            if (const auto * argument_column_array = typeid_cast<const ColumnArray *>(argument_column.get()))\n+                sources.emplace_back(GatherUtils::createArraySource(*argument_column_array, is_const, input_rows_count));\n+            else\n+                throw Exception{\"Arguments for function \" + getName() + \" must be arrays.\", ErrorCodes::LOGICAL_ERROR};\n+        }\n+\n+        auto result_column = ColumnUInt8::create(input_rows_count);\n+        auto * result_column_ptr = typeid_cast<ColumnUInt8 *>(result_column.get());\n+\n+        if constexpr (std::is_same_v<Name, NameStartsWith>)\n+            GatherUtils::sliceHas(*sources[0], *sources[1], GatherUtils::ArraySearchType::StartsWith, *result_column_ptr);\n+        else\n+            GatherUtils::sliceHas(*sources[0], *sources[1], GatherUtils::ArraySearchType::EndsWith, *result_column_ptr);\n+\n+        return result_column;\n+    }\n+\n+    ColumnPtr executeImplString(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const\n     {\n         const IColumn * haystack_column = arguments[0].column.get();\n         const IColumn * needle_column = arguments[1].column.get();\n@@ -92,7 +146,6 @@ class FunctionStartsEndsWith : public IFunction\n         return col_res;\n     }\n \n-private:\n     template <typename HaystackSource>\n     void dispatch(HaystackSource haystack_source, const IColumn * needle_column, PaddedPODArray<UInt8> & res_data) const\n     {\ndiff --git a/src/Functions/GatherUtils/Algorithms.h b/src/Functions/GatherUtils/Algorithms.h\nindex 046e2dcf70f6..2d4544b2167d 100644\n--- a/src/Functions/GatherUtils/Algorithms.h\n+++ b/src/Functions/GatherUtils/Algorithms.h\n@@ -496,6 +496,31 @@ bool sliceHasImplAnyAll(const FirstSliceType & first, const SecondSliceType & se\n     return search_type == ArraySearchType::All;\n }\n \n+template <\n+    ArraySearchType search_type,\n+    typename FirstSliceType,\n+    typename SecondSliceType,\n+          bool (*isEqual)(const FirstSliceType &, const SecondSliceType &, size_t, size_t)>\n+bool sliceHasImplStartsEndsWith(const FirstSliceType & first, const SecondSliceType & second, const UInt8 * first_null_map, const UInt8 * second_null_map)\n+{\n+    const bool has_first_null_map = first_null_map != nullptr;\n+    const bool has_second_null_map = second_null_map != nullptr;\n+\n+    if (first.size < second.size)\n+        return false;\n+\n+    size_t first_index = (search_type == ArraySearchType::StartsWith) ? 0 : first.size - second.size;\n+    for (size_t second_index = 0; second_index < second.size; ++second_index, ++first_index)\n+    {\n+        const bool is_first_null = has_first_null_map && first_null_map[first_index];\n+        const bool is_second_null = has_second_null_map && second_null_map[second_index];\n+        if (is_first_null != is_second_null)\n+            return false;\n+        if (!is_first_null && !is_second_null && !isEqual(first, second, first_index, second_index))\n+            return false;\n+    }\n+    return true;\n+}\n \n /// For details of Knuth-Morris-Pratt string matching algorithm see\n /// https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.\n@@ -589,6 +614,8 @@ bool sliceHasImpl(const FirstSliceType & first, const SecondSliceType & second,\n {\n     if constexpr (search_type == ArraySearchType::Substr)\n         return sliceHasImplSubstr<FirstSliceType, SecondSliceType, isEqual, isEqualSecond>(first, second, first_null_map, second_null_map);\n+    else if constexpr (search_type == ArraySearchType::StartsWith || search_type == ArraySearchType::EndsWith)\n+        return sliceHasImplStartsEndsWith<search_type, FirstSliceType, SecondSliceType, isEqual>(first, second, first_null_map, second_null_map);\n     else\n         return sliceHasImplAnyAll<search_type, FirstSliceType, SecondSliceType, isEqual>(first, second, first_null_map, second_null_map);\n }\ndiff --git a/src/Functions/GatherUtils/GatherUtils.h b/src/Functions/GatherUtils/GatherUtils.h\nindex 8a623caa2978..52a01b6ff625 100644\n--- a/src/Functions/GatherUtils/GatherUtils.h\n+++ b/src/Functions/GatherUtils/GatherUtils.h\n@@ -34,7 +34,9 @@ enum class ArraySearchType\n {\n     Any, // Corresponds to the hasAny array function\n     All, // Corresponds to the hasAll array function\n-    Substr // Corresponds to the hasSubstr array function\n+    Substr, // Corresponds to the hasSubstr array function\n+    StartsWith,\n+    EndsWith\n };\n \n std::unique_ptr<IArraySource> createArraySource(const ColumnArray & col, bool is_const, size_t total_rows);\n@@ -58,6 +60,8 @@ ColumnArray::MutablePtr sliceFromRightDynamicLength(IArraySource & src, const IC\n void sliceHasAny(IArraySource & first, IArraySource & second, ColumnUInt8 & result);\n void sliceHasAll(IArraySource & first, IArraySource & second, ColumnUInt8 & result);\n void sliceHasSubstr(IArraySource & first, IArraySource & second, ColumnUInt8 & result);\n+void sliceHasStartsWith(IArraySource & first, IArraySource & second, ColumnUInt8 & result);\n+void sliceHasEndsWith(IArraySource & first, IArraySource & second, ColumnUInt8 & result);\n \n inline void sliceHas(IArraySource & first, IArraySource & second, ArraySearchType search_type, ColumnUInt8 & result)\n {\n@@ -72,7 +76,12 @@ inline void sliceHas(IArraySource & first, IArraySource & second, ArraySearchTyp\n         case ArraySearchType::Substr:\n             sliceHasSubstr(first, second, result);\n             break;\n-\n+        case ArraySearchType::StartsWith:\n+            sliceHasStartsWith(first, second, result);\n+            break;\n+        case ArraySearchType::EndsWith:\n+            sliceHasEndsWith(first, second, result);\n+            break;\n     }\n }\n \ndiff --git a/src/Functions/GatherUtils/ends_with.cpp b/src/Functions/GatherUtils/ends_with.cpp\nnew file mode 100644\nindex 000000000000..579d903005a6\n--- /dev/null\n+++ b/src/Functions/GatherUtils/ends_with.cpp\n@@ -0,0 +1,71 @@\n+#include \"GatherUtils.h\"\n+#include \"Selectors.h\"\n+#include \"Algorithms.h\"\n+\n+namespace DB::GatherUtils\n+{\n+\n+namespace\n+{\n+\n+struct ArrayEndsWithSelectArraySourcePair : public ArraySourcePairSelector<ArrayEndsWithSelectArraySourcePair>\n+{\n+    template <typename FirstSource, typename SecondSource>\n+    static void callFunction(FirstSource && first,\n+                             bool is_second_const, bool is_second_nullable, SecondSource && second,\n+                             ColumnUInt8 & result)\n+    {\n+        using SourceType = typename std::decay<SecondSource>::type;\n+\n+        if (is_second_nullable)\n+        {\n+            using NullableSource = NullableArraySource<SourceType>;\n+\n+            if (is_second_const)\n+                arrayAllAny<ArraySearchType::EndsWith>(first, static_cast<ConstSource<NullableSource> &>(second), result);\n+            else\n+                arrayAllAny<ArraySearchType::EndsWith>(first, static_cast<NullableSource &>(second), result);\n+        }\n+        else\n+        {\n+            if (is_second_const)\n+                arrayAllAny<ArraySearchType::EndsWith>(first, static_cast<ConstSource<SourceType> &>(second), result);\n+            else\n+                arrayAllAny<ArraySearchType::EndsWith>(first, second, result);\n+        }\n+    }\n+\n+    template <typename FirstSource, typename SecondSource>\n+    static void selectSourcePair(bool is_first_const, bool is_first_nullable, FirstSource && first,\n+                                 bool is_second_const, bool is_second_nullable, SecondSource && second,\n+                                 ColumnUInt8 & result)\n+    {\n+        using SourceType = typename std::decay<FirstSource>::type;\n+\n+        if (is_first_nullable)\n+        {\n+            using NullableSource = NullableArraySource<SourceType>;\n+\n+            if (is_first_const)\n+                callFunction(static_cast<ConstSource<NullableSource> &>(first), is_second_const, is_second_nullable, second, result);\n+            else\n+                callFunction(static_cast<NullableSource &>(first), is_second_const, is_second_nullable, second, result);\n+        }\n+        else\n+        {\n+            if (is_first_const)\n+                callFunction(static_cast<ConstSource<SourceType> &>(first), is_second_const, is_second_nullable, second, result);\n+            else\n+                callFunction(first, is_second_const, is_second_nullable, second, result);\n+        }\n+    }\n+};\n+\n+}\n+\n+void sliceHasEndsWith(IArraySource & first, IArraySource & second, ColumnUInt8 & result)\n+{\n+    ArrayEndsWithSelectArraySourcePair::select(first, second, result);\n+}\n+\n+}\ndiff --git a/src/Functions/GatherUtils/starts_with.cpp b/src/Functions/GatherUtils/starts_with.cpp\nnew file mode 100644\nindex 000000000000..813294bc0922\n--- /dev/null\n+++ b/src/Functions/GatherUtils/starts_with.cpp\n@@ -0,0 +1,71 @@\n+#include \"GatherUtils.h\"\n+#include \"Selectors.h\"\n+#include \"Algorithms.h\"\n+\n+namespace DB::GatherUtils\n+{\n+\n+namespace\n+{\n+\n+struct ArrayStartsWithSelectArraySourcePair : public ArraySourcePairSelector<ArrayStartsWithSelectArraySourcePair>\n+{\n+    template <typename FirstSource, typename SecondSource>\n+    static void callFunction(FirstSource && first,\n+                             bool is_second_const, bool is_second_nullable, SecondSource && second,\n+                             ColumnUInt8 & result)\n+    {\n+        using SourceType = typename std::decay<SecondSource>::type;\n+\n+        if (is_second_nullable)\n+        {\n+            using NullableSource = NullableArraySource<SourceType>;\n+\n+            if (is_second_const)\n+                arrayAllAny<ArraySearchType::StartsWith>(first, static_cast<ConstSource<NullableSource> &>(second), result);\n+            else\n+                arrayAllAny<ArraySearchType::StartsWith>(first, static_cast<NullableSource &>(second), result);\n+        }\n+        else\n+        {\n+            if (is_second_const)\n+                arrayAllAny<ArraySearchType::StartsWith>(first, static_cast<ConstSource<SourceType> &>(second), result);\n+            else\n+                arrayAllAny<ArraySearchType::StartsWith>(first, second, result);\n+        }\n+    }\n+\n+    template <typename FirstSource, typename SecondSource>\n+    static void selectSourcePair(bool is_first_const, bool is_first_nullable, FirstSource && first,\n+                                 bool is_second_const, bool is_second_nullable, SecondSource && second,\n+                                 ColumnUInt8 & result)\n+    {\n+        using SourceType = typename std::decay<FirstSource>::type;\n+\n+        if (is_first_nullable)\n+        {\n+            using NullableSource = NullableArraySource<SourceType>;\n+\n+            if (is_first_const)\n+                callFunction(static_cast<ConstSource<NullableSource> &>(first), is_second_const, is_second_nullable, second, result);\n+            else\n+                callFunction(static_cast<NullableSource &>(first), is_second_const, is_second_nullable, second, result);\n+        }\n+        else\n+        {\n+            if (is_first_const)\n+                callFunction(static_cast<ConstSource<SourceType> &>(first), is_second_const, is_second_nullable, second, result);\n+            else\n+                callFunction(first, is_second_const, is_second_nullable, second, result);\n+        }\n+    }\n+};\n+\n+}\n+\n+void sliceHasStartsWith(IArraySource & first, IArraySource & second, ColumnUInt8 & result)\n+{\n+    ArrayStartsWithSelectArraySourcePair::select(first, second, result);\n+}\n+\n+}\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02206_array_starts_ends_with.reference b/tests/queries/0_stateless/02206_array_starts_ends_with.reference\nnew file mode 100644\nindex 000000000000..e0dacfc06e04\n--- /dev/null\n+++ b/tests/queries/0_stateless/02206_array_starts_ends_with.reference\n@@ -0,0 +1,30 @@\n+1\n+1\n+0\n+-\n+1\n+1\n+0\n+1\n+0\n+-\n+1\n+0\n+1\n+0\n+-\n+1\n+1\n+0\n+-\n+1\n+1\n+0\n+1\n+0\n+-\n+1\n+0\n+-\n+1\n+1\ndiff --git a/tests/queries/0_stateless/02206_array_starts_ends_with.sql b/tests/queries/0_stateless/02206_array_starts_ends_with.sql\nnew file mode 100644\nindex 000000000000..39b02c29dc02\n--- /dev/null\n+++ b/tests/queries/0_stateless/02206_array_starts_ends_with.sql\n@@ -0,0 +1,36 @@\n+select startsWith([], []);\n+select startsWith([1], []);\n+select startsWith([], [1]);\n+select '-'; \n+\n+select startsWith([NULL], [NULL]);\n+select startsWith([NULL], []);\n+select startsWith([], [NULL]);\n+select startsWith([NULL, 1], [NULL]);\n+select startsWith([NULL, 1], [1]);\n+select '-'; \n+\n+select startsWith([1, 2, 3, 4], [1, 2, 3]);\n+select startsWith([1, 2, 3, 4], [1, 2, 4]);\n+select startsWith(['a', 'b', 'c'], ['a', 'b']);\n+select startsWith(['a', 'b', 'c'], ['b']);\n+select '-'; \n+\n+select endsWith([], []);\n+select endsWith([1], []);\n+select endsWith([], [1]);\n+select '-'; \n+\n+select endsWith([NULL], [NULL]);\n+select endsWith([NULL], []);\n+select endsWith([], [NULL]);\n+select endsWith([1, NULL], [NULL]);\n+select endsWith([NULL, 1], [NULL]);\n+select '-'; \n+\n+select endsWith([1, 2, 3, 4], [3, 4]);\n+select endsWith([1, 2, 3, 4], [3]);\n+select '-'; \n+\n+select startsWith([1], emptyArrayUInt8());\n+select endsWith([1], emptyArrayUInt8());\n",
  "problem_statement": "startsWith function for arrays\nSupport for arrays in `startsWith` (and, maybe, `endsWith`)\r\n\r\n**Use case**\r\n\r\nWould be quite useful for handling tree-like structured data where the node paths are specified as arrays of names or IDs.\r\n\r\n**Describe the solution you'd like**\r\n\r\nThe desired behavior would be like this:\r\n```\r\nstartsWith([1, 2, 3, 4], [1, 2])  -- true (1)\r\nstartsWith(['qwe', 'rty', 'ui', 'op'], ['qwe', 'rty'])  -- true (1)\r\nstartsWith([1, 2, 3, 4], [2, 4])  -- false (0)\r\nstartsWith([1, 1, 2, 2], [1, 2])  -- false (0)\r\n```\r\n\r\nAnd similarly, for `endsWith`\r\n\r\n**Describe alternatives you've considered**\r\n\r\nSomething like `arraySlice(first, 1, length(second)) = second`\r\n\r\nBut `startsWith` would be much more readable, harder to make a mistake in and, probably, can be better optimized (i.e. might not have to create new objects like `arraySlice` does)\n",
  "hints_text": "Also, please, consider that since version 21.10 you can create the SQL UDF:\r\n```sql\r\n\r\nCREATE FUNCTION arrayStartsWith AS (first, second) -> (arraySlice(first, 1, length(second)) = second);\r\n\r\nSELECT arrayStartsWith([1, 2, 3, 4], [1, 2]);\r\n\r\nSELECT arrayStartsWith([1, 2, 3, 4], [1, 1]);\r\n```\r\n\r\nIt solves the usability problem, but of course performance is still suboptimal.\r\n\nThanks for the suggestion!\r\nHowever, in my case I'm not sure it would really help, as I need a solution that would work with read-only access.\nYes, this makes sense. Can be solved with reusing `GatherUtils`.\r\nThe code is quite template-heavy, but it is not too hard to implement.\nCan I take this?\n@usurai Sure, it's yours!",
  "created_at": "2022-02-07T07:34:27Z"
}