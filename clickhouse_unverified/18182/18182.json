{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 18182,
  "instance_id": "ClickHouse__ClickHouse-18182",
  "issue_numbers": [
    "17712"
  ],
  "base_commit": "0d9519a0a2ca464e752b2593f7b061cb63eca4a4",
  "patch": "diff --git a/src/Processors/Formats/IRowInputFormat.cpp b/src/Processors/Formats/IRowInputFormat.cpp\nindex f8a14722d192..a6c66f1cacc4 100644\n--- a/src/Processors/Formats/IRowInputFormat.cpp\n+++ b/src/Processors/Formats/IRowInputFormat.cpp\n@@ -53,18 +53,20 @@ Chunk IRowInputFormat::generate()\n     ///auto chunk_missing_values = std::make_unique<ChunkMissingValues>();\n     block_missing_values.clear();\n \n+    size_t num_rows = 0;\n+\n     try\n     {\n         RowReadExtension info;\n-        for (size_t rows = 0; rows < params.max_block_size; ++rows)\n+        bool continue_reading = true;\n+        for (size_t rows = 0; rows < params.max_block_size && continue_reading; ++rows)\n         {\n             try\n             {\n                 ++total_rows;\n \n                 info.read_columns.clear();\n-                if (!readRow(columns, info))\n-                    break;\n+                continue_reading = readRow(columns, info);\n \n                 for (size_t column_idx = 0; column_idx < info.read_columns.size(); ++column_idx)\n                 {\n@@ -76,6 +78,18 @@ Chunk IRowInputFormat::generate()\n                         block_missing_values.setBit(column_idx, column_size - 1);\n                     }\n                 }\n+\n+                /// Some formats may read row AND say the read is finished.\n+                /// For such a case, get the number or rows from first column.\n+                if (!columns.empty())\n+                    num_rows = columns.front()->size();\n+\n+                if (!continue_reading)\n+                    break;\n+\n+                /// The case when there is no columns. Just count rows.\n+                if (columns.empty())\n+                    ++num_rows;\n             }\n             catch (Exception & e)\n             {\n@@ -107,17 +121,13 @@ Chunk IRowInputFormat::generate()\n \n                 syncAfterError();\n \n-                /// Truncate all columns in block to minimal size (remove values, that was appended to only part of columns).\n-\n-                size_t min_size = std::numeric_limits<size_t>::max();\n-                for (size_t column_idx = 0; column_idx < num_columns; ++column_idx)\n-                    min_size = std::min(min_size, columns[column_idx]->size());\n+                /// Truncate all columns in block to initial size (remove values, that was appended to only part of columns).\n \n                 for (size_t column_idx = 0; column_idx < num_columns; ++column_idx)\n                 {\n                     auto & column = columns[column_idx];\n-                    if (column->size() > min_size)\n-                        column->popBack(column->size() - min_size);\n+                    if (column->size() > num_rows)\n+                        column->popBack(column->size() - num_rows);\n                 }\n             }\n         }\n@@ -157,7 +167,6 @@ Chunk IRowInputFormat::generate()\n         return {};\n     }\n \n-    auto num_rows = columns.front()->size();\n     Chunk chunk(std::move(columns), num_rows);\n     //chunk.setChunkInfo(std::move(chunk_missing_values));\n     return chunk;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01355_CSV_input_format_allow_errors.reference b/tests/queries/0_stateless/01355_CSV_input_format_allow_errors.reference\nindex 5d20150fdc1a..f7c4f677e9aa 100644\n--- a/tests/queries/0_stateless/01355_CSV_input_format_allow_errors.reference\n+++ b/tests/queries/0_stateless/01355_CSV_input_format_allow_errors.reference\n@@ -20,9 +20,7 @@ attempt to parse with input_format_allow_errors_ratio=0.3\n 1\t0\n 2\t0\n 3\t0\n-4\t0\n 5\t0\n-6\t0\n Return code: 0\n ******************\n attempt to parse with input_format_allow_errors_num=1\n@@ -34,7 +32,5 @@ attempt to parse with input_format_allow_errors_num=2\n 1\t0\n 2\t0\n 3\t0\n-4\t0\n 5\t0\n-6\t0\n Return code: 0\ndiff --git a/tests/queries/0_stateless/01355_CSV_input_format_allow_errors.sh b/tests/queries/0_stateless/01355_CSV_input_format_allow_errors.sh\nindex 63207c7f4a8b..7ae77eb9f0cb 100755\n--- a/tests/queries/0_stateless/01355_CSV_input_format_allow_errors.sh\n+++ b/tests/queries/0_stateless/01355_CSV_input_format_allow_errors.sh\n@@ -11,34 +11,34 @@ cat \"$SAMPLE_FILE\"\n \n echo '******************'\n echo 'attempt to parse w/o flags'\n-cat \"$SAMPLE_FILE\" | clickhouse-local --input-format=CSV --structure='num1 Int64, num2 Int64' --query='SELECT * from table' 2>\"$STD_ERROR_CAPTURED\"\n+cat \"$SAMPLE_FILE\" | ${CLICKHOUSE_LOCAL} --input-format=CSV --structure='num1 Int64, num2 Int64' --query='SELECT * from table' 2>\"$STD_ERROR_CAPTURED\"\n echo \"Return code: $?\"\n expected_error_message='is not like Int64'\n cat \"$STD_ERROR_CAPTURED\" | grep -q \"$expected_error_message\" && echo \"OK: stderr contains a message '$expected_error_message'\" || echo \"FAILED: Error message is wrong\"\n \n echo '******************'\n echo 'attempt to parse with input_format_allow_errors_ratio=0.1'\n-cat \"$SAMPLE_FILE\" | clickhouse-local --input-format=CSV --structure='num1 Int64, num2 Int64' --query='SELECT * from table' --input_format_allow_errors_ratio=0.1 2>\"$STD_ERROR_CAPTURED\"\n+cat \"$SAMPLE_FILE\" | ${CLICKHOUSE_LOCAL} --input-format=CSV --structure='num1 Int64, num2 Int64' --query='SELECT * from table' --input_format_allow_errors_ratio=0.1 2>\"$STD_ERROR_CAPTURED\"\n echo \"Return code: $?\"\n expected_error_message='Already have 1 errors out of 5 rows, which is 0.2'\n cat \"$STD_ERROR_CAPTURED\" | grep -q \"$expected_error_message\" && echo \"OK: stderr contains a message '$expected_error_message'\" || echo \"FAILED: Error message is wrong\"\n \n echo '******************'\n echo 'attempt to parse with input_format_allow_errors_ratio=0.3'\n-cat \"$SAMPLE_FILE\" | clickhouse-local --input-format=CSV --structure='num1 Int64, num2 Int64' --query='SELECT * from table' --input_format_allow_errors_ratio=0.3 2>\"$STD_ERROR_CAPTURED\"\n+cat \"$SAMPLE_FILE\" | ${CLICKHOUSE_LOCAL} --input-format=CSV --structure='num1 Int64, num2 Int64' --query='SELECT * from table' --input_format_allow_errors_ratio=0.3 2>\"$STD_ERROR_CAPTURED\"\n echo \"Return code: $?\"\n cat \"$STD_ERROR_CAPTURED\"\n \n echo '******************'\n echo 'attempt to parse with input_format_allow_errors_num=1'\n-cat \"$SAMPLE_FILE\" | clickhouse-local --input-format=CSV --structure='num1 Int64, num2 Int64' --query='SELECT * from table' --input_format_allow_errors_num=1 2>\"$STD_ERROR_CAPTURED\"\n+cat \"$SAMPLE_FILE\" | ${CLICKHOUSE_LOCAL} --input-format=CSV --structure='num1 Int64, num2 Int64' --query='SELECT * from table' --input_format_allow_errors_num=1 2>\"$STD_ERROR_CAPTURED\"\n echo \"Return code: $?\"\n expected_error_message='Already have 2 errors out of 7 rows'\n cat \"$STD_ERROR_CAPTURED\" | grep -q \"$expected_error_message\" && echo \"OK: stderr contains a message '$expected_error_message'\" || echo \"FAILED: Error message is wrong\"\n \n echo '******************'\n echo 'attempt to parse with input_format_allow_errors_num=2'\n-cat \"$SAMPLE_FILE\" | clickhouse-local --input-format=CSV --structure='num1 Int64, num2 Int64' --query='SELECT * from table' --input_format_allow_errors_num=2 2>\"$STD_ERROR_CAPTURED\"\n+cat \"$SAMPLE_FILE\" | ${CLICKHOUSE_LOCAL} --input-format=CSV --structure='num1 Int64, num2 Int64' --query='SELECT * from table' --input_format_allow_errors_num=2 2>\"$STD_ERROR_CAPTURED\"\n echo \"Return code: $?\"\n cat \"$STD_ERROR_CAPTURED\"\n \n",
  "problem_statement": "When doing CSV format loading test, the skipped rows may be inserted successfully in case of the bad data from the last column\n(you don't have to strictly follow this form)\r\n\r\n**Describe the bug**\r\nWrongly insert the skipped error data row into the table when the bad data is for the last column.\r\nIn the example, (1,a) was wrongly inserted, but (a,1) was not.\r\n\r\n**How to reproduce**\r\n1. Create table\r\ncreate table t (a int, b int) engine=Memory;\r\n\r\n2. Faked CSV format data\r\n1,a\r\na,1\r\n1,1\r\n\r\n3. use clickhouse-client to import data\r\n1) If no skip error\uff0c the row (1,a) failed with error and didn't insert into the target table.\r\n# clickhouse-client --query=\"INSERT INTO t(a,b) FORMAT CSV\" <data.csv\r\nCode: 117. DB::Exception: Expected end of line: (at row 1)\r\n\r\nRow 1:\r\nColumn 0,   name: a, type: Int32, parsed text: \"1\"\r\nColumn 1,   name: b, type: Int32, ERROR: text \"a<LINE FEED>a,1<LINE FEED>1,1<LINE FEED>\" is not like Int32\r\n\r\n: data for INSERT was parsed from stdin\r\n\r\n2). If use input_format_allow_errors_num, the bad row(1,a) was inserted into table, with values (1,0).\r\n# clickhouse-client --input_format_allow_errors_num 2 --query=\"INSERT INTO t(a,b) FORMAT CSV\" <data.csv\r\n\r\nselect * from t;\r\n\r\nSELECT *\r\nFROM t\r\n\r\nQuery id: c0482b5f-78e9-4fdf-aee2-a7c7e287c394\r\n\r\n\u250c\u2500a\u2500\u252c\u2500b\u2500\u2510\r\n\u2502 1 \u2502 0 \u2502  <<<< Is this wrong or not?\r\n\u2502 1 \u2502 1 \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\r\n\r\n2 rows in set. Elapsed: 0.002 sec.\r\n\r\n* Which ClickHouse server version to use\r\n20.13.1.5273\r\n\r\n* `CREATE TABLE` statements for all tables involved\r\ncreate table t (a int, b int) engine=Memory;\r\n\r\n* Sample data for all these tables, use [clickhouse-obfuscator]\r\ncat data.csv\r\n1,a\r\na,1\r\n1,1\r\n\r\n* Queries to run that lead to unexpected result\r\nclickhouse-client --input_format_allow_errors_num 2 --query=\"INSERT INTO t(a,b) FORMAT CSV\" <data.csv\r\n\r\n**Expected behavior**\r\nThe bad row #1 in CSV format (1,a) should not be inserted into the target table.\r\n\r\n**Error message and/or stacktrace**\r\n# clickhouse-client --query=\"INSERT INTO t(a,b) FORMAT CSV\" <data.csv\r\nCode: 117. DB::Exception: Expected end of line: (at row 1)\r\n\r\nRow 1:\r\nColumn 0,   name: a, type: Int32, parsed text: \"1\"\r\nColumn 1,   name: b, type: Int32, ERROR: text \"a<LINE FEED>a,1<LINE FEED>1,1<LINE FEED>\" is not like Int32\r\n\r\n**Additional context**\r\nAdd any other context about the problem here.\r\n\n",
  "hints_text": "",
  "created_at": "2020-12-17T06:29:51Z"
}