diff --git a/src/Processors/Formats/IRowInputFormat.cpp b/src/Processors/Formats/IRowInputFormat.cpp
index f8a14722d192..a6c66f1cacc4 100644
--- a/src/Processors/Formats/IRowInputFormat.cpp
+++ b/src/Processors/Formats/IRowInputFormat.cpp
@@ -53,18 +53,20 @@ Chunk IRowInputFormat::generate()
     ///auto chunk_missing_values = std::make_unique<ChunkMissingValues>();
     block_missing_values.clear();
 
+    size_t num_rows = 0;
+
     try
     {
         RowReadExtension info;
-        for (size_t rows = 0; rows < params.max_block_size; ++rows)
+        bool continue_reading = true;
+        for (size_t rows = 0; rows < params.max_block_size && continue_reading; ++rows)
         {
             try
             {
                 ++total_rows;
 
                 info.read_columns.clear();
-                if (!readRow(columns, info))
-                    break;
+                continue_reading = readRow(columns, info);
 
                 for (size_t column_idx = 0; column_idx < info.read_columns.size(); ++column_idx)
                 {
@@ -76,6 +78,18 @@ Chunk IRowInputFormat::generate()
                         block_missing_values.setBit(column_idx, column_size - 1);
                     }
                 }
+
+                /// Some formats may read row AND say the read is finished.
+                /// For such a case, get the number or rows from first column.
+                if (!columns.empty())
+                    num_rows = columns.front()->size();
+
+                if (!continue_reading)
+                    break;
+
+                /// The case when there is no columns. Just count rows.
+                if (columns.empty())
+                    ++num_rows;
             }
             catch (Exception & e)
             {
@@ -107,17 +121,13 @@ Chunk IRowInputFormat::generate()
 
                 syncAfterError();
 
-                /// Truncate all columns in block to minimal size (remove values, that was appended to only part of columns).
-
-                size_t min_size = std::numeric_limits<size_t>::max();
-                for (size_t column_idx = 0; column_idx < num_columns; ++column_idx)
-                    min_size = std::min(min_size, columns[column_idx]->size());
+                /// Truncate all columns in block to initial size (remove values, that was appended to only part of columns).
 
                 for (size_t column_idx = 0; column_idx < num_columns; ++column_idx)
                 {
                     auto & column = columns[column_idx];
-                    if (column->size() > min_size)
-                        column->popBack(column->size() - min_size);
+                    if (column->size() > num_rows)
+                        column->popBack(column->size() - num_rows);
                 }
             }
         }
@@ -157,7 +167,6 @@ Chunk IRowInputFormat::generate()
         return {};
     }
 
-    auto num_rows = columns.front()->size();
     Chunk chunk(std::move(columns), num_rows);
     //chunk.setChunkInfo(std::move(chunk_missing_values));
     return chunk;
