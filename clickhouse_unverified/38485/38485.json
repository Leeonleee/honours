{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 38485,
  "instance_id": "ClickHouse__ClickHouse-38485",
  "issue_numbers": [
    "38046"
  ],
  "base_commit": "fdd2db4aceac392e92665aefc4c74180d2bf9ad0",
  "patch": "diff --git a/src/Functions/FunctionsMultiStringFuzzySearch.h b/src/Functions/FunctionsMultiStringFuzzySearch.h\nindex 865a5d182c8f..26cafa7d4109 100644\n--- a/src/Functions/FunctionsMultiStringFuzzySearch.h\n+++ b/src/Functions/FunctionsMultiStringFuzzySearch.h\n@@ -46,7 +46,7 @@ class FunctionsMultiStringFuzzySearch : public IFunction\n     size_t getNumberOfArguments() const override { return 3; }\n     bool useDefaultImplementationForConstants() const override { return true; }\n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n-    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1, 2}; }\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n \n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n@@ -65,26 +65,30 @@ class FunctionsMultiStringFuzzySearch : public IFunction\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override\n     {\n-        const ColumnPtr & column_haystack = arguments[0].column;\n-        const ColumnPtr & num_ptr = arguments[1].column;\n-        const ColumnPtr & arr_ptr = arguments[2].column;\n+        const ColumnPtr & haystack_ptr = arguments[0].column;\n+        const ColumnPtr & edit_distance_ptr = arguments[1].column;\n+        const ColumnPtr & needles_ptr = arguments[2].column;\n \n-        const ColumnString * col_haystack_vector = checkAndGetColumn<ColumnString>(&*column_haystack);\n-        assert(col_haystack_vector); // getReturnTypeImpl() checks the data type\n+        const ColumnString * col_haystack_vector = checkAndGetColumn<ColumnString>(&*haystack_ptr);\n+        const ColumnConst * col_haystack_const = checkAndGetColumnConst<ColumnString>(&*haystack_ptr);\n+        assert(static_cast<bool>(col_haystack_vector) ^ static_cast<bool>(col_haystack_const));\n \n         UInt32 edit_distance = 0;\n-        if (const auto * col_const_uint8 = checkAndGetColumnConst<ColumnUInt8>(num_ptr.get()))\n+        if (const auto * col_const_uint8 = checkAndGetColumnConst<ColumnUInt8>(edit_distance_ptr.get()))\n             edit_distance = col_const_uint8->getValue<UInt8>();\n-        else if (const auto * col_const_uint16 = checkAndGetColumnConst<ColumnUInt16>(num_ptr.get()))\n+        else if (const auto * col_const_uint16 = checkAndGetColumnConst<ColumnUInt16>(edit_distance_ptr.get()))\n             edit_distance = col_const_uint16->getValue<UInt16>();\n-        else if (const auto * col_const_uint32 = checkAndGetColumnConst<ColumnUInt32>(num_ptr.get()))\n+        else if (const auto * col_const_uint32 = checkAndGetColumnConst<ColumnUInt32>(edit_distance_ptr.get()))\n             edit_distance = col_const_uint32->getValue<UInt32>();\n         else\n             throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {}. The number is not const or does not fit in UInt32\", arguments[1].column->getName());\n \n-        const ColumnConst * col_const_arr = checkAndGetColumnConst<ColumnArray>(arr_ptr.get());\n-        if (!col_const_arr)\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {}. The array is not const\", arguments[2].column->getName());\n+        const ColumnArray * col_needles_vector = checkAndGetColumn<ColumnArray>(needles_ptr.get());\n+        const ColumnConst * col_needles_const = checkAndGetColumnConst<ColumnArray>(needles_ptr.get());\n+        assert(static_cast<bool>(col_needles_vector) ^ static_cast<bool>(col_needles_const));\n+\n+        if (col_haystack_const && col_needles_vector)\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Function '{}' doesn't support search with non-constant needles in constant haystack\", name);\n \n         using ResultType = typename Impl::ResultType;\n         auto col_res = ColumnVector<ResultType>::create();\n@@ -92,12 +96,30 @@ class FunctionsMultiStringFuzzySearch : public IFunction\n \n         auto & vec_res = col_res->getData();\n         auto & offsets_res = col_offsets->getData();\n-        // the implementations are responsible for resizing the output column\n-\n-        Array needles_arr = col_const_arr->getValue<Array>();\n-        Impl::vectorConstant(\n-            col_haystack_vector->getChars(), col_haystack_vector->getOffsets(), needles_arr, vec_res, offsets_res, edit_distance,\n-            allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n+        /// the implementations are responsible for resizing the output column\n+\n+        if (col_needles_const)\n+        {\n+            Impl::vectorConstant(\n+                col_haystack_vector->getChars(), col_haystack_vector->getOffsets(),\n+                col_needles_const->getValue<Array>(),\n+                vec_res, offsets_res,\n+                edit_distance,\n+                allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n+        }\n+        else\n+        {\n+            Impl::vectorVector(\n+                col_haystack_vector->getChars(), col_haystack_vector->getOffsets(),\n+                col_needles_vector->getData(), col_needles_vector->getOffsets(),\n+                vec_res, offsets_res,\n+                edit_distance,\n+                allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n+        }\n+\n+        // the combination of const haystack + const needle is not implemented because\n+        // useDefaultImplementationForConstants() == true makes upper layers convert both to\n+        // non-const columns\n \n         if constexpr (Impl::is_column_array)\n             return ColumnArray::create(std::move(col_res), std::move(col_offsets));\ndiff --git a/src/Functions/FunctionsMultiStringSearch.h b/src/Functions/FunctionsMultiStringSearch.h\nindex 04235e0a97a5..fb800448bfae 100644\n--- a/src/Functions/FunctionsMultiStringSearch.h\n+++ b/src/Functions/FunctionsMultiStringSearch.h\n@@ -61,7 +61,6 @@ class FunctionsMultiStringSearch : public IFunction\n     size_t getNumberOfArguments() const override { return 2; }\n     bool useDefaultImplementationForConstants() const override { return true; }\n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n-    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n \n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n@@ -77,15 +76,19 @@ class FunctionsMultiStringSearch : public IFunction\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override\n     {\n-        const ColumnPtr & column_haystack = arguments[0].column;\n-        const ColumnPtr & arr_ptr = arguments[1].column;\n+        const ColumnPtr & haystack_ptr = arguments[0].column;\n+        const ColumnPtr & needles_ptr = arguments[1].column;\n \n-        const ColumnString * col_haystack_vector = checkAndGetColumn<ColumnString>(&*column_haystack);\n-        assert(col_haystack_vector); // getReturnTypeImpl() checks the data type\n+        const ColumnString * col_haystack_vector = checkAndGetColumn<ColumnString>(&*haystack_ptr);\n+        const ColumnConst * col_haystack_const = checkAndGetColumnConst<ColumnString>(&*haystack_ptr);\n+        assert(static_cast<bool>(col_haystack_vector) ^ static_cast<bool>(col_haystack_const));\n \n-        const ColumnConst * col_const_arr = checkAndGetColumnConst<ColumnArray>(arr_ptr.get());\n-        if (!col_const_arr)\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {}. The array is not const\", arguments[1].column->getName());\n+        const ColumnArray * col_needles_vector = checkAndGetColumn<ColumnArray>(needles_ptr.get());\n+        const ColumnConst * col_needles_const = checkAndGetColumnConst<ColumnArray>(needles_ptr.get());\n+        assert(static_cast<bool>(col_needles_vector) ^ static_cast<bool>(col_needles_const));\n+\n+        if (col_haystack_const && col_needles_vector)\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Function '{}' doesn't support search with non-constant needles in constant haystack\", name);\n \n         using ResultType = typename Impl::ResultType;\n         auto col_res = ColumnVector<ResultType>::create();\n@@ -93,12 +96,28 @@ class FunctionsMultiStringSearch : public IFunction\n \n         auto & vec_res = col_res->getData();\n         auto & offsets_res = col_offsets->getData();\n-        // the implementations are responsible for resizing the output column\n-\n-        Array needles_arr = col_const_arr->getValue<Array>();\n-        Impl::vectorConstant(\n-            col_haystack_vector->getChars(), col_haystack_vector->getOffsets(), needles_arr, vec_res, offsets_res,\n-            allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n+        /// the implementations are responsible for resizing the output column\n+\n+        if (col_needles_const)\n+        {\n+            Impl::vectorConstant(\n+                col_haystack_vector->getChars(), col_haystack_vector->getOffsets(),\n+                col_needles_const->getValue<Array>(),\n+                vec_res, offsets_res,\n+                allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n+        }\n+        else\n+        {\n+            Impl::vectorVector(\n+                col_haystack_vector->getChars(), col_haystack_vector->getOffsets(),\n+                col_needles_vector->getData(), col_needles_vector->getOffsets(),\n+                vec_res, offsets_res,\n+                allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n+        }\n+\n+        // the combination of const haystack + const needle is not implemented because\n+        // useDefaultImplementationForConstants() == true makes upper layers convert both to\n+        // non-const columns\n \n         if constexpr (Impl::is_column_array)\n             return ColumnArray::create(std::move(col_res), std::move(col_offsets));\ndiff --git a/src/Functions/MultiMatchAllIndicesImpl.h b/src/Functions/MultiMatchAllIndicesImpl.h\nindex 9c60dbffe91f..c6a8a4776485 100644\n--- a/src/Functions/MultiMatchAllIndicesImpl.h\n+++ b/src/Functions/MultiMatchAllIndicesImpl.h\n@@ -58,15 +58,15 @@ struct MultiMatchAllIndicesImpl\n     }\n \n     static void vectorConstant(\n-        [[maybe_unused]] const ColumnString::Chars & haystack_data,\n-        [[maybe_unused]] const ColumnString::Offsets & haystack_offsets,\n-        [[maybe_unused]] const Array & needles_arr,\n-        [[maybe_unused]] PaddedPODArray<ResultType> & res,\n-        [[maybe_unused]] PaddedPODArray<UInt64> & offsets,\n-        [[maybe_unused]] std::optional<UInt32> edit_distance,\n+        const ColumnString::Chars & haystack_data,\n+        const ColumnString::Offsets & haystack_offsets,\n+        const Array & needles_arr,\n+        PaddedPODArray<ResultType> & res,\n+        PaddedPODArray<UInt64> & offsets,\n+        std::optional<UInt32> edit_distance,\n         bool allow_hyperscan,\n-        [[maybe_unused]] size_t max_hyperscan_regexp_length,\n-        [[maybe_unused]] size_t max_hyperscan_regexp_total_length)\n+        size_t max_hyperscan_regexp_length,\n+        size_t max_hyperscan_regexp_total_length)\n     {\n         if (!allow_hyperscan)\n             throw Exception(ErrorCodes::FUNCTION_NOT_ALLOWED, \"Hyperscan functions are disabled, because setting 'allow_hyperscan' is set to 0\");\n@@ -79,6 +79,7 @@ struct MultiMatchAllIndicesImpl\n         checkHyperscanRegexp(needles, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n \n         offsets.resize(haystack_offsets.size());\n+\n         const auto & hyperscan_regex = MultiRegexps::get</*SaveIndices=*/true, WithEditDistance>(needles, edit_distance);\n         hs_scratch_t * scratch = nullptr;\n         hs_error_t err = hs_clone_scratch(hyperscan_regex->getScratch(), &scratch);\n@@ -102,10 +103,10 @@ struct MultiMatchAllIndicesImpl\n         for (size_t i = 0; i < haystack_offsets_size; ++i)\n         {\n             UInt64 length = haystack_offsets[i] - offset - 1;\n-            /// Hyperscan restriction.\n+            /// vectorscan restriction.\n             if (length > std::numeric_limits<UInt32>::max())\n                 throw Exception(\"Too long string to search\", ErrorCodes::TOO_MANY_BYTES);\n-            /// Scan, check, update the offsets array and the offset of haystack.\n+            /// scan, check, update the offsets array and the offset of haystack.\n             err = hs_scan(\n                 hyperscan_regex->getDB(),\n                 reinterpret_cast<const char *>(haystack_data.data()) + offset,\n@@ -120,6 +121,121 @@ struct MultiMatchAllIndicesImpl\n             offset = haystack_offsets[i];\n         }\n #else\n+        (void)haystack_data;\n+        (void)haystack_offsets;\n+        (void)needles_arr;\n+        (void)res;\n+        (void)offsets;\n+        (void)edit_distance;\n+        (void)max_hyperscan_regexp_length;\n+        (void)max_hyperscan_regexp_total_length;\n+        throw Exception(\n+            \"multi-search all indices is not implemented when vectorscan is off\",\n+            ErrorCodes::NOT_IMPLEMENTED);\n+#endif // USE_VECTORSCAN\n+    }\n+\n+    static void vectorVector(\n+        const ColumnString::Chars & haystack_data,\n+        const ColumnString::Offsets & haystack_offsets,\n+        const IColumn & needles_data,\n+        const ColumnArray::Offsets & needles_offsets,\n+        PaddedPODArray<ResultType> & res,\n+        PaddedPODArray<UInt64> & offsets,\n+        bool allow_hyperscan,\n+        size_t max_hyperscan_regexp_length,\n+        size_t max_hyperscan_regexp_total_length)\n+    {\n+        vectorVector(haystack_data, haystack_offsets, needles_data, needles_offsets, res, offsets, std::nullopt, allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n+    }\n+\n+    static void vectorVector(\n+        const ColumnString::Chars & haystack_data,\n+        const ColumnString::Offsets & haystack_offsets,\n+        const IColumn & needles_data,\n+        const ColumnArray::Offsets & needles_offsets,\n+        PaddedPODArray<ResultType> & res,\n+        PaddedPODArray<UInt64> & offsets,\n+        std::optional<UInt32> edit_distance,\n+        bool allow_hyperscan,\n+        size_t max_hyperscan_regexp_length,\n+        size_t max_hyperscan_regexp_total_length)\n+    {\n+        if (!allow_hyperscan)\n+            throw Exception(ErrorCodes::FUNCTION_NOT_ALLOWED, \"Hyperscan functions are disabled, because setting 'allow_hyperscan' is set to 0\");\n+#if USE_VECTORSCAN\n+        offsets.resize(haystack_offsets.size());\n+        size_t prev_haystack_offset = 0;\n+        size_t prev_needles_offset = 0;\n+\n+        const ColumnString * needles_data_string = checkAndGetColumn<ColumnString>(&needles_data);\n+\n+        std::vector<std::string_view> needles;\n+\n+        for (size_t i = 0; i < haystack_offsets.size(); ++i)\n+        {\n+            needles.reserve(needles_offsets[i] - prev_needles_offset);\n+\n+            for (size_t j = prev_needles_offset; j < needles_offsets[i]; ++j)\n+            {\n+                needles.emplace_back(needles_data_string->getDataAt(j).toView());\n+            }\n+\n+            checkHyperscanRegexp(needles, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n+\n+            const auto & hyperscan_regex = MultiRegexps::get</*SaveIndices=*/true, WithEditDistance>(needles, edit_distance);\n+            hs_scratch_t * scratch = nullptr;\n+            hs_error_t err = hs_clone_scratch(hyperscan_regex->getScratch(), &scratch);\n+\n+            if (err != HS_SUCCESS)\n+                throw Exception(\"Could not clone scratch space for hyperscan\", ErrorCodes::CANNOT_ALLOCATE_MEMORY);\n+\n+            MultiRegexps::ScratchPtr smart_scratch(scratch);\n+\n+            auto on_match = [](unsigned int id,\n+                               unsigned long long /* from */, // NOLINT\n+                               unsigned long long /* to */, // NOLINT\n+                               unsigned int /* flags */,\n+                               void * context) -> int\n+            {\n+                static_cast<PaddedPODArray<ResultType>*>(context)->push_back(id);\n+                return 0;\n+            };\n+\n+            const size_t cur_haystack_length = haystack_offsets[i] - prev_haystack_offset - 1;\n+\n+            /// vectorscan restriction.\n+            if (cur_haystack_length > std::numeric_limits<UInt32>::max())\n+                throw Exception(\"Too long string to search\", ErrorCodes::TOO_MANY_BYTES);\n+\n+            /// scan, check, update the offsets array and the offset of haystack.\n+            err = hs_scan(\n+                hyperscan_regex->getDB(),\n+                reinterpret_cast<const char *>(haystack_data.data()) + prev_haystack_offset,\n+                cur_haystack_length,\n+                0,\n+                smart_scratch.get(),\n+                on_match,\n+                &res);\n+            if (err != HS_SUCCESS)\n+                throw Exception(\"Failed to scan with vectorscan\", ErrorCodes::HYPERSCAN_CANNOT_SCAN_TEXT);\n+\n+            offsets[i] = res.size();\n+\n+            prev_haystack_offset = haystack_offsets[i];\n+            prev_needles_offset = needles_offsets[i];\n+            needles.clear();\n+        }\n+#else\n+        (void)haystack_data;\n+        (void)haystack_offsets;\n+        (void)needles_data;\n+        (void)needles_offsets;\n+        (void)res;\n+        (void)offsets;\n+        (void)edit_distance;\n+        (void)max_hyperscan_regexp_length;\n+        (void)max_hyperscan_regexp_total_length;\n         throw Exception(\n             \"multi-search all indices is not implemented when vectorscan is off\",\n             ErrorCodes::NOT_IMPLEMENTED);\ndiff --git a/src/Functions/MultiMatchAnyImpl.h b/src/Functions/MultiMatchAnyImpl.h\nindex 0752e87e8afb..38b1e37eca55 100644\n--- a/src/Functions/MultiMatchAnyImpl.h\n+++ b/src/Functions/MultiMatchAnyImpl.h\n@@ -14,6 +14,7 @@\n #    include <hs.h>\n #else\n #    include \"MatchImpl.h\"\n+    #include <Common/Volnitsky.h>\n #endif\n \n \n@@ -29,7 +30,7 @@ namespace ErrorCodes\n     extern const int TOO_MANY_BYTES;\n }\n \n-// For more readable instantiations of MultiMatchAnyImpl<>\n+/// For more readable instantiations of MultiMatchAnyImpl<>\n struct MultiMatchTraits\n {\n enum class Find\n@@ -75,7 +76,7 @@ struct MultiMatchAnyImpl\n         const ColumnString::Offsets & haystack_offsets,\n         const Array & needles_arr,\n         PaddedPODArray<ResultType> & res,\n-        [[maybe_unused]] PaddedPODArray<UInt64> & offsets,\n+        PaddedPODArray<UInt64> & /*offsets*/,\n         [[maybe_unused]] std::optional<UInt32> edit_distance,\n         bool allow_hyperscan,\n         size_t max_hyperscan_regexp_length,\n@@ -93,7 +94,7 @@ struct MultiMatchAnyImpl\n \n         res.resize(haystack_offsets.size());\n #if USE_VECTORSCAN\n-        const auto & hyperscan_regex = MultiRegexps::get<FindAnyIndex, WithEditDistance>(needles, edit_distance);\n+        const auto & hyperscan_regex = MultiRegexps::get</*SaveIndices*/ FindAnyIndex, WithEditDistance>(needles, edit_distance);\n         hs_scratch_t * scratch = nullptr;\n         hs_error_t err = hs_clone_scratch(hyperscan_regex->getScratch(), &scratch);\n \n@@ -120,10 +121,10 @@ struct MultiMatchAnyImpl\n         for (size_t i = 0; i < haystack_offsets_size; ++i)\n         {\n             UInt64 length = haystack_offsets[i] - offset - 1;\n-            /// Vectorscan restriction.\n+            /// vectorscan restriction.\n             if (length > std::numeric_limits<UInt32>::max())\n                 throw Exception(\"Too long string to search\", ErrorCodes::TOO_MANY_BYTES);\n-            /// Zero the result, scan, check, update the offset.\n+            /// zero the result, scan, check, update the offset.\n             res[i] = 0;\n             err = hs_scan(\n                 hyperscan_regex->getDB(),\n@@ -138,7 +139,7 @@ struct MultiMatchAnyImpl\n             offset = haystack_offsets[i];\n         }\n #else\n-        // fallback if vectorscan is not compiled\n+        /// fallback if vectorscan is not compiled\n         if constexpr (WithEditDistance)\n             throw Exception(\n                 \"Edit distance multi-search is not implemented when vectorscan is off\",\n@@ -157,6 +158,218 @@ struct MultiMatchAnyImpl\n                     res[i] = j + 1;\n             }\n         }\n+#endif // USE_VECTORSCAN\n+    }\n+\n+    static void vectorVector(\n+        const ColumnString::Chars & haystack_data,\n+        const ColumnString::Offsets & haystack_offsets,\n+        const IColumn & needles_data,\n+        const ColumnArray::Offsets & needles_offsets,\n+        PaddedPODArray<ResultType> & res,\n+        PaddedPODArray<UInt64> & offsets,\n+        bool allow_hyperscan,\n+        size_t max_hyperscan_regexp_length,\n+        size_t max_hyperscan_regexp_total_length)\n+    {\n+        vectorVector(haystack_data, haystack_offsets, needles_data, needles_offsets, res, offsets, std::nullopt, allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n+    }\n+\n+    static void vectorVector(\n+        const ColumnString::Chars & haystack_data,\n+        const ColumnString::Offsets & haystack_offsets,\n+        const IColumn & needles_data,\n+        const ColumnArray::Offsets & needles_offsets,\n+        PaddedPODArray<ResultType> & res,\n+        PaddedPODArray<UInt64> & /*offsets*/,\n+        std::optional<UInt32> edit_distance,\n+        bool allow_hyperscan,\n+        size_t max_hyperscan_regexp_length,\n+        size_t max_hyperscan_regexp_total_length)\n+    {\n+        if (!allow_hyperscan)\n+            throw Exception(ErrorCodes::FUNCTION_NOT_ALLOWED, \"Hyperscan functions are disabled, because setting 'allow_hyperscan' is set to 0\");\n+\n+        res.resize(haystack_offsets.size());\n+#if USE_VECTORSCAN\n+        size_t prev_haystack_offset = 0;\n+        size_t prev_needles_offset = 0;\n+\n+        const ColumnString * needles_data_string = checkAndGetColumn<ColumnString>(&needles_data);\n+\n+        std::vector<std::string_view> needles;\n+\n+        for (size_t i = 0; i < haystack_offsets.size(); ++i)\n+        {\n+            needles.reserve(needles_offsets[i] - prev_needles_offset);\n+\n+            for (size_t j = prev_needles_offset; j < needles_offsets[i]; ++j)\n+            {\n+                needles.emplace_back(needles_data_string->getDataAt(j).toView());\n+            }\n+\n+            checkHyperscanRegexp(needles, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n+\n+            const auto & hyperscan_regex = MultiRegexps::get</*SaveIndices*/ FindAnyIndex, WithEditDistance>(needles, edit_distance);\n+            hs_scratch_t * scratch = nullptr;\n+            hs_error_t err = hs_clone_scratch(hyperscan_regex->getScratch(), &scratch);\n+\n+            if (err != HS_SUCCESS)\n+                throw Exception(\"Could not clone scratch space for vectorscan\", ErrorCodes::CANNOT_ALLOCATE_MEMORY);\n+\n+            MultiRegexps::ScratchPtr smart_scratch(scratch);\n+\n+            auto on_match = []([[maybe_unused]] unsigned int id,\n+                               unsigned long long /* from */, // NOLINT\n+                               unsigned long long /* to */, // NOLINT\n+                               unsigned int /* flags */,\n+                               void * context) -> int\n+            {\n+                if constexpr (FindAnyIndex)\n+                    *reinterpret_cast<ResultType *>(context) = id;\n+                else if constexpr (FindAny)\n+                    *reinterpret_cast<ResultType *>(context) = 1;\n+                /// Once we hit the callback, there is no need to search for others.\n+                return 1;\n+            };\n+\n+            const size_t cur_haystack_length = haystack_offsets[i] - prev_haystack_offset - 1;\n+\n+            /// vectorscan restriction.\n+            if (cur_haystack_length > std::numeric_limits<UInt32>::max())\n+                throw Exception(\"Too long string to search\", ErrorCodes::TOO_MANY_BYTES);\n+\n+            /// zero the result, scan, check, update the offset.\n+            res[i] = 0;\n+            err = hs_scan(\n+                hyperscan_regex->getDB(),\n+                reinterpret_cast<const char *>(haystack_data.data()) + prev_haystack_offset,\n+                cur_haystack_length,\n+                0,\n+                smart_scratch.get(),\n+                on_match,\n+                &res[i]);\n+            if (err != HS_SUCCESS && err != HS_SCAN_TERMINATED)\n+                throw Exception(\"Failed to scan with vectorscan\", ErrorCodes::HYPERSCAN_CANNOT_SCAN_TEXT);\n+\n+            prev_haystack_offset = haystack_offsets[i];\n+            prev_needles_offset = needles_offsets[i];\n+            needles.clear();\n+        }\n+#else\n+        /// fallback if vectorscan is not compiled\n+        /// -- the code is copypasted from vectorVector() in MatchImpl.h and quite complex code ... all of it can be removed once vectorscan is\n+        ///    enabled on all platforms (#38906)\n+        if constexpr (WithEditDistance)\n+            throw Exception(\n+                \"Edit distance multi-search is not implemented when vectorscan is off\",\n+                ErrorCodes::NOT_IMPLEMENTED);\n+\n+        (void)edit_distance;\n+\n+        memset(res.data(), 0, res.size() * sizeof(res.front()));\n+\n+        size_t prev_haystack_offset = 0;\n+        size_t prev_needles_offset = 0;\n+\n+        const ColumnString * needles_data_string = checkAndGetColumn<ColumnString>(&needles_data);\n+\n+        std::vector<std::string_view> needles;\n+\n+        for (size_t i = 0; i < haystack_offsets.size(); ++i)\n+        {\n+            const auto * const cur_haystack_data = &haystack_data[prev_haystack_offset];\n+            const size_t cur_haystack_length = haystack_offsets[i] - prev_haystack_offset - 1;\n+\n+            needles.reserve(needles_offsets[i] - prev_needles_offset);\n+\n+            for (size_t j = prev_needles_offset; j < needles_offsets[i]; ++j)\n+            {\n+                needles.emplace_back(needles_data_string->getDataAt(j).toView());\n+            }\n+\n+            checkHyperscanRegexp(needles, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n+\n+            for (size_t j = 0; j < needles.size(); ++j)\n+            {\n+                String needle(needles[j]);\n+\n+                const auto & regexp = Regexps::Regexp(Regexps::createRegexp</*like*/ false, /*no_capture*/ true, /*case_insensitive*/ false>(needle));\n+\n+                String required_substr;\n+                bool is_trivial;\n+                bool required_substring_is_prefix; /// for `anchored` execution of the regexp.\n+\n+                regexp.getAnalyzeResult(required_substr, is_trivial, required_substring_is_prefix);\n+\n+                if (required_substr.empty())\n+                {\n+                    if (!regexp.getRE2()) /// An empty regexp. Always matches.\n+                    {\n+                        if constexpr (FindAny)\n+                            res[i] |= 1;\n+                        else if (FindAnyIndex)\n+                            res[i] = j + 1;\n+                    }\n+                    else\n+                    {\n+                        const bool match = regexp.getRE2()->Match(\n+                                {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},\n+                                0,\n+                                cur_haystack_length,\n+                                re2_st::RE2::UNANCHORED,\n+                                nullptr,\n+                                0);\n+                        if constexpr (FindAny)\n+                            res[i] |= match;\n+                        else if (FindAnyIndex && match)\n+                            res[i] = j + 1;\n+                    }\n+                }\n+                else\n+                {\n+                    Volnitsky searcher(required_substr.data(), required_substr.size(), cur_haystack_length);\n+                    const auto * match = searcher.search(cur_haystack_data, cur_haystack_length);\n+\n+                    if (match == cur_haystack_data + cur_haystack_length)\n+                    {\n+                        /// no match\n+                    }\n+                    else\n+                    {\n+                        if (is_trivial)\n+                        {\n+                            /// no wildcards in pattern\n+                            if constexpr (FindAny)\n+                                res[i] |= 1;\n+                            else if (FindAnyIndex)\n+                                res[i] = j + 1;\n+                        }\n+                        else\n+                        {\n+                            const size_t start_pos = (required_substring_is_prefix) ? (match - cur_haystack_data) : 0;\n+                            const size_t end_pos = cur_haystack_length;\n+\n+                            const bool match2 = regexp.getRE2()->Match(\n+                                    {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},\n+                                    start_pos,\n+                                    end_pos,\n+                                    re2_st::RE2::UNANCHORED,\n+                                    nullptr,\n+                                    0);\n+                            if constexpr (FindAny)\n+                                res[i] |= match2;\n+                            else if (FindAnyIndex && match2)\n+                                res[i] = j + 1;\n+                            }\n+                    }\n+                }\n+            }\n+\n+            prev_haystack_offset = haystack_offsets[i];\n+            prev_needles_offset = needles_offsets[i];\n+            needles.clear();\n+        }\n #endif // USE_VECTORSCAN\n     }\n };\ndiff --git a/src/Functions/MultiSearchFirstIndexImpl.h b/src/Functions/MultiSearchFirstIndexImpl.h\nindex f69a3edbf8b1..f108f2ca41e2 100644\n--- a/src/Functions/MultiSearchFirstIndexImpl.h\n+++ b/src/Functions/MultiSearchFirstIndexImpl.h\n@@ -29,7 +29,7 @@ struct MultiSearchFirstIndexImpl\n         const ColumnString::Offsets & haystack_offsets,\n         const Array & needles_arr,\n         PaddedPODArray<UInt64> & res,\n-        [[maybe_unused]] PaddedPODArray<UInt64> & offsets,\n+        PaddedPODArray<UInt64> & /*offsets*/,\n         bool /*allow_hyperscan*/,\n         size_t /*max_hyperscan_regexp_length*/,\n         size_t /*max_hyperscan_regexp_total_length*/)\n@@ -46,26 +46,83 @@ struct MultiSearchFirstIndexImpl\n             needles.emplace_back(needle.get<String>());\n \n         auto searcher = Impl::createMultiSearcherInBigHaystack(needles);\n-        const size_t haystack_string_size = haystack_offsets.size();\n-        res.resize(haystack_string_size);\n+\n+        const size_t haystack_size = haystack_offsets.size();\n+        res.resize(haystack_size);\n+\n         size_t iteration = 0;\n         while (searcher.hasMoreToSearch())\n         {\n-            size_t prev_offset = 0;\n-            for (size_t j = 0; j < haystack_string_size; ++j)\n+            size_t prev_haystack_offset = 0;\n+            for (size_t j = 0; j < haystack_size; ++j)\n             {\n-                const auto * haystack = &haystack_data[prev_offset];\n-                const auto * haystack_end = haystack + haystack_offsets[j] - prev_offset - 1;\n+                const auto * haystack = &haystack_data[prev_haystack_offset];\n+                const auto * haystack_end = haystack + haystack_offsets[j] - prev_haystack_offset - 1;\n                 /// hasMoreToSearch traverse needles in increasing order\n                 if (iteration == 0 || res[j] == 0)\n                     res[j] = searcher.searchOneFirstIndex(haystack, haystack_end);\n-                prev_offset = haystack_offsets[j];\n+                prev_haystack_offset = haystack_offsets[j];\n             }\n             ++iteration;\n         }\n         if (iteration == 0)\n             std::fill(res.begin(), res.end(), 0);\n     }\n+\n+    static void vectorVector(\n+        const ColumnString::Chars & haystack_data,\n+        const ColumnString::Offsets & haystack_offsets,\n+        const IColumn & needles_data,\n+        const ColumnArray::Offsets & needles_offsets,\n+        PaddedPODArray<ResultType> & res,\n+        PaddedPODArray<UInt64> & /*offsets*/,\n+        bool /*allow_hyperscan*/,\n+        size_t /*max_hyperscan_regexp_length*/,\n+        size_t /*max_hyperscan_regexp_total_length*/)\n+    {\n+        const size_t haystack_size = haystack_offsets.size();\n+        res.resize(haystack_size);\n+\n+        size_t prev_haystack_offset = 0;\n+        size_t prev_needles_offset = 0;\n+\n+        const ColumnString * needles_data_string = checkAndGetColumn<ColumnString>(&needles_data);\n+\n+        std::vector<std::string_view> needles;\n+\n+        for (size_t i = 0; i < haystack_size; ++i)\n+        {\n+            needles.reserve(needles_offsets[i] - prev_needles_offset);\n+\n+            for (size_t j = prev_needles_offset; j < needles_offsets[i]; ++j)\n+            {\n+                needles.emplace_back(needles_data_string->getDataAt(j).toView());\n+            }\n+\n+            auto searcher = Impl::createMultiSearcherInBigHaystack(needles); // sub-optimal\n+\n+            const auto * const haystack = &haystack_data[prev_haystack_offset];\n+            const auto * haystack_end = haystack + haystack_offsets[i] - prev_haystack_offset - 1;\n+\n+            size_t iteration = 0;\n+            while (searcher.hasMoreToSearch())\n+            {\n+                if (iteration == 0 || res[i] == 0)\n+                {\n+                    res[i] = searcher.searchOneFirstIndex(haystack, haystack_end);\n+                }\n+                ++iteration;\n+            }\n+            if (iteration == 0)\n+            {\n+                res[i] = 0;\n+            }\n+\n+            prev_haystack_offset = haystack_offsets[i];\n+            prev_needles_offset = needles_offsets[i];\n+            needles.clear();\n+        }\n+    }\n };\n \n }\ndiff --git a/src/Functions/MultiSearchFirstPositionImpl.h b/src/Functions/MultiSearchFirstPositionImpl.h\nindex 21d558a6d58c..69cab478d134 100644\n--- a/src/Functions/MultiSearchFirstPositionImpl.h\n+++ b/src/Functions/MultiSearchFirstPositionImpl.h\n@@ -29,7 +29,7 @@ struct MultiSearchFirstPositionImpl\n         const ColumnString::Offsets & haystack_offsets,\n         const Array & needles_arr,\n         PaddedPODArray<UInt64> & res,\n-        [[maybe_unused]] PaddedPODArray<UInt64> & offsets,\n+        PaddedPODArray<UInt64> & /*offsets*/,\n         bool /*allow_hyperscan*/,\n         size_t /*max_hyperscan_regexp_length*/,\n         size_t /*max_hyperscan_regexp_total_length*/)\n@@ -50,16 +50,18 @@ struct MultiSearchFirstPositionImpl\n             return 1 + Impl::countChars(reinterpret_cast<const char *>(start), reinterpret_cast<const char *>(end));\n         };\n         auto searcher = Impl::createMultiSearcherInBigHaystack(needles);\n-        const size_t haystack_string_size = haystack_offsets.size();\n-        res.resize(haystack_string_size);\n+\n+        const size_t haystack_size = haystack_offsets.size();\n+        res.resize(haystack_size);\n+\n         size_t iteration = 0;\n         while (searcher.hasMoreToSearch())\n         {\n-            size_t prev_offset = 0;\n-            for (size_t j = 0; j < haystack_string_size; ++j)\n+            size_t prev_haystack_offset = 0;\n+            for (size_t j = 0; j < haystack_size; ++j)\n             {\n-                const auto * haystack = &haystack_data[prev_offset];\n-                const auto * haystack_end = haystack + haystack_offsets[j] - prev_offset - 1;\n+                const auto * haystack = &haystack_data[prev_haystack_offset];\n+                const auto * haystack_end = haystack + haystack_offsets[j] - prev_haystack_offset - 1;\n                 if (iteration == 0 || res[j] == 0)\n                     res[j] = searcher.searchOneFirstPosition(haystack, haystack_end, res_callback);\n                 else\n@@ -68,13 +70,81 @@ struct MultiSearchFirstPositionImpl\n                     if (result != 0)\n                         res[j] = std::min(result, res[j]);\n                 }\n-                prev_offset = haystack_offsets[j];\n+                prev_haystack_offset = haystack_offsets[j];\n             }\n             ++iteration;\n         }\n         if (iteration == 0)\n             std::fill(res.begin(), res.end(), 0);\n     }\n+\n+    static void vectorVector(\n+        const ColumnString::Chars & haystack_data,\n+        const ColumnString::Offsets & haystack_offsets,\n+        const IColumn & needles_data,\n+        const ColumnArray::Offsets & needles_offsets,\n+        PaddedPODArray<ResultType> & res,\n+        PaddedPODArray<UInt64> & /*offsets*/,\n+        bool /*allow_hyperscan*/,\n+        size_t /*max_hyperscan_regexp_length*/,\n+        size_t /*max_hyperscan_regexp_total_length*/)\n+    {\n+        const size_t haystack_size = haystack_offsets.size();\n+        res.resize(haystack_size);\n+\n+        size_t prev_haystack_offset = 0;\n+        size_t prev_needles_offset = 0;\n+\n+        const ColumnString * needles_data_string = checkAndGetColumn<ColumnString>(&needles_data);\n+\n+        std::vector<std::string_view> needles;\n+\n+        auto res_callback = [](const UInt8 * start, const UInt8 * end) -> UInt64\n+        {\n+            return 1 + Impl::countChars(reinterpret_cast<const char *>(start), reinterpret_cast<const char *>(end));\n+        };\n+\n+        for (size_t i = 0; i < haystack_size; ++i)\n+        {\n+            needles.reserve(needles_offsets[i] - prev_needles_offset);\n+\n+            for (size_t j = prev_needles_offset; j < needles_offsets[i]; ++j)\n+            {\n+                needles.emplace_back(needles_data_string->getDataAt(j).toView());\n+            }\n+\n+            auto searcher = Impl::createMultiSearcherInBigHaystack(needles); // sub-optimal\n+\n+            const auto * const haystack = &haystack_data[prev_haystack_offset];\n+            const auto * haystack_end = haystack + haystack_offsets[i] - prev_haystack_offset - 1;\n+\n+            size_t iteration = 0;\n+            while (searcher.hasMoreToSearch())\n+            {\n+                if (iteration == 0 || res[i] == 0)\n+                {\n+                    res[i] = searcher.searchOneFirstPosition(haystack, haystack_end, res_callback);\n+                }\n+                else\n+                {\n+                    UInt64 result = searcher.searchOneFirstPosition(haystack, haystack_end, res_callback);\n+                    if (result != 0)\n+                    {\n+                        res[i] = std::min(result, res[i]);\n+                    }\n+                }\n+                ++iteration;\n+            }\n+            if (iteration == 0)\n+            {\n+                res[i] = 0;\n+            }\n+\n+            prev_haystack_offset = haystack_offsets[i];\n+            prev_needles_offset = needles_offsets[i];\n+            needles.clear();\n+        }\n+    }\n };\n \n }\ndiff --git a/src/Functions/MultiSearchImpl.h b/src/Functions/MultiSearchImpl.h\nindex 1124184f58cd..b9ce02932345 100644\n--- a/src/Functions/MultiSearchImpl.h\n+++ b/src/Functions/MultiSearchImpl.h\n@@ -29,7 +29,7 @@ struct MultiSearchImpl\n         const ColumnString::Offsets & haystack_offsets,\n         const Array & needles_arr,\n         PaddedPODArray<UInt8> & res,\n-        [[maybe_unused]] PaddedPODArray<UInt64> & offsets,\n+        PaddedPODArray<UInt64> & /*offsets*/,\n         bool /*allow_hyperscan*/,\n         size_t /*max_hyperscan_regexp_length*/,\n         size_t /*max_hyperscan_regexp_total_length*/)\n@@ -46,25 +46,80 @@ struct MultiSearchImpl\n             needles.emplace_back(needle.get<String>());\n \n         auto searcher = Impl::createMultiSearcherInBigHaystack(needles);\n-        const size_t haystack_string_size = haystack_offsets.size();\n-        res.resize(haystack_string_size);\n+\n+        const size_t haystack_size = haystack_offsets.size();\n+        res.resize(haystack_size);\n+\n         size_t iteration = 0;\n         while (searcher.hasMoreToSearch())\n         {\n-            size_t prev_offset = 0;\n-            for (size_t j = 0; j < haystack_string_size; ++j)\n+            size_t prev_haystack_offset = 0;\n+            for (size_t j = 0; j < haystack_size; ++j)\n             {\n-                const auto * haystack = &haystack_data[prev_offset];\n-                const auto * haystack_end = haystack + haystack_offsets[j] - prev_offset - 1;\n+                const auto * haystack = &haystack_data[prev_haystack_offset];\n+                const auto * haystack_end = haystack + haystack_offsets[j] - prev_haystack_offset - 1;\n                 if (iteration == 0 || !res[j])\n                     res[j] = searcher.searchOne(haystack, haystack_end);\n-                prev_offset = haystack_offsets[j];\n+                prev_haystack_offset = haystack_offsets[j];\n             }\n             ++iteration;\n         }\n         if (iteration == 0)\n             std::fill(res.begin(), res.end(), 0);\n     }\n+\n+    static void vectorVector(\n+        const ColumnString::Chars & haystack_data,\n+        const ColumnString::Offsets & haystack_offsets,\n+        const IColumn & needles_data,\n+        const ColumnArray::Offsets & needles_offsets,\n+        PaddedPODArray<ResultType> & res,\n+        PaddedPODArray<UInt64> & /*offsets*/,\n+        bool /*allow_hyperscan*/,\n+        size_t /*max_hyperscan_regexp_length*/,\n+        size_t /*max_hyperscan_regexp_total_length*/)\n+    {\n+        const size_t haystack_size = haystack_offsets.size();\n+        res.resize(haystack_size);\n+\n+        size_t prev_haystack_offset = 0;\n+        size_t prev_needles_offset = 0;\n+\n+        const ColumnString * needles_data_string = checkAndGetColumn<ColumnString>(&needles_data);\n+\n+        std::vector<std::string_view> needles;\n+\n+        for (size_t i = 0; i < haystack_size; ++i)\n+        {\n+            needles.reserve(needles_offsets[i] - prev_needles_offset);\n+\n+            for (size_t j = prev_needles_offset; j < needles_offsets[i]; ++j)\n+            {\n+                needles.emplace_back(needles_data_string->getDataAt(j).toView());\n+            }\n+\n+            const auto * const haystack = &haystack_data[prev_haystack_offset];\n+            const size_t haystack_length = haystack_offsets[i] - prev_haystack_offset - 1;\n+\n+            size_t iteration = 0;\n+            for (const auto & needle : needles)\n+            {\n+                auto searcher = Impl::createSearcherInSmallHaystack(needle.data(), needle.size());\n+                if (iteration == 0 || !res[i])\n+                {\n+                    const auto * match = searcher.search(haystack, haystack_length);\n+                    res[i] = (match != haystack + haystack_length);\n+                }\n+                ++iteration;\n+            }\n+            if (iteration == 0)\n+                res[i] = 0;\n+\n+            prev_haystack_offset = haystack_offsets[i];\n+            prev_needles_offset = needles_offsets[i];\n+            needles.clear();\n+        }\n+    }\n };\n \n }\ndiff --git a/src/Functions/checkHyperscanRegexp.h b/src/Functions/checkHyperscanRegexp.h\nindex 2aac44115fc6..e5f1165a949d 100644\n--- a/src/Functions/checkHyperscanRegexp.h\n+++ b/src/Functions/checkHyperscanRegexp.h\n@@ -1,6 +1,7 @@\n #pragma once\n \n-#include <base/StringRef.h>\n+#include <string_view>\n+#include <vector>\n \n namespace DB\n {\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00926_multimatch.reference b/tests/queries/0_stateless/00926_multimatch.reference\nindex 7ff32ecd73be..0ad98dc23b82 100644\n--- a/tests/queries/0_stateless/00926_multimatch.reference\n+++ b/tests/queries/0_stateless/00926_multimatch.reference\n@@ -1,3 +1,4 @@\n+-- With const pattern\n 1\n 1\n 1\n@@ -623,3 +624,624 @@ All tests above must return 1, all tests below return something.\n [1,3]\n []\n [1,2,3]\n+-- With non-const pattern\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\ndiff --git a/tests/queries/0_stateless/00926_multimatch.sql b/tests/queries/0_stateless/00926_multimatch.sql\nindex 067061dd99a7..c98ef18dc325 100644\n--- a/tests/queries/0_stateless/00926_multimatch.sql\n+++ b/tests/queries/0_stateless/00926_multimatch.sql\n@@ -1,5 +1,7 @@\n -- Tags: no-fasttest, use-vectorscan\n \n+SELECT '-- With const pattern';\n+\n select 0 = multiMatchAny(materialize('mpnsguhwsitzvuleiwebwjfitmsg'), ['wbirxqoabpblrnvvmjizj', 'cfcxhuvrexyzyjsh', 'oldhtubemyuqlqbwvwwkwin', 'bumoozxdkjglzu', 'intxlfohlxmajjomw', 'dxkeghohv', 'arsvmwwkjeopnlwnan', 'ouugllgowpqtaxslcopkytbfhifaxbgt', 'hkedmjlbcrzvryaopjqdjjc', 'tbqkljywstuahzh', 'o', 'wowoclosyfcuwotmvjygzuzhrery', 'vpefjiffkhlggntcu', 'ytdixvasrorhripzfhjdmlhqksmctyycwp']) from system.numbers limit 10;\n select 0 = multiMatchAny(materialize('qjjzqexjpgkglgxpzrbqbnskq'), ['vaiatcjacmlffdzsejpdareqzy', 'xspcfzdufkmecud', 'bcvtbuqtctq', 'nkcopwbfytgemkqcfnnno', 'dylxnzuyhq', 'tno', 'scukuhufly', 'cdyquzuqlptv', 'ohluyfeksyxepezdhqmtfmgkvzsyph', 'ualzwtahvqvtijwp', 'jg', 'gwbawqlngzcknzgtmlj', 'qimvjcgbkkp', 'eaedbcgyrdvv', 'qcwrncjoewwedyyewcdkh', 'uqcvhngoqngmitjfxpznqomertqnqcveoqk', 'ydrgjiankgygpm', 'axepgap']) from system.numbers limit 10;\n select 0 = multiMatchAny(materialize('fdkmtqmxnegwvnjhghjq'), ['vynkybvdmhgeezybbdqfrukibisj', 'knazzamgjjpavwhvdkwigykh', 'peumnifrmdhhmrqqnemw', 'lmsnyvqoisinlaqobxojlwfbi', 'oqwfzs', 'dymudxxeodwjpgbibnkvr', 'vomtfsnizkplgzktqyoiw', 'yoyfuhlpgrzds', 'cefao', 'gi', 'srpgxfjwl', 'etsjusdeiwbfe', 'ikvtzdopxo', 'ljfkavrau', 'soqdhxtenfrkmeic', 'ktprjwfcelzbup', 'pcvuoddqwsaurcqdtjfnczekwni', 'agkqkqxkfbkfgyqliahsljim']) from system.numbers limit 10;\n@@ -92,3 +94,96 @@ SELECT [1] = multiMatchAllIndices(materialize('/odezhda-dlya-bega/'), ['/odezhda\n SELECT [] = multiMatchAllIndices(materialize('aaaa'), ['.*aa.*aaa.*', 'aaaaaa{2}', '\\(aa\\){3}']);\n SELECT 'All tests above must return 1, all tests below return something.';\n SELECT arraySort(multiMatchAllIndices(arrayJoin(['aaaa', 'aaaaaa', 'bbbb', 'aaaaaaaaaaaaaa']), ['.*aa.*aaa.*', 'aaaaaa{2}', '(aa){3}']));\n+\n+SELECT '-- With non-const pattern';\n+\n+select 0 = multiMatchAny(materialize('mpnsguhwsitzvuleiwebwjfitmsg'), materialize(['wbirxqoabpblrnvvmjizj', 'cfcxhuvrexyzyjsh', 'oldhtubemyuqlqbwvwwkwin', 'bumoozxdkjglzu', 'intxlfohlxmajjomw', 'dxkeghohv', 'arsvmwwkjeopnlwnan', 'ouugllgowpqtaxslcopkytbfhifaxbgt', 'hkedmjlbcrzvryaopjqdjjc', 'tbqkljywstuahzh', 'o', 'wowoclosyfcuwotmvjygzuzhrery', 'vpefjiffkhlggntcu', 'ytdixvasrorhripzfhjdmlhqksmctyycwp'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('qjjzqexjpgkglgxpzrbqbnskq'), materialize(['vaiatcjacmlffdzsejpdareqzy', 'xspcfzdufkmecud', 'bcvtbuqtctq', 'nkcopwbfytgemkqcfnnno', 'dylxnzuyhq', 'tno', 'scukuhufly', 'cdyquzuqlptv', 'ohluyfeksyxepezdhqmtfmgkvzsyph', 'ualzwtahvqvtijwp', 'jg', 'gwbawqlngzcknzgtmlj', 'qimvjcgbkkp', 'eaedbcgyrdvv', 'qcwrncjoewwedyyewcdkh', 'uqcvhngoqngmitjfxpznqomertqnqcveoqk', 'ydrgjiankgygpm', 'axepgap'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('fdkmtqmxnegwvnjhghjq'), materialize(['vynkybvdmhgeezybbdqfrukibisj', 'knazzamgjjpavwhvdkwigykh', 'peumnifrmdhhmrqqnemw', 'lmsnyvqoisinlaqobxojlwfbi', 'oqwfzs', 'dymudxxeodwjpgbibnkvr', 'vomtfsnizkplgzktqyoiw', 'yoyfuhlpgrzds', 'cefao', 'gi', 'srpgxfjwl', 'etsjusdeiwbfe', 'ikvtzdopxo', 'ljfkavrau', 'soqdhxtenfrkmeic', 'ktprjwfcelzbup', 'pcvuoddqwsaurcqdtjfnczekwni', 'agkqkqxkfbkfgyqliahsljim'])) from system.numbers limit 10;\n+select 1 = multiMatchAny(materialize('khljxzxlpcrxpkrfybbfk'), materialize(['', 'lpc', 'rxpkrfybb', 'crxp', '', 'pkr', 'jxzxlpcrxpkrf', '', 'xzxlpcr', 'xpk', 'fyb', 'xzxlpcrxpkrfybbfk', 'k', 'lpcrxp', 'ljxzxlpcr', 'r', 'pkr', 'fk'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('rbrizgjbigvzfnpgmpkqxoqxvdj'), materialize(['ee', 'cohqnb', 'msol', 'yhlujcvhklnhuomy', 'ietn', 'vgmnlkcsybtokrepzrm', 'wspiryefojxysgrzsxyrluykxfnnbzdstcel', 'mxisnsivndbefqxwznimwgazuulupbaihavg', 'vpzdjvqqeizascxmzdhuq', 'pgvncohlxcqjhfkm', 'mbaypcnfapltsegquurahlsruqvipfhrhq', 'ioxjbcyyqujfveujfhnfdfokfcrlsincjbdt', 'cnvlujyowompdrqjwjx', 'wobwed', 'kdfhaoxiuifotmptcmdbk', 'leoamsnorcvtlmokdomkzuo', 'jjw', 'ogugysetxuqmvggneosbsfbonszepsatq'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('uymwxzyjbfegbhgswiqhinf'), materialize(['lizxzbzlwljkr', 'ukxygktlpzuyijcqeqktxenlaqi', 'onperabgbdiafsxwbvpjtyt', 'xfqgoqvhqph', 'aflmcwabtwgmajmmqelxwkaolyyhmdlc', 'yfz', 'meffuiaicvwed', 'hhzvgmifzamgftkifaeowayjrnnzw', 'nwewybtajv', 'ectiye', 'epjeiljegmqqjncubj', 'zsjgftqjrn', 'pssng', 'raqoarfhdoeujulvqmdo'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('omgghgnzjmecpzqmtcvw'), materialize(['fjhlzbszodmzavzg', 'gfofrnwrxprkfiokv', 'jmjiiqpgznlmyrxwewzqzbe', 'pkyrsqkltlmxr', 'crqgkgqkkyujcyoc', 'endagbcxwqhueczuasykmajfsvtcmh', 'xytmxtrnkdysuwltqomehddp', 'etmdxyyfotfyifwvbykghijvwv', 'mwqtgrncyhkfhjdg', 'iuvymofrqpp', 'pgllsdanlhzqhkstwsmzzftp', 'disjylcceufxtjdvhy'])) from system.numbers limit 10;\n+select 1 = multiMatchAny(materialize('mznihnmshftvnmmhnrulizzpslq'), materialize(['nrul', 'mshftvnmmhnr', 'z', 'mhnrulizzps', 'hftvnmmhnrul', 'ihnmshftvnmmhnrulizzp', 'izz', '', 'uli', 'nihnmshftvnmmhnru', 'hnrulizzp', 'nrulizz'])) from system.numbers limit 10;\n+select 1 = multiMatchAny(materialize('ruqmqrsxrbftvruvahonradau'), materialize(['uqmqrsxrbft', 'ftv', 'tvruvahonrad', 'mqrsxrbftvruvahon', 'rbftvruvah', 'qrsxrbftvru', 'o', 'ahonradau', 'a', 'ft', '', 'u', 'rsxrbftvruvahonradau', 'ruvahon', 'bftvruvahonradau', 'qrsxrbftvru', 't', 'vahonrada', 'vruvahonradau', 'onra'])) from system.numbers limit 10;\n+select 1 = multiMatchAny(materialize('gpsevxtcoeexrltyzduyidmtzxf'), materialize(['exrltyzduyid', 'vxtcoeexrltyz', 'xr', 'ltyzduyidmt', 'yzduy', 'exr', 'coeexrltyzduy', 'coeexrltyzduy', 'rlty', 'rltyzduyidm', 'exrltyz', 'xtcoeexrlty', 'vxtcoeexrltyzduyidm', '', 'coeexrl', 'sevxtcoeexrltyzdu', 'dmt', ''])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('dyhycfhzyewaikgursyxfkuv'), materialize(['sktnofpugrmyxmbizzrivmhn', 'fhlgadpoqcvktbfzncxbllvwutdawmw', 'eewzjpcgzrqmltbgmhafwlwqb', 'tpogbkyj', 'rtllntxjgkzs', 'mirbvsqexscnzglogigbujgdwjvcv', 'iktwpgjsakemewmahgqza', 'xgfvzkvqgiuoihjjnxwwpznxhz', 'nxaumpaknreklbwynvxdsmatjekdlxvklh', 'zadzwqhgfxqllihuudozxeixyokhny', 'tdqpgfpzexlkslodps', 'slztannufxaabqfcjyfquafgfhfb', 'xvjldhfuwurvkb', 'aecv', 'uycfsughpikqsbcmwvqygdyexkcykhbnau', 'jr'])) from system.numbers limit 10;\n+select 1 = multiMatchAny(materialize('vbcsettndwuntnruiyclvvwoo'), materialize(['dwuntnru', '', 'ttndwuntnruiyclvv', 'ntnr', 'nruiyclvvw', 'wo', '', 'bcsettndwuntnruiycl', 'yc', 'untnruiyclvvw', 'csettndwuntnr', 'ntnruiyclvvwo'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('pqqnugshlczcuxhpjxjbcnro'), materialize(['dpeedqy', 'rtsc', 'jdgla', 'qkgudqjiyzvlvsj', 'xmfxawhijgxxtydbd', 'ebgzazqthb', 'wyrjhvhwzhmpybnylirrn', 'iviqbyuclayqketooztwegtkgwnsezfl', 'bhvidy', 'hijctxxweboq', 't', 'osnzfbziidteiaifgaanm'])) from system.numbers limit 10;\n+select 1 = multiMatchAny(materialize('loqchlxspwuvvccucskuytr'), materialize(['', 'k', 'qchlxspwu', 'u', 'hlxspwuvv', 'wuvvccucsku', 'vcc', 'uyt', 'uvv', 'spwu', 'ytr', 'wuvvccucs', 'xspwuv', 'lxspwuvvccuc', 'spwuvvccu', 'oqchlxspwuvvccucskuy'])) from system.numbers limit 10;\n+select 1 = multiMatchAny(materialize('pjjyzupzwllshlnatiujmwvaofr'), materialize(['lnatiujmwvao', '', 'zupzwllsh', 'nati', 'wllshl', 'hlnatiujmwv', 'mwvao', 'shlnat', 'ati', 'wllshlnatiujmwvao', 'wllshlnatiujmwvaofr', 'nat'])) from system.numbers limit 10;\n+select 1 = multiMatchAny(materialize('iketunkleyaqaxdlocci'), materialize(['nkleyaqaxd', 'etunkleyaq', 'yaqaxdlocci', 'tunkleyaq', 'eyaqaxdlocc', 'leyaq', 'nkleyaqaxdl', 'tunkleya', 'kleyaqa', 'etunkleya', 'leyaqa', 'dlo', 'yaqa', 'leyaqaxd', 'etunkleyaq', ''])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('drqianqtangmgbdwruvblkqd'), materialize(['wusajejyucamkyl', 'wsgibljugzrpkniliy', 'lhwqqiuafwffyersqjgjvvvfurx', 'jfokpzzxfdonelorqu', 'ccwkpcgac', 'jmyulqpndkmzbfztobwtm', 'rwrgfkccgxht', 'ggldjecrgbngkonphtcxrkcviujihidjx', 'spwweavbiokizv', 'lv', 'krb', 'vstnhvkbwlqbconaxgbfobqky', 'pvxwdc', 'thrl', 'ahsblffdveamceonqwrbeyxzccmux', 'yozji', 'oejtaxwmeovtqtz', 'zsnzznvqpxdvdxhznxrjn', 'hse', 'kcmkrccxmljzizracxwmpoaggywhdfpxkq'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('yasnpckniistxcejowfijjsvkdajz'), materialize(['slkpxhtsmrtvtm', 'crsbq', 'rdeshtxbfrlfwpsqojassxmvlfbzefldavmgme', 'ipetilcbpsfroefkjirquciwtxhrimbmwnlyv', 'knjpwkmdwbvdbapuyqbtsw', 'horueidziztxovqhsicnklmharuxhtgrsr', 'ofohrgpz', 'oneqnwyevbaqsonrcpmxcynflojmsnix', 'shg', 'nglqzczevgevwawdfperpeytuodjlf'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('ueptpscfgxhplwsueckkxs'), materialize(['ohhygchclbpcdwmftperprn', 'dvpjdqmqckekndvcerqrpkxen', 'lohhvarnmyi', 'zppd', 'qmqxgfewitsunbuhffozcpjtc', 'hsjbioisycsrawktqssjovkmltxodjgv', 'dbzuunwbkrtosyvctdujqtvaawfnvuq', 'gupbvpqthqxae', 'abjdmijaaiasnccgxttmqdsz', 'uccyumqoyqe', 'kxxliepyzlc', 'wbqcqtbyyjbqcgdbpkmzugksmcxhvr', 'piedxm', 'uncpphzoif', 'exkdankwck', 'qeitzozdrqopsergzr', 'hesgrhaftgesnzflrrtjdobxhbepjoas', 'wfpexx'])) from system.numbers limit 10;\n+select 1 = multiMatchAny(materialize('ldrzgttlqaphekkkdukgngl'), materialize(['gttlqaphekkkdukgn', 'ekkkd', 'gttlqaphe', 'qaphek', 'h', 'kdu', 'he', 'phek', '', 'drzgttlqaphekkkd'])) from system.numbers limit 10;\n+select 1 = multiMatchAny(materialize('ololo'), materialize(['ololo', 'ololo', 'ololo']));\n+SELECT 1 = multiMatchAny(materialize('khljxzxlpcrxpkrfybbfk'), materialize(['k']));\n+\n+select 1 = multiMatchAny(materialize(''), materialize(['']));\n+select 0 = multiMatchAny(materialize(''), materialize(['some string']));\n+select 1 = multiMatchAny(materialize('abc'), materialize(['']));\n+select 1 = multiMatchAny(materialize('abc'), materialize([''])) from system.numbers limit 10;\n+\n+select 0 = multiMatchAny(materialize('abc'), materialize(['defgh']));\n+select 0 = multiMatchAny(materialize('abc'), materialize(['defg']));\n+select 0 = multiMatchAny(materialize('abc'), materialize(['def']));\n+select 0 = multiMatchAny(materialize('abc'), materialize(['de']));\n+select 0 = multiMatchAny(materialize('abc'), materialize(['d']));\n+\n+\n+select 1 = multiMatchAny(materialize('abc'), materialize(['b'])) from system.numbers limit 10;\n+select 1 = multiMatchAny(materialize('abc'), materialize(['bc'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('abc'), materialize(['bcde'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('abc'), materialize(['bcdef'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('abc'), materialize(['bcdefg'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('abc'), materialize(['bcdefgh'])) from system.numbers limit 10;\n+\n+\n+select 0 = multiMatchAny(materialize('abc'), materialize(['abcdefg'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('abc'), materialize(['abcdef'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('abc'), materialize(['abcde'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('abc'), materialize(['abcd'])) from system.numbers limit 10;\n+select 1 = multiMatchAny(materialize('abc'), materialize(['abc'])) from system.numbers limit 10;\n+select 1 = multiMatchAny(materialize('abc'), materialize(['ab'])) from system.numbers limit 10;\n+select 1 = multiMatchAny(materialize('abc'), materialize(['a'])) from system.numbers limit 10;\n+\n+select 1 = multiMatchAny(materialize('abcd'), materialize(['c'])) from system.numbers limit 10;\n+select 1 = multiMatchAny(materialize('abcd'), materialize(['cd'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('abcd'), materialize(['cde'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('abcd'), materialize(['cdef'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('abcd'), materialize(['cdefg'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('abcd'), materialize(['cdefgh'])) from system.numbers limit 10;\n+\n+select 0 = multiMatchAny(materialize('abc'), materialize(['defgh'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('abc'), materialize(['defg'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('abc'), materialize(['def'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('abc'), materialize(['de'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('abc'), materialize(['d'])) from system.numbers limit 10;\n+\n+select 1 = multiMatchAny(materialize('abc'), materialize(['...'])) from system.numbers limit 10;\n+select 1 = multiMatchAny(materialize('a\\nbc'), materialize(['a?bc'])) from system.numbers limit 10;\n+select 1 = multiMatchAny(materialize('a\\nbc'), materialize(['a.bc'])) from system.numbers limit 10;\n+select 1 = multiMatchAny(materialize('a\\0bc'), materialize(['a?bc'])) from system.numbers limit 10;\n+select 1 = multiMatchAny(materialize('a\\0bc'), materialize(['a.bc'])) from system.numbers limit 10;\n+select 1 = multiMatchAny(materialize('abcdef'), materialize(['a.....'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('abcdef'), materialize(['a......'])) from system.numbers limit 10;\n+select 1 = multiMatchAny(materialize('abcdef'), materialize(['a......', 'a.....'])) from system.numbers limit 10;\n+select 0 = multiMatchAny(materialize('aaaa'), materialize(['.*aa.*aaa.*', 'aaaaaa{2}', '\\(aa\\){3}'])) from system.numbers limit 10;\n+select 1 = multiMatchAny(materialize('abc'), materialize(['a\\0d'])) from system.numbers limit 10;\n+\n+select 1 = multiMatchAnyIndex(materialize('gogleuedeuniangoogle'), materialize(['google', 'unian1'])) from system.numbers limit 10;\n+select 2 = multiMatchAnyIndex(materialize('gogleuedeuniangoogle'), materialize(['google1', 'unian'])) from system.numbers limit 10;\n+select 0 != multiMatchAnyIndex(materialize('gogleuedeuniangoogle'), materialize(['.*goo.*', '.*yan.*'])) from system.numbers limit 10;\n+select 5 = multiMatchAnyIndex(materialize('vladizlvav dabe don\\'t heart me no more'), materialize(['what', 'is', 'love', 'baby', 'no mo??', 'dont', 'h.rt me'])) from system.numbers limit 10;\n+\n+SELECT multiMatchAny(materialize('/odezhda-dlya-bega/'), materialize(['/odezhda-dlya-bega/', 'kurtki-i-vetrovki-dlya-bega', 'futbolki-i-mayki-dlya-bega']));\n+SELECT 1 = multiMatchAny(materialize('\u0444\u0430\u0431\u0440\u0438\u043a\u0430\u043d\u0442'), materialize(['f[ae]b[ei]rl', '\u0444[\u0438\u0430\u044d\u0435]\u0431[\u0435\u044d\u0438][\u0440\u043f\u043b]', '\u0430\u0444\u0438\u0443\u043a\u0434', 'a[ft],th', '^\u0444[\u0430\u0438\u0435\u044d]?\u0431?[\u0435\u044d\u0438]?$', '\u0431\u0435\u0440\u043b\u0438\u043a', 'fab', '\u0444\u0430[\u0431\u0435\u044c\u0432]+\u0435?[\u0440\u043b\u043a\u043e]']));\n+\n+-- All indices tests\n+SELECT [1, 2] = arraySort(multiMatchAllIndices(materialize('gogleuedeuniangoogle'), materialize(['.*goo.*', '.*yan.*']))) from system.numbers limit 5;\n+SELECT [1, 3] = arraySort(multiMatchAllIndices(materialize('gogleuedeuniangoogle'), materialize(['.*goo.*', 'neverexisted', '.*yan.*']))) from system.numbers limit 5;\n+SELECT [] = multiMatchAllIndices(materialize('gogleuedeuniangoogle'), materialize(['neverexisted', 'anotherone', 'andanotherone'])) from system.numbers limit 5;\n+SELECT [1, 2, 3, 11] = arraySort(multiMatchAllIndices(materialize('\u0444\u0430\u0431\u0440\u0438\u043a\u0430\u043d\u0442'), materialize(['', '\u0440\u0438\u043a\u0430\u043d', '\u0430', 'f[ae]b[ei]rl', '\u0444[\u0438\u0430\u044d\u0435]\u0431[\u0435\u044d\u0438][\u0440\u043f\u043b]', '\u0430\u0444\u0438\u0443\u043a\u0434', 'a[ft],th', '^\u0444[\u0430\u0438\u0435\u044d]?\u0431?[\u0435\u044d\u0438]?$', '\u0431\u0435\u0440\u043b\u0438\u043a', 'fab', '\u0444\u0430[\u0431\u0435\u044c\u0432]+\u0435?[\u0440\u043b\u043a\u043e]'])));\n+SELECT [1] = multiMatchAllIndices(materialize('/odezhda-dlya-bega/'), materialize(['/odezhda-dlya-bega/', 'kurtki-i-vetrovki-dlya-bega', 'futbolki-i-mayki-dlya-bega']));\n+SELECT [] = multiMatchAllIndices(materialize('aaaa'), materialize(['.*aa.*aaa.*', 'aaaaaa{2}', '\\(aa\\){3}']));\ndiff --git a/tests/queries/0_stateless/00927_disable_hyperscan.reference b/tests/queries/0_stateless/00927_disable_hyperscan.reference\nindex 7cac306b9db7..a6548d5d5a7a 100644\n--- a/tests/queries/0_stateless/00927_disable_hyperscan.reference\n+++ b/tests/queries/0_stateless/00927_disable_hyperscan.reference\n@@ -6,4 +6,9 @@\n 1\n 1\n 1\n+1\n+0\n+1\n+1\n+1\n 0\ndiff --git a/tests/queries/0_stateless/00927_disable_hyperscan.sql b/tests/queries/0_stateless/00927_disable_hyperscan.sql\nindex 9f0f6ca15384..d6f47d739fb1 100644\n--- a/tests/queries/0_stateless/00927_disable_hyperscan.sql\n+++ b/tests/queries/0_stateless/00927_disable_hyperscan.sql\n@@ -1,9 +1,16 @@\n -- Tags: no-debug\n \n SET allow_hyperscan = 1;\n+\n SELECT multiMatchAny(arrayJoin(['hello', 'world', 'hellllllllo', 'wororld', 'abc']), ['hel+o', 'w(or)*ld']);\n+SELECT multiMatchAny(arrayJoin(['hello', 'world', 'hellllllllo', 'wororld', 'abc']), materialize(['hel+o', 'w(or)*ld']));\n+\n SET allow_hyperscan = 0;\n+\n SELECT multiMatchAny(arrayJoin(['hello', 'world', 'hellllllllo', 'wororld', 'abc']), ['hel+o', 'w(or)*ld']); -- { serverError 446 }\n+SELECT multiMatchAny(arrayJoin(['hello', 'world', 'hellllllllo', 'wororld', 'abc']), materialize(['hel+o', 'w(or)*ld'])); -- { serverError 446 }\n+\n SELECT multiMatchAllIndices(arrayJoin(['hello', 'world', 'hellllllllo', 'wororld', 'abc']), ['hel+o', 'w(or)*ld']); -- { serverError 446 }\n+SELECT multiMatchAllIndices(arrayJoin(['hello', 'world', 'hellllllllo', 'wororld', 'abc']), materialize(['hel+o', 'w(or)*ld'])); -- { serverError 446 }\n \n SELECT multiSearchAny(arrayJoin(['hello', 'world', 'hello, world', 'abc']), ['hello', 'world']);\ndiff --git a/tests/queries/0_stateless/00929_multi_match_edit_distance.reference b/tests/queries/0_stateless/00929_multi_match_edit_distance.reference\nindex 4600557506be..82e47e3ffadf 100644\n--- a/tests/queries/0_stateless/00929_multi_match_edit_distance.reference\n+++ b/tests/queries/0_stateless/00929_multi_match_edit_distance.reference\n@@ -1,3 +1,7 @@\n+- const pattern\n+0\n+0\n+0\n 1\n 1\n 1\n@@ -9,12 +13,22 @@\n 1\n 1\n 1\n+0\n 1\n 1\n 1\n 1\n+0\n 1\n+2\n+2\n 1\n+[2,3,4]\n+[]\n+- non-const pattern\n+0\n+0\n+0\n 1\n 1\n 1\n@@ -24,11 +38,15 @@\n 1\n 1\n 1\n+0\n 1\n 1\n 1\n 1\n+0\n 1\n+2\n+2\n 1\n-1\n-1\n+[2,3,4]\n+[]\ndiff --git a/tests/queries/0_stateless/00929_multi_match_edit_distance.sql b/tests/queries/0_stateless/00929_multi_match_edit_distance.sql\nindex 343fc75ed4d5..c86accd260ba 100644\n--- a/tests/queries/0_stateless/00929_multi_match_edit_distance.sql\n+++ b/tests/queries/0_stateless/00929_multi_match_edit_distance.sql\n@@ -2,30 +2,60 @@\n \n SET send_logs_level = 'fatal';\n \n-select 0 = multiFuzzyMatchAny('abc', 0, ['a1c']) from system.numbers limit 5;\n-select 1 = multiFuzzyMatchAny('abc', 1, ['a1c']) from system.numbers limit 5;\n-select 1 = multiFuzzyMatchAny('abc', 2, ['a1c']) from system.numbers limit 5;\n-select 1 = multiFuzzyMatchAny('abc', 3, ['a1c']) from system.numbers limit 5; -- { serverError 36 }\n-select 1 = multiFuzzyMatchAny('abc', 4, ['a1c']) from system.numbers limit 5; -- { serverError 36 }\n-\n-select 1 = multiFuzzyMatchAny('leftabcright', 1, ['a1c']) from system.numbers limit 5;\n-\n-select 1 = multiFuzzyMatchAny('hello some world', 0, ['^hello.*world$']);\n-select 1 = multiFuzzyMatchAny('hallo some world', 1, ['^hello.*world$']);\n-select 0 = multiFuzzyMatchAny('halo some wrld', 2, ['^hello.*world$']);\n-select 1 = multiFuzzyMatchAny('halo some wrld', 2, ['^hello.*world$', '^halo.*world$']);\n-select 1 = multiFuzzyMatchAny('halo some wrld', 2, ['^halo.*world$', '^hello.*world$']);\n-select 1 = multiFuzzyMatchAny('halo some wrld', 3, ['^hello.*world$']);\n-select 1 = multiFuzzyMatchAny('hello some world', 10, ['^hello.*world$']); -- { serverError 36 }\n-select 1 = multiFuzzyMatchAny('hello some world', -1, ['^hello.*world$']); -- { serverError 43 }\n-select 1 = multiFuzzyMatchAny('hello some world', 10000000000, ['^hello.*world$']); -- { serverError 44 }\n-select 1 = multiFuzzyMatchAny('http://hyperscan_is_nice.ru/st', 2, ['http://hyperscan_is_nice.ru/(st\\\\d\\\\d$|st\\\\d\\\\d\\\\.|st1[0-4]\\\\d|st150|st\\\\d$|gl|rz|ch)']);\n-select 0 = multiFuzzyMatchAny('string', 0, ['zorro$', '^tring', 'in$', 'how.*', 'it{2}', 'works']);\n-\n-select 1 = multiFuzzyMatchAny('string', 1, ['zorro$', '^tring', 'ip$', 'how.*', 'it{2}', 'works']);\n-select 2 = multiFuzzyMatchAnyIndex('string', 1, ['zorro$', '^tring', 'ip$', 'how.*', 'it{2}', 'works']);\n-select 2 = multiFuzzyMatchAnyIndex('halo some wrld', 2, ['^hello.*world$', '^halo.*world$']);\n-select 1 = multiFuzzyMatchAnyIndex('halo some wrld', 2, ['^halo.*world$', '^hello.*world$']);\n-\n-select [2, 3, 4] = arraySort(multiFuzzyMatchAllIndices('halo some wrld', 2, ['some random string', '^halo.*world$', '^halo.*world$', '^halo.*world$', '^hallllo.*world$']));\n-select [] = multiFuzzyMatchAllIndices('halo some wrld', 2, ['^halllllo.*world$', 'some random string']);\n+SELECT '- const pattern';\n+\n+-- run queries multiple times to test the pattern caching\n+select multiFuzzyMatchAny('abc', 0, ['a1c']) from system.numbers limit 3;\n+select multiFuzzyMatchAny('abc', 1, ['a1c']) from system.numbers limit 3;\n+select multiFuzzyMatchAny('abc', 2, ['a1c']) from system.numbers limit 3;\n+select multiFuzzyMatchAny('abc', 3, ['a1c']) from system.numbers limit 3; -- { serverError 36 }\n+select multiFuzzyMatchAny('abc', 4, ['a1c']) from system.numbers limit 3; -- { serverError 36 }\n+\n+select multiFuzzyMatchAny('leftabcright', 1, ['a1c']) from system.numbers limit 3;\n+\n+select multiFuzzyMatchAny('hello some world', 0, ['^hello.*world$']);\n+select multiFuzzyMatchAny('hallo some world', 1, ['^hello.*world$']);\n+select multiFuzzyMatchAny('halo some wrld', 2, ['^hello.*world$']);\n+select multiFuzzyMatchAny('halo some wrld', 2, ['^hello.*world$', '^halo.*world$']);\n+select multiFuzzyMatchAny('halo some wrld', 2, ['^halo.*world$', '^hello.*world$']);\n+select multiFuzzyMatchAny('halo some wrld', 3, ['^hello.*world$']);\n+select multiFuzzyMatchAny('hello some world', 10, ['^hello.*world$']); -- { serverError 36 }\n+select multiFuzzyMatchAny('hello some world', -1, ['^hello.*world$']); -- { serverError 43 }\n+select multiFuzzyMatchAny('hello some world', 10000000000, ['^hello.*world$']); -- { serverError 44 }\n+select multiFuzzyMatchAny('http://hyperscan_is_nice.de/st', 2, ['http://hyperscan_is_nice.de/(st\\\\d\\\\d$|st\\\\d\\\\d\\\\.|st1[0-4]\\\\d|st150|st\\\\d$|gl|rz|ch)']);\n+select multiFuzzyMatchAny('string', 0, ['zorro$', '^tring', 'in$', 'how.*', 'it{2}', 'works']);\n+select multiFuzzyMatchAny('string', 1, ['zorro$', '^tring', 'ip$', 'how.*', 'it{2}', 'works']);\n+select multiFuzzyMatchAnyIndex('string', 1, ['zorro$', '^tring', 'ip$', 'how.*', 'it{2}', 'works']);\n+select multiFuzzyMatchAnyIndex('halo some wrld', 2, ['^hello.*world$', '^halo.*world$']);\n+select multiFuzzyMatchAnyIndex('halo some wrld', 2, ['^halo.*world$', '^hello.*world$']);\n+--\n+select arraySort(multiFuzzyMatchAllIndices('halo some wrld', 2, ['some random string', '^halo.*world$', '^halo.*world$', '^halo.*world$', '^hallllo.*world$']));\n+select multiFuzzyMatchAllIndices('halo some wrld', 2, ['^halllllo.*world$', 'some random string']);\n+\n+SELECT '- non-const pattern';\n+\n+select multiFuzzyMatchAny(materialize('abc'), 0, materialize(['a1c'])) from system.numbers limit 3;\n+select multiFuzzyMatchAny(materialize('abc'), 1, materialize(['a1c'])) from system.numbers limit 3;\n+select multiFuzzyMatchAny(materialize('abc'), 2, materialize(['a1c'])) from system.numbers limit 3;\n+select multiFuzzyMatchAny(materialize('abc'), 3, materialize(['a1c'])) from system.numbers limit 3; -- { serverError 36}\n+select multiFuzzyMatchAny(materialize('abc'), 4, materialize(['a1c'])) from system.numbers limit 3; -- { serverError 36}\n+\n+select multiFuzzyMatchAny(materialize('leftabcright'), 1, materialize(['a1c']));\n+\n+select multiFuzzyMatchAny(materialize('hello some world'), 0, materialize(['^hello.*world$']));\n+select multiFuzzyMatchAny(materialize('hallo some world'), 1, materialize(['^hello.*world$']));\n+select multiFuzzyMatchAny(materialize('halo some wrld'), 2, materialize(['^hello.*world$']));\n+select multiFuzzyMatchAny(materialize('halo some wrld'), 2, materialize(['^hello.*world$', '^halo.*world$']));\n+select multiFuzzyMatchAny(materialize('halo some wrld'), 2, materialize(['^halo.*world$', '^hello.*world$']));\n+select multiFuzzyMatchAny(materialize('halo some wrld'), 3, materialize(['^hello.*world$']));\n+select multiFuzzyMatchAny(materialize('hello some world'), 10, materialize(['^hello.*world$'])); -- { serverError 36 }\n+select multiFuzzyMatchAny(materialize('hello some world'), -1, materialize(['^hello.*world$'])); -- { serverError 43 }\n+select multiFuzzyMatchAny(materialize('hello some world'), 10000000000, materialize(['^hello.*world$'])); -- { serverError 44 }\n+select multiFuzzyMatchAny(materialize('http://hyperscan_is_nice.de/st'), 2, materialize(['http://hyperscan_is_nice.de/(st\\\\d\\\\d$|st\\\\d\\\\d\\\\.|st1[0-4]\\\\d|st150|st\\\\d$|gl|rz|ch)']));\n+select multiFuzzyMatchAny(materialize('string'), 0, materialize(['zorro$', '^tring', 'in$', 'how.*', 'it{2}', 'works']));\n+select multiFuzzyMatchAny(materialize('string'), 1, materialize(['zorro$', '^tring', 'ip$', 'how.*', 'it{2}', 'works']));\n+select multiFuzzyMatchAnyIndex(materialize('string'), 1, materialize(['zorro$', '^tring', 'ip$', 'how.*', 'it{2}', 'works']));\n+select multiFuzzyMatchAnyIndex(materialize('halo some wrld'), 2, materialize(['^hello.*world$', '^halo.*world$']));\n+select multiFuzzyMatchAnyIndex(materialize('halo some wrld'), 2, materialize(['^halo.*world$', '^hello.*world$']));\n+select arraySort(multiFuzzyMatchAllIndices(materialize('halo some wrld'), 2, materialize(['some random string', '^halo.*world$', '^halo.*world$', '^halo.*world$', '^hallllo.*world$'])));\n+select multiFuzzyMatchAllIndices(materialize('halo some wrld'), 2, materialize(['^halllllo.*world$', 'some random string']));\ndiff --git a/tests/queries/0_stateless/02004_max_hyperscan_regex_length.reference b/tests/queries/0_stateless/02004_max_hyperscan_regex_length.reference\nindex 87e68c152c3f..673149878acc 100644\n--- a/tests/queries/0_stateless/02004_max_hyperscan_regex_length.reference\n+++ b/tests/queries/0_stateless/02004_max_hyperscan_regex_length.reference\n@@ -1,3 +1,11 @@\n+- const pattern\n+1\n+1\n+[1]\n+1\n+1\n+[1]\n+- non-const pattern\n 1\n 1\n [1]\ndiff --git a/tests/queries/0_stateless/02004_max_hyperscan_regex_length.sql b/tests/queries/0_stateless/02004_max_hyperscan_regex_length.sql\nindex df78b3ed2729..17d3796e88ca 100644\n--- a/tests/queries/0_stateless/02004_max_hyperscan_regex_length.sql\n+++ b/tests/queries/0_stateless/02004_max_hyperscan_regex_length.sql\n@@ -3,6 +3,8 @@\n set max_hyperscan_regexp_length = 1;\n set max_hyperscan_regexp_total_length = 1;\n \n+SELECT '- const pattern';\n+\n select multiMatchAny('123', ['1']);\n select multiMatchAny('123', ['12']); -- { serverError 36 }\n select multiMatchAny('123', ['1', '2']); -- { serverError 36 }\n@@ -26,3 +28,29 @@ select multiFuzzyMatchAnyIndex('123', 0, ['1', '2']); -- { serverError 36 }\n select multiFuzzyMatchAllIndices('123', 0, ['1']);\n select multiFuzzyMatchAllIndices('123', 0, ['12']); -- { serverError 36 }\n select multiFuzzyMatchAllIndices('123', 0, ['1', '2']); -- { serverError 36 }\n+\n+SELECT '- non-const pattern';\n+\n+select multiMatchAny(materialize('123'), materialize(['1']));\n+select multiMatchAny(materialize('123'), materialize(['12'])); -- { serverError 36 }\n+select multiMatchAny(materialize('123'), materialize(['1', '2'])); -- { serverError 36 }\n+\n+select multiMatchAnyIndex(materialize('123'), materialize(['1']));\n+select multiMatchAnyIndex(materialize('123'), materialize(['12'])); -- { serverError 36 }\n+select multiMatchAnyIndex(materialize('123'), materialize(['1', '2'])); -- { serverError 36 }\n+\n+select multiMatchAllIndices(materialize('123'), materialize(['1']));\n+select multiMatchAllIndices(materialize('123'), materialize(['12'])); -- { serverError 36 }\n+select multiMatchAllIndices(materialize('123'), materialize(['1', '2'])); -- { serverError 36 }\n+\n+select multiFuzzyMatchAny(materialize('123'), 0, materialize(['1']));\n+select multiFuzzyMatchAny(materialize('123'), 0, materialize(['12'])); -- { serverError 36 }\n+select multiFuzzyMatchAny(materialize('123'), 0, materialize(['1', '2'])); -- { serverError 36 }\n+\n+select multiFuzzyMatchAnyIndex(materialize('123'), 0, materialize(['1']));\n+select multiFuzzyMatchAnyIndex(materialize('123'), 0, materialize(['12'])); -- { serverError 36 }\n+select multiFuzzyMatchAnyIndex(materialize('123'), 0, materialize(['1', '2'])); -- { serverError 36 }\n+\n+select multiFuzzyMatchAllIndices(materialize('123'), 0, materialize(['1']));\n+select multiFuzzyMatchAllIndices(materialize('123'), 0, materialize(['12'])); -- { serverError 36 }\n+select multiFuzzyMatchAllIndices(materialize('123'), 0, materialize(['1', '2'])); -- { serverError 36 }\ndiff --git a/tests/queries/0_stateless/02294_stringsearch_with_nonconst_needle.reference b/tests/queries/0_stateless/02294_stringsearch_with_nonconst_needle.reference\nindex 7471bcad00cb..76ebc1fb99e4 100644\n--- a/tests/queries/0_stateless/02294_stringsearch_with_nonconst_needle.reference\n+++ b/tests/queries/0_stateless/02294_stringsearch_with_nonconst_needle.reference\n@@ -188,3 +188,27 @@ MATCH\n 35\tHello\t.*ell.*\t1\n 36\tHello\to$\t1\n 37\tHello\thE.*lO\t0\n+MULTISEARCHANY\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+MULTISEARCHFIRSTINDEX\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+MULTISEARCHFIRSTPOSITION\n+1\n+1\n+1\n+1\n+1\n+1\n+1\ndiff --git a/tests/queries/0_stateless/02294_stringsearch_with_nonconst_needle.sql b/tests/queries/0_stateless/02294_stringsearch_with_nonconst_needle.sql\nindex 3057e3427332..6dd4c4f396d0 100644\n--- a/tests/queries/0_stateless/02294_stringsearch_with_nonconst_needle.sql\n+++ b/tests/queries/0_stateless/02294_stringsearch_with_nonconst_needle.sql\n@@ -1,3 +1,5 @@\n+-- tests of \"(not) (i)like\" functions\n+\n drop table if exists non_const_needle;\n \n create table non_const_needle\n@@ -34,3 +36,35 @@ select id, haystack, needle, match(haystack, needle)\n   order by id;\n \n drop table if exists non_const_needle;\n+\n+-- rudimentary tests of \"multiSearchFirstIndex()\", \"multiSearchAnyPosition()\" and \"multiSearchFirstIndex()\" functions\n+\n+select 'MULTISEARCHANY';\n+select multiSearchAny(materialize('Hello World'), materialize([])); -- { serverError 43 }\n+select 0 = multiSearchAny('Hello World', CAST([], 'Array(String)'));\n+select 1 = multiSearchAny(materialize('Hello World'), materialize(['orld']));\n+select 0 = multiSearchAny(materialize('Hello World'), materialize(['Hallo', 'Welt']));\n+select 1 = multiSearchAny(materialize('Hello World'), materialize(['Hallo', 'orld']));\n+select 1 = multiSearchAnyCaseInsensitive(materialize('Hello World'), materialize(['WORLD']));\n+select 1 = multiSearchAnyUTF8(materialize('Hello World \u00a3'), materialize(['WORLD', '\u00a3']));\n+select 1 = multiSearchAnyCaseInsensitiveUTF8(materialize('Hello World \u00a3'), materialize(['WORLD']));\n+\n+select 'MULTISEARCHFIRSTINDEX';\n+select multiSearchFirstIndex(materialize('Hello World'), materialize([])); -- { serverError 43 }\n+select 0 = multiSearchFirstIndex('Hello World', CAST([], 'Array(String)'));\n+select 1 = multiSearchFirstIndex(materialize('Hello World'), materialize(['orld']));\n+select 0 = multiSearchFirstIndex(materialize('Hello World'), materialize(['Hallo', 'Welt']));\n+select 2 = multiSearchFirstIndex(materialize('Hello World'), materialize(['Hallo', 'orld']));\n+select 1 = multiSearchFirstIndexCaseInsensitive(materialize('Hello World'), materialize(['WORLD']));\n+select 2 = multiSearchFirstIndexUTF8(materialize('Hello World \u00a3'), materialize(['WORLD', '\u00a3']));\n+select 1 = multiSearchFirstIndexCaseInsensitiveUTF8(materialize('Hello World \u00a3'), materialize(['WORLD']));\n+\n+select 'MULTISEARCHFIRSTPOSITION';\n+select multiSearchFirstPosition(materialize('Hello World'), materialize([])); -- { serverError 43 }\n+select 0 = multiSearchFirstPosition('Hello World', CAST([], 'Array(String)'));\n+select 8 = multiSearchFirstPosition(materialize('Hello World'), materialize(['orld']));\n+select 0 = multiSearchFirstPosition(materialize('Hello World'), materialize(['Hallo', 'Welt']));\n+select 8 = multiSearchFirstPosition(materialize('Hello World'), materialize(['Hallo', 'orld']));\n+select 7 = multiSearchFirstPositionCaseInsensitive(materialize('Hello World'), materialize(['WORLD']));\n+select 13 = multiSearchFirstPositionUTF8(materialize('Hello World \u00a3'), materialize(['WORLD', '\u00a3']));\n+select 7 = multiSearchFirstPositionCaseInsensitiveUTF8(materialize('Hello World \u00a3'), materialize(['WORLD']));\n",
  "problem_statement": "multiFuzzyMatchAny function requirement \n In the multiFuzzyMatchAny function, Please make it possible to use column values instead of constants for the third variable\r\nI really need this feature so much!\r\nI need to extract names that match ( like operator ) similarly to the data in the array value category.names , and I plan to do this regularly.\r\n\r\n**Use case**\r\n```\r\nSELECT\r\n    names,\r\n    multiFuzzyMatchAny(names, 1, a.`category.names`)\r\nFROM\r\n(\r\n    SELECT category.names AS names\r\n    FROM mall\r\n    ARRAY JOIN category\r\n) AS A\r\nCROSS JOIN a\r\nLIMIT 10\r\nDB::Exception: Argument at index 2 for function multiFuzzyMatchAny must be constant. (ILLEGAL_COLUMN)\r\n```\r\n\r\n**Describe the solution you'd like**\r\n\r\n> A clear and concise description of what you want to happen.\r\n\r\n**Describe alternatives you've considered**\r\n\r\n> A clear and concise description of any alternative solutions or features you've considered.\r\n\r\n**Additional context**\r\n\r\n> Add any other context or screenshots about the feature request here.\r\n\n",
  "hints_text": "The reason why it requires a constant argument is that compiling a regular expression (especially for fuzzy matching) can be heavy. Doing it for every record is unreasonable. The only viable case is when you have only a few different regexes.\nI'm expecting it to be heavy.\r\nBut isn't Clickhouse an analytics-specialized DBMS?\r\nif so, I think a function that matches similar text is absolutely necessary.\r\nHow about providing the function as an on/off function by setting a set parameter?\nSimilar functionality (non-const pattern/regex arguments) was added very recently for functions `(I)LIKE()` and `MATCH()` with #37251. Haven't checked in detail yet but I have at least a rough idea what needs to be changed for `multiFuzzyMatchAny()`.\r\n\r\n`multiFuzzyMatchAny()` leverages Intel's hyperscan library (at least on x86). Alexey proposed to replace this lib by vectorscan which is a community fork with SIMD support on other platforms. Having vectorscan is not a strict requirement for this ticket, but it would simplify things later on (+ make string matching functions faster on ARM). Guess we should do this first.",
  "created_at": "2022-06-27T19:49:53Z"
}