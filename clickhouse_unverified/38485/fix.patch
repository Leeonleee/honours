diff --git a/src/Functions/FunctionsMultiStringFuzzySearch.h b/src/Functions/FunctionsMultiStringFuzzySearch.h
index 865a5d182c8f..26cafa7d4109 100644
--- a/src/Functions/FunctionsMultiStringFuzzySearch.h
+++ b/src/Functions/FunctionsMultiStringFuzzySearch.h
@@ -46,7 +46,7 @@ class FunctionsMultiStringFuzzySearch : public IFunction
     size_t getNumberOfArguments() const override { return 3; }
     bool useDefaultImplementationForConstants() const override { return true; }
     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
-    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1, 2}; }
+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }
 
     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
     {
@@ -65,26 +65,30 @@ class FunctionsMultiStringFuzzySearch : public IFunction
 
     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override
     {
-        const ColumnPtr & column_haystack = arguments[0].column;
-        const ColumnPtr & num_ptr = arguments[1].column;
-        const ColumnPtr & arr_ptr = arguments[2].column;
+        const ColumnPtr & haystack_ptr = arguments[0].column;
+        const ColumnPtr & edit_distance_ptr = arguments[1].column;
+        const ColumnPtr & needles_ptr = arguments[2].column;
 
-        const ColumnString * col_haystack_vector = checkAndGetColumn<ColumnString>(&*column_haystack);
-        assert(col_haystack_vector); // getReturnTypeImpl() checks the data type
+        const ColumnString * col_haystack_vector = checkAndGetColumn<ColumnString>(&*haystack_ptr);
+        const ColumnConst * col_haystack_const = checkAndGetColumnConst<ColumnString>(&*haystack_ptr);
+        assert(static_cast<bool>(col_haystack_vector) ^ static_cast<bool>(col_haystack_const));
 
         UInt32 edit_distance = 0;
-        if (const auto * col_const_uint8 = checkAndGetColumnConst<ColumnUInt8>(num_ptr.get()))
+        if (const auto * col_const_uint8 = checkAndGetColumnConst<ColumnUInt8>(edit_distance_ptr.get()))
             edit_distance = col_const_uint8->getValue<UInt8>();
-        else if (const auto * col_const_uint16 = checkAndGetColumnConst<ColumnUInt16>(num_ptr.get()))
+        else if (const auto * col_const_uint16 = checkAndGetColumnConst<ColumnUInt16>(edit_distance_ptr.get()))
             edit_distance = col_const_uint16->getValue<UInt16>();
-        else if (const auto * col_const_uint32 = checkAndGetColumnConst<ColumnUInt32>(num_ptr.get()))
+        else if (const auto * col_const_uint32 = checkAndGetColumnConst<ColumnUInt32>(edit_distance_ptr.get()))
             edit_distance = col_const_uint32->getValue<UInt32>();
         else
             throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {}. The number is not const or does not fit in UInt32", arguments[1].column->getName());
 
-        const ColumnConst * col_const_arr = checkAndGetColumnConst<ColumnArray>(arr_ptr.get());
-        if (!col_const_arr)
-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {}. The array is not const", arguments[2].column->getName());
+        const ColumnArray * col_needles_vector = checkAndGetColumn<ColumnArray>(needles_ptr.get());
+        const ColumnConst * col_needles_const = checkAndGetColumnConst<ColumnArray>(needles_ptr.get());
+        assert(static_cast<bool>(col_needles_vector) ^ static_cast<bool>(col_needles_const));
+
+        if (col_haystack_const && col_needles_vector)
+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Function '{}' doesn't support search with non-constant needles in constant haystack", name);
 
         using ResultType = typename Impl::ResultType;
         auto col_res = ColumnVector<ResultType>::create();
@@ -92,12 +96,30 @@ class FunctionsMultiStringFuzzySearch : public IFunction
 
         auto & vec_res = col_res->getData();
         auto & offsets_res = col_offsets->getData();
-        // the implementations are responsible for resizing the output column
-
-        Array needles_arr = col_const_arr->getValue<Array>();
-        Impl::vectorConstant(
-            col_haystack_vector->getChars(), col_haystack_vector->getOffsets(), needles_arr, vec_res, offsets_res, edit_distance,
-            allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);
+        /// the implementations are responsible for resizing the output column
+
+        if (col_needles_const)
+        {
+            Impl::vectorConstant(
+                col_haystack_vector->getChars(), col_haystack_vector->getOffsets(),
+                col_needles_const->getValue<Array>(),
+                vec_res, offsets_res,
+                edit_distance,
+                allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);
+        }
+        else
+        {
+            Impl::vectorVector(
+                col_haystack_vector->getChars(), col_haystack_vector->getOffsets(),
+                col_needles_vector->getData(), col_needles_vector->getOffsets(),
+                vec_res, offsets_res,
+                edit_distance,
+                allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);
+        }
+
+        // the combination of const haystack + const needle is not implemented because
+        // useDefaultImplementationForConstants() == true makes upper layers convert both to
+        // non-const columns
 
         if constexpr (Impl::is_column_array)
             return ColumnArray::create(std::move(col_res), std::move(col_offsets));
diff --git a/src/Functions/FunctionsMultiStringSearch.h b/src/Functions/FunctionsMultiStringSearch.h
index 04235e0a97a5..fb800448bfae 100644
--- a/src/Functions/FunctionsMultiStringSearch.h
+++ b/src/Functions/FunctionsMultiStringSearch.h
@@ -61,7 +61,6 @@ class FunctionsMultiStringSearch : public IFunction
     size_t getNumberOfArguments() const override { return 2; }
     bool useDefaultImplementationForConstants() const override { return true; }
     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
-    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }
 
     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
     {
@@ -77,15 +76,19 @@ class FunctionsMultiStringSearch : public IFunction
 
     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override
     {
-        const ColumnPtr & column_haystack = arguments[0].column;
-        const ColumnPtr & arr_ptr = arguments[1].column;
+        const ColumnPtr & haystack_ptr = arguments[0].column;
+        const ColumnPtr & needles_ptr = arguments[1].column;
 
-        const ColumnString * col_haystack_vector = checkAndGetColumn<ColumnString>(&*column_haystack);
-        assert(col_haystack_vector); // getReturnTypeImpl() checks the data type
+        const ColumnString * col_haystack_vector = checkAndGetColumn<ColumnString>(&*haystack_ptr);
+        const ColumnConst * col_haystack_const = checkAndGetColumnConst<ColumnString>(&*haystack_ptr);
+        assert(static_cast<bool>(col_haystack_vector) ^ static_cast<bool>(col_haystack_const));
 
-        const ColumnConst * col_const_arr = checkAndGetColumnConst<ColumnArray>(arr_ptr.get());
-        if (!col_const_arr)
-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {}. The array is not const", arguments[1].column->getName());
+        const ColumnArray * col_needles_vector = checkAndGetColumn<ColumnArray>(needles_ptr.get());
+        const ColumnConst * col_needles_const = checkAndGetColumnConst<ColumnArray>(needles_ptr.get());
+        assert(static_cast<bool>(col_needles_vector) ^ static_cast<bool>(col_needles_const));
+
+        if (col_haystack_const && col_needles_vector)
+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Function '{}' doesn't support search with non-constant needles in constant haystack", name);
 
         using ResultType = typename Impl::ResultType;
         auto col_res = ColumnVector<ResultType>::create();
@@ -93,12 +96,28 @@ class FunctionsMultiStringSearch : public IFunction
 
         auto & vec_res = col_res->getData();
         auto & offsets_res = col_offsets->getData();
-        // the implementations are responsible for resizing the output column
-
-        Array needles_arr = col_const_arr->getValue<Array>();
-        Impl::vectorConstant(
-            col_haystack_vector->getChars(), col_haystack_vector->getOffsets(), needles_arr, vec_res, offsets_res,
-            allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);
+        /// the implementations are responsible for resizing the output column
+
+        if (col_needles_const)
+        {
+            Impl::vectorConstant(
+                col_haystack_vector->getChars(), col_haystack_vector->getOffsets(),
+                col_needles_const->getValue<Array>(),
+                vec_res, offsets_res,
+                allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);
+        }
+        else
+        {
+            Impl::vectorVector(
+                col_haystack_vector->getChars(), col_haystack_vector->getOffsets(),
+                col_needles_vector->getData(), col_needles_vector->getOffsets(),
+                vec_res, offsets_res,
+                allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);
+        }
+
+        // the combination of const haystack + const needle is not implemented because
+        // useDefaultImplementationForConstants() == true makes upper layers convert both to
+        // non-const columns
 
         if constexpr (Impl::is_column_array)
             return ColumnArray::create(std::move(col_res), std::move(col_offsets));
diff --git a/src/Functions/MultiMatchAllIndicesImpl.h b/src/Functions/MultiMatchAllIndicesImpl.h
index 9c60dbffe91f..c6a8a4776485 100644
--- a/src/Functions/MultiMatchAllIndicesImpl.h
+++ b/src/Functions/MultiMatchAllIndicesImpl.h
@@ -58,15 +58,15 @@ struct MultiMatchAllIndicesImpl
     }
 
     static void vectorConstant(
-        [[maybe_unused]] const ColumnString::Chars & haystack_data,
-        [[maybe_unused]] const ColumnString::Offsets & haystack_offsets,
-        [[maybe_unused]] const Array & needles_arr,
-        [[maybe_unused]] PaddedPODArray<ResultType> & res,
-        [[maybe_unused]] PaddedPODArray<UInt64> & offsets,
-        [[maybe_unused]] std::optional<UInt32> edit_distance,
+        const ColumnString::Chars & haystack_data,
+        const ColumnString::Offsets & haystack_offsets,
+        const Array & needles_arr,
+        PaddedPODArray<ResultType> & res,
+        PaddedPODArray<UInt64> & offsets,
+        std::optional<UInt32> edit_distance,
         bool allow_hyperscan,
-        [[maybe_unused]] size_t max_hyperscan_regexp_length,
-        [[maybe_unused]] size_t max_hyperscan_regexp_total_length)
+        size_t max_hyperscan_regexp_length,
+        size_t max_hyperscan_regexp_total_length)
     {
         if (!allow_hyperscan)
             throw Exception(ErrorCodes::FUNCTION_NOT_ALLOWED, "Hyperscan functions are disabled, because setting 'allow_hyperscan' is set to 0");
@@ -79,6 +79,7 @@ struct MultiMatchAllIndicesImpl
         checkHyperscanRegexp(needles, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);
 
         offsets.resize(haystack_offsets.size());
+
         const auto & hyperscan_regex = MultiRegexps::get</*SaveIndices=*/true, WithEditDistance>(needles, edit_distance);
         hs_scratch_t * scratch = nullptr;
         hs_error_t err = hs_clone_scratch(hyperscan_regex->getScratch(), &scratch);
@@ -102,10 +103,10 @@ struct MultiMatchAllIndicesImpl
         for (size_t i = 0; i < haystack_offsets_size; ++i)
         {
             UInt64 length = haystack_offsets[i] - offset - 1;
-            /// Hyperscan restriction.
+            /// vectorscan restriction.
             if (length > std::numeric_limits<UInt32>::max())
                 throw Exception("Too long string to search", ErrorCodes::TOO_MANY_BYTES);
-            /// Scan, check, update the offsets array and the offset of haystack.
+            /// scan, check, update the offsets array and the offset of haystack.
             err = hs_scan(
                 hyperscan_regex->getDB(),
                 reinterpret_cast<const char *>(haystack_data.data()) + offset,
@@ -120,6 +121,121 @@ struct MultiMatchAllIndicesImpl
             offset = haystack_offsets[i];
         }
 #else
+        (void)haystack_data;
+        (void)haystack_offsets;
+        (void)needles_arr;
+        (void)res;
+        (void)offsets;
+        (void)edit_distance;
+        (void)max_hyperscan_regexp_length;
+        (void)max_hyperscan_regexp_total_length;
+        throw Exception(
+            "multi-search all indices is not implemented when vectorscan is off",
+            ErrorCodes::NOT_IMPLEMENTED);
+#endif // USE_VECTORSCAN
+    }
+
+    static void vectorVector(
+        const ColumnString::Chars & haystack_data,
+        const ColumnString::Offsets & haystack_offsets,
+        const IColumn & needles_data,
+        const ColumnArray::Offsets & needles_offsets,
+        PaddedPODArray<ResultType> & res,
+        PaddedPODArray<UInt64> & offsets,
+        bool allow_hyperscan,
+        size_t max_hyperscan_regexp_length,
+        size_t max_hyperscan_regexp_total_length)
+    {
+        vectorVector(haystack_data, haystack_offsets, needles_data, needles_offsets, res, offsets, std::nullopt, allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);
+    }
+
+    static void vectorVector(
+        const ColumnString::Chars & haystack_data,
+        const ColumnString::Offsets & haystack_offsets,
+        const IColumn & needles_data,
+        const ColumnArray::Offsets & needles_offsets,
+        PaddedPODArray<ResultType> & res,
+        PaddedPODArray<UInt64> & offsets,
+        std::optional<UInt32> edit_distance,
+        bool allow_hyperscan,
+        size_t max_hyperscan_regexp_length,
+        size_t max_hyperscan_regexp_total_length)
+    {
+        if (!allow_hyperscan)
+            throw Exception(ErrorCodes::FUNCTION_NOT_ALLOWED, "Hyperscan functions are disabled, because setting 'allow_hyperscan' is set to 0");
+#if USE_VECTORSCAN
+        offsets.resize(haystack_offsets.size());
+        size_t prev_haystack_offset = 0;
+        size_t prev_needles_offset = 0;
+
+        const ColumnString * needles_data_string = checkAndGetColumn<ColumnString>(&needles_data);
+
+        std::vector<std::string_view> needles;
+
+        for (size_t i = 0; i < haystack_offsets.size(); ++i)
+        {
+            needles.reserve(needles_offsets[i] - prev_needles_offset);
+
+            for (size_t j = prev_needles_offset; j < needles_offsets[i]; ++j)
+            {
+                needles.emplace_back(needles_data_string->getDataAt(j).toView());
+            }
+
+            checkHyperscanRegexp(needles, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);
+
+            const auto & hyperscan_regex = MultiRegexps::get</*SaveIndices=*/true, WithEditDistance>(needles, edit_distance);
+            hs_scratch_t * scratch = nullptr;
+            hs_error_t err = hs_clone_scratch(hyperscan_regex->getScratch(), &scratch);
+
+            if (err != HS_SUCCESS)
+                throw Exception("Could not clone scratch space for hyperscan", ErrorCodes::CANNOT_ALLOCATE_MEMORY);
+
+            MultiRegexps::ScratchPtr smart_scratch(scratch);
+
+            auto on_match = [](unsigned int id,
+                               unsigned long long /* from */, // NOLINT
+                               unsigned long long /* to */, // NOLINT
+                               unsigned int /* flags */,
+                               void * context) -> int
+            {
+                static_cast<PaddedPODArray<ResultType>*>(context)->push_back(id);
+                return 0;
+            };
+
+            const size_t cur_haystack_length = haystack_offsets[i] - prev_haystack_offset - 1;
+
+            /// vectorscan restriction.
+            if (cur_haystack_length > std::numeric_limits<UInt32>::max())
+                throw Exception("Too long string to search", ErrorCodes::TOO_MANY_BYTES);
+
+            /// scan, check, update the offsets array and the offset of haystack.
+            err = hs_scan(
+                hyperscan_regex->getDB(),
+                reinterpret_cast<const char *>(haystack_data.data()) + prev_haystack_offset,
+                cur_haystack_length,
+                0,
+                smart_scratch.get(),
+                on_match,
+                &res);
+            if (err != HS_SUCCESS)
+                throw Exception("Failed to scan with vectorscan", ErrorCodes::HYPERSCAN_CANNOT_SCAN_TEXT);
+
+            offsets[i] = res.size();
+
+            prev_haystack_offset = haystack_offsets[i];
+            prev_needles_offset = needles_offsets[i];
+            needles.clear();
+        }
+#else
+        (void)haystack_data;
+        (void)haystack_offsets;
+        (void)needles_data;
+        (void)needles_offsets;
+        (void)res;
+        (void)offsets;
+        (void)edit_distance;
+        (void)max_hyperscan_regexp_length;
+        (void)max_hyperscan_regexp_total_length;
         throw Exception(
             "multi-search all indices is not implemented when vectorscan is off",
             ErrorCodes::NOT_IMPLEMENTED);
diff --git a/src/Functions/MultiMatchAnyImpl.h b/src/Functions/MultiMatchAnyImpl.h
index 0752e87e8afb..38b1e37eca55 100644
--- a/src/Functions/MultiMatchAnyImpl.h
+++ b/src/Functions/MultiMatchAnyImpl.h
@@ -14,6 +14,7 @@
 #    include <hs.h>
 #else
 #    include "MatchImpl.h"
+    #include <Common/Volnitsky.h>
 #endif
 
 
@@ -29,7 +30,7 @@ namespace ErrorCodes
     extern const int TOO_MANY_BYTES;
 }
 
-// For more readable instantiations of MultiMatchAnyImpl<>
+/// For more readable instantiations of MultiMatchAnyImpl<>
 struct MultiMatchTraits
 {
 enum class Find
@@ -75,7 +76,7 @@ struct MultiMatchAnyImpl
         const ColumnString::Offsets & haystack_offsets,
         const Array & needles_arr,
         PaddedPODArray<ResultType> & res,
-        [[maybe_unused]] PaddedPODArray<UInt64> & offsets,
+        PaddedPODArray<UInt64> & /*offsets*/,
         [[maybe_unused]] std::optional<UInt32> edit_distance,
         bool allow_hyperscan,
         size_t max_hyperscan_regexp_length,
@@ -93,7 +94,7 @@ struct MultiMatchAnyImpl
 
         res.resize(haystack_offsets.size());
 #if USE_VECTORSCAN
-        const auto & hyperscan_regex = MultiRegexps::get<FindAnyIndex, WithEditDistance>(needles, edit_distance);
+        const auto & hyperscan_regex = MultiRegexps::get</*SaveIndices*/ FindAnyIndex, WithEditDistance>(needles, edit_distance);
         hs_scratch_t * scratch = nullptr;
         hs_error_t err = hs_clone_scratch(hyperscan_regex->getScratch(), &scratch);
 
@@ -120,10 +121,10 @@ struct MultiMatchAnyImpl
         for (size_t i = 0; i < haystack_offsets_size; ++i)
         {
             UInt64 length = haystack_offsets[i] - offset - 1;
-            /// Vectorscan restriction.
+            /// vectorscan restriction.
             if (length > std::numeric_limits<UInt32>::max())
                 throw Exception("Too long string to search", ErrorCodes::TOO_MANY_BYTES);
-            /// Zero the result, scan, check, update the offset.
+            /// zero the result, scan, check, update the offset.
             res[i] = 0;
             err = hs_scan(
                 hyperscan_regex->getDB(),
@@ -138,7 +139,7 @@ struct MultiMatchAnyImpl
             offset = haystack_offsets[i];
         }
 #else
-        // fallback if vectorscan is not compiled
+        /// fallback if vectorscan is not compiled
         if constexpr (WithEditDistance)
             throw Exception(
                 "Edit distance multi-search is not implemented when vectorscan is off",
@@ -157,6 +158,218 @@ struct MultiMatchAnyImpl
                     res[i] = j + 1;
             }
         }
+#endif // USE_VECTORSCAN
+    }
+
+    static void vectorVector(
+        const ColumnString::Chars & haystack_data,
+        const ColumnString::Offsets & haystack_offsets,
+        const IColumn & needles_data,
+        const ColumnArray::Offsets & needles_offsets,
+        PaddedPODArray<ResultType> & res,
+        PaddedPODArray<UInt64> & offsets,
+        bool allow_hyperscan,
+        size_t max_hyperscan_regexp_length,
+        size_t max_hyperscan_regexp_total_length)
+    {
+        vectorVector(haystack_data, haystack_offsets, needles_data, needles_offsets, res, offsets, std::nullopt, allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);
+    }
+
+    static void vectorVector(
+        const ColumnString::Chars & haystack_data,
+        const ColumnString::Offsets & haystack_offsets,
+        const IColumn & needles_data,
+        const ColumnArray::Offsets & needles_offsets,
+        PaddedPODArray<ResultType> & res,
+        PaddedPODArray<UInt64> & /*offsets*/,
+        std::optional<UInt32> edit_distance,
+        bool allow_hyperscan,
+        size_t max_hyperscan_regexp_length,
+        size_t max_hyperscan_regexp_total_length)
+    {
+        if (!allow_hyperscan)
+            throw Exception(ErrorCodes::FUNCTION_NOT_ALLOWED, "Hyperscan functions are disabled, because setting 'allow_hyperscan' is set to 0");
+
+        res.resize(haystack_offsets.size());
+#if USE_VECTORSCAN
+        size_t prev_haystack_offset = 0;
+        size_t prev_needles_offset = 0;
+
+        const ColumnString * needles_data_string = checkAndGetColumn<ColumnString>(&needles_data);
+
+        std::vector<std::string_view> needles;
+
+        for (size_t i = 0; i < haystack_offsets.size(); ++i)
+        {
+            needles.reserve(needles_offsets[i] - prev_needles_offset);
+
+            for (size_t j = prev_needles_offset; j < needles_offsets[i]; ++j)
+            {
+                needles.emplace_back(needles_data_string->getDataAt(j).toView());
+            }
+
+            checkHyperscanRegexp(needles, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);
+
+            const auto & hyperscan_regex = MultiRegexps::get</*SaveIndices*/ FindAnyIndex, WithEditDistance>(needles, edit_distance);
+            hs_scratch_t * scratch = nullptr;
+            hs_error_t err = hs_clone_scratch(hyperscan_regex->getScratch(), &scratch);
+
+            if (err != HS_SUCCESS)
+                throw Exception("Could not clone scratch space for vectorscan", ErrorCodes::CANNOT_ALLOCATE_MEMORY);
+
+            MultiRegexps::ScratchPtr smart_scratch(scratch);
+
+            auto on_match = []([[maybe_unused]] unsigned int id,
+                               unsigned long long /* from */, // NOLINT
+                               unsigned long long /* to */, // NOLINT
+                               unsigned int /* flags */,
+                               void * context) -> int
+            {
+                if constexpr (FindAnyIndex)
+                    *reinterpret_cast<ResultType *>(context) = id;
+                else if constexpr (FindAny)
+                    *reinterpret_cast<ResultType *>(context) = 1;
+                /// Once we hit the callback, there is no need to search for others.
+                return 1;
+            };
+
+            const size_t cur_haystack_length = haystack_offsets[i] - prev_haystack_offset - 1;
+
+            /// vectorscan restriction.
+            if (cur_haystack_length > std::numeric_limits<UInt32>::max())
+                throw Exception("Too long string to search", ErrorCodes::TOO_MANY_BYTES);
+
+            /// zero the result, scan, check, update the offset.
+            res[i] = 0;
+            err = hs_scan(
+                hyperscan_regex->getDB(),
+                reinterpret_cast<const char *>(haystack_data.data()) + prev_haystack_offset,
+                cur_haystack_length,
+                0,
+                smart_scratch.get(),
+                on_match,
+                &res[i]);
+            if (err != HS_SUCCESS && err != HS_SCAN_TERMINATED)
+                throw Exception("Failed to scan with vectorscan", ErrorCodes::HYPERSCAN_CANNOT_SCAN_TEXT);
+
+            prev_haystack_offset = haystack_offsets[i];
+            prev_needles_offset = needles_offsets[i];
+            needles.clear();
+        }
+#else
+        /// fallback if vectorscan is not compiled
+        /// -- the code is copypasted from vectorVector() in MatchImpl.h and quite complex code ... all of it can be removed once vectorscan is
+        ///    enabled on all platforms (#38906)
+        if constexpr (WithEditDistance)
+            throw Exception(
+                "Edit distance multi-search is not implemented when vectorscan is off",
+                ErrorCodes::NOT_IMPLEMENTED);
+
+        (void)edit_distance;
+
+        memset(res.data(), 0, res.size() * sizeof(res.front()));
+
+        size_t prev_haystack_offset = 0;
+        size_t prev_needles_offset = 0;
+
+        const ColumnString * needles_data_string = checkAndGetColumn<ColumnString>(&needles_data);
+
+        std::vector<std::string_view> needles;
+
+        for (size_t i = 0; i < haystack_offsets.size(); ++i)
+        {
+            const auto * const cur_haystack_data = &haystack_data[prev_haystack_offset];
+            const size_t cur_haystack_length = haystack_offsets[i] - prev_haystack_offset - 1;
+
+            needles.reserve(needles_offsets[i] - prev_needles_offset);
+
+            for (size_t j = prev_needles_offset; j < needles_offsets[i]; ++j)
+            {
+                needles.emplace_back(needles_data_string->getDataAt(j).toView());
+            }
+
+            checkHyperscanRegexp(needles, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);
+
+            for (size_t j = 0; j < needles.size(); ++j)
+            {
+                String needle(needles[j]);
+
+                const auto & regexp = Regexps::Regexp(Regexps::createRegexp</*like*/ false, /*no_capture*/ true, /*case_insensitive*/ false>(needle));
+
+                String required_substr;
+                bool is_trivial;
+                bool required_substring_is_prefix; /// for `anchored` execution of the regexp.
+
+                regexp.getAnalyzeResult(required_substr, is_trivial, required_substring_is_prefix);
+
+                if (required_substr.empty())
+                {
+                    if (!regexp.getRE2()) /// An empty regexp. Always matches.
+                    {
+                        if constexpr (FindAny)
+                            res[i] |= 1;
+                        else if (FindAnyIndex)
+                            res[i] = j + 1;
+                    }
+                    else
+                    {
+                        const bool match = regexp.getRE2()->Match(
+                                {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},
+                                0,
+                                cur_haystack_length,
+                                re2_st::RE2::UNANCHORED,
+                                nullptr,
+                                0);
+                        if constexpr (FindAny)
+                            res[i] |= match;
+                        else if (FindAnyIndex && match)
+                            res[i] = j + 1;
+                    }
+                }
+                else
+                {
+                    Volnitsky searcher(required_substr.data(), required_substr.size(), cur_haystack_length);
+                    const auto * match = searcher.search(cur_haystack_data, cur_haystack_length);
+
+                    if (match == cur_haystack_data + cur_haystack_length)
+                    {
+                        /// no match
+                    }
+                    else
+                    {
+                        if (is_trivial)
+                        {
+                            /// no wildcards in pattern
+                            if constexpr (FindAny)
+                                res[i] |= 1;
+                            else if (FindAnyIndex)
+                                res[i] = j + 1;
+                        }
+                        else
+                        {
+                            const size_t start_pos = (required_substring_is_prefix) ? (match - cur_haystack_data) : 0;
+                            const size_t end_pos = cur_haystack_length;
+
+                            const bool match2 = regexp.getRE2()->Match(
+                                    {reinterpret_cast<const char *>(cur_haystack_data), cur_haystack_length},
+                                    start_pos,
+                                    end_pos,
+                                    re2_st::RE2::UNANCHORED,
+                                    nullptr,
+                                    0);
+                            if constexpr (FindAny)
+                                res[i] |= match2;
+                            else if (FindAnyIndex && match2)
+                                res[i] = j + 1;
+                            }
+                    }
+                }
+            }
+
+            prev_haystack_offset = haystack_offsets[i];
+            prev_needles_offset = needles_offsets[i];
+            needles.clear();
+        }
 #endif // USE_VECTORSCAN
     }
 };
diff --git a/src/Functions/MultiSearchFirstIndexImpl.h b/src/Functions/MultiSearchFirstIndexImpl.h
index f69a3edbf8b1..f108f2ca41e2 100644
--- a/src/Functions/MultiSearchFirstIndexImpl.h
+++ b/src/Functions/MultiSearchFirstIndexImpl.h
@@ -29,7 +29,7 @@ struct MultiSearchFirstIndexImpl
         const ColumnString::Offsets & haystack_offsets,
         const Array & needles_arr,
         PaddedPODArray<UInt64> & res,
-        [[maybe_unused]] PaddedPODArray<UInt64> & offsets,
+        PaddedPODArray<UInt64> & /*offsets*/,
         bool /*allow_hyperscan*/,
         size_t /*max_hyperscan_regexp_length*/,
         size_t /*max_hyperscan_regexp_total_length*/)
@@ -46,26 +46,83 @@ struct MultiSearchFirstIndexImpl
             needles.emplace_back(needle.get<String>());
 
         auto searcher = Impl::createMultiSearcherInBigHaystack(needles);
-        const size_t haystack_string_size = haystack_offsets.size();
-        res.resize(haystack_string_size);
+
+        const size_t haystack_size = haystack_offsets.size();
+        res.resize(haystack_size);
+
         size_t iteration = 0;
         while (searcher.hasMoreToSearch())
         {
-            size_t prev_offset = 0;
-            for (size_t j = 0; j < haystack_string_size; ++j)
+            size_t prev_haystack_offset = 0;
+            for (size_t j = 0; j < haystack_size; ++j)
             {
-                const auto * haystack = &haystack_data[prev_offset];
-                const auto * haystack_end = haystack + haystack_offsets[j] - prev_offset - 1;
+                const auto * haystack = &haystack_data[prev_haystack_offset];
+                const auto * haystack_end = haystack + haystack_offsets[j] - prev_haystack_offset - 1;
                 /// hasMoreToSearch traverse needles in increasing order
                 if (iteration == 0 || res[j] == 0)
                     res[j] = searcher.searchOneFirstIndex(haystack, haystack_end);
-                prev_offset = haystack_offsets[j];
+                prev_haystack_offset = haystack_offsets[j];
             }
             ++iteration;
         }
         if (iteration == 0)
             std::fill(res.begin(), res.end(), 0);
     }
+
+    static void vectorVector(
+        const ColumnString::Chars & haystack_data,
+        const ColumnString::Offsets & haystack_offsets,
+        const IColumn & needles_data,
+        const ColumnArray::Offsets & needles_offsets,
+        PaddedPODArray<ResultType> & res,
+        PaddedPODArray<UInt64> & /*offsets*/,
+        bool /*allow_hyperscan*/,
+        size_t /*max_hyperscan_regexp_length*/,
+        size_t /*max_hyperscan_regexp_total_length*/)
+    {
+        const size_t haystack_size = haystack_offsets.size();
+        res.resize(haystack_size);
+
+        size_t prev_haystack_offset = 0;
+        size_t prev_needles_offset = 0;
+
+        const ColumnString * needles_data_string = checkAndGetColumn<ColumnString>(&needles_data);
+
+        std::vector<std::string_view> needles;
+
+        for (size_t i = 0; i < haystack_size; ++i)
+        {
+            needles.reserve(needles_offsets[i] - prev_needles_offset);
+
+            for (size_t j = prev_needles_offset; j < needles_offsets[i]; ++j)
+            {
+                needles.emplace_back(needles_data_string->getDataAt(j).toView());
+            }
+
+            auto searcher = Impl::createMultiSearcherInBigHaystack(needles); // sub-optimal
+
+            const auto * const haystack = &haystack_data[prev_haystack_offset];
+            const auto * haystack_end = haystack + haystack_offsets[i] - prev_haystack_offset - 1;
+
+            size_t iteration = 0;
+            while (searcher.hasMoreToSearch())
+            {
+                if (iteration == 0 || res[i] == 0)
+                {
+                    res[i] = searcher.searchOneFirstIndex(haystack, haystack_end);
+                }
+                ++iteration;
+            }
+            if (iteration == 0)
+            {
+                res[i] = 0;
+            }
+
+            prev_haystack_offset = haystack_offsets[i];
+            prev_needles_offset = needles_offsets[i];
+            needles.clear();
+        }
+    }
 };
 
 }
diff --git a/src/Functions/MultiSearchFirstPositionImpl.h b/src/Functions/MultiSearchFirstPositionImpl.h
index 21d558a6d58c..69cab478d134 100644
--- a/src/Functions/MultiSearchFirstPositionImpl.h
+++ b/src/Functions/MultiSearchFirstPositionImpl.h
@@ -29,7 +29,7 @@ struct MultiSearchFirstPositionImpl
         const ColumnString::Offsets & haystack_offsets,
         const Array & needles_arr,
         PaddedPODArray<UInt64> & res,
-        [[maybe_unused]] PaddedPODArray<UInt64> & offsets,
+        PaddedPODArray<UInt64> & /*offsets*/,
         bool /*allow_hyperscan*/,
         size_t /*max_hyperscan_regexp_length*/,
         size_t /*max_hyperscan_regexp_total_length*/)
@@ -50,16 +50,18 @@ struct MultiSearchFirstPositionImpl
             return 1 + Impl::countChars(reinterpret_cast<const char *>(start), reinterpret_cast<const char *>(end));
         };
         auto searcher = Impl::createMultiSearcherInBigHaystack(needles);
-        const size_t haystack_string_size = haystack_offsets.size();
-        res.resize(haystack_string_size);
+
+        const size_t haystack_size = haystack_offsets.size();
+        res.resize(haystack_size);
+
         size_t iteration = 0;
         while (searcher.hasMoreToSearch())
         {
-            size_t prev_offset = 0;
-            for (size_t j = 0; j < haystack_string_size; ++j)
+            size_t prev_haystack_offset = 0;
+            for (size_t j = 0; j < haystack_size; ++j)
             {
-                const auto * haystack = &haystack_data[prev_offset];
-                const auto * haystack_end = haystack + haystack_offsets[j] - prev_offset - 1;
+                const auto * haystack = &haystack_data[prev_haystack_offset];
+                const auto * haystack_end = haystack + haystack_offsets[j] - prev_haystack_offset - 1;
                 if (iteration == 0 || res[j] == 0)
                     res[j] = searcher.searchOneFirstPosition(haystack, haystack_end, res_callback);
                 else
@@ -68,13 +70,81 @@ struct MultiSearchFirstPositionImpl
                     if (result != 0)
                         res[j] = std::min(result, res[j]);
                 }
-                prev_offset = haystack_offsets[j];
+                prev_haystack_offset = haystack_offsets[j];
             }
             ++iteration;
         }
         if (iteration == 0)
             std::fill(res.begin(), res.end(), 0);
     }
+
+    static void vectorVector(
+        const ColumnString::Chars & haystack_data,
+        const ColumnString::Offsets & haystack_offsets,
+        const IColumn & needles_data,
+        const ColumnArray::Offsets & needles_offsets,
+        PaddedPODArray<ResultType> & res,
+        PaddedPODArray<UInt64> & /*offsets*/,
+        bool /*allow_hyperscan*/,
+        size_t /*max_hyperscan_regexp_length*/,
+        size_t /*max_hyperscan_regexp_total_length*/)
+    {
+        const size_t haystack_size = haystack_offsets.size();
+        res.resize(haystack_size);
+
+        size_t prev_haystack_offset = 0;
+        size_t prev_needles_offset = 0;
+
+        const ColumnString * needles_data_string = checkAndGetColumn<ColumnString>(&needles_data);
+
+        std::vector<std::string_view> needles;
+
+        auto res_callback = [](const UInt8 * start, const UInt8 * end) -> UInt64
+        {
+            return 1 + Impl::countChars(reinterpret_cast<const char *>(start), reinterpret_cast<const char *>(end));
+        };
+
+        for (size_t i = 0; i < haystack_size; ++i)
+        {
+            needles.reserve(needles_offsets[i] - prev_needles_offset);
+
+            for (size_t j = prev_needles_offset; j < needles_offsets[i]; ++j)
+            {
+                needles.emplace_back(needles_data_string->getDataAt(j).toView());
+            }
+
+            auto searcher = Impl::createMultiSearcherInBigHaystack(needles); // sub-optimal
+
+            const auto * const haystack = &haystack_data[prev_haystack_offset];
+            const auto * haystack_end = haystack + haystack_offsets[i] - prev_haystack_offset - 1;
+
+            size_t iteration = 0;
+            while (searcher.hasMoreToSearch())
+            {
+                if (iteration == 0 || res[i] == 0)
+                {
+                    res[i] = searcher.searchOneFirstPosition(haystack, haystack_end, res_callback);
+                }
+                else
+                {
+                    UInt64 result = searcher.searchOneFirstPosition(haystack, haystack_end, res_callback);
+                    if (result != 0)
+                    {
+                        res[i] = std::min(result, res[i]);
+                    }
+                }
+                ++iteration;
+            }
+            if (iteration == 0)
+            {
+                res[i] = 0;
+            }
+
+            prev_haystack_offset = haystack_offsets[i];
+            prev_needles_offset = needles_offsets[i];
+            needles.clear();
+        }
+    }
 };
 
 }
diff --git a/src/Functions/MultiSearchImpl.h b/src/Functions/MultiSearchImpl.h
index 1124184f58cd..b9ce02932345 100644
--- a/src/Functions/MultiSearchImpl.h
+++ b/src/Functions/MultiSearchImpl.h
@@ -29,7 +29,7 @@ struct MultiSearchImpl
         const ColumnString::Offsets & haystack_offsets,
         const Array & needles_arr,
         PaddedPODArray<UInt8> & res,
-        [[maybe_unused]] PaddedPODArray<UInt64> & offsets,
+        PaddedPODArray<UInt64> & /*offsets*/,
         bool /*allow_hyperscan*/,
         size_t /*max_hyperscan_regexp_length*/,
         size_t /*max_hyperscan_regexp_total_length*/)
@@ -46,25 +46,80 @@ struct MultiSearchImpl
             needles.emplace_back(needle.get<String>());
 
         auto searcher = Impl::createMultiSearcherInBigHaystack(needles);
-        const size_t haystack_string_size = haystack_offsets.size();
-        res.resize(haystack_string_size);
+
+        const size_t haystack_size = haystack_offsets.size();
+        res.resize(haystack_size);
+
         size_t iteration = 0;
         while (searcher.hasMoreToSearch())
         {
-            size_t prev_offset = 0;
-            for (size_t j = 0; j < haystack_string_size; ++j)
+            size_t prev_haystack_offset = 0;
+            for (size_t j = 0; j < haystack_size; ++j)
             {
-                const auto * haystack = &haystack_data[prev_offset];
-                const auto * haystack_end = haystack + haystack_offsets[j] - prev_offset - 1;
+                const auto * haystack = &haystack_data[prev_haystack_offset];
+                const auto * haystack_end = haystack + haystack_offsets[j] - prev_haystack_offset - 1;
                 if (iteration == 0 || !res[j])
                     res[j] = searcher.searchOne(haystack, haystack_end);
-                prev_offset = haystack_offsets[j];
+                prev_haystack_offset = haystack_offsets[j];
             }
             ++iteration;
         }
         if (iteration == 0)
             std::fill(res.begin(), res.end(), 0);
     }
+
+    static void vectorVector(
+        const ColumnString::Chars & haystack_data,
+        const ColumnString::Offsets & haystack_offsets,
+        const IColumn & needles_data,
+        const ColumnArray::Offsets & needles_offsets,
+        PaddedPODArray<ResultType> & res,
+        PaddedPODArray<UInt64> & /*offsets*/,
+        bool /*allow_hyperscan*/,
+        size_t /*max_hyperscan_regexp_length*/,
+        size_t /*max_hyperscan_regexp_total_length*/)
+    {
+        const size_t haystack_size = haystack_offsets.size();
+        res.resize(haystack_size);
+
+        size_t prev_haystack_offset = 0;
+        size_t prev_needles_offset = 0;
+
+        const ColumnString * needles_data_string = checkAndGetColumn<ColumnString>(&needles_data);
+
+        std::vector<std::string_view> needles;
+
+        for (size_t i = 0; i < haystack_size; ++i)
+        {
+            needles.reserve(needles_offsets[i] - prev_needles_offset);
+
+            for (size_t j = prev_needles_offset; j < needles_offsets[i]; ++j)
+            {
+                needles.emplace_back(needles_data_string->getDataAt(j).toView());
+            }
+
+            const auto * const haystack = &haystack_data[prev_haystack_offset];
+            const size_t haystack_length = haystack_offsets[i] - prev_haystack_offset - 1;
+
+            size_t iteration = 0;
+            for (const auto & needle : needles)
+            {
+                auto searcher = Impl::createSearcherInSmallHaystack(needle.data(), needle.size());
+                if (iteration == 0 || !res[i])
+                {
+                    const auto * match = searcher.search(haystack, haystack_length);
+                    res[i] = (match != haystack + haystack_length);
+                }
+                ++iteration;
+            }
+            if (iteration == 0)
+                res[i] = 0;
+
+            prev_haystack_offset = haystack_offsets[i];
+            prev_needles_offset = needles_offsets[i];
+            needles.clear();
+        }
+    }
 };
 
 }
diff --git a/src/Functions/checkHyperscanRegexp.h b/src/Functions/checkHyperscanRegexp.h
index 2aac44115fc6..e5f1165a949d 100644
--- a/src/Functions/checkHyperscanRegexp.h
+++ b/src/Functions/checkHyperscanRegexp.h
@@ -1,6 +1,7 @@
 #pragma once
 
-#include <base/StringRef.h>
+#include <string_view>
+#include <vector>
 
 namespace DB
 {
