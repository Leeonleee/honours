{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 62364,
  "instance_id": "ClickHouse__ClickHouse-62364",
  "issue_numbers": [
    "24778"
  ],
  "base_commit": "1cdccd527f0cbf5629b21d29970e28d5156003dc",
  "patch": "diff --git a/src/Storages/MergeTree/MergeProjectionPartsTask.cpp b/src/Storages/MergeTree/MergeProjectionPartsTask.cpp\nnew file mode 100644\nindex 000000000000..bdc2ba8b9cac\n--- /dev/null\n+++ b/src/Storages/MergeTree/MergeProjectionPartsTask.cpp\n@@ -0,0 +1,95 @@\n+#include <Storages/MergeTree/MergeProjectionPartsTask.h>\n+\n+#include <Common/TransactionID.h>\n+#include <Storages/MergeTree/MergeList.h>\n+\n+namespace DB\n+{\n+\n+bool MergeProjectionPartsTask::executeStep()\n+{\n+    auto & current_level_parts = level_parts[current_level];\n+    auto & next_level_parts = level_parts[next_level];\n+\n+    MergeTreeData::MutableDataPartsVector selected_parts;\n+    while (selected_parts.size() < max_parts_to_merge_in_one_level && !current_level_parts.empty())\n+    {\n+        selected_parts.push_back(std::move(current_level_parts.back()));\n+        current_level_parts.pop_back();\n+    }\n+\n+    if (selected_parts.empty())\n+    {\n+        if (next_level_parts.empty())\n+        {\n+            LOG_WARNING(log, \"There is no projection parts merged\");\n+\n+            /// Task is finished\n+            return false;\n+        }\n+        current_level = next_level;\n+        ++next_level;\n+    }\n+    else if (selected_parts.size() == 1)\n+    {\n+        if (next_level_parts.empty())\n+        {\n+            LOG_DEBUG(log, \"Merged a projection part in level {}\", current_level);\n+            selected_parts[0]->renameTo(projection.name + \".proj\", true);\n+            selected_parts[0]->setName(projection.name);\n+            selected_parts[0]->is_temp = false;\n+            new_data_part->addProjectionPart(name, std::move(selected_parts[0]));\n+\n+            /// Task is finished\n+            return false;\n+        }\n+        else\n+        {\n+            LOG_DEBUG(log, \"Forwarded part {} in level {} to next level\", selected_parts[0]->name, current_level);\n+            next_level_parts.push_back(std::move(selected_parts[0]));\n+        }\n+    }\n+    else if (selected_parts.size() > 1)\n+    {\n+        // Generate a unique part name\n+        ++block_num;\n+        auto projection_future_part = std::make_shared<FutureMergedMutatedPart>();\n+        MergeTreeData::DataPartsVector const_selected_parts(\n+            std::make_move_iterator(selected_parts.begin()), std::make_move_iterator(selected_parts.end()));\n+        projection_future_part->assign(std::move(const_selected_parts));\n+        projection_future_part->name = fmt::format(\"{}_{}\", projection.name, ++block_num);\n+        projection_future_part->part_info = {\"all\", 0, 0, 0};\n+\n+        MergeTreeData::MergingParams projection_merging_params;\n+        projection_merging_params.mode = MergeTreeData::MergingParams::Ordinary;\n+        if (projection.type == ProjectionDescription::Type::Aggregate)\n+            projection_merging_params.mode = MergeTreeData::MergingParams::Aggregating;\n+\n+        LOG_DEBUG(log, \"Merged {} parts in level {} to {}\", selected_parts.size(), current_level, projection_future_part->name);\n+        auto tmp_part_merge_task = mutator->mergePartsToTemporaryPart(\n+            projection_future_part,\n+            projection.metadata,\n+            merge_entry,\n+            std::make_unique<MergeListElement>((*merge_entry)->table_id, projection_future_part, context),\n+            *table_lock_holder,\n+            time_of_merge,\n+            context,\n+            space_reservation,\n+            false, // TODO Do we need deduplicate for projections\n+            {},\n+            false, // no cleanup\n+            projection_merging_params,\n+            NO_TRANSACTION_PTR,\n+            /* need_prefix */ true,\n+            new_data_part.get(),\n+            \".tmp_proj\");\n+\n+        next_level_parts.push_back(executeHere(tmp_part_merge_task));\n+        next_level_parts.back()->is_temp = true;\n+    }\n+\n+    /// Need execute again\n+    return true;\n+}\n+\n+}\ndiff --git a/src/Storages/MergeTree/MergeProjectionPartsTask.h b/src/Storages/MergeTree/MergeProjectionPartsTask.h\nnew file mode 100644\nindex 000000000000..47cafe01151b\n--- /dev/null\n+++ b/src/Storages/MergeTree/MergeProjectionPartsTask.h\n@@ -0,0 +1,84 @@\n+#pragma once\n+\n+#include <Interpreters/StorageID.h>\n+#include <Storages/MergeTree/IExecutableTask.h>\n+#include <Storages/MergeTree/MergeTreeData.h>\n+#include <Storages/MergeTree/MergeTreeDataMergerMutator.h>\n+#include <Storages/MergeTree/MergeProgress.h>\n+#include <Storages/MergeTree/FutureMergedMutatedPart.h>\n+#include <Storages/ProjectionsDescription.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int LOGICAL_ERROR;\n+}\n+\n+class MergeProjectionPartsTask : public IExecutableTask\n+{\n+public:\n+\n+    MergeProjectionPartsTask(\n+        String name_,\n+        MergeTreeData::MutableDataPartsVector && parts_,\n+        const ProjectionDescription & projection_,\n+        size_t & block_num_,\n+        ContextPtr context_,\n+        TableLockHolder * table_lock_holder_,\n+        MergeTreeDataMergerMutator * mutator_,\n+        MergeListEntry * merge_entry_,\n+        time_t time_of_merge_,\n+        MergeTreeData::MutableDataPartPtr new_data_part_,\n+        ReservationSharedPtr space_reservation_)\n+        : name(std::move(name_))\n+        , parts(std::move(parts_))\n+        , projection(projection_)\n+        , block_num(block_num_)\n+        , context(context_)\n+        , table_lock_holder(table_lock_holder_)\n+        , mutator(mutator_)\n+        , merge_entry(merge_entry_)\n+        , time_of_merge(time_of_merge_)\n+        , new_data_part(new_data_part_)\n+        , space_reservation(space_reservation_)\n+        , log(getLogger(\"MergeProjectionPartsTask\"))\n+        {\n+            LOG_DEBUG(log, \"Selected {} projection_parts from {} to {}\", parts.size(), parts.front()->name, parts.back()->name);\n+            level_parts[current_level] = std::move(parts);\n+        }\n+\n+    void onCompleted() override { throw Exception(ErrorCodes::LOGICAL_ERROR, \"Not implemented\"); }\n+    StorageID getStorageID() const override { throw Exception(ErrorCodes::LOGICAL_ERROR, \"Not implemented\"); }\n+    Priority getPriority() const override { throw Exception(ErrorCodes::LOGICAL_ERROR, \"Not implemented\"); }\n+    String getQueryId() const override { throw Exception(ErrorCodes::LOGICAL_ERROR, \"Not implemented\"); }\n+\n+    bool executeStep() override;\n+\n+private:\n+    String name;\n+    MergeTreeData::MutableDataPartsVector parts;\n+    const ProjectionDescription & projection;\n+    size_t & block_num;\n+\n+    ContextPtr context;\n+    TableLockHolder * table_lock_holder;\n+    MergeTreeDataMergerMutator * mutator;\n+    MergeListEntry * merge_entry;\n+    time_t time_of_merge;\n+\n+    MergeTreeData::MutableDataPartPtr new_data_part;\n+    ReservationSharedPtr space_reservation;\n+\n+    LoggerPtr log;\n+\n+    std::map<size_t, MergeTreeData::MutableDataPartsVector> level_parts;\n+    size_t current_level = 0;\n+    size_t next_level = 1;\n+\n+    /// TODO(nikitamikhaylov): make this constant a setting\n+    static constexpr size_t max_parts_to_merge_in_one_level = 10;\n+};\n+\n+}\ndiff --git a/src/Storages/MergeTree/MergeTask.cpp b/src/Storages/MergeTree/MergeTask.cpp\nindex 806ed930311f..aa178be270f0 100644\n--- a/src/Storages/MergeTree/MergeTask.cpp\n+++ b/src/Storages/MergeTree/MergeTask.cpp\n@@ -21,6 +21,8 @@\n #include <Storages/MergeTree/MergeTreeSettings.h>\n #include <Storages/MergeTree/FutureMergedMutatedPart.h>\n #include <Storages/MergeTree/MergeTreeDataMergerMutator.h>\n+#include <Storages/MergeTree/MergeTreeDataWriter.h>\n+#include <Storages/MergeTree/MergeProjectionPartsTask.h>\n #include <Processors/Transforms/ExpressionTransform.h>\n #include <Processors/Transforms/MaterializingTransform.h>\n #include <Processors/Transforms/FilterTransform.h>\n@@ -63,6 +65,7 @@ namespace ErrorCodes\n     extern const int SUPPORT_IS_DISABLED;\n }\n \n+\n static ColumnsStatistics getStatisticsForColumns(\n     const NamesAndTypesList & columns_to_read,\n     const StorageMetadataPtr & metadata_snapshot)\n@@ -155,6 +158,13 @@ void MergeTask::ExecuteAndFinalizeHorizontalPart::extractMergingAndGatheringColu\n         }\n     }\n \n+    for (const auto * projection : global_ctx->projections_to_rebuild)\n+    {\n+        Names projection_columns_vec = projection->getRequiredColumns();\n+        std::copy(projection_columns_vec.cbegin(), projection_columns_vec.cend(),\n+                  std::inserter(key_columns, key_columns.end()));\n+    }\n+\n     /// TODO: also force \"summing\" and \"aggregating\" columns to make Horizontal merge only for such columns\n \n     for (const auto & column : global_ctx->storage_columns)\n@@ -254,6 +264,8 @@ bool MergeTask::ExecuteAndFinalizeHorizontalPart::prepare()\n     extendObjectColumns(global_ctx->storage_columns, object_columns, false);\n     global_ctx->storage_snapshot = std::make_shared<StorageSnapshot>(*global_ctx->data, global_ctx->metadata_snapshot, std::move(object_columns));\n \n+    prepareProjectionsToMergeAndRebuild();\n+\n     extractMergingAndGatheringColumns();\n \n     global_ctx->new_data_part->uuid = global_ctx->future_part->uuid;\n@@ -517,6 +529,148 @@ bool MergeTask::ExecuteAndFinalizeHorizontalPart::execute()\n }\n \n \n+void MergeTask::ExecuteAndFinalizeHorizontalPart::prepareProjectionsToMergeAndRebuild() const\n+{\n+    const auto mode = global_ctx->data->getSettings()->deduplicate_merge_projection_mode;\n+    /// Under throw mode, we still choose to drop projections due to backward compatibility since some\n+    /// users might have projections before this change.\n+    if (global_ctx->data->merging_params.mode != MergeTreeData::MergingParams::Ordinary\n+        && (mode == DeduplicateMergeProjectionMode::THROW || mode == DeduplicateMergeProjectionMode::DROP))\n+        return;\n+\n+    /// These merging modes may or may not reduce number of rows. It's not known until the horizontal stage is finished.\n+    const bool merge_may_reduce_rows =\n+        global_ctx->cleanup ||\n+        global_ctx->deduplicate ||\n+        ctx->merging_params.mode == MergeTreeData::MergingParams::Collapsing ||\n+        ctx->merging_params.mode == MergeTreeData::MergingParams::Replacing ||\n+        ctx->merging_params.mode == MergeTreeData::MergingParams::VersionedCollapsing;\n+\n+    const auto & projections = global_ctx->metadata_snapshot->getProjections();\n+\n+    for (const auto & projection : projections)\n+    {\n+        if (merge_may_reduce_rows)\n+        {\n+            global_ctx->projections_to_rebuild.push_back(&projection);\n+            continue;\n+        }\n+\n+        MergeTreeData::DataPartsVector projection_parts;\n+        for (const auto & part : global_ctx->future_part->parts)\n+        {\n+            auto it = part->getProjectionParts().find(projection.name);\n+            if (it != part->getProjectionParts().end() && !it->second->is_broken)\n+                projection_parts.push_back(it->second);\n+        }\n+        if (projection_parts.size() == global_ctx->future_part->parts.size())\n+        {\n+            global_ctx->projections_to_merge.push_back(&projection);\n+            global_ctx->projections_to_merge_parts[projection.name].assign(projection_parts.begin(), projection_parts.end());\n+        }\n+        else\n+        {\n+            chassert(projection_parts.size() < global_ctx->future_part->parts.size());\n+            LOG_DEBUG(ctx->log, \"Projection {} is not merged because some parts don't have it\", projection.name);\n+            continue;\n+        }\n+    }\n+\n+    const auto & settings = global_ctx->context->getSettingsRef();\n+\n+    for (const auto * projection : global_ctx->projections_to_rebuild)\n+        ctx->projection_squashes.emplace_back(projection->sample_block.cloneEmpty(),\n+            settings.min_insert_block_size_rows, settings.min_insert_block_size_bytes);\n+}\n+\n+\n+void MergeTask::ExecuteAndFinalizeHorizontalPart::calculateProjections(const Block & block) const\n+{\n+    for (size_t i = 0, size = global_ctx->projections_to_rebuild.size(); i < size; ++i)\n+    {\n+        const auto & projection = *global_ctx->projections_to_rebuild[i];\n+        Block block_to_squash = projection.calculate(block, global_ctx->context);\n+        auto & projection_squash_plan = ctx->projection_squashes[i];\n+        projection_squash_plan.setHeader(block_to_squash.cloneEmpty());\n+        Chunk squashed_chunk = Squashing::squash(projection_squash_plan.add({block_to_squash.getColumns(), block_to_squash.rows()}));\n+        if (squashed_chunk)\n+        {\n+            auto result = projection_squash_plan.getHeader().cloneWithColumns(squashed_chunk.detachColumns());\n+            auto tmp_part = MergeTreeDataWriter::writeTempProjectionPart(\n+                *global_ctx->data, ctx->log, result, projection, global_ctx->new_data_part.get(), ++ctx->projection_block_num);\n+            tmp_part.finalize();\n+            tmp_part.part->getDataPartStorage().commitTransaction();\n+            ctx->projection_parts[projection.name].emplace_back(std::move(tmp_part.part));\n+        }\n+    }\n+}\n+\n+\n+void MergeTask::ExecuteAndFinalizeHorizontalPart::finalizeProjections() const\n+{\n+    for (size_t i = 0, size = global_ctx->projections_to_rebuild.size(); i < size; ++i)\n+    {\n+        const auto & projection = *global_ctx->projections_to_rebuild[i];\n+        auto & projection_squash_plan = ctx->projection_squashes[i];\n+        auto squashed_chunk = Squashing::squash(projection_squash_plan.flush());\n+        if (squashed_chunk)\n+        {\n+            auto result = projection_squash_plan.getHeader().cloneWithColumns(squashed_chunk.detachColumns());\n+            auto temp_part = MergeTreeDataWriter::writeTempProjectionPart(\n+                *global_ctx->data, ctx->log, result, projection, global_ctx->new_data_part.get(), ++ctx->projection_block_num);\n+            temp_part.finalize();\n+            temp_part.part->getDataPartStorage().commitTransaction();\n+            ctx->projection_parts[projection.name].emplace_back(std::move(temp_part.part));\n+        }\n+    }\n+\n+    ctx->projection_parts_iterator = std::make_move_iterator(ctx->projection_parts.begin());\n+    if (ctx->projection_parts_iterator != std::make_move_iterator(ctx->projection_parts.end()))\n+        constructTaskForProjectionPartsMerge();\n+}\n+\n+\n+void MergeTask::ExecuteAndFinalizeHorizontalPart::constructTaskForProjectionPartsMerge() const\n+{\n+    auto && [name, parts] = *ctx->projection_parts_iterator;\n+    const auto & projection = global_ctx->metadata_snapshot->projections.get(name);\n+\n+    ctx->merge_projection_parts_task_ptr = std::make_unique<MergeProjectionPartsTask>\n+    (\n+        name,\n+        std::move(parts),\n+        projection,\n+        ctx->projection_block_num,\n+        global_ctx->context,\n+        global_ctx->holder,\n+        global_ctx->mutator,\n+        global_ctx->merge_entry,\n+        global_ctx->time_of_merge,\n+        global_ctx->new_data_part,\n+        global_ctx->space_reservation\n+    );\n+}\n+\n+\n+bool MergeTask::ExecuteAndFinalizeHorizontalPart::executeMergeProjections() // NOLINT\n+{\n+    /// In case if there are no projections we didn't construct a task\n+    if (!ctx->merge_projection_parts_task_ptr)\n+        return false;\n+\n+    if (ctx->merge_projection_parts_task_ptr->executeStep())\n+        return true;\n+\n+    ++ctx->projection_parts_iterator;\n+\n+    if (ctx->projection_parts_iterator == std::make_move_iterator(ctx->projection_parts.end()))\n+        return false;\n+\n+    constructTaskForProjectionPartsMerge();\n+\n+    return true;\n+}\n+\n bool MergeTask::ExecuteAndFinalizeHorizontalPart::executeImpl()\n {\n     Stopwatch watch(CLOCK_MONOTONIC_COARSE);\n@@ -535,6 +689,8 @@ bool MergeTask::ExecuteAndFinalizeHorizontalPart::executeImpl()\n         global_ctx->rows_written += block.rows();\n         const_cast<MergedBlockOutputStream &>(*global_ctx->to).write(block);\n \n+        calculateProjections(block);\n+\n         UInt64 result_rows = 0;\n         UInt64 result_bytes = 0;\n         global_ctx->merged_pipeline.tryGetResultRowsAndBytes(result_rows, result_bytes);\n@@ -558,8 +714,10 @@ bool MergeTask::ExecuteAndFinalizeHorizontalPart::executeImpl()\n     return true;\n }\n \n+\n void MergeTask::ExecuteAndFinalizeHorizontalPart::finalize() const\n {\n+    finalizeProjections();\n     global_ctx->merging_executor.reset();\n     global_ctx->merged_pipeline.reset();\n \n@@ -847,35 +1005,9 @@ bool MergeTask::MergeProjectionsStage::mergeMinMaxIndexAndPrepareProjections() c\n             ReadableSize(global_ctx->merge_list_element_ptr->bytes_read_uncompressed / elapsed_seconds));\n     }\n \n-\n-    const auto mode = global_ctx->data->getSettings()->deduplicate_merge_projection_mode;\n-    /// Under throw mode, we still choose to drop projections due to backward compatibility since some\n-    /// users might have projections before this change.\n-    if (global_ctx->data->merging_params.mode != MergeTreeData::MergingParams::Ordinary\n-        && (mode == DeduplicateMergeProjectionMode::THROW || mode == DeduplicateMergeProjectionMode::DROP))\n+    for (const auto & projection : global_ctx->projections_to_merge)\n     {\n-        ctx->projections_iterator = ctx->tasks_for_projections.begin();\n-        return false;\n-    }\n-\n-    const auto & projections = global_ctx->metadata_snapshot->getProjections();\n-\n-    for (const auto & projection : projections)\n-    {\n-        MergeTreeData::DataPartsVector projection_parts;\n-        for (const auto & part : global_ctx->future_part->parts)\n-        {\n-            auto actual_projection_parts = part->getProjectionParts();\n-            auto it = actual_projection_parts.find(projection.name);\n-            if (it != actual_projection_parts.end() && !it->second->is_broken)\n-                projection_parts.push_back(it->second);\n-        }\n-        if (projection_parts.size() < global_ctx->future_part->parts.size())\n-        {\n-            LOG_DEBUG(ctx->log, \"Projection {} is not merged because some parts don't have it\", projection.name);\n-            continue;\n-        }\n-\n+        MergeTreeData::DataPartsVector projection_parts = global_ctx->projections_to_merge_parts[projection->name];\n         LOG_DEBUG(\n             ctx->log,\n             \"Selected {} projection_parts from {} to {}\",\n@@ -885,7 +1017,7 @@ bool MergeTask::MergeProjectionsStage::mergeMinMaxIndexAndPrepareProjections() c\n \n         auto projection_future_part = std::make_shared<FutureMergedMutatedPart>();\n         projection_future_part->assign(std::move(projection_parts));\n-        projection_future_part->name = projection.name;\n+        projection_future_part->name = projection->name;\n         // TODO (ab): path in future_part is only for merge process introspection, which is not available for merges of projection parts.\n         // Let's comment this out to avoid code inconsistency and add it back after we implement projection merge introspection.\n         // projection_future_part->path = global_ctx->future_part->path + \"/\" + projection.name + \".proj/\";\n@@ -893,16 +1025,17 @@ bool MergeTask::MergeProjectionsStage::mergeMinMaxIndexAndPrepareProjections() c\n \n         MergeTreeData::MergingParams projection_merging_params;\n         projection_merging_params.mode = MergeTreeData::MergingParams::Ordinary;\n-        if (projection.type == ProjectionDescription::Type::Aggregate)\n+        if (projection->type == ProjectionDescription::Type::Aggregate)\n             projection_merging_params.mode = MergeTreeData::MergingParams::Aggregating;\n \n         ctx->tasks_for_projections.emplace_back(std::make_shared<MergeTask>(\n             projection_future_part,\n-            projection.metadata,\n+            projection->metadata,\n             global_ctx->merge_entry,\n             std::make_unique<MergeListElement>((*global_ctx->merge_entry)->table_id, projection_future_part, global_ctx->context),\n             global_ctx->time_of_merge,\n             global_ctx->context,\n+            *global_ctx->holder,\n             global_ctx->space_reservation,\n             global_ctx->deduplicate,\n             global_ctx->deduplicate_by_columns,\ndiff --git a/src/Storages/MergeTree/MergeTask.h b/src/Storages/MergeTree/MergeTask.h\nindex 9a68b2e04ac4..c80995888d44 100644\n--- a/src/Storages/MergeTree/MergeTask.h\n+++ b/src/Storages/MergeTree/MergeTask.h\n@@ -9,6 +9,7 @@\n #include <Compression/CompressedReadBuffer.h>\n #include <Compression/CompressedReadBufferFromFile.h>\n \n+#include <Interpreters/Squashing.h>\n #include <Interpreters/TemporaryDataOnDisk.h>\n \n #include <Processors/Executors/PullingPipelineExecutor.h>\n@@ -72,6 +73,7 @@ class MergeTask\n         std::unique_ptr<MergeListElement> projection_merge_list_element_,\n         time_t time_of_merge_,\n         ContextPtr context_,\n+        TableLockHolder & holder,\n         ReservationSharedPtr space_reservation_,\n         bool deduplicate_,\n         Names deduplicate_by_columns_,\n@@ -96,6 +98,7 @@ class MergeTask\n                 = global_ctx->projection_merge_list_element ? global_ctx->projection_merge_list_element.get() : (*global_ctx->merge_entry)->ptr();\n             global_ctx->time_of_merge = std::move(time_of_merge_);\n             global_ctx->context = std::move(context_);\n+            global_ctx->holder = &holder;\n             global_ctx->space_reservation = std::move(space_reservation_);\n             global_ctx->deduplicate = std::move(deduplicate_);\n             global_ctx->deduplicate_by_columns = std::move(deduplicate_by_columns_);\n@@ -151,6 +154,7 @@ class MergeTask\n     /// Proper initialization is responsibility of the author\n     struct GlobalRuntimeContext : public IStageRuntimeContext\n     {\n+        TableLockHolder * holder;\n         MergeList::Entry * merge_entry{nullptr};\n         /// If not null, use this instead of the global MergeList::Entry. This is for merging projections.\n         std::unique_ptr<MergeListElement> projection_merge_list_element;\n@@ -181,6 +185,10 @@ class MergeTask\n \n         MergeAlgorithm chosen_merge_algorithm{MergeAlgorithm::Undecided};\n \n+        std::vector<ProjectionDescriptionRawPtr> projections_to_rebuild{};\n+        std::vector<ProjectionDescriptionRawPtr> projections_to_merge{};\n+        std::map<String, MergeTreeData::DataPartsVector> projections_to_merge_parts{};\n+\n         std::unique_ptr<MergeStageProgress> horizontal_stage_progress{nullptr};\n         std::unique_ptr<MergeStageProgress> column_progress{nullptr};\n \n@@ -228,6 +236,14 @@ class MergeTask\n         std::unique_ptr<WriteBuffer> rows_sources_write_buf{nullptr};\n         std::optional<ColumnSizeEstimator> column_sizes{};\n \n+        /// For projections to rebuild\n+        using ProjectionNameToItsBlocks = std::map<String, MergeTreeData::MutableDataPartsVector>;\n+        ProjectionNameToItsBlocks projection_parts;\n+        std::move_iterator<ProjectionNameToItsBlocks::iterator> projection_parts_iterator;\n+        std::vector<Squashing> projection_squashes;\n+        size_t projection_block_num = 0;\n+        ExecutableTaskPtr merge_projection_parts_task_ptr;\n+\n         size_t initial_reservation{0};\n         bool read_with_direct_io{false};\n \n@@ -257,16 +273,23 @@ class MergeTask\n         void finalize() const;\n \n         /// NOTE: Using pointer-to-member instead of std::function and lambda makes stacktraces much more concise and readable\n-        using ExecuteAndFinalizeHorizontalPartSubtasks = std::array<bool(ExecuteAndFinalizeHorizontalPart::*)(), 2>;\n+        using ExecuteAndFinalizeHorizontalPartSubtasks = std::array<bool(ExecuteAndFinalizeHorizontalPart::*)(), 3>;\n \n         const ExecuteAndFinalizeHorizontalPartSubtasks subtasks\n         {\n             &ExecuteAndFinalizeHorizontalPart::prepare,\n-            &ExecuteAndFinalizeHorizontalPart::executeImpl\n+            &ExecuteAndFinalizeHorizontalPart::executeImpl,\n+            &ExecuteAndFinalizeHorizontalPart::executeMergeProjections\n         };\n \n         ExecuteAndFinalizeHorizontalPartSubtasks::const_iterator subtasks_iterator = subtasks.begin();\n \n+        void prepareProjectionsToMergeAndRebuild() const;\n+        void calculateProjections(const Block & block) const;\n+        void finalizeProjections() const;\n+        void constructTaskForProjectionPartsMerge() const;\n+        bool executeMergeProjections();\n+\n         MergeAlgorithm chooseMergeAlgorithm() const;\n         void createMergedStream();\n         void extractMergingAndGatheringColumns() const;\ndiff --git a/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp b/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\nindex 140a226f2d14..5c65dd6c1c10 100644\n--- a/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\n@@ -671,7 +671,7 @@ MergeTaskPtr MergeTreeDataMergerMutator::mergePartsToTemporaryPart(\n     const StorageMetadataPtr & metadata_snapshot,\n     MergeList::Entry * merge_entry,\n     std::unique_ptr<MergeListElement> projection_merge_list_element,\n-    TableLockHolder,\n+    TableLockHolder & holder,\n     time_t time_of_merge,\n     ContextPtr context,\n     ReservationSharedPtr space_reservation,\n@@ -691,6 +691,7 @@ MergeTaskPtr MergeTreeDataMergerMutator::mergePartsToTemporaryPart(\n         std::move(projection_merge_list_element),\n         time_of_merge,\n         context,\n+        holder,\n         space_reservation,\n         deduplicate,\n         deduplicate_by_columns,\ndiff --git a/src/Storages/MergeTree/MergeTreeDataMergerMutator.h b/src/Storages/MergeTree/MergeTreeDataMergerMutator.h\nindex d2852a3a5047..c14962d903b7 100644\n--- a/src/Storages/MergeTree/MergeTreeDataMergerMutator.h\n+++ b/src/Storages/MergeTree/MergeTreeDataMergerMutator.h\n@@ -159,7 +159,7 @@ class MergeTreeDataMergerMutator\n         const StorageMetadataPtr & metadata_snapshot,\n         MergeListEntry * merge_entry,\n         std::unique_ptr<MergeListElement> projection_merge_list_element,\n-        TableLockHolder table_lock_holder,\n+        TableLockHolder & table_lock_holder,\n         time_t time_of_merge,\n         ContextPtr context,\n         ReservationSharedPtr space_reservation,\ndiff --git a/src/Storages/MergeTree/MutateTask.cpp b/src/Storages/MergeTree/MutateTask.cpp\nindex 55a4947832e3..28464ae64346 100644\n--- a/src/Storages/MergeTree/MutateTask.cpp\n+++ b/src/Storages/MergeTree/MutateTask.cpp\n@@ -24,6 +24,7 @@\n #include <Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.h>\n #include <Storages/MergeTree/StorageFromMergeTreeDataPart.h>\n #include <Storages/MergeTree/MergeTreeDataWriter.h>\n+#include <Storages/MergeTree/MergeProjectionPartsTask.h>\n #include <Storages/MutationCommands.h>\n #include <Storages/MergeTree/MergeTreeDataMergerMutator.h>\n #include <Storages/MergeTree/MergeTreeIndexFullText.h>\n@@ -1058,136 +1059,6 @@ struct MutationContext\n using MutationContextPtr = std::shared_ptr<MutationContext>;\n \n \n-class MergeProjectionPartsTask : public IExecutableTask\n-{\n-public:\n-\n-    MergeProjectionPartsTask(\n-        String name_,\n-        MergeTreeData::MutableDataPartsVector && parts_,\n-        const ProjectionDescription & projection_,\n-        size_t & block_num_,\n-        MutationContextPtr ctx_)\n-        : name(std::move(name_))\n-        , parts(std::move(parts_))\n-        , projection(projection_)\n-        , block_num(block_num_)\n-        , ctx(ctx_)\n-        , log(getLogger(\"MergeProjectionPartsTask\"))\n-        {\n-            LOG_DEBUG(log, \"Selected {} projection_parts from {} to {}\", parts.size(), parts.front()->name, parts.back()->name);\n-            level_parts[current_level] = std::move(parts);\n-        }\n-\n-    void onCompleted() override { throw Exception(ErrorCodes::LOGICAL_ERROR, \"Not implemented\"); }\n-    StorageID getStorageID() const override { throw Exception(ErrorCodes::LOGICAL_ERROR, \"Not implemented\"); }\n-    Priority getPriority() const override { throw Exception(ErrorCodes::LOGICAL_ERROR, \"Not implemented\"); }\n-    String getQueryId() const override { throw Exception(ErrorCodes::LOGICAL_ERROR, \"Not implemented\"); }\n-\n-    bool executeStep() override\n-    {\n-        auto & current_level_parts = level_parts[current_level];\n-        auto & next_level_parts = level_parts[next_level];\n-\n-        MergeTreeData::MutableDataPartsVector selected_parts;\n-        while (selected_parts.size() < max_parts_to_merge_in_one_level && !current_level_parts.empty())\n-        {\n-            selected_parts.push_back(std::move(current_level_parts.back()));\n-            current_level_parts.pop_back();\n-        }\n-\n-        if (selected_parts.empty())\n-        {\n-            if (next_level_parts.empty())\n-            {\n-                LOG_WARNING(log, \"There is no projection parts merged\");\n-\n-                /// Task is finished\n-                return false;\n-            }\n-            current_level = next_level;\n-            ++next_level;\n-        }\n-        else if (selected_parts.size() == 1)\n-        {\n-            if (next_level_parts.empty())\n-            {\n-                LOG_DEBUG(log, \"Merged a projection part in level {}\", current_level);\n-                selected_parts[0]->renameTo(projection.name + \".proj\", true);\n-                selected_parts[0]->setName(projection.name);\n-                selected_parts[0]->is_temp = false;\n-                ctx->new_data_part->addProjectionPart(name, std::move(selected_parts[0]));\n-\n-                /// Task is finished\n-                return false;\n-            }\n-            else\n-            {\n-                LOG_DEBUG(log, \"Forwarded part {} in level {} to next level\", selected_parts[0]->name, current_level);\n-                next_level_parts.push_back(std::move(selected_parts[0]));\n-            }\n-        }\n-        else if (selected_parts.size() > 1)\n-        {\n-            // Generate a unique part name\n-            ++block_num;\n-            auto projection_future_part = std::make_shared<FutureMergedMutatedPart>();\n-            MergeTreeData::DataPartsVector const_selected_parts(\n-                std::make_move_iterator(selected_parts.begin()), std::make_move_iterator(selected_parts.end()));\n-            projection_future_part->assign(std::move(const_selected_parts));\n-            projection_future_part->name = fmt::format(\"{}_{}\", projection.name, ++block_num);\n-            projection_future_part->part_info = {\"all\", 0, 0, 0};\n-\n-            MergeTreeData::MergingParams projection_merging_params;\n-            projection_merging_params.mode = MergeTreeData::MergingParams::Ordinary;\n-            if (projection.type == ProjectionDescription::Type::Aggregate)\n-                projection_merging_params.mode = MergeTreeData::MergingParams::Aggregating;\n-\n-            LOG_DEBUG(log, \"Merged {} parts in level {} to {}\", selected_parts.size(), current_level, projection_future_part->name);\n-            auto tmp_part_merge_task = ctx->mutator->mergePartsToTemporaryPart(\n-                projection_future_part,\n-                projection.metadata,\n-                ctx->mutate_entry,\n-                std::make_unique<MergeListElement>((*ctx->mutate_entry)->table_id, projection_future_part, ctx->context),\n-                *ctx->holder,\n-                ctx->time_of_mutation,\n-                ctx->context,\n-                ctx->space_reservation,\n-                false, // TODO Do we need deduplicate for projections\n-                {},\n-                false, // no cleanup\n-                projection_merging_params,\n-                NO_TRANSACTION_PTR,\n-                /* need_prefix */ true,\n-                ctx->new_data_part.get(),\n-                \".tmp_proj\");\n-\n-            next_level_parts.push_back(executeHere(tmp_part_merge_task));\n-            next_level_parts.back()->is_temp = true;\n-        }\n-\n-        /// Need execute again\n-        return true;\n-    }\n-\n-private:\n-    String name;\n-    MergeTreeData::MutableDataPartsVector parts;\n-    const ProjectionDescription & projection;\n-    size_t & block_num;\n-    MutationContextPtr ctx;\n-\n-    LoggerPtr log;\n-\n-    std::map<size_t, MergeTreeData::MutableDataPartsVector> level_parts;\n-    size_t current_level = 0;\n-    size_t next_level = 1;\n-\n-    /// TODO(nikitamikhaylov): make this constant a setting\n-    static constexpr size_t max_parts_to_merge_in_one_level = 10;\n-};\n-\n-\n // This class is responsible for:\n // 1. get projection pipeline and a sink to write parts\n // 2. build an executor that can write block to the input stream (actually we can write through it to generate as many parts as possible)\n@@ -1406,7 +1277,13 @@ void PartMergerWriter::constructTaskForProjectionPartsMerge()\n         std::move(parts),\n         projection,\n         block_num,\n-        ctx\n+        ctx->context,\n+        ctx->holder,\n+        ctx->mutator,\n+        ctx->mutate_entry,\n+        ctx->time_of_mutation,\n+        ctx->new_data_part,\n+        ctx->space_reservation\n     );\n }\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02968_projection_merge.reference b/tests/queries/0_stateless/02968_projection_merge.reference\nnew file mode 100644\nindex 000000000000..40cb572c95a6\n--- /dev/null\n+++ b/tests/queries/0_stateless/02968_projection_merge.reference\n@@ -0,0 +1,28 @@\n+ReplacingMergeTree\n+0\t2\n+1\t2\n+2\t2\n+0\t2\n+1\t2\n+2\t2\n+CollapsingMergeTree\n+0\t2\n+1\t2\n+2\t2\n+0\t2\n+1\t2\n+2\t2\n+VersionedCollapsingMergeTree\n+0\t2\n+1\t2\n+2\t2\n+0\t2\n+1\t2\n+2\t2\n+DEDUPLICATE ON MergeTree\n+0\t1\n+1\t1\n+2\t1\n+0\t1\n+1\t1\n+2\t1\ndiff --git a/tests/queries/0_stateless/02968_projection_merge.sql b/tests/queries/0_stateless/02968_projection_merge.sql\nnew file mode 100644\nindex 000000000000..3e047d2cf69a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02968_projection_merge.sql\n@@ -0,0 +1,116 @@\n+SELECT 'ReplacingMergeTree';\n+DROP TABLE IF EXISTS tp;\n+CREATE TABLE tp\n+(\n+    `type` Int32,\n+    `eventcnt` UInt64,\n+    PROJECTION p\n+    (\n+        SELECT type,sum(eventcnt)\n+        GROUP BY type\n+    )\n+)\n+ENGINE = ReplacingMergeTree\n+ORDER BY type\n+SETTINGS deduplicate_merge_projection_mode = 'rebuild';\n+\n+INSERT INTO tp SELECT number%3, 1 FROM numbers(3);\n+INSERT INTO tp SELECT number%3, 2 FROM numbers(3);\n+\n+OPTIMIZE TABLE tp FINAL;\n+\n+SELECT type,sum(eventcnt) FROM tp GROUP BY type ORDER BY type\n+SETTINGS optimize_use_projections = 0, force_optimize_projection = 0;\n+\n+SELECT type,sum(eventcnt) FROM tp GROUP BY type ORDER BY type\n+SETTINGS optimize_use_projections = 1, force_optimize_projection = 1;\n+\n+\n+SELECT 'CollapsingMergeTree';\n+DROP TABLE IF EXISTS tp;\n+CREATE TABLE tp\n+(\n+    `type` Int32,\n+    `eventcnt` UInt64,\n+    `sign` Int8,\n+    PROJECTION p\n+    (\n+        SELECT type,sum(eventcnt)\n+        GROUP BY type\n+    )\n+)\n+ENGINE = CollapsingMergeTree(sign)\n+ORDER BY type\n+SETTINGS deduplicate_merge_projection_mode = 'rebuild';\n+\n+INSERT INTO tp SELECT number % 3, 1, 1 FROM numbers(3);\n+INSERT INTO tp SELECT number % 3, 1, -1 FROM numbers(3);\n+INSERT INTO tp SELECT number % 3, 2, 1 FROM numbers(3);\n+\n+OPTIMIZE TABLE tp FINAL;\n+\n+SELECT type,sum(eventcnt) FROM tp GROUP BY type ORDER BY type\n+SETTINGS optimize_use_projections = 0, force_optimize_projection = 0;\n+\n+SELECT type,sum(eventcnt) FROM tp GROUP BY type ORDER BY type\n+SETTINGS optimize_use_projections = 1, force_optimize_projection = 1;\n+\n+-- Actually we don't need to test all 3 engines Replacing/Collapsing/VersionedCollapsing,\n+-- Because they share the same logic of 'reduce number of rows during merges'\n+SELECT 'VersionedCollapsingMergeTree';\n+DROP TABLE IF EXISTS tp;\n+CREATE TABLE tp\n+(\n+    `type` Int32,\n+    `eventcnt` UInt64,\n+    `sign` Int8,\n+    `version` UInt8,\n+    PROJECTION p\n+    (\n+        SELECT type,sum(eventcnt)\n+        GROUP BY type\n+    )\n+)\n+ENGINE = VersionedCollapsingMergeTree(sign,version)\n+ORDER BY type\n+SETTINGS deduplicate_merge_projection_mode = 'rebuild';\n+\n+INSERT INTO tp SELECT number % 3, 1, -1, 0 FROM numbers(3);\n+INSERT INTO tp SELECT number % 3, 2, 1, 1 FROM numbers(3);\n+INSERT INTO tp SELECT number % 3, 1, 1, 0 FROM numbers(3);\n+\n+OPTIMIZE TABLE tp FINAL;\n+\n+SELECT type,sum(eventcnt) FROM tp GROUP BY type ORDER BY type\n+SETTINGS optimize_use_projections = 0, force_optimize_projection = 0;\n+\n+SELECT type,sum(eventcnt) FROM tp GROUP BY type ORDER BY type\n+SETTINGS optimize_use_projections = 1, force_optimize_projection = 1;\n+\n+SELECT 'DEDUPLICATE ON MergeTree';\n+DROP TABLE IF EXISTS tp;\n+CREATE TABLE tp\n+(\n+    `type` Int32,\n+    `eventcnt` UInt64,\n+    PROJECTION p\n+    (\n+        SELECT type,sum(eventcnt)\n+        GROUP BY type\n+    )\n+)\n+ENGINE = MergeTree\n+ORDER BY type\n+SETTINGS deduplicate_merge_projection_mode = 'rebuild';\n+\n+INSERT INTO tp SELECT number % 3, 1 FROM numbers(3);\n+INSERT INTO tp SELECT number % 3, 2 FROM numbers(3);\n+\n+OPTIMIZE TABLE tp FINAL DEDUPLICATE BY type;\n+\n+SELECT type,sum(eventcnt) FROM tp GROUP BY type ORDER BY type\n+SETTINGS optimize_use_projections = 0, force_optimize_projection = 0;\n+\n+SELECT type,sum(eventcnt) FROM tp GROUP BY type ORDER BY type\n+SETTINGS optimize_use_projections = 1, force_optimize_projection = 1;\n+\n",
  "problem_statement": "Projections inconsistent results for ReplacingMergeTree/CollapsingMergeTree\n```sql\r\ndrop table if exists tp;\r\n\r\ncreate table tp (type Int32, eventcnt UInt64,\r\nprojection p (select sum(eventcnt), type group by type)) \r\nengine = ReplacingMergeTree order by type;\r\n\r\ninsert into tp select number%3, 1 from numbers(3);\r\ninsert into tp select number%3, 2 from numbers(3);\r\n\r\noptimize table tp final;\r\n\r\nset allow_experimental_projection_optimization = 0, force_optimize_projection = 0;\r\n\r\nselect sum(eventcnt) eventcnt, type\r\nfrom tp\r\ngroup by type\r\n\u250c\u2500eventcnt\u2500\u252c\u2500type\u2500\u2510\r\n\u2502        2 \u2502    0 \u2502\r\n\u2502        2 \u2502    2 \u2502\r\n\u2502        2 \u2502    1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nset allow_experimental_projection_optimization = 1, force_optimize_projection = 1;\r\n\r\nselect sum(eventcnt) eventcnt, type\r\nfrom tp\r\ngroup by type\r\n\u250c\u2500eventcnt\u2500\u252c\u2500type\u2500\u2510\r\n\u2502        3 \u2502    0 \u2502\r\n\u2502        3 \u2502    2 \u2502\r\n\u2502        3 \u2502    1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n",
  "hints_text": "The same issue with CollapsingMergeTree\r\n\r\n```sql\r\ndrop table if exists tp;\r\n\r\ncreate table tp (type Int32, eventcnt UInt64, sign Int8,\r\nprojection p (select sum(eventcnt), type group by type)) \r\nengine = CollapsingMergeTree(sign) order by type;\r\n\r\ninsert into tp select number%3, 1,1 from numbers(3);\r\ninsert into tp select number%3, 1,-1 from numbers(3);\r\ninsert into tp select number%3, 2,1 from numbers(3);\r\n\r\noptimize table tp final;\r\n\r\nset allow_experimental_projection_optimization = 0, force_optimize_projection = 0;\r\n\r\nselect sum(eventcnt) eventcnt, type\r\nfrom tp\r\ngroup by type\r\n\u250c\u2500eventcnt\u2500\u252c\u2500type\u2500\u2510\r\n\u2502        2 \u2502    0 \u2502\r\n\u2502        2 \u2502    2 \u2502\r\n\u2502        2 \u2502    1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nset allow_experimental_projection_optimization = 1, force_optimize_projection = 1;\r\n\r\nselect sum(eventcnt) eventcnt, type\r\nfrom tp\r\ngroup by type\r\n\u250c\u2500eventcnt\u2500\u252c\u2500type\u2500\u2510\r\n\u2502        4 \u2502    0 \u2502\r\n\u2502        4 \u2502    2 \u2502\r\n\u2502        4 \u2502    1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nIt's a known limitation (or perhaps an unexpected feature). But at least we should disable projection materialization for those MergeTree variants.\nSimilar problem occurs when using FINAL Keyword on query time:\r\n\r\n```\r\nCREATE TABLE ProjTest2\r\n(\r\na_int UInt8,\r\nb_int UInt16,\r\nPROJECTION prj1 (SELECT a_int, max(b_int) AS max_b, count(*) AS count_total GROUP BY  a_int)\r\n) ENGINE=ReplacingMergeTree ORDER BY (a_int, b_int);\r\n\r\nINSERT INTO ProjTest2\r\nSELECT *\r\nFROM generateRandom('a_int UInt8, b_int UInt16', NULL, 10) \r\nLIMIT 50000000;\r\n\r\n\r\n```\r\n\r\nWithout Projection:\r\n```\r\n\r\nSET allow_experimental_projection_optimization = 0, force_optimize_projection = 0;\r\nSELECT\r\n    count(*),\r\n    a_int\r\nFROM ProjTest2\r\nGROUP BY a_int\r\nORDER BY count() DESC\r\nLIMIT 3\r\n\r\nQuery id: 1bb133d8-3bc0-4882-aedc-e6a91b584e93\r\n\r\n\u250c\u2500count()\u2500\u252c\u2500a_int\u2500\u2510\r\n\u2502  129430 \u2502   188 \u2502\r\n\u2502  129369 \u2502   212 \u2502\r\n\u2502  129331 \u2502   246 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n3 rows in set. Elapsed: 0.032 sec. Processed 32.97 million rows, 32.97 MB (1.02 billion rows/s., 1.02 GB/s.)\r\n\r\nSELECT\r\n    count(*),\r\n    a_int\r\nFROM ProjTest2\r\nFINAL\r\nGROUP BY a_int\r\nORDER BY count() DESC\r\nLIMIT 3\r\n\r\nQuery id: a4dedc44-4595-45c2-a75e-9d57620ca37c\r\n\r\n\u250c\u2500count()\u2500\u252c\u2500a_int\u2500\u2510\r\n\u2502   62402 \u2502   112 \u2502\r\n\u2502   62347 \u2502    87 \u2502\r\n\u2502   62340 \u2502   150 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n3 rows in set. Elapsed: 1.093 sec. Processed 32.97 million rows, 164.84 MB (30.16 million rows/s., 150.81 MB/s.)\r\n\r\n```\r\n\r\nWith Projection enabled:\r\n\r\n```\r\nSET allow_experimental_projection_optimization = 1, force_optimize_projection = 1;\r\n\r\nSELECT\r\n    count(*),\r\n    a_int\r\nFROM ProjTest2\r\nFINAL\r\nGROUP BY a_int\r\nORDER BY count() DESC\r\nLIMIT 3\r\n\r\nQuery id: f2d7daaf-9e5f-49fe-af6c-27634f758295\r\n\r\n\u250c\u2500count()\u2500\u252c\u2500a_int\u2500\u2510\r\n\u2502    2928 \u2502    59 \u2502\r\n\u2502    2901 \u2502    92 \u2502\r\n\u2502    2880 \u2502   178 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n3 rows in set. Elapsed: 0.012 sec. Processed 2.05 thousand rows, 51.20 KB (164.19 thousand rows/s., 4.10 MB/s.)\r\n\r\n```\r\n\r\nAs seen count() is way to small when using final on query time\r\n\r\n\n> As seen count() is way to small when using final on query time\r\n\r\nHmm, the result of `select final` is indeed strange. I'll take a look. But in general we should not use projections in ReplacingMergeTree for now\nAs `select final` will almost everytime need to scan multiple parts, i'd suggest that when the final keyword is used, the optimizer should always ignore aggregated projections, and just consider main table or projections with different sortings only. At least for any partition with multiple parts.\r\n\r\nAs for the original topic. i would not disable projections for Replacing/Collapsing mergetree (its the one we use most often currently), but rather 'force' an rebuild of the projection data whenever two parts are merged.\r\n\r\nbtw: very cool feature amos!\nCan i use projection on replacingMergeTree now ? is this solved ?\nIs there any plan on fixing this issue yet? BTW my workaround is after insertion, do optimize final, clear projection and materialize projection on that partition to rebuild it.\nHey guys, looks like we have the same issue with `MergeTree`\r\n\r\n```sql\r\nselect version()\r\n\r\n\u250c\u2500version()\u2500\u2510\r\n\u2502 22.8.6.71 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\r\ncreate table tp (type Int32, eventcnt UInt64,\r\nprojection p (select sum(eventcnt), type group by type))\r\nengine = MergeTree order by type;\r\n\r\ninsert into tp select number%3, 1 from numbers(3);\r\ninsert into tp select number%3, 2 from numbers(3);\r\n\r\noptimize table tp final deduplicate by type;\r\n\r\nset allow_experimental_projection_optimization = 0, force_optimize_projection = 0;\r\n\r\nselect sum(eventcnt) eventcnt, type\r\nfrom tp\r\ngroup by type\r\n\u250c\u2500eventcnt\u2500\u252c\u2500type\u2500\u2510\r\n\u2502        1 \u2502    0 \u2502\r\n\u2502        1 \u2502    2 \u2502\r\n\u2502        1 \u2502    1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nset allow_experimental_projection_optimization = 1, force_optimize_projection = 1;\r\n\r\nselect sum(eventcnt) eventcnt, type\r\nfrom tp\r\ngroup by type\r\n\u250c\u2500eventcnt\u2500\u252c\u2500type\u2500\u2510\r\n\u2502        2 \u2502    0 \u2502\r\n\u2502        2 \u2502    2 \u2502\r\n\u2502        2 \u2502    1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nexplain select sum(eventcnt) eventcnt, type\r\nfrom tp\r\ngroup by type\r\n\r\n\u250c\u2500explain\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 Expression ((Projection + Before ORDER BY))                \u2502\r\n\u2502   ReadFromStorage (MergeTree(with Aggregate projection p)) \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n@amosbird Any news on fixing this bug sometime in the future?\r\nI lately had a customer falling in this trap again.\r\n\r\nHow i see things (unfortunatelly not a c++ developer), there should be a trigger added for recalculating the projections when merges occur in ReplacingMergeTree.\r\n\r\nInteresting fact, if i run a `OPTIMIZE TABLE xyz FINAL` then it does not recalculate the projections based on the newly merged dataparts, but if i run a `ALTER TABLE xyz UPDATE col1=col1 WHERE 1=1`, then it does update the projection data.\r\nSo i think it's really just a trigger missing to fire when data parts are merged\nI have just found this issue the hard way after getting inconsistent results from my queries depending on the use of a projection.\r\n\r\nI must say that finding this information only in the issues section of the project and not in the documentation - neither of projections nor of the CollapsingMergeTree - is not very user friendly. \u2639\ufe0f Especially since this limitation is known for more than 2 years...\n@beda42 documentation is open sourced in https://github.com/ClickHouse/ClickHouse/tree/master/docs/\r\ndon't be shy to make pull request",
  "created_at": "2024-04-06T19:39:54Z"
}