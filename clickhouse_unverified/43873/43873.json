{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 43873,
  "instance_id": "ClickHouse__ClickHouse-43873",
  "issue_numbers": [
    "43870"
  ],
  "base_commit": "f804fbb37565f73887e076e10f1b2d2a8f615005",
  "patch": "diff --git a/src/Analyzer/Passes/NormalizeCountVariantsPass.cpp b/src/Analyzer/Passes/NormalizeCountVariantsPass.cpp\nindex 28e5af3f5db2..cd6aa4d76f46 100644\n--- a/src/Analyzer/Passes/NormalizeCountVariantsPass.cpp\n+++ b/src/Analyzer/Passes/NormalizeCountVariantsPass.cpp\n@@ -6,6 +6,7 @@\n #include <Analyzer/InDepthQueryTreeVisitor.h>\n #include <Analyzer/ConstantNode.h>\n #include <Analyzer/FunctionNode.h>\n+#include <Interpreters/Context.h>\n \n namespace DB\n {\n@@ -16,7 +17,8 @@ namespace\n class NormalizeCountVariantsVisitor : public InDepthQueryTreeVisitor<NormalizeCountVariantsVisitor>\n {\n public:\n-    static void visitImpl(QueryTreeNodePtr & node)\n+    explicit NormalizeCountVariantsVisitor(ContextPtr context_) : context(std::move(context_)) {}\n+    void visitImpl(QueryTreeNodePtr & node)\n     {\n         auto * function_node = node->as<FunctionNode>();\n         if (!function_node || !function_node->isAggregateFunction() || (function_node->getFunctionName() != \"count\" && function_node->getFunctionName() != \"sum\"))\n@@ -39,13 +41,16 @@ class NormalizeCountVariantsVisitor : public InDepthQueryTreeVisitor<NormalizeCo\n         }\n         else if (function_node->getFunctionName() == \"sum\" &&\n             first_argument_constant_literal.getType() == Field::Types::UInt64 &&\n-            first_argument_constant_literal.get<UInt64>() == 1)\n+            first_argument_constant_literal.get<UInt64>() == 1 &&\n+            !context->getSettingsRef().aggregate_functions_null_for_empty)\n         {\n             resolveAsCountAggregateFunction(*function_node);\n             function_node->getArguments().getNodes().clear();\n         }\n     }\n private:\n+    ContextPtr context;\n+\n     static inline void resolveAsCountAggregateFunction(FunctionNode & function_node)\n     {\n         auto function_result_type = function_node.getResultType();\n@@ -59,9 +64,9 @@ class NormalizeCountVariantsVisitor : public InDepthQueryTreeVisitor<NormalizeCo\n \n }\n \n-void NormalizeCountVariantsPass::run(QueryTreeNodePtr query_tree_node, ContextPtr)\n+void NormalizeCountVariantsPass::run(QueryTreeNodePtr query_tree_node, ContextPtr context)\n {\n-    NormalizeCountVariantsVisitor visitor;\n+    NormalizeCountVariantsVisitor visitor(context);\n     visitor.visit(query_tree_node);\n }\n \ndiff --git a/src/Analyzer/Passes/SumIfToCountIfPass.cpp b/src/Analyzer/Passes/SumIfToCountIfPass.cpp\nindex e40ba25a965e..91c277d35b39 100644\n--- a/src/Analyzer/Passes/SumIfToCountIfPass.cpp\n+++ b/src/Analyzer/Passes/SumIfToCountIfPass.cpp\n@@ -56,7 +56,7 @@ class SumIfToCountIfVisitor : public InDepthQueryTreeVisitor<SumIfToCountIfVisit\n             if (!isInt64OrUInt64FieldType(constant_value_literal.getType()))\n                 return;\n \n-            if (constant_value_literal.get<UInt64>() != 1)\n+            if (constant_value_literal.get<UInt64>() != 1 || context->getSettingsRef().aggregate_functions_null_for_empty)\n                 return;\n \n             function_node_arguments_nodes[0] = std::move(function_node_arguments_nodes[1]);\ndiff --git a/src/Interpreters/RewriteCountVariantsVisitor.cpp b/src/Interpreters/RewriteCountVariantsVisitor.cpp\nindex 741dc3e8cb72..f207bc51527a 100644\n--- a/src/Interpreters/RewriteCountVariantsVisitor.cpp\n+++ b/src/Interpreters/RewriteCountVariantsVisitor.cpp\n@@ -6,6 +6,7 @@\n #include <Poco/String.h>\n #include <Common/typeid_cast.h>\n #include <Common/checkStackSize.h>\n+#include <Interpreters/Context.h>\n \n \n namespace DB\n@@ -52,7 +53,7 @@ void RewriteCountVariantsVisitor::visit(ASTFunction & func)\n         if (first_arg_literal->value.getType() == Field::Types::UInt64)\n         {\n             auto constant = first_arg_literal->value.get<UInt64>();\n-            if (constant == 1)\n+            if (constant == 1 && !context->getSettingsRef().aggregate_functions_null_for_empty)\n                 transform = true;\n         }\n     }\ndiff --git a/src/Interpreters/RewriteCountVariantsVisitor.h b/src/Interpreters/RewriteCountVariantsVisitor.h\nindex 6f731c8c4633..36c026bdfd78 100644\n--- a/src/Interpreters/RewriteCountVariantsVisitor.h\n+++ b/src/Interpreters/RewriteCountVariantsVisitor.h\n@@ -1,6 +1,7 @@\n #pragma once\n \n #include <Parsers/IAST.h>\n+#include <Interpreters/Context_fwd.h>\n \n namespace DB\n {\n@@ -10,8 +11,11 @@ class ASTFunction;\n class RewriteCountVariantsVisitor\n {\n public:\n-    static void visit(ASTPtr &);\n-    static void visit(ASTFunction &);\n+    explicit RewriteCountVariantsVisitor(ContextPtr context_) : context(context_) {}\n+    void visit(ASTPtr &);\n+    void visit(ASTFunction &);\n+private:\n+    ContextPtr context;\n };\n \n }\ndiff --git a/src/Interpreters/TreeOptimizer.cpp b/src/Interpreters/TreeOptimizer.cpp\nindex 182e9623c61d..6461a35dae65 100644\n--- a/src/Interpreters/TreeOptimizer.cpp\n+++ b/src/Interpreters/TreeOptimizer.cpp\n@@ -758,9 +758,9 @@ void TreeOptimizer::optimizeIf(ASTPtr & query, Aliases & aliases, bool if_chain_\n         OptimizeIfChainsVisitor().visit(query);\n }\n \n-void TreeOptimizer::optimizeCountConstantAndSumOne(ASTPtr & query)\n+void TreeOptimizer::optimizeCountConstantAndSumOne(ASTPtr & query, ContextPtr context)\n {\n-    RewriteCountVariantsVisitor::visit(query);\n+    RewriteCountVariantsVisitor(context).visit(query);\n }\n \n ///eliminate functions of other GROUP BY keys\n@@ -835,7 +835,7 @@ void TreeOptimizer::apply(ASTPtr & query, TreeRewriterResult & result,\n         optimizeAnyFunctions(query);\n \n     if (settings.optimize_normalize_count_variants)\n-        optimizeCountConstantAndSumOne(query);\n+        optimizeCountConstantAndSumOne(query, context);\n \n     if (settings.optimize_multiif_to_if)\n         optimizeMultiIfToIf(query);\ndiff --git a/src/Interpreters/TreeOptimizer.h b/src/Interpreters/TreeOptimizer.h\nindex 72a240d83b58..07ae2fbd12de 100644\n--- a/src/Interpreters/TreeOptimizer.h\n+++ b/src/Interpreters/TreeOptimizer.h\n@@ -24,7 +24,7 @@ class TreeOptimizer\n         ContextPtr context);\n \n     static void optimizeIf(ASTPtr & query, Aliases & aliases, bool if_chain_to_multiif);\n-    static void optimizeCountConstantAndSumOne(ASTPtr & query);\n+    static void optimizeCountConstantAndSumOne(ASTPtr & query, ContextPtr context);\n     static void optimizeGroupByFunctionKeys(ASTSelectQuery * select_query);\n };\n \ndiff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp\nindex 828f332af1d4..73f2ca162179 100644\n--- a/src/Interpreters/TreeRewriter.cpp\n+++ b/src/Interpreters/TreeRewriter.cpp\n@@ -147,7 +147,7 @@ struct CustomizeAggregateFunctionsSuffixData\n     void visit(ASTFunction & func, ASTPtr &) const\n     {\n         const auto & instance = AggregateFunctionFactory::instance();\n-        if (instance.isAggregateFunctionName(func.name) && !endsWith(func.name, customized_func_suffix))\n+        if (instance.isAggregateFunctionName(func.name) && !endsWith(func.name, customized_func_suffix) && !endsWith(func.name, customized_func_suffix + \"If\"))\n         {\n             auto properties = instance.tryGetProperties(func.name);\n             if (properties && !properties->returns_default_when_only_null)\n@@ -1292,7 +1292,7 @@ TreeRewriterResultPtr TreeRewriter::analyzeSelect(\n \n     /// Perform it before analyzing JOINs, because it may change number of columns with names unique and break some logic inside JOINs\n     if (settings.optimize_normalize_count_variants)\n-        TreeOptimizer::optimizeCountConstantAndSumOne(query);\n+        TreeOptimizer::optimizeCountConstantAndSumOne(query, getContext());\n \n     if (tables_with_columns.size() > 1)\n     {\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01528_setting_aggregate_functions_null_for_empty.reference b/tests/queries/0_stateless/01528_setting_aggregate_functions_null_for_empty.reference\nindex 9c6ae9c65abd..8b1aa83d73cc 100644\n--- a/tests/queries/0_stateless/01528_setting_aggregate_functions_null_for_empty.reference\n+++ b/tests/queries/0_stateless/01528_setting_aggregate_functions_null_for_empty.reference\n@@ -14,3 +14,6 @@\n 45\n 10\n 10\n+SELECT sumOrNullIf(1, number > 0)\n+FROM numbers(10)\n+WHERE 0\ndiff --git a/tests/queries/0_stateless/01528_setting_aggregate_functions_null_for_empty.sql b/tests/queries/0_stateless/01528_setting_aggregate_functions_null_for_empty.sql\nindex e76ce667bbc7..b57a492e3756 100644\n--- a/tests/queries/0_stateless/01528_setting_aggregate_functions_null_for_empty.sql\n+++ b/tests/queries/0_stateless/01528_setting_aggregate_functions_null_for_empty.sql\n@@ -33,4 +33,7 @@ SELECT sumOrNull(n) FROM defaults;\n SELECT count(n) FROM defaults;\n SELECT countOrNull(n) FROM defaults;\n \n+\n+EXPLAIN SYNTAX SELECT sumIf(1, number > 0) FROM numbers(10) WHERE 0;\n+\n DROP TABLE defaults;\ndiff --git a/tests/queries/0_stateless/01706_optimize_normalize_count_variants.reference b/tests/queries/0_stateless/01706_optimize_normalize_count_variants.reference\nindex 0343ad84abb3..3080226da328 100644\n--- a/tests/queries/0_stateless/01706_optimize_normalize_count_variants.reference\n+++ b/tests/queries/0_stateless/01706_optimize_normalize_count_variants.reference\n@@ -4,3 +4,6 @@ SELECT\n     count(),\n     count(),\n     count(NULL)\n+SELECT sumOrNull(1)\n+FROM numbers(10)\n+WHERE 0\ndiff --git a/tests/queries/0_stateless/01706_optimize_normalize_count_variants.sql b/tests/queries/0_stateless/01706_optimize_normalize_count_variants.sql\nindex d20f23feef89..9c85d6bc2fdb 100644\n--- a/tests/queries/0_stateless/01706_optimize_normalize_count_variants.sql\n+++ b/tests/queries/0_stateless/01706_optimize_normalize_count_variants.sql\n@@ -2,3 +2,7 @@\n set optimize_normalize_count_variants = 1;\n \n explain syntax select count(), count(1), count(-1), sum(1), count(null);\n+\n+set aggregate_functions_null_for_empty = 1;\n+\n+explain syntax select sum(1) from numbers(10) where 0;\n",
  "problem_statement": "aggregate_functions_null_for_empty is not working as expected for sum \n```\r\nSELECT SUM(1) AS aggr\r\nFROM system.one\r\nWHERE 0\r\nSETTINGS aggregate_functions_null_for_empty = 1\r\n\r\nQuery id: bc5d9708-d5bf-4d43-b22c-37d9db3dcc63\r\n\r\n\u250c\u2500aggr\u2500\u2510\r\n\u2502    0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nEverything is OK for max\r\n\r\n```\r\nSELECT max(1) AS aggr\r\nFROM system.one\r\nWHERE 0\r\nSETTINGS aggregate_functions_null_for_empty = 1\r\n\r\nQuery id: e6f245a5-b76b-4095-89c6-0884883fcc41\r\n\r\n\u250c\u2500aggr\u2500\u2510\r\n\u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.001 sec.\r\n```\n",
  "hints_text": "It seems it's due to other \"fancy\" optimizations:\r\n```\r\nSELECT sumOrNull(1) AS aggr\r\nFROM system.one\r\nWHERE 0\r\nSETTINGS aggregate_functions_null_for_empty = 1\r\n\r\nQuery id: e69248a8-a9a7-4112-ac9a-3d864f888e4b\r\n\r\n\u250c\u2500aggr\u2500\u2510\r\n\u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.001 sec.\r\n```\r\n\r\n\r\n```\r\nEXPLAIN SYNTAX\r\nSELECT SUM(1) AS aggr\r\nFROM system.one\r\nWHERE 0\r\nSETTINGS aggregate_functions_null_for_empty = 1\r\n\r\nQuery id: 4e35d563-381a-41e9-ad65-8997d4afbe7a\r\n\r\n\u250c\u2500explain\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 SELECT count() AS aggr                          \u2502 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\r\n\u2502 FROM system.one                                 \u2502\r\n\u2502 WHERE 0                                         \u2502\r\n\u2502 SETTINGS aggregate_functions_null_for_empty = 1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n```\r\nSELECT sum(1) AS aggr\r\nFROM system.one\r\nWHERE 0\r\nSETTINGS aggregate_functions_null_for_empty = 1, optimize_normalize_count_variants = 0\r\n\r\nQuery id: 0b9252ed-b678-41bb-9e95-fce4a2c57320\r\n\r\n\u250c\u2500aggr\u2500\u2510\r\n\u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.001 sec\r\n```\r\n\r\nBasically `optimize_normalize_count_variants` is breaking `aggregate_functions_null_for_empty`.\nShould we also have count()=NULL for 0 rows with aggregate_functions_null_for_empty=1?\n>  Should we also have count()=NULL for 0 rows with aggregate_functions_null_for_empty=1?\r\n\r\nThe docs says `aggregate_functions_null_for_empty` works by adding OrNull to the aggregation, so I'd say yes, since countOrNull() does return NULL in that case.\r\n\r\n```\r\nSELECT countOrNull() AS aggr\r\nFROM system.one\r\nWHERE 0\r\nSETTINGS aggregate_functions_null_for_empty = 1, optimize_normalize_count_variants = 0\r\n\r\nQuery id: 39f9c249-361d-4632-a73a-85bc0b4a913d\r\n\r\n\u250c\u2500aggr\u2500\u2510\r\n\u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n ```\nIt looks optimization is applied before we apply aggregate_functions_null_for_empty.\n\nSumOrNull(1) will be converted to countOrNull?\noptimize_normalize_count_variants is not applied to OrNull\r\n```\r\nEXPLAIN SYNTAX\r\nSELECT sumOrNull(1) AS aggr\r\nFROM system.one\r\nWHERE 0\r\nSETTINGS optimize_normalize_count_variants = 1\r\n\r\nQuery id: feb86bb9-c629-438f-941e-14e44230eaf3\r\n\r\n\u250c\u2500explain\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 SELECT sumOrNull(1) AS aggr                    \u2502\r\n\u2502 FROM system.one                                \u2502\r\n\u2502 WHERE 0                                        \u2502\r\n\u2502 SETTINGS optimize_normalize_count_variants = 1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n4 rows in set. Elapsed: 0.001 sec.\r\n```\n> Should we also have count()=NULL for 0 rows with aggregate_functions_null_for_empty=1?\r\n\r\nNo. It should be `0` by standard sql\r\n\r\n```sql\r\n\r\npsql => \\pset null '<null>'\r\n\r\npsql => select sum(1) from (select 1 a) t where 1=0;\r\n  sum\r\n--------\r\n <null>\r\n\r\npsql => select max(a) from (select 1 a) t where 1=0;\r\n  max\r\n--------\r\n <null>\r\n\r\npsql => select count(1) from (select 1 a) t where 1=0;\r\n count\r\n-------\r\n     0\r\n\r\npsql => select count(a) from (select 1 a) t where 1=0;\r\n count\r\n-------\r\n     0\r\n\r\npsql => select count(*) from (select 1 a) t where 1=0;\r\n count\r\n-------\r\n     0\r\n```",
  "created_at": "2022-12-02T10:04:01Z",
  "modified_files": [
    "src/Analyzer/Passes/NormalizeCountVariantsPass.cpp",
    "src/Analyzer/Passes/SumIfToCountIfPass.cpp",
    "src/Interpreters/RewriteCountVariantsVisitor.cpp",
    "src/Interpreters/RewriteCountVariantsVisitor.h",
    "src/Interpreters/TreeOptimizer.cpp",
    "src/Interpreters/TreeOptimizer.h",
    "src/Interpreters/TreeRewriter.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01528_setting_aggregate_functions_null_for_empty.reference",
    "tests/queries/0_stateless/01528_setting_aggregate_functions_null_for_empty.sql",
    "tests/queries/0_stateless/01706_optimize_normalize_count_variants.reference",
    "tests/queries/0_stateless/01706_optimize_normalize_count_variants.sql"
  ]
}