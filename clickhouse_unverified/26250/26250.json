{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 26250,
  "instance_id": "ClickHouse__ClickHouse-26250",
  "issue_numbers": [
    "26017"
  ],
  "base_commit": "fc783be800ea6eb8ddcedbe075aa74a3bc5fde27",
  "patch": "diff --git a/src/Core/Block.cpp b/src/Core/Block.cpp\nindex fa78f052f377..7a7355692385 100644\n--- a/src/Core/Block.cpp\n+++ b/src/Core/Block.cpp\n@@ -436,7 +436,7 @@ Block Block::sortColumns() const\n     Block sorted_block;\n \n     /// std::unordered_map (index_by_name) cannot be used to guarantee the sort order\n-    std::vector<decltype(index_by_name.begin())> sorted_index_by_name(index_by_name.size());\n+    std::vector<IndexByName::const_iterator> sorted_index_by_name(index_by_name.size());\n     {\n         size_t i = 0;\n         for (auto it = index_by_name.begin(); it != index_by_name.end(); ++it)\ndiff --git a/src/Core/Block.h b/src/Core/Block.h\nindex a21bd2905718..fb94a205bf55 100644\n--- a/src/Core/Block.h\n+++ b/src/Core/Block.h\n@@ -68,7 +68,7 @@ class Block\n             const_cast<const Block *>(this)->findByName(name));\n     }\n \n-    const ColumnWithTypeAndName* findByName(const std::string & name) const;\n+    const ColumnWithTypeAndName * findByName(const std::string & name) const;\n \n     ColumnWithTypeAndName & getByName(const std::string & name)\n     {\ndiff --git a/src/Interpreters/HashJoin.cpp b/src/Interpreters/HashJoin.cpp\nindex 6e5f7df99bd0..56ad13511ac5 100644\n--- a/src/Interpreters/HashJoin.cpp\n+++ b/src/Interpreters/HashJoin.cpp\n@@ -1368,18 +1368,6 @@ void HashJoin::joinBlock(Block & block, ExtraBlockPtr & not_processed)\n         throw Exception(\"Logical error: unknown combination of JOIN\", ErrorCodes::LOGICAL_ERROR);\n }\n \n-\n-void HashJoin::joinTotals(Block & block) const\n-{\n-    Block sample_right_block = sample_block_with_columns_to_add.cloneEmpty();\n-    /// For StorageJoin column names isn't qualified in sample_block_with_columns_to_add\n-    for (auto & col : sample_right_block)\n-        col.name = getTableJoin().renamedRightColumnName(col.name);\n-\n-    JoinCommon::joinTotals(totals, sample_right_block, *table_join, block);\n-}\n-\n-\n template <typename Mapped>\n struct AdderNonJoined\n {\ndiff --git a/src/Interpreters/HashJoin.h b/src/Interpreters/HashJoin.h\nindex 84c447d875e7..86c530810590 100644\n--- a/src/Interpreters/HashJoin.h\n+++ b/src/Interpreters/HashJoin.h\n@@ -155,9 +155,7 @@ class HashJoin : public IJoin\n     /** Keep \"totals\" (separate part of dataset, see WITH TOTALS) to use later.\n       */\n     void setTotals(const Block & block) override { totals = block; }\n-    bool hasTotals() const override { return totals; }\n-\n-    void joinTotals(Block & block) const override;\n+    const Block & getTotals() const override { return totals; }\n \n     bool isFilled() const override { return from_storage_join || data->type == Type::DICT; }\n \ndiff --git a/src/Interpreters/IJoin.h b/src/Interpreters/IJoin.h\nindex 0f486fbe5233..c2cf007d8233 100644\n--- a/src/Interpreters/IJoin.h\n+++ b/src/Interpreters/IJoin.h\n@@ -31,11 +31,9 @@ class IJoin\n     /// Could be called from different threads in parallel.\n     virtual void joinBlock(Block & block, std::shared_ptr<ExtraBlock> & not_processed) = 0;\n \n-    virtual bool hasTotals() const = 0;\n-    /// Set totals for right table\n+    /// Set/Get totals for right table\n     virtual void setTotals(const Block & block) = 0;\n-    /// Add totals to block from left table\n-    virtual void joinTotals(Block & block) const = 0;\n+    virtual const Block & getTotals() const = 0;\n \n     virtual size_t getTotalRowCount() const = 0;\n     virtual size_t getTotalByteCount() const = 0;\ndiff --git a/src/Interpreters/JoinSwitcher.h b/src/Interpreters/JoinSwitcher.h\nindex 75ff7bb9b2c5..a89ac6d5d982 100644\n--- a/src/Interpreters/JoinSwitcher.h\n+++ b/src/Interpreters/JoinSwitcher.h\n@@ -31,9 +31,9 @@ class JoinSwitcher : public IJoin\n         join->joinBlock(block, not_processed);\n     }\n \n-    bool hasTotals() const override\n+    const Block & getTotals() const override\n     {\n-        return join->hasTotals();\n+        return join->getTotals();\n     }\n \n     void setTotals(const Block & block) override\n@@ -41,11 +41,6 @@ class JoinSwitcher : public IJoin\n         join->setTotals(block);\n     }\n \n-    void joinTotals(Block & block) const override\n-    {\n-        join->joinTotals(block);\n-    }\n-\n     size_t getTotalRowCount() const override\n     {\n         return join->getTotalRowCount();\ndiff --git a/src/Interpreters/MergeJoin.cpp b/src/Interpreters/MergeJoin.cpp\nindex 26463c8c6edd..46833f9769e7 100644\n--- a/src/Interpreters/MergeJoin.cpp\n+++ b/src/Interpreters/MergeJoin.cpp\n@@ -503,11 +503,6 @@ void MergeJoin::setTotals(const Block & totals_block)\n         used_rows_bitmap = std::make_shared<RowBitmaps>(getRightBlocksCount());\n }\n \n-void MergeJoin::joinTotals(Block & block) const\n-{\n-    JoinCommon::joinTotals(totals, right_columns_to_add, *table_join, block);\n-}\n-\n void MergeJoin::mergeRightBlocks()\n {\n     if (is_in_memory)\ndiff --git a/src/Interpreters/MergeJoin.h b/src/Interpreters/MergeJoin.h\nindex b6bde8fb1312..8c829569a41d 100644\n--- a/src/Interpreters/MergeJoin.h\n+++ b/src/Interpreters/MergeJoin.h\n@@ -26,9 +26,10 @@ class MergeJoin : public IJoin\n     const TableJoin & getTableJoin() const override { return *table_join; }\n     bool addJoinedBlock(const Block & block, bool check_limits) override;\n     void joinBlock(Block &, ExtraBlockPtr & not_processed) override;\n-    void joinTotals(Block &) const override;\n+\n     void setTotals(const Block &) override;\n-    bool hasTotals() const override { return totals; }\n+    const Block & getTotals() const override { return totals; }\n+\n     size_t getTotalRowCount() const override { return right_blocks.row_count; }\n     size_t getTotalByteCount() const override { return right_blocks.bytes; }\n \ndiff --git a/src/Interpreters/join_common.cpp b/src/Interpreters/join_common.cpp\nindex 5548667e1a7d..74f2c26a2ef5 100644\n--- a/src/Interpreters/join_common.cpp\n+++ b/src/Interpreters/join_common.cpp\n@@ -322,46 +322,26 @@ void createMissedColumns(Block & block)\n }\n \n /// Append totals from right to left block, correct types if needed\n-void joinTotals(const Block & totals, const Block & columns_to_add, const TableJoin & table_join, Block & block)\n+void joinTotals(Block left_totals, Block right_totals, const TableJoin & table_join, Block & out_block)\n {\n     if (table_join.forceNullableLeft())\n-        convertColumnsToNullable(block);\n+        JoinCommon::convertColumnsToNullable(left_totals);\n \n-    if (Block totals_without_keys = totals)\n-    {\n-        for (const auto & name : table_join.keyNamesRight())\n-            totals_without_keys.erase(totals_without_keys.getPositionByName(name));\n-\n-        for (auto & col : totals_without_keys)\n-        {\n-            if (table_join.rightBecomeNullable(col.type))\n-                JoinCommon::convertColumnToNullable(col);\n+    if (table_join.forceNullableRight())\n+        JoinCommon::convertColumnsToNullable(right_totals);\n \n-            /// In case of arrayJoin it can be not one row\n-            if (col.column->size() != 1)\n-                col.column = col.column->cloneResized(1);\n-        }\n-\n-        for (size_t i = 0; i < totals_without_keys.columns(); ++i)\n-            block.insert(totals_without_keys.safeGetByPosition(i));\n-    }\n-    else\n+    for (auto & col : out_block)\n     {\n-        /// We will join empty `totals` - from one row with the default values.\n+        if (const auto * left_col = left_totals.findByName(col.name))\n+            col = *left_col;\n+        else if (const auto * right_col = right_totals.findByName(col.name))\n+            col = *right_col;\n+        else\n+            col.column = col.type->createColumnConstWithDefaultValue(1)->convertToFullColumnIfConst();\n \n-        for (size_t i = 0; i < columns_to_add.columns(); ++i)\n-        {\n-            const auto & col = columns_to_add.getByPosition(i);\n-            if (block.has(col.name))\n-            {\n-                /// For StorageJoin we discarded table qualifiers, so some names may clash\n-                continue;\n-            }\n-            block.insert({\n-                col.type->createColumnConstWithDefaultValue(1)->convertToFullColumnIfConst(),\n-                col.type,\n-                col.name});\n-        }\n+        /// In case of using `arrayJoin` we can get more or less rows than one\n+        if (col.column->size() != 1)\n+            col.column = col.column->cloneResized(1);\n     }\n }\n \ndiff --git a/src/Interpreters/join_common.h b/src/Interpreters/join_common.h\nindex 9334b9d672fc..2da795d0d4c6 100644\n--- a/src/Interpreters/join_common.h\n+++ b/src/Interpreters/join_common.h\n@@ -35,7 +35,7 @@ ColumnRawPtrs extractKeysForJoin(const Block & block_keys, const Names & key_nam\n void checkTypesOfKeys(const Block & block_left, const Names & key_names_left, const Block & block_right, const Names & key_names_right);\n \n void createMissedColumns(Block & block);\n-void joinTotals(const Block & totals, const Block & columns_to_add, const TableJoin & table_join, Block & block);\n+void joinTotals(Block left_totals, Block right_totals, const TableJoin & table_join, Block & out_block);\n \n void addDefaultValues(IColumn & column, const DataTypePtr & type, size_t count);\n \ndiff --git a/src/Processors/QueryPlan/JoinStep.cpp b/src/Processors/QueryPlan/JoinStep.cpp\nindex b06d6628dcbd..736d7eb37c14 100644\n--- a/src/Processors/QueryPlan/JoinStep.cpp\n+++ b/src/Processors/QueryPlan/JoinStep.cpp\n@@ -70,7 +70,7 @@ FilledJoinStep::FilledJoinStep(const DataStream & input_stream_, JoinPtr join_,\n void FilledJoinStep::transformPipeline(QueryPipeline & pipeline, const BuildQueryPipelineSettings &)\n {\n     bool default_totals = false;\n-    if (!pipeline.hasTotals() && join->hasTotals())\n+    if (!pipeline.hasTotals() && join->getTotals())\n     {\n         pipeline.addDefaultTotals();\n         default_totals = true;\ndiff --git a/src/Processors/Transforms/JoiningTransform.cpp b/src/Processors/Transforms/JoiningTransform.cpp\nindex 31b2da46ab3e..87f22319bbaf 100644\n--- a/src/Processors/Transforms/JoiningTransform.cpp\n+++ b/src/Processors/Transforms/JoiningTransform.cpp\n@@ -1,6 +1,6 @@\n #include <Processors/Transforms/JoiningTransform.h>\n #include <Interpreters/ExpressionAnalyzer.h>\n-#include <Interpreters/ExpressionActions.h>\n+#include <Interpreters/join_common.h>\n #include <DataStreams/IBlockInputStream.h>\n #include <DataTypes/DataTypesNumber.h>\n \n@@ -159,19 +159,16 @@ void JoiningTransform::transform(Chunk & chunk)\n     Block block;\n     if (on_totals)\n     {\n-        /// We have to make chunk empty before return\n-        /// In case of using `arrayJoin` we can get more or less rows than one\n-        auto cols = chunk.detachColumns();\n-        for (auto & col : cols)\n-            col = col->cloneResized(1);\n-        block = inputs.front().getHeader().cloneWithColumns(std::move(cols));\n+        const auto & left_totals = inputs.front().getHeader().cloneWithColumns(chunk.detachColumns());\n+        const auto & right_totals = join->getTotals();\n \n         /// Drop totals if both out stream and joined stream doesn't have ones.\n         /// See comment in ExpressionTransform.h\n-        if (default_totals && !join->hasTotals())\n+        if (default_totals && !right_totals)\n             return;\n \n-        join->joinTotals(block);\n+        block = outputs.front().getHeader().cloneEmpty();\n+        JoinCommon::joinTotals(left_totals, right_totals, join->getTableJoin(), block);\n     }\n     else\n         block = readExecute(chunk);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01107_join_right_table_totals.reference b/tests/queries/0_stateless/01107_join_right_table_totals.reference\nindex f71d3b0d05f4..daf503b776d3 100644\n--- a/tests/queries/0_stateless/01107_join_right_table_totals.reference\n+++ b/tests/queries/0_stateless/01107_join_right_table_totals.reference\n@@ -18,3 +18,31 @@\n 0\t0\n \n 0\t0\n+1\t1\n+1\t1\n+\n+0\t0\n+1\t1\n+1\t1\n+\n+0\t0\n+1\t1\n+1\t1\n+\n+0\t0\n+1\t1\n+1\t1\n+\n+0\t0\n+1\t1\n+\n+0\t0\n+1\tfoo\t1\t1\t300\n+\n+0\tfoo\t1\t0\t300\n+1\t100\t1970-01-01\t1\t100\t1970-01-01\n+1\t100\t1970-01-01\t1\t200\t1970-01-02\n+1\t200\t1970-01-02\t1\t100\t1970-01-01\n+1\t200\t1970-01-02\t1\t200\t1970-01-02\n+\n+0\t0\t1970-01-01\t0\t0\t1970-01-01\ndiff --git a/tests/queries/0_stateless/01107_join_right_table_totals.sql b/tests/queries/0_stateless/01107_join_right_table_totals.sql\nindex a4f284e5e2da..f894b6bf8bbe 100644\n--- a/tests/queries/0_stateless/01107_join_right_table_totals.sql\n+++ b/tests/queries/0_stateless/01107_join_right_table_totals.sql\n@@ -35,29 +35,66 @@ FULL JOIN\n ) rr\n USING (id);\n \n-SELECT id, yago \n+SELECT id, yago\n FROM ( SELECT item_id AS id FROM t GROUP BY id ) AS ll\n-FULL OUTER JOIN ( SELECT item_id AS id, arrayJoin([111, 222, 333, 444]), SUM(price_sold) AS yago FROM t GROUP BY id WITH TOTALS ) AS rr \n+FULL OUTER JOIN ( SELECT item_id AS id, arrayJoin([111, 222, 333, 444]), SUM(price_sold) AS yago FROM t GROUP BY id WITH TOTALS ) AS rr\n USING (id);\n \n-SELECT id, yago \n+SELECT id, yago\n FROM ( SELECT item_id AS id, arrayJoin([111, 222, 333]) FROM t GROUP BY id WITH TOTALS ) AS ll\n-FULL OUTER JOIN ( SELECT item_id AS id, SUM(price_sold) AS yago FROM t GROUP BY id ) AS rr \n+FULL OUTER JOIN ( SELECT item_id AS id, SUM(price_sold) AS yago FROM t GROUP BY id ) AS rr\n USING (id);\n \n-SELECT id, yago \n+SELECT id, yago\n FROM ( SELECT item_id AS id, arrayJoin(emptyArrayInt32()) FROM t GROUP BY id WITH TOTALS ) AS ll\n-FULL OUTER JOIN ( SELECT item_id AS id, SUM(price_sold) AS yago FROM t GROUP BY id ) AS rr \n+FULL OUTER JOIN ( SELECT item_id AS id, SUM(price_sold) AS yago FROM t GROUP BY id ) AS rr\n USING (id);\n \n-SELECT id, yago \n+SELECT id, yago\n FROM ( SELECT item_id AS id FROM t GROUP BY id ) AS ll\n-FULL OUTER JOIN ( SELECT item_id AS id, arrayJoin(emptyArrayInt32()), SUM(price_sold) AS yago FROM t GROUP BY id WITH TOTALS ) AS rr \n+FULL OUTER JOIN ( SELECT item_id AS id, arrayJoin(emptyArrayInt32()), SUM(price_sold) AS yago FROM t GROUP BY id WITH TOTALS ) AS rr\n USING (id);\n \n-SELECT id, yago \n+SELECT id, yago\n FROM ( SELECT item_id AS id, arrayJoin([111, 222, 333]) FROM t GROUP BY id WITH TOTALS ) AS ll\n-FULL OUTER JOIN ( SELECT item_id AS id, arrayJoin([111, 222, 333, 444]), SUM(price_sold) AS yago FROM t GROUP BY id WITH TOTALS ) AS rr \n+FULL OUTER JOIN ( SELECT item_id AS id, arrayJoin([111, 222, 333, 444]), SUM(price_sold) AS yago FROM t GROUP BY id WITH TOTALS ) AS rr\n USING (id);\n \n+INSERT INTO t VALUES (1, 100, '1970-01-01'), (1, 200, '1970-01-02');\n+\n+SELECT *\n+FROM (SELECT item_id FROM t GROUP BY item_id WITH TOTALS) l\n+LEFT JOIN (SELECT item_id FROM t ) r\n+ON l.item_id = r.item_id;\n+\n+SELECT *\n+FROM (SELECT item_id FROM t GROUP BY item_id WITH TOTALS) l\n+RIGHT JOIN (SELECT item_id FROM t ) r\n+ON l.item_id = r.item_id;\n+\n+SELECT *\n+FROM (SELECT item_id FROM t) l\n+LEFT JOIN (SELECT item_id FROM t GROUP BY item_id WITH TOTALS ) r\n+ON l.item_id = r.item_id;\n+\n+SELECT *\n+FROM (SELECT item_id FROM t) l\n+RIGHT JOIN (SELECT item_id FROM t GROUP BY item_id WITH TOTALS ) r\n+ON l.item_id = r.item_id;\n+\n+SELECT *\n+FROM (SELECT item_id FROM t GROUP BY item_id WITH TOTALS) l\n+LEFT JOIN (SELECT item_id FROM t GROUP BY item_id WITH TOTALS ) r\n+ON l.item_id = r.item_id;\n+\n+SELECT *\n+FROM (SELECT item_id, 'foo' AS key, 1 AS val FROM t GROUP BY item_id WITH TOTALS) l\n+LEFT JOIN (SELECT item_id, sum(price_sold) AS val FROM t GROUP BY item_id WITH TOTALS ) r\n+ON l.item_id = r.item_id;\n+\n+SELECT *\n+FROM (SELECT * FROM t GROUP BY item_id, price_sold, date WITH TOTALS) l\n+LEFT JOIN (SELECT * FROM t GROUP BY item_id, price_sold, date WITH TOTALS ) r\n+ON l.item_id = r.item_id;\n+\n DROP TABLE t;\n",
  "problem_statement": "Logical error leads to server crash when joining subquery with totals\n\r\n**How to reproduce**\r\n\r\n* Which ClickHouse server version to use\r\nlatest master/trunk version\r\n\r\n\r\n* Queries to run that lead to unexpected result\r\n```sql\r\n:) select * from (select * from numbers(10) group by number with totals) as a global all left join numbers(10) as b on a.number = b.number\r\n\r\nSELECT *\r\nFROM\r\n(\r\n    SELECT *\r\n    FROM numbers(10)\r\n    GROUP BY number\r\n        WITH TOTALS\r\n) AS a\r\nGLOBAL ALL LEFT JOIN numbers(10) AS b ON a.number = b.number\r\n```\r\n\r\n**Error message and/or stacktrace**\r\n```\r\n<Fatal> : Logical error: 'Invalid number of columns in chunk pushed to OutputPort. Expected 2, found 1\r\nHeader: number UInt64 UInt64(size = 0), b.number UInt64 UInt64(size = 0)\r\nChunk:  UInt64(size = 1)\r\n'.\r\n```\r\n```\r\n19. @     0x1bf11424 <DB::Exception::Exception(std::__y1::basic_string<char, std::__y1::char_traits<char>, std::__y1::allocator<char> > const&, int, bool)+147> (/home/dakovalkov/ytarc/build/yt/chyt/server/bin/ytserver-clickhouse+466687011)\r\n20. @     0x1d160760 <DB::JoiningTransform::prepare()+4031> (/home/dakovalkov/ytarc/build/yt/chyt/server/bin/ytserver-clickhouse+485885791)\r\n21. @     0x1c436ffe <DB::IProcessor::prepare(std::__y1::vector<unsigned long, std::__y1::allocator<unsigned long> > const&, std::__y1::vector<unsigned long, std::__y1::allocator<unsigned long> > const&)+29> (/home/dakovalkov/ytarc/build/yt/chyt/server/bin/ytserver-clickhouse+472084477)\r\n22. @     0x1d16ee90 <DB::PipelineExecutor::prepareProcessor(unsigned long, unsigned long, std::__y1::queue<DB::ExecutingGraph::Node*, std::__y1::deque<DB::ExecutingGraph::Node*, std::__y1::allocator<DB::ExecutingGraph::Node*> > >&, std::__y1::queue<DB::ExecutingGraph::Node*, std::__y1::deque<DB::ExecutingGraph::Node*, std::__y1::allocator<DB::ExecutingGraph::Node*> > >&, std::__y1::unique_lock<std::__y1::mutex>)+191> (/home/dakovalkov/ytarc/build/yt/chyt/server/bin/ytserver-clickhouse+485944975)\r\n23. @     0x1d1720df <DB::PipelineExecutor::executeStepImpl(unsigned long, unsigned long, std::__y1::atomic<bool>*)+2414> (/home/dakovalkov/ytarc/build/yt/chyt/server/bin/ytserver-clickhouse+485957854)\r\n24. @     0x1d1728e5 <DB::PipelineExecutor::executeSingleThread(unsigned long, unsigned long)+68> (/home/dakovalkov/ytarc/build/yt/chyt/server/bin/ytserver-clickhouse+485959908)\r\n25. @     0x1d170833 <DB::PipelineExecutor::executeImpl(unsigned long)+1218> (/home/dakovalkov/ytarc/build/yt/chyt/server/bin/ytserver-clickhouse+485951538)\r\n26. @     0x1d16fb73 <DB::PipelineExecutor::execute(unsigned long)+50> (/home/dakovalkov/ytarc/build/yt/chyt/server/bin/ytserver-clickhouse+485948274)\r\n27. @     0x1e0e979b <DB::executeQuery(DB::ReadBuffer&, DB::WriteBuffer&, bool, std::__y1::shared_ptr<DB::Context>, std::__y1::function<void (std::__y1::basic_string<char, std::__y1::char_traits<char>, std::__y1::allocator<char> > const&, std::__y1::basic_string<char, std::__y1::char_traits<char>, std::__y1::allocator<char> > const&, std::__y1::basic_string<char, std::__y1::char_traits<char>, std::__y1::allocator<char> > const&, std::__y1::basic_string<char, std::__y1::char_traits<char>, std::__y1::allocator<char> > const&)>)+5882> (/home/dakovalkov/ytarc/build/yt/chyt/server/bin/ytserver-clickhouse+502175642)\r\n28. @     0x2bcf5e56 <DB::HTTPHandler::processQuery(std::__y1::shared_ptr<DB::Context>, DB::HTTPServerRequest&, DB::HTMLForm&, DB::HTTPServerResponse&, DB::HTTPHandler::Output&, std::__y1::optional<DB::CurrentThread::QueryScope>&)+11349> (/home/dakovalkov/ytarc/build/yt/chyt/server/bin/ytserver-clickhouse+732913237)\r\n```\r\n\r\n\r\n**Additional context**\r\n\r\nWithout \"with totals\" query works fine.\r\nChanging \"on a.number = b.number\" to \"using number\" also helps.\r\n\n",
  "hints_text": "@DimasKovas Logical error is a simple exception in release build.\r\nBut in debug build it terminates the server (as failed assertion).\nThis reproduces in Yandex.Metrica acceptance testing: https://st.yandex-team.ru/MTRSADMIN-7467\nA real query fails with a cryptic error while it worked before. Looks like this is a bug.",
  "created_at": "2021-07-12T15:01:42Z"
}