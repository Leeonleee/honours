{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 13017,
  "instance_id": "ClickHouse__ClickHouse-13017",
  "issue_numbers": [
    "8076"
  ],
  "base_commit": "585d9247ecc33287d85fa3ab64e0952edb12f5d9",
  "patch": "diff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex ad03fa706d17..ac325538923f 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -393,6 +393,7 @@ struct Settings : public SettingsCollection<Settings>\n     M(SettingBool, allow_experimental_geo_types, false, \"Allow geo data types such as Point, Ring, Polygon, MultiPolygon\", 0) \\\n     M(SettingBool, data_type_default_nullable, false, \"Data types without NULL or NOT NULL will make Nullable\", 0) \\\n     M(SettingBool, cast_keep_nullable, false, \"CAST operator keep Nullable for result data type\", 0) \\\n+    M(SettingBool, alter_partition_verbose_result, false, \"Output information about affected parts. Currently works only for FREEZE and ATTACH commands.\", 0) \\\n     \\\n     /** Obsolete settings that do nothing but left for compatibility reasons. Remove each one after half a year of obsolescence. */ \\\n     \\\ndiff --git a/src/Interpreters/InterpreterAlterQuery.cpp b/src/Interpreters/InterpreterAlterQuery.cpp\nindex cd35e619d373..2f9e93d0eee7 100644\n--- a/src/Interpreters/InterpreterAlterQuery.cpp\n+++ b/src/Interpreters/InterpreterAlterQuery.cpp\n@@ -34,6 +34,7 @@ InterpreterAlterQuery::InterpreterAlterQuery(const ASTPtr & query_ptr_, const Co\n \n BlockIO InterpreterAlterQuery::execute()\n {\n+    BlockIO res;\n     const auto & alter = query_ptr->as<ASTAlterQuery &>();\n \n     if (!alter.cluster.empty())\n@@ -86,7 +87,9 @@ BlockIO InterpreterAlterQuery::execute()\n     if (!partition_commands.empty())\n     {\n         table->checkAlterPartitionIsPossible(partition_commands, metadata_snapshot, context.getSettingsRef());\n-        table->alterPartition(query_ptr, metadata_snapshot, partition_commands, context);\n+        auto partition_commands_pipes = table->alterPartition(query_ptr, metadata_snapshot, partition_commands, context);\n+        if (!partition_commands_pipes.empty())\n+            res.pipeline.init(std::move(partition_commands_pipes));\n     }\n \n     if (!live_view_commands.empty())\n@@ -113,7 +116,7 @@ BlockIO InterpreterAlterQuery::execute()\n         table->alter(alter_commands, context, alter_lock);\n     }\n \n-    return {};\n+    return res;\n }\n \n \ndiff --git a/src/Processors/Chunk.cpp b/src/Processors/Chunk.cpp\nindex 340cd4a43d78..4800bfca2ce2 100644\n--- a/src/Processors/Chunk.cpp\n+++ b/src/Processors/Chunk.cpp\n@@ -65,10 +65,13 @@ void Chunk::setColumns(MutableColumns columns_, UInt64 num_rows_)\n \n void Chunk::checkNumRowsIsConsistent()\n {\n-    for (auto & column : columns)\n+    for (size_t i = 0; i < columns.size(); ++i)\n+    {\n+        auto & column = columns[i];\n         if (column->size() != num_rows)\n-            throw Exception(\"Invalid number of rows in Chunk column \" + column->getName()+ \": expected \" +\n+            throw Exception(\"Invalid number of rows in Chunk column \" + column->getName()+ \" position \" + toString(i) + \": expected \" +\n                             toString(num_rows) + \", got \" + toString(column->size()), ErrorCodes::LOGICAL_ERROR);\n+    }\n }\n \n MutableColumns Chunk::mutateColumns()\ndiff --git a/src/Storages/IStorage.h b/src/Storages/IStorage.h\nindex e6a1a8e12989..1c75a661339e 100644\n--- a/src/Storages/IStorage.h\n+++ b/src/Storages/IStorage.h\n@@ -355,7 +355,7 @@ class IStorage : public std::enable_shared_from_this<IStorage>, public TypePromo\n     /** ALTER tables with regard to its partitions.\n       * Should handle locks for each command on its own.\n       */\n-    virtual void alterPartition(const ASTPtr & /* query */, const StorageMetadataPtr & /* metadata_snapshot */, const PartitionCommands & /* commands */, const Context & /* context */)\n+    virtual Pipes alterPartition(const ASTPtr & /* query */, const StorageMetadataPtr & /* metadata_snapshot */, const PartitionCommands & /* commands */, const Context & /* context */)\n     {\n         throw Exception(\"Partition operations are not supported by storage \" + getName(), ErrorCodes::NOT_IMPLEMENTED);\n     }\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex c71172850ba5..c865406467b9 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -1662,9 +1662,9 @@ void MergeTreeData::changeSettings(\n     }\n }\n \n-void MergeTreeData::freezeAll(const String & with_name, const StorageMetadataPtr & metadata_snapshot, const Context & context, TableLockHolder &)\n+PartitionCommandsResultInfo MergeTreeData::freezeAll(const String & with_name, const StorageMetadataPtr & metadata_snapshot, const Context & context, TableLockHolder &)\n {\n-    freezePartitionsByMatcher([] (const DataPartPtr &){ return true; }, metadata_snapshot, with_name, context);\n+    return freezePartitionsByMatcher([] (const DataPartPtr &) { return true; }, metadata_snapshot, with_name, context);\n }\n \n void MergeTreeData::PartsTemporaryRename::addPart(const String & old_name, const String & new_name)\n@@ -2468,7 +2468,7 @@ void MergeTreeData::removePartContributionToColumnSizes(const DataPartPtr & part\n }\n \n \n-void MergeTreeData::freezePartition(const ASTPtr & partition_ast, const StorageMetadataPtr & metadata_snapshot, const String & with_name, const Context & context, TableLockHolder &)\n+PartitionCommandsResultInfo MergeTreeData::freezePartition(const ASTPtr & partition_ast, const StorageMetadataPtr & metadata_snapshot, const String & with_name, const Context & context, TableLockHolder &)\n {\n     std::optional<String> prefix;\n     String partition_id;\n@@ -2492,7 +2492,7 @@ void MergeTreeData::freezePartition(const ASTPtr & partition_ast, const StorageM\n         LOG_DEBUG(log, \"Freezing parts with partition ID {}\", partition_id);\n \n \n-    freezePartitionsByMatcher(\n+    return freezePartitionsByMatcher(\n         [&prefix, &partition_id](const DataPartPtr & part)\n         {\n             if (prefix)\n@@ -3319,7 +3319,7 @@ MergeTreeData::PathsWithDisks MergeTreeData::getRelativeDataPathsWithDisks() con\n     return res;\n }\n \n-void MergeTreeData::freezePartitionsByMatcher(MatcherFn matcher, const StorageMetadataPtr & metadata_snapshot, const String & with_name, const Context & context)\n+PartitionCommandsResultInfo MergeTreeData::freezePartitionsByMatcher(MatcherFn matcher, const StorageMetadataPtr & metadata_snapshot, const String & with_name, const Context & context)\n {\n     String clickhouse_path = Poco::Path(context.getPath()).makeAbsolute().toString();\n     String default_shadow_path = clickhouse_path + \"shadow/\";\n@@ -3331,6 +3331,10 @@ void MergeTreeData::freezePartitionsByMatcher(MatcherFn matcher, const StorageMe\n     /// Acquire a snapshot of active data parts to prevent removing while doing backup.\n     const auto data_parts = getDataParts();\n \n+    String backup_name = (!with_name.empty() ? escapeForFileName(with_name) : toString(increment));\n+\n+    PartitionCommandsResultInfo result;\n+\n     size_t parts_processed = 0;\n     for (const auto & part : data_parts)\n     {\n@@ -3339,11 +3343,7 @@ void MergeTreeData::freezePartitionsByMatcher(MatcherFn matcher, const StorageMe\n \n         part->volume->getDisk()->createDirectories(shadow_path);\n \n-        String backup_path = shadow_path\n-            + (!with_name.empty()\n-                ? escapeForFileName(with_name)\n-                : toString(increment))\n-            + \"/\";\n+        String backup_path = shadow_path + backup_name + \"/\";\n \n         LOG_DEBUG(log, \"Freezing part {} snapshot will be placed at {}\", part->name, backup_path);\n \n@@ -3356,10 +3356,17 @@ void MergeTreeData::freezePartitionsByMatcher(MatcherFn matcher, const StorageMe\n         part->volume->getDisk()->removeIfExists(backup_part_path + \"/\" + DELETE_ON_DESTROY_MARKER_PATH);\n \n         part->is_frozen.store(true, std::memory_order_relaxed);\n+        result.push_back(PartitionCommandResultInfo{\n+            .partition_id = part->info.partition_id,\n+            .part_name = part->name,\n+            .backup_path = backup_path,\n+            .backup_name = backup_name,\n+        });\n         ++parts_processed;\n     }\n \n     LOG_DEBUG(log, \"Freezed {} parts\", parts_processed);\n+    return result;\n }\n \n bool MergeTreeData::canReplacePartition(const DataPartPtr & src_part) const\ndiff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h\nindex 2c53b3287cd1..a50ea2a939f5 100644\n--- a/src/Storages/MergeTree/MergeTreeData.h\n+++ b/src/Storages/MergeTree/MergeTreeData.h\n@@ -515,7 +515,7 @@ class MergeTreeData : public IStorage\n         TableLockHolder & table_lock_holder);\n \n     /// Freezes all parts.\n-    void freezeAll(\n+    PartitionCommandsResultInfo freezeAll(\n         const String & with_name,\n         const StorageMetadataPtr & metadata_snapshot,\n         const Context & context,\n@@ -541,7 +541,7 @@ class MergeTreeData : public IStorage\n       * Backup is created in directory clickhouse_dir/shadow/i/, where i - incremental number,\n       *  or if 'with_name' is specified - backup is created in directory with specified name.\n       */\n-    void freezePartition(const ASTPtr & partition, const StorageMetadataPtr & metadata_snapshot, const String & with_name, const Context & context, TableLockHolder & table_lock_holder);\n+    PartitionCommandsResultInfo freezePartition(const ASTPtr & partition, const StorageMetadataPtr & metadata_snapshot, const String & with_name, const Context & context, TableLockHolder & table_lock_holder);\n \n \n public:\n@@ -836,7 +836,7 @@ class MergeTreeData : public IStorage\n \n     /// Common part for |freezePartition()| and |freezeAll()|.\n     using MatcherFn = std::function<bool(const DataPartPtr &)>;\n-    void freezePartitionsByMatcher(MatcherFn matcher, const StorageMetadataPtr & metadata_snapshot, const String & with_name, const Context & context);\n+    PartitionCommandsResultInfo freezePartitionsByMatcher(MatcherFn matcher, const StorageMetadataPtr & metadata_snapshot, const String & with_name, const Context & context);\n \n     bool canReplacePartition(const DataPartPtr & src_part) const;\n \ndiff --git a/src/Storages/PartitionCommands.cpp b/src/Storages/PartitionCommands.cpp\nindex c3bf00187afa..e3f542695cbd 100644\n--- a/src/Storages/PartitionCommands.cpp\n+++ b/src/Storages/PartitionCommands.cpp\n@@ -3,6 +3,11 @@\n #include <Storages/DataDestinationType.h>\n #include <Parsers/ASTAlterQuery.h>\n #include <Parsers/ASTIdentifier.h>\n+#include <Core/ColumnWithTypeAndName.h>\n+#include <DataTypes/DataTypeString.h>\n+#include <Processors/Chunk.h>\n+#include <Processors/Pipe.h>\n+#include <Processors/Sources/SourceFromSingleChunk.h>\n \n \n namespace DB\n@@ -97,4 +102,89 @@ std::optional<PartitionCommand> PartitionCommand::parse(const ASTAlterCommand *\n         return {};\n }\n \n+std::string PartitionCommand::typeToString() const\n+{\n+    switch (type)\n+    {\n+    case PartitionCommand::Type::ATTACH_PARTITION:\n+        if (part)\n+            return \"ATTACH PART\";\n+        else\n+            return \"ATTACH PARTITION\";\n+    case PartitionCommand::Type::MOVE_PARTITION:\n+        return \"MOVE PARTITION\";\n+    case PartitionCommand::Type::DROP_PARTITION:\n+        if (detach)\n+            return \"DETACH PARTITION\";\n+        else\n+            return \"DROP PARTITION\";\n+    case PartitionCommand::Type::DROP_DETACHED_PARTITION:\n+        if (part)\n+            return \"DROP DETACHED PART\";\n+        else\n+            return \"DROP DETACHED PARTITION\";\n+    case PartitionCommand::Type::FETCH_PARTITION:\n+        return \"FETCH PARTITION\";\n+    case PartitionCommand::Type::FREEZE_ALL_PARTITIONS:\n+        return \"FREEZE ALL\";\n+    case PartitionCommand::Type::FREEZE_PARTITION:\n+        return \"FREEZE PARTITION\";\n+    case PartitionCommand::Type::REPLACE_PARTITION:\n+        return \"REPLACE PARTITION\";\n+    }\n+    __builtin_unreachable();\n+}\n+\n+Pipes convertCommandsResultToSource(const PartitionCommandsResultInfo & commands_result)\n+{\n+    Block header {\n+         ColumnWithTypeAndName(std::make_shared<DataTypeString>(), \"command_type\"),\n+         ColumnWithTypeAndName(std::make_shared<DataTypeString>(), \"partition_id\"),\n+         ColumnWithTypeAndName(std::make_shared<DataTypeString>(), \"part_name\"),\n+    };\n+\n+    for (const auto & command_result : commands_result)\n+    {\n+        if (!command_result.old_part_name.empty() && !header.has(\"old_part_name\"))\n+            header.insert(ColumnWithTypeAndName(std::make_shared<DataTypeString>(), \"old_part_name\"));\n+\n+        if (!command_result.backup_name.empty() && !header.has(\"backup_name\"))\n+            header.insert(ColumnWithTypeAndName(std::make_shared<DataTypeString>(), \"backup_name\"));\n+\n+        if (!command_result.backup_path.empty() && !header.has(\"backup_path\"))\n+            header.insert(ColumnWithTypeAndName(std::make_shared<DataTypeString>(), \"backup_path\"));\n+    }\n+\n+    MutableColumns res_columns = header.cloneEmptyColumns();\n+\n+    for (const auto & command_result : commands_result)\n+    {\n+        res_columns[0]->insert(command_result.command_type);\n+        res_columns[1]->insert(command_result.partition_id);\n+        res_columns[2]->insert(command_result.part_name);\n+        if (header.has(\"old_part_name\"))\n+        {\n+            size_t pos = header.getPositionByName(\"old_part_name\");\n+            res_columns[pos]->insert(command_result.old_part_name);\n+        }\n+        if (header.has(\"backup_name\"))\n+        {\n+            size_t pos = header.getPositionByName(\"backup_name\");\n+            res_columns[pos]->insert(command_result.backup_name);\n+        }\n+        if (header.has(\"backup_path\"))\n+        {\n+            size_t pos = header.getPositionByName(\"backup_path\");\n+            res_columns[pos]->insert(command_result.backup_path);\n+        }\n+    }\n+\n+    Chunk chunk(std::move(res_columns), commands_result.size());\n+\n+    Pipe pipe(std::make_shared<SourceFromSingleChunk>(std::move(header), std::move(chunk)));\n+    Pipes result;\n+    result.emplace_back(std::move(pipe));\n+    return result;\n+}\n+\n }\ndiff --git a/src/Storages/PartitionCommands.h b/src/Storages/PartitionCommands.h\nindex 74c25e26a0c8..9f5540fdbdf7 100644\n--- a/src/Storages/PartitionCommands.h\n+++ b/src/Storages/PartitionCommands.h\n@@ -14,6 +14,9 @@ namespace DB\n \n class ASTAlterCommand;\n \n+class Pipe;\n+using Pipes = std::vector<Pipe>;\n+\n struct PartitionCommand\n {\n     enum Type\n@@ -66,9 +69,39 @@ struct PartitionCommand\n     String move_destination_name;\n \n     static std::optional<PartitionCommand> parse(const ASTAlterCommand * command);\n+    /// Convert type of the command to string (use not only type, but also\n+    /// different flags)\n+    std::string typeToString() const;\n };\n \n using PartitionCommands = std::vector<PartitionCommand>;\n \n+/// Result of exectuin of a single partition commands. Partition commands quite\n+/// different, so some fields will be empty for some commands. Currently used in\n+/// ATTACH and FREEZE commands.\n+struct PartitionCommandResultInfo\n+{\n+    /// Command type, always filled\n+    String command_type;\n+    /// Partition id, always filled\n+    String partition_id;\n+    /// Part name, always filled\n+    String part_name;\n+    /// Part name in /detached directory, filled in ATTACH\n+    String old_part_name;\n+    /// Path to backup directory, filled in FREEZE\n+    String backup_path;\n+    /// Name of the backup (specified by user or increment value), filled in\n+    /// FREEZE\n+    String backup_name;\n+};\n+\n+using PartitionCommandsResultInfo = std::vector<PartitionCommandResultInfo>;\n+\n+/// Convert partition comands result to Source from single Chunk, which will be\n+/// used to print info to the user. Tries to create narrowest table for given\n+/// results. For example, if all commands were FREEZE commands, than\n+/// old_part_name column will be absent.\n+Pipes convertCommandsResultToSource(const PartitionCommandsResultInfo & commands_result);\n \n }\ndiff --git a/src/Storages/StorageMaterializedView.cpp b/src/Storages/StorageMaterializedView.cpp\nindex 9cbe06a37015..5fd1e7792e4a 100644\n--- a/src/Storages/StorageMaterializedView.cpp\n+++ b/src/Storages/StorageMaterializedView.cpp\n@@ -250,11 +250,11 @@ void StorageMaterializedView::checkAlterIsPossible(const AlterCommands & command\n     }\n }\n \n-void StorageMaterializedView::alterPartition(\n+Pipes StorageMaterializedView::alterPartition(\n     const ASTPtr & query, const StorageMetadataPtr & metadata_snapshot, const PartitionCommands & commands, const Context & context)\n {\n     checkStatementCanBeForwarded();\n-    getTargetTable()->alterPartition(query, metadata_snapshot, commands, context);\n+    return getTargetTable()->alterPartition(query, metadata_snapshot, commands, context);\n }\n \n void StorageMaterializedView::checkAlterPartitionIsPossible(\ndiff --git a/src/Storages/StorageMaterializedView.h b/src/Storages/StorageMaterializedView.h\nindex 2692880eb2c2..315d4cf01a21 100644\n--- a/src/Storages/StorageMaterializedView.h\n+++ b/src/Storages/StorageMaterializedView.h\n@@ -51,7 +51,7 @@ class StorageMaterializedView final : public ext::shared_ptr_helper<StorageMater\n \n     void checkAlterIsPossible(const AlterCommands & commands, const Settings & settings) const override;\n \n-    void alterPartition(const ASTPtr & query, const StorageMetadataPtr & metadata_snapshot, const PartitionCommands & commands, const Context & context) override;\n+    Pipes alterPartition(const ASTPtr & query, const StorageMetadataPtr & metadata_snapshot, const PartitionCommands & commands, const Context & context) override;\n \n     void checkAlterPartitionIsPossible(const PartitionCommands & commands, const StorageMetadataPtr & metadata_snapshot, const Settings & settings) const override;\n \ndiff --git a/src/Storages/StorageMergeTree.cpp b/src/Storages/StorageMergeTree.cpp\nindex eecde28b7bbe..067117de43af 100644\n--- a/src/Storages/StorageMergeTree.cpp\n+++ b/src/Storages/StorageMergeTree.cpp\n@@ -1007,24 +1007,29 @@ bool StorageMergeTree::optimize(\n     return true;\n }\n \n-void StorageMergeTree::alterPartition(\n-    const ASTPtr & query, const StorageMetadataPtr & metadata_snapshot, const PartitionCommands & commands, const Context & context)\n+Pipes StorageMergeTree::alterPartition(\n+    const ASTPtr & query,\n+    const StorageMetadataPtr & metadata_snapshot,\n+    const PartitionCommands & commands,\n+    const Context & query_context)\n {\n+    PartitionCommandsResultInfo result;\n     for (const PartitionCommand & command : commands)\n     {\n+        PartitionCommandsResultInfo current_command_results;\n         switch (command.type)\n         {\n             case PartitionCommand::DROP_PARTITION:\n                 checkPartitionCanBeDropped(command.partition);\n-                dropPartition(command.partition, command.detach, context);\n+                dropPartition(command.partition, command.detach, query_context);\n                 break;\n \n             case PartitionCommand::DROP_DETACHED_PARTITION:\n-                dropDetached(command.partition, command.part, context);\n+                dropDetached(command.partition, command.part, query_context);\n                 break;\n \n             case PartitionCommand::ATTACH_PARTITION:\n-                attachPartition(command.partition, command.part, context);\n+                current_command_results = attachPartition(command.partition, command.part, query_context);\n                 break;\n \n             case PartitionCommand::MOVE_PARTITION:\n@@ -1032,18 +1037,18 @@ void StorageMergeTree::alterPartition(\n                 switch (*command.move_destination_type)\n                 {\n                     case PartitionCommand::MoveDestinationType::DISK:\n-                        movePartitionToDisk(command.partition, command.move_destination_name, command.part, context);\n+                        movePartitionToDisk(command.partition, command.move_destination_name, command.part, query_context);\n                         break;\n \n                     case PartitionCommand::MoveDestinationType::VOLUME:\n-                        movePartitionToVolume(command.partition, command.move_destination_name, command.part, context);\n+                        movePartitionToVolume(command.partition, command.move_destination_name, command.part, query_context);\n                         break;\n \n                     case PartitionCommand::MoveDestinationType::TABLE:\n                         checkPartitionCanBeDropped(command.partition);\n-                        String dest_database = context.resolveDatabase(command.to_database);\n-                        auto dest_storage = DatabaseCatalog::instance().getTable({dest_database, command.to_table}, context);\n-                        movePartitionToTable(dest_storage, command.partition, context);\n+                        String dest_database = query_context.resolveDatabase(command.to_database);\n+                        auto dest_storage = DatabaseCatalog::instance().getTable({dest_database, command.to_table}, query_context);\n+                        movePartitionToTable(dest_storage, command.partition, query_context);\n                         break;\n                 }\n \n@@ -1053,30 +1058,39 @@ void StorageMergeTree::alterPartition(\n             case PartitionCommand::REPLACE_PARTITION:\n             {\n                 checkPartitionCanBeDropped(command.partition);\n-                String from_database = context.resolveDatabase(command.from_database);\n-                auto from_storage = DatabaseCatalog::instance().getTable({from_database, command.from_table}, context);\n-                replacePartitionFrom(from_storage, command.partition, command.replace, context);\n+                String from_database = query_context.resolveDatabase(command.from_database);\n+                auto from_storage = DatabaseCatalog::instance().getTable({from_database, command.from_table}, query_context);\n+                replacePartitionFrom(from_storage, command.partition, command.replace, query_context);\n             }\n             break;\n \n             case PartitionCommand::FREEZE_PARTITION:\n             {\n-                auto lock = lockForShare(context.getCurrentQueryId(), context.getSettingsRef().lock_acquire_timeout);\n-                freezePartition(command.partition, metadata_snapshot, command.with_name, context, lock);\n+                auto lock = lockForShare(query_context.getCurrentQueryId(), query_context.getSettingsRef().lock_acquire_timeout);\n+                current_command_results = freezePartition(command.partition, metadata_snapshot, command.with_name, query_context, lock);\n             }\n             break;\n \n             case PartitionCommand::FREEZE_ALL_PARTITIONS:\n             {\n-                auto lock = lockForShare(context.getCurrentQueryId(), context.getSettingsRef().lock_acquire_timeout);\n-                freezeAll(command.with_name, metadata_snapshot, context, lock);\n+                auto lock = lockForShare(query_context.getCurrentQueryId(), query_context.getSettingsRef().lock_acquire_timeout);\n+                current_command_results = freezeAll(command.with_name, metadata_snapshot, query_context, lock);\n             }\n             break;\n \n             default:\n-                IStorage::alterPartition(query, metadata_snapshot, commands, context); // should throw an exception.\n+                IStorage::alterPartition(query, metadata_snapshot, commands, query_context); // should throw an exception.\n         }\n+\n+        for (auto & command_result : current_command_results)\n+            command_result.command_type = command.typeToString();\n+        result.insert(result.end(), current_command_results.begin(), current_command_results.end());\n     }\n+\n+    if (query_context.getSettingsRef().alter_partition_verbose_result)\n+        return convertCommandsResultToSource(result);\n+\n+    return { };\n }\n \n void StorageMergeTree::dropPartition(const ASTPtr & partition, bool detach, const Context & context)\n@@ -1114,24 +1128,32 @@ void StorageMergeTree::dropPartition(const ASTPtr & partition, bool detach, cons\n }\n \n \n-void StorageMergeTree::attachPartition(\n+PartitionCommandsResultInfo  StorageMergeTree::attachPartition(\n     const ASTPtr & partition, bool attach_part, const Context & context)\n {\n-    // TODO: should get some locks to prevent race with 'alter \u2026 modify column'\n-\n+    PartitionCommandsResultInfo results;\n     PartsTemporaryRename renamed_parts(*this, \"detached/\");\n     MutableDataPartsVector loaded_parts = tryLoadPartsToAttach(partition, attach_part, context, renamed_parts);\n \n     for (size_t i = 0; i < loaded_parts.size(); ++i)\n     {\n         LOG_INFO(log, \"Attaching part {} from {}\", loaded_parts[i]->name, renamed_parts.old_and_new_names[i].second);\n+        String old_name = renamed_parts.old_and_new_names[i].first;\n         renameTempPartAndAdd(loaded_parts[i], &increment);\n         renamed_parts.old_and_new_names[i].first.clear();\n+\n+        results.push_back(PartitionCommandResultInfo{\n+            .partition_id = loaded_parts[i]->info.partition_id,\n+            .part_name = loaded_parts[i]->name,\n+            .old_part_name = old_name,\n+        });\n+\n         LOG_INFO(log, \"Finished attaching part\");\n     }\n \n     /// New parts with other data may appear in place of deleted parts.\n     context.dropCaches();\n+    return results;\n }\n \n void StorageMergeTree::replacePartitionFrom(const StoragePtr & source_table, const ASTPtr & partition, bool replace, const Context & context)\ndiff --git a/src/Storages/StorageMergeTree.h b/src/Storages/StorageMergeTree.h\nindex c80c9f443778..fb191f14c540 100644\n--- a/src/Storages/StorageMergeTree.h\n+++ b/src/Storages/StorageMergeTree.h\n@@ -61,7 +61,7 @@ class StorageMergeTree final : public ext::shared_ptr_helper<StorageMergeTree>,\n         bool deduplicate,\n         const Context & context) override;\n \n-    void alterPartition(\n+    Pipes alterPartition(\n         const ASTPtr & query,\n         const StorageMetadataPtr & /* metadata_snapshot */,\n         const PartitionCommands & commands,\n@@ -149,7 +149,8 @@ class StorageMergeTree final : public ext::shared_ptr_helper<StorageMergeTree>,\n \n     // Partition helpers\n     void dropPartition(const ASTPtr & partition, bool detach, const Context & context);\n-    void attachPartition(const ASTPtr & partition, bool part, const Context & context);\n+    PartitionCommandsResultInfo attachPartition(const ASTPtr & partition, bool part, const Context & context);\n+\n     void replacePartitionFrom(const StoragePtr & source_table, const ASTPtr & partition, bool replace, const Context & context);\n     void movePartitionToTable(const StoragePtr & dest_table, const ASTPtr & partition, const Context & context);\n     bool partIsAssignedToBackgroundOperation(const DataPartPtr & part) const override;\ndiff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp\nindex c6dc3e67b807..7a0b86347d07 100644\n--- a/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -3851,14 +3851,16 @@ void StorageReplicatedMergeTree::alter(\n     }\n }\n \n-void StorageReplicatedMergeTree::alterPartition(\n+Pipes StorageReplicatedMergeTree::alterPartition(\n     const ASTPtr & query,\n     const StorageMetadataPtr & metadata_snapshot,\n     const PartitionCommands & commands,\n     const Context & query_context)\n {\n+    PartitionCommandsResultInfo result;\n     for (const PartitionCommand & command : commands)\n     {\n+        PartitionCommandsResultInfo current_command_results;\n         switch (command.type)\n         {\n             case PartitionCommand::DROP_PARTITION:\n@@ -3871,7 +3873,7 @@ void StorageReplicatedMergeTree::alterPartition(\n                 break;\n \n             case PartitionCommand::ATTACH_PARTITION:\n-                attachPartition(command.partition, metadata_snapshot, command.part, query_context);\n+                current_command_results = attachPartition(command.partition, metadata_snapshot, command.part, query_context);\n                 break;\n             case PartitionCommand::MOVE_PARTITION:\n             {\n@@ -3911,18 +3913,26 @@ void StorageReplicatedMergeTree::alterPartition(\n             case PartitionCommand::FREEZE_PARTITION:\n             {\n                 auto lock = lockForShare(query_context.getCurrentQueryId(), query_context.getSettingsRef().lock_acquire_timeout);\n-                freezePartition(command.partition, metadata_snapshot, command.with_name, query_context, lock);\n+                current_command_results = freezePartition(command.partition, metadata_snapshot, command.with_name, query_context, lock);\n             }\n             break;\n \n             case PartitionCommand::FREEZE_ALL_PARTITIONS:\n             {\n                 auto lock = lockForShare(query_context.getCurrentQueryId(), query_context.getSettingsRef().lock_acquire_timeout);\n-                freezeAll(command.with_name, metadata_snapshot, query_context, lock);\n+                current_command_results = freezeAll(command.with_name, metadata_snapshot, query_context, lock);\n             }\n             break;\n         }\n+        for (auto & command_result : current_command_results)\n+            command_result.command_type = command.typeToString();\n+        result.insert(result.end(), current_command_results.begin(), current_command_results.end());\n     }\n+\n+    if (query_context.getSettingsRef().alter_partition_verbose_result)\n+        return convertCommandsResultToSource(result);\n+\n+    return {};\n }\n \n \n@@ -4028,12 +4038,15 @@ void StorageReplicatedMergeTree::truncate(\n }\n \n \n-void StorageReplicatedMergeTree::attachPartition(const ASTPtr & partition, const StorageMetadataPtr & metadata_snapshot, bool attach_part, const Context & query_context)\n+PartitionCommandsResultInfo StorageReplicatedMergeTree::attachPartition(\n+    const ASTPtr & partition,\n+    const StorageMetadataPtr & metadata_snapshot,\n+    bool attach_part,\n+    const Context & query_context)\n {\n-    // TODO: should get some locks to prevent race with 'alter \u2026 modify column'\n-\n     assertNotReadonly();\n \n+    PartitionCommandsResultInfo results;\n     PartsTemporaryRename renamed_parts(*this, \"detached/\");\n     MutableDataPartsVector loaded_parts = tryLoadPartsToAttach(partition, attach_part, query_context, renamed_parts);\n \n@@ -4044,7 +4057,13 @@ void StorageReplicatedMergeTree::attachPartition(const ASTPtr & partition, const\n         output.writeExistingPart(loaded_parts[i]);\n         renamed_parts.old_and_new_names[i].first.clear();\n         LOG_DEBUG(log, \"Attached part {} as {}\", old_name, loaded_parts[i]->name);\n+        results.push_back(PartitionCommandResultInfo{\n+            .partition_id = loaded_parts[i]->info.partition_id,\n+            .part_name = loaded_parts[i]->name,\n+            .old_part_name = old_name,\n+        });\n     }\n+    return results;\n }\n \n \ndiff --git a/src/Storages/StorageReplicatedMergeTree.h b/src/Storages/StorageReplicatedMergeTree.h\nindex f6690051ad6e..84fbae73fa57 100644\n--- a/src/Storages/StorageReplicatedMergeTree.h\n+++ b/src/Storages/StorageReplicatedMergeTree.h\n@@ -111,7 +111,7 @@ class StorageReplicatedMergeTree final : public ext::shared_ptr_helper<StorageRe\n \n     void alter(const AlterCommands & params, const Context & query_context, TableLockHolder & table_lock_holder) override;\n \n-    void alterPartition(\n+    Pipes alterPartition(\n         const ASTPtr & query,\n         const StorageMetadataPtr & metadata_snapshot,\n         const PartitionCommands & commands,\n@@ -534,7 +534,7 @@ class StorageReplicatedMergeTree final : public ext::shared_ptr_helper<StorageRe\n \n     // Partition helpers\n     void dropPartition(const ASTPtr & query, const ASTPtr & partition, bool detach, const Context & query_context);\n-    void attachPartition(const ASTPtr & partition, const StorageMetadataPtr & metadata_snapshot, bool part, const Context & query_context);\n+    PartitionCommandsResultInfo attachPartition(const ASTPtr & partition, const StorageMetadataPtr & metadata_snapshot, bool part, const Context & query_context);\n     void replacePartitionFrom(const StoragePtr & source_table, const ASTPtr & partition, bool replace, const Context & query_context);\n     void movePartitionToTable(const StoragePtr & dest_table, const ASTPtr & partition, const Context & query_context);\n     void fetchPartition(const ASTPtr & partition, const StorageMetadataPtr & metadata_snapshot, const String & from, const Context & query_context);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01417_freeze_partition_verbose.reference b/tests/queries/0_stateless/01417_freeze_partition_verbose.reference\nnew file mode 100644\nindex 000000000000..a3be410532ba\n--- /dev/null\n+++ b/tests/queries/0_stateless/01417_freeze_partition_verbose.reference\n@@ -0,0 +1,18 @@\n+command_type\tpartition_id\tpart_name\tbackup_name\tbackup_path\n+FREEZE ALL\t0\t0_1_1_0\ttest_01417\tshadow/test_01417/\n+FREEZE ALL\t1\t1_2_2_0\ttest_01417\tshadow/test_01417/\n+FREEZE ALL\t2\t2_3_3_0\ttest_01417\tshadow/test_01417/\n+FREEZE ALL\t3\t3_4_4_0\ttest_01417\tshadow/test_01417/\n+FREEZE ALL\t4\t4_5_5_0\ttest_01417\tshadow/test_01417/\n+FREEZE ALL\t5\t5_6_6_0\ttest_01417\tshadow/test_01417/\n+FREEZE ALL\t6\t6_7_7_0\ttest_01417\tshadow/test_01417/\n+FREEZE ALL\t7\t7_8_8_0\ttest_01417\tshadow/test_01417/\n+FREEZE ALL\t8\t8_9_9_0\ttest_01417\tshadow/test_01417/\n+FREEZE ALL\t9\t9_10_10_0\ttest_01417\tshadow/test_01417/\n+command_type\tpartition_id\tpart_name\tbackup_name\tbackup_path\n+FREEZE PARTITION\t3\t3_4_4_0\ttest_01417_single_part\tshadow/test_01417_single_part/\n+command_type\tpartition_id\tpart_name\told_part_name\n+ATTACH PARTITION\t3\t3_12_12_0\t3_4_4_0\n+command_type\tpartition_id\tpart_name\tbackup_name\tbackup_path\told_part_name\n+FREEZE PARTITION\t7\t7_8_8_0\ttest_01417_single_part_7\tshadow/test_01417_single_part_7/\t\n+ATTACH PART\t5\t5_13_13_0\t\t\t5_6_6_0\ndiff --git a/tests/queries/0_stateless/01417_freeze_partition_verbose.sql b/tests/queries/0_stateless/01417_freeze_partition_verbose.sql\nnew file mode 100644\nindex 000000000000..176093b43239\n--- /dev/null\n+++ b/tests/queries/0_stateless/01417_freeze_partition_verbose.sql\n@@ -0,0 +1,28 @@\n+DROP TABLE IF EXISTS table_for_freeze;\n+\n+CREATE TABLE table_for_freeze\n+(\n+  key UInt64,\n+  value String\n+)\n+ENGINE = MergeTree()\n+ORDER BY key\n+PARTITION BY key % 10;\n+\n+INSERT INTO table_for_freeze SELECT number, toString(number) from numbers(10);\n+\n+ALTER TABLE table_for_freeze FREEZE WITH NAME 'test_01417' FORMAT TSVWithNames SETTINGS alter_partition_verbose_result = 1;\n+\n+ALTER TABLE table_for_freeze FREEZE PARTITION '3' WITH NAME 'test_01417_single_part' FORMAT TSVWithNames SETTINGS alter_partition_verbose_result = 1;\n+\n+ALTER TABLE table_for_freeze DETACH PARTITION '3';\n+\n+INSERT INTO table_for_freeze VALUES (3, '3');\n+\n+ALTER TABLE table_for_freeze ATTACH PARTITION '3' FORMAT TSVWithNames SETTINGS alter_partition_verbose_result = 1;\n+\n+ALTER TABLE table_for_freeze DETACH PARTITION '5';\n+\n+ALTER TABLE table_for_freeze FREEZE PARTITION '7' WITH NAME 'test_01417_single_part_7', ATTACH PART '5_6_6_0' FORMAT TSVWithNames SETTINGS alter_partition_verbose_result = 1;\n+\n+DROP TABLE IF EXISTS table_for_freeze;\ndiff --git a/tests/queries/0_stateless/01417_freeze_partition_verbose_zookeeper.reference b/tests/queries/0_stateless/01417_freeze_partition_verbose_zookeeper.reference\nnew file mode 100644\nindex 000000000000..7fea72f847df\n--- /dev/null\n+++ b/tests/queries/0_stateless/01417_freeze_partition_verbose_zookeeper.reference\n@@ -0,0 +1,18 @@\n+command_type\tpartition_id\tpart_name\tbackup_name\tbackup_path\n+FREEZE ALL\t0\t0_0_0_0\ttest_01417\tshadow/test_01417/\n+FREEZE ALL\t1\t1_0_0_0\ttest_01417\tshadow/test_01417/\n+FREEZE ALL\t2\t2_0_0_0\ttest_01417\tshadow/test_01417/\n+FREEZE ALL\t3\t3_0_0_0\ttest_01417\tshadow/test_01417/\n+FREEZE ALL\t4\t4_0_0_0\ttest_01417\tshadow/test_01417/\n+FREEZE ALL\t5\t5_0_0_0\ttest_01417\tshadow/test_01417/\n+FREEZE ALL\t6\t6_0_0_0\ttest_01417\tshadow/test_01417/\n+FREEZE ALL\t7\t7_0_0_0\ttest_01417\tshadow/test_01417/\n+FREEZE ALL\t8\t8_0_0_0\ttest_01417\tshadow/test_01417/\n+FREEZE ALL\t9\t9_0_0_0\ttest_01417\tshadow/test_01417/\n+command_type\tpartition_id\tpart_name\tbackup_name\tbackup_path\n+FREEZE PARTITION\t3\t3_0_0_0\ttest_01417_single_part\tshadow/test_01417_single_part/\n+command_type\tpartition_id\tpart_name\told_part_name\n+ATTACH PARTITION\t3\t3_3_3_0\t3_0_0_0\n+command_type\tpartition_id\tpart_name\tbackup_name\tbackup_path\told_part_name\n+FREEZE PARTITION\t7\t7_0_0_0\ttest_01417_single_part_7\tshadow/test_01417_single_part_7/\t\n+ATTACH PART\t5\t5_2_2_0\t\t\t5_0_0_0\ndiff --git a/tests/queries/0_stateless/01417_freeze_partition_verbose_zookeeper.sql b/tests/queries/0_stateless/01417_freeze_partition_verbose_zookeeper.sql\nnew file mode 100644\nindex 000000000000..4947d0c9fd82\n--- /dev/null\n+++ b/tests/queries/0_stateless/01417_freeze_partition_verbose_zookeeper.sql\n@@ -0,0 +1,28 @@\n+DROP TABLE IF EXISTS table_for_freeze_replicated;\n+\n+CREATE TABLE table_for_freeze_replicated\n+(\n+  key UInt64,\n+  value String\n+)\n+ENGINE = ReplicatedMergeTree('/test/table_for_freeze_replicated', '1')\n+ORDER BY key\n+PARTITION BY key % 10;\n+\n+INSERT INTO table_for_freeze_replicated SELECT number, toString(number) from numbers(10);\n+\n+ALTER TABLE table_for_freeze_replicated FREEZE WITH NAME 'test_01417' FORMAT TSVWithNames SETTINGS alter_partition_verbose_result = 1;\n+\n+ALTER TABLE table_for_freeze_replicated FREEZE PARTITION '3' WITH NAME 'test_01417_single_part' FORMAT TSVWithNames SETTINGS alter_partition_verbose_result = 1;\n+\n+ALTER TABLE table_for_freeze_replicated DETACH PARTITION '3';\n+\n+INSERT INTO table_for_freeze_replicated VALUES (3, '3');\n+\n+ALTER TABLE table_for_freeze_replicated ATTACH PARTITION '3' FORMAT TSVWithNames SETTINGS alter_partition_verbose_result = 1;\n+\n+ALTER TABLE table_for_freeze_replicated DETACH PARTITION '5';\n+\n+ALTER TABLE table_for_freeze_replicated FREEZE PARTITION '7' WITH NAME 'test_01417_single_part_7', ATTACH PART '5_0_0_0' FORMAT TSVWithNames SETTINGS alter_partition_verbose_result = 1;\n+\n+DROP TABLE IF EXISTS table_for_freeze_replicated;\n",
  "problem_statement": "FREEZE TABLE syntax returning snapshot details\nI hereby agree to the terms of the CLA available at: https://yandex.ru/legal/cla/?lang=en\r\n\r\nChangelog category (leave one):\r\n- New Feature\r\n\r\nChangelog entry (up to few sentences, required except for Non-significant/Documentation categories):\r\n\r\n`FREEZE TABLE [db.]name [PARTITION partition_expr] [WITH NAME custom_dir]`\r\n\r\n\r\nDetailed description (optional):\r\n\r\n```sql\r\nFREEZE TABLE system.query_log\r\n\r\n\u250c\u2500backup_name\u2500\u252c\u2500partition\u2500\u252c\u2500partition_id\u2500\u252c\u2500part_name\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500backup_path\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 5           \u2502 201912    \u2502 201912       \u2502 201912_1_10_2  \u2502 /home/nv/clickhouse-testbed/srv2/data/shadow/5/data/system/query_log/201912_1_10_2  \u2502\r\n\u2502 5           \u2502 201912    \u2502 201912       \u2502 201912_11_11_0 \u2502 /home/nv/clickhouse-testbed/srv2/data/shadow/5/data/system/query_log/201912_11_11_0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n2 rows in set. Elapsed: 0.007 sec.\r\n```\r\n\r\nCloses #7785.\r\n\n",
  "hints_text": "CI is hibernating?\nI'll avoid rebasing this until it gets a green light, did it too many times already.\nWe decided to go this way: https://github.com/ClickHouse/ClickHouse/pull/8076#pullrequestreview-389025609",
  "created_at": "2020-07-28T15:12:55Z"
}