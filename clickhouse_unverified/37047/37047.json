{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 37047,
  "instance_id": "ClickHouse__ClickHouse-37047",
  "issue_numbers": [
    "36792"
  ],
  "base_commit": "b647f8f9bf492728cf43a7fb5a70d5d6ac641c3a",
  "patch": "diff --git a/src/Interpreters/InterpreterInsertQuery.cpp b/src/Interpreters/InterpreterInsertQuery.cpp\nindex 8408b0ac5fcb..5c91b41845b9 100644\n--- a/src/Interpreters/InterpreterInsertQuery.cpp\n+++ b/src/Interpreters/InterpreterInsertQuery.cpp\n@@ -2,6 +2,7 @@\n \n #include <Access/Common/AccessFlags.h>\n #include <Access/EnabledQuota.h>\n+#include <AggregateFunctions/AggregateFunctionFactory.h>\n #include <Columns/ColumnNullable.h>\n #include <Processors/Transforms/buildPushingToViewsChain.h>\n #include <DataTypes/DataTypeNullable.h>\n@@ -153,7 +154,18 @@ Block InterpreterInsertQuery::getSampleBlock(\n     return res;\n }\n \n+static bool hasAggregateFunctions(const IAST * ast)\n+{\n+    if (const auto * func = typeid_cast<const ASTFunction *>(ast))\n+        if (AggregateFunctionFactory::instance().isAggregateFunctionName(func->name))\n+            return true;\n+\n+    for (const auto & child : ast->children)\n+        if (hasAggregateFunctions(child.get()))\n+            return true;\n \n+    return false;\n+}\n /** A query that just reads all data without any complex computations or filetering.\n   * If we just pipe the result to INSERT, we don't have to use too many threads for read.\n   */\n@@ -186,7 +198,8 @@ static bool isTrivialSelect(const ASTPtr & select)\n             && !select_query->groupBy()\n             && !select_query->having()\n             && !select_query->orderBy()\n-            && !select_query->limitBy());\n+            && !select_query->limitBy()\n+            && !hasAggregateFunctions(select_query));\n     }\n     /// This query is ASTSelectWithUnionQuery subquery\n     return false;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01119_optimize_trivial_insert_select.reference b/tests/queries/0_stateless/01119_optimize_trivial_insert_select.reference\nnew file mode 100644\nindex 000000000000..de22f396eaef\n--- /dev/null\n+++ b/tests/queries/0_stateless/01119_optimize_trivial_insert_select.reference\n@@ -0,0 +1,4 @@\n+1\t4999999950000000\t1\t1\n+2\t4999999950000000\t1\t1\n+3\t49999995000000\t1\t1\n+4\t49999995000000\t1\t1\ndiff --git a/tests/queries/0_stateless/01119_optimize_trivial_insert_select.sql b/tests/queries/0_stateless/01119_optimize_trivial_insert_select.sql\nnew file mode 100644\nindex 000000000000..7be0ffbcc8ea\n--- /dev/null\n+++ b/tests/queries/0_stateless/01119_optimize_trivial_insert_select.sql\n@@ -0,0 +1,11 @@\n+drop table if exists t;\n+create table t(n int, a Int64, s String) engine = MergeTree() order by a;\n+\n+insert into t select 1, sum(number) as c, getSetting('max_threads') from numbers_mt(100000000);\n+insert into t select 2, sum(number) as c, getSetting('max_threads') from numbers_mt(100000000) group by 1;\n+insert into t select 3, sum(number) as c, getSetting('max_threads') from numbers_mt(10000000) group by 3;\n+insert into t select 4, sum(number) as c, getSetting('max_threads') as mt from numbers_mt(10000000) group by mt;\n+\n+select n, a, s != '1', s = toString(getSetting('max_threads')) from t order by n;\n+\n+drop table t;\n",
  "problem_statement": "Optimization of trivial INSERT SELECT significantly slows down some queries\n\r\n**The creation of table becomes too slow when I use CTEs within the query.**\r\n\r\n***ClickHouse server version 22.4.3***\r\n\r\n**How to reproduce**\r\nTrying to create a table based on the result of a query, I take very bad performance when I use a CTE:\r\n\r\n```\r\n--creation of table t and insertion of 10000000000 records\r\n--exec time: ~260 second\r\ndrop table if exists t;\r\ncreate table t(a Int64) engine = MergeTree() order by a;\r\ninsert into t SELECT * FROM system.numbers LIMIT 10000000000;\r\n\r\n\r\n--scenario 1 \r\n--exec time: ~200 seconds\r\ndrop table if exists t2;\r\ncreate table t2 engine = MergeTree() order by c\r\nas (\r\n\r\nwith\r\n\r\ncte1 as (\r\n  SELECT * FROM t WHERE modulo(a,2)=1\r\n)\r\n\r\nSELECT count(*) as c FROM cte1 \r\n\r\n);\r\n--end of scenario 1\r\n\r\n\r\n--scenario 2 \r\n--exec time: ~10 seconds\r\ndrop table if exists t3;\r\ncreate table t3 engine = MergeTree() order by c\r\nas (\r\n\r\n  SELECT count(*) as c FROM t WHERE modulo(a,2)=1\r\n\r\n);\r\n--end of scenario 2\r\n```\r\n\r\nAlthough the two scenarios do exactly the same thing, with the difference that in the first scenario we use an intermediate CTE, there is a huge difference in the execution time.\r\n\r\nThe issue becomes even stranger if you execute the following queries and see that the execution time is the same, that in generally makes sense.\r\n\r\n```\r\n--query from scenario 1 \r\n--exec time: ~9 seconds\r\nwith\r\n\r\ncte1 as (\r\n  SELECT * FROM t WHERE modulo(a,2)=1\r\n)\r\n\r\nSELECT count(*) as c FROM t WHERE modulo(a,2)=1\r\n\r\n\r\n--query from scenario 2\r\n--exec time: ~9 seconds\r\nSELECT count(*) as c FROM t WHERE modulo(a,2)=1\r\n```\r\n\r\nObviously, there is a performance issue when someone wants to `CREATE TABLE AS` and uses CTEs in the query.\r\n\r\nDoes anyone know why clickhouse behaves in that strange way? \r\n\r\n\n",
  "hints_text": "",
  "created_at": "2022-05-09T15:50:37Z",
  "modified_files": [
    "src/Interpreters/InterpreterInsertQuery.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01119_optimize_trivial_insert_select.reference",
    "b/tests/queries/0_stateless/01119_optimize_trivial_insert_select.sql"
  ]
}