{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 68989,
  "instance_id": "ClickHouse__ClickHouse-68989",
  "issue_numbers": [
    "61553"
  ],
  "base_commit": "9ab3ee1b1341c10ffd92b53719307d9539a52cd7",
  "patch": "diff --git a/docs/en/sql-reference/functions/array-functions.md b/docs/en/sql-reference/functions/array-functions.md\nindex 1b52440903de..e1516ae19d9d 100644\n--- a/docs/en/sql-reference/functions/array-functions.md\n+++ b/docs/en/sql-reference/functions/array-functions.md\n@@ -1717,6 +1717,24 @@ Result:\n [[1,1,2,3],[1,2,3,4]]\n ```\n \n+## arrayUnion(arr)\n+\n+Takes multiple arrays, returns an array that contains all elements that are present in any of the source arrays.\n+\n+Example:\n+```sql\n+SELECT\n+    arrayUnion([-2, 1], [10, 1], [-2], []) as num_example,\n+    arrayUnion(['hi'], [], ['hello', 'hi']) as str_example,\n+    arrayUnion([1, 3, NULL], [2, 3, NULL]) as null_example\n+```\n+\n+```text\n+\u250c\u2500num_example\u2500\u252c\u2500str_example\u2500\u2500\u2500\u2500\u252c\u2500null_example\u2500\u2510\n+\u2502 [10,-2,1]   \u2502 ['hello','hi'] \u2502 [3,2,1,NULL] \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## arrayIntersect(arr)\n \n Takes multiple arrays, returns an array with elements that are present in all source arrays.\ndiff --git a/src/Functions/array/arrayIntersect.cpp b/src/Functions/array/arrayIntersect.cpp\nindex 209441eb301d..316cc869ca10 100644\n--- a/src/Functions/array/arrayIntersect.cpp\n+++ b/src/Functions/array/arrayIntersect.cpp\n@@ -1,3 +1,4 @@\n+#include <type_traits>\n #include <Functions/IFunction.h>\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionHelpers.h>\n@@ -12,6 +13,7 @@\n #include <DataTypes/DataTypeNullable.h>\n #include <DataTypes/DataTypeTuple.h>\n #include <DataTypes/getMostSubtype.h>\n+#include <DataTypes/getLeastSupertype.h>\n #include <Columns/ColumnArray.h>\n #include <Columns/ColumnString.h>\n #include <Columns/ColumnFixedString.h>\n@@ -35,10 +37,21 @@ namespace ErrorCodes\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n }\n \n+struct ArrayModeIntersect\n+{\n+    static constexpr auto name = \"arrayIntersect\";\n+};\n+\n+struct ArrayModeUnion\n+{\n+    static constexpr auto name = \"arrayUnion\";\n+};\n+\n+template <typename Mode>\n class FunctionArrayIntersect : public IFunction\n {\n public:\n-    static constexpr auto name = \"arrayIntersect\";\n+    static constexpr auto name = Mode::name;\n     static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionArrayIntersect>(context); }\n     explicit FunctionArrayIntersect(ContextPtr context_) : context(context_) {}\n \n@@ -97,6 +110,9 @@ class FunctionArrayIntersect : public IFunction\n     template <typename Map, typename ColumnType, bool is_numeric_column>\n     static ColumnPtr execute(const UnpackedArrays & arrays, MutableColumnPtr result_data);\n \n+    template <typename Map, typename ColumnType, bool is_numeric_column>\n+    static void insertElement(typename Map::LookupResult & pair, size_t & result_offset, ColumnType & result_data, NullMap & null_map, const bool & use_null_map);\n+\n     struct NumberExecutor\n     {\n         const UnpackedArrays & arrays;\n@@ -124,13 +140,15 @@ class FunctionArrayIntersect : public IFunction\n     };\n };\n \n-\n-DataTypePtr FunctionArrayIntersect::getReturnTypeImpl(const DataTypes & arguments) const\n+template <typename Mode>\n+DataTypePtr FunctionArrayIntersect<Mode>::getReturnTypeImpl(const DataTypes & arguments) const\n {\n     DataTypes nested_types;\n     nested_types.reserve(arguments.size());\n \n     bool has_nothing = false;\n+    DataTypePtr has_decimal_type = nullptr;\n+    DataTypePtr has_non_decimal_type = nullptr;\n \n     if (arguments.empty())\n         throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Function {} requires at least one argument.\", getName());\n@@ -146,23 +164,49 @@ DataTypePtr FunctionArrayIntersect::getReturnTypeImpl(const DataTypes & argument\n         const auto & nested_type = array_type->getNestedType();\n \n         if (typeid_cast<const DataTypeNothing *>(nested_type.get()))\n-            has_nothing = true;\n+        {\n+            if constexpr (std::is_same_v<Mode, ArrayModeIntersect>)\n+            {\n+                has_nothing = true;\n+                break;\n+            }\n+        }\n         else\n+        {\n             nested_types.push_back(nested_type);\n+\n+            /// Throw exception if have a decimal and another type (e.g int/date type)\n+            /// This is the same behavior as the arrayIntersect and notEquals functions\n+            /// This case is not covered by getLeastSupertype() and results in crashing the program if left out\n+            if constexpr (std::is_same_v<Mode, ArrayModeUnion>)\n+            {\n+                if (WhichDataType(nested_type).isDecimal())\n+                    has_decimal_type = nested_type;\n+                else\n+                    has_non_decimal_type = nested_type;\n+\n+                if (has_non_decimal_type && has_decimal_type)\n+                    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal types of arguments for function {}: {} and {}.\",\n+                                    getName(), has_non_decimal_type->getName(), has_decimal_type);\n+            }\n+        }\n     }\n \n     DataTypePtr result_type;\n \n-    if (!nested_types.empty())\n-        result_type = getMostSubtype(nested_types, true);\n-\n-    if (has_nothing)\n+    // If any DataTypeNothing in ArrayModeIntersect or all arrays in ArrayModeUnion are DataTypeNothing\n+    if (has_nothing || nested_types.empty())\n         result_type = std::make_shared<DataTypeNothing>();\n+    else if constexpr (std::is_same_v<Mode, ArrayModeIntersect>)\n+        result_type = getMostSubtype(nested_types, true);\n+    else\n+        result_type = getLeastSupertype(nested_types);\n \n     return std::make_shared<DataTypeArray>(result_type);\n }\n \n-ColumnPtr FunctionArrayIntersect::castRemoveNullable(const ColumnPtr & column, const DataTypePtr & data_type) const\n+template <typename Mode>\n+ColumnPtr FunctionArrayIntersect<Mode>::castRemoveNullable(const ColumnPtr & column, const DataTypePtr & data_type) const\n {\n     if (const auto * column_nullable = checkAndGetColumn<ColumnNullable>(column.get()))\n     {\n@@ -208,7 +252,8 @@ ColumnPtr FunctionArrayIntersect::castRemoveNullable(const ColumnPtr & column, c\n     return column;\n }\n \n-FunctionArrayIntersect::CastArgumentsResult FunctionArrayIntersect::castColumns(\n+template <typename Mode>\n+FunctionArrayIntersect<Mode>::CastArgumentsResult FunctionArrayIntersect<Mode>::castColumns(\n     const ColumnsWithTypeAndName & arguments, const DataTypePtr & return_type, const DataTypePtr & return_type_with_nulls)\n {\n     size_t num_args = arguments.size();\n@@ -294,7 +339,8 @@ static ColumnPtr callFunctionNotEquals(ColumnWithTypeAndName first, ColumnWithTy\n     return eq_func->execute(args, eq_func->getResultType(), args.front().column->size());\n }\n \n-FunctionArrayIntersect::UnpackedArrays FunctionArrayIntersect::prepareArrays(\n+template <typename Mode>\n+FunctionArrayIntersect<Mode>::UnpackedArrays FunctionArrayIntersect<Mode>::prepareArrays(\n     const ColumnsWithTypeAndName & columns, ColumnsWithTypeAndName & initial_columns) const\n {\n     UnpackedArrays arrays;\n@@ -384,7 +430,8 @@ FunctionArrayIntersect::UnpackedArrays FunctionArrayIntersect::prepareArrays(\n     return arrays;\n }\n \n-ColumnPtr FunctionArrayIntersect::executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const\n+template <typename Mode>\n+ColumnPtr FunctionArrayIntersect<Mode>::executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const\n {\n     const auto * return_type_array = checkAndGetDataType<DataTypeArray>(result_type.get());\n \n@@ -402,7 +449,12 @@ ColumnPtr FunctionArrayIntersect::executeImpl(const ColumnsWithTypeAndName & arg\n     for (size_t i = 0; i < num_args; ++i)\n         data_types.push_back(arguments[i].type);\n \n-    auto return_type_with_nulls = getMostSubtype(data_types, true, true);\n+    DataTypePtr return_type_with_nulls;\n+    if constexpr (std::is_same_v<Mode, ArrayModeIntersect>)\n+        return_type_with_nulls = getMostSubtype(data_types, true, true);\n+    else\n+        return_type_with_nulls = getLeastSupertype(data_types);\n+\n     auto casted_columns = castColumns(arguments, result_type, return_type_with_nulls);\n \n     UnpackedArrays arrays = prepareArrays(casted_columns.casted, casted_columns.initial);\n@@ -450,8 +502,9 @@ ColumnPtr FunctionArrayIntersect::executeImpl(const ColumnsWithTypeAndName & arg\n     return result_column;\n }\n \n+template <typename Mode>\n template <class T>\n-void FunctionArrayIntersect::NumberExecutor::operator()(TypeList<T>)\n+void FunctionArrayIntersect<Mode>::NumberExecutor::operator()(TypeList<T>)\n {\n     using Container = ClearableHashMapWithStackMemory<T, size_t, DefaultHash<T>,\n         INITIAL_SIZE_DEGREE>;\n@@ -460,8 +513,9 @@ void FunctionArrayIntersect::NumberExecutor::operator()(TypeList<T>)\n         result = execute<Container, ColumnVector<T>, true>(arrays, ColumnVector<T>::create());\n }\n \n+template <typename Mode>\n template <class T>\n-void FunctionArrayIntersect::DecimalExecutor::operator()(TypeList<T>)\n+void FunctionArrayIntersect<Mode>::DecimalExecutor::operator()(TypeList<T>)\n {\n     using Container = ClearableHashMapWithStackMemory<T, size_t, DefaultHash<T>,\n         INITIAL_SIZE_DEGREE>;\n@@ -471,13 +525,15 @@ void FunctionArrayIntersect::DecimalExecutor::operator()(TypeList<T>)\n             result = execute<Container, ColumnDecimal<T>, true>(arrays, ColumnDecimal<T>::create(0, decimal->getScale()));\n }\n \n+template <typename Mode>\n template <typename Map, typename ColumnType, bool is_numeric_column>\n-ColumnPtr FunctionArrayIntersect::execute(const UnpackedArrays & arrays, MutableColumnPtr result_data_ptr)\n+ColumnPtr FunctionArrayIntersect<Mode>::execute(const UnpackedArrays & arrays, MutableColumnPtr result_data_ptr)\n {\n     auto args = arrays.args.size();\n     auto rows = arrays.base_rows;\n \n     bool all_nullable = true;\n+    bool has_nullable = false;\n \n     std::vector<const ColumnType *> columns;\n     columns.reserve(args);\n@@ -493,6 +549,8 @@ ColumnPtr FunctionArrayIntersect::execute(const UnpackedArrays & arrays, Mutable\n \n         if (!arg.null_map)\n             all_nullable = false;\n+        else\n+            has_nullable = true;\n     }\n \n     auto & result_data = static_cast<ColumnType &>(*result_data_ptr);\n@@ -511,6 +569,7 @@ ColumnPtr FunctionArrayIntersect::execute(const UnpackedArrays & arrays, Mutable\n         map.clear();\n \n         bool all_has_nullable = all_nullable;\n+        bool has_a_null = false;\n         bool current_has_nullable = false;\n \n         for (size_t arg_num = 0; arg_num < args; ++arg_num)\n@@ -546,7 +605,7 @@ ColumnPtr FunctionArrayIntersect::execute(const UnpackedArrays & arrays, Mutable\n                     }\n \n                     /// Here we count the number of element appearances, but no more than once per array.\n-                    if (*value == arg_num)\n+                    if (*value <= arg_num)\n                         ++(*value);\n                 }\n             }\n@@ -561,77 +620,90 @@ ColumnPtr FunctionArrayIntersect::execute(const UnpackedArrays & arrays, Mutable\n             }\n             if (!current_has_nullable)\n                 all_has_nullable = false;\n+            else\n+                has_a_null = true;\n         }\n \n         // We have NULL in output only once if it should be there\n         bool null_added = false;\n-        const auto & arg = arrays.args[0];\n-        size_t off;\n-        // const array has only one row\n-        if (arg.is_const)\n-            off = (*arg.offsets)[0];\n-        else\n-            off = (*arg.offsets)[row];\n+        bool use_null_map;\n \n-        for (auto i : collections::range(prev_off[0], off))\n+        if constexpr (std::is_same_v<Mode, ArrayModeUnion>)\n         {\n-            all_has_nullable = all_nullable;\n-            typename Map::LookupResult pair = nullptr;\n-\n-            if (arg.null_map && (*arg.null_map)[i])\n+            use_null_map = has_nullable;\n+            for (auto & p : map)\n             {\n-                current_has_nullable = true;\n-                if (all_has_nullable && !null_added)\n+                typename Map::LookupResult pair = map.find(p.getKey());\n+                if (pair && pair->getMapped() >= 1)\n                 {\n-                    ++result_offset;\n-                    result_data.insertDefault();\n-                    null_map.push_back(1);\n-                    null_added = true;\n+                    insertElement<Map, ColumnType, is_numeric_column>(pair, result_offset, result_data, null_map, use_null_map);\n                 }\n-                if (null_added)\n-                    continue;\n             }\n-            else if constexpr (is_numeric_column)\n+            if (has_a_null && !null_added)\n             {\n-                pair = map.find(columns[0]->getElement(i));\n-            }\n-            else if constexpr (std::is_same_v<ColumnType, ColumnString> || std::is_same_v<ColumnType, ColumnFixedString>)\n-                pair = map.find(columns[0]->getDataAt(i));\n-            else\n-            {\n-                const char * data = nullptr;\n-                pair = map.find(columns[0]->serializeValueIntoArena(i, arena, data));\n+                ++result_offset;\n+                result_data.insertDefault();\n+                null_map.push_back(1);\n+                null_added = true;\n             }\n-            prev_off[0] = off;\n+        }\n+        else if constexpr (std::is_same_v<Mode, ArrayModeIntersect>)\n+        {\n+            use_null_map = all_nullable;\n+            const auto & arg = arrays.args[0];\n+            size_t off;\n+            // const array has only one row\n             if (arg.is_const)\n-                prev_off[0] = 0;\n-\n-            if (!current_has_nullable)\n-                all_has_nullable = false;\n+                off = (*arg.offsets)[0];\n+            else\n+                off = (*arg.offsets)[row];\n \n-            if (pair && pair->getMapped() == args)\n+            for (auto i : collections::range(prev_off[0], off))\n             {\n-                // We increase pair->getMapped() here to not skip duplicate values from the first array.\n-                ++pair->getMapped();\n-                ++result_offset;\n-                if constexpr (is_numeric_column)\n+                all_has_nullable = all_nullable;\n+                typename Map::LookupResult pair = nullptr;\n+\n+                if (arg.null_map && (*arg.null_map)[i])\n                 {\n-                    result_data.insertValue(pair->getKey());\n+                    current_has_nullable = true;\n+                    if (all_has_nullable && !null_added)\n+                    {\n+                        ++result_offset;\n+                        result_data.insertDefault();\n+                        null_map.push_back(1);\n+                        null_added = true;\n+                    }\n+                    if (null_added)\n+                        continue;\n                 }\n-                else if constexpr (std::is_same_v<ColumnType, ColumnString> || std::is_same_v<ColumnType, ColumnFixedString>)\n+                else if constexpr (is_numeric_column)\n                 {\n-                    result_data.insertData(pair->getKey().data, pair->getKey().size);\n+                    pair = map.find(columns[0]->getElement(i));\n                 }\n+                else if constexpr (std::is_same_v<ColumnType, ColumnString> || std::is_same_v<ColumnType, ColumnFixedString>)\n+                    pair = map.find(columns[0]->getDataAt(i));\n                 else\n                 {\n-                    std::ignore = result_data.deserializeAndInsertFromArena(pair->getKey().data);\n+                    const char * data = nullptr;\n+                    pair = map.find(columns[0]->serializeValueIntoArena(i, arena, data));\n+                }\n+                prev_off[0] = off;\n+                if (arg.is_const)\n+                    prev_off[0] = 0;\n+\n+                if (!current_has_nullable)\n+                    all_has_nullable = false;\n+\n+                // Add the value if all arrays have the value for intersect\n+                // or if there was at least one occurrence in all of the arrays for union\n+                if (pair && pair->getMapped() == args)\n+                {\n+                    insertElement<Map, ColumnType, is_numeric_column>(pair, result_offset, result_data, null_map, use_null_map);\n                 }\n-                if (all_nullable)\n-                    null_map.push_back(0);\n             }\n         }\n-        result_offsets.getElement(row) = result_offset;\n \n+        result_offsets.getElement(row) = result_offset;\n     }\n     ColumnPtr result_column = std::move(result_data_ptr);\n     if (all_nullable)\n@@ -640,10 +712,36 @@ ColumnPtr FunctionArrayIntersect::execute(const UnpackedArrays & arrays, Mutable\n \n }\n \n+template <typename Mode>\n+template <typename Map, typename ColumnType, bool is_numeric_column>\n+void FunctionArrayIntersect<Mode>::insertElement(typename Map::LookupResult & pair, size_t & result_offset, ColumnType & result_data, NullMap & null_map, const bool & use_null_map)\n+{\n+    pair->getMapped() = -1;\n+    ++result_offset;\n+    if constexpr (is_numeric_column)\n+    {\n+        result_data.insertValue(pair->getKey());\n+    }\n+    else if constexpr (std::is_same_v<ColumnType, ColumnString> || std::is_same_v<ColumnType, ColumnFixedString>)\n+    {\n+        result_data.insertData(pair->getKey().data, pair->getKey().size);\n+    }\n+    else\n+    {\n+        std::ignore = result_data.deserializeAndInsertFromArena(pair->getKey().data);\n+    }\n+    if (use_null_map)\n+        null_map.push_back(0);\n+}\n+\n+\n+using ArrayIntersect = FunctionArrayIntersect<ArrayModeIntersect>;\n+using ArrayUnion = FunctionArrayIntersect<ArrayModeUnion>;\n \n REGISTER_FUNCTION(ArrayIntersect)\n {\n-    factory.registerFunction<FunctionArrayIntersect>();\n+    factory.registerFunction<ArrayIntersect>();\n+    factory.registerFunction<ArrayUnion>();\n }\n \n }\ndiff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt\nindex 14b1d90c3193..cccfc0b38c79 100644\n--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt\n+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt\n@@ -1,4 +1,4 @@\n-personal_ws-1.1 en 2983\n+personal_ws-1.1 en 2984\n AArch\n ACLs\n ALTERs\n@@ -1206,6 +1206,7 @@ arraySort\n arraySplit\n arrayStringConcat\n arraySum\n+arrayUnion\n arrayUniq\n arrayWithConstant\n arrayZip\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\nindex 0980e25b70ff..fd0ab1c90453 100644\n--- a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\n+++ b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\n@@ -141,6 +141,7 @@ arraySort\n arraySplit\n arrayStringConcat\n arraySum\n+arrayUnion\n arrayUniq\n arrayWithConstant\n arrayZip\ndiff --git a/tests/queries/0_stateless/03224_arrayUnion.reference b/tests/queries/0_stateless/03224_arrayUnion.reference\nnew file mode 100644\nindex 000000000000..b900b6cdb0a0\n--- /dev/null\n+++ b/tests/queries/0_stateless/03224_arrayUnion.reference\n@@ -0,0 +1,43 @@\n+[1,2]\n+[1,2]\n+[1,2]\n+[1,2,3]\n+-------\n+[]\n+[1]\n+[1,2]\n+[1,2,3]\n+-------\n+[]\n+[1]\n+[1,2]\n+[1,2,3]\n+-------\n+[1,2]\n+[1,2]\n+[1,2]\n+[1,2,3]\n+-------\n+[1,2,3,4]\n+[1,2,3,4]\n+[1,2,3,4]\n+[1,2,3,4]\n+-------\n+[]\n+[]\n+[]\n+[]\n+-------\n+[-100,156]\n+-------\n+[-257,-100,1]\n+-------\n+['hello','hi']\n+-------\n+[1,2,3,NULL]\n+-------\n+[1,2,3,NULL]\n+-------\n+[1,2,3,4,5,10,20]\n+-------\n+[1,2,3]\ndiff --git a/tests/queries/0_stateless/03224_arrayUnion.sql b/tests/queries/0_stateless/03224_arrayUnion.sql\nnew file mode 100644\nindex 000000000000..dedbacad9062\n--- /dev/null\n+++ b/tests/queries/0_stateless/03224_arrayUnion.sql\n@@ -0,0 +1,38 @@\n+drop table if exists array_union;\n+\n+create table array_union (date Date, arr Array(UInt8)) engine=MergeTree partition by date order by date;\n+\n+insert into array_union values ('2019-01-01', [1,2,3]);\n+insert into array_union values ('2019-01-01', [1,2]);\n+insert into array_union values ('2019-01-01', [1]);\n+insert into array_union values ('2019-01-01', []);\n+\n+\n+select arraySort(arrayUnion(arr, [1,2])) from array_union order by arr;\n+select '-------';\n+select arraySort(arrayUnion(arr, [])) from array_union order by arr;\n+select '-------';\n+select arraySort(arrayUnion([], arr)) from array_union order by arr;\n+select '-------';\n+select arraySort(arrayUnion([1,2], arr)) from array_union order by arr;\n+select '-------';\n+select arraySort(arrayUnion([1,2], [1,2,3,4])) from array_union order by arr;\n+select '-------';\n+select arraySort(arrayUnion([], [])) from array_union order by arr;\n+\n+drop table if exists array_union;\n+\n+select '-------';\n+select arraySort(arrayUnion([-100], [156]));\n+select '-------';\n+select arraySort(arrayUnion([1], [-257, -100]));\n+select '-------';\n+select arraySort(arrayUnion(['hi'], ['hello', 'hi'], []));\n+select '-------';\n+SELECT arraySort(arrayUnion([1, 2, NULL], [1, 3, NULL], [2, 3, NULL]));\n+select '-------';\n+SELECT arraySort(arrayUnion([NULL, NULL, NULL, 1], [1, NULL, NULL], [1, 2, 3, NULL]));\n+select '-------';\n+SELECT arraySort(arrayUnion([1, 1, 1, 2, 3], [2, 2, 4], [5, 10, 20]));\n+select '-------';\n+SELECT arraySort(arrayUnion([1, 2], [1, 3], [])),\n",
  "problem_statement": "Add `arrayUnion` function\nBasically `arrayDistinct(arrayConcat(arr1, arr2, arr3, ...))`\r\n\r\nRelated function: [`arrayIntersect`](https://clickhouse.com/docs/en/sql-reference/functions/array-functions#arrayintersectarr)\n",
  "hints_text": "Hey @rschu1ze, I'd like to try fixing this issue. Can you assign it to me?\nCool, please go ahead, thanks.\n@rschu1ze Just wanted to confirm this before I start working to not miss anything.\r\n\r\nInitial Plan:\r\n- Add an `arrayUnion.cpp` file under `src/Functions/array` & implement the required function\r\n- Use the `tests/queries/0_stateless/add-test` script to generate a `.sql` & `.reference` file\r\n- Add tests in the generated `.sql` file & then update the reference file with:\r\n\t`clickhouse-client --multiquery < 0xxxx_arrayUnion.sql > 0xxxx_arrayUnion.reference`\r\n- Update `docs/en/sql-reference/functions/array-functions.md`\r\n- Update `utils/check-style/aspell-ignore/en/aspell-dict.txt`\n@tinfoil-knight The new function `arrayUnion` is conceptually similar to the existing function `arrayIntersect`. We should avoid to re-implement logic. Therefore, I'd suggest as first step to check `src/Functions/array/arrayIntersect.cpp` (possibly step through it using a debugger) which has a well-optimized implementation. As far as I see, most of the existing code also applies to `arrayUnion` and we only need to templatize `FunctionArrayIntersect::execute` (e.g. add a new template parameter `bool intersect` to distinguish `intersect` and `union` cases) and add a path under an `if constexpr` to it.\r\n\r\nThe other steps look good!\n@rschu1ze I'll work on this one\n@Blargian That's nice, I assigned you. Please ping me if you like me to have a look.\n@Blargian Are you still working on this? If not, I'd like to give it a shot.\n@petern48 please go ahead! I got distracted with another project.",
  "created_at": "2024-08-28T06:23:26Z"
}