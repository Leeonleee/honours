{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 75399,
  "instance_id": "ClickHouse__ClickHouse-75399",
  "issue_numbers": [
    "69922"
  ],
  "base_commit": "280ecea7c6e906888b0cb3bd3a84fa5c23a43cb9",
  "patch": "diff --git a/base/base/find_symbols.h b/base/base/find_symbols.h\nindex eb1290dd2894..ae6849c4fc16 100644\n--- a/base/base/find_symbols.h\n+++ b/base/base/find_symbols.h\n@@ -3,6 +3,7 @@\n #include <cstdint>\n #include <string>\n #include <array>\n+#include <string_view>\n \n #if defined(__SSE2__)\n     #include <emmintrin.h>\n@@ -51,7 +52,7 @@ struct SearchSymbols\n #if defined(__SSE4_2__)\n         if (str.size() > BUFFER_SIZE)\n         {\n-            throw std::runtime_error(\"SearchSymbols can contain at most \" + std::to_string(BUFFER_SIZE) + \" symbols and \" + std::to_string(str.size()) + \" was provided\\n\");\n+            throw std::runtime_error(\"SearchSymbols may contain at most \" + std::to_string(BUFFER_SIZE) + \" symbols but \" + std::to_string(str.size()) + \" symbols were provided\");\n         }\n \n         char tmp_safety_buffer[BUFFER_SIZE] = {0};\n@@ -236,6 +237,32 @@ inline const char * find_last_symbols_sse2(const char * const begin, const char\n     return return_mode == ReturnMode::End ? end : nullptr;\n }\n \n+template <bool positive, ReturnMode return_mode>\n+inline const char * find_last_symbols_sse2(const char * const begin, const char * const end, const char * symbols, size_t num_chars)\n+{\n+    const char * pos = end;\n+\n+#if defined(__SSE2__)\n+    const auto needles = mm_is_in_prepare(symbols, num_chars);\n+    for (; pos - 16 >= begin; pos -= 16)\n+    {\n+        __m128i bytes = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pos - 16));\n+\n+        __m128i eq = mm_is_in_execute(bytes, needles);\n+\n+        uint16_t bit_mask = maybe_negate<positive>(uint16_t(_mm_movemask_epi8(eq)));\n+        if (bit_mask)\n+            return pos - 1 - (__builtin_clz(bit_mask) - 16);    /// because __builtin_clz works with mask as uint32.\n+    }\n+#endif\n+\n+    --pos;\n+    for (; pos >= begin; --pos)\n+        if (maybe_negate<positive>(is_in(*pos, symbols, num_chars)))\n+            return pos;\n+\n+    return return_mode == ReturnMode::End ? end : nullptr;\n+}\n \n template <bool positive, ReturnMode return_mode, size_t num_chars,\n     char c01,     char c02 = 0, char c03 = 0, char c04 = 0,\n@@ -348,6 +375,19 @@ inline const char * find_first_symbols_dispatch(const std::string_view haystack,\n     return find_first_symbols_sse2<positive, return_mode>(haystack.begin(), haystack.end(), symbols.str.data(), symbols.str.size());\n }\n \n+template <bool positive, ReturnMode return_mode, char... symbols>\n+inline const char * find_last_symbols_dispatch(const char * begin, const char * end)\n+    requires(0 <= sizeof...(symbols) && sizeof...(symbols) <= 16)\n+{\n+    return find_last_symbols_sse2<positive, return_mode, symbols...>(begin, end);\n+}\n+\n+template <bool positive, ReturnMode return_mode>\n+inline const char * find_last_symbols_dispatch(const std::string_view haystack, const SearchSymbols & symbols)\n+{\n+    return find_last_symbols_sse2<positive, return_mode>(haystack.begin(), haystack.end(), symbols.str.data(), symbols.str.size());\n+}\n+\n }\n \n \n@@ -424,25 +464,35 @@ inline const char * find_first_not_symbols_or_null(std::string_view haystack, co\n template <char... symbols>\n inline const char * find_last_symbols_or_null(const char * begin, const char * end)\n {\n-    return detail::find_last_symbols_sse2<true, detail::ReturnMode::Nullptr, symbols...>(begin, end);\n+    return detail::find_last_symbols_dispatch<true, detail::ReturnMode::Nullptr, symbols...>(begin, end);\n }\n \n template <char... symbols>\n inline char * find_last_symbols_or_null(char * begin, char * end)\n {\n-    return const_cast<char *>(detail::find_last_symbols_sse2<true, detail::ReturnMode::Nullptr, symbols...>(begin, end));\n+    return const_cast<char *>(detail::find_last_symbols_dispatch<true, detail::ReturnMode::Nullptr, symbols...>(begin, end));\n+}\n+\n+inline const char * find_last_symbols_or_null(std::string_view haystack, const SearchSymbols & symbols)\n+{\n+    return detail::find_last_symbols_dispatch<true, detail::ReturnMode::Nullptr>(haystack, symbols);\n }\n \n template <char... symbols>\n inline const char * find_last_not_symbols_or_null(const char * begin, const char * end)\n {\n-    return detail::find_last_symbols_sse2<false, detail::ReturnMode::Nullptr, symbols...>(begin, end);\n+    return detail::find_last_symbols_dispatch<false, detail::ReturnMode::Nullptr, symbols...>(begin, end);\n }\n \n template <char... symbols>\n inline char * find_last_not_symbols_or_null(char * begin, char * end)\n {\n-    return const_cast<char *>(detail::find_last_symbols_sse2<false, detail::ReturnMode::Nullptr, symbols...>(begin, end));\n+    return const_cast<char *>(detail::find_last_symbols_dispatch<false, detail::ReturnMode::Nullptr, symbols...>(begin, end));\n+}\n+\n+inline const char * find_last_not_symbols_or_null(std::string_view haystack, const SearchSymbols & symbols)\n+{\n+    return detail::find_last_symbols_dispatch<false, detail::ReturnMode::Nullptr>(haystack, symbols);\n }\n \n template <char... symbols>\ndiff --git a/docs/en/sql-reference/functions/string-functions.md b/docs/en/sql-reference/functions/string-functions.md\nindex bd85c0f553e2..9d84cbc69d6c 100644\n--- a/docs/en/sql-reference/functions/string-functions.md\n+++ b/docs/en/sql-reference/functions/string-functions.md\n@@ -1473,7 +1473,7 @@ trim([[LEADING|TRAILING|BOTH] trim_character FROM] input_string)\n \n **Arguments**\n \n-- `trim_character` \u2014 Specified characters for trim. [String](../data-types/string.md).\n+- `trim_character` \u2014 The characters to trim. [String](../data-types/string.md).\n - `input_string` \u2014 String for trim. [String](../data-types/string.md).\n \n **Returned value**\n@@ -1501,14 +1501,15 @@ Removes the consecutive occurrences of whitespace (ASCII-character 32) from the\n **Syntax**\n \n ``` sql\n-trimLeft(input_string)\n+trimLeft(input_string[, trim_characters])\n ```\n \n-Alias: `ltrim(input_string)`.\n+Alias: `ltrim`.\n \n **Arguments**\n \n-- `input_string` \u2014 string to trim. [String](../data-types/string.md).\n+- `input_string` \u2014 The string to trim. [String](../data-types/string.md).\n+- `trim_characters` \u2014 The characters to trim. Optional. [String](../data-types/string.md). If not specified, `' '` ( single whitespace) is used as trim character.\n \n **Returned value**\n \n@@ -1535,14 +1536,15 @@ Removes the consecutive occurrences of whitespace (ASCII-character 32) from the\n **Syntax**\n \n ``` sql\n-trimRight(input_string)\n+trimRight(input_string[, trim_characters])\n ```\n \n-Alias: `rtrim(input_string)`.\n+Alias: `rtrim`.\n \n **Arguments**\n \n-- `input_string` \u2014 string to trim. [String](../data-types/string.md).\n+- `input_string` \u2014 The string to trim. [String](../data-types/string.md).\n+- `trim_characters` \u2014 The characters to trim. Optional. [String](../data-types/string.md). If not specified, `' '` ( single whitespace) is used as trim character.\n \n **Returned value**\n \n@@ -1569,14 +1571,15 @@ Removes the consecutive occurrences of whitespace (ASCII-character 32) from both\n **Syntax**\n \n ``` sql\n-trimBoth(input_string)\n+trimBoth(input_string[, trim_characters])\n ```\n \n-Alias: `trim(input_string)`.\n+Alias: `trim`.\n \n **Arguments**\n \n-- `input_string` \u2014 string to trim. [String](../data-types/string.md).\n+- `input_string` \u2014 The string to trim. [String](../data-types/string.md).\n+- `trim_characters` \u2014 The characters to trim. Optional. [String](../data-types/string.md). If not specified, `' '` ( single whitespace) is used as trim character.\n \n **Returned value**\n \ndiff --git a/src/Functions/trim.cpp b/src/Functions/trim.cpp\nindex 5703e8714239..869c8516d4dd 100644\n--- a/src/Functions/trim.cpp\n+++ b/src/Functions/trim.cpp\n@@ -1,53 +1,80 @@\n #include <Columns/ColumnString.h>\n+#include \"Columns/IColumn.h\"\n+#include \"Functions/IFunction.h\"\n #include <Functions/FunctionFactory.h>\n-#include <Functions/FunctionStringToString.h>\n+#include <Functions/FunctionHelpers.h>\n #include <base/find_symbols.h>\n \n-\n namespace DB\n {\n namespace ErrorCodes\n {\n-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int ILLEGAL_COLUMN;\n }\n \n namespace\n {\n \n-struct TrimModeLeft\n+template <typename Mode>\n+class FunctionTrim : public IFunction\n {\n-    static constexpr auto name = \"trimLeft\";\n-    static constexpr bool trim_left = true;\n-    static constexpr bool trim_right = false;\n-};\n+public:\n+    static constexpr auto name = Mode::name;\n \n-struct TrimModeRight\n-{\n-    static constexpr auto name = \"trimRight\";\n-    static constexpr bool trim_left = false;\n-    static constexpr bool trim_right = true;\n-};\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionTrim<Mode>>(); }\n+    String getName() const override { return name; }\n+    bool isVariadic() const override { return true; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+    size_t getNumberOfArguments() const override { return 0; }\n \n-struct TrimModeBoth\n-{\n-    static constexpr auto name = \"trimBoth\";\n-    static constexpr bool trim_left = true;\n-    static constexpr bool trim_right = true;\n-};\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        FunctionArgumentDescriptors mandatory_args{\n+            {\"input_string\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isString), nullptr, \"String\"}\n+        };\n+\n+        FunctionArgumentDescriptors optional_args{\n+            {\"trim_character\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isString), isColumnConst, \"const String\"}\n+        };\n+\n+        validateFunctionArguments(*this, arguments, mandatory_args, optional_args);\n+\n+        return arguments[0].type;\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        std::optional<SearchSymbols> custom_trim_characters;\n+        if (arguments.size() == 2 && input_rows_count > 0)\n+        {\n+            const ColumnConst * col_trim_characters_const = checkAndGetColumnConst<ColumnString>(arguments[1].column.get());\n+            const String & trim_characters_string = col_trim_characters_const->getDataAt(0).toString();\n+            custom_trim_characters = std::make_optional<SearchSymbols>(trim_characters_string);\n+        }\n+\n+        ColumnPtr col_input_full;\n+        col_input_full = arguments[0].column->convertToFullColumnIfConst();\n+\n+        if (const ColumnString * col_input_string = checkAndGetColumn<ColumnString>(col_input_full.get()))\n+        {\n+            auto col_res = ColumnString::create();\n+            vector(col_input_string->getChars(), col_input_string->getOffsets(), custom_trim_characters, col_res->getChars(), col_res->getOffsets(), input_rows_count);\n+            return col_res;\n+        }\n+        throw Exception(\n+            ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of argument of function {}\", arguments[0].column->getName(), getName());\n+    }\n \n-template <typename Mode>\n-class FunctionTrimImpl\n-{\n-public:\n     static void vector(\n-        const ColumnString::Chars & data,\n-        const ColumnString::Offsets & offsets,\n+        const ColumnString::Chars & input_data,\n+        const ColumnString::Offsets & input_offsets,\n+        const std::optional<SearchSymbols> & custom_trim_characters,\n         ColumnString::Chars & res_data,\n         ColumnString::Offsets & res_offsets,\n         size_t input_rows_count)\n     {\n         res_offsets.resize_exact(input_rows_count);\n-        res_data.reserve_exact(data.size());\n+        res_data.reserve_exact(input_data.size());\n \n         size_t prev_offset = 0;\n         size_t res_offset = 0;\n@@ -57,7 +84,7 @@ class FunctionTrimImpl\n \n         for (size_t i = 0; i < input_rows_count; ++i)\n         {\n-            execute(reinterpret_cast<const UInt8 *>(&data[prev_offset]), offsets[i] - prev_offset - 1, start, length);\n+            execute(reinterpret_cast<const UInt8 *>(&input_data[prev_offset]), input_offsets[i] - prev_offset - 1, custom_trim_characters, start, length);\n \n             res_data.resize(res_data.size() + length + 1);\n             memcpySmallAllowReadWriteOverflow15(&res_data[res_offset], start, length);\n@@ -65,45 +92,73 @@ class FunctionTrimImpl\n             res_data[res_offset - 1] = '\\0';\n \n             res_offsets[i] = res_offset;\n-            prev_offset = offsets[i];\n+            prev_offset = input_offsets[i];\n         }\n     }\n \n-    static void vectorFixed(const ColumnString::Chars &, size_t, ColumnString::Chars &, size_t)\n+    static void execute(const UInt8 * data, size_t size, const std::optional<SearchSymbols> & custom_trim_characters, const UInt8 *& res_data, size_t & res_size)\n     {\n-        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Functions trimLeft, trimRight and trimBoth cannot work with FixedString argument\");\n-    }\n-\n-private:\n-    static void execute(const UInt8 * data, size_t size, const UInt8 *& res_data, size_t & res_size)\n-    {\n-        const char * char_data = reinterpret_cast<const char *>(data);\n-        const char * char_end = char_data + size;\n+        const char * char_begin = reinterpret_cast<const char *>(data);\n+        const char * char_end = char_begin + size;\n \n         if constexpr (Mode::trim_left)\n-        { // NOLINT\n-            const char * found = find_first_not_symbols<' '>(char_data, char_end);\n-            size_t num_chars = found - char_data;\n-            char_data += num_chars;\n+        {\n+            const char * found = nullptr;\n+            if (!custom_trim_characters)\n+                found = find_first_not_symbols<' '>(char_begin, char_end);\n+            else\n+            {\n+                std::string_view input(char_begin, char_end);\n+                found = find_first_not_symbols(input, *custom_trim_characters);\n+            }\n+            size_t num_chars = found - char_begin;\n+            char_begin += num_chars;\n         }\n-\n         if constexpr (Mode::trim_right)\n-        { // NOLINT\n-            const char * found = find_last_not_symbols_or_null<' '>(char_data, char_end);\n+        {\n+            const char * found = nullptr;\n+            if (!custom_trim_characters)\n+                found = find_last_not_symbols_or_null<' '>(char_begin, char_end);\n+            else\n+            {\n+                std::string_view input(char_begin, char_end);\n+                found = find_last_not_symbols_or_null(input, *custom_trim_characters);\n+            }\n             if (found)\n                 char_end = found + 1;\n             else\n-                char_end = char_data;\n+                char_end = char_begin;\n         }\n \n-        res_data = reinterpret_cast<const UInt8 *>(char_data);\n-        res_size = char_end - char_data;\n+        res_data = reinterpret_cast<const UInt8 *>(char_begin);\n+        res_size = char_end - char_begin;\n     }\n };\n \n-using FunctionTrimLeft = FunctionStringToString<FunctionTrimImpl<TrimModeLeft>, TrimModeLeft>;\n-using FunctionTrimRight = FunctionStringToString<FunctionTrimImpl<TrimModeRight>, TrimModeRight>;\n-using FunctionTrimBoth = FunctionStringToString<FunctionTrimImpl<TrimModeBoth>, TrimModeBoth>;\n+struct TrimModeLeft\n+{\n+    static constexpr auto name = \"trimLeft\";\n+    static constexpr bool trim_left = true;\n+    static constexpr bool trim_right = false;\n+};\n+\n+struct TrimModeRight\n+{\n+    static constexpr auto name = \"trimRight\";\n+    static constexpr bool trim_left = false;\n+    static constexpr bool trim_right = true;\n+};\n+\n+struct TrimModeBoth\n+{\n+    static constexpr auto name = \"trimBoth\";\n+    static constexpr bool trim_left = true;\n+    static constexpr bool trim_right = true;\n+};\n+\n+using FunctionTrimLeft = FunctionTrim<TrimModeLeft>;\n+using FunctionTrimRight = FunctionTrim<TrimModeRight>;\n+using FunctionTrimBoth = FunctionTrim<TrimModeBoth>;\n \n }\n \ndiff --git a/src/Parsers/ExpressionListParsers.cpp b/src/Parsers/ExpressionListParsers.cpp\nindex da9a93beb2a1..35f53eec3710 100644\n--- a/src/Parsers/ExpressionListParsers.cpp\n+++ b/src/Parsers/ExpressionListParsers.cpp\n@@ -30,6 +30,7 @@\n #include <Parsers/Kusto/ParserKQLStatement.h>\n \n #include <AggregateFunctions/AggregateFunctionFactory.h>\n+#include <fmt/core.h>\n \n using namespace std::literals;\n \n@@ -1617,7 +1618,10 @@ class TrimLayer : public Layer\n {\n public:\n     TrimLayer(bool trim_left_, bool trim_right_)\n-        : Layer(/*allow_alias*/ true, /*allow_alias_without_as_keyword*/ true), trim_left(trim_left_), trim_right(trim_right_) {}\n+        : Layer(/*allow_alias*/ true, /*allow_alias_without_as_keyword*/ true)\n+        , trim_left(trim_left_)\n+        , trim_right(trim_right_)\n+    {}\n \n     bool parse(IParser::Pos & pos, Expected & expected, Action & action) override\n     {\n@@ -1675,7 +1679,7 @@ class TrimLayer : public Layer\n                 if (!mergeElement())\n                     return false;\n \n-                /// Trimming an empty string is a no-op.\n+                /// Trimming an empty string is a no-op. (shortcut that works when we supply an empty string as the first argument)\n                 ASTLiteral * ast_literal = typeid_cast<ASTLiteral *>(elements[0].get());\n                 if (ast_literal && ast_literal->value.getType() == Field::Types::String && ast_literal->value.safeGet<String>().empty())\n                 {\n@@ -1683,7 +1687,7 @@ class TrimLayer : public Layer\n                 }\n                 else\n                 {\n-                    to_remove = makeASTFunction(\"regexpQuoteMeta\", elements[0]);\n+                    to_remove = std::move(elements[0]);\n                     elements.clear();\n                 }\n \n@@ -1702,72 +1706,17 @@ class TrimLayer : public Layer\n                 {\n                     /// The operation does nothing.\n                 }\n-                if (char_override)\n-                {\n-                    ASTPtr pattern_node;\n-\n-                    auto pattern_func_node = std::make_shared<ASTFunction>();\n-                    auto pattern_list_args = std::make_shared<ASTExpressionList>();\n-                    if (trim_left && trim_right)\n-                    {\n-                        pattern_list_args->children =\n-                        {\n-                            std::make_shared<ASTLiteral>(\"^[\"),\n-                            to_remove,\n-                            std::make_shared<ASTLiteral>(\"]+|[\"),\n-                            to_remove,\n-                            std::make_shared<ASTLiteral>(\"]+$\")\n-                        };\n-                        function_name = \"replaceRegexpAll\";\n-                    }\n-                    else\n-                    {\n-                        if (trim_left)\n-                        {\n-                            pattern_list_args->children =\n-                            {\n-                                std::make_shared<ASTLiteral>(\"^[\"),\n-                                to_remove,\n-                                std::make_shared<ASTLiteral>(\"]+\")\n-                            };\n-                        }\n-                        else\n-                        {\n-                            /// trim_right == false not possible\n-                            pattern_list_args->children =\n-                            {\n-                                std::make_shared<ASTLiteral>(\"[\"),\n-                                to_remove,\n-                                std::make_shared<ASTLiteral>(\"]+$\")\n-                            };\n-                        }\n-                        function_name = \"replaceRegexpOne\";\n-                    }\n-\n-                    pattern_func_node->name = \"concat\";\n-                    pattern_func_node->arguments = std::move(pattern_list_args);\n-                    pattern_func_node->children.push_back(pattern_func_node->arguments);\n-\n-                    pattern_node = std::move(pattern_func_node);\n-\n-                    elements.push_back(pattern_node);\n-                    elements.push_back(std::make_shared<ASTLiteral>(\"\"));\n-                }\n+                if (trim_left && trim_right)\n+                    function_name = \"trimBoth\";\n+                else if (trim_left)\n+                    function_name = \"trimLeft\";\n                 else\n+                    function_name = \"trimRight\";\n+\n+                if (char_override && to_remove)\n                 {\n-                    if (trim_left && trim_right)\n-                    {\n-                        function_name = \"trimBoth\";\n-                    }\n-                    else\n-                    {\n-                        if (trim_left)\n-                            function_name = \"trimLeft\";\n-                        else\n-                            function_name = \"trimRight\";\n-                    }\n+                    elements.push_back(std::move(to_remove));\n                 }\n-\n                 finished = true;\n             }\n         }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02267_special_operator_parse_alias_check.reference b/tests/queries/0_stateless/02267_special_operator_parse_alias_check.reference\nindex 401d4d493a82..070f1191d535 100644\n--- a/tests/queries/0_stateless/02267_special_operator_parse_alias_check.reference\n+++ b/tests/queries/0_stateless/02267_special_operator_parse_alias_check.reference\n@@ -35,6 +35,8 @@ abc\ta\tabca\n abc\ta\tabca\n bc\ta\tabca\n bc\ta\tabca\n+abc\n+c\n 5\t2019-05-05\n 5\t2019-05-05\n 123\t1234\t123\ndiff --git a/tests/queries/0_stateless/02267_special_operator_parse_alias_check.sql b/tests/queries/0_stateless/02267_special_operator_parse_alias_check.sql\nindex 423bb619b001..40e4122ad6e6 100644\n--- a/tests/queries/0_stateless/02267_special_operator_parse_alias_check.sql\n+++ b/tests/queries/0_stateless/02267_special_operator_parse_alias_check.sql\n@@ -59,6 +59,10 @@ SELECT trim(TRAILING 'a' arg_1 FROM 'abca' arg_2), arg_1, arg_2;\n SELECT trim(BOTH 'a' AS arg_1 FROM 'abca' AS arg_2), arg_1, arg_2;\n SELECT trim(BOTH 'a' arg_1 FROM 'abca' arg_2), arg_1, arg_2;\n \n+-- Bug #69922\n+SELECT trim(LEADING concat('') FROM 'abc');\n+SELECT trim(LEADING concat('a', 'b') FROM 'abc');\n+\n -- EXTRACT expression\n \n -- EXTRACT(part FROM date)\ndiff --git a/tests/queries/0_stateless/03315_trim_two_args.reference b/tests/queries/0_stateless/03315_trim_two_args.reference\nnew file mode 100644\nindex 000000000000..4f1d5d1b5ebf\n--- /dev/null\n+++ b/tests/queries/0_stateless/03315_trim_two_args.reference\n@@ -0,0 +1,21 @@\n+Basic custom character trimming\n+1\t1\t1\n+Same as before but with non-const input strings\n+1\t1\t1\n+Multiple different characters to trim\n+1\t1\t1\n+Empty trim character string\n+1\t1\t1\n+Empty string to trim\n+1\t1\t1\n+String containing only trim characters\n+1\t1\t1\n+Characters that have special meaning in regex\n+1\t1\t1\n+Very long input strings\n+1\t1\t1\n+Overlapping trim characters\n+1\t1\t1\n+Same trim characters provided more than once\n+1\t1\t1\n+Negative tests\ndiff --git a/tests/queries/0_stateless/03315_trim_two_args.sql b/tests/queries/0_stateless/03315_trim_two_args.sql\nnew file mode 100644\nindex 000000000000..c9ed8157fcbe\n--- /dev/null\n+++ b/tests/queries/0_stateless/03315_trim_two_args.sql\n@@ -0,0 +1,70 @@\n+-- Tests the second argument (custom trim charactres) for functions trim, trimLeft and trimRight.\n+\n+SELECT 'Basic custom character trimming';\n+SELECT\n+    trimLeft('#@hello#@', '#@') = 'hello#@' as left_custom_ok,\n+    trimRight('#@hello#@', '#@') = '#@hello' as right_custom_ok,\n+    trimBoth('#@hello#@', '#@') = 'hello' as both_custom_ok;\n+\n+SELECT 'Same as before but with non-const input strings';\n+SELECT\n+    trimLeft(materialize('#@hello#@'), '#@') = 'hello#@' as left_custom_ok,\n+    trimRight(materialize('#@hello#@'), '#@') = '#@hello' as right_custom_ok,\n+    trimBoth(materialize('#@hello#@'), '#@') = 'hello' as both_custom_ok;\n+\n+SELECT 'Multiple different characters to trim';\n+SELECT\n+    trimLeft('##@@hello##@@', '#@') = 'hello##@@' as left_multi_ok,\n+    trimRight('##@@hello##@@', '#@') = '##@@hello' as right_multi_ok,\n+    trimBoth('##@@hello##@@', '#@') = 'hello' as both_multi_ok;\n+\n+SELECT 'Empty trim character string';\n+SELECT\n+    trimLeft('  hello  ', '') = '  hello  ' as left_empty_chars_ok,\n+    trimRight('  hello  ', '') = '  hello  ' as right_empty_chars_ok,\n+    trimBoth('  hello  ', '') = '  hello  ' as both_empty_chars_ok;\n+\n+SELECT 'Empty string to trim';\n+SELECT\n+    trimLeft('', '#@') = '' as left_empty_str_ok,\n+    trimRight('', '#@') = '' as right_empty_str_ok,\n+    trimBoth('', '#@') = '' as both_empty_str_ok;\n+\n+SELECT 'String containing only trim characters';\n+SELECT\n+    trimLeft('####', '#') = '' as left_only_trim_chars_ok,\n+    trimRight('####', '#') = '' as right_only_trim_chars_ok,\n+    trimBoth('####', '#') = '' as both_only_trim_chars_ok;\n+\n+SELECT 'Characters that have special meaning in regex';\n+SELECT\n+    trimLeft('...hello...', '.') = 'hello...' as left_special_ok,\n+    trimRight('...hello...', '.') = '...hello' as right_special_ok,\n+    trimBoth('...hello...', '.') = 'hello' as both_special_ok;\n+\n+SELECT 'Very long input strings';\n+WITH\n+    repeat('x', 1000) as long_str,\n+    repeat('#@', 50) as trim_chars\n+SELECT\n+    length(trimLeft(concat(trim_chars, long_str, trim_chars), '#@')) = 1100 as left_long_ok,\n+    length(trimRight(concat(trim_chars, long_str, trim_chars), '#@')) = 1100 as right_long_ok,\n+    length(trimBoth(concat(trim_chars, long_str, trim_chars), '#@')) = 1000 as both_long_ok;\n+\n+SELECT 'Overlapping trim characters';\n+SELECT\n+    trimLeft('aabbccHELLOccbbaa', 'abc') = 'HELLOccbbaa' as left_overlap_ok,\n+    trimRight('aabbccHELLOccbbaa', 'abc') = 'aabbccHELLO' as right_overlap_ok,\n+    trimBoth('aabbccHELLOccbbaa', 'abc') = 'HELLO' as both_overlap_ok;\n+\n+SELECT 'Same trim characters provided more than once';\n+SELECT\n+    trimLeft('#@hello#@', '#@#@') = 'hello#@' as left_custom_ok,\n+    trimRight('#@hello#@', '#@#@') = '#@hello' as right_custom_ok,\n+    trimBoth('#@hello#@', '#@#@') = 'hello' as both_custom_ok;\n+\n+SELECT 'Negative tests';\n+SELECT trimLeft('hello', 'a', 'b'); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT trimRight(123, 'a'); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT trimBoth('hello', 123); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT trimBoth('hello', materialize('a')); -- { serverError ILLEGAL_COLUMN }\n",
  "problem_statement": "`TRIM` does not support empty trim characters, pt. II\nThis issue is motivated by https://github.com/ClickHouse/ClickHouse/issues/67792#issuecomment-2373036614.\r\n\r\nAs per #68455, function `TRIM` supports empty characters `''` as a trim character argument. This was implemented as a shortcut for `''` in src/Parsers/ExpressionListParsers.cpp.\r\n\r\nThe problem is that _computed_ empty trim characters still throw an error, e.g.\r\n\r\n```sql\r\nSELECT TRIM(leading concat('') FROM 'foo');\r\n\r\n-- Code: 36. DB::Exception: Received from localhost:9000. DB::Exception: The pattern argument is not a valid re2 pattern: missing ]: []+: In scope SELECT replaceRegexpOne('foo', concat('^[', regexpQuoteMeta(concat('')), ']+'), ''). (BAD_ARGUMENTS)\r\n```\r\n\r\nThe code calls `regexpReplaceOne` with pattern `^[]+` which is not a valid re2 pattern.\r\n\r\nI think the problem is that we map to `regexpReplaceAll` at all. We should rather\r\n- extend the existing trim function (src/Functions/trim.cpp) with two optional arguments: the trim character (right now, it is hardcoded to `' '`) and an integer mode argument (0 = both, 1 = left, 2 = right)\r\n- replace the mapping from `regexpReplaceAll` to the extended trim function.\r\n\r\nSince `trim` is not based on regexps, any regexp-related issues will go away with that + it will probably also be faster.\n",
  "hints_text": "Hi , I am new in contributing to this repo ? Could u help me with this issue and probably how can i get started , i have tried to gain some inital undrstand related to above issue but not understood completely \r\n\nHey @SayeedKhan21, (I'm the author of that original part 1 PR that was mentioned) I actually took a quick look yesterday and have maybe 1/2 of it done, which could serve as a good head start for you. Do you want to collaborate and work off those changes I made? I could explain the other half that I haven't figured out yet for you to look into. Also, I'd be happy to let you submit the PR so you can make your first contribution.\nHey @petern48 yeah i would love to , although i dont know what level of understanding would be required for me to make changes it but yeah I'll give it a try and let's see .\n@SayeedKhan21 Probably easiest if I just share you access to my fork and you can commit from there (that way we both get credit for our commits). I'll give instructions on what you need to figure out. Does that sound good?\r\n\r\n(Again, you can submit the PR, the fact that it's my fork doesn't make a difference. It's just more convenient since my changes are only my branch already. If there's any reason you strongly prefer to move my changes to your own fork, we can do that too, just let me know)\n@SayeedKhan21 The best way for you to understand how `TRIM` is implemented is to run ClickHouse in a debugger (lldb, gdb). Then set a breakpoint in the TRIM handler in src/Parsers/ExpressionListParsers.cpp and run a few `SELECT` statements that contain `TRIM`.\nOk , will check today when i get time , btw are there any discord servers of this org or any other channel to talk ? \nThere is a community Slack with lots of discussion (see here: https://github.com/ClickHouse/ClickHouse). There is less C++ and development discussion over there, unfortunately :(\r\n\r\nMy suggestion is to push a PR (which references this issue in its PR message) and discuss everything within that PR via GitHub comments.\nOk nevermind . Hey @rschu1ze https://clickhouse.com/docs/en/development/build-osx , this would be the link which explains all steps to build locally right ?  Also should i spend some days understanding clickhouse and building it locally and its functionalities a bit before jumping to the issues ??\r\n\n@SayeedKhan21 Steps to compile ClickHouse are here: https://clickhouse.com/docs/en/development/build . The most convenient option is to build on Linux for Linux but building on Mac for Mac is possible too (as you discovered already :).\r\n\r\nHow much you are willing to invest really depends on you and your time. I'd say, there are a lot of interesting things to learn from the codebase. For this particular issue, you will not need a deep understanding of the [architecture](https://clickhouse.com/docs/en/development/architecture). Just attach a debugger (see my other comment), understand what the code is currently doing and why it does not work, then explore the existing `trim` functions in src/Functions/trim.cpp (not: `TRIM`), then extend then as I proposed in this issue, and redirect `TRIM` to always use `trim`.\n> @SayeedKhan21 Probably easiest if I just share you access to my fork and you can commit from there (that way we both get credit for our commits). I'll give instructions on what you need to figure out. Does that sound good?\r\n> \r\n> (Again, you can submit the PR, the fact that it's my fork doesn't make a difference. It's just more convenient since my changes are only my branch already. If there's any reason you strongly prefer to move my changes to your own fork, we can do that too, just let me know)\r\n\r\nhey i think we can go ahead with this , i don't have any problem , u can give me access and i would clone the same .  Just one thing would this PR be done as if made by me ? The thing is I am also participating in hacktoberfest this year , so like this repo has hacktoberfest tagged , now it isn't that I am interested only in completing hacktoberfest but just that if i make any successfull PR's during this time then my contri would be recognized in hacktoberfest as well . But anyways I am gonna contibue contriubting here  as i find this repo quite fascinating \nhey @rschu1ze can i ping u on slack? or is it better here itself ?\nSure, please ping me on Slack.\n@SayeedKhan21 Hmm, I'm glad you mentioned that. I took a look at Hacktoberfest's website, I'm guessing it just needs to be your PR, but I'm not sure and I don't mind having everything be yours to be safe. So feel free to do whatever you think is best (e.g. clone or just copy everything over to your own fork) and submit from there.\r\n\r\nI pushed the notes I have for you on [this new branch on my fork](https://github.com/petern48/ClickHouse/tree/fix_trim_empty_2). Read through my comments because I explained what you need to figure out and what I found that could help you (and how). All the changes are commented so it compiles, but there are some compile errors to fix once you uncomment a few things. Also, [here's a diff](https://github.com/ClickHouse/ClickHouse/compare/master...petern48:ClickHouse:fix_trim_empty_2) to view the changes for convenience. I'm a fairly new contributor too (~2 months) so I'm not 100%, but I think these should set you in the right direction. Good luck and feel free to ping on Slack for clarifications. \n```\r\n/Users/skhan/Personal/Repos/ClickHouse/src/Common/QueryFuzzer.cpp:1008:20: error: variable 'literal' set but not used [-Werror,-Wunused-but-set-variable]\r\n 1008 |         if (auto * literal = typeid_cast<ASTLiteral *>(child.get()))\r\n      |                    ^\r\n1 error generated.\r\n```\r\n\r\nhey i am getting this error while building locally using cmake --build ./build , anyone knows how to resolve this. ? @petern48 @rschu1ze ??\n@SayeedKhan21 you can use `[[maybe_unused]]` to mute this warning.\n ```\r\nerror: variable 'literal' set but not used [-Werror,-Wunused-but-set-variable]\r\n 1008 |         if (auto * literal = typeid_cast<ASTLiteral *>(child.get()))\r\n      |                    ^\r\n1 error generated.\r\n[3345/11158] Building CXX object src/CMakeFiles/clickhouse_common_io.dir/Common/SystemLogBase.cpp.o\r\nninja: build stopped: subcommand failed.`\r\n```\r\nBut it popped as an error and not warning \nThe build settings of ClickHouse treat warnings as errors. `[[maybe_unused]]` will fix the issue.\n@rschu1ze where should i add [[maybe_unused]] before literal ? but wouldnt that create a change in code ? why don't we do it permanently to codebase ? \r\n\n> where should i add [[maybe_unused]] before literal?\r\n\r\nPlease google \"C++ maybe_unused\" and you will get hundreds of references how to use `[[maybe_unused]]`.\r\n\r\n> why don't we do it permanently to codebase ?\r\n\r\nI am actually surprised that you ran into this build issue at all. If you share your `cmake` invocation, I can try to reproduce the issue.\nhttps://clickhouse.com/docs/en/development/build-osx\r\nI followed this doc  and used below commands to build\r\n`cmake -G Ninja -DCMAKE_BUILD_TYPE=RelWithDebInfo -DCMAKE_C_COMPILER=$(brew --prefix llvm)/bin/clang -DCMAKE_CXX_COMPILER=$(brew --prefix llvm)/bin/clang++ -S . -B build\r\n`\nI am actually getting the same error at multiple instances across code wherever it applies\r\n\nHmm, I followed the steps but did not get any error.\n@rschu1ze \r\n`-- The C compiler identification is Clang 19.1.0\r\n-- The CXX compiler identification is Clang 19.1.0\r\n-- The ASM compiler identification is Clang with GNU-like command-line\r\n-- Found assembler: /opt/homebrew/Cellar/llvm/19.1.0/bin/clang\r\n-- Detecting C compiler ABI info\r\n-- Detecting C compiler ABI info - done\r\n-- Check for working C compiler: /opt/homebrew/Cellar/llvm/19.1.0/bin/clang - skipped\r\n-- Detecting C compile features\r\n-- Detecting C compile features - done\r\n-- Detecting CXX compiler ABI info\r\n-- Detecting CXX compiler ABI info - done\r\n-- Check for working CXX compiler: /opt/homebrew/Cellar/llvm/19.1.0/bin/clang++ - skipped\r\n-- Detecting CXX compile features\r\n-- Detecting CXX compile features - done\r\n-- Using compiler:\r\nHomebrew clang version 19.1.0\r\nTarget: arm64-apple-darwin23.6.0\r\nThread model: posix\r\nInstalledDir: /opt/homebrew/Cellar/llvm/19.1.0/bin\r\n-- Using linker: /usr/bin/ld\r\n-- Using archiver: /usr/bin/ar\r\n-- Using ranlib: /opt/homebrew/Cellar/llvm/19.1.0/bin/llvm-ranlib\r\n-- Using install-name-tool: /usr/bin/install_name_tool\r\nCMake Error at cmake/tools.cmake:102 (message):\r\n  Cannot find objcopy.\r\nCall Stack (most recent call first):\r\n  CMakeLists.txt:18 (include)`\r\n  \r\n  \r\n  this was the error i get for cmake invocation command \r\n  \r\n  tools.cmake file --> \r\n  \r\n  `find_program (OBJCOPY_PATH NAMES \"llvm-objcopy-${COMPILER_VERSION_MAJOR}\" \"llvm-objcopy\" \"objcopy\")\r\nif (OBJCOPY_PATH)\r\n    message (STATUS \"Using objcopy: ${OBJCOPY_PATH}\")\r\nelse ()\r\n    message (FATAL_ERROR \"Cannot find objcopy.\")\r\nendif ()`\r\n\r\ni configured everything correctly and tried to resolve the error (configuring the build path correctly) as well but still no progress \r\n  \r\n  \nIt will be too difficult for me to help you debug your macOS build environment (`objcopy` seems to be missing). Try to build on Linux for Linux. Building on macOS works only on a best effort basis, as you found out the hard way, sorry.\nUmm sorry but i dont understand what are u trying to suggest\nhey @rschu1ze  i am getting this issue during build \r\n`/Users/skhan/Personal/Repos/ClickHouse/contrib/flatbuffers/include/flatbuffers/stl_emulation.h:549:12: error: cannot assign to non-static data member 'count_' with const-qualified type 'const size_type' (aka 'const unsigned long')\r\n  549 |     count_ = other.count_;\r\n      |     ~~~~~~ ^\r\n/Users/skhan/Personal/Repos/ClickHouse/contrib/flatbuffers/include/flatbuffers/stl_emulation.h:628:19: note: non-static data member 'count_' declared const here\r\n  628 |   const size_type count_;`\r\n  \nI am unable to help without knowing\r\n- your operating system\r\n- your CMake invocation\r\n- the code state (git hash) you are trying to compile.\n@rschu1ze \r\nOperating system -> macOs\r\nCmake invocation -> cmake -G Ninja -DCMAKE_BUILD_TYPE=RelWithDebInfo -DCMAKE_C_COMPILER=$(brew --prefix llvm)/bin/clang -DCMAKE_CXX_COMPILER=$(brew --prefix llvm)/bin/clang++ -S . -B build\r\nCommand used -> cmake --build build ( got error after this command)\r\nCode state ->  just cloned the latest fork (df4e80bd01c4baaba95cd9471a7f6b95ac5db465)\n@SayeedKhan21 maybe it's an issue with your git submodules (nested git repos inside ClickHouse). Run `git status` and check if there is anything that shows up in the `contrib` directory like this:\r\n![image](https://github.com/user-attachments/assets/33e8e54b-6764-4b6e-a2a5-0175b29d96da)\r\n\r\nIf there are, delete it entirely with `rm -r <submodule_path>` and run `git submodule init` and `git submodule update` again. Maybe at least try it with the `contrib/flatbuffers` submodule since that is involved in that error.\r\n\r\n(deleting the folder isn't always necessary, but I've found it to be the easiest fix for when something weird happens after changing/updating  branches, etc)\n@petern48 flatbuffers get regenerated on submodule update , and then again i get same issue during build \nflatbuffers should be regenerated, just want to make sure it's the correct version. Does `git status` show anything?\n<img width=\"633\" alt=\"Screenshot 2024-10-13 at 4 41 23\u202fAM\" src=\"https://github.com/user-attachments/assets/54b4093a-e3c6-4a05-bdc4-43d07686f426\">\r\nI am getting this on git status\nTry this. Tbh I'm not deeply familiar with the complexities with git submodules, but I generally aim to have nothing show up in git status from the `contrib/` directory.\r\n\r\n```\r\nrm -r contrib/liburing\r\nrm -r contrib/sysroot\r\ngit submodule init\r\ngit submodule update\r\n```\n@petern48 did the same but still getting same thing on git status\n@SayeedKhan21 Kindly see our discussion on Slack on 2 Oct.",
  "created_at": "2025-02-03T04:14:05Z",
  "modified_files": [
    "base/base/find_symbols.h",
    "docs/en/sql-reference/functions/string-functions.md",
    "src/Functions/trim.cpp",
    "src/Parsers/ExpressionListParsers.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/02267_special_operator_parse_alias_check.reference",
    "tests/queries/0_stateless/02267_special_operator_parse_alias_check.sql",
    "b/tests/queries/0_stateless/03315_trim_two_args.reference",
    "b/tests/queries/0_stateless/03315_trim_two_args.sql"
  ]
}