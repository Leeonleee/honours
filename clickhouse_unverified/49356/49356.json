{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 49356,
  "instance_id": "ClickHouse__ClickHouse-49356",
  "issue_numbers": [
    "49231",
    "49232"
  ],
  "base_commit": "1267fbca1c14be1c3d3b1b0bd7dd45fbe6538e03",
  "patch": "diff --git a/docs/en/sql-reference/table-functions/url.md b/docs/en/sql-reference/table-functions/url.md\nindex 014dc3ae8532..9b4a02e2393b 100644\n--- a/docs/en/sql-reference/table-functions/url.md\n+++ b/docs/en/sql-reference/table-functions/url.md\n@@ -46,3 +46,12 @@ SELECT * FROM test_table;\n \n Patterns in curly brackets `{ }` are used to generate a set of shards or to specify failover addresses. Supported pattern types and examples see in the description of the [remote](remote.md#globs-in-addresses) function.\n Character `|` inside patterns is used to specify failover addresses. They are iterated in the same order as listed in the pattern. The number of generated addresses is limited by [glob_expansion_max_elements](../../operations/settings/settings.md#glob_expansion_max_elements) setting.\n+\n+## Virtual Columns\n+\n+- `_path` \u2014 Path to the `URL`.\n+- `_file` \u2014 Resource name of the `URL`.\n+\n+**See Also**\n+\n+- [Virtual columns](/docs/en/engines/table-engines/index.md#table_engines-virtual_columns)\ndiff --git a/docs/ru/sql-reference/table-functions/url.md b/docs/ru/sql-reference/table-functions/url.md\nindex e5d9faeec007..ec9548229c80 100644\n--- a/docs/ru/sql-reference/table-functions/url.md\n+++ b/docs/ru/sql-reference/table-functions/url.md\n@@ -46,3 +46,12 @@ SELECT * FROM test_table;\n \n \u0428\u0430\u0431\u043b\u043e\u043d\u044b \u0432 \u0444\u0438\u0433\u0443\u0440\u043d\u044b\u0445 \u0441\u043a\u043e\u0431\u043a\u0430\u0445 `{ }` \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f, \u0447\u0442\u043e\u0431\u044b \u0441\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0441\u043f\u0438\u0441\u043e\u043a \u0448\u0430\u0440\u0434\u043e\u0432 \u0438\u043b\u0438 \u0443\u043a\u0430\u0437\u0430\u0442\u044c \u0430\u043b\u044c\u0442\u0435\u0440\u043d\u0430\u0442\u0438\u0432\u043d\u044b\u0435 \u0430\u0434\u0440\u0435\u0441\u0430 \u043d\u0430 \u0441\u043b\u0443\u0447\u0430\u0439 \u043e\u0442\u043a\u0430\u0437\u0430. \u041f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u043c\u044b\u0435 \u0442\u0438\u043f\u044b \u0448\u0430\u0431\u043b\u043e\u043d\u043e\u0432 \u0438 \u043f\u0440\u0438\u043c\u0435\u0440\u044b \u0441\u043c\u043e\u0442\u0440\u0438\u0442\u0435 \u0432 \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 [remote](remote.md#globs-in-addresses).\n \u0421\u0438\u043c\u0432\u043e\u043b `|` \u0432\u043d\u0443\u0442\u0440\u0438 \u0448\u0430\u0431\u043b\u043e\u043d\u043e\u0432 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f, \u0447\u0442\u043e\u0431\u044b \u0437\u0430\u0434\u0430\u0442\u044c \u0430\u0434\u0440\u0435\u0441\u0430, \u0435\u0441\u043b\u0438 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0438\u0435 \u043e\u043a\u0430\u0437\u0430\u043b\u0438\u0441\u044c \u043d\u0435\u0434\u043e\u0441\u0442\u0443\u043f\u043d\u044b. \u042d\u0442\u0438 \u0430\u0434\u0440\u0435\u0441\u0430 \u043f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u044e\u0442\u0441\u044f \u0432 \u0442\u043e\u043c \u0436\u0435 \u043f\u043e\u0440\u044f\u0434\u043a\u0435, \u0432 \u043a\u043e\u0442\u043e\u0440\u043e\u043c \u043e\u043d\u0438 \u0443\u043a\u0430\u0437\u0430\u043d\u044b \u0432 \u0448\u0430\u0431\u043b\u043e\u043d\u0435. \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0430\u0434\u0440\u0435\u0441\u043e\u0432, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043c\u043e\u0433\u0443\u0442 \u0431\u044b\u0442\u044c \u0441\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u044b, \u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u043e \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u043e\u0439 [glob_expansion_max_elements](../../operations/settings/settings.md#glob_expansion_max_elements).\n+\n+## \u0412\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u044b\u0435 \u0441\u0442\u043e\u043b\u0431\u0446\u044b\n+\n+-   `_path` \u2014 \u041f\u0443\u0442\u044c \u0434\u043e `URL`.\n+-   `_file` \u2014 \u0418\u043c\u044f \u0440\u0435\u0441\u0443\u0440\u0441\u0430 `URL`.\n+\n+**\u0421\u043c\u043e\u0442\u0440\u0438\u0442\u0435 \u0442\u0430\u043a\u0436\u0435**\n+\n+-   [\u0412\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u044b\u0435 \u0441\u0442\u043e\u043b\u0431\u0446\u044b](index.md#table_engines-virtual_columns)\ndiff --git a/docs/zh/sql-reference/table-functions/url.md b/docs/zh/sql-reference/table-functions/url.md\nindex d3b7665d21bd..c8ca9b775b25 100644\n--- a/docs/zh/sql-reference/table-functions/url.md\n+++ b/docs/zh/sql-reference/table-functions/url.md\n@@ -41,3 +41,11 @@ CREATE TABLE test_table (column1 String, column2 UInt32) ENGINE=Memory;\n INSERT INTO FUNCTION url('http://127.0.0.1:8123/?query=INSERT+INTO+test_table+FORMAT+CSV', 'CSV', 'column1 String, column2 UInt32') VALUES ('http interface', 42);\n SELECT * FROM test_table;\n ```\n+## \u865a\u62df\u5217 {#virtual-columns}\n+\n+-   `_path` \u2014 `URL`\u8def\u5f84\u3002\n+-   `_file` \u2014 \u8d44\u6e90\u540d\u79f0\u3002\n+\n+**\u53e6\u8bf7\u53c2\u9605**\n+\n+-   [\u865a\u62df\u5217](https://clickhouse.com/docs/en/operations/table_engines/#table_engines-virtual_columns)\ndiff --git a/src/Common/parseRemoteDescription.cpp b/src/Common/parseRemoteDescription.cpp\nindex aa7122ffb4c3..0bcd62d30c7e 100644\n--- a/src/Common/parseRemoteDescription.cpp\n+++ b/src/Common/parseRemoteDescription.cpp\n@@ -64,7 +64,8 @@ static bool parseNumber(const String & description, size_t l, size_t r, size_t &\n  * abc{1..9}de{f,g,h}   - is a direct product, 27 shards.\n  * abc{1..9}de{0|1}     - is a direct product, 9 shards, in each 2 replicas.\n  */\n-std::vector<String> parseRemoteDescription(const String & description, size_t l, size_t r, char separator, size_t max_addresses)\n+std::vector<String>\n+parseRemoteDescription(const String & description, size_t l, size_t r, char separator, size_t max_addresses, const String & func_name)\n {\n     std::vector<String> res;\n     std::vector<String> cur;\n@@ -97,28 +98,41 @@ std::vector<String> parseRemoteDescription(const String & description, size_t l,\n                 if (cnt == 0) break;\n             }\n             if (cnt != 0)\n-                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Table function 'remote': incorrect brace sequence in first argument\");\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Table function '{}': incorrect brace sequence in first argument\", func_name);\n             /// The presence of a dot - numeric interval\n             if (last_dot != -1)\n             {\n                 size_t left, right;\n                 if (description[last_dot - 1] != '.')\n-                    throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Table function 'remote': incorrect argument in braces (only one dot): {}\",\n-                                    description.substr(i, m - i + 1));\n+                    throw Exception(\n+                        ErrorCodes::BAD_ARGUMENTS,\n+                        \"Table function '{}': incorrect argument in braces (only one dot): {}\",\n+                        func_name,\n+                        description.substr(i, m - i + 1));\n                 if (!parseNumber(description, i + 1, last_dot - 1, left))\n-                    throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Table function 'remote': \"\n-                                    \"incorrect argument in braces (Incorrect left number): {}\",\n-                                    description.substr(i, m - i + 1));\n+                    throw Exception(\n+                        ErrorCodes::BAD_ARGUMENTS,\n+                        \"Table function '{}': \"\n+                        \"incorrect argument in braces (Incorrect left number): {}\",\n+                        func_name,\n+                        description.substr(i, m - i + 1));\n                 if (!parseNumber(description, last_dot + 1, m, right))\n-                    throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Table function 'remote': \"\n-                                    \"incorrect argument in braces (Incorrect right number): {}\",\n-                                    description.substr(i, m - i + 1));\n+                    throw Exception(\n+                        ErrorCodes::BAD_ARGUMENTS,\n+                        \"Table function '{}': \"\n+                        \"incorrect argument in braces (Incorrect right number): {}\",\n+                        func_name,\n+                        description.substr(i, m - i + 1));\n                 if (left > right)\n-                    throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Table function 'remote': \"\n-                                    \"incorrect argument in braces (left number is greater then right): {}\",\n-                                    description.substr(i, m - i + 1));\n+                    throw Exception(\n+                        ErrorCodes::BAD_ARGUMENTS,\n+                        \"Table function '{}': \"\n+                        \"incorrect argument in braces (left number is greater then right): {}\",\n+                        func_name,\n+                        description.substr(i, m - i + 1));\n                 if (right - left + 1 >  max_addresses)\n-                    throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Table function 'remote': first argument generates too many result addresses\");\n+                    throw Exception(\n+                        ErrorCodes::BAD_ARGUMENTS, \"Table function '{}': first argument generates too many result addresses\", func_name);\n                 bool add_leading_zeroes = false;\n                 size_t len = last_dot - 1 - (i + 1);\n                 /// If the left and right borders have equal numbers, then you must add leading zeros.\n@@ -161,7 +175,7 @@ std::vector<String> parseRemoteDescription(const String & description, size_t l,\n \n     res.insert(res.end(), cur.begin(), cur.end());\n     if (res.size() > max_addresses)\n-        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Table function 'remote': first argument generates too many result addresses\");\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Table function '{}': first argument generates too many result addresses\", func_name);\n \n     return res;\n }\ndiff --git a/src/Common/parseRemoteDescription.h b/src/Common/parseRemoteDescription.h\nindex eef8fbfefe4e..e3e4a3f523c2 100644\n--- a/src/Common/parseRemoteDescription.h\n+++ b/src/Common/parseRemoteDescription.h\n@@ -15,7 +15,8 @@ namespace DB\n  * abc{1..9}de{f,g,h}   - is a direct product, 27 shards.\n  * abc{1..9}de{0|1}     - is a direct product, 9 shards, in each 2 replicas.\n  */\n-std::vector<String> parseRemoteDescription(const String & description, size_t l, size_t r, char separator, size_t max_addresses);\n+std::vector<String> parseRemoteDescription(\n+    const String & description, size_t l, size_t r, char separator, size_t max_addresses, const String & func_name = \"remote\");\n \n /// Parse remote description for external database (MySQL or PostgreSQL).\n std::vector<std::pair<String, uint16_t>> parseRemoteDescriptionForExternalDatabase(const String & description, size_t max_addresses, UInt16 default_port);\ndiff --git a/src/Storages/StorageURL.cpp b/src/Storages/StorageURL.cpp\nindex d2df3881c710..0d36319d8942 100644\n--- a/src/Storages/StorageURL.cpp\n+++ b/src/Storages/StorageURL.cpp\n@@ -38,6 +38,7 @@\n #include <Common/logger_useful.h>\n #include <Poco/Net/HTTPRequest.h>\n #include <regex>\n+#include <DataTypes/DataTypeString.h>\n \n \n namespace DB\n@@ -159,6 +160,9 @@ namespace\n             using FailoverOptions = std::vector<String>;\n             std::vector<FailoverOptions> uri_list_to_read;\n             std::atomic<size_t> next_uri_to_read = 0;\n+\n+            bool need_path_column = false;\n+            bool need_file_column = false;\n         };\n         using URIInfoPtr = std::shared_ptr<URIInfo>;\n \n@@ -176,6 +180,27 @@ namespace\n             }\n         }\n \n+        static Block getBlockForSource(const Block & block_for_format, const URIInfoPtr & uri_info)\n+        {\n+            auto res = block_for_format;\n+            if (uri_info->need_path_column)\n+            {\n+                res.insert(\n+                    {DataTypeLowCardinality{std::make_shared<DataTypeString>()}.createColumn(),\n+                     std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>()),\n+                     \"_path\"});\n+            }\n+\n+            if (uri_info->need_file_column)\n+            {\n+                res.insert(\n+                    {DataTypeLowCardinality{std::make_shared<DataTypeString>()}.createColumn(),\n+                     std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>()),\n+                     \"_file\"});\n+            }\n+            return res;\n+        }\n+\n         StorageURLSource(\n             URIInfoPtr uri_info_,\n             const std::string & http_method,\n@@ -193,7 +218,7 @@ namespace\n             const HTTPHeaderEntries & headers_ = {},\n             const URIParams & params = {},\n             bool glob_url = false)\n-            : ISource(sample_block), name(std::move(name_)), uri_info(uri_info_)\n+            : ISource(getBlockForSource(sample_block, uri_info_)), name(std::move(name_)), uri_info(uri_info_)\n         {\n             auto headers = getHeaders(headers_);\n \n@@ -204,7 +229,7 @@ namespace\n                     throw Exception(ErrorCodes::LOGICAL_ERROR, \"Got empty url list\");\n \n                 auto first_option = uri_options.begin();\n-                auto buf_factory = getFirstAvailableURLReadBuffer(\n+                auto [actual_uri, buf_factory] = getFirstAvailableURIAndReadBuffer(\n                     first_option,\n                     uri_options.end(),\n                     context,\n@@ -217,6 +242,8 @@ namespace\n                     glob_url,\n                     uri_options.size() == 1);\n \n+                curr_uri = actual_uri;\n+\n                 try\n                 {\n                     total_size += buf_factory->getFileSize();\n@@ -269,15 +296,32 @@ namespace\n                     if (current_uri_pos >= uri_info->uri_list_to_read.size())\n                         return {};\n \n-                    auto current_uri = uri_info->uri_list_to_read[current_uri_pos];\n+                    auto current_uri_options = uri_info->uri_list_to_read[current_uri_pos];\n \n-                    initialize(current_uri);\n+                    initialize(current_uri_options);\n                 }\n \n                 Chunk chunk;\n                 if (reader->pull(chunk))\n                 {\n                     UInt64 num_rows = chunk.getNumRows();\n+\n+                    const String & path{curr_uri.getPath()};\n+                    if (uri_info->need_path_column)\n+                    {\n+                        auto column = DataTypeLowCardinality{std::make_shared<DataTypeString>()}.createColumnConst(num_rows, path);\n+                        chunk.addColumn(column->convertToFullColumnIfConst());\n+                    }\n+\n+                    if (uri_info->need_file_column)\n+                    {\n+                        const size_t last_slash_pos = path.find_last_of('/');\n+                        auto file_name = path.substr(last_slash_pos + 1);\n+                        auto column\n+                            = DataTypeLowCardinality{std::make_shared<DataTypeString>()}.createColumnConst(num_rows, std::move(file_name));\n+                        chunk.addColumn(column->convertToFullColumnIfConst());\n+                    }\n+\n                     if (num_rows && total_size)\n                         updateRowsProgressApprox(\n                             *this, chunk, total_size, total_rows_approx_accumulated, total_rows_count_times, total_rows_approx_max);\n@@ -291,7 +335,7 @@ namespace\n             return {};\n         }\n \n-        static SeekableReadBufferFactoryPtr getFirstAvailableURLReadBuffer(\n+        static std::tuple<Poco::URI, SeekableReadBufferFactoryPtr> getFirstAvailableURIAndReadBuffer(\n             std::vector<String>::const_iterator & option,\n             const std::vector<String>::const_iterator & end,\n             ContextPtr context,\n@@ -352,7 +396,7 @@ namespace\n                     }\n                 }\n \n-                return res;\n+                return std::make_tuple(request_uri, std::move(res));\n             }\n \n             throw Exception(ErrorCodes::NETWORK_ERROR, \"All uri ({}) options are unreachable: {}\", options, first_exception_message);\n@@ -364,6 +408,7 @@ namespace\n \n         String name;\n         URIInfoPtr uri_info;\n+        Poco::URI curr_uri;\n \n         std::unique_ptr<QueryPipeline> pipeline;\n         std::unique_ptr<PullingPipelineExecutor> reader;\n@@ -538,10 +583,10 @@ ColumnsDescription IStorageURLBase::getTableStructureFromData(\n     if (urlWithGlobs(uri))\n     {\n         size_t max_addresses = context->getSettingsRef().glob_expansion_max_elements;\n-        auto uri_descriptions = parseRemoteDescription(uri, 0, uri.size(), ',', max_addresses);\n+        auto uri_descriptions = parseRemoteDescription(uri, 0, uri.size(), ',', max_addresses, \"url\");\n         for (const auto & description : uri_descriptions)\n         {\n-            auto options = parseRemoteDescription(description, 0, description.size(), '|', max_addresses);\n+            auto options = parseRemoteDescription(description, 0, description.size(), '|', max_addresses, \"url\");\n             urls_to_check.insert(urls_to_check.end(), options.begin(), options.end());\n         }\n     }\n@@ -559,7 +604,7 @@ ColumnsDescription IStorageURLBase::getTableStructureFromData(\n         if (it == urls_to_check.cend())\n             return nullptr;\n \n-        auto buf_factory = StorageURLSource::getFirstAvailableURLReadBuffer(\n+        auto [_, buf_factory] = StorageURLSource::getFirstAvailableURIAndReadBuffer(\n             it,\n             urls_to_check.cend(),\n             context,\n@@ -621,18 +666,27 @@ Pipe IStorageURLBase::read(\n \n     size_t max_download_threads = local_context->getSettingsRef().max_download_threads;\n \n+    auto uri_info = std::make_shared<StorageURLSource::URIInfo>();\n+    for (const auto & column : column_names)\n+    {\n+        if (column == \"_path\")\n+            uri_info->need_path_column = true;\n+        if (column == \"_file\")\n+            uri_info->need_file_column = true;\n+    }\n+\n     if (urlWithGlobs(uri))\n     {\n         size_t max_addresses = local_context->getSettingsRef().glob_expansion_max_elements;\n-        auto uri_descriptions = parseRemoteDescription(uri, 0, uri.size(), ',', max_addresses);\n+        auto uri_descriptions = parseRemoteDescription(uri, 0, uri.size(), ',', max_addresses, \"url\");\n \n         if (num_streams > uri_descriptions.size())\n             num_streams = uri_descriptions.size();\n \n         /// For each uri (which acts like shard) check if it has failover options\n-        auto uri_info = std::make_shared<StorageURLSource::URIInfo>();\n+        uri_info->uri_list_to_read.reserve(uri_descriptions.size());\n         for (const auto & description : uri_descriptions)\n-            uri_info->uri_list_to_read.emplace_back(parseRemoteDescription(description, 0, description.size(), '|', max_addresses));\n+            uri_info->uri_list_to_read.emplace_back(parseRemoteDescription(description, 0, description.size(), '|', max_addresses, \"url\"));\n \n         Pipes pipes;\n         pipes.reserve(num_streams);\n@@ -662,7 +716,6 @@ Pipe IStorageURLBase::read(\n     }\n     else\n     {\n-        auto uri_info = std::make_shared<StorageURLSource::URIInfo>();\n         uri_info->uri_list_to_read.emplace_back(std::vector<String>{uri});\n         return Pipe(std::make_shared<StorageURLSource>(\n             uri_info,\n@@ -771,6 +824,13 @@ SinkToStoragePtr IStorageURLBase::write(const ASTPtr & query, const StorageMetad\n     }\n }\n \n+NamesAndTypesList IStorageURLBase::getVirtuals() const\n+{\n+    return NamesAndTypesList{\n+        {\"_path\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())},\n+        {\"_file\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())}};\n+}\n+\n SchemaCache & IStorageURLBase::getSchemaCache(const ContextPtr & context)\n {\n     static SchemaCache schema_cache(context->getConfigRef().getUInt(\"schema_inference_cache_max_elements_for_url\", DEFAULT_SCHEMA_CACHE_ELEMENTS));\ndiff --git a/src/Storages/StorageURL.h b/src/Storages/StorageURL.h\nindex 65ee78e1e736..48498836e8d9 100644\n--- a/src/Storages/StorageURL.h\n+++ b/src/Storages/StorageURL.h\n@@ -43,6 +43,8 @@ class IStorageURLBase : public IStorage\n \n     bool supportsPartitionBy() const override { return true; }\n \n+    NamesAndTypesList getVirtuals() const override;\n+\n     static ColumnsDescription getTableStructureFromData(\n         const String & format,\n         const String & uri,\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00646_url_engine.python b/tests/queries/0_stateless/00646_url_engine.python\nindex 0a26f8039c29..dc0fdd1a71d7 100644\n--- a/tests/queries/0_stateless/00646_url_engine.python\n+++ b/tests/queries/0_stateless/00646_url_engine.python\n@@ -7,6 +7,7 @@ import tempfile\n import threading\n import os\n import traceback\n+from urllib.parse import urljoin\n import urllib.request\n import subprocess\n from io import StringIO\n@@ -163,6 +164,7 @@ def test_select(\n     requests=[],\n     answers=[],\n     test_data=\"\",\n+    res_path=\"\",\n ):\n     with open(CSV_DATA, \"w\") as f:  # clear file\n         f.write(\"\")\n@@ -183,7 +185,7 @@ def test_select(\n         tbl = table_name\n         if not tbl:\n             tbl = \"url('{addr}', 'CSV', '{schema}')\".format(\n-                addr=HTTP_SERVER_URL_STR, schema=schema\n+                addr=urljoin(HTTP_SERVER_URL_STR, res_path), schema=schema\n             )\n         check_answers(requests[i].format(tbl=tbl), answers[i])\n \n@@ -252,6 +254,20 @@ def main():\n         \"select double, count(*) from {tbl} group by double order by double\": \"7.7\\t2\\n9.9\\t10\",\n     }\n \n+    pathname = CSV_DATA\n+    filename = os.path.basename(CSV_DATA)\n+    select_virtual_requests = {\n+        \"select _path from {tbl}\": \"\\n\".join(pathname for _ in range(2)),\n+        \"select _file from {tbl}\": \"\\n\".join(filename for _ in range(2)),\n+        \"select _file, from {tbl} order by _path\": \"\\n\".join(\n+            filename for _ in range(2)\n+        ),\n+        \"select _path, _file from {tbl}\": \"\\n\".join(\n+            f\"{pathname}\\t{filename}\" for _ in range(2)\n+        ),\n+        \"select _path, count(*) from {tbl} group by _path\": f\"{pathname}\\t2\",\n+    }\n+\n     t, httpd = start_server()\n     t.start()\n     # test table with url engine\n@@ -267,6 +283,14 @@ def main():\n         answers=list(select_only_requests.values()),\n         test_data=test_data,\n     )\n+    # test table function url for virtual column\n+    test_select(\n+        requests=list(select_virtual_requests.keys()),\n+        answers=list(select_virtual_requests.values()),\n+        test_data=test_data,\n+        res_path=CSV_DATA,\n+    )\n+\n     # test insert into table with url engine\n     test_insert(\n         table_name=\"test_table_insert\",\ndiff --git a/tests/queries/0_stateless/02725_url_support_virtual_column.reference b/tests/queries/0_stateless/02725_url_support_virtual_column.reference\nnew file mode 100644\nindex 000000000000..d20c91344e5c\n--- /dev/null\n+++ b/tests/queries/0_stateless/02725_url_support_virtual_column.reference\n@@ -0,0 +1,4 @@\n+/\n+\n+\t1\n+/\t\t1\ndiff --git a/tests/queries/0_stateless/02725_url_support_virtual_column.sql b/tests/queries/0_stateless/02725_url_support_virtual_column.sql\nnew file mode 100644\nindex 000000000000..02a4dfc449bf\n--- /dev/null\n+++ b/tests/queries/0_stateless/02725_url_support_virtual_column.sql\n@@ -0,0 +1,8 @@\n+-- Tags: no-parallel\n+\n+select _path from url('http://127.0.0.1:8123/?query=select+1&user=default', LineAsString, 's String');\n+select _file from url('http://127.0.0.1:8123/?query=select+1&user=default', LineAsString, 's String');\n+select _file, count() from url('http://127.0.0.1:8123/?query=select+1&user=default', LineAsString, 's String') group by _file;\n+select _path, _file, s from url('http://127.0.0.1:8123/?query=select+1&user=default', LineAsString, 's String');\n+select _path, _file, s from url('http://127.0.0.1:8123/?query=select+1&user=default&password=wrong', LineAsString, 's String'); -- { serverError RECEIVED_ERROR_FROM_REMOTE_IO_SERVER }\n+\n",
  "problem_statement": "Support for `_path` and `_file` virtual columns for table function `url`.\n```\r\nplay-eu :) SELECT _file, count() FROM url('https://clickhouse-public-datasets.s3.amazonaws.com/wikistat/original/pageviews-20200101-00{00..59}00.gz', LineAsString) GROUP BY _file ORDER BY _file\r\n\r\nSELECT\r\n    _file,\r\n    count()\r\nFROM url('https://clickhouse-public-datasets.s3.amazonaws.com/wikistat/original/pageviews-20200101-00{00..59}00.gz', LineAsString)\r\nGROUP BY _file\r\nORDER BY _file ASC\r\n\r\nQuery id: a208a18c-02f9-47cc-8848-a6895bba3b49\r\n\r\n\r\n0 rows in set. Elapsed: 0.023 sec. \r\n\r\nReceived exception from server (version 23.4.1):\r\nCode: 47. DB::Exception: Received from localhost:9000. DB::Exception: Missing columns: '_file' while processing query: 'SELECT _file, count() FROM url('https://clickhouse-public-datasets.s3.amazonaws.com/wikistat/original/pageviews-20200101-00{00..59}00.gz', 'LineAsString') GROUP BY _file ORDER BY _file ASC', required columns: '_file'. (UNKNOWN_IDENTIFIER)\r\n\r\nplay-eu :) SELECT _path, count() FROM url('https://clickhouse-public-datasets.s3.amazonaws.com/wikistat/original/pageviews-20200101-00{00..59}00.gz', LineAsString) GROUP BY _path ORDER BY _path\r\n\r\nSELECT\r\n    _path,\r\n    count()\r\nFROM url('https://clickhouse-public-datasets.s3.amazonaws.com/wikistat/original/pageviews-20200101-00{00..59}00.gz', LineAsString)\r\nGROUP BY _path\r\nORDER BY _path ASC\r\n\r\nQuery id: 495fdc97-0069-4da7-b2ac-af015fb45f25\r\n\r\n\r\n0 rows in set. Elapsed: 0.025 sec. \r\n\r\nReceived exception from server (version 23.4.1):\r\nCode: 47. DB::Exception: Received from localhost:9000. DB::Exception: Missing columns: '_path' while processing query: 'SELECT _path, count() FROM url('https://clickhouse-public-datasets.s3.amazonaws.com/wikistat/original/pageviews-20200101-00{00..59}00.gz', 'LineAsString') GROUP BY _path ORDER BY _path ASC', required columns: '_path'. (UNKNOWN_IDENTIFIER)\r\n```\nThe limit on the maximum number of generated addresses cannot be changed for function `url`\n```\r\nplay-eu :) SELECT _path, count() FROM url('https://clickhouse-public-datasets.s3.amazonaws.com/wikistat/original/pageviews-20200101-{00..23}{00..59}00.gz', LineAsString) GROUP BY _path ORDER BY _path\r\n\r\nSELECT\r\n    _path,\r\n    count()\r\nFROM url('https://clickhouse-public-datasets.s3.amazonaws.com/wikistat/original/pageviews-20200101-{00..23}{00..59}00.gz', LineAsString)\r\nGROUP BY _path\r\nORDER BY _path ASC\r\n\r\nQuery id: 90cd5580-a567-4af1-9b6f-ea99035053b1\r\n\r\n\r\n0 rows in set. Elapsed: 0.022 sec. \r\n\r\nReceived exception from server (version 23.4.1):\r\nCode: 36. DB::Exception: Received from localhost:9000. DB::Exception: Table function 'remote': first argument generates too many result addresses. (BAD_ARGUMENTS)\r\n\r\nplay-eu :) SET table_function_remote_max_addresses = 1000000\r\n\r\nSET table_function_remote_max_addresses = 1000000\r\n\r\nQuery id: 31702a49-0a8b-4580-88fc-a87ef2079764\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.001 sec. \r\n\r\nplay-eu :) SELECT _path, count() FROM url('https://clickhouse-public-datasets.s3.amazonaws.com/wikistat/original/pageviews-20200101-{00..23}{00..59}00.gz', LineAsString) GROUP BY _path ORDER BY _path\r\n\r\nSELECT\r\n    _path,\r\n    count()\r\nFROM url('https://clickhouse-public-datasets.s3.amazonaws.com/wikistat/original/pageviews-20200101-{00..23}{00..59}00.gz', LineAsString)\r\nGROUP BY _path\r\nORDER BY _path ASC\r\n\r\nQuery id: 1e18851a-f9d7-43e4-84ef-3ffd34fb4b14\r\n\r\n\r\n0 rows in set. Elapsed: 0.001 sec. \r\n\r\nReceived exception from server (version 23.4.1):\r\nCode: 36. DB::Exception: Received from localhost:9000. DB::Exception: Table function 'remote': first argument generates too many result addresses. (BAD_ARGUMENTS)\r\n```\r\n\r\nAlso, take a look at the exception message. It is wrong.\n",
  "hints_text": "Is this two separate tasks from https://github.com/ClickHouse/ClickHouse/issues/49232 ?\nYes, but they can be solved at once.\ntake\n@alexey-milovidov Seems like `SET glob_expansion_max_elements = 1000000` will work for function url?\r\n<img width=\"1920\" alt=\"\u5fae\u4fe1\u56fe\u7247_20230428231434\" src=\"https://user-images.githubusercontent.com/49604965/235186553-b5dcc363-0866-433e-b04e-2b35987ecd5b.png\">\r\n\n@Ziy1-Tan ok. Then only the error message has to be fixed.",
  "created_at": "2023-05-01T13:48:52Z"
}