diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index 8afc08da21ad..d3e776958201 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -518,6 +518,7 @@ class IColumn;
     M(Bool, output_format_write_statistics, true, "Write statistics about read rows, bytes, time elapsed in suitable output formats.", 0) \
     M(Bool, output_format_pretty_row_numbers, false, "Add row numbers before each row for pretty output format", 0) \
     M(Bool, insert_distributed_one_random_shard, false, "If setting is enabled, inserting into distributed table will choose a random shard to write when there is no sharding key", 0) \
+    M(Bool, cross_to_inner_join_rewrite, true, "Use inner join instead of comma/cross join if possible", 0) \
 
 
 // End of FORMAT_FACTORY_SETTINGS
diff --git a/src/Interpreters/CrossToInnerJoinVisitor.cpp b/src/Interpreters/CrossToInnerJoinVisitor.cpp
index 604bfc7774f9..c4d330831bba 100644
--- a/src/Interpreters/CrossToInnerJoinVisitor.cpp
+++ b/src/Interpreters/CrossToInnerJoinVisitor.cpp
@@ -1,20 +1,21 @@
 #include <Common/typeid_cast.h>
 #include <Functions/FunctionsComparison.h>
 #include <Functions/FunctionsLogical.h>
+#include <IO/WriteHelpers.h>
 #include <Interpreters/CrossToInnerJoinVisitor.h>
 #include <Interpreters/DatabaseAndTableWithAlias.h>
 #include <Interpreters/IdentifierSemantic.h>
 #include <Interpreters/misc.h>
+#include <Parsers/ASTExpressionList.h>
+#include <Parsers/ASTFunction.h>
+#include <Parsers/ASTIdentifier.h>
+#include <Parsers/ASTLiteral.h>
 #include <Parsers/ASTSelectQuery.h>
 #include <Parsers/ASTSubquery.h>
 #include <Parsers/ASTTablesInSelectQuery.h>
-#include <Parsers/ASTIdentifier.h>
-#include <Parsers/ASTFunction.h>
-#include <Parsers/ASTExpressionList.h>
-#include <Parsers/ParserTablesInSelectQuery.h>
 #include <Parsers/ExpressionListParsers.h>
+#include <Parsers/ParserTablesInSelectQuery.h>
 #include <Parsers/parseQuery.h>
-#include <IO/WriteHelpers.h>
 
 namespace DB
 {
@@ -80,147 +81,150 @@ struct JoinedElement
     ASTTableJoin * join = nullptr;
 };
 
-bool isComparison(const String & name)
-{
-    return name == NameEquals::name ||
-        name == NameNotEquals::name ||
-        name == NameLess::name ||
-        name == NameGreater::name ||
-        name == NameLessOrEquals::name ||
-        name == NameGreaterOrEquals::name;
-}
-
-/// It checks if where expression could be moved to JOIN ON expression partially or entirely.
-class CheckExpressionVisitorData
+/// Collect all identifiers from ast
+class IdentifiersCollector
 {
 public:
-    using TypeToVisit = const ASTFunction;
-
-    CheckExpressionVisitorData(const std::vector<JoinedElement> & tables_,
-                               const std::vector<TableWithColumnNamesAndTypes> & tables_with_columns,
-                               const Aliases & aliases_)
-        : joined_tables(tables_)
-        , tables(tables_with_columns)
-        , aliases(aliases_)
-        , ands_only(true)
-    {}
-
-    void visit(const ASTFunction & node, const ASTPtr & ast)
+    using ASTIdentPtr = const ASTIdentifier *;
+    using ASTIdentifiers = std::vector<ASTIdentPtr>;
+    struct Data
     {
-        if (!ands_only)
-            return;
-
-        if (node.name == NameAnd::name)
-        {
-            if (!node.arguments || node.arguments->children.empty())
-                throw Exception("Logical error: function requires argument", ErrorCodes::LOGICAL_ERROR);
+        ASTIdentifiers idents;
+    };
 
-            for (auto & child : node.arguments->children)
-            {
-                if (const auto * func = child->as<ASTFunction>())
-                    visit(*func, child);
-                else
-                    ands_only = false;
-            }
-        }
-        else if (node.name == NameEquals::name)
-        {
-            if (size_t min_table = canMoveEqualsToJoinOn(node))
-                asts_to_join_on[min_table].push_back(ast);
-        }
-        else if (isComparison(node.name))
-        {
-            /// leave other comparisons as is
-        }
-        else if (functionIsLikeOperator(node.name) || /// LIKE, NOT LIKE, ILIKE, NOT ILIKE
-                 functionIsInOperator(node.name))  /// IN, NOT IN
-        {
-            /// leave as is. It's not possible to make push down here cause of unknown aliases and not implemented JOIN predicates.
-            ///     select a as b form t1, t2 where t1.x = t2.x and b in(42)
-            ///     select a as b form t1 inner join t2 on t1.x = t2.x and b in(42)
-        }
-        else
-        {
-            ands_only = false;
-            asts_to_join_on.clear();
-        }
+    static void visit(const ASTPtr & node, Data & data)
+    {
+        if (const auto * ident = node->as<ASTIdentifier>())
+            data.idents.push_back(ident);
     }
 
-    bool complex() const { return !ands_only; }
-    bool matchAny(size_t t) const { return asts_to_join_on.count(t); }
-
-    ASTPtr makeOnExpression(size_t table_pos)
+    static bool needChildVisit(const ASTPtr &, const ASTPtr &)
     {
-        if (!asts_to_join_on.count(table_pos))
-            return {};
-
-        std::vector<ASTPtr> & expressions = asts_to_join_on[table_pos];
-
-        if (expressions.size() == 1)
-            return expressions[0]->clone();
+        return true;
+    }
 
-        std::vector<ASTPtr> arguments;
-        arguments.reserve(expressions.size());
-        for (auto & ast : expressions)
-            arguments.emplace_back(ast->clone());
+    static ASTIdentifiers collect(const ASTPtr & node)
+    {
+        IdentifiersCollector::Data ident_data;
+        ConstInDepthNodeVisitor<IdentifiersCollector, true> ident_visitor(ident_data);
+        ident_visitor.visit(node);
+        return ident_data.idents;
+    }
+};
 
-        return makeASTFunction(NameAnd::name, std::move(arguments));
+/// Split expression `expr_1 AND expr_2 AND ... AND expr_n` into vector `[expr_1, expr_2, ..., expr_n]`
+void collectConjunctions(const ASTPtr & node, std::vector<ASTPtr> & members)
+{
+    if (const auto * func = node->as<ASTFunction>(); func && func->name == NameAnd::name)
+    {
+        for (const auto & child : func->arguments->children)
+            collectConjunctions(child, members);
+        return;
     }
+    members.push_back(node);
+}
 
-private:
-    const std::vector<JoinedElement> & joined_tables;
-    const std::vector<TableWithColumnNamesAndTypes> & tables;
-    std::map<size_t, std::vector<ASTPtr>> asts_to_join_on;
-    const Aliases & aliases;
-    bool ands_only;
+std::vector<ASTPtr> collectConjunctions(const ASTPtr & node)
+{
+    std::vector<ASTPtr> members;
+    collectConjunctions(node, members);
+    return members;
+}
 
-    size_t canMoveEqualsToJoinOn(const ASTFunction & node)
-    {
-        if (!node.arguments)
-            throw Exception("Logical error: function requires arguments", ErrorCodes::LOGICAL_ERROR);
-        if (node.arguments->children.size() != 2)
-            return false;
+std::optional<size_t> getIdentMembership(const ASTIdentifier & ident, const std::vector<TableWithColumnNamesAndTypes> & tables)
+{
+    std::optional<size_t> table_pos = IdentifierSemantic::getMembership(ident);
+    if (table_pos)
+        return table_pos;
+    return IdentifierSemantic::chooseTableColumnMatch(ident, tables);
+}
 
-        const auto * left = node.arguments->children[0]->as<ASTIdentifier>();
-        const auto * right = node.arguments->children[1]->as<ASTIdentifier>();
-        if (!left || !right)
-            return false;
+std::optional<size_t> getIdentsMembership(const ASTPtr ast,
+                                          const std::vector<TableWithColumnNamesAndTypes> & tables,
+                                          const Aliases & aliases)
+{
+    auto idents = IdentifiersCollector::collect(ast);
 
+    std::optional<size_t> result;
+    for (const auto * ident : idents)
+    {
         /// Moving expressions that use column aliases is not supported.
-        if (left->isShort() && aliases.count(left->shortName()))
-            return false;
-        if (right->isShort() && aliases.count(right->shortName()))
-            return false;
+        if (ident->isShort() && aliases.count(ident->shortName()))
+            return {};
+        const auto pos = getIdentMembership(*ident, tables);
+        if (!pos)
+            return {};
+        if (result && *pos != *result)
+            return {};
+        result = pos;
+    }
+    return result;
+}
 
-        return checkIdentifiers(*left, *right);
+bool isAllowedToRewriteCrossJoin(const ASTPtr & node, const Aliases & aliases)
+{
+    if (node->as<ASTFunction>())
+    {
+        auto idents = IdentifiersCollector::collect(node);
+        for (const auto * ident : idents)
+        {
+            if (ident->isShort() && aliases.count(ident->shortName()))
+                return false;
+        }
+        return true;
     }
+    return node->as<ASTIdentifier>() || node->as<ASTLiteral>();
+}
 
-    /// Check if the identifiers are from different joined tables. If it's a self joint, tables should have aliases.
-    /// select * from t1 a cross join t2 b where a.x = b.x
-    /// @return table position to attach expression to or 0.
-    size_t checkIdentifiers(const ASTIdentifier & left, const ASTIdentifier & right)
+/// Return mapping table_no -> expression with expression that can be moved into JOIN ON section
+std::map<size_t, std::vector<ASTPtr>> moveExpressionToJoinOn(
+    const ASTPtr & ast,
+    const std::vector<JoinedElement> & joined_tables,
+    const std::vector<TableWithColumnNamesAndTypes> & tables,
+    const Aliases & aliases)
+{
+    std::map<size_t, std::vector<ASTPtr>> asts_to_join_on;
+    for (const auto & node : collectConjunctions(ast))
     {
-        std::optional<size_t> left_table_pos = IdentifierSemantic::getMembership(left);
-        if (!left_table_pos)
-            left_table_pos = IdentifierSemantic::chooseTableColumnMatch(left, tables);
+        if (const auto * func = node->as<ASTFunction>(); func && func->name == NameEquals::name)
+        {
+            if (!func->arguments || func->arguments->children.size() != 2)
+                return {};
 
-        std::optional<size_t> right_table_pos = IdentifierSemantic::getMembership(right);
-        if (!right_table_pos)
-            right_table_pos = IdentifierSemantic::chooseTableColumnMatch(right, tables);
+            /// Check if the identifiers are from different joined tables.
+            /// If it's a self joint, tables should have aliases.
+            auto left_table_pos = getIdentsMembership(func->arguments->children[0], tables, aliases);
+            auto right_table_pos = getIdentsMembership(func->arguments->children[1], tables, aliases);
 
-        if (left_table_pos && right_table_pos && (*left_table_pos != *right_table_pos))
-        {
-            size_t table_pos = std::max(*left_table_pos, *right_table_pos);
-            if (joined_tables[table_pos].canAttachOnExpression())
-                return table_pos;
+            /// Identifiers from different table move to JOIN ON
+            if (left_table_pos && right_table_pos && *left_table_pos != *right_table_pos)
+            {
+                size_t table_pos = std::max(*left_table_pos, *right_table_pos);
+                if (joined_tables[table_pos].canAttachOnExpression())
+                    asts_to_join_on[table_pos].push_back(node);
+                else
+                    return {};
+            }
         }
-        return 0;
+
+        if (!isAllowedToRewriteCrossJoin(node, aliases))
+            return {};
     }
-};
+    return asts_to_join_on;
+}
+
+ASTPtr makeOnExpression(const std::vector<ASTPtr> & expressions)
+{
+    if (expressions.size() == 1)
+        return expressions[0]->clone();
 
-using CheckExpressionMatcher = ConstOneTypeMatcher<CheckExpressionVisitorData, NeedChild::none>;
-using CheckExpressionVisitor = ConstInDepthNodeVisitor<CheckExpressionMatcher, true>;
+    std::vector<ASTPtr> arguments;
+    arguments.reserve(expressions.size());
+    for (const auto & ast : expressions)
+        arguments.emplace_back(ast->clone());
 
+    return makeASTFunction(NameAnd::name, std::move(arguments));
+}
 
 bool getTables(ASTSelectQuery & select, std::vector<JoinedElement> & joined_tables, size_t & num_comma)
 {
@@ -320,7 +324,6 @@ void CrossToInnerJoinMatcher::visit(ASTSelectQuery & select, ASTPtr &, Data & da
     }
 
     /// COMMA to CROSS
-
     if (num_comma)
     {
         for (auto & table : joined_tables)
@@ -328,22 +331,17 @@ void CrossToInnerJoinMatcher::visit(ASTSelectQuery & select, ASTPtr &, Data & da
     }
 
     /// CROSS to INNER
-
-    if (!select.where())
-        return;
-
-    CheckExpressionVisitor::Data visitor_data{joined_tables, data.tables_with_columns, data.aliases};
-    CheckExpressionVisitor(visitor_data).visit(select.where());
-
-    if (visitor_data.complex())
-        return;
-
-    for (size_t i = 1; i < joined_tables.size(); ++i)
+    if (data.cross_to_inner_join_rewrite && select.where())
     {
-        if (visitor_data.matchAny(i))
+        auto asts_to_join_on = moveExpressionToJoinOn(select.where(), joined_tables, data.tables_with_columns, data.aliases);
+        for (size_t i = 1; i < joined_tables.size(); ++i)
         {
-            if (joined_tables[i].rewriteCrossToInner(visitor_data.makeOnExpression(i)))
-                data.done = true;
+            const auto & expr_it = asts_to_join_on.find(i);
+            if (expr_it != asts_to_join_on.end())
+            {
+                if (joined_tables[i].rewriteCrossToInner(makeOnExpression(expr_it->second)))
+                    data.done = true;
+            }
         }
     }
 }
diff --git a/src/Interpreters/CrossToInnerJoinVisitor.h b/src/Interpreters/CrossToInnerJoinVisitor.h
index 7cd5c93b1e38..885cf8162c10 100644
--- a/src/Interpreters/CrossToInnerJoinVisitor.h
+++ b/src/Interpreters/CrossToInnerJoinVisitor.h
@@ -19,6 +19,7 @@ class CrossToInnerJoinMatcher
         const Aliases & aliases;
         const String current_database;
         bool done = false;
+        bool cross_to_inner_join_rewrite = true;
     };
 
     static bool needChildVisit(ASTPtr &, const ASTPtr &);
diff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp
index 341af15cd246..d0c8966cf077 100644
--- a/src/Interpreters/InterpreterSelectQuery.cpp
+++ b/src/Interpreters/InterpreterSelectQuery.cpp
@@ -204,7 +204,7 @@ static Context getSubqueryContext(const Context & context)
     return subquery_context;
 }
 
-static void rewriteMultipleJoins(ASTPtr & query, const TablesWithColumns & tables, const String & database)
+static void rewriteMultipleJoins(ASTPtr & query, const TablesWithColumns & tables, const String & database, const Settings & settings)
 {
     ASTSelectQuery & select = query->as<ASTSelectQuery &>();
 
@@ -214,6 +214,7 @@ static void rewriteMultipleJoins(ASTPtr & query, const TablesWithColumns & table
     QueryAliasesNoSubqueriesVisitor(aliases).visit(select.select());
 
     CrossToInnerJoinVisitor::Data cross_to_inner{tables, aliases, database};
+    cross_to_inner.cross_to_inner_join_rewrite = settings.cross_to_inner_join_rewrite;
     CrossToInnerJoinVisitor(cross_to_inner).visit(query);
 
     JoinToSubqueryTransformVisitor::Data join_to_subs_data{tables, aliases};
@@ -331,7 +332,7 @@ InterpreterSelectQuery::InterpreterSelectQuery(
     /// Rewrite JOINs
     if (!has_input && joined_tables.tablesCount() > 1)
     {
-        rewriteMultipleJoins(query_ptr, joined_tables.tablesWithColumns(), context->getCurrentDatabase());
+        rewriteMultipleJoins(query_ptr, joined_tables.tablesWithColumns(), context->getCurrentDatabase(), context->getSettingsRef());
 
         joined_tables.reset(getSelectQuery());
         joined_tables.resolveTables();
