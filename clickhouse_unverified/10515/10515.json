{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 10515,
  "instance_id": "ClickHouse__ClickHouse-10515",
  "issue_numbers": [
    "5206"
  ],
  "base_commit": "2f06a7b4c15ec2549d18f63c2fe1f8d1b65b7ce4",
  "patch": "diff --git a/src/Functions/FunctionsComparison.h b/src/Functions/FunctionsComparison.h\nindex 5671a8674e82..61cba5487047 100644\n--- a/src/Functions/FunctionsComparison.h\n+++ b/src/Functions/FunctionsComparison.h\n@@ -849,7 +849,7 @@ class FunctionComparison : public IFunction\n         {\n             time_t date_time;\n             ReadBufferFromMemory in(string_value.data, string_value.size);\n-            readDateTimeText(date_time, in);\n+            readDateTimeText(date_time, in, dynamic_cast<const DataTypeDateTime &>(*number_type).getTimeZone());\n             if (!in.eof())\n                 throw Exception(\"String is too long for DateTime: \" + string_value.toString(), ErrorCodes::TOO_LARGE_STRING_SIZE);\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01265_datetime_string_comparison_felix_mueller.reference b/tests/queries/0_stateless/01265_datetime_string_comparison_felix_mueller.reference\nnew file mode 100644\nindex 000000000000..a76c5db14aff\n--- /dev/null\n+++ b/tests/queries/0_stateless/01265_datetime_string_comparison_felix_mueller.reference\n@@ -0,0 +1,4 @@\n+1557136800\t1557169200\n+1\n+1\n+1\ndiff --git a/tests/queries/0_stateless/01265_datetime_string_comparison_felix_mueller.sql b/tests/queries/0_stateless/01265_datetime_string_comparison_felix_mueller.sql\nnew file mode 100644\nindex 000000000000..41cc5b532390\n--- /dev/null\n+++ b/tests/queries/0_stateless/01265_datetime_string_comparison_felix_mueller.sql\n@@ -0,0 +1,29 @@\n+DROP TABLE IF EXISTS tztest;\n+\n+CREATE TABLE tztest\n+(\n+    timeBerlin DateTime('Europe/Berlin'), \n+    timeLA DateTime('America/Los_Angeles')\n+)\n+ENGINE = Memory;\n+\n+INSERT INTO tztest (timeBerlin, timeLA) VALUES ('2019-05-06 12:00:00', '2019-05-06 12:00:00');\n+\n+SELECT\n+    toUnixTimestamp(timeBerlin),\n+    toUnixTimestamp(timeLA)\n+FROM tztest;\n+\n+SELECT 1\n+FROM tztest\n+WHERE timeBerlin = '2019-05-06 12:00:00';\n+\n+SELECT 1\n+FROM tztest\n+WHERE timeLA = '2019-05-06 12:00:00';\n+\n+SELECT 1\n+FROM tztest\n+WHERE '2019-05-06 12:00:00' = timeBerlin;\n+\n+DROP TABLE tztest;\n",
  "problem_statement": "DateTime TimeZone Behavior Inconsistent\n**Describe the bug**\r\nClickHouse uses Timezone-local times when inserting values, but Server-local times when querying. This is inconsistent.\r\n\r\n**How to reproduce**\r\n* Which ClickHouse server version to use: 19.5.2.6\r\n* Which interface to use, if matters: Native clickhouse-client\r\n* Non-default settings, if any: Server timezone = UTC\r\n* `CREATE TABLE` statements for all tables involved:\r\n```\r\nCREATE TABLE tztest\r\n(\r\n    timeBerlin DateTime('Europe/Berlin'), \r\n    timeLA DateTime('America/Los_Angeles')\r\n)\r\nENGINE = Memory\r\n```\r\n* Queries to run that lead to unexpected result:\r\n```\r\nINSERT INTO tztest (timeBerlin, timeLA) VALUES ('2019-05-06 12:00:00', '2019-05-06 12:00:00');\r\n```\r\n```\r\nSELECT \r\n    toUnixTimestamp(timeBerlin), \r\n    toUnixTimestamp(timeLA)\r\nFROM tztest \r\n\r\n\u250c\u2500toUnixTimestamp(timeBerlin)\u2500\u252c\u2500toUnixTimestamp(timeLA)\u2500\u2510\r\n\u2502                  1557136800 \u2502              1557169200 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n```\r\nSELECT 1\r\nFROM tztest \r\nWHERE timeBerlin = '2019-05-06 12:00:00'\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.003 sec. \r\n```\r\n```\r\nSELECT 1\r\nFROM tztest \r\nWHERE timeLA = '2019-05-06 12:00:00'\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.003 sec.\r\n```\r\n\r\n**Expected behavior**\r\nThe queries should have returned the row, or ClickHouse should have used the server timezone when inserting the values. Either way, ClickHouse should behave consistent.\r\n\r\n\n",
  "hints_text": "It is not so obvious to say what behaviour is correct. \r\n\r\nIf you use datatype with timezone specified you force ClickHouse to use the formatting rules for that timezone when reading/writing time from that field. That's why it was read according to tz rules you've specified in datatype. \r\n\r\nWhen querying you're comparing two datestamps. One stored in the table (with tz forced) and another provided in query. The timestamp used in query has no timezone enforced so it's created using system default tz. \r\n\r\nSo that is expected. Maybe tz rules should be also enforced for inlined timestamp predicate when comparing with a column which has enforced tz in data type. But it can also create misunderstanding. \r\n\r\nCurrently, it's really easy to workaround:\r\n```\r\nSELECT 1 FROM tztest WHERE timeBerlin = toDateTime('2019-05-06 12:00:00', 'Europe/Berlin').\r\n```\r\n\r\nDoes it make sense?\n> It is not so obvious to say what behaviour is correct.\r\n\r\nI agree. Particularly when time zones or leap seconds are involved :smile: \r\n\r\nI am not an expert on this issue, and if the current behavior fits most use cases or is consistent with SQL standard or with the behavior of many popular databases, it's OK. I would like to point out though that it might not be intuitive for some users:\r\n\r\n```\r\nSELECT timeBerlin\r\nFROM tztest \r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500timeBerlin\u2500\u2510\r\n\u2502 2019-05-06 12:00:00 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n```\r\nSELECT 1\r\nFROM tztest \r\nWHERE timeBerlin = '2019-05-06 12:00:00'\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.006 sec.\r\n```\r\n\nYes, it makes sense.\r\n\r\nWhen you type `timeBerlin = '2019-05-06 12:00:00'` you are comparing DateTime column with constant string literal. It is already a special case (it is supported only for constant string literals) and it is different from `timeBerlin = toDateTime('2019-05-06 12:00:00')` when you are comparing DateTime with DateTime.\r\n\r\nIt will be reasonable to parse string using timezone of the DateTime data type that the string is compared to.",
  "created_at": "2020-04-26T22:14:45Z"
}