{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 48000,
  "instance_id": "ClickHouse__ClickHouse-48000",
  "issue_numbers": [
    "43755"
  ],
  "base_commit": "f809f1b812725081bdefadf31efbb3056a169cd4",
  "patch": "diff --git a/docs/en/sql-reference/functions/type-conversion-functions.md b/docs/en/sql-reference/functions/type-conversion-functions.md\nindex 90f6cf0aa7d9..6e4686a0b930 100644\n--- a/docs/en/sql-reference/functions/type-conversion-functions.md\n+++ b/docs/en/sql-reference/functions/type-conversion-functions.md\n@@ -1188,6 +1188,16 @@ SELECT parseDateTime('2021-01-04+23:00:00', '%Y-%m-%d+%H:%i:%s')\n \n Alias: `TO_TIMESTAMP`.\n \n+## parseDateTimeOrZero\n+\n+Same as for [parseDateTime](#type_conversion_functions-parseDateTime) except that it returns zero date when it encounters a date format that cannot be processed.\n+\n+## parseDateTimeOrNull\n+\n+Same as for [parseDateTime](#type_conversion_functions-parseDateTime) except that it returns `NULL` when it encounters a date format that cannot be processed.\n+\n+Alias: `str_to_date`.\n+\n ## parseDateTimeInJodaSyntax {#type_conversion_functions-parseDateTimeInJodaSyntax}\n \n Similar to [parseDateTime](#parsedatetime), except that the format string is in [Joda](https://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html) instead of MySQL syntax.\n@@ -1227,6 +1237,14 @@ SELECT parseDateTimeInJodaSyntax('2023-02-24 14:53:31', 'yyyy-MM-dd HH:mm:ss', '\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## parseDateTimeInJodaSyntaxOrZero\n+\n+Same as for [parseDateTimeInJodaSyntax](#type_conversion_functions-parseDateTimeInJodaSyntax) except that it returns zero date when it encounters a date format that cannot be processed.\n+\n+## parseDateTimeInJodaSyntaxOrNull\n+\n+Same as for [parseDateTimeInJodaSyntax](#type_conversion_functions-parseDateTimeInJodaSyntax) except that it returns `NULL` when it encounters a date format that cannot be processed.\n+\n ## parseDateTimeBestEffort\n ## parseDateTime32BestEffort\n \ndiff --git a/src/Functions/parseDateTime.cpp b/src/Functions/parseDateTime.cpp\nindex abee7e0d8f8d..6a7a6010d4b0 100644\n--- a/src/Functions/parseDateTime.cpp\n+++ b/src/Functions/parseDateTime.cpp\n@@ -1,3 +1,5 @@\n+#include <Columns/ColumnNullable.h>\n+#include <Columns/ColumnsNumber.h>\n #include <Columns/ColumnString.h>\n #include <Columns/ColumnsDateTime.h>\n #include <DataTypes/DataTypeDateTime.h>\n@@ -452,8 +454,15 @@ namespace\n         Joda\n     };\n \n+    enum class ErrorHandling\n+    {\n+        Exception,\n+        Zero,\n+        Null\n+    };\n+\n     /// _FUNC_(str[, format, timezone])\n-    template <typename Name, ParseSyntax parse_syntax>\n+    template <typename Name, ParseSyntax parse_syntax, ErrorHandling error_handling>\n     class FunctionParseDateTimeImpl : public IFunction\n     {\n     public:\n@@ -500,11 +509,14 @@ namespace\n                     getName());\n \n             String time_zone_name = getTimeZone(arguments).getTimeZone();\n-            return std::make_shared<DataTypeDateTime>(time_zone_name);\n+            DataTypePtr date_type = std::make_shared<DataTypeDateTime>(time_zone_name);\n+            if (error_handling == ErrorHandling::Null)\n+                return std::make_shared<DataTypeNullable>(date_type);\n+            else\n+                return date_type;\n         }\n \n-        ColumnPtr\n-        executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & /*result_type*/, size_t input_rows_count) const override\n+        ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & /*result_type*/, size_t input_rows_count) const override\n         {\n             const auto * col_str = checkAndGetColumn<ColumnString>(arguments[0].column.get());\n             if (!col_str)\n@@ -518,8 +530,12 @@ namespace\n             const auto & time_zone = getTimeZone(arguments);\n             std::vector<Instruction> instructions = parseFormat(format);\n \n-            auto col_res = ColumnDateTime::create();\n-            col_res->reserve(input_rows_count);\n+            auto col_res = ColumnDateTime::create(input_rows_count);\n+\n+            ColumnUInt8::MutablePtr col_null_map;\n+            if constexpr (error_handling == ErrorHandling::Null)\n+                col_null_map = ColumnUInt8::create(input_rows_count, 0);\n+\n             auto & res_data = col_res->getData();\n \n             /// Make datetime fit in a cache line.\n@@ -527,29 +543,77 @@ namespace\n             for (size_t i = 0; i < input_rows_count; ++i)\n             {\n                 datetime.reset();\n-\n                 StringRef str_ref = col_str->getDataAt(i);\n                 Pos cur = str_ref.data;\n                 Pos end = str_ref.data + str_ref.size;\n+                bool error = false;\n+\n                 for (const auto & instruction : instructions)\n                 {\n-                    cur = instruction.perform(cur, end, datetime);\n+                    try\n+                    {\n+                        cur = instruction.perform(cur, end, datetime);\n+                    }\n+                    catch (...)\n+                    {\n+                        if constexpr (error_handling == ErrorHandling::Zero)\n+                        {\n+                            res_data[i] = 0;\n+                            error = true;\n+                            break;\n+                        }\n+                        else if constexpr (error_handling == ErrorHandling::Null)\n+                        {\n+                            res_data[i] = 0;\n+                            col_null_map->getData()[i] = 1;\n+                            error = true;\n+                            break;\n+                        }\n+                        else\n+                        {\n+                            static_assert(error_handling == ErrorHandling::Exception);\n+                            throw;\n+                        }\n+                    }\n                 }\n \n-                // Ensure all input was consumed.\n-                if (cur < end)\n-                    throw Exception(\n-                        ErrorCodes::CANNOT_PARSE_DATETIME,\n-                        \"Invalid format input {} is malformed at {}\",\n-                        str_ref.toView(),\n-                        std::string_view(cur, end - cur));\n+                if (error)\n+                    continue;\n \n-                Int64 time = datetime.buildDateTime(time_zone);\n-                res_data.push_back(static_cast<UInt32>(time));\n+                try\n+                {\n+                    /// Ensure all input was consumed\n+                    if (cur < end)\n+                        throw Exception(\n+                            ErrorCodes::CANNOT_PARSE_DATETIME,\n+                            \"Invalid format input {} is malformed at {}\",\n+                            str_ref.toView(),\n+                            std::string_view(cur, end - cur));\n+                    Int64 time = datetime.buildDateTime(time_zone);\n+                    res_data[i] = static_cast<UInt32>(time);\n+                }\n+                catch (...)\n+                {\n+                    if constexpr (error_handling == ErrorHandling::Zero)\n+                        res_data[i] = 0;\n+                    else if constexpr (error_handling == ErrorHandling::Null)\n+                    {\n+                        res_data[i] = 0;\n+                        col_null_map->getData()[i] = 1;\n+                    }\n+                    else\n+                    {\n+                        static_assert(error_handling == ErrorHandling::Exception);\n+                        throw;\n+                    }\n+                }\n             }\n \n-            return col_res;\n-        }\n+            if constexpr (error_handling == ErrorHandling::Null)\n+                return ColumnNullable::create(std::move(col_res), std::move(col_null_map));\n+            else\n+                return col_res;\n+            }\n \n \n     private:\n@@ -1753,23 +1817,50 @@ namespace\n         static constexpr auto name = \"parseDateTime\";\n     };\n \n+    struct NameParseDateTimeOrZero\n+    {\n+        static constexpr auto name = \"parseDateTimeOrZero\";\n+    };\n+\n+    struct NameParseDateTimeOrNull\n+    {\n+        static constexpr auto name = \"parseDateTimeOrNull\";\n+    };\n+\n     struct NameParseDateTimeInJodaSyntax\n     {\n         static constexpr auto name = \"parseDateTimeInJodaSyntax\";\n     };\n \n+    struct NameParseDateTimeInJodaSyntaxOrZero\n+    {\n+        static constexpr auto name = \"parseDateTimeInJodaSyntaxOrZero\";\n+    };\n+\n+    struct NameParseDateTimeInJodaSyntaxOrNull\n+    {\n+        static constexpr auto name = \"parseDateTimeInJodaSyntaxOrNull\";\n+    };\n \n-    using FunctionParseDateTime = FunctionParseDateTimeImpl<NameParseDateTime, ParseSyntax::MySQL>;\n-    using FunctionParseDateTimeInJodaSyntax\n-        = FunctionParseDateTimeImpl<NameParseDateTimeInJodaSyntax, ParseSyntax::Joda>;\n+    using FunctionParseDateTime = FunctionParseDateTimeImpl<NameParseDateTime, ParseSyntax::MySQL, ErrorHandling::Exception>;\n+    using FunctionParseDateTimeOrZero = FunctionParseDateTimeImpl<NameParseDateTimeOrZero, ParseSyntax::MySQL, ErrorHandling::Zero>;\n+    using FunctionParseDateTimeOrNull = FunctionParseDateTimeImpl<NameParseDateTimeOrNull, ParseSyntax::MySQL, ErrorHandling::Null>;\n+    using FunctionParseDateTimeInJodaSyntax = FunctionParseDateTimeImpl<NameParseDateTimeInJodaSyntax, ParseSyntax::Joda, ErrorHandling::Exception>;\n+    using FunctionParseDateTimeInJodaSyntaxOrZero = FunctionParseDateTimeImpl<NameParseDateTimeInJodaSyntaxOrZero, ParseSyntax::Joda, ErrorHandling::Zero>;\n+    using FunctionParseDateTimeInJodaSyntaxOrNull = FunctionParseDateTimeImpl<NameParseDateTimeInJodaSyntaxOrNull, ParseSyntax::Joda, ErrorHandling::Null>;\n }\n \n REGISTER_FUNCTION(ParseDateTime)\n {\n     factory.registerFunction<FunctionParseDateTime>();\n     factory.registerAlias(\"TO_UNIXTIME\", FunctionParseDateTime::name);\n+    factory.registerFunction<FunctionParseDateTimeOrZero>();\n+    factory.registerFunction<FunctionParseDateTimeOrNull>();\n+    factory.registerAlias(\"str_to_date\", FunctionParseDateTimeOrNull::name);\n \n     factory.registerFunction<FunctionParseDateTimeInJodaSyntax>();\n+    factory.registerFunction<FunctionParseDateTimeInJodaSyntaxOrZero>();\n+    factory.registerFunction<FunctionParseDateTimeInJodaSyntaxOrNull>();\n }\n \n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\nindex 4ae98bda16d7..6682f5668ead 100644\n--- a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\n+++ b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\n@@ -530,6 +530,10 @@ parseDateTimeBestEffortUS\n parseDateTimeBestEffortUSOrNull\n parseDateTimeBestEffortUSOrZero\n parseDateTimeInJodaSyntax\n+parseDateTimeInJodaSyntaxOrNull\n+parseDateTimeInJodaSyntaxOrZero\n+parseDateTimeOrNull\n+parseDateTimeOrZero\n parseTimeDelta\n partitionId\n path\ndiff --git a/tests/queries/0_stateless/02668_parse_datetime.reference b/tests/queries/0_stateless/02668_parse_datetime.reference\nindex b893c1bc6e95..f39655c6a414 100644\n--- a/tests/queries/0_stateless/02668_parse_datetime.reference\n+++ b/tests/queries/0_stateless/02668_parse_datetime.reference\n@@ -197,3 +197,16 @@ select parseDateTime('2019-07-03 11:04:10', '%Y-%m-%d %H:%i:%s', 'UTC') = toDate\n 1\n select parseDateTime('10:04:11 03-07-2019', '%s:%i:%H %d-%m-%Y', 'UTC') = toDateTime('2019-07-03 11:04:10', 'UTC');\n 1\n+-- *OrZero, *OrNull, str_to_date\n+select parseDateTimeOrZero('10:04:11 03-07-2019', '%s:%i:%H %d-%m-%Y', 'UTC') = toDateTime('2019-07-03 11:04:10', 'UTC');\n+1\n+select parseDateTimeOrZero('10:04:11 invalid 03-07-2019', '%s:%i:%H %d-%m-%Y', 'UTC') = toDateTime('1970-01-01 00:00:00', 'UTC');\n+1\n+select parseDateTimeOrNull('10:04:11 03-07-2019', '%s:%i:%H %d-%m-%Y', 'UTC') = toDateTime('2019-07-03 11:04:10', 'UTC');\n+1\n+select parseDateTimeOrNull('10:04:11 invalid 03-07-2019', '%s:%i:%H %d-%m-%Y', 'UTC') IS NULL;\n+1\n+select str_to_date('10:04:11 03-07-2019', '%s:%i:%H %d-%m-%Y', 'UTC') = toDateTime('2019-07-03 11:04:10', 'UTC');\n+1\n+select str_to_date('10:04:11 invalid 03-07-2019', '%s:%i:%H %d-%m-%Y', 'UTC') IS NULL;\n+1\ndiff --git a/tests/queries/0_stateless/02668_parse_datetime.sql b/tests/queries/0_stateless/02668_parse_datetime.sql\nindex 86e8877eedcf..757c4fe2efec 100644\n--- a/tests/queries/0_stateless/02668_parse_datetime.sql\n+++ b/tests/queries/0_stateless/02668_parse_datetime.sql\n@@ -132,4 +132,12 @@ select parseDateTime('2021-01-04+23:00:00', '%Y-%m-%d+%H:%i:%s', 'UTC') = toDate\n select parseDateTime('2019-07-03 11:04:10', '%Y-%m-%d %H:%i:%s', 'UTC') = toDateTime('2019-07-03 11:04:10', 'UTC');\n select parseDateTime('10:04:11 03-07-2019', '%s:%i:%H %d-%m-%Y', 'UTC') = toDateTime('2019-07-03 11:04:10', 'UTC');\n \n--- { echoOff }\n\\ No newline at end of file\n+-- *OrZero, *OrNull, str_to_date\n+select parseDateTimeOrZero('10:04:11 03-07-2019', '%s:%i:%H %d-%m-%Y', 'UTC') = toDateTime('2019-07-03 11:04:10', 'UTC');\n+select parseDateTimeOrZero('10:04:11 invalid 03-07-2019', '%s:%i:%H %d-%m-%Y', 'UTC') = toDateTime('1970-01-01 00:00:00', 'UTC');\n+select parseDateTimeOrNull('10:04:11 03-07-2019', '%s:%i:%H %d-%m-%Y', 'UTC') = toDateTime('2019-07-03 11:04:10', 'UTC');\n+select parseDateTimeOrNull('10:04:11 invalid 03-07-2019', '%s:%i:%H %d-%m-%Y', 'UTC') IS NULL;\n+select str_to_date('10:04:11 03-07-2019', '%s:%i:%H %d-%m-%Y', 'UTC') = toDateTime('2019-07-03 11:04:10', 'UTC');\n+select str_to_date('10:04:11 invalid 03-07-2019', '%s:%i:%H %d-%m-%Y', 'UTC') IS NULL;\n+\n+-- { echoOff }\ndiff --git a/tests/queries/0_stateless/02668_parse_datetime_in_joda_syntax.reference b/tests/queries/0_stateless/02668_parse_datetime_in_joda_syntax.reference\nindex 7402f104ae48..124836d6118e 100644\n--- a/tests/queries/0_stateless/02668_parse_datetime_in_joda_syntax.reference\n+++ b/tests/queries/0_stateless/02668_parse_datetime_in_joda_syntax.reference\n@@ -344,3 +344,12 @@ select parseDateTimeInJodaSyntax('-1', 's', 'UTC'); -- { serverError CANNOT_PARS\n select parseDateTimeInJodaSyntax('123456789', 's', 'UTC'); -- { serverError CANNOT_PARSE_DATETIME }\n -- integer overflow in AST Fuzzer\n select parseDateTimeInJodaSyntax('19191919191919191919191919191919', 'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC', 'UTC'); -- { serverError CANNOT_PARSE_DATETIME }\n+-- *OrZero, *OrNull\n+select parseDateTimeInJodaSyntaxOrZero('2001 366 2000', 'yyyy D yyyy', 'UTC') = toDateTime('2000-12-31', 'UTC');\n+1\n+select parseDateTimeInJodaSyntaxOrZero('2001 invalid 366 2000', 'yyyy D yyyy', 'UTC') = toDateTime('1970-01-01', 'UTC');\n+1\n+select parseDateTimeInJodaSyntaxOrNull('2001 366 2000', 'yyyy D yyyy', 'UTC') = toDateTime('2000-12-31', 'UTC');\n+1\n+select parseDateTimeInJodaSyntaxOrNull('2001 invalid 366 2000', 'yyyy D yyyy', 'UTC') IS NULL;\n+1\ndiff --git a/tests/queries/0_stateless/02668_parse_datetime_in_joda_syntax.sql b/tests/queries/0_stateless/02668_parse_datetime_in_joda_syntax.sql\nindex 7ce5c1a4fdd7..b2c781432d12 100644\n--- a/tests/queries/0_stateless/02668_parse_datetime_in_joda_syntax.sql\n+++ b/tests/queries/0_stateless/02668_parse_datetime_in_joda_syntax.sql\n@@ -232,4 +232,10 @@ select parseDateTimeInJodaSyntax('123456789', 's', 'UTC'); -- { serverError CANN\n -- integer overflow in AST Fuzzer\n select parseDateTimeInJodaSyntax('19191919191919191919191919191919', 'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC', 'UTC'); -- { serverError CANNOT_PARSE_DATETIME }\n \n+-- *OrZero, *OrNull\n+select parseDateTimeInJodaSyntaxOrZero('2001 366 2000', 'yyyy D yyyy', 'UTC') = toDateTime('2000-12-31', 'UTC');\n+select parseDateTimeInJodaSyntaxOrZero('2001 invalid 366 2000', 'yyyy D yyyy', 'UTC') = toDateTime('1970-01-01', 'UTC');\n+select parseDateTimeInJodaSyntaxOrNull('2001 366 2000', 'yyyy D yyyy', 'UTC') = toDateTime('2000-12-31', 'UTC');\n+select parseDateTimeInJodaSyntaxOrNull('2001 invalid 366 2000', 'yyyy D yyyy', 'UTC') IS NULL;\n+\n -- { echoOff }\n",
  "problem_statement": "MySQL dialect parity: str_to_date\n> (you don't have to strictly follow this form)\r\n\r\n**Use case**\r\nWe are using ClickHouse as a pseudo-MySQL data source for the QuickSight dashboard.\r\n\r\nWhen using calculated columns which convert strings and dates, QuickSight issues queries with MySQL's [str_to_date](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_str-to-date) function.\r\n\r\n**Describe the solution you'd like**\r\nSupport built-in `str_to_date` function OOTB\r\n\r\n**Describe alternatives you've considered**\r\nAs a workaround, customer mocks this function like this, but we don't know what unintended consequences could arise.\r\n```sql\r\ncreate or replace function str_to_date as (s1,s2) -> parseDateTimeBestEffort(s1);\r\n```\r\n\n",
  "hints_text": "The functionality is more or less covered by\r\n- #46815\r\n- #47959\r\n- #47246\r\n\r\nA meticulous emulation of SQL features of other DBMS is usually not a great idea for the reasons explained [here](https://github.com/ClickHouse/ClickHouse/pull/46581#discussion_r1117044078). But perhaps we can add an alias and/or extend the docs. I'll check.\nMySQL `str_to_date` differs from ClickHouse `parseDateTime()` in these ways:\r\n- `str_to_date` ignores trailing characters after the matching ones ... that looks weird to me, the only use case I can think of is parsing of date/time with attached comment/description (e.g. `2022-02-03 (ship date)`), nevertheless I don't think `parseDateTime()` should emulate that\r\n- `str_to_date` sets date/time components by default to 0. As a result, if the parsed string does not explicitly set them, they remain 0 and potentially produce garbage date/times, e.g. `2023-00-24` if the month isn't set (to be fair the behavior depends on setting `NO_ZERO_DATE` and can be turned off). Since ClickHouse's `DateTime` values with 0-components can't be constructed, we can't emulate this behavior.\r\n- `str_to_date` doesn't check if the combination of year-month-date is consistent, it only checks individual components. E.g. it allows to construct `2023-02-31`. Like in the previous issue, we can't support that.\r\n- `str_to_date` derives the output type (date or date with time) from the concrete parsed string and the format specifier. We can't do that in ClickHouse functions, the output type is fixed per column.\r\n- `str_to_date` returns `NULL` if the parsed string or the format specifier are NULL or there is an issue during parsing.\r\n\r\nI can add a `OrNull` or `OrZero` variant like we have for other `parseDateTime*()` functions. But it will still not be a drop-in replacement.",
  "created_at": "2023-03-25T22:46:51Z",
  "modified_files": [
    "docs/en/sql-reference/functions/type-conversion-functions.md",
    "src/Functions/parseDateTime.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference",
    "tests/queries/0_stateless/02668_parse_datetime.reference",
    "tests/queries/0_stateless/02668_parse_datetime.sql",
    "tests/queries/0_stateless/02668_parse_datetime_in_joda_syntax.reference",
    "tests/queries/0_stateless/02668_parse_datetime_in_joda_syntax.sql"
  ]
}