diff --git a/src/Dictionaries/RangeDictionaryBlockInputStream.h b/src/Dictionaries/RangeDictionaryBlockInputStream.h
index ccd77d49e0f2..6531f5cba9d3 100644
--- a/src/Dictionaries/RangeDictionaryBlockInputStream.h
+++ b/src/Dictionaries/RangeDictionaryBlockInputStream.h
@@ -17,14 +17,14 @@ namespace DB
  * BlockInputStream implementation for external dictionaries
  * read() returns single block consisting of the in-memory contents of the dictionaries
  */
-template <typename DictionaryType, typename RangeType, typename Key>
+template <typename RangeType>
 class RangeDictionaryBlockInputStream : public DictionaryBlockInputStreamBase
 {
 public:
-    using DictionaryPtr = std::shared_ptr<DictionaryType const>;
+    using Key = UInt64;
 
     RangeDictionaryBlockInputStream(
-        DictionaryPtr dictionary,
+        std::shared_ptr<const IDictionaryBase> dictionary,
         size_t max_block_size,
         const Names & column_names,
         PaddedPODArray<Key> && ids_to_fill,
@@ -40,35 +40,26 @@ class RangeDictionaryBlockInputStream : public DictionaryBlockInputStreamBase
     template <typename T>
     ColumnPtr getColumnFromPODArray(const PaddedPODArray<T> & array) const;
 
-    template <typename DictionarySpecialAttributeType, typename T>
-    void addSpecialColumn(
-        const std::optional<DictionarySpecialAttributeType> & attribute,
-        DataTypePtr type,
-        const std::string & default_name,
-        const std::unordered_set<std::string> & column_names_set,
-        const PaddedPODArray<T> & values,
-        ColumnsWithTypeAndName & columns,
-        bool force = false) const;
-
     Block fillBlock(
         const PaddedPODArray<Key> & ids_to_fill,
         const PaddedPODArray<RangeType> & block_start_dates,
         const PaddedPODArray<RangeType> & block_end_dates) const;
 
-    PaddedPODArray<Int64>
-    makeDateKey(const PaddedPODArray<RangeType> & block_start_dates, const PaddedPODArray<RangeType> & block_end_dates) const;
+    PaddedPODArray<Int64> makeDateKey(
+        const PaddedPODArray<RangeType> & block_start_dates,
+        const PaddedPODArray<RangeType> & block_end_dates) const;
 
-    DictionaryPtr dictionary;
-    Names column_names;
+    std::shared_ptr<const IDictionaryBase> dictionary;
+    NameSet column_names;
     PaddedPODArray<Key> ids;
     PaddedPODArray<RangeType> start_dates;
     PaddedPODArray<RangeType> end_dates;
 };
 
 
-template <typename DictionaryType, typename RangeType, typename Key>
-RangeDictionaryBlockInputStream<DictionaryType, RangeType, Key>::RangeDictionaryBlockInputStream(
-    DictionaryPtr dictionary_,
+template <typename RangeType>
+RangeDictionaryBlockInputStream<RangeType>::RangeDictionaryBlockInputStream(
+    std::shared_ptr<const IDictionaryBase> dictionary_,
     size_t max_block_size_,
     const Names & column_names_,
     PaddedPODArray<Key> && ids_,
@@ -76,15 +67,15 @@ RangeDictionaryBlockInputStream<DictionaryType, RangeType, Key>::RangeDictionary
     PaddedPODArray<RangeType> && block_end_dates)
     : DictionaryBlockInputStreamBase(ids_.size(), max_block_size_)
     , dictionary(dictionary_)
-    , column_names(column_names_)
+    , column_names(column_names_.begin(), column_names_.end())
     , ids(std::move(ids_))
     , start_dates(std::move(block_start_dates))
     , end_dates(std::move(block_end_dates))
 {
 }
 
-template <typename DictionaryType, typename RangeType, typename Key>
-Block RangeDictionaryBlockInputStream<DictionaryType, RangeType, Key>::getBlock(size_t start, size_t length) const
+template <typename RangeType>
+Block RangeDictionaryBlockInputStream<RangeType>::getBlock(size_t start, size_t length) const
 {
     PaddedPODArray<Key> block_ids;
     PaddedPODArray<RangeType> block_start_dates;
@@ -103,38 +94,19 @@ Block RangeDictionaryBlockInputStream<DictionaryType, RangeType, Key>::getBlock(
     return fillBlock(block_ids, block_start_dates, block_end_dates);
 }
 
-template <typename DictionaryType, typename RangeType, typename Key>
+template <typename RangeType>
 template <typename T>
-ColumnPtr RangeDictionaryBlockInputStream<DictionaryType, RangeType, Key>::getColumnFromPODArray(const PaddedPODArray<T> & array) const
+ColumnPtr RangeDictionaryBlockInputStream<RangeType>::getColumnFromPODArray(const PaddedPODArray<T> & array) const
 {
     auto column_vector = ColumnVector<T>::create();
     column_vector->getData().reserve(array.size());
-    for (T value : array)
-        column_vector->insertValue(value);
-    return column_vector;
-}
-
-template <typename DictionaryType, typename RangeType, typename Key>
-template <typename DictionarySpecialAttributeType, typename T>
-void RangeDictionaryBlockInputStream<DictionaryType, RangeType, Key>::addSpecialColumn(
-    const std::optional<DictionarySpecialAttributeType> & attribute,
-    DataTypePtr type,
-    const std::string & default_name,
-    const std::unordered_set<std::string> & column_names_set,
-    const PaddedPODArray<T> & values,
-    ColumnsWithTypeAndName & columns,
-    bool force) const
-{
-    std::string name = default_name;
-    if (attribute)
-        name = attribute->name;
+    column_vector->getData().insert(array.begin(), array.end());
 
-    if (force || column_names_set.find(name) != column_names_set.end())
-        columns.emplace_back(getColumnFromPODArray(values), type, name);
+    return column_vector;
 }
 
-template <typename DictionaryType, typename RangeType, typename Key>
-PaddedPODArray<Int64> RangeDictionaryBlockInputStream<DictionaryType, RangeType, Key>::makeDateKey(
+template <typename RangeType>
+PaddedPODArray<Int64> RangeDictionaryBlockInputStream<RangeType>::makeDateKey(
     const PaddedPODArray<RangeType> & block_start_dates, const PaddedPODArray<RangeType> & block_end_dates) const
 {
     PaddedPODArray<Int64> key(block_start_dates.size());
@@ -150,8 +122,8 @@ PaddedPODArray<Int64> RangeDictionaryBlockInputStream<DictionaryType, RangeType,
 }
 
 
-template <typename DictionaryType, typename RangeType, typename Key>
-Block RangeDictionaryBlockInputStream<DictionaryType, RangeType, Key>::fillBlock(
+template <typename RangeType>
+Block RangeDictionaryBlockInputStream<RangeType>::fillBlock(
     const PaddedPODArray<Key> & ids_to_fill,
     const PaddedPODArray<RangeType> & block_start_dates,
     const PaddedPODArray<RangeType> & block_end_dates) const
@@ -159,20 +131,32 @@ Block RangeDictionaryBlockInputStream<DictionaryType, RangeType, Key>::fillBlock
     ColumnsWithTypeAndName columns;
     const DictionaryStructure & structure = dictionary->getStructure();
 
-    std::unordered_set<std::string> names(column_names.begin(), column_names.end());
-
-    addSpecialColumn(structure.id, std::make_shared<DataTypeUInt64>(), "ID", names, ids_to_fill, columns, true);
-    auto ids_column = columns.back().column;
-    addSpecialColumn(structure.range_min, structure.range_max->type, "Range Start", names, block_start_dates, columns);
-    addSpecialColumn(structure.range_max, structure.range_max->type, "Range End", names, block_end_dates, columns);
+    auto ids_column = getColumnFromPODArray(ids_to_fill);
+    const std::string & id_column_name = structure.id->name;
+    if (column_names.find(id_column_name) != column_names.end())
+        columns.emplace_back(ids_column, std::make_shared<DataTypeUInt64>(), id_column_name);
 
     auto date_key = makeDateKey(block_start_dates, block_end_dates);
     auto date_column = getColumnFromPODArray(date_key);
 
+    const std::string & range_min_column_name = structure.range_min->name;
+    if (column_names.find(range_min_column_name) != column_names.end())
+    {
+        auto range_min_column = getColumnFromPODArray(block_start_dates);
+        columns.emplace_back(range_min_column, structure.range_max->type, range_min_column_name);
+    }
+
+    const std::string & range_max_column_name = structure.range_max->name;
+    if (column_names.find(range_max_column_name) != column_names.end())
+    {
+        auto range_max_column = getColumnFromPODArray(block_end_dates);
+        columns.emplace_back(range_max_column, structure.range_max->type, range_max_column_name);
+    }
+
     for (const auto idx : ext::range(0, structure.attributes.size()))
     {
         const DictionaryAttribute & attribute = structure.attributes[idx];
-        if (names.find(attribute.name) != names.end())
+        if (column_names.find(attribute.name) != column_names.end())
         {
             ColumnPtr column = dictionary->getColumn(
                 attribute.name,
diff --git a/src/Dictionaries/RangeHashedDictionary.cpp b/src/Dictionaries/RangeHashedDictionary.cpp
index f5be04c120d2..52b6f219baca 100644
--- a/src/Dictionaries/RangeHashedDictionary.cpp
+++ b/src/Dictionaries/RangeHashedDictionary.cpp
@@ -52,7 +52,6 @@ namespace ErrorCodes
     extern const int DICTIONARY_IS_EMPTY;
     extern const int TYPE_MISMATCH;
     extern const int UNSUPPORTED_METHOD;
-    extern const int NOT_IMPLEMENTED;
 }
 
 bool RangeHashedDictionary::Range::isCorrectDate(const RangeStorageType & date)
@@ -178,10 +177,76 @@ ColumnPtr RangeHashedDictionary::getColumn(
     return result;
 }
 
-ColumnUInt8::Ptr RangeHashedDictionary::hasKeys(const Columns &, const DataTypes &) const
+ColumnUInt8::Ptr RangeHashedDictionary::hasKeys(const Columns & key_columns, const DataTypes & key_types) const
 {
-    throw Exception(ErrorCodes::NOT_IMPLEMENTED,
-        "Has not supported", getDictionaryID().getNameForLogs());
+    auto range_storage_column = key_columns[1];
+    ColumnWithTypeAndName column_to_cast = {range_storage_column->convertToFullColumnIfConst(), key_types[1], ""};
+
+    auto range_column_storage_type = std::make_shared<DataTypeInt64>();
+    auto range_column_updated = castColumnAccurate(column_to_cast, range_column_storage_type);
+
+    PaddedPODArray<Key> key_backup_storage;
+    PaddedPODArray<RangeStorageType> range_backup_storage;
+
+    const PaddedPODArray<Key> & ids = getColumnVectorData(this, key_columns[0], key_backup_storage);
+    const PaddedPODArray<RangeStorageType> & dates = getColumnVectorData(this, range_column_updated, range_backup_storage);
+
+    const auto & attribute = attributes.front();
+
+    ColumnUInt8::Ptr result;
+
+    auto type_call = [&](const auto & dictionary_attribute_type)
+    {
+        using Type = std::decay_t<decltype(dictionary_attribute_type)>;
+        using AttributeType = typename Type::AttributeType;
+        using ValueType = DictionaryValueType<AttributeType>;
+        result = hasKeysImpl<ValueType>(attribute, ids, dates);
+    };
+
+    callOnDictionaryAttributeType(attribute.type, type_call);
+
+    query_count.fetch_add(ids.size(), std::memory_order_relaxed);
+
+    return result;
+}
+
+template <typename AttributeType>
+ColumnUInt8::Ptr RangeHashedDictionary::hasKeysImpl(
+    const Attribute & attribute,
+    const PaddedPODArray<Key> & ids,
+    const PaddedPODArray<RangeStorageType> & dates) const
+{
+    auto result = ColumnUInt8::create(ids.size());
+    auto& out = result->getData();
+
+    const auto & attr = *std::get<Ptr<AttributeType>>(attribute.maps);
+
+    for (const auto row : ext::range(0, ids.size()))
+    {
+        const auto it = attr.find(ids[row]);
+
+        if (it)
+        {
+            const auto date = dates[row];
+            const auto & ranges_and_values = it->getMapped();
+            const auto val_it = std::find_if(
+                std::begin(ranges_and_values),
+                std::end(ranges_and_values),
+                [date](const Value<AttributeType> & v)
+                {
+                    return v.range.contains(date);
+                });
+
+            if (val_it != std::end(ranges_and_values))
+                out[row] = true;
+            else
+                out[row] = false;
+        }
+        else
+            out[row] = false;
+    }
+
+    return result;
 }
 
 void RangeHashedDictionary::createAttributes()
@@ -450,7 +515,9 @@ RangeHashedDictionary::getAttributeWithType(const std::string & attribute_name,
 
 template <typename RangeType>
 void RangeHashedDictionary::getIdsAndDates(
-    PaddedPODArray<Key> & ids, PaddedPODArray<RangeType> & start_dates, PaddedPODArray<RangeType> & end_dates) const
+    PaddedPODArray<Key> & ids,
+    PaddedPODArray<RangeType> & start_dates,
+    PaddedPODArray<RangeType> & end_dates) const
 {
     const auto & attribute = attributes.front();
 
@@ -458,11 +525,9 @@ void RangeHashedDictionary::getIdsAndDates(
     {
         using Type = std::decay_t<decltype(dictionary_attribute_type)>;
         using AttributeType = typename Type::AttributeType;
+        using ValueType = DictionaryValueType<AttributeType>;
 
-        if constexpr (std::is_same_v<AttributeType, String>)
-            getIdsAndDates<StringRef>(attribute, ids, start_dates, end_dates);
-        else
-            getIdsAndDates<AttributeType>(attribute, ids, start_dates, end_dates);
+        getIdsAndDates<ValueType>(attribute, ids, start_dates, end_dates);
     };
 
     callOnDictionaryAttributeType(attribute.type, type_call);
@@ -506,13 +571,20 @@ BlockInputStreamPtr RangeHashedDictionary::getBlockInputStreamImpl(const Names &
     PaddedPODArray<RangeType> end_dates;
     getIdsAndDates(ids, start_dates, end_dates);
 
-    using BlockInputStreamType = RangeDictionaryBlockInputStream<RangeHashedDictionary, RangeType, Key>;
-    auto dict_ptr = std::static_pointer_cast<const RangeHashedDictionary>(shared_from_this());
-    return std::make_shared<BlockInputStreamType>(
-        dict_ptr, max_block_size, column_names, std::move(ids), std::move(start_dates), std::move(end_dates));
+    using BlockInputStreamType = RangeDictionaryBlockInputStream<RangeType>;
+
+    auto stream = std::make_shared<BlockInputStreamType>(
+        shared_from_this(),
+        max_block_size,
+        column_names,
+        std::move(ids),
+        std::move(start_dates),
+        std::move(end_dates));
+
+    return stream;
 }
 
-struct RangeHashedDIctionaryCallGetBlockInputStreamImpl
+struct RangeHashedDictionaryCallGetBlockInputStreamImpl
 {
     BlockInputStreamPtr stream;
     const RangeHashedDictionary * dict;
@@ -532,7 +604,7 @@ BlockInputStreamPtr RangeHashedDictionary::getBlockInputStream(const Names & col
 {
     using ListType = TypeList<UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64, Int128, Float32, Float64>;
 
-    RangeHashedDIctionaryCallGetBlockInputStreamImpl callable;
+    RangeHashedDictionaryCallGetBlockInputStreamImpl callable;
     callable.dict = this;
     callable.column_names = &column_names;
     callable.max_block_size = max_block_size;
diff --git a/src/Dictionaries/RangeHashedDictionary.h b/src/Dictionaries/RangeHashedDictionary.h
index 1f93fa757758..f2b24e52dfc0 100644
--- a/src/Dictionaries/RangeHashedDictionary.h
+++ b/src/Dictionaries/RangeHashedDictionary.h
@@ -93,8 +93,6 @@ class RangeHashedDictionary final : public IDictionaryBase
     template <typename T>
     using Ptr = std::unique_ptr<Collection<T>>;
 
-    using NullableSet = HashSet<Key, DefaultHash<Key>>;
-
     struct Attribute final
     {
     public:
@@ -159,6 +157,12 @@ class RangeHashedDictionary final : public IDictionaryBase
         ValueSetter && set_value,
         DefaultValueExtractor & default_value_extractor) const;
 
+    template <typename AttributeType>
+    ColumnUInt8::Ptr hasKeysImpl(
+        const Attribute & attribute,
+        const PaddedPODArray<Key> & ids,
+        const PaddedPODArray<RangeStorageType> & dates) const;
+
     template <typename T>
     static void setAttributeValueImpl(Attribute & attribute, const Key id, const Range & range, const Field & value);
 
@@ -181,7 +185,7 @@ class RangeHashedDictionary final : public IDictionaryBase
     template <typename RangeType>
     BlockInputStreamPtr getBlockInputStreamImpl(const Names & column_names, size_t max_block_size) const;
 
-    friend struct RangeHashedDIctionaryCallGetBlockInputStreamImpl;
+    friend struct RangeHashedDictionaryCallGetBlockInputStreamImpl;
 
     const DictionaryStructure dict_struct;
     const DictionarySourcePtr source_ptr;
diff --git a/src/Functions/FunctionsExternalDictionaries.h b/src/Functions/FunctionsExternalDictionaries.h
index acf158d42eff..4177d686f573 100644
--- a/src/Functions/FunctionsExternalDictionaries.h
+++ b/src/Functions/FunctionsExternalDictionaries.h
@@ -54,7 +54,6 @@ namespace ErrorCodes
     extern const int ILLEGAL_COLUMN;
     extern const int BAD_ARGUMENTS;
     extern const int TYPE_MISMATCH;
-    extern const int NOT_IMPLEMENTED;
 }
 
 
@@ -154,13 +153,20 @@ class FunctionDictHas final : public IFunction
     String getName() const override { return name; }
 
 private:
-    size_t getNumberOfArguments() const override { return 2; }
+    size_t getNumberOfArguments() const override { return 0; }
+    bool isVariadic() const override { return true; }
+
+    bool isDeterministic() const override { return false; }
 
     bool useDefaultImplementationForConstants() const final { return true; }
+
     ColumnNumbers getArgumentsThatAreAlwaysConstant() const final { return {0}; }
 
     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
     {
+        if (arguments.size() < 2)
+            throw Exception{"Wrong argument count for function " + getName(), ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH};
+
         if (!isString(arguments[0]))
             throw Exception{"Illegal type " + arguments[0]->getName() + " of first argument of function " + getName()
                 + ", expected a string.", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};
@@ -173,8 +179,6 @@ class FunctionDictHas final : public IFunction
         return std::make_shared<DataTypeUInt8>();
     }
 
-    bool isDeterministic() const override { return false; }
-
     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override
     {
         /** Do not require existence of the dictionary if the function is called for empty columns.
@@ -194,6 +198,24 @@ class FunctionDictHas final : public IFunction
         const auto key_column = key_column_with_type.column;
         const auto key_column_type = WhichDataType(key_column_with_type.type);
 
+        ColumnPtr range_col = nullptr;
+        DataTypePtr range_col_type = nullptr;
+
+        if (dictionary_key_type == DictionaryKeyType::range)
+        {
+            if (arguments.size() != 3)
+                throw Exception{"Wrong argument count for function " + getName()
+                    + " when dictionary has key type range", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH};
+
+            range_col = arguments[2].column;
+            range_col_type = arguments[2].type;
+
+            if (!(range_col_type->isValueRepresentedByInteger() && range_col_type->getSizeOfValueInMemory() <= sizeof(Int64)))
+                throw Exception{"Illegal type " + range_col_type->getName() + " of fourth argument of function "
+                        + getName() + " must be convertible to Int64.",
+                    ErrorCodes::ILLEGAL_COLUMN};
+        }
+
         if (dictionary_key_type == DictionaryKeyType::simple)
         {
             if (!key_column_type.isUInt64())
@@ -217,7 +239,7 @@ class FunctionDictHas final : public IFunction
             return dictionary->hasKeys(key_columns, key_types);
         }
         else
-            throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Has not supported for range dictionary", dictionary->getDictionaryID().getNameForLogs());
+            return dictionary->hasKeys({key_column, range_col}, {std::make_shared<DataTypeUInt64>(), range_col_type});
     }
 
     mutable FunctionDictHelper helper;
