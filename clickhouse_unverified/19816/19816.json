{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 19816,
  "instance_id": "ClickHouse__ClickHouse-19816",
  "issue_numbers": [
    "6680"
  ],
  "base_commit": "6495de66fcd770f4a4d378bfcd8079706afb5185",
  "patch": "diff --git a/src/Dictionaries/RangeDictionaryBlockInputStream.h b/src/Dictionaries/RangeDictionaryBlockInputStream.h\nindex ccd77d49e0f2..6531f5cba9d3 100644\n--- a/src/Dictionaries/RangeDictionaryBlockInputStream.h\n+++ b/src/Dictionaries/RangeDictionaryBlockInputStream.h\n@@ -17,14 +17,14 @@ namespace DB\n  * BlockInputStream implementation for external dictionaries\n  * read() returns single block consisting of the in-memory contents of the dictionaries\n  */\n-template <typename DictionaryType, typename RangeType, typename Key>\n+template <typename RangeType>\n class RangeDictionaryBlockInputStream : public DictionaryBlockInputStreamBase\n {\n public:\n-    using DictionaryPtr = std::shared_ptr<DictionaryType const>;\n+    using Key = UInt64;\n \n     RangeDictionaryBlockInputStream(\n-        DictionaryPtr dictionary,\n+        std::shared_ptr<const IDictionaryBase> dictionary,\n         size_t max_block_size,\n         const Names & column_names,\n         PaddedPODArray<Key> && ids_to_fill,\n@@ -40,35 +40,26 @@ class RangeDictionaryBlockInputStream : public DictionaryBlockInputStreamBase\n     template <typename T>\n     ColumnPtr getColumnFromPODArray(const PaddedPODArray<T> & array) const;\n \n-    template <typename DictionarySpecialAttributeType, typename T>\n-    void addSpecialColumn(\n-        const std::optional<DictionarySpecialAttributeType> & attribute,\n-        DataTypePtr type,\n-        const std::string & default_name,\n-        const std::unordered_set<std::string> & column_names_set,\n-        const PaddedPODArray<T> & values,\n-        ColumnsWithTypeAndName & columns,\n-        bool force = false) const;\n-\n     Block fillBlock(\n         const PaddedPODArray<Key> & ids_to_fill,\n         const PaddedPODArray<RangeType> & block_start_dates,\n         const PaddedPODArray<RangeType> & block_end_dates) const;\n \n-    PaddedPODArray<Int64>\n-    makeDateKey(const PaddedPODArray<RangeType> & block_start_dates, const PaddedPODArray<RangeType> & block_end_dates) const;\n+    PaddedPODArray<Int64> makeDateKey(\n+        const PaddedPODArray<RangeType> & block_start_dates,\n+        const PaddedPODArray<RangeType> & block_end_dates) const;\n \n-    DictionaryPtr dictionary;\n-    Names column_names;\n+    std::shared_ptr<const IDictionaryBase> dictionary;\n+    NameSet column_names;\n     PaddedPODArray<Key> ids;\n     PaddedPODArray<RangeType> start_dates;\n     PaddedPODArray<RangeType> end_dates;\n };\n \n \n-template <typename DictionaryType, typename RangeType, typename Key>\n-RangeDictionaryBlockInputStream<DictionaryType, RangeType, Key>::RangeDictionaryBlockInputStream(\n-    DictionaryPtr dictionary_,\n+template <typename RangeType>\n+RangeDictionaryBlockInputStream<RangeType>::RangeDictionaryBlockInputStream(\n+    std::shared_ptr<const IDictionaryBase> dictionary_,\n     size_t max_block_size_,\n     const Names & column_names_,\n     PaddedPODArray<Key> && ids_,\n@@ -76,15 +67,15 @@ RangeDictionaryBlockInputStream<DictionaryType, RangeType, Key>::RangeDictionary\n     PaddedPODArray<RangeType> && block_end_dates)\n     : DictionaryBlockInputStreamBase(ids_.size(), max_block_size_)\n     , dictionary(dictionary_)\n-    , column_names(column_names_)\n+    , column_names(column_names_.begin(), column_names_.end())\n     , ids(std::move(ids_))\n     , start_dates(std::move(block_start_dates))\n     , end_dates(std::move(block_end_dates))\n {\n }\n \n-template <typename DictionaryType, typename RangeType, typename Key>\n-Block RangeDictionaryBlockInputStream<DictionaryType, RangeType, Key>::getBlock(size_t start, size_t length) const\n+template <typename RangeType>\n+Block RangeDictionaryBlockInputStream<RangeType>::getBlock(size_t start, size_t length) const\n {\n     PaddedPODArray<Key> block_ids;\n     PaddedPODArray<RangeType> block_start_dates;\n@@ -103,38 +94,19 @@ Block RangeDictionaryBlockInputStream<DictionaryType, RangeType, Key>::getBlock(\n     return fillBlock(block_ids, block_start_dates, block_end_dates);\n }\n \n-template <typename DictionaryType, typename RangeType, typename Key>\n+template <typename RangeType>\n template <typename T>\n-ColumnPtr RangeDictionaryBlockInputStream<DictionaryType, RangeType, Key>::getColumnFromPODArray(const PaddedPODArray<T> & array) const\n+ColumnPtr RangeDictionaryBlockInputStream<RangeType>::getColumnFromPODArray(const PaddedPODArray<T> & array) const\n {\n     auto column_vector = ColumnVector<T>::create();\n     column_vector->getData().reserve(array.size());\n-    for (T value : array)\n-        column_vector->insertValue(value);\n-    return column_vector;\n-}\n-\n-template <typename DictionaryType, typename RangeType, typename Key>\n-template <typename DictionarySpecialAttributeType, typename T>\n-void RangeDictionaryBlockInputStream<DictionaryType, RangeType, Key>::addSpecialColumn(\n-    const std::optional<DictionarySpecialAttributeType> & attribute,\n-    DataTypePtr type,\n-    const std::string & default_name,\n-    const std::unordered_set<std::string> & column_names_set,\n-    const PaddedPODArray<T> & values,\n-    ColumnsWithTypeAndName & columns,\n-    bool force) const\n-{\n-    std::string name = default_name;\n-    if (attribute)\n-        name = attribute->name;\n+    column_vector->getData().insert(array.begin(), array.end());\n \n-    if (force || column_names_set.find(name) != column_names_set.end())\n-        columns.emplace_back(getColumnFromPODArray(values), type, name);\n+    return column_vector;\n }\n \n-template <typename DictionaryType, typename RangeType, typename Key>\n-PaddedPODArray<Int64> RangeDictionaryBlockInputStream<DictionaryType, RangeType, Key>::makeDateKey(\n+template <typename RangeType>\n+PaddedPODArray<Int64> RangeDictionaryBlockInputStream<RangeType>::makeDateKey(\n     const PaddedPODArray<RangeType> & block_start_dates, const PaddedPODArray<RangeType> & block_end_dates) const\n {\n     PaddedPODArray<Int64> key(block_start_dates.size());\n@@ -150,8 +122,8 @@ PaddedPODArray<Int64> RangeDictionaryBlockInputStream<DictionaryType, RangeType,\n }\n \n \n-template <typename DictionaryType, typename RangeType, typename Key>\n-Block RangeDictionaryBlockInputStream<DictionaryType, RangeType, Key>::fillBlock(\n+template <typename RangeType>\n+Block RangeDictionaryBlockInputStream<RangeType>::fillBlock(\n     const PaddedPODArray<Key> & ids_to_fill,\n     const PaddedPODArray<RangeType> & block_start_dates,\n     const PaddedPODArray<RangeType> & block_end_dates) const\n@@ -159,20 +131,32 @@ Block RangeDictionaryBlockInputStream<DictionaryType, RangeType, Key>::fillBlock\n     ColumnsWithTypeAndName columns;\n     const DictionaryStructure & structure = dictionary->getStructure();\n \n-    std::unordered_set<std::string> names(column_names.begin(), column_names.end());\n-\n-    addSpecialColumn(structure.id, std::make_shared<DataTypeUInt64>(), \"ID\", names, ids_to_fill, columns, true);\n-    auto ids_column = columns.back().column;\n-    addSpecialColumn(structure.range_min, structure.range_max->type, \"Range Start\", names, block_start_dates, columns);\n-    addSpecialColumn(structure.range_max, structure.range_max->type, \"Range End\", names, block_end_dates, columns);\n+    auto ids_column = getColumnFromPODArray(ids_to_fill);\n+    const std::string & id_column_name = structure.id->name;\n+    if (column_names.find(id_column_name) != column_names.end())\n+        columns.emplace_back(ids_column, std::make_shared<DataTypeUInt64>(), id_column_name);\n \n     auto date_key = makeDateKey(block_start_dates, block_end_dates);\n     auto date_column = getColumnFromPODArray(date_key);\n \n+    const std::string & range_min_column_name = structure.range_min->name;\n+    if (column_names.find(range_min_column_name) != column_names.end())\n+    {\n+        auto range_min_column = getColumnFromPODArray(block_start_dates);\n+        columns.emplace_back(range_min_column, structure.range_max->type, range_min_column_name);\n+    }\n+\n+    const std::string & range_max_column_name = structure.range_max->name;\n+    if (column_names.find(range_max_column_name) != column_names.end())\n+    {\n+        auto range_max_column = getColumnFromPODArray(block_end_dates);\n+        columns.emplace_back(range_max_column, structure.range_max->type, range_max_column_name);\n+    }\n+\n     for (const auto idx : ext::range(0, structure.attributes.size()))\n     {\n         const DictionaryAttribute & attribute = structure.attributes[idx];\n-        if (names.find(attribute.name) != names.end())\n+        if (column_names.find(attribute.name) != column_names.end())\n         {\n             ColumnPtr column = dictionary->getColumn(\n                 attribute.name,\ndiff --git a/src/Dictionaries/RangeHashedDictionary.cpp b/src/Dictionaries/RangeHashedDictionary.cpp\nindex f5be04c120d2..52b6f219baca 100644\n--- a/src/Dictionaries/RangeHashedDictionary.cpp\n+++ b/src/Dictionaries/RangeHashedDictionary.cpp\n@@ -52,7 +52,6 @@ namespace ErrorCodes\n     extern const int DICTIONARY_IS_EMPTY;\n     extern const int TYPE_MISMATCH;\n     extern const int UNSUPPORTED_METHOD;\n-    extern const int NOT_IMPLEMENTED;\n }\n \n bool RangeHashedDictionary::Range::isCorrectDate(const RangeStorageType & date)\n@@ -178,10 +177,76 @@ ColumnPtr RangeHashedDictionary::getColumn(\n     return result;\n }\n \n-ColumnUInt8::Ptr RangeHashedDictionary::hasKeys(const Columns &, const DataTypes &) const\n+ColumnUInt8::Ptr RangeHashedDictionary::hasKeys(const Columns & key_columns, const DataTypes & key_types) const\n {\n-    throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n-        \"Has not supported\", getDictionaryID().getNameForLogs());\n+    auto range_storage_column = key_columns[1];\n+    ColumnWithTypeAndName column_to_cast = {range_storage_column->convertToFullColumnIfConst(), key_types[1], \"\"};\n+\n+    auto range_column_storage_type = std::make_shared<DataTypeInt64>();\n+    auto range_column_updated = castColumnAccurate(column_to_cast, range_column_storage_type);\n+\n+    PaddedPODArray<Key> key_backup_storage;\n+    PaddedPODArray<RangeStorageType> range_backup_storage;\n+\n+    const PaddedPODArray<Key> & ids = getColumnVectorData(this, key_columns[0], key_backup_storage);\n+    const PaddedPODArray<RangeStorageType> & dates = getColumnVectorData(this, range_column_updated, range_backup_storage);\n+\n+    const auto & attribute = attributes.front();\n+\n+    ColumnUInt8::Ptr result;\n+\n+    auto type_call = [&](const auto & dictionary_attribute_type)\n+    {\n+        using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n+        using AttributeType = typename Type::AttributeType;\n+        using ValueType = DictionaryValueType<AttributeType>;\n+        result = hasKeysImpl<ValueType>(attribute, ids, dates);\n+    };\n+\n+    callOnDictionaryAttributeType(attribute.type, type_call);\n+\n+    query_count.fetch_add(ids.size(), std::memory_order_relaxed);\n+\n+    return result;\n+}\n+\n+template <typename AttributeType>\n+ColumnUInt8::Ptr RangeHashedDictionary::hasKeysImpl(\n+    const Attribute & attribute,\n+    const PaddedPODArray<Key> & ids,\n+    const PaddedPODArray<RangeStorageType> & dates) const\n+{\n+    auto result = ColumnUInt8::create(ids.size());\n+    auto& out = result->getData();\n+\n+    const auto & attr = *std::get<Ptr<AttributeType>>(attribute.maps);\n+\n+    for (const auto row : ext::range(0, ids.size()))\n+    {\n+        const auto it = attr.find(ids[row]);\n+\n+        if (it)\n+        {\n+            const auto date = dates[row];\n+            const auto & ranges_and_values = it->getMapped();\n+            const auto val_it = std::find_if(\n+                std::begin(ranges_and_values),\n+                std::end(ranges_and_values),\n+                [date](const Value<AttributeType> & v)\n+                {\n+                    return v.range.contains(date);\n+                });\n+\n+            if (val_it != std::end(ranges_and_values))\n+                out[row] = true;\n+            else\n+                out[row] = false;\n+        }\n+        else\n+            out[row] = false;\n+    }\n+\n+    return result;\n }\n \n void RangeHashedDictionary::createAttributes()\n@@ -450,7 +515,9 @@ RangeHashedDictionary::getAttributeWithType(const std::string & attribute_name,\n \n template <typename RangeType>\n void RangeHashedDictionary::getIdsAndDates(\n-    PaddedPODArray<Key> & ids, PaddedPODArray<RangeType> & start_dates, PaddedPODArray<RangeType> & end_dates) const\n+    PaddedPODArray<Key> & ids,\n+    PaddedPODArray<RangeType> & start_dates,\n+    PaddedPODArray<RangeType> & end_dates) const\n {\n     const auto & attribute = attributes.front();\n \n@@ -458,11 +525,9 @@ void RangeHashedDictionary::getIdsAndDates(\n     {\n         using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n         using AttributeType = typename Type::AttributeType;\n+        using ValueType = DictionaryValueType<AttributeType>;\n \n-        if constexpr (std::is_same_v<AttributeType, String>)\n-            getIdsAndDates<StringRef>(attribute, ids, start_dates, end_dates);\n-        else\n-            getIdsAndDates<AttributeType>(attribute, ids, start_dates, end_dates);\n+        getIdsAndDates<ValueType>(attribute, ids, start_dates, end_dates);\n     };\n \n     callOnDictionaryAttributeType(attribute.type, type_call);\n@@ -506,13 +571,20 @@ BlockInputStreamPtr RangeHashedDictionary::getBlockInputStreamImpl(const Names &\n     PaddedPODArray<RangeType> end_dates;\n     getIdsAndDates(ids, start_dates, end_dates);\n \n-    using BlockInputStreamType = RangeDictionaryBlockInputStream<RangeHashedDictionary, RangeType, Key>;\n-    auto dict_ptr = std::static_pointer_cast<const RangeHashedDictionary>(shared_from_this());\n-    return std::make_shared<BlockInputStreamType>(\n-        dict_ptr, max_block_size, column_names, std::move(ids), std::move(start_dates), std::move(end_dates));\n+    using BlockInputStreamType = RangeDictionaryBlockInputStream<RangeType>;\n+\n+    auto stream = std::make_shared<BlockInputStreamType>(\n+        shared_from_this(),\n+        max_block_size,\n+        column_names,\n+        std::move(ids),\n+        std::move(start_dates),\n+        std::move(end_dates));\n+\n+    return stream;\n }\n \n-struct RangeHashedDIctionaryCallGetBlockInputStreamImpl\n+struct RangeHashedDictionaryCallGetBlockInputStreamImpl\n {\n     BlockInputStreamPtr stream;\n     const RangeHashedDictionary * dict;\n@@ -532,7 +604,7 @@ BlockInputStreamPtr RangeHashedDictionary::getBlockInputStream(const Names & col\n {\n     using ListType = TypeList<UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64, Int128, Float32, Float64>;\n \n-    RangeHashedDIctionaryCallGetBlockInputStreamImpl callable;\n+    RangeHashedDictionaryCallGetBlockInputStreamImpl callable;\n     callable.dict = this;\n     callable.column_names = &column_names;\n     callable.max_block_size = max_block_size;\ndiff --git a/src/Dictionaries/RangeHashedDictionary.h b/src/Dictionaries/RangeHashedDictionary.h\nindex 1f93fa757758..f2b24e52dfc0 100644\n--- a/src/Dictionaries/RangeHashedDictionary.h\n+++ b/src/Dictionaries/RangeHashedDictionary.h\n@@ -93,8 +93,6 @@ class RangeHashedDictionary final : public IDictionaryBase\n     template <typename T>\n     using Ptr = std::unique_ptr<Collection<T>>;\n \n-    using NullableSet = HashSet<Key, DefaultHash<Key>>;\n-\n     struct Attribute final\n     {\n     public:\n@@ -159,6 +157,12 @@ class RangeHashedDictionary final : public IDictionaryBase\n         ValueSetter && set_value,\n         DefaultValueExtractor & default_value_extractor) const;\n \n+    template <typename AttributeType>\n+    ColumnUInt8::Ptr hasKeysImpl(\n+        const Attribute & attribute,\n+        const PaddedPODArray<Key> & ids,\n+        const PaddedPODArray<RangeStorageType> & dates) const;\n+\n     template <typename T>\n     static void setAttributeValueImpl(Attribute & attribute, const Key id, const Range & range, const Field & value);\n \n@@ -181,7 +185,7 @@ class RangeHashedDictionary final : public IDictionaryBase\n     template <typename RangeType>\n     BlockInputStreamPtr getBlockInputStreamImpl(const Names & column_names, size_t max_block_size) const;\n \n-    friend struct RangeHashedDIctionaryCallGetBlockInputStreamImpl;\n+    friend struct RangeHashedDictionaryCallGetBlockInputStreamImpl;\n \n     const DictionaryStructure dict_struct;\n     const DictionarySourcePtr source_ptr;\ndiff --git a/src/Functions/FunctionsExternalDictionaries.h b/src/Functions/FunctionsExternalDictionaries.h\nindex acf158d42eff..4177d686f573 100644\n--- a/src/Functions/FunctionsExternalDictionaries.h\n+++ b/src/Functions/FunctionsExternalDictionaries.h\n@@ -54,7 +54,6 @@ namespace ErrorCodes\n     extern const int ILLEGAL_COLUMN;\n     extern const int BAD_ARGUMENTS;\n     extern const int TYPE_MISMATCH;\n-    extern const int NOT_IMPLEMENTED;\n }\n \n \n@@ -154,13 +153,20 @@ class FunctionDictHas final : public IFunction\n     String getName() const override { return name; }\n \n private:\n-    size_t getNumberOfArguments() const override { return 2; }\n+    size_t getNumberOfArguments() const override { return 0; }\n+    bool isVariadic() const override { return true; }\n+\n+    bool isDeterministic() const override { return false; }\n \n     bool useDefaultImplementationForConstants() const final { return true; }\n+\n     ColumnNumbers getArgumentsThatAreAlwaysConstant() const final { return {0}; }\n \n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n+        if (arguments.size() < 2)\n+            throw Exception{\"Wrong argument count for function \" + getName(), ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH};\n+\n         if (!isString(arguments[0]))\n             throw Exception{\"Illegal type \" + arguments[0]->getName() + \" of first argument of function \" + getName()\n                 + \", expected a string.\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};\n@@ -173,8 +179,6 @@ class FunctionDictHas final : public IFunction\n         return std::make_shared<DataTypeUInt8>();\n     }\n \n-    bool isDeterministic() const override { return false; }\n-\n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n     {\n         /** Do not require existence of the dictionary if the function is called for empty columns.\n@@ -194,6 +198,24 @@ class FunctionDictHas final : public IFunction\n         const auto key_column = key_column_with_type.column;\n         const auto key_column_type = WhichDataType(key_column_with_type.type);\n \n+        ColumnPtr range_col = nullptr;\n+        DataTypePtr range_col_type = nullptr;\n+\n+        if (dictionary_key_type == DictionaryKeyType::range)\n+        {\n+            if (arguments.size() != 3)\n+                throw Exception{\"Wrong argument count for function \" + getName()\n+                    + \" when dictionary has key type range\", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH};\n+\n+            range_col = arguments[2].column;\n+            range_col_type = arguments[2].type;\n+\n+            if (!(range_col_type->isValueRepresentedByInteger() && range_col_type->getSizeOfValueInMemory() <= sizeof(Int64)))\n+                throw Exception{\"Illegal type \" + range_col_type->getName() + \" of fourth argument of function \"\n+                        + getName() + \" must be convertible to Int64.\",\n+                    ErrorCodes::ILLEGAL_COLUMN};\n+        }\n+\n         if (dictionary_key_type == DictionaryKeyType::simple)\n         {\n             if (!key_column_type.isUInt64())\n@@ -217,7 +239,7 @@ class FunctionDictHas final : public IFunction\n             return dictionary->hasKeys(key_columns, key_types);\n         }\n         else\n-            throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Has not supported for range dictionary\", dictionary->getDictionaryID().getNameForLogs());\n+            return dictionary->hasKeys({key_column, range_col}, {std::make_shared<DataTypeUInt64>(), range_col_type});\n     }\n \n     mutable FunctionDictHelper helper;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01280_ssd_complex_key_dictionary.sql b/tests/queries/0_stateless/01280_ssd_complex_key_dictionary.sql\nindex 8c304818602a..50b34c4b18fe 100644\n--- a/tests/queries/0_stateless/01280_ssd_complex_key_dictionary.sql\n+++ b/tests/queries/0_stateless/01280_ssd_complex_key_dictionary.sql\n@@ -42,8 +42,7 @@ LAYOUT(COMPLEX_KEY_SSD_CACHE(FILE_SIZE 8192 PATH '/var/lib/clickhouse/clickhouse\n SELECT 'TEST_SMALL';\n SELECT 'VALUE FROM RAM BUFFER';\n \n--- NUMBER_OF_ARGUMENTS_DOESNT_MATCH\n-SELECT dictHas('01280_db.ssd_dict', 'a', tuple('1')); -- { serverError 42 }\n+SELECT dictHas('01280_db.ssd_dict', 'a', tuple('1')); -- { serverError 43 }\n \n SELECT dictGetUInt64('01280_db.ssd_dict', 'a', tuple('1', toInt32(3)));\n SELECT dictGetInt32('01280_db.ssd_dict', 'b', tuple('1', toInt32(3)));\ndiff --git a/tests/queries/0_stateless/01676_range_hashed_dictionary.reference b/tests/queries/0_stateless/01676_range_hashed_dictionary.reference\nnew file mode 100644\nindex 000000000000..23a5180d99ca\n--- /dev/null\n+++ b/tests/queries/0_stateless/01676_range_hashed_dictionary.reference\n@@ -0,0 +1,58 @@\n+Dictionary not nullable\n+dictGet\n+0.33\n+0.42\n+0.46\n+0.2\n+0.4\n+dictHas\n+1\n+1\n+1\n+0\n+select columns from dictionary\n+allColumns\n+1\t2019-05-05\t2019-05-20\t0.33\n+1\t2019-05-21\t2019-05-30\t0.42\n+2\t2019-05-21\t2019-05-30\t0.46\n+noColumns\n+1\n+1\n+1\n+onlySpecificColumns\n+1\t2019-05-05\t0.33\n+1\t2019-05-21\t0.42\n+2\t2019-05-21\t0.46\n+onlySpecificColumn\n+0.33\n+0.42\n+0.46\n+Dictionary nullable\n+dictGet\n+0.33\n+0.42\n+\\N\n+0.2\n+0.4\n+dictHas\n+1\n+1\n+1\n+0\n+select columns from dictionary\n+allColumns\n+1\t2019-05-05\t2019-05-20\t0.33\n+1\t2019-05-21\t2019-05-30\t0.42\n+2\t2019-05-21\t2019-05-30\t\\N\n+noColumns\n+1\n+1\n+1\n+onlySpecificColumns\n+1\t2019-05-05\t0.33\n+1\t2019-05-21\t0.42\n+2\t2019-05-21\t\\N\n+onlySpecificColumn\n+0.33\n+0.42\n+\\N\ndiff --git a/tests/queries/0_stateless/01676_range_hashed_dictionary.sql b/tests/queries/0_stateless/01676_range_hashed_dictionary.sql\nnew file mode 100644\nindex 000000000000..455e850b2392\n--- /dev/null\n+++ b/tests/queries/0_stateless/01676_range_hashed_dictionary.sql\n@@ -0,0 +1,110 @@\n+DROP DATABASE IF EXISTS database_for_range_dict;\n+\n+CREATE DATABASE database_for_range_dict;\n+\n+CREATE TABLE database_for_range_dict.date_table\n+(\n+  CountryID UInt64,\n+  StartDate Date,\n+  EndDate Date,\n+  Tax Float64\n+)\n+ENGINE = MergeTree()\n+ORDER BY CountryID;\n+\n+INSERT INTO database_for_range_dict.date_table VALUES(1, toDate('2019-05-05'), toDate('2019-05-20'), 0.33);\n+INSERT INTO database_for_range_dict.date_table VALUES(1, toDate('2019-05-21'), toDate('2019-05-30'), 0.42);\n+INSERT INTO database_for_range_dict.date_table VALUES(2, toDate('2019-05-21'), toDate('2019-05-30'), 0.46);\n+\n+CREATE DICTIONARY database_for_range_dict.range_dictionary\n+(\n+  CountryID UInt64,\n+  StartDate Date,\n+  EndDate Date,\n+  Tax Float64 DEFAULT 0.2\n+)\n+PRIMARY KEY CountryID\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() USER 'default' TABLE 'date_table' DB 'database_for_range_dict'))\n+LIFETIME(MIN 1 MAX 1000)\n+LAYOUT(RANGE_HASHED())\n+RANGE(MIN StartDate MAX EndDate);\n+\n+SELECT 'Dictionary not nullable';\n+SELECT 'dictGet';\n+SELECT dictGet('database_for_range_dict.range_dictionary', 'Tax', toUInt64(1), toDate('2019-05-15'));\n+SELECT dictGet('database_for_range_dict.range_dictionary', 'Tax', toUInt64(1), toDate('2019-05-29'));\n+SELECT dictGet('database_for_range_dict.range_dictionary', 'Tax', toUInt64(2), toDate('2019-05-29'));\n+SELECT dictGet('database_for_range_dict.range_dictionary', 'Tax', toUInt64(2), toDate('2019-05-31'));\n+SELECT dictGetOrDefault('database_for_range_dict.range_dictionary', 'Tax', toUInt64(2), toDate('2019-05-31'), 0.4);\n+SELECT 'dictHas';\n+SELECT dictHas('database_for_range_dict.range_dictionary', toUInt64(1), toDate('2019-05-15'));\n+SELECT dictHas('database_for_range_dict.range_dictionary', toUInt64(1), toDate('2019-05-29'));\n+SELECT dictHas('database_for_range_dict.range_dictionary', toUInt64(2), toDate('2019-05-29'));\n+SELECT dictHas('database_for_range_dict.range_dictionary', toUInt64(2), toDate('2019-05-31'));\n+SELECT 'select columns from dictionary';\n+SELECT 'allColumns';\n+SELECT * FROM database_for_range_dict.range_dictionary;\n+SELECT 'noColumns';\n+SELECT 1 FROM database_for_range_dict.range_dictionary;\n+SELECT 'onlySpecificColumns';\n+SELECT CountryID, StartDate, Tax FROM database_for_range_dict.range_dictionary;\n+SELECT 'onlySpecificColumn';\n+SELECT Tax FROM database_for_range_dict.range_dictionary;\n+\n+DROP TABLE database_for_range_dict.date_table;\n+DROP DICTIONARY database_for_range_dict.range_dictionary;\n+\n+CREATE TABLE database_for_range_dict.date_table\n+(\n+  CountryID UInt64,\n+  StartDate Date,\n+  EndDate Date,\n+  Tax Nullable(Float64)\n+)\n+ENGINE = MergeTree()\n+ORDER BY CountryID;\n+\n+INSERT INTO database_for_range_dict.date_table VALUES(1, toDate('2019-05-05'), toDate('2019-05-20'), 0.33);\n+INSERT INTO database_for_range_dict.date_table VALUES(1, toDate('2019-05-21'), toDate('2019-05-30'), 0.42);\n+INSERT INTO database_for_range_dict.date_table VALUES(2, toDate('2019-05-21'), toDate('2019-05-30'), NULL);\n+\n+CREATE DICTIONARY database_for_range_dict.range_dictionary_nullable\n+(\n+  CountryID UInt64,\n+  StartDate Date,\n+  EndDate Date,\n+  Tax Nullable(Float64) DEFAULT 0.2\n+)\n+PRIMARY KEY CountryID\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() USER 'default' TABLE 'date_table' DB 'database_for_range_dict'))\n+LIFETIME(MIN 1 MAX 1000)\n+LAYOUT(RANGE_HASHED())\n+RANGE(MIN StartDate MAX EndDate);\n+\n+SELECT 'Dictionary nullable';\n+SELECT 'dictGet';\n+SELECT dictGet('database_for_range_dict.range_dictionary_nullable', 'Tax', toUInt64(1), toDate('2019-05-15'));\n+SELECT dictGet('database_for_range_dict.range_dictionary_nullable', 'Tax', toUInt64(1), toDate('2019-05-29'));\n+SELECT dictGet('database_for_range_dict.range_dictionary_nullable', 'Tax', toUInt64(2), toDate('2019-05-29'));\n+SELECT dictGet('database_for_range_dict.range_dictionary_nullable', 'Tax', toUInt64(2), toDate('2019-05-31'));\n+SELECT dictGetOrDefault('database_for_range_dict.range_dictionary_nullable', 'Tax', toUInt64(2), toDate('2019-05-31'), 0.4);\n+SELECT 'dictHas';\n+SELECT dictHas('database_for_range_dict.range_dictionary_nullable', toUInt64(1), toDate('2019-05-15'));\n+SELECT dictHas('database_for_range_dict.range_dictionary_nullable', toUInt64(1), toDate('2019-05-29'));\n+SELECT dictHas('database_for_range_dict.range_dictionary_nullable', toUInt64(2), toDate('2019-05-29'));\n+SELECT dictHas('database_for_range_dict.range_dictionary_nullable', toUInt64(2), toDate('2019-05-31'));\n+SELECT 'select columns from dictionary';\n+SELECT 'allColumns';\n+SELECT * FROM database_for_range_dict.range_dictionary_nullable;\n+SELECT 'noColumns';\n+SELECT 1 FROM database_for_range_dict.range_dictionary_nullable;\n+SELECT 'onlySpecificColumns';\n+SELECT CountryID, StartDate, Tax FROM database_for_range_dict.range_dictionary_nullable;\n+SELECT 'onlySpecificColumn';\n+SELECT Tax FROM database_for_range_dict.range_dictionary_nullable;\n+\n+DROP TABLE database_for_range_dict.date_table;\n+DROP DICTIONARY database_for_range_dict.range_dictionary_nullable;\n+\n+DROP DATABASE database_for_range_dict;\n+\n",
  "problem_statement": "dictHas is not supported with range_hashed\ndictGet works\r\n```\r\nSELECT dictGet('d_test', 'atr', toUInt64(1), toDateTime('2019-02-01 00:00:00')) AS x\r\n\u250c\u2500x\u2500\u2510\r\n\u2502 1 \u2502\r\n\u2514\u2500\u2500\u2500\u2518\r\n```\r\n\r\nbut dictHas does not.\r\n```\r\nSELECT dictHas('d_test', toUInt64(1), toDateTime('2019-02-01 00:00:00')) AS x\r\n\r\nReceived exception from server (version 19.14.1):\r\nCode: 42. DB::Exception: Received from localhost:9000. \r\nDB::Exception: Number of arguments for function dictHas doesn't match: passed 3, should be 2.\r\n```\r\n\r\n```\r\n\r\n\r\nCREATE VIEW default.v_test (`id` UInt8, `start` DateTime, `end` DateTime, `atr` UInt8) AS SELECT 1 AS id, toDateTime('2019-01-01 00:00:00') AS start, toDateTime('2020-01-01 00:00:00') AS end, 1 AS atr\r\n\r\n<?xml version=\"1.0\"?>\r\n<dictionaries>\r\n<dictionary>\r\n        <name>d_test</name>\r\n        <source>\r\n            <clickhouse>\r\n                <host>localhost</host>\r\n                <port>9000</port>\r\n                <user>default</user>\r\n                <password></password>\r\n                <db>default</db>\r\n                <table>v_test</table>\r\n            </clickhouse>\r\n        </source>\r\n\r\n        <layout>\r\n            <range_hashed />\r\n        </layout>\r\n\r\n        <structure>\r\n            <id>\r\n                <name>id</name>\r\n            </id>\r\n            <range_min>\r\n                    <name>start</name>\r\n\t\t           <type>DateTime</type>\r\n            </range_min>\r\n            <range_max>\r\n\t\t    <name>end</name>\r\n\t\t    <type>DateTime</type>\r\n            </range_max>\r\n            <attribute>\r\n                    <name>atr</name>\r\n                    <type>UInt8</type>\r\n                    <null_value>0</null_value>\r\n            </attribute>\r\n        </structure>\r\n\r\n        <lifetime>\r\n            <min>3000</min>\r\n            <max>3600</max>\r\n        </lifetime>\r\n    </dictionary>\r\n```\n",
  "hints_text": "",
  "created_at": "2021-01-29T14:51:49Z",
  "modified_files": [
    "src/Dictionaries/RangeDictionaryBlockInputStream.h",
    "src/Dictionaries/RangeHashedDictionary.cpp",
    "src/Dictionaries/RangeHashedDictionary.h",
    "src/Functions/FunctionsExternalDictionaries.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01280_ssd_complex_key_dictionary.sql",
    "b/tests/queries/0_stateless/01676_range_hashed_dictionary.reference",
    "b/tests/queries/0_stateless/01676_range_hashed_dictionary.sql"
  ]
}