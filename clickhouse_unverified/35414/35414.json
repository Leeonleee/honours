{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 35414,
  "instance_id": "ClickHouse__ClickHouse-35414",
  "issue_numbers": [
    "35238"
  ],
  "base_commit": "dc205d44da22f1cd5c1cd306b0ac9ba62d17d45d",
  "patch": "diff --git a/docs/en/sql-reference/functions/array-functions.md b/docs/en/sql-reference/functions/array-functions.md\nindex 8231cda4b775..eebc489fffa3 100644\n--- a/docs/en/sql-reference/functions/array-functions.md\n+++ b/docs/en/sql-reference/functions/array-functions.md\n@@ -1392,12 +1392,24 @@ Returns the first element in the `arr1` array for which `func` returns something\n \n Note that the `arrayFirst` is a [higher-order function](../../sql-reference/functions/index.md#higher-order-functions). You must pass a lambda function to it as the first argument, and it can\u2019t be omitted.\n \n+## arrayFirstOrNull(func, arr1, \u2026) {#array-first-or-null}\n+\n+Returns the first element in the `arr1` array for which `func` returns something other than 0. If there are no such element, returns null.\n+\n+Note that the `arrayFirstOrNull` is a [higher-order function](../../sql-reference/functions/index.md#higher-order-functions). You must pass a lambda function to it as the first argument, and it can\u2019t be omitted.\n+\n ## arrayLast(func, arr1, \u2026) {#array-last}\n \n Returns the last element in the `arr1` array for which `func` returns something other than 0.\n \n Note that the `arrayLast` is a [higher-order function](../../sql-reference/functions/index.md#higher-order-functions). You must pass a lambda function to it as the first argument, and it can\u2019t be omitted.\n \n+## arrayLastOrNull(func, arr1, \u2026) {#array-last-or-null}\n+\n+Returns the last element in the `arr1` array for which `func` returns something other than 0. If there are no such element, returns null.\n+\n+Note that the `arrayLast` is a [higher-order function](../../sql-reference/functions/index.md#higher-order-functions). You must pass a lambda function to it as the first argument, and it can\u2019t be omitted.\n+\n ## arrayFirstIndex(func, arr1, \u2026) {#array-first-index}\n \n Returns the index of the first element in the `arr1` array for which `func` returns something other than 0.\ndiff --git a/src/Functions/array/arrayFirst.cpp b/src/Functions/array/arrayFirstLast.cpp\nsimilarity index 57%\nrename from src/Functions/array/arrayFirst.cpp\nrename to src/Functions/array/arrayFirstLast.cpp\nindex 693aea746f5c..c9a8d2ba4973 100644\n--- a/src/Functions/array/arrayFirst.cpp\n+++ b/src/Functions/array/arrayFirstLast.cpp\n@@ -1,4 +1,5 @@\n #include <Columns/ColumnsNumber.h>\n+#include <Columns/ColumnNullable.h>\n #include <DataTypes/DataTypesNumber.h>\n #include <Functions/FunctionFactory.h>\n \n@@ -12,13 +13,19 @@ namespace ErrorCodes\n     extern const int ILLEGAL_COLUMN;\n }\n \n-enum class ArrayFirstLastStrategy\n+enum class ArrayFirstLastStrategy : uint8_t\n {\n     First,\n     Last\n };\n \n-template <ArrayFirstLastStrategy strategy>\n+enum class ArrayFirstLastElementNotExistsStrategy : uint8_t\n+{\n+    Default,\n+    Null\n+};\n+\n+template <ArrayFirstLastStrategy strategy, ArrayFirstLastElementNotExistsStrategy element_not_exists_strategy>\n struct ArrayFirstLastImpl\n {\n     using column_type = ColumnArray;\n@@ -30,6 +37,9 @@ struct ArrayFirstLastImpl\n \n     static DataTypePtr getReturnType(const DataTypePtr & /*expression_return*/, const DataTypePtr & array_element)\n     {\n+        if constexpr (element_not_exists_strategy == ArrayFirstLastElementNotExistsStrategy::Null)\n+            return makeNullable(array_element);\n+\n         return array_element;\n     }\n \n@@ -52,6 +62,16 @@ struct ArrayFirstLastImpl\n                 out->reserve(data.size());\n \n                 size_t offsets_size = offsets.size();\n+\n+                ColumnUInt8::MutablePtr col_null_map_to;\n+                ColumnUInt8::Container * vec_null_map_to = nullptr;\n+\n+                if constexpr (element_not_exists_strategy == ArrayFirstLastElementNotExistsStrategy::Null)\n+                {\n+                    col_null_map_to = ColumnUInt8::create(offsets_size, false);\n+                    vec_null_map_to = &col_null_map_to->getData();\n+                }\n+\n                 for (size_t offset_index = 0; offset_index < offsets_size; ++offset_index)\n                 {\n                     size_t start_offset = offsets[offset_index - 1];\n@@ -67,16 +87,29 @@ struct ArrayFirstLastImpl\n                     else\n                     {\n                         out->insertDefault();\n+\n+                        if constexpr (element_not_exists_strategy == ArrayFirstLastElementNotExistsStrategy::Null)\n+                            (*vec_null_map_to)[offset_index] = true;\n                     }\n                 }\n \n+                if constexpr (element_not_exists_strategy == ArrayFirstLastElementNotExistsStrategy::Null)\n+                    return ColumnNullable::create(std::move(out), std::move(col_null_map_to));\n+\n                 return out;\n             }\n             else\n             {\n                 auto out = array.getData().cloneEmpty();\n-                out->insertDefault();\n-                return out->replicate(IColumn::Offsets(1, array.size()));\n+                out->insertManyDefaults(array.size());\n+\n+                if constexpr (element_not_exists_strategy == ArrayFirstLastElementNotExistsStrategy::Null)\n+                {\n+                    auto col_null_map_to = ColumnUInt8::create(out->size(), true);\n+                    return ColumnNullable::create(std::move(out), std::move(col_null_map_to));\n+                }\n+\n+                return out;\n             }\n         }\n \n@@ -87,6 +120,16 @@ struct ArrayFirstLastImpl\n         out->reserve(data.size());\n \n         size_t offsets_size = offsets.size();\n+\n+        ColumnUInt8::MutablePtr col_null_map_to;\n+        ColumnUInt8::Container * vec_null_map_to = nullptr;\n+\n+        if constexpr (element_not_exists_strategy == ArrayFirstLastElementNotExistsStrategy::Null)\n+        {\n+            col_null_map_to = ColumnUInt8::create(offsets_size, false);\n+            vec_null_map_to = &col_null_map_to->getData();\n+        }\n+\n         for (size_t offset_index = 0; offset_index < offsets_size; ++offset_index)\n         {\n             size_t start_offset = offsets[offset_index - 1];\n@@ -120,25 +163,43 @@ struct ArrayFirstLastImpl\n             }\n \n             if (!exists)\n+            {\n                 out->insertDefault();\n+\n+                if constexpr (element_not_exists_strategy == ArrayFirstLastElementNotExistsStrategy::Null)\n+                    (*vec_null_map_to)[offset_index] = true;\n+            }\n         }\n \n+        if constexpr (element_not_exists_strategy == ArrayFirstLastElementNotExistsStrategy::Null)\n+            return ColumnNullable::create(std::move(out), std::move(col_null_map_to));\n+\n         return out;\n     }\n };\n \n struct NameArrayFirst { static constexpr auto name = \"arrayFirst\"; };\n-using ArrayFirstImpl = ArrayFirstLastImpl<ArrayFirstLastStrategy::First>;\n+using ArrayFirstImpl = ArrayFirstLastImpl<ArrayFirstLastStrategy::First, ArrayFirstLastElementNotExistsStrategy::Default>;\n using FunctionArrayFirst = FunctionArrayMapped<ArrayFirstImpl, NameArrayFirst>;\n \n+struct NameArrayFirstOrNull { static constexpr auto name = \"arrayFirstOrNull\"; };\n+using ArrayFirstOrNullImpl = ArrayFirstLastImpl<ArrayFirstLastStrategy::First, ArrayFirstLastElementNotExistsStrategy::Null>;\n+using FunctionArrayFirstOrNull = FunctionArrayMapped<ArrayFirstOrNullImpl, NameArrayFirstOrNull>;\n+\n struct NameArrayLast { static constexpr auto name = \"arrayLast\"; };\n-using ArrayLastImpl = ArrayFirstLastImpl<ArrayFirstLastStrategy::Last>;\n+using ArrayLastImpl = ArrayFirstLastImpl<ArrayFirstLastStrategy::Last, ArrayFirstLastElementNotExistsStrategy::Default>;\n using FunctionArrayLast = FunctionArrayMapped<ArrayLastImpl, NameArrayLast>;\n \n+struct NameArrayLastOrNull { static constexpr auto name = \"arrayLastOrNull\"; };\n+using ArrayLastOrNullImpl = ArrayFirstLastImpl<ArrayFirstLastStrategy::Last, ArrayFirstLastElementNotExistsStrategy::Null>;\n+using FunctionArrayLastOrNull = FunctionArrayMapped<ArrayLastOrNullImpl, NameArrayLastOrNull>;\n+\n void registerFunctionArrayFirst(FunctionFactory & factory)\n {\n     factory.registerFunction<FunctionArrayFirst>();\n+    factory.registerFunction<FunctionArrayFirstOrNull>();\n     factory.registerFunction<FunctionArrayLast>();\n+    factory.registerFunction<FunctionArrayLastOrNull>();\n }\n \n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02241_array_first_last_or_null.reference b/tests/queries/0_stateless/02241_array_first_last_or_null.reference\nnew file mode 100644\nindex 000000000000..2906b04ecd02\n--- /dev/null\n+++ b/tests/queries/0_stateless/02241_array_first_last_or_null.reference\n@@ -0,0 +1,18 @@\n+ArrayFirst constant predicate\n+\\N\n+\\N\n+1\n+\\N\n+ArrayFirst non constant predicate\n+\\N\n+2\n+2\n+ArrayLast constant predicate\n+\\N\n+\\N\n+3\n+\\N\n+ArrayLast non constant predicate\n+\\N\n+3\n+3\ndiff --git a/tests/queries/0_stateless/02241_array_first_last_or_null.sql b/tests/queries/0_stateless/02241_array_first_last_or_null.sql\nnew file mode 100644\nindex 000000000000..3230e4d483a9\n--- /dev/null\n+++ b/tests/queries/0_stateless/02241_array_first_last_or_null.sql\n@@ -0,0 +1,21 @@\n+SELECT 'ArrayFirst constant predicate';\n+SELECT arrayFirstOrNull(x -> 1, emptyArrayUInt8());\n+SELECT arrayFirstOrNull(x -> 0, emptyArrayUInt8());\n+SELECT arrayFirstOrNull(x -> 1, [1, 2, 3]);\n+SELECT arrayFirstOrNull(x -> 0, [1, 2, 3]);\n+\n+SELECT 'ArrayFirst non constant predicate';\n+SELECT arrayFirstOrNull(x -> x >= 2, emptyArrayUInt8());\n+SELECT arrayFirstOrNull(x -> x >= 2, [1, 2, 3]);\n+SELECT arrayFirstOrNull(x -> x >= 2, materialize([1, 2, 3]));\n+\n+SELECT 'ArrayLast constant predicate';\n+SELECT arrayLastOrNull(x -> 1, emptyArrayUInt8());\n+SELECT arrayLastOrNull(x -> 0, emptyArrayUInt8());\n+SELECT arrayLastOrNull(x -> 1, [1, 2, 3]);\n+SELECT arrayLastOrNull(x -> 0, [1, 2, 3]);\n+\n+SELECT 'ArrayLast non constant predicate';\n+SELECT arrayLastOrNull(x -> x >= 2, emptyArrayUInt8());\n+SELECT arrayLastOrNull(x -> x >= 2, [1, 2, 3]);\n+SELECT arrayLastOrNull(x -> x >= 2, materialize([1, 2, 3]));\n",
  "problem_statement": "ArrayFirstOrDefault function\nFor example, we have table like this\r\n![image](https://user-images.githubusercontent.com/4305175/158013399-debd6796-1cee-4026-b78d-58fb94be3cb9.png)\r\n\r\nand i run query like this\r\n```\r\nselect arrayFirst((i, v)->(v = 'a'), ids, values) as a_id,\r\n       arrayFirst((i, v)->(v = 'c'), ids, values) as c_id\r\n```\r\n![image](https://user-images.githubusercontent.com/4305175/158013431-cac1e643-13f7-4a77-89b8-033a2d89fe25.png)\r\n\r\nthis result is not right for me, i need to write smth like \r\n```\r\nselect if(arrayCount((i, v)->(v = 'a'), ids, values) > 0, arrayFirst((i, v)->(v = 'a'), ids, values), null) as a_id,\r\n       if(arrayCount((i, v)->(v = 'c'), ids, values) > 0, arrayFirst((i, v)->(v = 'c'), ids, values), null) as c_id\r\n```\r\n\r\nand will get right result\r\n![image](https://user-images.githubusercontent.com/4305175/158013465-bbbb373c-9b56-4310-a82d-1546f242a334.png)\r\n\r\nso, can we get function smth like `arrayFirstOrDefault `or `arrayFirstOrNull`?\r\n```\r\nselect arrayFirstOrNull((i, v)->(v = 'a'), ids, values) as a_id,\r\n       arrayFirstOrNull((i, v)->(v = 'c'), ids, values) as c_id\r\n```\r\n\n",
  "hints_text": "@alexsubota by default `arrayFirst`, `arrayLast` functions return default value if predicate do not match any array element. We can implement `arrayFirstOrNull`, `arrayLastOrNull`.",
  "created_at": "2022-03-18T19:01:42Z"
}