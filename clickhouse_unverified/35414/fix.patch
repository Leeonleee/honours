diff --git a/docs/en/sql-reference/functions/array-functions.md b/docs/en/sql-reference/functions/array-functions.md
index 8231cda4b775..eebc489fffa3 100644
--- a/docs/en/sql-reference/functions/array-functions.md
+++ b/docs/en/sql-reference/functions/array-functions.md
@@ -1392,12 +1392,24 @@ Returns the first element in the `arr1` array for which `func` returns something
 
 Note that the `arrayFirst` is a [higher-order function](../../sql-reference/functions/index.md#higher-order-functions). You must pass a lambda function to it as the first argument, and it can’t be omitted.
 
+## arrayFirstOrNull(func, arr1, …) {#array-first-or-null}
+
+Returns the first element in the `arr1` array for which `func` returns something other than 0. If there are no such element, returns null.
+
+Note that the `arrayFirstOrNull` is a [higher-order function](../../sql-reference/functions/index.md#higher-order-functions). You must pass a lambda function to it as the first argument, and it can’t be omitted.
+
 ## arrayLast(func, arr1, …) {#array-last}
 
 Returns the last element in the `arr1` array for which `func` returns something other than 0.
 
 Note that the `arrayLast` is a [higher-order function](../../sql-reference/functions/index.md#higher-order-functions). You must pass a lambda function to it as the first argument, and it can’t be omitted.
 
+## arrayLastOrNull(func, arr1, …) {#array-last-or-null}
+
+Returns the last element in the `arr1` array for which `func` returns something other than 0. If there are no such element, returns null.
+
+Note that the `arrayLast` is a [higher-order function](../../sql-reference/functions/index.md#higher-order-functions). You must pass a lambda function to it as the first argument, and it can’t be omitted.
+
 ## arrayFirstIndex(func, arr1, …) {#array-first-index}
 
 Returns the index of the first element in the `arr1` array for which `func` returns something other than 0.
diff --git a/src/Functions/array/arrayFirst.cpp b/src/Functions/array/arrayFirstLast.cpp
similarity index 57%
rename from src/Functions/array/arrayFirst.cpp
rename to src/Functions/array/arrayFirstLast.cpp
index 693aea746f5c..c9a8d2ba4973 100644
--- a/src/Functions/array/arrayFirst.cpp
+++ b/src/Functions/array/arrayFirstLast.cpp
@@ -1,4 +1,5 @@
 #include <Columns/ColumnsNumber.h>
+#include <Columns/ColumnNullable.h>
 #include <DataTypes/DataTypesNumber.h>
 #include <Functions/FunctionFactory.h>
 
@@ -12,13 +13,19 @@ namespace ErrorCodes
     extern const int ILLEGAL_COLUMN;
 }
 
-enum class ArrayFirstLastStrategy
+enum class ArrayFirstLastStrategy : uint8_t
 {
     First,
     Last
 };
 
-template <ArrayFirstLastStrategy strategy>
+enum class ArrayFirstLastElementNotExistsStrategy : uint8_t
+{
+    Default,
+    Null
+};
+
+template <ArrayFirstLastStrategy strategy, ArrayFirstLastElementNotExistsStrategy element_not_exists_strategy>
 struct ArrayFirstLastImpl
 {
     using column_type = ColumnArray;
@@ -30,6 +37,9 @@ struct ArrayFirstLastImpl
 
     static DataTypePtr getReturnType(const DataTypePtr & /*expression_return*/, const DataTypePtr & array_element)
     {
+        if constexpr (element_not_exists_strategy == ArrayFirstLastElementNotExistsStrategy::Null)
+            return makeNullable(array_element);
+
         return array_element;
     }
 
@@ -52,6 +62,16 @@ struct ArrayFirstLastImpl
                 out->reserve(data.size());
 
                 size_t offsets_size = offsets.size();
+
+                ColumnUInt8::MutablePtr col_null_map_to;
+                ColumnUInt8::Container * vec_null_map_to = nullptr;
+
+                if constexpr (element_not_exists_strategy == ArrayFirstLastElementNotExistsStrategy::Null)
+                {
+                    col_null_map_to = ColumnUInt8::create(offsets_size, false);
+                    vec_null_map_to = &col_null_map_to->getData();
+                }
+
                 for (size_t offset_index = 0; offset_index < offsets_size; ++offset_index)
                 {
                     size_t start_offset = offsets[offset_index - 1];
@@ -67,16 +87,29 @@ struct ArrayFirstLastImpl
                     else
                     {
                         out->insertDefault();
+
+                        if constexpr (element_not_exists_strategy == ArrayFirstLastElementNotExistsStrategy::Null)
+                            (*vec_null_map_to)[offset_index] = true;
                     }
                 }
 
+                if constexpr (element_not_exists_strategy == ArrayFirstLastElementNotExistsStrategy::Null)
+                    return ColumnNullable::create(std::move(out), std::move(col_null_map_to));
+
                 return out;
             }
             else
             {
                 auto out = array.getData().cloneEmpty();
-                out->insertDefault();
-                return out->replicate(IColumn::Offsets(1, array.size()));
+                out->insertManyDefaults(array.size());
+
+                if constexpr (element_not_exists_strategy == ArrayFirstLastElementNotExistsStrategy::Null)
+                {
+                    auto col_null_map_to = ColumnUInt8::create(out->size(), true);
+                    return ColumnNullable::create(std::move(out), std::move(col_null_map_to));
+                }
+
+                return out;
             }
         }
 
@@ -87,6 +120,16 @@ struct ArrayFirstLastImpl
         out->reserve(data.size());
 
         size_t offsets_size = offsets.size();
+
+        ColumnUInt8::MutablePtr col_null_map_to;
+        ColumnUInt8::Container * vec_null_map_to = nullptr;
+
+        if constexpr (element_not_exists_strategy == ArrayFirstLastElementNotExistsStrategy::Null)
+        {
+            col_null_map_to = ColumnUInt8::create(offsets_size, false);
+            vec_null_map_to = &col_null_map_to->getData();
+        }
+
         for (size_t offset_index = 0; offset_index < offsets_size; ++offset_index)
         {
             size_t start_offset = offsets[offset_index - 1];
@@ -120,25 +163,43 @@ struct ArrayFirstLastImpl
             }
 
             if (!exists)
+            {
                 out->insertDefault();
+
+                if constexpr (element_not_exists_strategy == ArrayFirstLastElementNotExistsStrategy::Null)
+                    (*vec_null_map_to)[offset_index] = true;
+            }
         }
 
+        if constexpr (element_not_exists_strategy == ArrayFirstLastElementNotExistsStrategy::Null)
+            return ColumnNullable::create(std::move(out), std::move(col_null_map_to));
+
         return out;
     }
 };
 
 struct NameArrayFirst { static constexpr auto name = "arrayFirst"; };
-using ArrayFirstImpl = ArrayFirstLastImpl<ArrayFirstLastStrategy::First>;
+using ArrayFirstImpl = ArrayFirstLastImpl<ArrayFirstLastStrategy::First, ArrayFirstLastElementNotExistsStrategy::Default>;
 using FunctionArrayFirst = FunctionArrayMapped<ArrayFirstImpl, NameArrayFirst>;
 
+struct NameArrayFirstOrNull { static constexpr auto name = "arrayFirstOrNull"; };
+using ArrayFirstOrNullImpl = ArrayFirstLastImpl<ArrayFirstLastStrategy::First, ArrayFirstLastElementNotExistsStrategy::Null>;
+using FunctionArrayFirstOrNull = FunctionArrayMapped<ArrayFirstOrNullImpl, NameArrayFirstOrNull>;
+
 struct NameArrayLast { static constexpr auto name = "arrayLast"; };
-using ArrayLastImpl = ArrayFirstLastImpl<ArrayFirstLastStrategy::Last>;
+using ArrayLastImpl = ArrayFirstLastImpl<ArrayFirstLastStrategy::Last, ArrayFirstLastElementNotExistsStrategy::Default>;
 using FunctionArrayLast = FunctionArrayMapped<ArrayLastImpl, NameArrayLast>;
 
+struct NameArrayLastOrNull { static constexpr auto name = "arrayLastOrNull"; };
+using ArrayLastOrNullImpl = ArrayFirstLastImpl<ArrayFirstLastStrategy::Last, ArrayFirstLastElementNotExistsStrategy::Null>;
+using FunctionArrayLastOrNull = FunctionArrayMapped<ArrayLastOrNullImpl, NameArrayLastOrNull>;
+
 void registerFunctionArrayFirst(FunctionFactory & factory)
 {
     factory.registerFunction<FunctionArrayFirst>();
+    factory.registerFunction<FunctionArrayFirstOrNull>();
     factory.registerFunction<FunctionArrayLast>();
+    factory.registerFunction<FunctionArrayLastOrNull>();
 }
 
 }
