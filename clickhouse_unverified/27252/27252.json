{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 27252,
  "instance_id": "ClickHouse__ClickHouse-27252",
  "issue_numbers": [
    "26555"
  ],
  "base_commit": "560e71dcfa1b572eb1272c2304b0b17fb846f7f4",
  "patch": "diff --git a/base/common/memory.h b/base/common/memory.h\ndeleted file mode 100644\nindex e82c019ceaba..000000000000\n--- a/base/common/memory.h\n+++ /dev/null\n@@ -1,57 +0,0 @@\n-#pragma once\n-\n-#include <new>\n-#include \"defines.h\"\n-\n-#if USE_JEMALLOC\n-#    include <jemalloc/jemalloc.h>\n-#endif\n-\n-#if !USE_JEMALLOC || JEMALLOC_VERSION_MAJOR < 4\n-#    include <cstdlib>\n-#endif\n-\n-\n-namespace Memory\n-{\n-\n-inline ALWAYS_INLINE void * newImpl(std::size_t size)\n-{\n-    auto * ptr = malloc(size);\n-    if (likely(ptr != nullptr))\n-        return ptr;\n-\n-    /// @note no std::get_new_handler logic implemented\n-    throw std::bad_alloc{};\n-}\n-\n-inline ALWAYS_INLINE void * newNoExept(std::size_t size) noexcept\n-{\n-    return malloc(size);\n-}\n-\n-inline ALWAYS_INLINE void deleteImpl(void * ptr) noexcept\n-{\n-    free(ptr);\n-}\n-\n-#if USE_JEMALLOC && JEMALLOC_VERSION_MAJOR >= 4\n-\n-inline ALWAYS_INLINE void deleteSized(void * ptr, std::size_t size) noexcept\n-{\n-    if (unlikely(ptr == nullptr))\n-        return;\n-\n-    sdallocx(ptr, size, 0);\n-}\n-\n-#else\n-\n-inline ALWAYS_INLINE void deleteSized(void * ptr, std::size_t size [[maybe_unused]]) noexcept\n-{\n-    free(ptr);\n-}\n-\n-#endif\n-\n-}\ndiff --git a/contrib/croaring-cmake/CMakeLists.txt b/contrib/croaring-cmake/CMakeLists.txt\nindex f4a5d8a01dce..f0cb378864b5 100644\n--- a/contrib/croaring-cmake/CMakeLists.txt\n+++ b/contrib/croaring-cmake/CMakeLists.txt\n@@ -24,3 +24,19 @@ add_library(roaring ${SRCS})\n target_include_directories(roaring PRIVATE \"${LIBRARY_DIR}/include/roaring\")\n target_include_directories(roaring SYSTEM BEFORE PUBLIC \"${LIBRARY_DIR}/include\")\n target_include_directories(roaring SYSTEM BEFORE PUBLIC \"${LIBRARY_DIR}/cpp\")\n+\n+# We redirect malloc/free family of functions to different functions that will track memory in ClickHouse.\n+# It will make this library depend on linking to 'clickhouse_common_io' library that is not done explicitly via 'target_link_libraries'.\n+# And we check that all libraries dependencies are satisfied and all symbols are resolved if we do build with shared libraries.\n+# That's why we enable it only in static build.\n+# Also note that we exploit implicit function declarations.\n+\n+if (USE_STATIC_LIBRARIES)\n+    target_compile_definitions(roaring PRIVATE\n+        -Dmalloc=clickhouse_malloc\n+        -Dcalloc=clickhouse_calloc\n+        -Drealloc=clickhouse_realloc\n+        -Dreallocarray=clickhouse_reallocarray\n+        -Dfree=clickhouse_free\n+        -Dposix_memalign=clickhouse_posix_memalign)\n+endif ()\ndiff --git a/src/AggregateFunctions/AggregateFunctionGroupBitmapData.h b/src/AggregateFunctions/AggregateFunctionGroupBitmapData.h\nindex 067daf6dc3a6..95c7e6075d7c 100644\n--- a/src/AggregateFunctions/AggregateFunctionGroupBitmapData.h\n+++ b/src/AggregateFunctions/AggregateFunctionGroupBitmapData.h\n@@ -44,7 +44,7 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable\n \n     void toLarge()\n     {\n-        rb = std::make_unique<RoaringBitmap>();\n+        rb = std::make_shared<RoaringBitmap>();\n         for (const auto & x : small)\n             rb->add(static_cast<Value>(x.getValue()));\n         small.clear();\n@@ -114,7 +114,7 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable\n             readVarUInt(size, in);\n             std::unique_ptr<char[]> buf(new char[size]);\n             in.readStrict(buf.get(), size);\n-            rb = std::make_unique<RoaringBitmap>(RoaringBitmap::read(buf.get()));\n+            rb = std::make_shared<RoaringBitmap>(RoaringBitmap::read(buf.get()));\n         }\n     }\n \n@@ -141,7 +141,7 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable\n      */\n     std::shared_ptr<RoaringBitmap> getNewRoaringBitmapFromSmall() const\n     {\n-        std::shared_ptr<RoaringBitmap> ret = std::make_unique<RoaringBitmap>();\n+        std::shared_ptr<RoaringBitmap> ret = std::make_shared<RoaringBitmap>();\n         for (const auto & x : small)\n             ret->add(static_cast<Value>(x.getValue()));\n         return ret;\ndiff --git a/src/CMakeLists.txt b/src/CMakeLists.txt\nindex 2853a2e1a811..6c10d3e2f2ba 100644\n--- a/src/CMakeLists.txt\n+++ b/src/CMakeLists.txt\n@@ -158,6 +158,8 @@ else()\n     target_link_libraries (clickhouse_new_delete PRIVATE clickhouse_common_io jemalloc)\n endif()\n \n+target_link_libraries (clickhouse_common_io PRIVATE jemalloc)\n+\n add_subdirectory(Common/ZooKeeper)\n add_subdirectory(Common/Config)\n \ndiff --git a/src/Common/CurrentMemoryTracker.cpp b/src/Common/CurrentMemoryTracker.cpp\nindex d38a5a9c70c9..bf0745e667e7 100644\n--- a/src/Common/CurrentMemoryTracker.cpp\n+++ b/src/Common/CurrentMemoryTracker.cpp\n@@ -3,6 +3,7 @@\n \n #include <Common/CurrentMemoryTracker.h>\n \n+\n namespace\n {\n \n@@ -36,6 +37,7 @@ namespace\n             if (current_thread)\n             {\n                 current_thread->untracked_memory += size;\n+\n                 if (current_thread->untracked_memory > current_thread->untracked_memory_limit)\n                 {\n                     /// Zero untracked before track. If tracker throws out-of-limit we would be able to alloc up to untracked_memory_limit bytes\n@@ -54,6 +56,12 @@ namespace\n     }\n }\n \n+void check()\n+{\n+    if (auto * memory_tracker = getMemoryTracker())\n+        memory_tracker->allocImpl(0, true);\n+}\n+\n void alloc(Int64 size)\n {\n     bool throw_if_memory_exceeded = true;\ndiff --git a/src/Common/CurrentMemoryTracker.h b/src/Common/CurrentMemoryTracker.h\nindex 5090b7c36875..2f9ace4291f9 100644\n--- a/src/Common/CurrentMemoryTracker.h\n+++ b/src/Common/CurrentMemoryTracker.h\n@@ -9,4 +9,5 @@ namespace CurrentMemoryTracker\n     void allocNoThrow(Int64 size);\n     void realloc(Int64 old_size, Int64 new_size);\n     void free(Int64 size);\n+    void check();\n }\ndiff --git a/src/Common/clickhouse_malloc.cpp b/src/Common/clickhouse_malloc.cpp\nnew file mode 100644\nindex 000000000000..3f69ebdf58dc\n--- /dev/null\n+++ b/src/Common/clickhouse_malloc.cpp\n@@ -0,0 +1,55 @@\n+#include <Common/memory.h>\n+#include <cstdlib>\n+\n+\n+/** These functions can be substituted instead of regular ones when memory tracking is needed.\n+  */\n+\n+extern \"C\" void * clickhouse_malloc(size_t size)\n+{\n+    void * res = malloc(size);\n+    if (res)\n+        Memory::trackMemory(size);\n+    return res;\n+}\n+\n+extern \"C\" void * clickhouse_calloc(size_t number_of_members, size_t size)\n+{\n+    void * res = calloc(number_of_members, size);\n+    if (res)\n+        Memory::trackMemory(number_of_members * size);\n+    return res;\n+}\n+\n+extern \"C\" void * clickhouse_realloc(void * ptr, size_t size)\n+{\n+    if (ptr)\n+        Memory::untrackMemory(ptr);\n+    void * res = realloc(ptr, size);\n+    if (res)\n+        Memory::trackMemory(size);\n+    return res;\n+}\n+\n+extern \"C\" void * clickhouse_reallocarray(void * ptr, size_t number_of_members, size_t size)\n+{\n+    size_t real_size = 0;\n+    if (__builtin_mul_overflow(number_of_members, size, &real_size))\n+        return nullptr;\n+\n+    return clickhouse_realloc(ptr, real_size);\n+}\n+\n+extern \"C\" void clickhouse_free(void * ptr)\n+{\n+    Memory::untrackMemory(ptr);\n+    free(ptr);\n+}\n+\n+extern \"C\" int clickhouse_posix_memalign(void ** memptr, size_t alignment, size_t size)\n+{\n+    int res = posix_memalign(memptr, alignment, size);\n+    if (res == 0)\n+        Memory::trackMemory(size);\n+    return res;\n+}\ndiff --git a/src/Common/memory.cpp b/src/Common/memory.cpp\nnew file mode 100644\nindex 000000000000..a79d35720719\n--- /dev/null\n+++ b/src/Common/memory.cpp\n@@ -0,0 +1,25 @@\n+#if defined(OS_DARWIN) && defined(BUNDLED_STATIC_JEMALLOC)\n+\n+extern \"C\"\n+{\n+    extern void zone_register();\n+}\n+\n+struct InitializeJemallocZoneAllocatorForOSX\n+{\n+    InitializeJemallocZoneAllocatorForOSX()\n+    {\n+        /// In case of OSX jemalloc register itself as a default zone allocator.\n+        ///\n+        /// But when you link statically then zone_register() will not be called,\n+        /// and even will be optimized out:\n+        ///\n+        /// It is ok to call it twice (i.e. in case of shared libraries)\n+        /// Since zone_register() is a no-op if the default zone is already replaced with something.\n+        ///\n+        /// https://github.com/jemalloc/jemalloc/issues/708\n+        zone_register();\n+    }\n+} initializeJemallocZoneAllocatorForOSX;\n+\n+#endif\ndiff --git a/src/Common/memory.h b/src/Common/memory.h\nnew file mode 100644\nindex 000000000000..84c6af9a1bef\n--- /dev/null\n+++ b/src/Common/memory.h\n@@ -0,0 +1,108 @@\n+#pragma once\n+\n+#include <new>\n+#include <common/defines.h>\n+\n+#include <Common/CurrentMemoryTracker.h>\n+\n+#if USE_JEMALLOC\n+#    include <jemalloc/jemalloc.h>\n+#endif\n+\n+#if !USE_JEMALLOC || JEMALLOC_VERSION_MAJOR < 4\n+#    include <cstdlib>\n+#endif\n+\n+\n+namespace Memory\n+{\n+\n+inline ALWAYS_INLINE void * newImpl(std::size_t size)\n+{\n+    auto * ptr = malloc(size);\n+    if (likely(ptr != nullptr))\n+        return ptr;\n+\n+    /// @note no std::get_new_handler logic implemented\n+    throw std::bad_alloc{};\n+}\n+\n+inline ALWAYS_INLINE void * newNoExept(std::size_t size) noexcept\n+{\n+    return malloc(size);\n+}\n+\n+inline ALWAYS_INLINE void deleteImpl(void * ptr) noexcept\n+{\n+    free(ptr);\n+}\n+\n+#if USE_JEMALLOC && JEMALLOC_VERSION_MAJOR >= 4\n+\n+inline ALWAYS_INLINE void deleteSized(void * ptr, std::size_t size) noexcept\n+{\n+    if (unlikely(ptr == nullptr))\n+        return;\n+\n+    sdallocx(ptr, size, 0);\n+}\n+\n+#else\n+\n+inline ALWAYS_INLINE void deleteSized(void * ptr, std::size_t size [[maybe_unused]]) noexcept\n+{\n+    free(ptr);\n+}\n+\n+#endif\n+\n+#if defined(OS_LINUX)\n+#   include <malloc.h>\n+#elif defined(OS_DARWIN)\n+#   include <malloc/malloc.h>\n+#endif\n+\n+\n+inline ALWAYS_INLINE size_t getActualAllocationSize(size_t size)\n+{\n+    size_t actual_size = size;\n+\n+#if USE_JEMALLOC && JEMALLOC_VERSION_MAJOR >= 5\n+    /// The nallocx() function allocates no memory, but it performs the same size computation as the mallocx() function\n+    /// @note je_mallocx() != je_malloc(). It's expected they don't differ much in allocation logic.\n+    if (likely(size != 0))\n+        actual_size = nallocx(size, 0);\n+#endif\n+\n+    return actual_size;\n+}\n+\n+inline ALWAYS_INLINE void trackMemory(std::size_t size)\n+{\n+    std::size_t actual_size = getActualAllocationSize(size);\n+    CurrentMemoryTracker::allocNoThrow(actual_size);\n+}\n+\n+inline ALWAYS_INLINE void untrackMemory(void * ptr [[maybe_unused]], std::size_t size [[maybe_unused]] = 0) noexcept\n+{\n+    try\n+    {\n+#if USE_JEMALLOC && JEMALLOC_VERSION_MAJOR >= 5\n+        /// @note It's also possible to use je_malloc_usable_size() here.\n+        if (likely(ptr != nullptr))\n+            CurrentMemoryTracker::free(sallocx(ptr, 0));\n+#else\n+        if (size)\n+            CurrentMemoryTracker::free(size);\n+#    if defined(_GNU_SOURCE)\n+        /// It's innaccurate resource free for sanitizers. malloc_usable_size() result is greater or equal to allocated size.\n+        else\n+            CurrentMemoryTracker::free(malloc_usable_size(ptr));\n+#    endif\n+#endif\n+    }\n+    catch (...)\n+    {}\n+}\n+\n+}\ndiff --git a/src/Common/new_delete.cpp b/src/Common/new_delete.cpp\nindex 56173fb108a7..fa32d56b350d 100644\n--- a/src/Common/new_delete.cpp\n+++ b/src/Common/new_delete.cpp\n@@ -1,117 +1,34 @@\n-#include <common/memory.h>\n-#include <Common/CurrentMemoryTracker.h>\n-\n-#include <iostream>\n+#include <Common/memory.h>\n #include <new>\n \n-#if defined(OS_LINUX)\n-#   include <malloc.h>\n-#elif defined(OS_DARWIN)\n-#   include <malloc/malloc.h>\n-#endif\n-\n-#if defined(OS_DARWIN) && defined(BUNDLED_STATIC_JEMALLOC)\n-extern \"C\"\n-{\n-extern void zone_register();\n-}\n-\n-struct InitializeJemallocZoneAllocatorForOSX\n-{\n-    InitializeJemallocZoneAllocatorForOSX()\n-    {\n-        /// In case of OSX jemalloc register itself as a default zone allocator.\n-        ///\n-        /// But when you link statically then zone_register() will not be called,\n-        /// and even will be optimized out:\n-        ///\n-        /// It is ok to call it twice (i.e. in case of shared libraries)\n-        /// Since zone_register() is a no-op if the default zone is already replaced with something.\n-        ///\n-        /// https://github.com/jemalloc/jemalloc/issues/708\n-        zone_register();\n-    }\n-} initializeJemallocZoneAllocatorForOSX;\n-#endif\n \n /// Replace default new/delete with memory tracking versions.\n /// @sa https://en.cppreference.com/w/cpp/memory/new/operator_new\n ///     https://en.cppreference.com/w/cpp/memory/new/operator_delete\n \n-namespace Memory\n-{\n-\n-inline ALWAYS_INLINE size_t getActualAllocationSize(size_t size)\n-{\n-    size_t actual_size = size;\n-\n-#if USE_JEMALLOC && JEMALLOC_VERSION_MAJOR >= 5\n-    /// The nallocx() function allocates no memory, but it performs the same size computation as the mallocx() function\n-    /// @note je_mallocx() != je_malloc(). It's expected they don't differ much in allocation logic.\n-    if (likely(size != 0))\n-        actual_size = nallocx(size, 0);\n-#endif\n-\n-    return actual_size;\n-}\n-\n-inline ALWAYS_INLINE void trackMemory(std::size_t size)\n-{\n-    std::size_t actual_size = getActualAllocationSize(size);\n-    CurrentMemoryTracker::allocNoThrow(actual_size);\n-}\n-\n-inline ALWAYS_INLINE void untrackMemory(void * ptr [[maybe_unused]], std::size_t size [[maybe_unused]] = 0) noexcept\n-{\n-    try\n-    {\n-#if USE_JEMALLOC && JEMALLOC_VERSION_MAJOR >= 5\n-        /// @note It's also possible to use je_malloc_usable_size() here.\n-        if (likely(ptr != nullptr))\n-            CurrentMemoryTracker::free(sallocx(ptr, 0));\n-#else\n-        if (size)\n-            CurrentMemoryTracker::free(size);\n-#    if defined(_GNU_SOURCE)\n-        /// It's innaccurate resource free for sanitizers. malloc_usable_size() result is greater or equal to allocated size.\n-        else\n-            CurrentMemoryTracker::free(malloc_usable_size(ptr));\n-#    endif\n-#endif\n-    }\n-    catch (...)\n-    {}\n-}\n-\n-}\n-\n /// new\n \n void * operator new(std::size_t size)\n {\n     Memory::trackMemory(size);\n-\n     return Memory::newImpl(size);\n }\n \n void * operator new[](std::size_t size)\n {\n     Memory::trackMemory(size);\n-\n     return Memory::newImpl(size);\n }\n \n void * operator new(std::size_t size, const std::nothrow_t &) noexcept\n {\n     Memory::trackMemory(size);\n-\n     return Memory::newNoExept(size);\n }\n \n void * operator new[](std::size_t size, const std::nothrow_t &) noexcept\n {\n     Memory::trackMemory(size);\n-\n     return Memory::newNoExept(size);\n }\n \ndiff --git a/src/Interpreters/Aggregator.cpp b/src/Interpreters/Aggregator.cpp\nindex 7ffae761c0c5..69ad1d56359a 100644\n--- a/src/Interpreters/Aggregator.cpp\n+++ b/src/Interpreters/Aggregator.cpp\n@@ -1193,6 +1193,9 @@ bool Aggregator::checkLimits(size_t result_size, bool & no_more_keys) const\n         }\n     }\n \n+    /// Some aggregate functions cannot throw exceptions on allocations (e.g. from C malloc)\n+    /// but still tracks memory. Check it here.\n+    CurrentMemoryTracker::check();\n     return true;\n }\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01961_roaring_memory_tracking.reference b/tests/queries/0_stateless/01961_roaring_memory_tracking.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/01961_roaring_memory_tracking.sql b/tests/queries/0_stateless/01961_roaring_memory_tracking.sql\nnew file mode 100644\nindex 000000000000..57d71cdc91c4\n--- /dev/null\n+++ b/tests/queries/0_stateless/01961_roaring_memory_tracking.sql\n@@ -0,0 +1,2 @@\n+SET max_memory_usage = '100M';\n+SELECT cityHash64(rand() % 1000) as n, groupBitmapState(number) FROM numbers_mt(2000000000) GROUP BY n; -- { serverError 241 }\n",
  "problem_statement": "Memory tracking issue in groupBitmapState ?\nThat query uses about 10Gb of RAM, should fail with that setting.\r\nIn practice it can go OOM, and clickhouse memory tracker doesn't know about that:\r\n\r\n```\r\nSET max_threads = 8, max_memory_usage = '3G';\r\nCREATE TABLE oom_issue ENGINE = AggregatingMergeTree ORDER BY n AS\u3000SELECT cityHash64(rand() % 1000) as n, groupBitmapState(number) FROM numbers_mt(2000000000) GROUP BY n;\r\n```\r\n\r\n```\r\n[laptop-5591] 2021.07.20 13:22:45.739115 [ 272424 ] {cda8ab45-5c7c-47de-83eb-14ec6d0fdb4c} <Debug> MemoryTracker: Peak memory usage (for query): 6.53 MiB.\r\n```\n",
  "hints_text": "It's likely because CRoaring is a C library. Perhaps we need to do memory tracking over malloc.\nWe can add a setting `allow_roaring_bitmap` to prevent usage of these functions if memory consumption for arbitrary queries has to be enforced. Not the best solution, though.",
  "created_at": "2021-08-05T20:46:19Z",
  "modified_files": [
    "base/common/memory.h",
    "contrib/croaring-cmake/CMakeLists.txt",
    "src/AggregateFunctions/AggregateFunctionGroupBitmapData.h",
    "src/CMakeLists.txt",
    "src/Common/CurrentMemoryTracker.cpp",
    "src/Common/CurrentMemoryTracker.h",
    "b/src/Common/clickhouse_malloc.cpp",
    "b/src/Common/memory.cpp",
    "b/src/Common/memory.h",
    "src/Common/new_delete.cpp",
    "src/Interpreters/Aggregator.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01961_roaring_memory_tracking.sql"
  ]
}