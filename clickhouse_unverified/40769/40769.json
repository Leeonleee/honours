{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 40769,
  "instance_id": "ClickHouse__ClickHouse-40769",
  "issue_numbers": [
    "40595"
  ],
  "base_commit": "88141cae98d7dad12720423c9ddbb98551d089f7",
  "patch": "diff --git a/src/Access/Common/AllowedClientHosts.cpp b/src/Access/Common/AllowedClientHosts.cpp\nindex efbdf3924e81..2f8151bf7578 100644\n--- a/src/Access/Common/AllowedClientHosts.cpp\n+++ b/src/Access/Common/AllowedClientHosts.cpp\n@@ -110,7 +110,7 @@ namespace\n     }\n \n     /// Returns the host name by its address.\n-    Strings getHostsByAddress(const IPAddress & address)\n+    std::unordered_set<String> getHostsByAddress(const IPAddress & address)\n     {\n         auto hosts = DNSResolver::instance().reverseResolve(address);\n \n@@ -526,7 +526,7 @@ bool AllowedClientHosts::contains(const IPAddress & client_address) const\n             return true;\n \n     /// Check `name_regexps`.\n-    std::optional<Strings> resolved_hosts;\n+    std::optional<std::unordered_set<String>> resolved_hosts;\n     auto check_name_regexp = [&](const String & name_regexp_)\n     {\n         try\ndiff --git a/src/Common/CaresPTRResolver.cpp b/src/Common/CaresPTRResolver.cpp\nindex 376d3665f7ed..e5d48b864c80 100644\n--- a/src/Common/CaresPTRResolver.cpp\n+++ b/src/Common/CaresPTRResolver.cpp\n@@ -15,13 +15,23 @@ namespace DB\n \n     static void callback(void * arg, int status, int, struct hostent * host)\n     {\n-        auto * ptr_records = reinterpret_cast<std::vector<std::string>*>(arg);\n+        auto * ptr_records = reinterpret_cast<std::unordered_set<std::string>*>(arg);\n         if (status == ARES_SUCCESS && host->h_aliases)\n         {\n+            /*\n+             * In some cases (e.g /etc/hosts), hostent::h_name is filled and hostent::h_aliases is empty.\n+             * Thus, we can't rely solely on hostent::h_aliases. More info on:\n+             * https://github.com/ClickHouse/ClickHouse/issues/40595#issuecomment-1230526931\n+             * */\n+            if (auto * ptr_record = host->h_name)\n+            {\n+                ptr_records->insert(ptr_record);\n+            }\n+\n             int i = 0;\n             while (auto * ptr_record = host->h_aliases[i])\n             {\n-                ptr_records->emplace_back(ptr_record);\n+                ptr_records->insert(ptr_record);\n                 i++;\n             }\n         }\n@@ -58,9 +68,9 @@ namespace DB\n          * */\n     }\n \n-    std::vector<std::string> CaresPTRResolver::resolve(const std::string & ip)\n+    std::unordered_set<std::string> CaresPTRResolver::resolve(const std::string & ip)\n     {\n-        std::vector<std::string> ptr_records;\n+        std::unordered_set<std::string> ptr_records;\n \n         resolve(ip, ptr_records);\n         wait();\n@@ -68,9 +78,9 @@ namespace DB\n         return ptr_records;\n     }\n \n-    std::vector<std::string> CaresPTRResolver::resolve_v6(const std::string & ip)\n+    std::unordered_set<std::string> CaresPTRResolver::resolve_v6(const std::string & ip)\n     {\n-        std::vector<std::string> ptr_records;\n+        std::unordered_set<std::string> ptr_records;\n \n         resolve_v6(ip, ptr_records);\n         wait();\n@@ -78,7 +88,7 @@ namespace DB\n         return ptr_records;\n     }\n \n-    void CaresPTRResolver::resolve(const std::string & ip, std::vector<std::string> & response)\n+    void CaresPTRResolver::resolve(const std::string & ip, std::unordered_set<std::string> & response)\n     {\n         in_addr addr;\n \n@@ -87,7 +97,7 @@ namespace DB\n         ares_gethostbyaddr(channel, reinterpret_cast<const void*>(&addr), sizeof(addr), AF_INET, callback, &response);\n     }\n \n-    void CaresPTRResolver::resolve_v6(const std::string & ip, std::vector<std::string> & response)\n+    void CaresPTRResolver::resolve_v6(const std::string & ip, std::unordered_set<std::string> & response)\n     {\n         in6_addr addr;\n         inet_pton(AF_INET6, ip.c_str(), &addr);\ndiff --git a/src/Common/CaresPTRResolver.h b/src/Common/CaresPTRResolver.h\nindex fd6a1cf7bc57..e5182d346820 100644\n--- a/src/Common/CaresPTRResolver.h\n+++ b/src/Common/CaresPTRResolver.h\n@@ -25,16 +25,16 @@ namespace DB\n         explicit CaresPTRResolver(provider_token);\n         ~CaresPTRResolver() override;\n \n-        std::vector<std::string> resolve(const std::string & ip) override;\n+        std::unordered_set<std::string> resolve(const std::string & ip) override;\n \n-        std::vector<std::string> resolve_v6(const std::string & ip) override;\n+        std::unordered_set<std::string> resolve_v6(const std::string & ip) override;\n \n     private:\n         void wait();\n \n-        void resolve(const std::string & ip, std::vector<std::string> & response);\n+        void resolve(const std::string & ip, std::unordered_set<std::string> & response);\n \n-        void resolve_v6(const std::string & ip, std::vector<std::string> & response);\n+        void resolve_v6(const std::string & ip, std::unordered_set<std::string> & response);\n \n         ares_channel channel;\n     };\ndiff --git a/src/Common/DNSPTRResolver.h b/src/Common/DNSPTRResolver.h\nindex e6cce83f79da..38f890ae29a5 100644\n--- a/src/Common/DNSPTRResolver.h\n+++ b/src/Common/DNSPTRResolver.h\n@@ -1,7 +1,7 @@\n #pragma once\n \n #include <string>\n-#include <vector>\n+#include <unordered_set>\n \n namespace DB\n {\n@@ -10,9 +10,9 @@ namespace DB\n \n         virtual ~DNSPTRResolver() = default;\n \n-        virtual std::vector<std::string> resolve(const std::string & ip) = 0;\n+        virtual std::unordered_set<std::string> resolve(const std::string & ip) = 0;\n \n-        virtual std::vector<std::string> resolve_v6(const std::string & ip) = 0;\n+        virtual std::unordered_set<std::string> resolve_v6(const std::string & ip) = 0;\n \n     };\n }\ndiff --git a/src/Common/DNSResolver.cpp b/src/Common/DNSResolver.cpp\nindex cf61d2795f09..67d87f757c74 100644\n--- a/src/Common/DNSResolver.cpp\n+++ b/src/Common/DNSResolver.cpp\n@@ -136,7 +136,7 @@ static DNSResolver::IPAddresses resolveIPAddressImpl(const std::string & host)\n     return addresses;\n }\n \n-static Strings reverseResolveImpl(const Poco::Net::IPAddress & address)\n+static std::unordered_set<String> reverseResolveImpl(const Poco::Net::IPAddress & address)\n {\n     auto ptr_resolver = DB::DNSPTRResolverProvider::get();\n \n@@ -234,7 +234,7 @@ std::vector<Poco::Net::SocketAddress> DNSResolver::resolveAddressList(const std:\n     return addresses;\n }\n \n-Strings DNSResolver::reverseResolve(const Poco::Net::IPAddress & address)\n+std::unordered_set<String> DNSResolver::reverseResolve(const Poco::Net::IPAddress & address)\n {\n     if (impl->disable_cache)\n         return reverseResolveImpl(address);\ndiff --git a/src/Common/DNSResolver.h b/src/Common/DNSResolver.h\nindex 84c885866362..83de616d81a6 100644\n--- a/src/Common/DNSResolver.h\n+++ b/src/Common/DNSResolver.h\n@@ -37,7 +37,7 @@ class DNSResolver : private boost::noncopyable\n     std::vector<Poco::Net::SocketAddress> resolveAddressList(const std::string & host, UInt16 port);\n \n     /// Accepts host IP and resolves its host names\n-    Strings reverseResolve(const Poco::Net::IPAddress & address);\n+    std::unordered_set<String> reverseResolve(const Poco::Net::IPAddress & address);\n \n     /// Get this server host name\n     String getHostName();\n",
  "test_patch": "diff --git a/tests/integration/test_host_regexp_hosts_file_resolution/__init__.py b/tests/integration/test_host_regexp_hosts_file_resolution/__init__.py\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/integration/test_host_regexp_hosts_file_resolution/configs/host_regexp.xml b/tests/integration/test_host_regexp_hosts_file_resolution/configs/host_regexp.xml\nnew file mode 100644\nindex 000000000000..7a2141e6c7e2\n--- /dev/null\n+++ b/tests/integration/test_host_regexp_hosts_file_resolution/configs/host_regexp.xml\n@@ -0,0 +1,11 @@\n+<yandex>\n+    <users>\n+        <test_dns>\n+            <password/>\n+            <networks>\n+                <host_regexp>test1\\.example\\.com$</host_regexp>\n+            </networks>\n+            <profile>default</profile>\n+        </test_dns>\n+    </users>\n+</yandex>\n\\ No newline at end of file\ndiff --git a/tests/integration/test_host_regexp_hosts_file_resolution/configs/listen_host.xml b/tests/integration/test_host_regexp_hosts_file_resolution/configs/listen_host.xml\nnew file mode 100644\nindex 000000000000..58ef55cd3f35\n--- /dev/null\n+++ b/tests/integration/test_host_regexp_hosts_file_resolution/configs/listen_host.xml\n@@ -0,0 +1,5 @@\n+<yandex>\n+    <listen_host>::</listen_host>\n+    <listen_host>0.0.0.0</listen_host>\n+    <listen_try>1</listen_try>\n+</yandex>\ndiff --git a/tests/integration/test_host_regexp_hosts_file_resolution/test.py b/tests/integration/test_host_regexp_hosts_file_resolution/test.py\nnew file mode 100644\nindex 000000000000..3fd9e65cf2ac\n--- /dev/null\n+++ b/tests/integration/test_host_regexp_hosts_file_resolution/test.py\n@@ -0,0 +1,46 @@\n+import pytest\n+from helpers.cluster import ClickHouseCluster, get_docker_compose_path, run_and_check\n+import os\n+\n+DOCKER_COMPOSE_PATH = get_docker_compose_path()\n+SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))\n+\n+cluster = ClickHouseCluster(__file__)\n+\n+ch_server = cluster.add_instance(\n+    \"clickhouse-server\",\n+    main_configs=[\"configs/listen_host.xml\"],\n+    user_configs=[\"configs/host_regexp.xml\"],\n+)\n+\n+client = cluster.add_instance(\n+    \"clickhouse-client\",\n+)\n+\n+\n+def build_endpoint_v4(ip):\n+    return f\"'http://{ip}:8123/?query=SELECT+1&user=test_dns'\"\n+\n+\n+@pytest.fixture(scope=\"module\")\n+def started_cluster():\n+    global cluster\n+    try:\n+        cluster.start()\n+        yield cluster\n+\n+    finally:\n+        cluster.shutdown()\n+\n+\n+def test_host_regexp_multiple_ptr_hosts_file_v4(started_cluster):\n+    server_ip = cluster.get_instance_ip(\"clickhouse-server\")\n+    client_ip = cluster.get_instance_ip(\"clickhouse-client\")\n+\n+    ch_server.exec_in_container(\n+        ([\"bash\", \"-c\", f\"echo '{client_ip} test1.example.com' > /etc/hosts\"])\n+    )\n+\n+    endpoint = build_endpoint_v4(server_ip)\n+\n+    assert \"1\\n\" == client.exec_in_container(([\"bash\", \"-c\", f\"curl {endpoint}\"]))\n",
  "problem_statement": "22.8.2 version   users.xml <host_regexp> abnormal\n> Make sure to check documentation https://clickhouse.com/docs/en/ first. If the question is concise and probably has a short answer, asking it in Telegram chat https://telegram.me/clickhouse_en is probably the fastest way to find the answer. For more complicated questions, consider asking them on StackOverflow with \"clickhouse\" tag https://stackoverflow.com/questions/tagged/clickhouse \r\n\r\n> If you still prefer GitHub issues, remove all this text and ask your question here.\r\n\r\n`            <networks incl=\"networks\" replace=\"replace\">\r\n                <ip>127.0.0.1</ip>\r\n                <host_regexp>^abc00[1-6]$</host_regexp>\r\n            </networks>\r\n`\r\n`clickhouse-client --host abc003\r\nClickHouse client version 22.8.2.11 (official build).\r\nConnecting to abc003:9000 as user default.\r\n\r\nIf you have installed ClickHouse and forgot password you can reset it in the configuration file.\r\nThe password for default user is typically located at /etc/clickhouse-server/users.d/default-password.xml\r\nand deleting this file will reset the password.\r\nSee also /etc/clickhouse-server/users.xml on the server where ClickHouse is installed.\r\n\r\nCode: 516. DB::Exception: Received from abc003:9000. DB::Exception: default: Authentication failed: password is incorrect or there is no user with such name. (AUTHENTICATION_FAILED)`\r\n\r\n\r\n`if use <host> no problem`\n",
  "hints_text": "Did it work before? Which version?\n> Did it work before? Which version?\r\n\r\nIt was 22.3.10.22 before, \n@tavplubix should we revert https://github.com/ClickHouse/ClickHouse/pull/37827?\nWe can try to fix it and revert if it cannot be easily fixed. More information is needed:\r\n\r\n@xujinlong0314, please find the corresponding message in server log:\r\n```\r\nzgrep -Fa \"Authentication failed\" /var/log/clickhouse-server/clickhouse-server.log\r\n```\r\nThe message will look like:\r\n```\r\n2022.08.25 20:53:09.705658 [ 94932 ] {} <Error> Access(user directories): from: ::1, user: user_name: Authentication failed: Code: 192. DB::Exception: There is no user `user_name` in local directory. (UNKNOWN_USER), Stack trace (when copying this message, always include the lines below):\r\n```\r\nWe are interested in the client address (in the example above it's here: `from: ::1`)\r\n\r\nThen we need to know to which host names is this address resolved to:\r\n```\r\ndig -x <that address>\r\npython3 -c \"import socket;print(socket.getnameinfo(('<that address>', 0), socket.NI_NAMEREQD));print(socket.gethostbyaddr('<that address>'))\"\r\n```\r\n(output of both commands is required)\r\n\r\ncc: @arthurpassos \nI have just tested a similar setup in my local environment.\r\n\r\n```\r\n157     IN      PTR     abc003.\r\nabc003. IN A 192.168.0.157\r\n\r\narthur@arthur:~$ nslookup 192.168.0.157\r\n157.0.168.192.in-addr.arpa\tname = abc003.\r\n\r\n\r\narthur@arthur:~$ nslookup abc003\r\nServer:\t\t127.0.0.1\r\nAddress:\t127.0.0.1#53\r\n\r\nName:\tabc003\r\nAddress: 192.168.0.157\r\n\r\n\r\n```\r\n\r\nClickHouse host config:\r\n```\r\n<yandex>\r\n    <users>\r\n        <test_dns>\r\n            <password/>\r\n            <networks>\r\n                <host_regexp>^abc00[1-6]$</host_regexp>\r\n            </networks>\r\n            <profile>default</profile>\r\n        </test_dns>\r\n    </users>\r\n</yandex>\r\n```\r\n\r\nTest:\r\n```\r\narthur@arthur:~$ curl --interface 192.168.0.157 'http://127.0.0.1:8123/?query=SELECT+version()&user=test_dns'\r\n22.9.1.1\r\n```\r\nThe differences lie in `incl=\"networks\" replace=\"replace\"`. I am not sure what those refer to, but don't seem related. I am not using localhost, but doesn't seem related either.\r\n\r\nPlease let me know if I have missed anything @tavplubix @xujinlong0314 \n> We can try to fix it and revert if it cannot be easily fixed. More information is needed:\r\n> \r\n> @xujinlong0314, please find the corresponding message in server log:\r\n> \r\n> ```\r\n> zgrep -Fa \"Authentication failed\" /var/log/clickhouse-server/clickhouse-server.log\r\n> ```\r\n> \r\n> The message will look like:\r\n> \r\n> ```\r\n> 2022.08.25 20:53:09.705658 [ 94932 ] {} <Error> Access(user directories): from: ::1, user: user_name: Authentication failed: Code: 192. DB::Exception: There is no user `user_name` in local directory. (UNKNOWN_USER), Stack trace (when copying this message, always include the lines below):\r\n> ```\r\n> \r\n> We are interested in the client address (in the example above it's here: `from: ::1`)\r\n> \r\n> Then we need to know to which host names is this address resolved to:\r\n> \r\n> ```\r\n> dig -x <that address>\r\n> python3 -c \"import socket;print(socket.getnameinfo(('<that address>', 0), socket.NI_NAMEREQD));print(socket.gethostbyaddr('<that address>'))\"\r\n> ```\r\n> \r\n> (output of both commands is required)\r\n> \r\n> cc: @arthurpassos\r\n\r\n\r\n`<networks incl=\"networks\" replace=\"replace\">\r\n\t<ip>127.0.0.1</ip>\r\n\t<host_regexp>^ck[1-9]$</host_regexp>\r\n</networks>\r\n`\r\n\r\n`cat /etc/hosts\r\n10.0.7.18 ck1\r\n10.0.7.19 ck2\r\n10.0.7.20 ck3`\r\n\r\n`2022.08.29 09:25:57.586934 [ 3179 ] {} <Error> Access(user directories): from: 10.0.7.18, user: default: Authentication failed: Code: 195. DB::Exception: Connections from 10.0.7tack trace (when copying this message, always include the lines below):\r\n`\r\n\r\n`python -c \"import socket;print(socket.getnameinfo(('10.0.7.18', 0), socket.NI_NAMEREQD));print(socket.gethostbyaddr('10.0.7.18'))\"\r\n('ck1', '0')\r\n('ck1', [], ['10.0.7.18'])`\r\n\r\n`dig -x 10.0.7.18;\r\n; <<>> DiG 9.11.4-P2-RedHat-9.11.4-9.P2.el7 <<>> -x 10.0.7.18\r\n;; global options: +cmd\r\n;; Got answer:\r\n;; ->>HEADER<<- opcode: QUERY, status: NXDOMAIN, id: 28784\r\n;; flags: qr aa rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1\r\n;; OPT PSEUDOSECTION:\r\n; EDNS: version: 0, flags:; udp: 4096\r\n;; QUESTION SECTION:\r\n;18.7.0.10.in-addr.arpa.\t\tIN\tPTR\r\n;; AUTHORITY SECTION:\r\n10.in-addr.arpa.\t10800\tIN\tSOA\tlocalhost. nobody.invalid. 1 3600 1200 604800 10800\r\n;; Query time: 1 msec\r\n;; SERVER: 10.0.1.146#53(10.0.1.146)\r\n;; WHEN: Mon Aug 29 09:35:05 CST 2022\r\n;; MSG SIZE  rcvd: 110`\r\n\r\n\r\n\r\n\r\n\n> `cat /etc/hosts 10.0.7.18 ck1 10.0.7.19 ck2 10.0.7.20 ck3`\r\n\r\nThis is really important, better to mention things like that when creating an issue.\r\n\r\nSo `getnameinfo` respects `/etc/hosts` and `dig` does not. Maybe `c-ares` does not respect it too for some reason (but it [should](https://github.com/c-ares/c-ares/blob/de042a65f492f8a8b0a10bf21494623b9ac345fd/src/lib/ares_gethostbyaddr.c#L169)). Please also share the content of `/etc/resolv.conf`.\n> > `cat /etc/hosts 10.0.7.18 ck1 10.0.7.19 ck2 10.0.7.20 ck3`\r\n> \r\n> This is really important, better to mention things like that when creating an issue.\r\n> \r\n> So `getnameinfo` respects `/etc/hosts` and `dig` does not. Maybe `c-ares` does not respect it too for some reason (but it [should](https://github.com/c-ares/c-ares/blob/de042a65f492f8a8b0a10bf21494623b9ac345fd/src/lib/ares_gethostbyaddr.c#L169)). Please also share the content of `/etc/resolv.conf`.\r\n\r\n`c-ares` does query `/etc/hosts`. It fills out the `hostent::h_name` member, but we are checkin only for `hostent::h_aliases` in the resolver [callback](https://github.com/ClickHouse/ClickHouse/blob/master/src/Common/CaresPTRResolver.cpp#L22).\r\n\r\nThere are a couple of ways to approach this, each with its pros and cons:\r\n\r\n1. Append `hostent::h_name` to the return vector if it's not null. It would solve the problem, but could cause duplicates.\r\n2. Use a `std::unordered_set` instead of a `vector` to avoid duplicates. It could add some extra overhead, but probably fine to do so.\r\n3. Understand all the inner workings and small details of the `c-ares` library to properly handle corner cases. This is time consuming and prone to future problems in case the inner workings of the library change, we should strive to rely on the public interface and documentation.\r\n4. Skip the first alias in case `hostent::h_name` is not null. Dangerous because we do not know if the first entry will always match the `h_name`\r\n\r\nI'll publish a PR with approach 2 and we can discuss it there.",
  "created_at": "2022-08-29T18:15:23Z",
  "modified_files": [
    "src/Access/Common/AllowedClientHosts.cpp",
    "src/Common/CaresPTRResolver.cpp",
    "src/Common/CaresPTRResolver.h",
    "src/Common/DNSPTRResolver.h",
    "src/Common/DNSResolver.cpp",
    "src/Common/DNSResolver.h"
  ],
  "modified_test_files": [
    "b/tests/integration/test_host_regexp_hosts_file_resolution/configs/host_regexp.xml",
    "b/tests/integration/test_host_regexp_hosts_file_resolution/configs/listen_host.xml",
    "b/tests/integration/test_host_regexp_hosts_file_resolution/test.py"
  ]
}