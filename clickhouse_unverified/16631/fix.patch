diff --git a/src/AggregateFunctions/AggregateFunctionSumMap.h b/src/AggregateFunctions/AggregateFunctionSumMap.h
index 456334ee9c31..c991474d0e65 100644
--- a/src/AggregateFunctions/AggregateFunctionSumMap.h
+++ b/src/AggregateFunctions/AggregateFunctionSumMap.h
@@ -56,7 +56,7 @@ struct AggregateFunctionMapData
   * minMap and maxMap share the same idea, but calculate min and max correspondingly.
   */
 
-template <typename T, typename Derived, typename Visitor, bool overflow, bool tuple_argument>
+template <typename T, typename Derived, typename Visitor, bool overflow, bool tuple_argument, bool compact>
 class AggregateFunctionMapBase : public IAggregateFunctionDataHelper<
     AggregateFunctionMapData<NearestFieldType<T>>, Derived>
 {
@@ -255,23 +255,28 @@ class AggregateFunctionMapBase : public IAggregateFunctionDataHelper<
     {
         // Final step does compaction of keys that have zero values, this mutates the state
         auto & merged_maps = this->data(place).merged_maps;
-        for (auto it = merged_maps.cbegin(); it != merged_maps.cend();)
+
+        // Remove keys which are zeros or empty. This should be enabled only for sumMap.
+        if constexpr (compact)
         {
-            // Key is not compacted if it has at least one non-zero value
-            bool erase = true;
-            for (size_t col = 0; col < values_types.size(); ++col)
+            for (auto it = merged_maps.cbegin(); it != merged_maps.cend();)
             {
-                if (it->second[col] != values_types[col]->getDefault())
+                // Key is not compacted if it has at least one non-zero value
+                bool erase = true;
+                for (size_t col = 0; col < values_types.size(); ++col)
                 {
-                    erase = false;
-                    break;
+                    if (it->second[col] != values_types[col]->getDefault())
+                    {
+                        erase = false;
+                        break;
+                    }
                 }
-            }
 
-            if (erase)
-                it = merged_maps.erase(it);
-            else
-                ++it;
+                if (erase)
+                    it = merged_maps.erase(it);
+                else
+                    ++it;
+            }
         }
 
         size_t size = merged_maps.size();
@@ -314,11 +319,11 @@ class AggregateFunctionMapBase : public IAggregateFunctionDataHelper<
 
 template <typename T, bool overflow, bool tuple_argument>
 class AggregateFunctionSumMap final :
-    public AggregateFunctionMapBase<T, AggregateFunctionSumMap<T, overflow, tuple_argument>, FieldVisitorSum, overflow, tuple_argument>
+    public AggregateFunctionMapBase<T, AggregateFunctionSumMap<T, overflow, tuple_argument>, FieldVisitorSum, overflow, tuple_argument, true>
 {
 private:
     using Self = AggregateFunctionSumMap<T, overflow, tuple_argument>;
-    using Base = AggregateFunctionMapBase<T, Self, FieldVisitorSum, overflow, tuple_argument>;
+    using Base = AggregateFunctionMapBase<T, Self, FieldVisitorSum, overflow, tuple_argument, true>;
 
 public:
     AggregateFunctionSumMap(const DataTypePtr & keys_type_,
@@ -342,11 +347,12 @@ class AggregateFunctionSumMapFiltered final :
         AggregateFunctionSumMapFiltered<T, overflow, tuple_argument>,
         FieldVisitorSum,
         overflow,
-        tuple_argument>
+        tuple_argument,
+        true>
 {
 private:
     using Self = AggregateFunctionSumMapFiltered<T, overflow, tuple_argument>;
-    using Base = AggregateFunctionMapBase<T, Self, FieldVisitorSum, overflow, tuple_argument>;
+    using Base = AggregateFunctionMapBase<T, Self, FieldVisitorSum, overflow, tuple_argument, true>;
 
     /// ARCADIA_BUILD disallow unordered_set for big ints for some reason
     static constexpr const bool allow_hash = !OverBigInt<T>;
@@ -474,11 +480,11 @@ class FieldVisitorMin : public StaticVisitor<bool>
 
 template <typename T, bool tuple_argument>
 class AggregateFunctionMinMap final :
-    public AggregateFunctionMapBase<T, AggregateFunctionMinMap<T, tuple_argument>, FieldVisitorMin, true, tuple_argument>
+    public AggregateFunctionMapBase<T, AggregateFunctionMinMap<T, tuple_argument>, FieldVisitorMin, true, tuple_argument, false>
 {
 private:
     using Self = AggregateFunctionMinMap<T, tuple_argument>;
-    using Base = AggregateFunctionMapBase<T, Self, FieldVisitorMin, true, tuple_argument>;
+    using Base = AggregateFunctionMapBase<T, Self, FieldVisitorMin, true, tuple_argument, false>;
 
 public:
     AggregateFunctionMinMap(const DataTypePtr & keys_type_,
@@ -498,11 +504,11 @@ class AggregateFunctionMinMap final :
 
 template <typename T, bool tuple_argument>
 class AggregateFunctionMaxMap final :
-    public AggregateFunctionMapBase<T, AggregateFunctionMaxMap<T, tuple_argument>, FieldVisitorMax, true, tuple_argument>
+    public AggregateFunctionMapBase<T, AggregateFunctionMaxMap<T, tuple_argument>, FieldVisitorMax, true, tuple_argument, false>
 {
 private:
     using Self = AggregateFunctionMaxMap<T, tuple_argument>;
-    using Base = AggregateFunctionMapBase<T, Self, FieldVisitorMax, true, tuple_argument>;
+    using Base = AggregateFunctionMapBase<T, Self, FieldVisitorMax, true, tuple_argument, false>;
 
 public:
     AggregateFunctionMaxMap(const DataTypePtr & keys_type_,
