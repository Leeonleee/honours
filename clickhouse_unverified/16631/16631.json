{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 16631,
  "instance_id": "ClickHouse__ClickHouse-16631",
  "issue_numbers": [
    "16087"
  ],
  "base_commit": "268c80520fb13fdeaaff6085d8705fb470f142cd",
  "patch": "diff --git a/src/AggregateFunctions/AggregateFunctionSumMap.h b/src/AggregateFunctions/AggregateFunctionSumMap.h\nindex 456334ee9c31..c991474d0e65 100644\n--- a/src/AggregateFunctions/AggregateFunctionSumMap.h\n+++ b/src/AggregateFunctions/AggregateFunctionSumMap.h\n@@ -56,7 +56,7 @@ struct AggregateFunctionMapData\n   * minMap and maxMap share the same idea, but calculate min and max correspondingly.\n   */\n \n-template <typename T, typename Derived, typename Visitor, bool overflow, bool tuple_argument>\n+template <typename T, typename Derived, typename Visitor, bool overflow, bool tuple_argument, bool compact>\n class AggregateFunctionMapBase : public IAggregateFunctionDataHelper<\n     AggregateFunctionMapData<NearestFieldType<T>>, Derived>\n {\n@@ -255,23 +255,28 @@ class AggregateFunctionMapBase : public IAggregateFunctionDataHelper<\n     {\n         // Final step does compaction of keys that have zero values, this mutates the state\n         auto & merged_maps = this->data(place).merged_maps;\n-        for (auto it = merged_maps.cbegin(); it != merged_maps.cend();)\n+\n+        // Remove keys which are zeros or empty. This should be enabled only for sumMap.\n+        if constexpr (compact)\n         {\n-            // Key is not compacted if it has at least one non-zero value\n-            bool erase = true;\n-            for (size_t col = 0; col < values_types.size(); ++col)\n+            for (auto it = merged_maps.cbegin(); it != merged_maps.cend();)\n             {\n-                if (it->second[col] != values_types[col]->getDefault())\n+                // Key is not compacted if it has at least one non-zero value\n+                bool erase = true;\n+                for (size_t col = 0; col < values_types.size(); ++col)\n                 {\n-                    erase = false;\n-                    break;\n+                    if (it->second[col] != values_types[col]->getDefault())\n+                    {\n+                        erase = false;\n+                        break;\n+                    }\n                 }\n-            }\n \n-            if (erase)\n-                it = merged_maps.erase(it);\n-            else\n-                ++it;\n+                if (erase)\n+                    it = merged_maps.erase(it);\n+                else\n+                    ++it;\n+            }\n         }\n \n         size_t size = merged_maps.size();\n@@ -314,11 +319,11 @@ class AggregateFunctionMapBase : public IAggregateFunctionDataHelper<\n \n template <typename T, bool overflow, bool tuple_argument>\n class AggregateFunctionSumMap final :\n-    public AggregateFunctionMapBase<T, AggregateFunctionSumMap<T, overflow, tuple_argument>, FieldVisitorSum, overflow, tuple_argument>\n+    public AggregateFunctionMapBase<T, AggregateFunctionSumMap<T, overflow, tuple_argument>, FieldVisitorSum, overflow, tuple_argument, true>\n {\n private:\n     using Self = AggregateFunctionSumMap<T, overflow, tuple_argument>;\n-    using Base = AggregateFunctionMapBase<T, Self, FieldVisitorSum, overflow, tuple_argument>;\n+    using Base = AggregateFunctionMapBase<T, Self, FieldVisitorSum, overflow, tuple_argument, true>;\n \n public:\n     AggregateFunctionSumMap(const DataTypePtr & keys_type_,\n@@ -342,11 +347,12 @@ class AggregateFunctionSumMapFiltered final :\n         AggregateFunctionSumMapFiltered<T, overflow, tuple_argument>,\n         FieldVisitorSum,\n         overflow,\n-        tuple_argument>\n+        tuple_argument,\n+        true>\n {\n private:\n     using Self = AggregateFunctionSumMapFiltered<T, overflow, tuple_argument>;\n-    using Base = AggregateFunctionMapBase<T, Self, FieldVisitorSum, overflow, tuple_argument>;\n+    using Base = AggregateFunctionMapBase<T, Self, FieldVisitorSum, overflow, tuple_argument, true>;\n \n     /// ARCADIA_BUILD disallow unordered_set for big ints for some reason\n     static constexpr const bool allow_hash = !OverBigInt<T>;\n@@ -474,11 +480,11 @@ class FieldVisitorMin : public StaticVisitor<bool>\n \n template <typename T, bool tuple_argument>\n class AggregateFunctionMinMap final :\n-    public AggregateFunctionMapBase<T, AggregateFunctionMinMap<T, tuple_argument>, FieldVisitorMin, true, tuple_argument>\n+    public AggregateFunctionMapBase<T, AggregateFunctionMinMap<T, tuple_argument>, FieldVisitorMin, true, tuple_argument, false>\n {\n private:\n     using Self = AggregateFunctionMinMap<T, tuple_argument>;\n-    using Base = AggregateFunctionMapBase<T, Self, FieldVisitorMin, true, tuple_argument>;\n+    using Base = AggregateFunctionMapBase<T, Self, FieldVisitorMin, true, tuple_argument, false>;\n \n public:\n     AggregateFunctionMinMap(const DataTypePtr & keys_type_,\n@@ -498,11 +504,11 @@ class AggregateFunctionMinMap final :\n \n template <typename T, bool tuple_argument>\n class AggregateFunctionMaxMap final :\n-    public AggregateFunctionMapBase<T, AggregateFunctionMaxMap<T, tuple_argument>, FieldVisitorMax, true, tuple_argument>\n+    public AggregateFunctionMapBase<T, AggregateFunctionMaxMap<T, tuple_argument>, FieldVisitorMax, true, tuple_argument, false>\n {\n private:\n     using Self = AggregateFunctionMaxMap<T, tuple_argument>;\n-    using Base = AggregateFunctionMapBase<T, Self, FieldVisitorMax, true, tuple_argument>;\n+    using Base = AggregateFunctionMapBase<T, Self, FieldVisitorMax, true, tuple_argument, false>;\n \n public:\n     AggregateFunctionMaxMap(const DataTypePtr & keys_type_,\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01280_min_map_max_map.reference b/tests/queries/0_stateless/01280_min_map_max_map.reference\nindex dd707d602c72..abb500553fd4 100644\n--- a/tests/queries/0_stateless/01280_min_map_max_map.reference\n+++ b/tests/queries/0_stateless/01280_min_map_max_map.reference\n@@ -22,3 +22,8 @@\n (['1970-01-01 03:00:01'],[2])\n ([1.01],[2])\n (['a'],[2])\n+([1,2],[0,0])\n+([1,2],[0,0])\n+(['A','B'],['',''])\n+(['A','B'],['',''])\n+([],[])\ndiff --git a/tests/queries/0_stateless/01280_min_map_max_map.sql b/tests/queries/0_stateless/01280_min_map_max_map.sql\nindex 02731eee6019..cc07998bb79e 100644\n--- a/tests/queries/0_stateless/01280_min_map_max_map.sql\n+++ b/tests/queries/0_stateless/01280_min_map_max_map.sql\n@@ -31,3 +31,10 @@ select maxMap(val, cnt) from values ('val Array(Date), cnt Array(Int16)',  ([1],\n select maxMap(val, cnt) from values ('val Array(DateTime(\\'Europe/Moscow\\')), cnt Array(Int32)',  ([1], [1]), ([1], [2]));\n select maxMap(val, cnt) from values ('val Array(Decimal(10, 2)), cnt Array(Int16)',  (['1.01'], [1]), (['1.01'], [2]));\n select maxMap(val, cnt) from values ('val Array(Enum16(\\'a\\'=1)), cnt Array(Int16)',  (['a'], [1]), (['a'], [2]));\n+\n+-- bugfix, minMap and maxMap should not remove values with zero and empty strings but this behavior should not affect sumMap\n+select minMap(val, cnt) from values ('val Array(UInt64), cnt Array(UInt64)',  ([1], [0]), ([2], [0]));\n+select maxMap(val, cnt) from values ('val Array(UInt64), cnt Array(UInt64)',  ([1], [0]), ([2], [0]));\n+select minMap(val, cnt) from values ('val Array(String), cnt Array(String)',  (['A'], ['']), (['B'], ['']));\n+select maxMap(val, cnt) from values ('val Array(String), cnt Array(String)',  (['A'], ['']), (['B'], ['']));\n+select sumMap(val, cnt) from values ('val Array(UInt64), cnt Array(UInt64)',  ([1], [0]), ([2], [0]));\n",
  "problem_statement": "maxMap is removing entries with empty string or zero value\n**Describe the unexpected behaviour**\r\nmaxMap is removing entries with empty string or zero value.\r\n\r\n**How to reproduce**\r\n\r\nString array\r\nSELECT maxMap(a, b) from values ('a Array(String), b Array(String)',(['A'],['']),(['B'],['']));\r\n\r\n\u250c\u2500maxMap(a, b) \u2500\u2510\r\n\u2502 ([],[])                    \u2502 \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nNumeric array\r\n`SELECT maxMap(a, b) from values ('a Array(String), b Array(UInt64)',(['A'],[0]),(['B'],[0]));\r\n\r\n\u250c\u2500maxMap(a, b) \u2500\u2510\r\n\u2502 ([],[])                    \u2502 \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n`\r\nIt happens with all versions published.\r\n\r\n**Expected behavior**\r\nWe expect this to maintain those keys with its value (empty string or zero).\r\n\n",
  "hints_text": "",
  "created_at": "2020-11-03T10:28:56Z"
}