{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 84026,
  "instance_id": "ClickHouse__ClickHouse-84026",
  "issue_numbers": [
    "81506"
  ],
  "base_commit": "0f54691edf5b97fa0a179bec6a3a0de34a991c0a",
  "patch": "diff --git a/src/Processors/Sources/RecursiveCTESource.cpp b/src/Processors/Sources/RecursiveCTESource.cpp\nindex 4a160465626e..5b41bad6b57d 100644\n--- a/src/Processors/Sources/RecursiveCTESource.cpp\n+++ b/src/Processors/Sources/RecursiveCTESource.cpp\n@@ -26,6 +26,7 @@ namespace DB\n namespace Setting\n {\n     extern const SettingsUInt64 max_recursive_cte_evaluation_depth;\n+    extern const SettingsBool use_query_condition_cache;\n }\n \n namespace ErrorCodes\n@@ -176,6 +177,10 @@ class RecursiveCTEChunkGenerator\n                 recursive_subquery_settings[Setting::max_recursive_cte_evaluation_depth].value,\n                 recursive_cte_union_node->formatASTForErrorMessage());\n \n+        /// Workaround for issue 84026: Usage of the query condition cache with recursive CTEs caused wrong results\n+        if (recursive_step > 0 && recursive_subquery_settings[Setting::use_query_condition_cache])\n+            recursive_query_context->setSetting(\"use_query_condition_cache\", false);\n+\n         auto & query_to_execute = recursive_step > 0 ? recursive_query : non_recursive_query;\n         ++recursive_step;\n \ndiff --git a/src/Storages/MergeTree/MergeTreeSelectProcessor.cpp b/src/Storages/MergeTree/MergeTreeSelectProcessor.cpp\nindex 642a0f4ad4e2..c254d369140f 100644\n--- a/src/Storages/MergeTree/MergeTreeSelectProcessor.cpp\n+++ b/src/Storages/MergeTree/MergeTreeSelectProcessor.cpp\n@@ -198,7 +198,7 @@ ChunkAndProgress MergeTreeSelectProcessor::read()\n                                 part_name,\n                                 output->getHash(),\n                                 reader_settings.query_condition_cache_store_conditions_as_plaintext\n-                                    ? prewhere_info->prewhere_actions.getNames()[0]\n+                                    ? output->result_name\n                                     : \"\",\n                                 task->getPrewhereUnmatchedMarks(),\n                                 data_part->index_granularity->getMarksCount(),\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03229_query_condition_cache_recursive_cte.reference b/tests/queries/0_stateless/03229_query_condition_cache_recursive_cte.reference\nnew file mode 100644\nindex 000000000000..5ccd40613180\n--- /dev/null\n+++ b/tests/queries/0_stateless/03229_query_condition_cache_recursive_cte.reference\n@@ -0,0 +1,9 @@\n+-- Prepare data\n+-- First run\n+uuid2\n+uuid3\n+uuid4\n+-- Second run\n+uuid2\n+uuid3\n+uuid4\ndiff --git a/tests/queries/0_stateless/03229_query_condition_cache_recursive_cte.sql b/tests/queries/0_stateless/03229_query_condition_cache_recursive_cte.sql\nnew file mode 100644\nindex 000000000000..a90666d79718\n--- /dev/null\n+++ b/tests/queries/0_stateless/03229_query_condition_cache_recursive_cte.sql\n@@ -0,0 +1,62 @@\n+-- Tags: no-parallel\n+-- Tag no-parallel: Messes with internal cache\n+\n+-- Test for issue #81506 (recursive CTEs return wrong results if the query condition cache is on)\n+\n+SET allow_experimental_analyzer = 1; -- needed by recursive CTEs\n+\n+-- Start from a clean query condition cache\n+SYSTEM DROP QUERY CONDITION CACHE;\n+\n+SELECT '-- Prepare data';\n+\n+DROP TABLE IF EXISTS tab;\n+CREATE TABLE tab\n+(\n+    id String,\n+    parent String,\n+)\n+ENGINE = MergeTree\n+ORDER BY tuple();\n+\n+INSERT INTO tab (id, parent) VALUES\n+  ('uuid1', 'uuid2'),\n+  ('uuid3', 'uuid4'),\n+  ('uuid4', 'uuid2'),\n+  ('uuid2', 'empty'),\n+  ('uuid5', 'uuid2'),\n+  ('uuid6', 'uuid4');\n+\n+SELECT '-- First run';\n+\n+WITH RECURSIVE\n+        recursive AS (\n+                SELECT id FROM tab WHERE id = 'uuid3'\n+            UNION ALL\n+                SELECT parent AS id\n+                FROM tab\n+                WHERE tab.id IN recursive AND parent != 'empty'\n+                GROUP BY parent\n+        )\n+SELECT *\n+FROM recursive\n+GROUP BY id\n+ORDER BY id;\n+\n+SELECT '-- Second run'; -- same query\n+\n+WITH RECURSIVE\n+        recursive AS (\n+                SELECT id FROM tab WHERE id = 'uuid3'\n+            UNION ALL\n+                SELECT parent AS id\n+                FROM tab\n+                WHERE tab.id IN recursive AND parent != 'empty'\n+                GROUP BY parent\n+        )\n+SELECT *\n+FROM recursive\n+GROUP BY id\n+ORDER BY id;\n+\n+DROP TABLE tab;\n",
  "problem_statement": "Recursive query inconsistently lose part of result when use_query_condition_cache is enabled\n### Company or project name\n\n_No response_\n\n### Describe what's wrong\n\nI have a tree-like structure stored in a table. There is recursive query walking the tree. The first time the query runs it returns 3 rows as expected, the second and consecutive runs return only one row (only \"init\" step of recursive query).\n\nThe issue is not happening if to remove one condition from \"step\" query (parent != zero).\n\nHere is minimized code: https://fiddle.clickhouse.com/54e07ef3-7bd4-4d77-87d8-0ef19ee6542c\n\n### Does it reproduce on the most recent release?\n\nYes\n\n### How to reproduce\n\nVersions 25.4 and later up to the latest are affected.\nThe issue is reproducible on fiddle.\n\nAll the other details are here: https://fiddle.clickhouse.com/54e07ef3-7bd4-4d77-87d8-0ef19ee6542c\n\n### Expected behavior\n\nTo get the same result for the same query on the same data, considering data is unambiguous.\n\n### Error message and/or stacktrace\n\n_No response_\n\n### Additional context\n\n_No response_\n",
  "hints_text": "Workaround: set use_query_condition_cache=0;\nhttps://fiddle.clickhouse.com/d6467b8f-a973-4cb0-aa8b-4d18a17ea036\n@zhongyuankai Like to have a look?\nOK, I'll check it out.",
  "created_at": "2025-07-19T04:15:32Z"
}