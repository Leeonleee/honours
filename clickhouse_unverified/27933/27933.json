{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 27933,
  "instance_id": "ClickHouse__ClickHouse-27933",
  "issue_numbers": [
    "4509"
  ],
  "base_commit": "54ac0801a236a4dd0de56e00a60b104ccd855eca",
  "patch": "diff --git a/src/Functions/FunctionBinaryArithmetic.h b/src/Functions/FunctionBinaryArithmetic.h\nindex 69f9f2123343..4eef807c5882 100644\n--- a/src/Functions/FunctionBinaryArithmetic.h\n+++ b/src/Functions/FunctionBinaryArithmetic.h\n@@ -636,7 +636,7 @@ class FunctionBinaryArithmetic : public IFunction\n         }\n \n         if (second_is_date_or_datetime && is_minus)\n-            throw Exception(\"Wrong order of arguments for function \" + String(name) + \": argument of type Interval cannot be first.\",\n+            throw Exception(\"Wrong order of arguments for function \" + String(name) + \": argument of type Interval cannot be first\",\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n         std::string function_name;\n@@ -657,6 +657,64 @@ class FunctionBinaryArithmetic : public IFunction\n         return FunctionFactory::instance().get(function_name, context);\n     }\n \n+    static FunctionOverloadResolverPtr\n+    getFunctionForTupleArithmetic(const DataTypePtr & type0, const DataTypePtr & type1, ContextPtr context)\n+    {\n+        if (!isTuple(type0) || !isTuple(type1))\n+            return {};\n+\n+        /// Special case when the function is plus, minus or multiply, both arguments are tuples.\n+        /// We construct another function (example: tuplePlus) and call it.\n+\n+        if constexpr (!is_plus && !is_minus && !is_multiply)\n+            return {};\n+\n+        std::string function_name;\n+        if (is_plus)\n+        {\n+            function_name = \"tuplePlus\";\n+        }\n+        else if (is_minus)\n+        {\n+            function_name = \"tupleMinus\";\n+        }\n+        else\n+        {\n+            function_name = \"dotProduct\";\n+        }\n+\n+        return FunctionFactory::instance().get(function_name, context);\n+    }\n+\n+    static FunctionOverloadResolverPtr\n+    getFunctionForTupleAndNumberArithmetic(const DataTypePtr & type0, const DataTypePtr & type1, ContextPtr context)\n+    {\n+        if (!(isTuple(type0) && isNumber(type1)) && !(isTuple(type1) && isNumber(type0)))\n+            return {};\n+\n+        /// Special case when the function is multiply or divide, one of arguments is Tuple and another is Number.\n+        /// We construct another function (example: tupleMultiplyByNumber) and call it.\n+\n+        if constexpr (!is_multiply && !is_division)\n+            return {};\n+\n+        if (isNumber(type0) && is_division)\n+            throw Exception(\"Wrong order of arguments for function \" + String(name) + \": argument of numeric type cannot be first\",\n+                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+        std::string function_name;\n+        if (is_multiply)\n+        {\n+            function_name = \"tupleMultiplyByNumber\";\n+        }\n+        else\n+        {\n+            function_name = \"tupleDivideByNumber\";\n+        }\n+\n+        return FunctionFactory::instance().get(function_name, context);\n+    }\n+\n     static bool isAggregateMultiply(const DataTypePtr & type0, const DataTypePtr & type1)\n     {\n         if constexpr (!is_multiply)\n@@ -797,6 +855,20 @@ class FunctionBinaryArithmetic : public IFunction\n         return function->execute(new_arguments, result_type, input_rows_count);\n     }\n \n+    ColumnPtr executeTupleNumberOperator(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type,\n+                                               size_t input_rows_count, const FunctionOverloadResolverPtr & function_builder) const\n+    {\n+        ColumnsWithTypeAndName new_arguments = arguments;\n+\n+        /// Number argument must be second.\n+        if (isNumber(arguments[0].type))\n+            std::swap(new_arguments[0], new_arguments[1]);\n+\n+        auto function = function_builder->build(new_arguments);\n+\n+        return function->execute(new_arguments, result_type, input_rows_count);\n+    }\n+\n     template <typename T, typename ResultDataType>\n     static auto helperGetOrConvert(const auto & col_const, const auto & col)\n     {\n@@ -1014,6 +1086,34 @@ class FunctionBinaryArithmetic : public IFunction\n             return function->getResultType();\n         }\n \n+        /// Special case when the function is plus, minus or multiply, both arguments are tuples.\n+        if (auto function_builder = getFunctionForTupleArithmetic(arguments[0], arguments[1], context))\n+        {\n+            ColumnsWithTypeAndName new_arguments(2);\n+\n+            for (size_t i = 0; i < 2; ++i)\n+                new_arguments[i].type = arguments[i];\n+\n+            auto function = function_builder->build(new_arguments);\n+            return function->getResultType();\n+        }\n+\n+        /// Special case when the function is multiply or divide, one of arguments is Tuple and another is Number.\n+        if (auto function_builder = getFunctionForTupleAndNumberArithmetic(arguments[0], arguments[1], context))\n+        {\n+            ColumnsWithTypeAndName new_arguments(2);\n+\n+            for (size_t i = 0; i < 2; ++i)\n+                new_arguments[i].type = arguments[i];\n+\n+            /// Number argument must be second.\n+            if (isNumber(new_arguments[0].type))\n+                std::swap(new_arguments[0], new_arguments[1]);\n+\n+            auto function = function_builder->build(new_arguments);\n+            return function->getResultType();\n+        }\n+\n         DataTypePtr type_res;\n \n         const bool valid = castBothTypes(arguments[0].get(), arguments[1].get(), [&](const auto & left, const auto & right)\n@@ -1399,6 +1499,20 @@ class FunctionBinaryArithmetic : public IFunction\n             return executeDateTimeIntervalPlusMinus(arguments, result_type, input_rows_count, function_builder);\n         }\n \n+        /// Special case when the function is plus, minus or multiply, both arguments are tuples.\n+        if (auto function_builder\n+            = getFunctionForTupleArithmetic(arguments[0].type, arguments[1].type, context))\n+        {\n+            return function_builder->build(arguments)->execute(arguments, result_type, input_rows_count);\n+        }\n+\n+        /// Special case when the function is multiply or divide, one of arguments is Tuple and another is Number.\n+        if (auto function_builder\n+            = getFunctionForTupleAndNumberArithmetic(arguments[0].type, arguments[1].type, context))\n+        {\n+            return executeTupleNumberOperator(arguments, result_type, input_rows_count, function_builder);\n+        }\n+\n         const auto & left_argument = arguments[0];\n         const auto & right_argument = arguments[1];\n         const auto * const left_generic = left_argument.type.get();\ndiff --git a/src/Functions/FunctionUnaryArithmetic.h b/src/Functions/FunctionUnaryArithmetic.h\nindex 31227b5b1261..4f0a1fceadd3 100644\n--- a/src/Functions/FunctionUnaryArithmetic.h\n+++ b/src/Functions/FunctionUnaryArithmetic.h\n@@ -83,6 +83,8 @@ class FunctionUnaryArithmetic : public IFunction\n     static constexpr bool allow_fixed_string = Op<UInt8>::allow_fixed_string;\n     static constexpr bool is_sign_function = IsUnaryOperation<Op>::sign;\n \n+    ContextPtr context;\n+\n     template <typename F>\n     static bool castType(const IDataType * type, F && f)\n     {\n@@ -109,10 +111,29 @@ class FunctionUnaryArithmetic : public IFunction\n         >(type, std::forward<F>(f));\n     }\n \n+    static FunctionOverloadResolverPtr\n+    getFunctionForTupleArithmetic(const DataTypePtr & type, ContextPtr context)\n+    {\n+        if (!isTuple(type))\n+            return {};\n+\n+        /// Special case when the function is negate, argument is tuple.\n+        /// We construct another function (example: tupleNegate) and call it.\n+\n+        if constexpr (!IsUnaryOperation<Op>::negate)\n+            return {};\n+\n+        return FunctionFactory::instance().get(\"tupleNegate\", context);\n+    }\n+\n public:\n     static constexpr auto name = Name::name;\n     static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionUnaryArithmetic>(); }\n \n+    FunctionUnaryArithmetic() = default;\n+\n+    explicit FunctionUnaryArithmetic(ContextPtr context_) : context(context_) {}\n+\n     String getName() const override\n     {\n         return name;\n@@ -126,6 +147,22 @@ class FunctionUnaryArithmetic : public IFunction\n \n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n+        return getReturnTypeImplStatic(arguments, context);\n+    }\n+\n+    static DataTypePtr getReturnTypeImplStatic(const DataTypes & arguments, ContextPtr context)\n+    {\n+        /// Special case when the function is negate, argument is tuple.\n+        if (auto function_builder = getFunctionForTupleArithmetic(arguments[0], context))\n+        {\n+            ColumnsWithTypeAndName new_arguments(1);\n+\n+            new_arguments[0].type = arguments[0];\n+\n+            auto function = function_builder->build(new_arguments);\n+            return function->getResultType();\n+        }\n+\n         DataTypePtr result;\n         bool valid = castType(arguments[0].get(), [&](const auto & type)\n         {\n@@ -152,13 +189,19 @@ class FunctionUnaryArithmetic : public IFunction\n             return true;\n         });\n         if (!valid)\n-            throw Exception(\"Illegal type \" + arguments[0]->getName() + \" of argument of function \" + getName(),\n+            throw Exception(\"Illegal type \" + arguments[0]->getName() + \" of argument of function \" + String(name),\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n         return result;\n     }\n \n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n     {\n+        /// Special case when the function is negate, argument is tuple.\n+        if (auto function_builder = getFunctionForTupleArithmetic(arguments[0].type, context))\n+        {\n+            return function_builder->build(arguments)->execute(arguments, result_type, input_rows_count);\n+        }\n+\n         ColumnPtr result_column;\n         bool valid = castType(arguments[0].type.get(), [&](const auto & type)\n         {\ndiff --git a/src/Functions/ITupleFunction.h b/src/Functions/ITupleFunction.h\nnew file mode 100644\nindex 000000000000..836e5d273fce\n--- /dev/null\n+++ b/src/Functions/ITupleFunction.h\n@@ -0,0 +1,41 @@\n+#pragma once\n+\n+#include <Functions/IFunction.h>\n+\n+namespace DB\n+{\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+}\n+\n+class ITupleFunction : public IFunction\n+{\n+protected:\n+    ContextPtr context;\n+\n+public:\n+    explicit ITupleFunction(ContextPtr context_) : context(context_) {}\n+\n+    Columns getTupleElements(const IColumn & column) const\n+    {\n+        if (const auto * const_column = typeid_cast<const ColumnConst *>(&column))\n+            return convertConstTupleToConstantElements(*const_column);\n+\n+        if (const auto * column_tuple = typeid_cast<const ColumnTuple *>(&column))\n+        {\n+            Columns columns(column_tuple->tupleSize());\n+            for (size_t i = 0; i < columns.size(); ++i)\n+                columns[i] = column_tuple->getColumnPtr(i);\n+            return columns;\n+        }\n+\n+        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Argument of function {} should be tuples, got {}\",\n+                        getName(), column.getName());\n+    }\n+\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n+};\n+}\ndiff --git a/src/Functions/IsOperation.h b/src/Functions/IsOperation.h\nindex 5b03ae3d189b..369978fe271e 100644\n--- a/src/Functions/IsOperation.h\n+++ b/src/Functions/IsOperation.h\n@@ -3,7 +3,7 @@\n namespace DB\n {\n \n-/// These classes should be present in DB namespace (cannot place them into nemelesspace)\n+/// These classes should be present in DB namespace (cannot place them into namelesspace)\n template <typename> struct AbsImpl;\n template <typename> struct NegateImpl;\n template <typename, typename> struct PlusImpl;\ndiff --git a/src/Functions/max2.cpp b/src/Functions/max2.cpp\nnew file mode 100644\nindex 000000000000..bbe3a870811b\n--- /dev/null\n+++ b/src/Functions/max2.cpp\n@@ -0,0 +1,22 @@\n+#include <Functions/FunctionMathBinaryFloat64.h>\n+#include <Functions/FunctionFactory.h>\n+\n+template <typename T>\n+T max(T a, T b)\n+{\n+    return a > b ? a : b;\n+}\n+\n+namespace DB\n+{\n+namespace\n+{\n+    struct Max2Name { static constexpr auto name = \"max2\"; };\n+    using FunctionMax2 = FunctionMathBinaryFloat64<BinaryFunctionVectorized<Max2Name, max>>;\n+}\n+\n+void registerFunctionMax2(FunctionFactory & factory)\n+{\n+    factory.registerFunction<FunctionMax2>(FunctionFactory::CaseInsensitive);\n+}\n+}\ndiff --git a/src/Functions/min2.cpp b/src/Functions/min2.cpp\nnew file mode 100644\nindex 000000000000..50597a30dc23\n--- /dev/null\n+++ b/src/Functions/min2.cpp\n@@ -0,0 +1,22 @@\n+#include <Functions/FunctionMathBinaryFloat64.h>\n+#include <Functions/FunctionFactory.h>\n+\n+template <typename T>\n+T min(T a, T b)\n+{\n+    return a < b ? a : b;\n+}\n+\n+namespace DB\n+{\n+namespace\n+{\n+    struct Min2Name { static constexpr auto name = \"min2\"; };\n+    using FunctionMin2 = FunctionMathBinaryFloat64<BinaryFunctionVectorized<Min2Name, min>>;\n+}\n+\n+void registerFunctionMin2(FunctionFactory & factory)\n+{\n+    factory.registerFunction<FunctionMin2>(FunctionFactory::CaseInsensitive);\n+}\n+}\ndiff --git a/src/Functions/registerFunctionsMath.cpp b/src/Functions/registerFunctionsMath.cpp\nindex bc851de9b937..9df24f4a8eb1 100644\n--- a/src/Functions/registerFunctionsMath.cpp\n+++ b/src/Functions/registerFunctionsMath.cpp\n@@ -34,6 +34,9 @@ void registerFunctionAcosh(FunctionFactory & factory);\n void registerFunctionAtanh(FunctionFactory & factory);\n void registerFunctionPow(FunctionFactory & factory);\n void registerFunctionSign(FunctionFactory & factory);\n+void registerFunctionMax2(FunctionFactory & factory);\n+void registerFunctionMin2(FunctionFactory & factory);\n+void registerVectorFunctions(FunctionFactory &);\n \n \n void registerFunctionsMath(FunctionFactory & factory)\n@@ -70,6 +73,9 @@ void registerFunctionsMath(FunctionFactory & factory)\n     registerFunctionAtanh(factory);\n     registerFunctionPow(factory);\n     registerFunctionSign(factory);\n+    registerFunctionMax2(factory);\n+    registerFunctionMin2(factory);\n+    registerVectorFunctions(factory);\n }\n \n }\ndiff --git a/src/Functions/tupleHammingDistance.cpp b/src/Functions/tupleHammingDistance.cpp\nindex a8c6354b6be0..11c8cf84b405 100644\n--- a/src/Functions/tupleHammingDistance.cpp\n+++ b/src/Functions/tupleHammingDistance.cpp\n@@ -4,7 +4,7 @@\n #include <DataTypes/DataTypesNumber.h>\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionHelpers.h>\n-#include <Functions/IFunction.h>\n+#include <Functions/ITupleFunction.h>\n #include <Functions/castTypeToEither.h>\n \n namespace DB\n@@ -16,17 +16,13 @@ namespace ErrorCodes\n \n /// tupleHammingDistance function: (Tuple(...), Tuple(...))-> N\n /// Return the number of non-equal tuple elements\n-class FunctionTupleHammingDistance : public IFunction\n+class FunctionTupleHammingDistance : public ITupleFunction\n {\n-private:\n-    ContextPtr context;\n-\n public:\n     static constexpr auto name = \"tupleHammingDistance\";\n-    using ResultType = UInt8;\n \n-    explicit FunctionTupleHammingDistance(ContextPtr context_) : context(context_) {}\n-    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionTupleHammingDistance>(context); }\n+    explicit FunctionTupleHammingDistance(ContextPtr context_) : ITupleFunction(context_) {}\n+    static FunctionPtr create(ContextPtr context_) { return std::make_shared<FunctionTupleHammingDistance>(context_); }\n \n     String getName() const override { return name; }\n \n@@ -36,34 +32,17 @@ class FunctionTupleHammingDistance : public IFunction\n \n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n \n-    Columns getTupleElements(const IColumn & column) const\n-    {\n-        if (const auto * const_column = typeid_cast<const ColumnConst *>(&column))\n-            return convertConstTupleToConstantElements(*const_column);\n-\n-        if (const auto * column_tuple = typeid_cast<const ColumnTuple *>(&column))\n-        {\n-            Columns columns(column_tuple->tupleSize());\n-            for (size_t i = 0; i < columns.size(); ++i)\n-                columns[i] = column_tuple->getColumnPtr(i);\n-            return columns;\n-        }\n-\n-        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Argument of function {} should be tuples, got {}\",\n-                        getName(), column.getName());\n-    }\n-\n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n         const auto * left_tuple = checkAndGetDataType<DataTypeTuple>(arguments[0].type.get());\n         const auto * right_tuple = checkAndGetDataType<DataTypeTuple>(arguments[1].type.get());\n \n         if (!left_tuple)\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Argument 0 of function {} should be tuples, got {}\",\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Argument 0 of function {} should be tuple, got {}\",\n                             getName(), arguments[0].type->getName());\n \n         if (!right_tuple)\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Argument 1 of function {} should be tuples, got {}\",\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Argument 1 of function {} should be tuple, got {}\",\n                             getName(), arguments[1].type->getName());\n \n         const auto & left_types = left_tuple->getElements();\n@@ -87,7 +66,7 @@ class FunctionTupleHammingDistance : public IFunction\n \n         auto compare = FunctionFactory::instance().get(\"notEquals\", context);\n         auto plus = FunctionFactory::instance().get(\"plus\", context);\n-        DataTypes types(tuple_size);\n+        DataTypePtr res_type;\n         for (size_t i = 0; i < tuple_size; ++i)\n         {\n             try\n@@ -95,7 +74,17 @@ class FunctionTupleHammingDistance : public IFunction\n                 ColumnWithTypeAndName left{left_elements.empty() ? nullptr : left_elements[i], left_types[i], {}};\n                 ColumnWithTypeAndName right{right_elements.empty() ? nullptr : right_elements[i], right_types[i], {}};\n                 auto elem_compare = compare->build(ColumnsWithTypeAndName{left, right});\n-                types[i] = elem_compare->getResultType();\n+\n+                if (i == 0)\n+                {\n+                    res_type = elem_compare->getResultType();\n+                    continue;\n+                }\n+\n+                ColumnWithTypeAndName left_type{res_type, {}};\n+                ColumnWithTypeAndName right_type{elem_compare->getResultType(), {}};\n+                auto plus_elem = plus->build({left_type, right_type});\n+                res_type = plus_elem->getResultType();\n             }\n             catch (DB::Exception & e)\n             {\n@@ -104,15 +93,6 @@ class FunctionTupleHammingDistance : public IFunction\n             }\n         }\n \n-        auto res_type = types[0];\n-        for (size_t i = 1; i < tuple_size; ++i)\n-        {\n-            ColumnWithTypeAndName left{res_type, {}};\n-            ColumnWithTypeAndName right{types[i], {}};\n-            auto plus_elem = plus->build({left, right});\n-            res_type = plus_elem->getResultType();\n-        }\n-\n         return res_type;\n     }\n \n@@ -131,23 +111,28 @@ class FunctionTupleHammingDistance : public IFunction\n \n         auto compare = FunctionFactory::instance().get(\"notEquals\", context);\n         auto plus = FunctionFactory::instance().get(\"plus\", context);\n-        ColumnsWithTypeAndName columns(tuple_size);\n+        ColumnWithTypeAndName res;\n         for (size_t i = 0; i < tuple_size; ++i)\n         {\n             ColumnWithTypeAndName left{left_elements[i], left_types[i], {}};\n             ColumnWithTypeAndName right{right_elements[i], right_types[i], {}};\n             auto elem_compare = compare->build(ColumnsWithTypeAndName{left, right});\n-            columns[i].type = elem_compare->getResultType();\n-            columns[i].column = elem_compare->execute({left, right}, columns[i].type, input_rows_count);\n-        }\n \n-        auto res = columns[0];\n-        for (size_t i = 1; i < tuple_size; ++i)\n-        {\n-            auto plus_elem = plus->build({res, columns[i]});\n-            auto res_type = plus_elem->getResultType();\n-            res.column = plus_elem->execute({res, columns[i]}, res_type, input_rows_count);\n-            res.type = res_type;\n+            ColumnWithTypeAndName column;\n+            column.type = elem_compare->getResultType();\n+            column.column = elem_compare->execute({left, right}, column.type, input_rows_count);\n+\n+            if (i == 0)\n+            {\n+                res = std::move(column);\n+            }\n+            else\n+            {\n+                auto plus_elem = plus->build({res, column});\n+                auto res_type = plus_elem->getResultType();\n+                res.column = plus_elem->execute({res, column}, res_type, input_rows_count);\n+                res.type = res_type;\n+            }\n         }\n \n         return res.column;\ndiff --git a/src/Functions/vectorFunctions.cpp b/src/Functions/vectorFunctions.cpp\nnew file mode 100644\nindex 000000000000..62cfdcd9ee73\n--- /dev/null\n+++ b/src/Functions/vectorFunctions.cpp\n@@ -0,0 +1,1116 @@\n+#include <Columns/ColumnTuple.h>\n+#include <DataTypes/DataTypeTuple.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/DataTypeNothing.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <Functions/ITupleFunction.h>\n+#include <Functions/castTypeToEither.h>\n+\n+namespace DB\n+{\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int ILLEGAL_COLUMN;\n+    extern const int ARGUMENT_OUT_OF_BOUND;\n+}\n+\n+struct PlusName { static constexpr auto name = \"plus\"; };\n+struct MinusName { static constexpr auto name = \"minus\"; };\n+struct MultiplyName { static constexpr auto name = \"multiply\"; };\n+struct DivideName { static constexpr auto name = \"divide\"; };\n+\n+struct L1Label { static constexpr auto name = \"1\"; };\n+struct L2Label { static constexpr auto name = \"2\"; };\n+struct LinfLabel { static constexpr auto name = \"inf\"; };\n+struct LpLabel { static constexpr auto name = \"p\"; };\n+\n+/// str starts from the lowercase letter; not constexpr due to the compiler version\n+/*constexpr*/ std::string makeFirstLetterUppercase(const std::string& str)\n+{\n+    std::string res(str);\n+    res[0] += 'A' - 'a';\n+    return res;\n+}\n+\n+template <class FuncName>\n+class FunctionTupleOperator : public ITupleFunction\n+{\n+public:\n+    /// constexpr cannot be used due to std::string has not constexpr constructor in this compiler version\n+    static inline auto name = \"tuple\" + makeFirstLetterUppercase(FuncName::name);\n+\n+    explicit FunctionTupleOperator(ContextPtr context_) : ITupleFunction(context_) {}\n+    static FunctionPtr create(ContextPtr context_) { return std::make_shared<FunctionTupleOperator>(context_); }\n+\n+    String getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 2; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        const auto * left_tuple = checkAndGetDataType<DataTypeTuple>(arguments[0].type.get());\n+        const auto * right_tuple = checkAndGetDataType<DataTypeTuple>(arguments[1].type.get());\n+\n+        if (!left_tuple)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Argument 0 of function {} should be tuple, got {}\",\n+                            getName(), arguments[0].type->getName());\n+\n+        if (!right_tuple)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Argument 1 of function {} should be tuple, got {}\",\n+                            getName(), arguments[1].type->getName());\n+\n+        const auto & left_types = left_tuple->getElements();\n+        const auto & right_types = right_tuple->getElements();\n+\n+        Columns left_elements;\n+        Columns right_elements;\n+        if (arguments[0].column)\n+            left_elements = getTupleElements(*arguments[0].column);\n+        if (arguments[1].column)\n+            right_elements = getTupleElements(*arguments[1].column);\n+\n+        if (left_types.size() != right_types.size())\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                            \"Expected tuples of the same size as arguments of function {}. Got {} and {}\",\n+                            getName(), arguments[0].type->getName(), arguments[1].type->getName());\n+\n+        size_t tuple_size = left_types.size();\n+        if (tuple_size == 0)\n+            return std::make_shared<DataTypeUInt8>();\n+\n+        auto func = FunctionFactory::instance().get(FuncName::name, context);\n+        DataTypes types(tuple_size);\n+        for (size_t i = 0; i < tuple_size; ++i)\n+        {\n+            try\n+            {\n+                ColumnWithTypeAndName left{left_elements.empty() ? nullptr : left_elements[i], left_types[i], {}};\n+                ColumnWithTypeAndName right{right_elements.empty() ? nullptr : right_elements[i], right_types[i], {}};\n+                auto elem_func = func->build(ColumnsWithTypeAndName{left, right});\n+                types[i] = elem_func->getResultType();\n+            }\n+            catch (DB::Exception & e)\n+            {\n+                e.addMessage(\"While executing function {} for tuple element {}\", getName(), i);\n+                throw;\n+            }\n+        }\n+\n+        return std::make_shared<DataTypeTuple>(types);\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        const auto * left_tuple = checkAndGetDataType<DataTypeTuple>(arguments[0].type.get());\n+        const auto * right_tuple = checkAndGetDataType<DataTypeTuple>(arguments[1].type.get());\n+        const auto & left_types = left_tuple->getElements();\n+        const auto & right_types = right_tuple->getElements();\n+        auto left_elements = getTupleElements(*arguments[0].column);\n+        auto right_elements = getTupleElements(*arguments[1].column);\n+\n+        size_t tuple_size = left_elements.size();\n+        if (tuple_size == 0)\n+            return DataTypeUInt8().createColumnConstWithDefaultValue(input_rows_count);\n+\n+        auto func = FunctionFactory::instance().get(FuncName::name, context);\n+        Columns columns(tuple_size);\n+        for (size_t i = 0; i < tuple_size; ++i)\n+        {\n+            ColumnWithTypeAndName left{left_elements[i], left_types[i], {}};\n+            ColumnWithTypeAndName right{right_elements[i], right_types[i], {}};\n+            auto elem_func = func->build(ColumnsWithTypeAndName{left, right});\n+            columns[i] = elem_func->execute({left, right}, elem_func->getResultType(), input_rows_count)\n+                                  ->convertToFullColumnIfConst();\n+        }\n+\n+        return ColumnTuple::create(columns);\n+    }\n+};\n+\n+using FunctionTuplePlus = FunctionTupleOperator<PlusName>;\n+\n+using FunctionTupleMinus = FunctionTupleOperator<MinusName>;\n+\n+using FunctionTupleMultiply = FunctionTupleOperator<MultiplyName>;\n+\n+using FunctionTupleDivide = FunctionTupleOperator<DivideName>;\n+\n+class FunctionTupleNegate : public ITupleFunction\n+{\n+public:\n+    static constexpr auto name = \"tupleNegate\";\n+\n+    explicit FunctionTupleNegate(ContextPtr context_) : ITupleFunction(context_) {}\n+    static FunctionPtr create(ContextPtr context_) { return std::make_shared<FunctionTupleNegate>(context_); }\n+\n+    String getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 1; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        const auto * cur_tuple = checkAndGetDataType<DataTypeTuple>(arguments[0].type.get());\n+\n+        if (!cur_tuple)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Argument 0 of function {} should be tuple, got {}\",\n+                            getName(), arguments[0].type->getName());\n+\n+        const auto & cur_types = cur_tuple->getElements();\n+\n+        Columns cur_elements;\n+        if (arguments[0].column)\n+            cur_elements = getTupleElements(*arguments[0].column);\n+\n+        size_t tuple_size = cur_types.size();\n+        if (tuple_size == 0)\n+            return std::make_shared<DataTypeUInt8>();\n+\n+        auto negate = FunctionFactory::instance().get(\"negate\", context);\n+        DataTypes types(tuple_size);\n+        for (size_t i = 0; i < tuple_size; ++i)\n+        {\n+            try\n+            {\n+                ColumnWithTypeAndName cur{cur_elements.empty() ? nullptr : cur_elements[i], cur_types[i], {}};\n+                auto elem_negate = negate->build(ColumnsWithTypeAndName{cur});\n+                types[i] = elem_negate->getResultType();\n+            }\n+            catch (DB::Exception & e)\n+            {\n+                e.addMessage(\"While executing function {} for tuple element {}\", getName(), i);\n+                throw;\n+            }\n+        }\n+\n+        return std::make_shared<DataTypeTuple>(types);\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        const auto * cur_tuple = checkAndGetDataType<DataTypeTuple>(arguments[0].type.get());\n+        const auto & cur_types = cur_tuple->getElements();\n+        auto cur_elements = getTupleElements(*arguments[0].column);\n+\n+        size_t tuple_size = cur_elements.size();\n+        if (tuple_size == 0)\n+            return DataTypeUInt8().createColumnConstWithDefaultValue(input_rows_count);\n+\n+        auto negate = FunctionFactory::instance().get(\"negate\", context);\n+        Columns columns(tuple_size);\n+        for (size_t i = 0; i < tuple_size; ++i)\n+        {\n+            ColumnWithTypeAndName cur{cur_elements[i], cur_types[i], {}};\n+            auto elem_negate = negate->build(ColumnsWithTypeAndName{cur});\n+            columns[i] = elem_negate->execute({cur}, elem_negate->getResultType(), input_rows_count)\n+                                    ->convertToFullColumnIfConst();\n+        }\n+\n+        return ColumnTuple::create(columns);\n+    }\n+};\n+\n+template <class FuncName>\n+class FunctionTupleOperatorByNumber : public ITupleFunction\n+{\n+public:\n+    /// constexpr cannot be used due to std::string has not constexpr constructor in this compiler version\n+    static inline auto name = \"tuple\" + makeFirstLetterUppercase(FuncName::name) + \"ByNumber\";\n+\n+    explicit FunctionTupleOperatorByNumber(ContextPtr context_) : ITupleFunction(context_) {}\n+    static FunctionPtr create(ContextPtr context_) { return std::make_shared<FunctionTupleOperatorByNumber>(context_); }\n+\n+    String getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 2; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        const auto * cur_tuple = checkAndGetDataType<DataTypeTuple>(arguments[0].type.get());\n+\n+        if (!cur_tuple)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Argument 0 of function {} should be tuple, got {}\",\n+                            getName(), arguments[0].type->getName());\n+\n+        const auto & cur_types = cur_tuple->getElements();\n+\n+        Columns cur_elements;\n+        if (arguments[0].column)\n+            cur_elements = getTupleElements(*arguments[0].column);\n+\n+        size_t tuple_size = cur_types.size();\n+        if (tuple_size == 0)\n+            return std::make_shared<DataTypeUInt8>();\n+\n+        const auto & p_column = arguments[1];\n+        auto func = FunctionFactory::instance().get(FuncName::name, context);\n+        DataTypes types(tuple_size);\n+        for (size_t i = 0; i < tuple_size; ++i)\n+        {\n+            try\n+            {\n+                ColumnWithTypeAndName cur{cur_elements.empty() ? nullptr : cur_elements[i], cur_types[i], {}};\n+                auto elem_func = func->build(ColumnsWithTypeAndName{cur, p_column});\n+                types[i] = elem_func->getResultType();\n+            }\n+            catch (DB::Exception & e)\n+            {\n+                e.addMessage(\"While executing function {} for tuple element {}\", getName(), i);\n+                throw;\n+            }\n+        }\n+\n+        return std::make_shared<DataTypeTuple>(types);\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        const auto * cur_tuple = checkAndGetDataType<DataTypeTuple>(arguments[0].type.get());\n+        const auto & cur_types = cur_tuple->getElements();\n+        auto cur_elements = getTupleElements(*arguments[0].column);\n+\n+        size_t tuple_size = cur_elements.size();\n+        if (tuple_size == 0)\n+            return DataTypeUInt8().createColumnConstWithDefaultValue(input_rows_count);\n+\n+        const auto & p_column = arguments[1];\n+        auto func = FunctionFactory::instance().get(FuncName::name, context);\n+        Columns columns(tuple_size);\n+        for (size_t i = 0; i < tuple_size; ++i)\n+        {\n+            ColumnWithTypeAndName cur{cur_elements[i], cur_types[i], {}};\n+            auto elem_func = func->build(ColumnsWithTypeAndName{cur, p_column});\n+            columns[i] = elem_func->execute({cur, p_column}, elem_func->getResultType(), input_rows_count)\n+                                  ->convertToFullColumnIfConst();\n+        }\n+\n+        return ColumnTuple::create(columns);\n+    }\n+};\n+\n+using FunctionTupleMultiplyByNumber = FunctionTupleOperatorByNumber<MultiplyName>;\n+\n+using FunctionTupleDivideByNumber = FunctionTupleOperatorByNumber<DivideName>;\n+\n+class FunctionDotProduct : public ITupleFunction\n+{\n+public:\n+    static constexpr auto name = \"dotProduct\";\n+\n+    explicit FunctionDotProduct(ContextPtr context_) : ITupleFunction(context_) {}\n+    static FunctionPtr create(ContextPtr context_) { return std::make_shared<FunctionDotProduct>(context_); }\n+\n+    String getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 2; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        const auto * left_tuple = checkAndGetDataType<DataTypeTuple>(arguments[0].type.get());\n+        const auto * right_tuple = checkAndGetDataType<DataTypeTuple>(arguments[1].type.get());\n+\n+        if (!left_tuple)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Argument 0 of function {} should be tuple, got {}\",\n+                            getName(), arguments[0].type->getName());\n+\n+        if (!right_tuple)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Argument 1 of function {} should be tuple, got {}\",\n+                            getName(), arguments[1].type->getName());\n+\n+        const auto & left_types = left_tuple->getElements();\n+        const auto & right_types = right_tuple->getElements();\n+\n+        Columns left_elements;\n+        Columns right_elements;\n+        if (arguments[0].column)\n+            left_elements = getTupleElements(*arguments[0].column);\n+        if (arguments[1].column)\n+            right_elements = getTupleElements(*arguments[1].column);\n+\n+        if (left_types.size() != right_types.size())\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                            \"Expected tuples of the same size as arguments of function {}. Got {} and {}\",\n+                            getName(), arguments[0].type->getName(), arguments[1].type->getName());\n+\n+        size_t tuple_size = left_types.size();\n+        if (tuple_size == 0)\n+            return std::make_shared<DataTypeUInt8>();\n+\n+        auto multiply = FunctionFactory::instance().get(\"multiply\", context);\n+        auto plus = FunctionFactory::instance().get(\"plus\", context);\n+        DataTypePtr res_type;\n+        for (size_t i = 0; i < tuple_size; ++i)\n+        {\n+            try\n+            {\n+                ColumnWithTypeAndName left{left_elements.empty() ? nullptr : left_elements[i], left_types[i], {}};\n+                ColumnWithTypeAndName right{right_elements.empty() ? nullptr : right_elements[i], right_types[i], {}};\n+                auto elem_multiply = multiply->build(ColumnsWithTypeAndName{left, right});\n+\n+                if (i == 0)\n+                {\n+                    res_type = elem_multiply->getResultType();\n+                    continue;\n+                }\n+\n+                ColumnWithTypeAndName left_type{res_type, {}};\n+                ColumnWithTypeAndName right_type{elem_multiply->getResultType(), {}};\n+                auto plus_elem = plus->build({left_type, right_type});\n+                res_type = plus_elem->getResultType();\n+            }\n+            catch (DB::Exception & e)\n+            {\n+                e.addMessage(\"While executing function {} for tuple element {}\", getName(), i);\n+                throw;\n+            }\n+        }\n+\n+        return res_type;\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        const auto * left_tuple = checkAndGetDataType<DataTypeTuple>(arguments[0].type.get());\n+        const auto * right_tuple = checkAndGetDataType<DataTypeTuple>(arguments[1].type.get());\n+        const auto & left_types = left_tuple->getElements();\n+        const auto & right_types = right_tuple->getElements();\n+        auto left_elements = getTupleElements(*arguments[0].column);\n+        auto right_elements = getTupleElements(*arguments[1].column);\n+\n+        size_t tuple_size = left_elements.size();\n+        if (tuple_size == 0)\n+            return DataTypeUInt8().createColumnConstWithDefaultValue(input_rows_count);\n+\n+        auto multiply = FunctionFactory::instance().get(\"multiply\", context);\n+        auto plus = FunctionFactory::instance().get(\"plus\", context);\n+        ColumnWithTypeAndName res;\n+        for (size_t i = 0; i < tuple_size; ++i)\n+        {\n+            ColumnWithTypeAndName left{left_elements[i], left_types[i], {}};\n+            ColumnWithTypeAndName right{right_elements[i], right_types[i], {}};\n+            auto elem_multiply = multiply->build(ColumnsWithTypeAndName{left, right});\n+\n+            ColumnWithTypeAndName column;\n+            column.type = elem_multiply->getResultType();\n+            column.column = elem_multiply->execute({left, right}, column.type, input_rows_count);\n+\n+            if (i == 0)\n+            {\n+                res = std::move(column);\n+            }\n+            else\n+            {\n+                auto plus_elem = plus->build({res, column});\n+                auto res_type = plus_elem->getResultType();\n+                res.column = plus_elem->execute({res, column}, res_type, input_rows_count);\n+                res.type = res_type;\n+            }\n+        }\n+\n+        return res.column;\n+    }\n+};\n+\n+/// this is for convenient usage in LNormalize\n+template <class FuncLabel>\n+class FunctionLNorm : public ITupleFunction {};\n+\n+template <>\n+class FunctionLNorm<L1Label> : public ITupleFunction\n+{\n+public:\n+    static constexpr auto name = \"L1Norm\";\n+\n+    explicit FunctionLNorm(ContextPtr context_) : ITupleFunction(context_) {}\n+    static FunctionPtr create(ContextPtr context_) { return std::make_shared<FunctionLNorm>(context_); }\n+\n+    String getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 1; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        const auto * cur_tuple = checkAndGetDataType<DataTypeTuple>(arguments[0].type.get());\n+\n+        if (!cur_tuple)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Argument 0 of function {} should be tuple, got {}\",\n+                            getName(), arguments[0].type->getName());\n+\n+        const auto & cur_types = cur_tuple->getElements();\n+\n+        Columns cur_elements;\n+        if (arguments[0].column)\n+            cur_elements = getTupleElements(*arguments[0].column);\n+\n+        size_t tuple_size = cur_types.size();\n+        if (tuple_size == 0)\n+            return std::make_shared<DataTypeUInt8>();\n+\n+        auto abs = FunctionFactory::instance().get(\"abs\", context);\n+        auto plus = FunctionFactory::instance().get(\"plus\", context);\n+        DataTypePtr res_type;\n+        for (size_t i = 0; i < tuple_size; ++i)\n+        {\n+            try\n+            {\n+                ColumnWithTypeAndName cur{cur_elements.empty() ? nullptr : cur_elements[i], cur_types[i], {}};\n+                auto elem_abs = abs->build(ColumnsWithTypeAndName{cur});\n+\n+                if (i == 0)\n+                {\n+                    res_type = elem_abs->getResultType();\n+                    continue;\n+                }\n+\n+                ColumnWithTypeAndName left_type{res_type, {}};\n+                ColumnWithTypeAndName right_type{elem_abs->getResultType(), {}};\n+                auto plus_elem = plus->build({left_type, right_type});\n+                res_type = plus_elem->getResultType();\n+            }\n+            catch (DB::Exception & e)\n+            {\n+                e.addMessage(\"While executing function {} for tuple element {}\", getName(), i);\n+                throw;\n+            }\n+        }\n+\n+        return res_type;\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        const auto * cur_tuple = checkAndGetDataType<DataTypeTuple>(arguments[0].type.get());\n+        const auto & cur_types = cur_tuple->getElements();\n+        auto cur_elements = getTupleElements(*arguments[0].column);\n+\n+        size_t tuple_size = cur_elements.size();\n+        if (tuple_size == 0)\n+            return DataTypeUInt8().createColumnConstWithDefaultValue(input_rows_count);\n+\n+        auto abs = FunctionFactory::instance().get(\"abs\", context);\n+        auto plus = FunctionFactory::instance().get(\"plus\", context);\n+        ColumnWithTypeAndName res;\n+        for (size_t i = 0; i < tuple_size; ++i)\n+        {\n+            ColumnWithTypeAndName cur{cur_elements[i], cur_types[i], {}};\n+            auto elem_abs = abs->build(ColumnsWithTypeAndName{cur});\n+\n+            ColumnWithTypeAndName column;\n+            column.type = elem_abs->getResultType();\n+            column.column = elem_abs->execute({cur}, column.type, input_rows_count);\n+\n+            if (i == 0)\n+            {\n+                res = std::move(column);\n+            }\n+            else\n+            {\n+                auto plus_elem = plus->build({res, column});\n+                auto res_type = plus_elem->getResultType();\n+                res.column = plus_elem->execute({res, column}, res_type, input_rows_count);\n+                res.type = res_type;\n+            }\n+        }\n+\n+        return res.column;\n+    }\n+};\n+using FunctionL1Norm = FunctionLNorm<L1Label>;\n+\n+template <>\n+class FunctionLNorm<L2Label> : public ITupleFunction\n+{\n+public:\n+    static constexpr auto name = \"L2Norm\";\n+\n+    explicit FunctionLNorm(ContextPtr context_) : ITupleFunction(context_) {}\n+    static FunctionPtr create(ContextPtr context_) { return std::make_shared<FunctionLNorm>(context_); }\n+\n+    String getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 1; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        const auto * cur_tuple = checkAndGetDataType<DataTypeTuple>(arguments[0].type.get());\n+\n+        if (!cur_tuple)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Argument 0 of function {} should be tuple, got {}\",\n+                            getName(), arguments[0].type->getName());\n+\n+        const auto & cur_types = cur_tuple->getElements();\n+\n+        Columns cur_elements;\n+        if (arguments[0].column)\n+            cur_elements = getTupleElements(*arguments[0].column);\n+\n+        size_t tuple_size = cur_types.size();\n+        if (tuple_size == 0)\n+            return std::make_shared<DataTypeUInt8>();\n+\n+        auto multiply = FunctionFactory::instance().get(\"multiply\", context);\n+        auto plus = FunctionFactory::instance().get(\"plus\", context);\n+        DataTypePtr res_type;\n+        for (size_t i = 0; i < tuple_size; ++i)\n+        {\n+            try\n+            {\n+                ColumnWithTypeAndName cur{cur_elements.empty() ? nullptr : cur_elements[i], cur_types[i], {}};\n+                auto elem_multiply = multiply->build(ColumnsWithTypeAndName{cur, cur});\n+\n+                if (i == 0)\n+                {\n+                    res_type = elem_multiply->getResultType();\n+                    continue;\n+                }\n+\n+                ColumnWithTypeAndName left_type{res_type, {}};\n+                ColumnWithTypeAndName right_type{elem_multiply->getResultType(), {}};\n+                auto plus_elem = plus->build({left_type, right_type});\n+                res_type = plus_elem->getResultType();\n+            }\n+            catch (DB::Exception & e)\n+            {\n+                e.addMessage(\"While executing function {} for tuple element {}\", getName(), i);\n+                throw;\n+            }\n+        }\n+\n+        auto sqrt = FunctionFactory::instance().get(\"sqrt\", context);\n+        return sqrt->build({ColumnWithTypeAndName{res_type, {}}})->getResultType();\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        const auto * cur_tuple = checkAndGetDataType<DataTypeTuple>(arguments[0].type.get());\n+        const auto & cur_types = cur_tuple->getElements();\n+        auto cur_elements = getTupleElements(*arguments[0].column);\n+\n+        size_t tuple_size = cur_elements.size();\n+        if (tuple_size == 0)\n+            return DataTypeUInt8().createColumnConstWithDefaultValue(input_rows_count);\n+\n+        auto multiply = FunctionFactory::instance().get(\"multiply\", context);\n+        auto plus = FunctionFactory::instance().get(\"plus\", context);\n+        ColumnWithTypeAndName res;\n+        for (size_t i = 0; i < tuple_size; ++i)\n+        {\n+            ColumnWithTypeAndName cur{cur_elements[i], cur_types[i], {}};\n+            auto elem_multiply = multiply->build(ColumnsWithTypeAndName{cur, cur});\n+\n+            ColumnWithTypeAndName column;\n+            column.type = elem_multiply->getResultType();\n+            column.column = elem_multiply->execute({cur, cur}, column.type, input_rows_count);\n+\n+            if (i == 0)\n+            {\n+                res = std::move(column);\n+            }\n+            else\n+            {\n+                auto plus_elem = plus->build({res, column});\n+                auto res_type = plus_elem->getResultType();\n+                res.column = plus_elem->execute({res, column}, res_type, input_rows_count);\n+                res.type = res_type;\n+            }\n+        }\n+\n+        auto sqrt = FunctionFactory::instance().get(\"sqrt\", context);\n+        auto sqrt_elem = sqrt->build({res});\n+        return sqrt_elem->execute({res}, sqrt_elem->getResultType(), input_rows_count);\n+    }\n+};\n+using FunctionL2Norm = FunctionLNorm<L2Label>;\n+\n+template <>\n+class FunctionLNorm<LinfLabel> : public ITupleFunction\n+{\n+public:\n+    static constexpr auto name = \"LinfNorm\";\n+\n+    explicit FunctionLNorm(ContextPtr context_) : ITupleFunction(context_) {}\n+    static FunctionPtr create(ContextPtr context_) { return std::make_shared<FunctionLNorm>(context_); }\n+\n+    String getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 1; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        const auto * cur_tuple = checkAndGetDataType<DataTypeTuple>(arguments[0].type.get());\n+\n+        if (!cur_tuple)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Argument 0 of function {} should be tuple, got {}\",\n+                            getName(), arguments[0].type->getName());\n+\n+        const auto & cur_types = cur_tuple->getElements();\n+\n+        Columns cur_elements;\n+        if (arguments[0].column)\n+            cur_elements = getTupleElements(*arguments[0].column);\n+\n+        size_t tuple_size = cur_types.size();\n+        if (tuple_size == 0)\n+            return std::make_shared<DataTypeUInt8>();\n+\n+        auto abs = FunctionFactory::instance().get(\"abs\", context);\n+        auto max = FunctionFactory::instance().get(\"max2\", context);\n+        DataTypePtr res_type;\n+        for (size_t i = 0; i < tuple_size; ++i)\n+        {\n+            try\n+            {\n+                ColumnWithTypeAndName cur{cur_elements.empty() ? nullptr : cur_elements[i], cur_types[i], {}};\n+                auto elem_abs = abs->build(ColumnsWithTypeAndName{cur});\n+\n+                if (i == 0)\n+                {\n+                    res_type = elem_abs->getResultType();\n+                    continue;\n+                }\n+\n+                ColumnWithTypeAndName left_type{res_type, {}};\n+                ColumnWithTypeAndName right_type{elem_abs->getResultType(), {}};\n+                auto max_elem = max->build({left_type, right_type});\n+                res_type = max_elem->getResultType();\n+            }\n+            catch (DB::Exception & e)\n+            {\n+                e.addMessage(\"While executing function {} for tuple element {}\", getName(), i);\n+                throw;\n+            }\n+        }\n+\n+        return res_type;\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        const auto * cur_tuple = checkAndGetDataType<DataTypeTuple>(arguments[0].type.get());\n+        const auto & cur_types = cur_tuple->getElements();\n+        auto cur_elements = getTupleElements(*arguments[0].column);\n+\n+        size_t tuple_size = cur_elements.size();\n+        if (tuple_size == 0)\n+            return DataTypeUInt8().createColumnConstWithDefaultValue(input_rows_count);\n+\n+        auto abs = FunctionFactory::instance().get(\"abs\", context);\n+        auto max = FunctionFactory::instance().get(\"max2\", context);\n+        ColumnWithTypeAndName res;\n+        for (size_t i = 0; i < tuple_size; ++i)\n+        {\n+            ColumnWithTypeAndName cur{cur_elements[i], cur_types[i], {}};\n+            auto elem_abs = abs->build(ColumnsWithTypeAndName{cur});\n+\n+            ColumnWithTypeAndName column;\n+            column.type = elem_abs->getResultType();\n+            column.column = elem_abs->execute({cur}, column.type, input_rows_count);\n+\n+            if (i == 0)\n+            {\n+                res = std::move(column);\n+            }\n+            else\n+            {\n+                auto max_elem = max->build({res, column});\n+                auto res_type = max_elem->getResultType();\n+                res.column = max_elem->execute({res, column}, res_type, input_rows_count);\n+                res.type = res_type;\n+            }\n+        }\n+\n+        return res.column;\n+    }\n+};\n+using FunctionLinfNorm = FunctionLNorm<LinfLabel>;\n+\n+template <>\n+class FunctionLNorm<LpLabel> : public ITupleFunction\n+{\n+public:\n+    static constexpr auto name = \"LpNorm\";\n+\n+    explicit FunctionLNorm(ContextPtr context_) : ITupleFunction(context_) {}\n+    static FunctionPtr create(ContextPtr context_) { return std::make_shared<FunctionLNorm>(context_); }\n+\n+    String getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 2; }\n+\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        const auto * cur_tuple = checkAndGetDataType<DataTypeTuple>(arguments[0].type.get());\n+\n+        if (!cur_tuple)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Argument 0 of function {} should be tuple, got {}\",\n+                            getName(), arguments[0].type->getName());\n+\n+        const auto & cur_types = cur_tuple->getElements();\n+\n+        Columns cur_elements;\n+        if (arguments[0].column)\n+            cur_elements = getTupleElements(*arguments[0].column);\n+\n+        size_t tuple_size = cur_types.size();\n+        if (tuple_size == 0)\n+            return std::make_shared<DataTypeUInt8>();\n+\n+        const auto & p_column = arguments[1];\n+        auto abs = FunctionFactory::instance().get(\"abs\", context);\n+        auto pow = FunctionFactory::instance().get(\"pow\", context);\n+        auto plus = FunctionFactory::instance().get(\"plus\", context);\n+        DataTypePtr res_type;\n+        for (size_t i = 0; i < tuple_size; ++i)\n+        {\n+            try\n+            {\n+                ColumnWithTypeAndName cur{cur_elements.empty() ? nullptr : cur_elements[i], cur_types[i], {}};\n+                auto elem_abs = abs->build(ColumnsWithTypeAndName{cur});\n+                cur.type = elem_abs->getResultType();\n+                cur.column = cur.type->createColumn();\n+\n+                auto elem_pow = pow->build(ColumnsWithTypeAndName{cur, p_column});\n+\n+                if (i == 0)\n+                {\n+                    res_type = elem_pow->getResultType();\n+                    continue;\n+                }\n+\n+                ColumnWithTypeAndName left_type{res_type, {}};\n+                ColumnWithTypeAndName right_type{elem_pow->getResultType(), {}};\n+                auto plus_elem = plus->build({left_type, right_type});\n+                res_type = plus_elem->getResultType();\n+            }\n+            catch (DB::Exception & e)\n+            {\n+                e.addMessage(\"While executing function {} for tuple element {}\", getName(), i);\n+                throw;\n+            }\n+        }\n+\n+        ColumnWithTypeAndName inv_p_column{std::make_shared<DataTypeFloat64>(), {}};\n+        return pow->build({ColumnWithTypeAndName{res_type, {}}, inv_p_column})->getResultType();\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        const auto * cur_tuple = checkAndGetDataType<DataTypeTuple>(arguments[0].type.get());\n+        const auto & cur_types = cur_tuple->getElements();\n+        auto cur_elements = getTupleElements(*arguments[0].column);\n+\n+        size_t tuple_size = cur_elements.size();\n+        if (tuple_size == 0)\n+            return DataTypeUInt8().createColumnConstWithDefaultValue(input_rows_count);\n+\n+        const auto & p_column = arguments[1];\n+\n+        const auto * p_column_const = assert_cast<const ColumnConst *>(p_column.column.get());\n+        double p;\n+        if (isFloat(p_column_const->getDataType()))\n+            p = p_column_const->getFloat64(0);\n+        else if (isUnsignedInteger(p_column_const->getDataType()))\n+            p = p_column_const->getUInt(0);\n+        else\n+            throw Exception{\"Second argument for function \" + getName() + \" must be either constant Float64 or constant UInt\", ErrorCodes::ILLEGAL_COLUMN};\n+\n+        if (p < 1 || p == HUGE_VAL)\n+            throw Exception{\"Second argument for function \" + getName() + \" must be not less than one and not be an infinity\", ErrorCodes::ARGUMENT_OUT_OF_BOUND};\n+\n+        auto abs = FunctionFactory::instance().get(\"abs\", context);\n+        auto pow = FunctionFactory::instance().get(\"pow\", context);\n+        auto plus = FunctionFactory::instance().get(\"plus\", context);\n+        ColumnWithTypeAndName res;\n+        for (size_t i = 0; i < tuple_size; ++i)\n+        {\n+            ColumnWithTypeAndName cur{cur_elements[i], cur_types[i], {}};\n+            auto elem_abs = abs->build(ColumnsWithTypeAndName{cur});\n+            cur.column = elem_abs->execute({cur}, elem_abs->getResultType(), input_rows_count);\n+            cur.type = elem_abs->getResultType();\n+\n+            auto elem_pow = pow->build(ColumnsWithTypeAndName{cur, p_column});\n+\n+            ColumnWithTypeAndName column;\n+            column.type = elem_pow->getResultType();\n+            column.column = elem_pow->execute({cur, p_column}, column.type, input_rows_count);\n+\n+            if (i == 0)\n+            {\n+                res = std::move(column);\n+            }\n+            else\n+            {\n+                auto plus_elem = plus->build({res, column});\n+                auto res_type = plus_elem->getResultType();\n+                res.column = plus_elem->execute({res, column}, res_type, input_rows_count);\n+                res.type = res_type;\n+            }\n+        }\n+\n+        ColumnWithTypeAndName inv_p_column{DataTypeFloat64().createColumnConst(input_rows_count, 1 / p),\n+                                           std::make_shared<DataTypeFloat64>(), {}};\n+        auto pow_elem = pow->build({res, inv_p_column});\n+        return pow_elem->execute({res, inv_p_column}, pow_elem->getResultType(), input_rows_count);\n+    }\n+};\n+using FunctionLpNorm = FunctionLNorm<LpLabel>;\n+\n+template <class FuncLabel>\n+class FunctionLDistance : public ITupleFunction\n+{\n+public:\n+    /// constexpr cannot be used due to std::string has not constexpr constructor in this compiler version\n+    static inline auto name = std::string(\"L\") + FuncLabel::name + \"Distance\";\n+\n+    explicit FunctionLDistance(ContextPtr context_) : ITupleFunction(context_) {}\n+    static FunctionPtr create(ContextPtr context_) { return std::make_shared<FunctionLDistance>(context_); }\n+\n+    String getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override\n+    {\n+        if constexpr (FuncLabel::name[0] == 'p')\n+            return 3;\n+        else\n+            return 2;\n+    }\n+\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override\n+    {\n+        if constexpr (FuncLabel::name[0] == 'p')\n+            return {2};\n+        else\n+            return {};\n+    }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        FunctionTupleMinus tuple_minus(context);\n+        auto type = tuple_minus.getReturnTypeImpl(arguments);\n+\n+        ColumnWithTypeAndName minus_res{type, {}};\n+\n+        auto func = FunctionFactory::instance().get(std::string(\"L\") + FuncLabel::name + \"Norm\", context);\n+        if constexpr (FuncLabel::name[0] == 'p')\n+            return func->build({minus_res, arguments[2]})->getResultType();\n+        else\n+            return func->build({minus_res})->getResultType();\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        FunctionTupleMinus tuple_minus(context);\n+        auto type = tuple_minus.getReturnTypeImpl(arguments);\n+        auto column = tuple_minus.executeImpl(arguments, DataTypePtr(), input_rows_count);\n+\n+        ColumnWithTypeAndName minus_res{column, type, {}};\n+\n+        auto func = FunctionFactory::instance().get(std::string(\"L\") + FuncLabel::name + \"Norm\", context);\n+        if constexpr (FuncLabel::name[0] == 'p')\n+        {\n+            auto func_elem = func->build({minus_res, arguments[2]});\n+            return func_elem->execute({minus_res, arguments[2]}, func_elem->getResultType(), input_rows_count);\n+        }\n+        else\n+        {\n+            auto func_elem = func->build({minus_res});\n+            return func_elem->execute({minus_res}, func_elem->getResultType(), input_rows_count);\n+        }\n+    }\n+};\n+\n+using FunctionL1Distance = FunctionLDistance<L1Label>;\n+\n+using FunctionL2Distance = FunctionLDistance<L2Label>;\n+\n+using FunctionLinfDistance = FunctionLDistance<LinfLabel>;\n+\n+using FunctionLpDistance = FunctionLDistance<LpLabel>;\n+\n+template <class FuncLabel>\n+class FunctionLNormalize : public ITupleFunction\n+{\n+public:\n+    /// constexpr cannot be used due to std::string has not constexpr constructor in this compiler version\n+    static inline auto name = std::string(\"L\") + FuncLabel::name + \"Normalize\";\n+\n+    explicit FunctionLNormalize(ContextPtr context_) : ITupleFunction(context_) {}\n+    static FunctionPtr create(ContextPtr context_) { return std::make_shared<FunctionLNormalize>(context_); }\n+\n+    String getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override\n+    {\n+        if constexpr (FuncLabel::name[0] == 'p')\n+            return 2;\n+        else\n+            return 1;\n+    }\n+\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override\n+    {\n+        if constexpr (FuncLabel::name[0] == 'p')\n+            return {1};\n+        else\n+            return {};\n+    }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        FunctionLNorm<FuncLabel> norm(context);\n+        auto type = norm.getReturnTypeImpl(arguments);\n+\n+        ColumnWithTypeAndName norm_res{type, {}};\n+\n+        FunctionTupleDivideByNumber divide(context);\n+        return divide.getReturnTypeImpl({arguments[0], norm_res});\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        FunctionLNorm<FuncLabel> norm(context);\n+        auto type = norm.getReturnTypeImpl(arguments);\n+        auto column = norm.executeImpl(arguments, DataTypePtr(), input_rows_count);\n+\n+        ColumnWithTypeAndName norm_res{column, type, {}};\n+\n+        FunctionTupleDivideByNumber divide(context);\n+        return divide.executeImpl({arguments[0], norm_res}, DataTypePtr(), input_rows_count);\n+    }\n+};\n+\n+using FunctionL1Normalize = FunctionLNormalize<L1Label>;\n+\n+using FunctionL2Normalize = FunctionLNormalize<L2Label>;\n+\n+using FunctionLinfNormalize = FunctionLNormalize<LinfLabel>;\n+\n+using FunctionLpNormalize = FunctionLNormalize<LpLabel>;\n+\n+class FunctionCosineDistance : public ITupleFunction\n+{\n+public:\n+    /// constexpr cannot be used due to std::string has not constexpr constructor in this compiler version\n+    static inline auto name = \"cosineDistance\";\n+\n+    explicit FunctionCosineDistance(ContextPtr context_) : ITupleFunction(context_) {}\n+    static FunctionPtr create(ContextPtr context_) { return std::make_shared<FunctionCosineDistance>(context_); }\n+\n+    String getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 2; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        FunctionDotProduct dot(context);\n+        ColumnWithTypeAndName dot_result{dot.getReturnTypeImpl(arguments), {}};\n+\n+        FunctionL2Norm norm(context);\n+        ColumnWithTypeAndName first_norm{norm.getReturnTypeImpl({arguments[0]}), {}};\n+        ColumnWithTypeAndName second_norm{norm.getReturnTypeImpl({arguments[1]}), {}};\n+\n+        auto minus = FunctionFactory::instance().get(\"minus\", context);\n+        auto multiply = FunctionFactory::instance().get(\"multiply\", context);\n+        auto divide = FunctionFactory::instance().get(\"divide\", context);\n+\n+        ColumnWithTypeAndName one{std::make_shared<DataTypeUInt8>(), {}};\n+\n+        ColumnWithTypeAndName multiply_result{multiply->build({first_norm, second_norm})->getResultType(), {}};\n+        ColumnWithTypeAndName divide_result{divide->build({dot_result, multiply_result})->getResultType(), {}};\n+        return minus->build({one, divide_result})->getResultType();\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        if (getReturnTypeImpl(arguments)->isNullable())\n+        {\n+            return DataTypeNullable(std::make_shared<DataTypeNothing>())\n+                   .createColumnConstWithDefaultValue(input_rows_count);\n+        }\n+\n+        FunctionDotProduct dot(context);\n+        ColumnWithTypeAndName dot_result{dot.executeImpl(arguments, DataTypePtr(), input_rows_count),\n+                                         dot.getReturnTypeImpl(arguments), {}};\n+\n+        FunctionL2Norm norm(context);\n+        ColumnWithTypeAndName first_norm{norm.executeImpl({arguments[0]}, DataTypePtr(), input_rows_count),\n+                                         norm.getReturnTypeImpl({arguments[0]}), {}};\n+        ColumnWithTypeAndName second_norm{norm.executeImpl({arguments[1]}, DataTypePtr(), input_rows_count),\n+                                          norm.getReturnTypeImpl({arguments[1]}), {}};\n+\n+        auto minus = FunctionFactory::instance().get(\"minus\", context);\n+        auto multiply = FunctionFactory::instance().get(\"multiply\", context);\n+        auto divide = FunctionFactory::instance().get(\"divide\", context);\n+\n+        ColumnWithTypeAndName one{DataTypeUInt8().createColumnConst(input_rows_count, 1),\n+                                  std::make_shared<DataTypeUInt8>(), {}};\n+\n+        auto multiply_elem = multiply->build({first_norm, second_norm});\n+        ColumnWithTypeAndName multiply_result;\n+        multiply_result.type = multiply_elem->getResultType();\n+        multiply_result.column = multiply_elem->execute({first_norm, second_norm},\n+                                                        multiply_result.type, input_rows_count);\n+\n+        auto divide_elem = divide->build({dot_result, multiply_result});\n+        ColumnWithTypeAndName divide_result;\n+        divide_result.type = divide_elem->getResultType();\n+        divide_result.column = divide_elem->execute({dot_result, multiply_result},\n+                                                    divide_result.type, input_rows_count);\n+\n+        auto minus_elem = minus->build({one, divide_result});\n+        return minus_elem->execute({one, divide_result}, minus_elem->getResultType(), {});\n+    }\n+};\n+\n+void registerVectorFunctions(FunctionFactory & factory)\n+{\n+    factory.registerFunction<FunctionTuplePlus>();\n+    factory.registerAlias(\"vectorSum\", FunctionTuplePlus::name, FunctionFactory::CaseInsensitive);\n+    factory.registerFunction<FunctionTupleMinus>();\n+    factory.registerAlias(\"vectorDifference\", FunctionTupleMinus::name, FunctionFactory::CaseInsensitive);\n+    factory.registerFunction<FunctionTupleMultiply>();\n+    factory.registerFunction<FunctionTupleDivide>();\n+    factory.registerFunction<FunctionTupleNegate>();\n+\n+    factory.registerFunction<FunctionTupleMultiplyByNumber>();\n+    factory.registerFunction<FunctionTupleDivideByNumber>();\n+\n+    factory.registerFunction<FunctionDotProduct>();\n+    factory.registerAlias(\"scalarProduct\", FunctionDotProduct::name, FunctionFactory::CaseInsensitive);\n+\n+    factory.registerFunction<FunctionL1Norm>();\n+    factory.registerFunction<FunctionL2Norm>();\n+    factory.registerFunction<FunctionLinfNorm>();\n+    factory.registerFunction<FunctionLpNorm>();\n+\n+    factory.registerAlias(\"normL1\", FunctionL1Norm::name, FunctionFactory::CaseInsensitive);\n+    factory.registerAlias(\"normL2\", FunctionL2Norm::name, FunctionFactory::CaseInsensitive);\n+    factory.registerAlias(\"normLinf\", FunctionLinfNorm::name, FunctionFactory::CaseInsensitive);\n+    factory.registerAlias(\"normLp\", FunctionLpNorm::name, FunctionFactory::CaseInsensitive);\n+\n+    factory.registerFunction<FunctionL1Distance>();\n+    factory.registerFunction<FunctionL2Distance>();\n+    factory.registerFunction<FunctionLinfDistance>();\n+    factory.registerFunction<FunctionLpDistance>();\n+\n+    factory.registerAlias(\"distanceL1\", FunctionL1Distance::name, FunctionFactory::CaseInsensitive);\n+    factory.registerAlias(\"distanceL2\", FunctionL2Distance::name, FunctionFactory::CaseInsensitive);\n+    factory.registerAlias(\"distanceLinf\", FunctionLinfDistance::name, FunctionFactory::CaseInsensitive);\n+    factory.registerAlias(\"distanceLp\", FunctionLpDistance::name, FunctionFactory::CaseInsensitive);\n+\n+    factory.registerFunction<FunctionL1Normalize>();\n+    factory.registerFunction<FunctionL2Normalize>();\n+    factory.registerFunction<FunctionLinfNormalize>();\n+    factory.registerFunction<FunctionLpNormalize>();\n+\n+    factory.registerAlias(\"normalizeL1\", FunctionL1Normalize::name, FunctionFactory::CaseInsensitive);\n+    factory.registerAlias(\"normalizeL2\", FunctionL2Normalize::name, FunctionFactory::CaseInsensitive);\n+    factory.registerAlias(\"normalizeLinf\", FunctionLinfNormalize::name, FunctionFactory::CaseInsensitive);\n+    factory.registerAlias(\"normalizeLp\", FunctionLpNormalize::name, FunctionFactory::CaseInsensitive);\n+\n+    factory.registerFunction<FunctionCosineDistance>();\n+}\n+}\ndiff --git a/src/Parsers/ASTFunction.cpp b/src/Parsers/ASTFunction.cpp\nindex 058cd8daa418..3c78c4060d69 100644\n--- a/src/Parsers/ASTFunction.cpp\n+++ b/src/Parsers/ASTFunction.cpp\n@@ -4,6 +4,7 @@\n #include <Common/FieldVisitorToString.h>\n #include <Common/SipHash.h>\n #include <Common/typeid_cast.h>\n+#include <DataTypes/IDataType.h>\n #include <DataTypes/NumberTraits.h>\n #include <IO/Operators.h>\n #include <IO/WriteBufferFromString.h>\n@@ -243,8 +244,11 @@ void ASTFunction::formatImplWithoutAlias(const FormatSettings & settings, Format\n                 const auto * literal = arguments->children[0]->as<ASTLiteral>();\n                 const auto * function = arguments->children[0]->as<ASTFunction>();\n                 bool negate = name == \"negate\";\n+                bool is_tuple = literal && literal->value.getType() == Field::Types::Tuple;\n+                // do not add parentheses for tuple literal, otherwise extra parens will be added `-((3, 7, 3), 1)` -> `-(((3, 7, 3), 1))`\n+                bool literal_need_parens = literal && !is_tuple;\n                 // negate always requires parentheses, otherwise -(-1) will be printed as --1\n-                bool negate_need_parens = negate && (literal || (function && function->name == \"negate\"));\n+                bool negate_need_parens = negate && (literal_need_parens || (function && function->name == \"negate\"));\n                 // We don't need parentheses around a single literal.\n                 bool need_parens = !literal && frame.need_parens && !negate_need_parens;\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02011_tuple_vector_functions.reference b/tests/queries/0_stateless/02011_tuple_vector_functions.reference\nnew file mode 100644\nindex 000000000000..4c5067c7da2c\n--- /dev/null\n+++ b/tests/queries/0_stateless/02011_tuple_vector_functions.reference\n@@ -0,0 +1,74 @@\n+0\n+1\n+(10,3)\n+(-1,0)\n+(-23,-27)\n+(-2.5,4,2.75)\n+(3)\n+(-1,0,-3.5)\n+(-1,-2,-3)\n+(-1)\n+(0.5,1,1.5)\n+(2,5,6)\n+(1)\n+(1)\n+(3,6,9.3)\n+(11,22)\n+(0.5,1)\n+20\n+16.808\n+0\n+6\n+7.1\n+1.4142135623730951\n+13\n+1.5\n+-3\n+2.3\n+1\n+1\n+1.1\n+422481\n+1\n+1\n+2.0000887587111964\n+4\n+2.8284271247461903\n+1\n+0\n+-4.413254828250501e-8\n+(0.2,-0.8)\n+(0.6,0.8)\n+(1,-1,1)\n+(0.4999999999999999,0.9936703773322288)\n+2.220446049250313e-16\n+1\n+1.9999999999999998\n+0.4999999999999999\n+(NULL,NULL)\n+\\N\n+\\N\n+(2,4,NULL)\n+\\N\n+\\N\n+(NULL,NULL,-1)\n+\\N\n+(NULL,NULL)\n+\\N\n+\\N\n+(3.1,6.2)\n+(2,1)\n+(3,2)\n+(4,3)\n+2.220446049250313e-16\n+0.007722123286332261\n+0.01613008990009257\n+(NULL,0,0)\n+(NULL,-2,-1)\n+2\t1.4142135623730951\t1\t2\n+0\t0\t0\t0\n+(0.5,0.5)\t(0.7071067811865475,0.7071067811865475)\t(1,1)\t(0.5,0.5)\n+3.6060655943063797\n+4.3208683194033215\n+\\N\n+SELECT -((3, 7, 3), 100)\ndiff --git a/tests/queries/0_stateless/02011_tuple_vector_functions.sql b/tests/queries/0_stateless/02011_tuple_vector_functions.sql\nnew file mode 100644\nindex 000000000000..f34fb91586cc\n--- /dev/null\n+++ b/tests/queries/0_stateless/02011_tuple_vector_functions.sql\n@@ -0,0 +1,106 @@\n+SELECT tupleHammingDistance(tuple(1), tuple(1));\n+SELECT tupleHammingDistance((1, 3), (1, 2));\n+\n+SELECT (1, 2) + tupleMultiply((3, 4), materialize((5, 1))) - (6, 3);\n+SELECT vectorDifference(tuplePlus((1, 2), (3, 4)), (5, 6));\n+SELECT tupleMinus(materialize(vectorSum(tupleMultiply(materialize((1, 2)), (3, 4)), (5, 6))), (31, 41));\n+SELECT tupleDivide((5, 8, 11), (-2, 2, 4));\n+SELECT tuple(1) + tuple(2);\n+\n+SELECT tupleNegate((1, 0, 3.5));\n+SELECT -materialize((1, 2, 3));\n+SELECT -tuple(1);\n+\n+SELECT tupleMultiplyByNumber((1, 2, 3), 0.5);\n+SELECT tupleDivideByNumber((1, 2.5, 3), materialize(0.5));\n+SELECT tupleMultiplyByNumber(tuple(1), 1);\n+SELECT tupleDivideByNumber(tuple(1), materialize(1));\n+\n+SELECT materialize((1, 2.0, 3.1)) * 3;\n+SELECT 5.5 * (2, 4);\n+SELECT (1, 2) / 2;\n+SELECT 2 / (1, 1); -- { serverError 43 }\n+\n+SELECT tuple(1, 2, 3) * tuple(2, 3, 4);\n+SELECT dotProduct(materialize((-1, 2, 3.002)), materialize((2, 3.4, 4)));\n+SELECT scalarProduct(tuple(1), tuple(0));\n+\n+SELECT L1Norm((-1, 2, -3));\n+SELECT L1Norm((-1, 2.5, -3.6));\n+SELECT L2Norm((1, 1.0));\n+SELECT L2Norm(materialize((-12, 5)));\n+\n+SELECT max2(materialize(1), 1.5);\n+SELECT min2(-1, -3);\n+SELECT LinfNorm((1, -2.3, 1.7));\n+\n+SELECT LpNorm(tuple(-1), 3.3);\n+SELECT LpNorm(tuple(-1), 3);\n+SELECT LpNorm(tuple(-1.1), 3);\n+SELECT LpNorm((95800, 217519, 414560), 4);\n+SELECT LpNorm((13, -84.4, 91, 63.1), 2) = L2Norm(tuple(13, -84.4, 91, 63.1));\n+SELECT LpNorm(materialize((13, -84.4, 91, 63.1)), 1) = L1Norm(tuple(13, -84.4, 91, 63.1));\n+SELECT LpNorm((-1, -2), 11.);\n+\n+SELECT L1Distance((1, 2, 3), (2, 3, 1));\n+SELECT L2Distance(materialize((1, 1)), (3, -1));\n+SELECT LinfDistance((1, 1), (1, 2));\n+SELECT L2Distance((5, 5), (5, 5));\n+SELECT LpDistance((1800, 1900), (18, 59), 12) - LpDistance(tuple(-22), tuple(1900), 12.);\n+\n+SELECT L1Normalize(materialize((1, -4)));\n+SELECT L2Normalize((3, 4));\n+SELECT LinfNormalize((5, -5, 5.0));\n+SELECT LpNormalize((1, pow(31, 1 / 5)), 5.);\n+\n+SELECT cosineDistance(materialize((1, 1)), (2, 2));\n+SELECT cosineDistance((1, 1), materialize((-3, 3.0)));\n+SELECT cosineDistance((1, 1), (-1, -1));\n+SELECT cosineDistance((1, 0), (0.5, sqrt(3) / 2));\n+\n+SELECT (NULL, 1) + (1, NULL);\n+SELECT (NULL, 1) * materialize((1, NULL));\n+SELECT L2Norm((NULL, 3, 4));\n+SELECT 2 * (1, 2, NULL);\n+SELECT (1, 1.0, NULL) / NULL;\n+SELECT (1, 1.0, NULL) / materialize(NULL);\n+SELECT -(NULL, NULL, 1);\n+SELECT (NULL, NULL) * NULL;\n+SELECT L1Normalize((NULL, 1));\n+SELECT cosineDistance((NULL, 1), (NULL, NULL));\n+SELECT max2(NULL, 1) - min2(NULL, 1);\n+\n+SELECT L1Norm(1); -- { serverError 43 }\n+SELECT (1, 1) / toString(1); -- { serverError 43 }\n+SELECT -(1, toString(1)); -- { serverError 43 }\n+SELECT LpNorm((1, 2), toDecimal32(2, 4)); -- { serverError 43 }\n+SELECT (1, 2) * toDecimal32(3.1, 8);\n+\n+SELECT cosineDistance((1, 2), (2, 3, 4)); -- { serverError 43 }\n+SELECT tuple() + tuple(); -- { serverError 42 }\n+SELECT LpNorm((1, 2, 3)); -- { serverError 42 }\n+SELECT max2(1, 2, -1); -- { serverError 42 }\n+\n+SELECT LpNorm((1, 2, 3), materialize(4.)); -- { serverError 44 }\n+\n+SELECT tuple(*, 1) + tuple(2, *) FROM numbers(3);\n+SELECT LpDistance(tuple(*, 1), tuple(2, *), * + 1.) FROM numbers(3, 2); -- { serverError 44 }\n+SELECT cosineDistance(tuple(*, * + 1), tuple(1, 2)) FROM numbers(1, 3);\n+SELECT -tuple(NULL, * * 2, *) FROM numbers(2);\n+\n+SELECT normL1((1, 1)), normL2((1, 1)), normLinf((1, 1)), normLp((1, 1), 1.);\n+SELECT distanceL1((1, 1), (1, 1)), distanceL2((1, 1), (1, 1)), distanceLinf((1, 1), (1, 1)), distanceLp((1, 1), (1, 1), 1.);\n+SELECT normalizeL1((1, 1)), normalizeL2((1, 1)), normalizeLinf((1, 1)), normalizeLp((1, 1), 1.);\n+\n+SELECT LpNorm((1, 2, 3), 2.2);\n+SELECT LpNorm((1.5, 2.5, 4), pi());\n+SELECT LpNorm((3, 1, 4), 0); -- { serverError 69 }\n+SELECT LpNorm((1, 2, 3), 0.5); -- { serverError 69 }\n+SELECT LpNorm((1, 2, 3), inf); -- { serverError 69 }\n+SELECT LpNorm((1, 2, 3), -1.); -- { serverError 69 }\n+SELECT LpNorm((1, 2, 3), -1); -- { serverError 44 }\n+SELECT LpNorm((1, 2, 3), 0.); -- { serverError 69 }\n+SELECT cosineDistance(materialize((NULL, -2147483648)), (1048577, 1048575));\n+\n+-- not extra parentheses\n+EXPLAIN SYNTAX SELECT -((3, 7, 3), 100);\n",
  "problem_statement": "support multidimensional cosine distance and euclidean distance function\nMultidimensional vector cosine distance and euclidean distance\r\n\r\n----tbl----\r\nid,dim1,dim2,dim3,dim4,dim5\r\n1,0.13,024,0.37,1.2,1.1\r\n2,0.13,024,0.46,1.27,0.7\r\n3,0.11,024,0.37,1.2,0.3\r\n4,0.23,028,0.17,1.2.0.311\r\n\r\nquery term: 0.12,023,0.37,1.2,0.31\r\ncalculate Euclidean distance and cos distance with every row \r\n\r\n\r\n\r\n\n",
  "hints_text": "So, we need tuple-wise addition and subtraction operators, and also scalar product function and l2Distance, l2Norm and cosineDistance functions.\nThere will be L1, L2, Linf, Lp versions for the Distance and Norm functions.",
  "created_at": "2021-08-20T14:53:38Z"
}