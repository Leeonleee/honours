{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 57995,
  "instance_id": "ClickHouse__ClickHouse-57995",
  "issue_numbers": [
    "35843"
  ],
  "base_commit": "802ad4ec478fd65f22ded257c5177622d6a037fc",
  "patch": "diff --git a/docs/en/sql-reference/statements/select/join.md b/docs/en/sql-reference/statements/select/join.md\nindex 281a1d0436c1..97090a7a699e 100644\n--- a/docs/en/sql-reference/statements/select/join.md\n+++ b/docs/en/sql-reference/statements/select/join.md\n@@ -43,6 +43,7 @@ Additional join types available in ClickHouse:\n - `LEFT ANTI JOIN` and `RIGHT ANTI JOIN`, a blacklist on \u201cjoin keys\u201d, without producing a cartesian product.\n - `LEFT ANY JOIN`, `RIGHT ANY JOIN` and `INNER ANY JOIN`, partially (for opposite side of `LEFT` and `RIGHT`) or completely (for `INNER` and `FULL`) disables the cartesian product for standard `JOIN` types.\n - `ASOF JOIN` and `LEFT ASOF JOIN`, joining sequences with a non-exact match. `ASOF JOIN` usage is described below.\n+- `PASTE JOIN`, performs a horizontal concatenation of two tables.\n \n :::note\n When [join_algorithm](../../../operations/settings/settings.md#settings-join_algorithm) is set to `partial_merge`, `RIGHT JOIN` and `FULL JOIN` are supported only with `ALL` strictness (`SEMI`, `ANTI`, `ANY`, and `ASOF` are not supported).\n@@ -269,6 +270,33 @@ For example, consider the following tables:\n `ASOF` join is **not** supported in the [Join](../../../engines/table-engines/special/join.md) table engine.\n :::\n \n+## PASTE JOIN Usage\n+\n+The result of `PASTE JOIN` is a table that contains all columns from left subquery followed by all columns from the right subquery.\n+The rows are matched based on their positions in the original tables (the order of rows should be defined). \n+If the subqueries return a different number of rows, extra rows will be cut.\n+\n+Example:\n+```SQL\n+SELECT *\n+FROM\n+(\n+    SELECT number AS a\n+    FROM numbers(2)\n+) AS t1\n+PASTE JOIN\n+(\n+    SELECT number AS a\n+    FROM numbers(2)\n+    ORDER BY a DESC\n+) AS t2\n+\n+\u250c\u2500a\u2500\u252c\u2500t2.a\u2500\u2510\n+\u2502 0 \u2502    1 \u2502\n+\u2502 1 \u2502    0 \u2502\n+\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## Distributed JOIN\n \n There are two ways to execute join involving distributed tables:\ndiff --git a/src/Client/Suggest.cpp b/src/Client/Suggest.cpp\nindex c7ebcac12644..eb98c3a57402 100644\n--- a/src/Client/Suggest.cpp\n+++ b/src/Client/Suggest.cpp\n@@ -48,7 +48,7 @@ Suggest::Suggest()\n               \"GRANT\",        \"REVOKE\",        \"OPTION\",       \"ADMIN\",      \"EXCEPT\",   \"REPLACE\",     \"IDENTIFIED\", \"HOST\",\n               \"NAME\",         \"READONLY\",      \"WRITABLE\",     \"PERMISSIVE\", \"FOR\",      \"RESTRICTIVE\", \"RANDOMIZED\", \"INTERVAL\",\n               \"LIMITS\",       \"ONLY\",          \"TRACKING\",     \"IP\",         \"REGEXP\",   \"ILIKE\",       \"CLEANUP\",    \"APPEND\",\n-              \"IGNORE NULLS\", \"RESPECT NULLS\", \"OVER\"});\n+              \"IGNORE NULLS\", \"RESPECT NULLS\", \"OVER\",         \"PASTE\"});\n }\n \n static String getLoadSuggestionQuery(Int32 suggestion_limit, bool basic_suggestion)\ndiff --git a/src/Core/Joins.cpp b/src/Core/Joins.cpp\nindex 9c8ece822248..77568223d718 100644\n--- a/src/Core/Joins.cpp\n+++ b/src/Core/Joins.cpp\n@@ -13,6 +13,7 @@ const char * toString(JoinKind kind)\n         case JoinKind::Full: return \"FULL\";\n         case JoinKind::Cross: return \"CROSS\";\n         case JoinKind::Comma: return \"COMMA\";\n+        case JoinKind::Paste: return \"PASTE\";\n     }\n };\n \ndiff --git a/src/Core/Joins.h b/src/Core/Joins.h\nindex 6884e8dfd9a7..cc69f07263d8 100644\n--- a/src/Core/Joins.h\n+++ b/src/Core/Joins.h\n@@ -13,7 +13,8 @@ enum class JoinKind\n     Right,\n     Full,\n     Cross, /// Direct product. Strictness and condition doesn't matter.\n-    Comma /// Same as direct product. Intended to be converted to INNER JOIN with conditions from WHERE.\n+    Comma, /// Same as direct product. Intended to be converted to INNER JOIN with conditions from WHERE.\n+    Paste, /// Used to join parts without `ON` clause.\n };\n \n const char * toString(JoinKind kind);\n@@ -27,6 +28,7 @@ inline constexpr bool isRightOrFull(JoinKind kind)  { return kind == JoinKind::R\n inline constexpr bool isLeftOrFull(JoinKind kind)   { return kind == JoinKind::Left  || kind == JoinKind::Full; }\n inline constexpr bool isInnerOrRight(JoinKind kind) { return kind == JoinKind::Inner || kind == JoinKind::Right; }\n inline constexpr bool isInnerOrLeft(JoinKind kind)  { return kind == JoinKind::Inner || kind == JoinKind::Left; }\n+inline constexpr bool isPaste(JoinKind kind)        { return kind == JoinKind::Paste; }\n \n /// Allows more optimal JOIN for typical cases.\n enum class JoinStrictness\ndiff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp\nindex 3b389dcf61e4..6dbdcb50cfdd 100644\n--- a/src/Interpreters/ExpressionAnalyzer.cpp\n+++ b/src/Interpreters/ExpressionAnalyzer.cpp\n@@ -56,6 +56,7 @@\n #include <Core/Names.h>\n #include <Core/NamesAndTypes.h>\n #include <Common/logger_useful.h>\n+#include <Interpreters/PasteJoin.h>\n #include <QueryPipeline/SizeLimits.h>\n \n \n@@ -954,6 +955,9 @@ static std::shared_ptr<IJoin> tryCreateJoin(\n     std::unique_ptr<QueryPlan> & joined_plan,\n     ContextPtr context)\n {\n+    if (analyzed_join->kind() == JoinKind::Paste)\n+        return std::make_shared<PasteJoin>(analyzed_join, right_sample_block);\n+\n     if (algorithm == JoinAlgorithm::DIRECT || algorithm == JoinAlgorithm::DEFAULT)\n     {\n         JoinPtr direct_join = tryKeyValueJoin(analyzed_join, right_sample_block);\ndiff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex 672454381568..e9b0bdbd925c 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -1698,7 +1698,7 @@ void InterpreterSelectQuery::executeImpl(QueryPlan & query_plan, std::optional<P\n                         return step_raw_ptr;\n                     };\n \n-                    if (expressions.join->pipelineType() == JoinPipelineType::YShaped)\n+                    if (expressions.join->pipelineType() == JoinPipelineType::YShaped && expressions.join->getTableJoin().kind() != JoinKind::Paste)\n                     {\n                         const auto & table_join = expressions.join->getTableJoin();\n                         const auto & join_clause = table_join.getOnlyClause();\ndiff --git a/src/Interpreters/PasteJoin.h b/src/Interpreters/PasteJoin.h\nnew file mode 100644\nindex 000000000000..df7bb2f280c1\n--- /dev/null\n+++ b/src/Interpreters/PasteJoin.h\n@@ -0,0 +1,96 @@\n+#pragma once\n+\n+#include <Interpreters/IJoin.h>\n+#include <Interpreters/TableJoin.h>\n+#include <DataTypes/DataTypeNullable.h>\n+#include <DataTypes/DataTypeLowCardinality.h>\n+#include <Common/logger_useful.h>\n+#include <Poco/Logger.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int LOGICAL_ERROR;\n+    extern const int NOT_IMPLEMENTED;\n+}\n+\n+/// Dummy class, actual joining is done by MergeTransform\n+class PasteJoin : public IJoin\n+{\n+public:\n+    explicit PasteJoin(std::shared_ptr<TableJoin> table_join_, const Block & right_sample_block_)\n+        : table_join(table_join_)\n+        , right_sample_block(right_sample_block_)\n+    {\n+        LOG_TRACE(&Poco::Logger::get(\"PasteJoin\"), \"Will use paste join\");\n+    }\n+\n+    std::string getName() const override { return \"PasteJoin\"; }\n+    const TableJoin & getTableJoin() const override { return *table_join; }\n+\n+    bool addBlockToJoin(const Block & /* block */, bool /* check_limits */) override\n+    {\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"PasteJoin::addBlockToJoin should not be called\");\n+    }\n+\n+    static bool isSupported(const std::shared_ptr<TableJoin> & table_join)\n+    {\n+        bool support_storage = !table_join->isSpecialStorage();\n+\n+        /// Key column can change nullability and it's not handled on type conversion stage, so algorithm should be aware of it\n+        bool support_using = !table_join->hasUsing();\n+\n+        bool check_strictness = table_join->strictness() == JoinStrictness::All;\n+\n+        bool if_has_keys = table_join->getClauses().empty();\n+\n+        return support_using && support_storage && check_strictness && if_has_keys;\n+    }\n+\n+    void checkTypesOfKeys(const Block & /*left_block*/) const override\n+    {\n+        if (!isSupported(table_join))\n+            throw DB::Exception(ErrorCodes::NOT_IMPLEMENTED, \"PasteJoin doesn't support specified query\");\n+    }\n+\n+    /// Used just to get result header\n+    void joinBlock(Block & block, std::shared_ptr<ExtraBlock> & /* not_processed */) override\n+    {\n+        for (const auto & col : right_sample_block)\n+            block.insert(col);\n+        block = materializeBlock(block).cloneEmpty();\n+    }\n+\n+    void setTotals(const Block & block) override { totals = block; }\n+    const Block & getTotals() const override { return totals; }\n+\n+    size_t getTotalRowCount() const override\n+    {\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"PasteJoin::getTotalRowCount should not be called\");\n+    }\n+\n+    size_t getTotalByteCount() const override\n+    {\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"PasteJoin::getTotalByteCount should not be called\");\n+    }\n+\n+    bool alwaysReturnsEmptySet() const override { return false; }\n+\n+    IBlocksStreamPtr\n+    getNonJoinedBlocks(const Block & /* left_sample_block */, const Block & /* result_sample_block */, UInt64 /* max_block_size */) const override\n+    {\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"PasteJoin::getNonJoinedBlocks should not be called\");\n+    }\n+\n+    /// Left and right streams have the same priority and are processed simultaneously\n+    JoinPipelineType pipelineType() const override { return JoinPipelineType::YShaped; }\n+\n+private:\n+    std::shared_ptr<TableJoin> table_join;\n+    Block right_sample_block;\n+    Block totals;\n+};\n+\n+}\ndiff --git a/src/Parsers/ASTTablesInSelectQuery.cpp b/src/Parsers/ASTTablesInSelectQuery.cpp\nindex e4e8c00879ee..8ca2ee0efae0 100644\n--- a/src/Parsers/ASTTablesInSelectQuery.cpp\n+++ b/src/Parsers/ASTTablesInSelectQuery.cpp\n@@ -211,6 +211,9 @@ void ASTTableJoin::formatImplBeforeTable(const FormatSettings & settings, Format\n         case JoinKind::Comma:\n             settings.ostr << \",\";\n             break;\n+        case JoinKind::Paste:\n+            settings.ostr << \"PASTE JOIN\";\n+            break;\n     }\n \n     settings.ostr << (settings.hilite ? hilite_none : \"\");\ndiff --git a/src/Parsers/ParserTablesInSelectQuery.cpp b/src/Parsers/ParserTablesInSelectQuery.cpp\nindex b3ae6ca0bb91..ca209739dada 100644\n--- a/src/Parsers/ParserTablesInSelectQuery.cpp\n+++ b/src/Parsers/ParserTablesInSelectQuery.cpp\n@@ -6,6 +6,7 @@\n #include <Parsers/ParserSelectQuery.h>\n #include <Parsers/ParserSampleRatio.h>\n #include <Parsers/ParserTablesInSelectQuery.h>\n+#include <Core/Joins.h>\n \n \n namespace DB\n@@ -166,6 +167,8 @@ bool ParserTablesInSelectQueryElement::parseImpl(Pos & pos, ASTPtr & node, Expec\n                 table_join->kind = JoinKind::Full;\n             else if (ParserKeyword(\"CROSS\").ignore(pos))\n                 table_join->kind = JoinKind::Cross;\n+            else if (ParserKeyword(\"PASTE\").ignore(pos))\n+                table_join->kind = JoinKind::Paste;\n             else\n                 no_kind = true;\n \n@@ -191,8 +194,8 @@ bool ParserTablesInSelectQueryElement::parseImpl(Pos & pos, ASTPtr & node, Expec\n             }\n \n             if (table_join->strictness != JoinStrictness::Unspecified\n-                && table_join->kind == JoinKind::Cross)\n-                throw Exception(ErrorCodes::SYNTAX_ERROR, \"You must not specify ANY or ALL for CROSS JOIN.\");\n+                && (table_join->kind == JoinKind::Cross || table_join->kind == JoinKind::Paste))\n+                throw Exception(ErrorCodes::SYNTAX_ERROR, \"You must not specify ANY or ALL for {} JOIN.\", toString(table_join->kind));\n \n             if ((table_join->strictness == JoinStrictness::Semi || table_join->strictness == JoinStrictness::Anti) &&\n                 (table_join->kind != JoinKind::Left && table_join->kind != JoinKind::Right))\n@@ -206,7 +209,7 @@ bool ParserTablesInSelectQueryElement::parseImpl(Pos & pos, ASTPtr & node, Expec\n             return false;\n \n         if (table_join->kind != JoinKind::Comma\n-            && table_join->kind != JoinKind::Cross)\n+            && table_join->kind != JoinKind::Cross && table_join->kind != JoinKind::Paste)\n         {\n             if (ParserKeyword(\"USING\").ignore(pos, expected))\n             {\ndiff --git a/src/Planner/PlannerJoinTree.cpp b/src/Planner/PlannerJoinTree.cpp\nindex abcf971b8320..25a23052153c 100644\n--- a/src/Planner/PlannerJoinTree.cpp\n+++ b/src/Planner/PlannerJoinTree.cpp\n@@ -1312,7 +1312,7 @@ JoinTreeQueryPlan buildQueryPlanForJoinNode(const QueryTreeNodePtr & join_table_\n             return step_raw_ptr;\n         };\n \n-        if (join_algorithm->pipelineType() == JoinPipelineType::YShaped)\n+        if (join_algorithm->pipelineType() == JoinPipelineType::YShaped && join_kind != JoinKind::Paste)\n         {\n             const auto & join_clause = table_join->getOnlyClause();\n \ndiff --git a/src/Planner/PlannerJoins.cpp b/src/Planner/PlannerJoins.cpp\nindex 5fda2a8617d1..5e9de4dedcf6 100644\n--- a/src/Planner/PlannerJoins.cpp\n+++ b/src/Planner/PlannerJoins.cpp\n@@ -35,6 +35,7 @@\n #include <Interpreters/JoinSwitcher.h>\n #include <Interpreters/ArrayJoinAction.h>\n #include <Interpreters/GraceHashJoin.h>\n+#include <Interpreters/PasteJoin.h>\n \n #include <Planner/PlannerActionsVisitor.h>\n #include <Planner/PlannerContext.h>\n@@ -653,6 +654,8 @@ static std::shared_ptr<IJoin> tryCreateJoin(JoinAlgorithm algorithm,\n     const Block & right_table_expression_header,\n     const PlannerContextPtr & planner_context)\n {\n+    if (table_join->kind() == JoinKind::Paste)\n+        return std::make_shared<PasteJoin>(table_join, right_table_expression_header);\n     /// Direct JOIN with special storages that support key value access. For example JOIN with Dictionary\n     if (algorithm == JoinAlgorithm::DIRECT || algorithm == JoinAlgorithm::DEFAULT)\n     {\ndiff --git a/src/Processors/Transforms/PasteJoinTransform.cpp b/src/Processors/Transforms/PasteJoinTransform.cpp\nnew file mode 100644\nindex 000000000000..ff3e2fb85e55\n--- /dev/null\n+++ b/src/Processors/Transforms/PasteJoinTransform.cpp\n@@ -0,0 +1,127 @@\n+#include <cassert>\n+#include <cstddef>\n+#include <limits>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <base/defines.h>\n+#include <base/types.h>\n+\n+#include <Common/logger_useful.h>\n+#include <Columns/ColumnNullable.h>\n+#include <Columns/ColumnsNumber.h>\n+#include <Columns/IColumn.h>\n+#include <IO/WriteHelpers.h>\n+#include <Interpreters/TableJoin.h>\n+#include <Parsers/ASTTablesInSelectQuery.h>\n+#include <Processors/Transforms/PasteJoinTransform.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int LOGICAL_ERROR;\n+    extern const int NOT_IMPLEMENTED;\n+}\n+\n+\n+PasteJoinAlgorithm::PasteJoinAlgorithm(\n+    JoinPtr table_join_,\n+    const Blocks & input_headers,\n+    size_t max_block_size_)\n+    : table_join(table_join_)\n+    , max_block_size(max_block_size_)\n+    , log(&Poco::Logger::get(\"PasteJoinAlgorithm\"))\n+{\n+    if (input_headers.size() != 2)\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"PasteJoinAlgorithm requires exactly two inputs\");\n+\n+    auto strictness = table_join->getTableJoin().strictness();\n+    if (strictness != JoinStrictness::Any && strictness != JoinStrictness::All)\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"PasteJoinAlgorithm is not implemented for strictness {}\", strictness);\n+\n+    auto kind = table_join->getTableJoin().kind();\n+    if (!isPaste(kind))\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"PasteJoinAlgorithm is not implemented for kind {}\", kind);\n+}\n+\n+static void prepareChunk(Chunk & chunk)\n+{\n+    if (!chunk)\n+        return;\n+\n+    auto num_rows = chunk.getNumRows();\n+    auto columns = chunk.detachColumns();\n+\n+    chunk.setColumns(std::move(columns), num_rows);\n+}\n+\n+void PasteJoinAlgorithm::initialize(Inputs inputs)\n+{\n+    if (inputs.size() != 2)\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Two inputs are required, got {}\", inputs.size());\n+\n+    for (size_t i = 0; i < inputs.size(); ++i)\n+    {\n+        consume(inputs[i], i);\n+    }\n+}\n+\n+void PasteJoinAlgorithm::consume(Input & input, size_t source_num)\n+{\n+    if (input.skip_last_row)\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"skip_last_row is not supported\");\n+\n+    if (input.permutation)\n+        throw DB::Exception(ErrorCodes::NOT_IMPLEMENTED, \"permutation is not supported\");\n+\n+    last_used_row[source_num] = 0;\n+\n+    prepareChunk(input.chunk);\n+    chunks[source_num] = std::move(input.chunk);\n+}\n+\n+IMergingAlgorithm::Status PasteJoinAlgorithm::merge()\n+{\n+    if (chunks[0].empty() || chunks[1].empty())\n+        return Status({}, true);\n+    if (last_used_row[0] >= chunks[0].getNumRows())\n+        return Status(0);\n+    if (last_used_row[1] >= chunks[1].getNumRows())\n+        return Status(1);\n+    /// We have unused rows from both inputs\n+    size_t result_num_rows = std::min(chunks[0].getNumRows() - last_used_row[0], chunks[1].getNumRows() - last_used_row[1]);\n+\n+    Chunk result;\n+    for (size_t source_num = 0; source_num < 2; ++source_num)\n+        for (const auto & col : chunks[source_num].getColumns())\n+            result.addColumn(col->cut(last_used_row[source_num], result_num_rows));\n+    last_used_row[0] += result_num_rows;\n+    last_used_row[1] += result_num_rows;\n+    return Status(std::move(result));\n+}\n+\n+PasteJoinTransform::PasteJoinTransform(\n+        JoinPtr table_join,\n+        const Blocks & input_headers,\n+        const Block & output_header,\n+        size_t max_block_size,\n+        UInt64 limit_hint_)\n+    : IMergingTransform<PasteJoinAlgorithm>(\n+        input_headers,\n+        output_header,\n+        /* have_all_inputs_= */ true,\n+        limit_hint_,\n+        /* always_read_till_end_= */ false,\n+        /* empty_chunk_on_finish_= */ true,\n+        table_join, input_headers, max_block_size)\n+    , log(&Poco::Logger::get(\"PasteJoinTransform\"))\n+{\n+    LOG_TRACE(log, \"Use PasteJoinTransform\");\n+}\n+\n+void PasteJoinTransform::onFinish() {};\n+\n+}\ndiff --git a/src/Processors/Transforms/PasteJoinTransform.h b/src/Processors/Transforms/PasteJoinTransform.h\nnew file mode 100644\nindex 000000000000..7ecf70e18dc2\n--- /dev/null\n+++ b/src/Processors/Transforms/PasteJoinTransform.h\n@@ -0,0 +1,88 @@\n+#pragma once\n+#include <cassert>\n+#include <cstddef>\n+#include <memory>\n+#include <mutex>\n+#include <utility>\n+\n+#include <boost/core/noncopyable.hpp>\n+\n+#include <Common/PODArray.h>\n+#include <IO/ReadBuffer.h>\n+#include <Parsers/ASTTablesInSelectQuery.h>\n+#include <Processors/Chunk.h>\n+#include <Processors/Merges/Algorithms/IMergingAlgorithm.h>\n+#include <Processors/Merges/IMergingTransform.h>\n+\n+namespace Poco { class Logger; }\n+\n+namespace DB\n+{\n+\n+class IJoin;\n+using JoinPtr = std::shared_ptr<IJoin>;\n+\n+/*\n+ * This class is used to join chunks from two sorted streams.\n+ * It is used in MergeJoinTransform.\n+ */\n+class PasteJoinAlgorithm final : public IMergingAlgorithm\n+{\n+public:\n+    explicit PasteJoinAlgorithm(JoinPtr table_join, const Blocks & input_headers, size_t max_block_size_);\n+\n+    const char * getName() const override { return \"PasteJoinAlgorithm\"; }\n+    virtual void initialize(Inputs inputs) override;\n+    virtual void consume(Input & input, size_t source_num) override;\n+    virtual Status merge() override;\n+\n+    void logElapsed(double seconds);\n+\n+private:\n+    Chunk createBlockWithDefaults(size_t source_num);\n+    Chunk createBlockWithDefaults(size_t source_num, size_t start, size_t num_rows) const;\n+\n+    /// For `USING` join key columns should have values from right side instead of defaults\n+    std::unordered_map<size_t, size_t> left_to_right_key_remap;\n+\n+    std::array<Chunk, 2> chunks;\n+\n+    JoinPtr table_join;\n+\n+    size_t max_block_size;\n+\n+    struct Statistic\n+    {\n+        size_t num_blocks[2] = {0, 0};\n+        size_t num_rows[2] = {0, 0};\n+\n+        size_t max_blocks_loaded = 0;\n+    };\n+\n+    Statistic stat;\n+\n+    Poco::Logger * log;\n+    UInt64 last_used_row[2] = {0, 0};\n+};\n+\n+class PasteJoinTransform final : public IMergingTransform<PasteJoinAlgorithm>\n+{\n+    using Base = IMergingTransform<PasteJoinAlgorithm>;\n+\n+public:\n+    PasteJoinTransform(\n+        JoinPtr table_join,\n+        const Blocks & input_headers,\n+        const Block & output_header,\n+        size_t max_block_size,\n+        UInt64 limit_hint = 0);\n+\n+    String getName() const override { return \"PasteJoinTransform\"; }\n+\n+protected:\n+    void onFinish() override;\n+\n+    Poco::Logger * log;\n+};\n+\n+}\ndiff --git a/src/QueryPipeline/QueryPipelineBuilder.cpp b/src/QueryPipeline/QueryPipelineBuilder.cpp\nindex 21eb07a5acd1..a0fabe3273c3 100644\n--- a/src/QueryPipeline/QueryPipelineBuilder.cpp\n+++ b/src/QueryPipeline/QueryPipelineBuilder.cpp\n@@ -25,6 +25,7 @@\n #include <Processors/Transforms/ExtremesTransform.h>\n #include <Processors/Transforms/JoiningTransform.h>\n #include <Processors/Transforms/MergeJoinTransform.h>\n+#include <Processors/Transforms/PasteJoinTransform.h>\n #include <Processors/Transforms/MergingAggregatedMemoryEfficientTransform.h>\n #include <Processors/Transforms/PartialSortingTransform.h>\n #include <Processors/Transforms/TotalsHavingTransform.h>\n@@ -36,6 +37,7 @@ namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n     extern const int NOT_IMPLEMENTED;\n+    extern const int BAD_ARGUMENTS;\n }\n \n void QueryPipelineBuilder::checkInitialized()\n@@ -354,7 +356,9 @@ std::unique_ptr<QueryPipelineBuilder> QueryPipelineBuilder::joinPipelinesYShaped\n \n     left->pipe.dropExtremes();\n     right->pipe.dropExtremes();\n-    if (left->getNumStreams() != 1 || right->getNumStreams() != 1)\n+    if ((left->getNumStreams() != 1 || right->getNumStreams() != 1) && join->getTableJoin().kind() == JoinKind::Paste)\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Paste JOIN requires sorted tables only\");\n+    else if (left->getNumStreams() != 1 || right->getNumStreams() != 1)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Join is supported only for pipelines with one output port\");\n \n     if (left->hasTotals() || right->hasTotals())\n@@ -362,9 +366,16 @@ std::unique_ptr<QueryPipelineBuilder> QueryPipelineBuilder::joinPipelinesYShaped\n \n     Blocks inputs = {left->getHeader(), right->getHeader()};\n \n-    auto joining = std::make_shared<MergeJoinTransform>(join, inputs, out_header, max_block_size);\n-\n-    return mergePipelines(std::move(left), std::move(right), std::move(joining), collected_processors);\n+    if (join->getTableJoin().kind() == JoinKind::Paste)\n+    {\n+        auto joining = std::make_shared<PasteJoinTransform>(join, inputs, out_header, max_block_size);\n+        return mergePipelines(std::move(left), std::move(right), std::move(joining), collected_processors);\n+    }\n+    else\n+    {\n+        auto joining = std::make_shared<MergeJoinTransform>(join, inputs, out_header, max_block_size);\n+        return mergePipelines(std::move(left), std::move(right), std::move(joining), collected_processors);\n+    }\n }\n \n std::unique_ptr<QueryPipelineBuilder> QueryPipelineBuilder::joinPipelinesRightLeft(\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02933_paste_join.reference b/tests/queries/0_stateless/02933_paste_join.reference\nnew file mode 100644\nindex 000000000000..84ae5987926a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02933_paste_join.reference\n@@ -0,0 +1,74 @@\n+0\t0\n+1\t1\n+2\t2\n+3\t3\n+4\t4\n+5\t5\n+6\t6\n+7\t7\n+8\t8\n+9\t9\n+0\t9\n+1\t8\n+2\t7\n+3\t6\n+4\t5\n+5\t4\n+6\t3\n+7\t2\n+8\t1\n+9\t0\n+1\t2\n+0\t0\n+1\t1\n+2\t2\n+3\t3\n+4\t4\n+5\t5\n+6\t0\n+7\t1\n+8\t2\n+9\t3\n+10\t4\n+0\t0\n+1\t1\n+0\t0\t0\t0\n+1\t1\t1\t1\n+2\t2\t2\t2\n+3\t3\t3\t3\n+4\t4\t4\t4\n+5\t5\t5\t5\n+6\t6\t6\t6\n+7\t7\t7\t7\n+8\t8\t8\t8\n+9\t9\t9\t9\n+10\t10\t10\t10\n+11\t11\t11\t11\n+12\t12\t12\t12\n+13\t13\t13\t13\n+14\t14\t14\t14\n+15\t15\t15\t15\n+16\t16\t16\t16\n+17\t17\t17\t17\n+18\t18\t18\t18\n+19\t19\t19\t19\n+20\t20\t20\t20\n+21\t21\t21\t21\n+22\t22\t22\t22\n+23\t23\t23\t23\n+24\t24\t24\t24\n+25\t25\t25\t25\n+26\t26\t26\t26\n+27\t27\t27\t27\n+28\t28\t28\t28\n+29\t29\t29\t29\n+UInt64\n+UInt64\n+UInt64\n+UInt64\n+UInt64\n+UInt64\n+UInt64\n+UInt64\n+UInt64\n+UInt64\ndiff --git a/tests/queries/0_stateless/02933_paste_join.sql b/tests/queries/0_stateless/02933_paste_join.sql\nnew file mode 100644\nindex 000000000000..1c346438d778\n--- /dev/null\n+++ b/tests/queries/0_stateless/02933_paste_join.sql\n@@ -0,0 +1,37 @@\n+select * from (SELECT number as a FROM numbers(10)) t1 PASTE JOIN (select number as a from numbers(10)) t2;\n+select * from (SELECT number as a FROM numbers(10)) t1 PASTE JOIN (select number as a from numbers(10) order by a desc) t2;\n+create table if not exists test (num UInt64) engine=Memory;\n+insert into test select number from numbers(6);\n+insert into test select number from numbers(5);\n+SELECT * FROM (SELECT 1) t1 PASTE JOIN (SELECT 2) SETTINGS joined_subquery_requires_alias=0;\n+select * from (SELECT number as a FROM numbers(11)) t1 PASTE JOIN test t2 SETTINGS max_threads=1;\n+select * from (SELECT number as a FROM numbers(11)) t1 PASTE JOIN (select * from test limit 2) t2 SETTINGs max_threads=1;\n+CREATE TABLE t1 (a UInt64, b UInt64) ENGINE = Memory;\n+INSERT INTO t1 SELECT number, number FROM numbers(0, 3);\n+INSERT INTO t1 SELECT number, number FROM numbers(3, 2);\n+INSERT INTO t1 SELECT number, number FROM numbers(5, 7);\n+INSERT INTO t1 SELECT number, number FROM numbers(12, 2);\n+INSERT INTO t1 SELECT number, number FROM numbers(14, 1);\n+INSERT INTO t1 SELECT number, number FROM numbers(15, 2);\n+INSERT INTO t1 SELECT number, number FROM numbers(17, 1);\n+INSERT INTO t1 SELECT number, number FROM numbers(18, 2);\n+INSERT INTO t1 SELECT number, number FROM numbers(20, 2);\n+INSERT INTO t1 SELECT number, number FROM numbers(22, 2);\n+INSERT INTO t1 SELECT number, number FROM numbers(24, 2);\n+INSERT INTO t1 SELECT number, number FROM numbers(26, 2);\n+INSERT INTO t1 SELECT number, number FROM numbers(28, 2);\n+\n+\n+CREATE TABLE t2 (a UInt64, b UInt64) ENGINE = Memory;\n+INSERT INTO t2 SELECT number, number FROM numbers(0, 2);\n+INSERT INTO t2 SELECT number, number FROM numbers(2, 3);\n+INSERT INTO t2 SELECT number, number FROM numbers(5, 5);\n+INSERT INTO t2 SELECT number, number FROM numbers(10, 5);\n+INSERT INTO t2 SELECT number, number FROM numbers(15, 15);\n+\n+SELECT * FROM ( SELECT * from t1 ) t1 PASTE JOIN ( SELECT * from t2 ) t2 SETTINGS max_threads = 1;\n+SELECT toTypeName(a) FROM (SELECT number as a FROM numbers(11)) t1 PASTE JOIN (select number as a from numbers(10)) t2 SETTINGS join_use_nulls = 1;\n+SET max_threads = 2;\n+select * from (SELECT number as a FROM numbers(10)) t1 ANY PASTE JOIN (select number as a from numbers(10)) t2; -- { clientError SYNTAX_ERROR }\n+select * from (SELECT number as a FROM numbers(10)) t1 ALL PASTE JOIN (select number as a from numbers(10)) t2; -- { clientError SYNTAX_ERROR }\n+select * from (SELECT number as a FROM numbers_mt(10)) t1 PASTE JOIN (select number as a from numbers(10) ORDER BY a DESC) t2 SETTINGS max_block_size=3; -- { serverError BAD_ARGUMENTS }\n",
  "problem_statement": "Unordered \"Paste\" joins for tables\n**Use case**\r\n\r\nWe have two ordered select results:\r\n```\r\nSELECT number * 2 FROM numbers(1000000)\r\nSELECT number * 4 FROM numbers(1000000)\r\n```\r\n\r\nWe need to divide the results of these requests in the order we already have: 1-st row divide by 1-st row, 2-nd / 2-nd, etc.\r\nEvery result would be 0.5 in this case :) .\r\nFor this case it's possible through left join\r\n```\r\nSELECT n1.n / n2.n\r\nFROM      (SELECT number as id, number * 2 as n FROM numbers(1000000)) as n1\r\nLEFT JOIN (SELECT number as id, number * 4 as n FROM numbers(1000000)) as n2 \r\nON n1.id == n2.id\r\n```\r\nbut this solution seems heavy to compute because of unneeded `ON` clause. \r\n\r\n**Describe the solution you'd like**\r\n\r\nAfter discussing this feature with @alexey-milovidov we decided that it would be nice to have something like `PASTE` join with no `ON` part joining rows in the order they appear.\r\n```\r\nSELECT n1.n / n2.n\r\nFROM       (SELECT number as id, number * 2 as n FROM numbers(1000000)) as n1\r\nPASTE JOIN (SELECT number as id, number * 4 as n FROM numbers(1000000)) as n2 \r\n```\r\n\n",
  "hints_text": "it's exactly the same as pure merge join with `ON n1.id == n2.id`\r\nand you need to sort the left table (both tables, but the left usually is bigger) because CH select yields rows in a random order.\nCloser explanation.\r\n\r\n# Example I\r\nLet's create two tables:\r\n```\r\nCREATE TABLE e1 (\r\n\tid Int32,\r\n\tval Float64\r\n) engine = MergeTree() ORDER BY id;\r\n\r\nCREATE TABLE e2 (\r\n\tid Int32,\r\n\tval Float64\r\n) engine = MergeTree() ORDER BY id;\r\n\r\nINSERT INTO e1 (id, val) SELECT number, rand() / pow(2, 32) FROM numbers(10000000)\r\nINSERT INTO e2 (id, val) SELECT number, rand() / pow(2, 32) FROM numbers(10000000)\r\n\r\nSELECT e1.val / e2.val FROM e1 LEFT ANY JOIN e2 ON e1.id == e2.id \r\n...\r\n10000000 rows in set. Elapsed: 1.058 sec. Processed 20.00 million rows, 240.00 MB (18.90 million rows/s., 226.78 MB/s.)\r\n```\r\n# Example II\r\n```\r\nCREATE TABLE e3 (\r\n\tid Int32,\r\n\tval Float64,\r\n\tval2 Float64\r\n) engine = MergeTree() ORDER BY id;\r\n\r\nINSERT INTO e3 (id, val, val2) SELECT number, rand() / pow(2, 32), rand() / pow(2, 32) FROM numbers(10000000)\r\n\r\nSELECT e3.val / e3.val2 FROM e3\r\n...\r\n10000000 rows in set. Elapsed: 0.075 sec. Processed 10.00 million rows, 160.00 MB (133.54 million rows/s., 2.14 GB/s.)\r\n```\r\n\r\nCan be there an unordered join operation like: \r\n```\r\nSELECT e1.val / e2.val \r\nFROM (SELECT * FROM e1 ORDER BY id) as e1 \r\nPASTE JOIN (SELECT * FROM e2 ORDER BY id) as e2\r\n```\r\nWorking somehow around 0.1 - 0.2s in this case? \r\n",
  "created_at": "2023-12-18T15:12:29Z"
}