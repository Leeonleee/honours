diff --git a/src/Interpreters/QueryAliasesVisitor.cpp b/src/Interpreters/QueryAliasesVisitor.cpp
index d395bfc20e92..bd0b2e88d2f8 100644
--- a/src/Interpreters/QueryAliasesVisitor.cpp
+++ b/src/Interpreters/QueryAliasesVisitor.cpp
@@ -15,15 +15,22 @@ namespace ErrorCodes
     extern const int MULTIPLE_EXPRESSIONS_FOR_ALIAS;
 }
 
-static String wrongAliasMessage(const ASTPtr & ast, const ASTPtr & prev_ast, const String & alias)
+namespace
 {
-    WriteBufferFromOwnString message;
-    message << "Different expressions with the same alias " << backQuoteIfNeed(alias) << ":
";
-    formatAST(*ast, message, false, true);
-    message << "
and
";
-    formatAST(*prev_ast, message, false, true);
-    message << '
';
-    return message.str();
+
+    constexpr auto dummy_subquery_name_prefix = "_subquery";
+
+    String wrongAliasMessage(const ASTPtr & ast, const ASTPtr & prev_ast, const String & alias)
+    {
+        WriteBufferFromOwnString message;
+        message << "Different expressions with the same alias " << backQuoteIfNeed(alias) << ":
";
+        formatAST(*ast, message, false, true);
+        message << "
and
";
+        formatAST(*prev_ast, message, false, true);
+        message << '
';
+        return message.str();
+    }
+
 }
 
 
@@ -99,7 +106,7 @@ void QueryAliasesMatcher<T>::visit(const ASTSubquery & const_subquery, const AST
         String alias;
         do
         {
-            alias = "_subquery" + std::to_string(++subquery_index);
+            alias = dummy_subquery_name_prefix + std::to_string(++subquery_index);
         }
         while (aliases.count(alias));
 
@@ -124,6 +131,30 @@ void QueryAliasesMatcher<T>::visitOther(const ASTPtr & ast, Data & data)
 
         aliases[alias] = ast;
     }
+
+    /** QueryAliasesVisitor is executed before ExecuteScalarSubqueriesVisitor.
+        For example we have subquery in our query (SELECT sum(number) FROM numbers(10)).
+
+        After running QueryAliasesVisitor it will be (SELECT sum(number) FROM numbers(10)) as _subquery_1
+        and prefer_alias_to_column_name for this subquery will be true.
+
+        After running ExecuteScalarSubqueriesVisitor it will be converted to (45 as _subquery_1)
+        and prefer_alias_to_column_name for ast literal will be true.
+
+        But if we send such query on remote host with Distributed engine for example we cannot send prefer_alias_to_column_name
+        information for our ast node with query string. And this alias will be dropped because prefer_alias_to_column_name for ASTWIthAlias
+        by default is false.
+
+        It is imporant that subquery can be converted to literal during ExecuteScalarSubqueriesVisitor.
+        And code below check if we previously set for subquery alias as _subquery, and if it is true
+        then set prefer_alias_to_column_name = true for node that was optimized during ExecuteScalarSubqueriesVisitor.
+     */
+
+    if (auto * ast_with_alias = dynamic_cast<ASTWithAlias *>(ast.get()))
+    {
+        if (startsWith(alias, dummy_subquery_name_prefix))
+            ast_with_alias->prefer_alias_to_column_name = true;
+    }
 }
 
 /// Explicit template instantiations
