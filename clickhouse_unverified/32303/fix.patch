diff --git a/src/AggregateFunctions/AggregateFunctionAvg.h b/src/AggregateFunctions/AggregateFunctionAvg.h
index e2a9220f113b..8ca0ae1dac22 100644
--- a/src/AggregateFunctions/AggregateFunctionAvg.h
+++ b/src/AggregateFunctions/AggregateFunctionAvg.h
@@ -20,6 +20,7 @@
 
 namespace DB
 {
+
 struct Settings;
 
 template <typename T> constexpr bool DecimalOrExtendedInt =
@@ -42,39 +43,19 @@ struct AvgFraction
     /// Invoked only is either Numerator or Denominator are Decimal.
     Float64 NO_SANITIZE_UNDEFINED divideIfAnyDecimal(UInt32 num_scale, UInt32 denom_scale [[maybe_unused]]) const
     {
-        if constexpr (is_decimal<Numerator> && is_decimal<Denominator>)
-        {
-            // According to the docs, num(S1) / denom(S2) would have scale S1
-
-            if constexpr (std::is_same_v<Numerator, Decimal256> && std::is_same_v<Denominator, Decimal128>)
-                ///Special case as Decimal256 / Decimal128 = compile error (as Decimal128 is not parametrized by a wide
-                ///int), but an __int128 instead
-                return DecimalUtils::convertTo<Float64>(
-                    numerator / (denominator.template convertTo<Decimal256>()), num_scale);
-            else
-                return DecimalUtils::convertTo<Float64>(numerator / denominator, num_scale);
-        }
-
-        /// Numerator is always casted to Float64 to divide correctly if the denominator is not Float64.
-        Float64 num_converted;
-
+        Float64 numerator_float;
         if constexpr (is_decimal<Numerator>)
-            num_converted = DecimalUtils::convertTo<Float64>(numerator, num_scale);
+            numerator_float = DecimalUtils::convertTo<Float64>(numerator, num_scale);
         else
-            num_converted = static_cast<Float64>(numerator); /// all other types, including extended integral.
-
-        std::conditional_t<DecimalOrExtendedInt<Denominator>,
-            Float64, Denominator> denom_converted;
+            numerator_float = numerator;
 
+        Float64 denominator_float;
         if constexpr (is_decimal<Denominator>)
-            denom_converted = DecimalUtils::convertTo<Float64>(denominator, denom_scale);
-        else if constexpr (DecimalOrExtendedInt<Denominator>)
-            /// no way to divide Float64 and extended integral type without an explicit cast.
-            denom_converted = static_cast<Float64>(denominator);
+            denominator_float = DecimalUtils::convertTo<Float64>(denominator, denom_scale);
         else
-            denom_converted = denominator; /// can divide on float, no cast required.
+            denominator_float = denominator;
 
-        return num_converted / denom_converted;
+        return numerator_float / denominator_float;
     }
 
     Float64 NO_SANITIZE_UNDEFINED divide() const
diff --git a/src/AggregateFunctions/AggregateFunctionAvgWeighted.cpp b/src/AggregateFunctions/AggregateFunctionAvgWeighted.cpp
index b7fdb3460e34..ab6fdc8fd7e8 100644
--- a/src/AggregateFunctions/AggregateFunctionAvgWeighted.cpp
+++ b/src/AggregateFunctions/AggregateFunctionAvgWeighted.cpp
@@ -82,17 +82,17 @@ createAggregateFunctionAvgWeighted(const std::string & name, const DataTypes & a
     const bool left_decimal = isDecimal(data_type);
     const bool right_decimal = isDecimal(data_type_weight);
 
+    /// We multiply value by weight, so actual scale of numerator is <scale of value> + <scale of weight>
     if (left_decimal && right_decimal)
         ptr.reset(create(*data_type, *data_type_weight,
             argument_types,
-            getDecimalScale(*data_type), getDecimalScale(*data_type_weight)));
+            getDecimalScale(*data_type) + getDecimalScale(*data_type_weight), getDecimalScale(*data_type_weight)));
     else if (left_decimal)
         ptr.reset(create(*data_type, *data_type_weight, argument_types,
             getDecimalScale(*data_type)));
     else if (right_decimal)
         ptr.reset(create(*data_type, *data_type_weight, argument_types,
-            // numerator is not decimal, so its scale is 0
-            0, getDecimalScale(*data_type_weight)));
+            getDecimalScale(*data_type_weight), getDecimalScale(*data_type_weight)));
     else
         ptr.reset(create(*data_type, *data_type_weight, argument_types));
 
