{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 5600,
  "instance_id": "ClickHouse__ClickHouse-5600",
  "issue_numbers": [
    "2"
  ],
  "base_commit": "3577f31ef6234c38b621d32a97902bff6ecc532d",
  "patch": "diff --git a/dbms/src/Common/BitHelpers.h b/dbms/src/Common/BitHelpers.h\nindex d776a399ac8e..ba6a4c60a494 100644\n--- a/dbms/src/Common/BitHelpers.h\n+++ b/dbms/src/Common/BitHelpers.h\n@@ -1,6 +1,7 @@\n #pragma once\n \n #include <cstddef>\n+#include <type_traits>\n \n \n /** Returns log2 of number, rounded down.\n@@ -30,3 +31,64 @@ inline size_t roundUpToPowerOfTwoOrZero(size_t n)\n \n     return n;\n }\n+\n+\n+template <typename T>\n+inline size_t getLeadingZeroBits(T x)\n+{\n+    if (!x)\n+        return sizeof(x) * 8;\n+\n+    if constexpr (sizeof(T) <= sizeof(unsigned int))\n+    {\n+        return __builtin_clz(x);\n+    }\n+    else if constexpr (sizeof(T) <= sizeof(unsigned long int))\n+    {\n+        return __builtin_clzl(x);\n+    }\n+    else\n+    {\n+        return __builtin_clzll(x);\n+    }\n+}\n+\n+template <typename T>\n+inline size_t getTrailingZeroBits(T x)\n+{\n+    if (!x)\n+        return sizeof(x) * 8;\n+\n+    if constexpr (sizeof(T) <= sizeof(unsigned int))\n+    {\n+        return __builtin_ctz(x);\n+    }\n+    else if constexpr (sizeof(T) <= sizeof(unsigned long int))\n+    {\n+        return __builtin_ctzl(x);\n+    }\n+    else\n+    {\n+        return __builtin_ctzll(x);\n+    }\n+}\n+\n+/** Returns a mask that has '1' for `bits` LSB set:\n+ * maskLowBits<UInt8>(3) => 00000111\n+ */\n+template <typename T>\n+inline T maskLowBits(unsigned char bits)\n+{\n+    if (bits == 0)\n+    {\n+        return 0;\n+    }\n+\n+    T result = static_cast<T>(~T{0});\n+    if (bits < sizeof(T) * 8)\n+    {\n+        result = static_cast<T>(result >> (sizeof(T) * 8 - bits));\n+    }\n+\n+    return result;\n+}\ndiff --git a/dbms/src/Compression/CompressionCodecDoubleDelta.cpp b/dbms/src/Compression/CompressionCodecDoubleDelta.cpp\nnew file mode 100644\nindex 000000000000..b40b2abccfac\n--- /dev/null\n+++ b/dbms/src/Compression/CompressionCodecDoubleDelta.cpp\n@@ -0,0 +1,325 @@\n+#include <Compression/CompressionCodecDoubleDelta.h>\n+#include <Compression/CompressionInfo.h>\n+#include <Compression/CompressionFactory.h>\n+#include <common/unaligned.h>\n+#include <Parsers/IAST_fwd.h>\n+\n+#include <IO/ReadBufferFromMemory.h>\n+#include <IO/BitHelpers.h>\n+#include <IO/WriteHelpers.h>\n+\n+#include <string.h>\n+#include <algorithm>\n+#include <cstdlib>\n+#include <type_traits>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+extern const int CANNOT_COMPRESS;\n+extern const int CANNOT_DECOMPRESS;\n+}\n+\n+namespace\n+{\n+UInt32 getDeltaTypeByteSize(UInt8 data_bytes_size)\n+{\n+    // both delta and double delta can be twice the size of data item, but not less than 32 bits and not more that 64.\n+    return std::min(64/8, std::max(32/8, data_bytes_size * 2));\n+}\n+\n+UInt32 getCompressedHeaderSize(UInt8 data_bytes_size)\n+{\n+    const UInt8 items_count_size = 4;\n+\n+    return items_count_size + data_bytes_size + getDeltaTypeByteSize(data_bytes_size);\n+}\n+\n+UInt32 getCompressedDataSize(UInt8 data_bytes_size, UInt32 uncompressed_size)\n+{\n+    const UInt32 items_count = uncompressed_size / data_bytes_size;\n+\n+    // 11111 + max 64 bits of double delta.\n+    const UInt32 max_item_size_bits = 5 + getDeltaTypeByteSize(data_bytes_size) * 8;\n+\n+    // + 8 is to round up to next byte.\n+    return (items_count * max_item_size_bits + 8) / 8;\n+}\n+\n+struct WriteSpec\n+{\n+    const UInt8 prefix_bits;\n+    const UInt8 prefix;\n+    const UInt8 data_bits;\n+};\n+\n+template <typename T>\n+WriteSpec getWriteSpec(const T & value)\n+{\n+    if (value > -63 && value < 64)\n+    {\n+        return WriteSpec{2, 0b10, 7};\n+    }\n+    else if (value > -255 && value < 256)\n+    {\n+        return WriteSpec{3, 0b110, 9};\n+    }\n+    else if (value > -2047 && value < 2048)\n+    {\n+        return WriteSpec{4, 0b1110, 12};\n+    }\n+    else if (value > std::numeric_limits<Int32>::min() && value < std::numeric_limits<Int32>::max())\n+    {\n+        return WriteSpec{5, 0b11110, 32};\n+    }\n+    else\n+    {\n+        return WriteSpec{5, 0b11111, 64};\n+    }\n+}\n+\n+template <typename T, typename DeltaType>\n+UInt32 compressDataForType(const char * source, UInt32 source_size, char * dest)\n+{\n+    using UnsignedDeltaType = typename std::make_unsigned<DeltaType>::type;\n+\n+    if (source_size % sizeof(T) != 0)\n+        throw Exception(\"Cannot compress, data size \" + toString(source_size) + \" is not aligned to \" + toString(sizeof(T)), ErrorCodes::CANNOT_COMPRESS);\n+    const char * source_end = source + source_size;\n+\n+    const UInt32 items_count = source_size / sizeof(T);\n+    unalignedStore(dest, items_count);\n+    dest += sizeof(items_count);\n+\n+    T prev_value{};\n+    DeltaType prev_delta{};\n+\n+    if (source < source_end)\n+    {\n+        prev_value = unalignedLoad<T>(source);\n+        unalignedStore(dest, prev_value);\n+\n+        source += sizeof(prev_value);\n+        dest += sizeof(prev_value);\n+    }\n+\n+    if (source < source_end)\n+    {\n+        const T curr_value = unalignedLoad<T>(source);\n+        prev_delta = static_cast<DeltaType>(curr_value - prev_value);\n+        unalignedStore(dest, prev_delta);\n+\n+        source += sizeof(curr_value);\n+        dest += sizeof(prev_delta);\n+        prev_value = curr_value;\n+    }\n+\n+    WriteBuffer buffer(dest, getCompressedDataSize(sizeof(T), source_size - sizeof(T)*2));\n+    BitWriter writer(buffer);\n+\n+    for (; source < source_end; source += sizeof(T))\n+    {\n+        const T curr_value = unalignedLoad<T>(source);\n+\n+        const auto delta = curr_value - prev_value;\n+        const DeltaType double_delta = static_cast<DeltaType>(delta - static_cast<T>(prev_delta));\n+\n+        prev_delta = delta;\n+        prev_value = curr_value;\n+\n+        if (double_delta == 0)\n+        {\n+            writer.writeBits(1, 0);\n+        }\n+        else\n+        {\n+            const auto sign = std::signbit(double_delta);\n+            const auto abs_value = static_cast<UnsignedDeltaType>(std::abs(double_delta));\n+            const auto write_spec = getWriteSpec(double_delta);\n+\n+            writer.writeBits(write_spec.prefix_bits, write_spec.prefix);\n+            writer.writeBits(1, sign);\n+            writer.writeBits(write_spec.data_bits - 1, abs_value);\n+        }\n+    }\n+\n+    writer.flush();\n+\n+    return sizeof(items_count) + sizeof(prev_value) + sizeof(prev_delta) + buffer.count();\n+}\n+\n+template <typename T, typename DeltaType>\n+void decompressDataForType(const char * source, UInt32 source_size, char * dest)\n+{\n+    const char * source_end = source + source_size;\n+\n+    const UInt32 items_count = unalignedLoad<UInt32>(source);\n+    source += sizeof(items_count);\n+\n+    T prev_value{};\n+    DeltaType prev_delta{};\n+\n+    if (source < source_end)\n+    {\n+        prev_value = unalignedLoad<T>(source);\n+        unalignedStore(dest, prev_value);\n+\n+        source += sizeof(prev_value);\n+        dest += sizeof(prev_value);\n+    }\n+\n+    if (source < source_end)\n+    {\n+        prev_delta = unalignedLoad<DeltaType>(source);\n+        prev_value = static_cast<T>(prev_value + prev_delta);\n+        unalignedStore(dest, prev_value);\n+\n+        source += sizeof(prev_delta);\n+        dest += sizeof(prev_value);\n+    }\n+\n+    ReadBufferFromMemory buffer(source, source_size - sizeof(prev_value) - sizeof(prev_delta) - sizeof(items_count));\n+    BitReader reader(buffer);\n+\n+    // since data is tightly packed, up to 1 bit per value, and last byte is padded with zeroes,\n+    // we have to keep track of items to avoid reading more that there is.\n+    for (UInt32 items_read = 2; items_read < items_count && !reader.eof(); ++items_read)\n+    {\n+        DeltaType double_delta = 0;\n+        if (reader.readBit() == 1)\n+        {\n+            const UInt8 data_sizes[] = {6, 8, 11, 31, 63};\n+            UInt8 i = 0;\n+            for (; i < sizeof(data_sizes) - 1; ++i)\n+            {\n+                const auto next_bit = reader.readBit();\n+                if (next_bit == 0)\n+                    break;\n+            }\n+\n+            const UInt8 sign = reader.readBit();\n+            double_delta = static_cast<DeltaType>(reader.readBits(data_sizes[i]));\n+            if (sign)\n+            {\n+                double_delta *= -1;\n+            }\n+        }\n+        // else if first bit is zero, no need to read more data.\n+\n+        const T curr_value = static_cast<T>(prev_value + prev_delta + double_delta);\n+        unalignedStore(dest, curr_value);\n+        dest += sizeof(curr_value);\n+\n+        prev_delta = curr_value - prev_value;\n+        prev_value = curr_value;\n+    }\n+}\n+\n+UInt8 getDataBytesSize(DataTypePtr column_type)\n+{\n+    UInt8 data_bytes_size = 1;\n+    if (column_type && column_type->haveMaximumSizeOfValue())\n+    {\n+        size_t max_size = column_type->getSizeOfValueInMemory();\n+        if (max_size == 1 || max_size == 2 || max_size == 4 || max_size == 8)\n+            data_bytes_size = static_cast<UInt8>(max_size);\n+    }\n+    return data_bytes_size;\n+}\n+\n+}\n+\n+\n+CompressionCodecDoubleDelta::CompressionCodecDoubleDelta(UInt8 data_bytes_size_)\n+    : data_bytes_size(data_bytes_size_)\n+{\n+}\n+\n+UInt8 CompressionCodecDoubleDelta::getMethodByte() const\n+{\n+    return static_cast<UInt8>(CompressionMethodByte::DoubleDelta);\n+}\n+\n+String CompressionCodecDoubleDelta::getCodecDesc() const\n+{\n+    return \"DoubleDelta\";\n+}\n+\n+UInt32 CompressionCodecDoubleDelta::getMaxCompressedDataSize(UInt32 uncompressed_size) const\n+{\n+    const auto result = 2 // common header\n+            + data_bytes_size // max bytes skipped if source is not properly aligned.\n+            + getCompressedHeaderSize(data_bytes_size) // data-specific header\n+            + getCompressedDataSize(data_bytes_size, uncompressed_size);\n+\n+    return result;\n+}\n+\n+UInt32 CompressionCodecDoubleDelta::doCompressData(const char * source, UInt32 source_size, char * dest) const\n+{\n+    UInt8 bytes_to_skip = source_size % data_bytes_size;\n+    dest[0] = data_bytes_size;\n+    dest[1] = bytes_to_skip;\n+    memcpy(&dest[2], source, bytes_to_skip);\n+    size_t start_pos = 2 + bytes_to_skip;\n+    UInt32 compressed_size = 0;\n+    switch (data_bytes_size)\n+    {\n+    case 1:\n+        compressed_size = compressDataForType<UInt8, Int16>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);\n+        break;\n+    case 2:\n+        compressed_size = compressDataForType<UInt16, Int32>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);\n+        break;\n+    case 4:\n+        compressed_size = compressDataForType<UInt32, Int64>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);\n+        break;\n+    case 8:\n+        compressed_size = compressDataForType<UInt64, Int64>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);\n+        break;\n+    }\n+\n+    return 1 + 1 + compressed_size;\n+}\n+\n+void CompressionCodecDoubleDelta::doDecompressData(const char * source, UInt32 source_size, char * dest, UInt32 /* uncompressed_size */) const\n+{\n+    UInt8 bytes_size = source[0];\n+    UInt8 bytes_to_skip = source[1];\n+\n+    memcpy(dest, &source[2], bytes_to_skip);\n+    UInt32 source_size_no_header = source_size - bytes_to_skip - 2;\n+    switch (bytes_size)\n+    {\n+    case 1:\n+        decompressDataForType<UInt8, Int16>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip]);\n+        break;\n+    case 2:\n+        decompressDataForType<UInt16, Int32>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip]);\n+        break;\n+    case 4:\n+        decompressDataForType<UInt32, Int64>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip]);\n+        break;\n+    case 8:\n+        decompressDataForType<UInt64, Int64>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip]);\n+        break;\n+    }\n+}\n+\n+void CompressionCodecDoubleDelta::useInfoAboutType(DataTypePtr data_type)\n+{\n+    data_bytes_size = getDataBytesSize(data_type);\n+}\n+\n+void registerCodecDoubleDelta(CompressionCodecFactory & factory)\n+{\n+    UInt8 method_code = UInt8(CompressionMethodByte::DoubleDelta);\n+    factory.registerCompressionCodecWithType(\"DoubleDelta\", method_code, [&](const ASTPtr &, DataTypePtr column_type) -> CompressionCodecPtr\n+    {\n+        UInt8 delta_bytes_size = getDataBytesSize(column_type);\n+        return std::make_shared<CompressionCodecDoubleDelta>(delta_bytes_size);\n+    });\n+}\n+}\ndiff --git a/dbms/src/Compression/CompressionCodecDoubleDelta.h b/dbms/src/Compression/CompressionCodecDoubleDelta.h\nnew file mode 100644\nindex 000000000000..19c072141155\n--- /dev/null\n+++ b/dbms/src/Compression/CompressionCodecDoubleDelta.h\n@@ -0,0 +1,30 @@\n+#pragma once\n+\n+#include <Compression/ICompressionCodec.h>\n+\n+namespace DB\n+{\n+\n+class CompressionCodecDoubleDelta : public ICompressionCodec\n+{\n+public:\n+    CompressionCodecDoubleDelta(UInt8 data_bytes_size_);\n+\n+    UInt8 getMethodByte() const override;\n+\n+    String getCodecDesc() const override;\n+\n+    void useInfoAboutType(DataTypePtr data_type) override;\n+\n+protected:\n+    UInt32 doCompressData(const char * source, UInt32 source_size, char * dest) const override;\n+\n+    void doDecompressData(const char * source, UInt32 source_size, char * dest, UInt32 uncompressed_size) const override;\n+\n+    UInt32 getMaxCompressedDataSize(UInt32 uncompressed_size) const override;\n+\n+private:\n+    UInt8 data_bytes_size;\n+};\n+\n+}\ndiff --git a/dbms/src/Compression/CompressionCodecGorilla.cpp b/dbms/src/Compression/CompressionCodecGorilla.cpp\nnew file mode 100644\nindex 000000000000..f9c6b52756c2\n--- /dev/null\n+++ b/dbms/src/Compression/CompressionCodecGorilla.cpp\n@@ -0,0 +1,326 @@\n+#include <Compression/CompressionCodecGorilla.h>\n+#include <Compression/CompressionInfo.h>\n+#include <Compression/CompressionFactory.h>\n+#include <common/unaligned.h>\n+#include <Parsers/IAST_fwd.h>\n+#include <IO/WriteHelpers.h>\n+#include <IO/ReadBufferFromMemory.h>\n+#include <IO/BitHelpers.h>\n+\n+#include <string.h>\n+#include <algorithm>\n+#include <cstdlib>\n+#include <type_traits>\n+\n+#include <bitset>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+extern const int CANNOT_COMPRESS;\n+extern const int CANNOT_DECOMPRESS;\n+extern const int ILLEGAL_SYNTAX_FOR_CODEC_TYPE;\n+extern const int ILLEGAL_CODEC_PARAMETER;\n+}\n+\n+namespace\n+{\n+\n+constexpr inline UInt8 getBitLengthOfLength(UInt8 data_bytes_size)\n+{\n+    // 1-byte value is 8 bits, and we need 4 bits to represent 8 : 1000,\n+    // 2-byte         16 bits        =>    5\n+    // 4-byte         32 bits        =>    6\n+    // 8-byte         64 bits        =>    7\n+    const UInt8 bit_lengths[] = {0, 4, 5, 0, 6, 0, 0, 0, 7};\n+    assert(data_bytes_size >= 1 && data_bytes_size < sizeof(bit_lengths) && bit_lengths[data_bytes_size] != 0);\n+\n+    return bit_lengths[data_bytes_size];\n+}\n+\n+\n+UInt32 getCompressedHeaderSize(UInt8 data_bytes_size)\n+{\n+    const UInt8 items_count_size = 4;\n+\n+    return items_count_size + data_bytes_size;\n+}\n+\n+UInt32 getCompressedDataSize(UInt8 data_bytes_size, UInt32 uncompressed_size)\n+{\n+    const UInt32 items_count = uncompressed_size / data_bytes_size;\n+    static const auto DATA_BIT_LENGTH = getBitLengthOfLength(data_bytes_size);\n+    // -1 since there must be at least 1 non-zero bit.\n+    static const auto LEADING_ZEROES_BIT_LENGTH = DATA_BIT_LENGTH - 1;\n+\n+    // worst case (for 32-bit value):\n+    // 11 + 5 bits of leading zeroes bit-size + 5 bits of data bit-size + non-zero data bits.\n+    const UInt32 max_item_size_bits = 2 + LEADING_ZEROES_BIT_LENGTH + DATA_BIT_LENGTH + data_bytes_size * 8;\n+\n+    // + 8 is to round up to next byte.\n+    return (items_count * max_item_size_bits + 8) / 8;\n+}\n+\n+struct binary_value_info\n+{\n+    UInt8 leading_zero_bits;\n+    UInt8 data_bits;\n+    UInt8 trailing_zero_bits;\n+};\n+\n+template <typename T>\n+binary_value_info getLeadingAndTrailingBits(const T & value)\n+{\n+    constexpr UInt8 bit_size = sizeof(T) * 8;\n+\n+    const UInt8 lz = getLeadingZeroBits(value);\n+    const UInt8 tz = getTrailingZeroBits(value);\n+    const UInt8 data_size = value == 0 ? 0 : static_cast<UInt8>(bit_size - lz - tz);\n+    return binary_value_info{lz, data_size, tz};\n+}\n+\n+template <typename T>\n+UInt32 compressDataForType(const char * source, UInt32 source_size, char * dest)\n+{\n+    static const auto DATA_BIT_LENGTH = getBitLengthOfLength(sizeof(T));\n+    // -1 since there must be at least 1 non-zero bit.\n+    static const auto LEADING_ZEROES_BIT_LENGTH = DATA_BIT_LENGTH - 1;\n+\n+    if (source_size % sizeof(T) != 0)\n+        throw Exception(\"Cannot compress, data size \" + toString(source_size) + \" is not aligned to \" + toString(sizeof(T)), ErrorCodes::CANNOT_COMPRESS);\n+    const char * source_end = source + source_size;\n+\n+    const UInt32 items_count = source_size / sizeof(T);\n+\n+    unalignedStore(dest, items_count);\n+    dest += sizeof(items_count);\n+\n+    T prev_value{};\n+    // That would cause first XORed value to be written in-full.\n+    binary_value_info prev_xored_info{0, 0, 0};\n+\n+    if (source < source_end)\n+    {\n+        prev_value = unalignedLoad<T>(source);\n+        unalignedStore(dest, prev_value);\n+\n+        source += sizeof(prev_value);\n+        dest += sizeof(prev_value);\n+    }\n+\n+    WriteBuffer buffer(dest, getCompressedDataSize(sizeof(T), source_size - sizeof(items_count) - sizeof(prev_value)));\n+    BitWriter writer(buffer);\n+\n+    while (source < source_end)\n+    {\n+        const T curr_value = unalignedLoad<T>(source);\n+        source += sizeof(curr_value);\n+\n+        const auto xored_data = curr_value ^ prev_value;\n+        const binary_value_info curr_xored_info = getLeadingAndTrailingBits(xored_data);\n+\n+        if (xored_data == 0)\n+        {\n+            writer.writeBits(1, 0);\n+        }\n+        else if (prev_xored_info.data_bits != 0\n+                && prev_xored_info.leading_zero_bits <= curr_xored_info.leading_zero_bits\n+                && prev_xored_info.trailing_zero_bits <= curr_xored_info.trailing_zero_bits)\n+        {\n+            writer.writeBits(2, 0b10);\n+            writer.writeBits(prev_xored_info.data_bits, xored_data >> prev_xored_info.trailing_zero_bits);\n+        }\n+        else\n+        {\n+            writer.writeBits(2, 0b11);\n+            writer.writeBits(LEADING_ZEROES_BIT_LENGTH, curr_xored_info.leading_zero_bits);\n+            writer.writeBits(DATA_BIT_LENGTH, curr_xored_info.data_bits);\n+            writer.writeBits(curr_xored_info.data_bits, xored_data >> curr_xored_info.trailing_zero_bits);\n+            prev_xored_info = curr_xored_info;\n+        }\n+\n+        prev_value = curr_value;\n+    }\n+\n+    writer.flush();\n+\n+    return sizeof(items_count) + sizeof(prev_value) + buffer.count();\n+}\n+\n+template <typename T>\n+void decompressDataForType(const char * source, UInt32 source_size, char * dest)\n+{\n+    static const auto DATA_BIT_LENGTH = getBitLengthOfLength(sizeof(T));\n+    // -1 since there must be at least 1 non-zero bit.\n+    static const auto LEADING_ZEROES_BIT_LENGTH = DATA_BIT_LENGTH - 1;\n+\n+    const char * source_end = source + source_size;\n+\n+    const UInt32 items_count = unalignedLoad<UInt32>(source);\n+    source += sizeof(items_count);\n+\n+    T prev_value{};\n+\n+    if (source < source_end)\n+    {\n+        prev_value = unalignedLoad<T>(source);\n+        unalignedStore(dest, prev_value);\n+\n+        source += sizeof(prev_value);\n+        dest += sizeof(prev_value);\n+    }\n+\n+    ReadBufferFromMemory buffer(source, source_size - sizeof(items_count) - sizeof(prev_value));\n+    BitReader reader(buffer);\n+\n+    binary_value_info prev_xored_info{0, 0, 0};\n+\n+    // since data is tightly packed, up to 1 bit per value, and last byte is padded with zeroes,\n+    // we have to keep track of items to avoid reading more that there is.\n+    for (UInt32 items_read = 1; items_read < items_count && !reader.eof(); ++items_read)\n+    {\n+        T curr_value = prev_value;\n+        binary_value_info curr_xored_info = prev_xored_info;\n+        T xored_data{};\n+\n+        if (reader.readBit() == 1)\n+        {\n+            if (reader.readBit() == 1)\n+            {\n+                // 0b11 prefix\n+                curr_xored_info.leading_zero_bits = reader.readBits(LEADING_ZEROES_BIT_LENGTH);\n+                curr_xored_info.data_bits = reader.readBits(DATA_BIT_LENGTH);\n+                curr_xored_info.trailing_zero_bits = sizeof(T) * 8 - curr_xored_info.leading_zero_bits - curr_xored_info.data_bits;\n+            }\n+            // else: 0b10 prefix - use prev_xored_info\n+\n+            if (curr_xored_info.leading_zero_bits == 0\n+                && curr_xored_info.data_bits == 0\n+                && curr_xored_info.trailing_zero_bits == 0)\n+            {\n+                throw Exception(\"Cannot decompress gorilla-encoded data: corrupted input data.\",\n+                        ErrorCodes::CANNOT_DECOMPRESS);\n+            }\n+\n+            xored_data = reader.readBits(curr_xored_info.data_bits);\n+            xored_data <<= curr_xored_info.trailing_zero_bits;\n+            curr_value = prev_value ^ xored_data;\n+        }\n+        // else: 0b0 prefix - use prev_value\n+\n+        unalignedStore(dest, curr_value);\n+        dest += sizeof(curr_value);\n+\n+        prev_xored_info = curr_xored_info;\n+        prev_value = curr_value;\n+    }\n+}\n+\n+UInt8 getDataBytesSize(DataTypePtr column_type)\n+{\n+    UInt8 delta_bytes_size = 1;\n+    if (column_type && column_type->haveMaximumSizeOfValue())\n+    {\n+        size_t max_size = column_type->getSizeOfValueInMemory();\n+        if (max_size == 1 || max_size == 2 || max_size == 4 || max_size == 8)\n+            delta_bytes_size = static_cast<UInt8>(max_size);\n+    }\n+    return delta_bytes_size;\n+}\n+\n+}\n+\n+\n+CompressionCodecGorilla::CompressionCodecGorilla(UInt8 data_bytes_size_)\n+    : data_bytes_size(data_bytes_size_)\n+{\n+}\n+\n+UInt8 CompressionCodecGorilla::getMethodByte() const\n+{\n+    return static_cast<UInt8>(CompressionMethodByte::Gorilla);\n+}\n+\n+String CompressionCodecGorilla::getCodecDesc() const\n+{\n+    return \"Gorilla\";\n+}\n+\n+UInt32 CompressionCodecGorilla::getMaxCompressedDataSize(UInt32 uncompressed_size) const\n+{\n+    const auto result = 2 // common header\n+            + data_bytes_size // max bytes skipped if source is not properly aligned.\n+            + getCompressedHeaderSize(data_bytes_size) // data-specific header\n+            + getCompressedDataSize(data_bytes_size, uncompressed_size);\n+\n+    return result;\n+}\n+\n+UInt32 CompressionCodecGorilla::doCompressData(const char * source, UInt32 source_size, char * dest) const\n+{\n+    UInt8 bytes_to_skip = source_size % data_bytes_size;\n+    dest[0] = data_bytes_size;\n+    dest[1] = bytes_to_skip;\n+    memcpy(&dest[2], source, bytes_to_skip);\n+    size_t start_pos = 2 + bytes_to_skip;\n+    UInt32 compressed_size = 0;\n+    switch (data_bytes_size)\n+    {\n+    case 1:\n+        compressed_size = compressDataForType<UInt8>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);\n+        break;\n+    case 2:\n+        compressed_size = compressDataForType<UInt16>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);\n+        break;\n+    case 4:\n+        compressed_size = compressDataForType<UInt32>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);\n+        break;\n+    case 8:\n+        compressed_size = compressDataForType<UInt64>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);\n+        break;\n+    }\n+\n+    return 1 + 1 + compressed_size;\n+}\n+\n+void CompressionCodecGorilla::doDecompressData(const char * source, UInt32 source_size, char * dest, UInt32 /* uncompressed_size */) const\n+{\n+    UInt8 bytes_size = source[0];\n+    UInt8 bytes_to_skip = source[1];\n+\n+    memcpy(dest, &source[2], bytes_to_skip);\n+    UInt32 source_size_no_header = source_size - bytes_to_skip - 2;\n+    switch (bytes_size)\n+    {\n+    case 1:\n+        decompressDataForType<UInt8>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip]);\n+        break;\n+    case 2:\n+        decompressDataForType<UInt16>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip]);\n+        break;\n+    case 4:\n+        decompressDataForType<UInt32>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip]);\n+        break;\n+    case 8:\n+        decompressDataForType<UInt64>(&source[2 + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip]);\n+        break;\n+    }\n+}\n+\n+void CompressionCodecGorilla::useInfoAboutType(DataTypePtr data_type)\n+{\n+    data_bytes_size = getDataBytesSize(data_type);\n+}\n+\n+void registerCodecGorilla(CompressionCodecFactory & factory)\n+{\n+    UInt8 method_code = UInt8(CompressionMethodByte::Gorilla);\n+    factory.registerCompressionCodecWithType(\"Gorilla\", method_code, [&](const ASTPtr &, DataTypePtr column_type) -> CompressionCodecPtr\n+    {\n+        UInt8 delta_bytes_size = getDataBytesSize(column_type);\n+        return std::make_shared<CompressionCodecGorilla>(delta_bytes_size);\n+    });\n+}\n+}\ndiff --git a/dbms/src/Compression/CompressionCodecGorilla.h b/dbms/src/Compression/CompressionCodecGorilla.h\nnew file mode 100644\nindex 000000000000..a3947434ad91\n--- /dev/null\n+++ b/dbms/src/Compression/CompressionCodecGorilla.h\n@@ -0,0 +1,30 @@\n+#pragma once\n+\n+#include <Compression/ICompressionCodec.h>\n+\n+namespace DB\n+{\n+\n+class CompressionCodecGorilla : public ICompressionCodec\n+{\n+public:\n+    CompressionCodecGorilla(UInt8 data_bytes_size_);\n+\n+    UInt8 getMethodByte() const override;\n+\n+    String getCodecDesc() const override;\n+\n+    void useInfoAboutType(DataTypePtr data_type) override;\n+\n+protected:\n+    UInt32 doCompressData(const char * source, UInt32 source_size, char * dest) const override;\n+\n+    void doDecompressData(const char * source, UInt32 source_size, char * dest, UInt32 uncompressed_size) const override;\n+\n+    UInt32 getMaxCompressedDataSize(UInt32 uncompressed_size) const override;\n+\n+private:\n+    UInt8 data_bytes_size;\n+};\n+\n+}\ndiff --git a/dbms/src/Compression/CompressionFactory.cpp b/dbms/src/Compression/CompressionFactory.cpp\nindex 7f9a7a24f096..b67ac78b9702 100644\n--- a/dbms/src/Compression/CompressionFactory.cpp\n+++ b/dbms/src/Compression/CompressionFactory.cpp\n@@ -138,6 +138,8 @@ void registerCodecMultiple(CompressionCodecFactory & factory);\n void registerCodecLZ4HC(CompressionCodecFactory & factory);\n void registerCodecDelta(CompressionCodecFactory & factory);\n void registerCodecT64(CompressionCodecFactory & factory);\n+void registerCodecDoubleDelta(CompressionCodecFactory & factory);\n+void registerCodecGorilla(CompressionCodecFactory & factory);\n \n CompressionCodecFactory::CompressionCodecFactory()\n {\n@@ -149,6 +151,8 @@ CompressionCodecFactory::CompressionCodecFactory()\n     registerCodecLZ4HC(*this);\n     registerCodecDelta(*this);\n     registerCodecT64(*this);\n+    registerCodecDoubleDelta(*this);\n+    registerCodecGorilla(*this);\n }\n \n }\ndiff --git a/dbms/src/Compression/CompressionInfo.h b/dbms/src/Compression/CompressionInfo.h\nindex 430840686c9c..290ebaeb5042 100644\n--- a/dbms/src/Compression/CompressionInfo.h\n+++ b/dbms/src/Compression/CompressionInfo.h\n@@ -41,6 +41,8 @@ enum class CompressionMethodByte : uint8_t\n     Multiple = 0x91,\n     Delta    = 0x92,\n     T64      = 0x93,\n+    DoubleDelta = 0x94,\n+    Gorilla     = 0x95,\n };\n \n }\ndiff --git a/dbms/src/Compression/ICompressionCodec.cpp b/dbms/src/Compression/ICompressionCodec.cpp\nindex f9707d7c9da3..ddedf8a4c9cf 100644\n--- a/dbms/src/Compression/ICompressionCodec.cpp\n+++ b/dbms/src/Compression/ICompressionCodec.cpp\n@@ -29,7 +29,7 @@ namespace ErrorCodes\n }\n \n \n-UInt32 ICompressionCodec::compress(char * source, UInt32 source_size, char * dest) const\n+UInt32 ICompressionCodec::compress(const char * source, UInt32 source_size, char * dest) const\n {\n     dest[0] = getMethodByte();\n     UInt8 header_size = getHeaderSize();\n@@ -41,7 +41,7 @@ UInt32 ICompressionCodec::compress(char * source, UInt32 source_size, char * des\n }\n \n \n-UInt32 ICompressionCodec::decompress(char * source, UInt32 source_size, char * dest) const\n+UInt32 ICompressionCodec::decompress(const char * source, UInt32 source_size, char * dest) const\n {\n     UInt8 method = source[0];\n     if (method != getMethodByte())\ndiff --git a/dbms/src/Compression/ICompressionCodec.h b/dbms/src/Compression/ICompressionCodec.h\nindex 040cb84c5ebd..27630a79a0b5 100644\n--- a/dbms/src/Compression/ICompressionCodec.h\n+++ b/dbms/src/Compression/ICompressionCodec.h\n@@ -35,10 +35,10 @@ class ICompressionCodec : private boost::noncopyable\n     virtual String getCodecDesc() const = 0;\n \n     /// Compressed bytes from uncompressed source to dest. Dest should preallocate memory\n-    virtual UInt32 compress(char * source, UInt32 source_size, char * dest) const;\n+    virtual UInt32 compress(const char * source, UInt32 source_size, char * dest) const;\n \n     /// Decompress bytes from compressed source to dest. Dest should preallocate memory\n-    virtual UInt32 decompress(char * source, UInt32 source_size, char * dest) const;\n+    virtual UInt32 decompress(const char * source, UInt32 source_size, char * dest) const;\n \n     /// Number of bytes, that will be used to compress uncompressed_size bytes with current codec\n     virtual UInt32 getCompressedReserveSize(UInt32 uncompressed_size) const { return getHeaderSize() + getMaxCompressedDataSize(uncompressed_size); }\ndiff --git a/dbms/src/IO/BitHelpers.h b/dbms/src/IO/BitHelpers.h\nnew file mode 100644\nindex 000000000000..c29862997461\n--- /dev/null\n+++ b/dbms/src/IO/BitHelpers.h\n@@ -0,0 +1,178 @@\n+#pragma once\n+\n+#include <IO/ReadBuffer.h>\n+#include <IO/WriteBuffer.h>\n+#include <Core/Types.h>\n+#include <Common/BitHelpers.h>\n+\n+namespace DB\n+{\n+\n+/** Reads data from underlying ReadBuffer bit by bit, max 64 bits at once.\n+ *\n+ * reads MSB bits first, imagine that you have a data:\n+ * 11110000 10101010 00100100 11111110\n+ *\n+ * Given that r is BitReader created with a ReadBuffer that reads from data above:\n+ *  r.readBits(3)  => 0b111\n+ *  r.readBit()    => 0b1\n+ *  r.readBits(8)  => 0b1010 // 4 leading zero-bits are not shown\n+ *  r.readBit()    => 0b1\n+ *  r.readBit()    => 0b0\n+ *  r.readBits(15) => 0b10001001001111111\n+ *  r.readBit()    => 0b0\n+**/\n+\n+class BitReader\n+{\n+    ReadBuffer & buf;\n+\n+    UInt64 bits_buffer;\n+    UInt8 bits_count;\n+    static constexpr UInt8 BIT_BUFFER_SIZE = sizeof(bits_buffer) * 8;\n+\n+public:\n+    BitReader(ReadBuffer & buf_)\n+        : buf(buf_),\n+          bits_buffer(0),\n+          bits_count(0)\n+    {}\n+\n+    ~BitReader()\n+    {}\n+\n+    inline UInt64 readBits(UInt8 bits)\n+    {\n+        UInt64 result = 0;\n+        bits = std::min(static_cast<UInt8>(sizeof(result) * 8), bits);\n+\n+        while (bits != 0)\n+        {\n+            if (bits_count == 0)\n+            {\n+                fillBuffer();\n+                if (bits_count == 0)\n+                {\n+                    // EOF.\n+                    break;\n+                }\n+            }\n+\n+            const auto to_read = std::min(bits, bits_count);\n+\n+            const UInt64 v = bits_buffer >> (bits_count - to_read);\n+            const UInt64 mask = maskLowBits<UInt64>(to_read);\n+            const UInt64 value = v & mask;\n+            result |= value;\n+\n+            // unset bits that were read\n+            bits_buffer &= ~(mask << (bits_count - to_read));\n+            bits_count -= to_read;\n+            bits -= to_read;\n+\n+            result <<= std::min(bits, BIT_BUFFER_SIZE);\n+        }\n+\n+        return result;\n+    }\n+\n+    inline UInt64 peekBits(UInt8 /*bits*/)\n+    {\n+        return 0;\n+    }\n+\n+    inline UInt8 readBit()\n+    {\n+        return static_cast<UInt8>(readBits(1));\n+    }\n+\n+    inline bool eof() const\n+    {\n+        return bits_count == 0 && buf.eof();\n+    }\n+\n+private:\n+    void fillBuffer()\n+    {\n+        auto read = buf.read(reinterpret_cast<char *>(&bits_buffer), BIT_BUFFER_SIZE / 8);\n+        bits_buffer = be64toh(bits_buffer);\n+        bits_buffer >>= BIT_BUFFER_SIZE - read * 8;\n+\n+        bits_count = static_cast<UInt8>(read) * 8;\n+    }\n+};\n+\n+class BitWriter\n+{\n+    WriteBuffer & buf;\n+\n+    UInt64 bits_buffer;\n+    UInt8 bits_count;\n+\n+    static constexpr UInt8 BIT_BUFFER_SIZE = sizeof(bits_buffer) * 8;\n+\n+public:\n+    BitWriter(WriteBuffer & buf_)\n+        : buf(buf_),\n+          bits_buffer(0),\n+          bits_count(0)\n+    {}\n+\n+    ~BitWriter()\n+    {\n+        flush();\n+    }\n+\n+    inline void writeBits(UInt8 bits, UInt64 value)\n+    {\n+        bits = std::min(static_cast<UInt8>(sizeof(value) * 8), bits);\n+\n+        while (bits > 0)\n+        {\n+            auto v = value;\n+            auto to_write = bits;\n+\n+            const UInt8 capacity = BIT_BUFFER_SIZE - bits_count;\n+            if (capacity < bits)\n+            {\n+                v >>= bits - capacity;\n+                to_write = capacity;\n+            }\n+\n+            const UInt64 mask = maskLowBits<UInt64>(to_write);\n+            v &= mask;\n+//            assert(v <= 255);\n+\n+            bits_buffer <<= to_write;\n+            bits_buffer |= v;\n+            bits_count += to_write;\n+\n+            if (bits_count < BIT_BUFFER_SIZE)\n+                break;\n+\n+            doFlush();\n+            bits -= to_write;\n+        }\n+    }\n+\n+    inline void flush()\n+    {\n+        if (bits_count != 0)\n+        {\n+            bits_buffer <<= (BIT_BUFFER_SIZE - bits_count);\n+            doFlush();\n+        }\n+    }\n+\n+private:\n+    void doFlush()\n+    {\n+        bits_buffer = htobe64(bits_buffer);\n+        buf.write(reinterpret_cast<const char *>(&bits_buffer), (bits_count + 7) / 8);\n+\n+        bits_count = 0;\n+        bits_buffer = 0;\n+    }\n+};\n+\n+}\ndiff --git a/docs/en/query_language/create.md b/docs/en/query_language/create.md\nindex 9ebd50839d38..926ba95173f1 100644\n--- a/docs/en/query_language/create.md\n+++ b/docs/en/query_language/create.md\n@@ -101,6 +101,8 @@ Possible `level` range: \\[3, 12\\]. Default value: 9. Greater values stands for b\n Greater values stands for better compression and higher CPU usage.\n - `Delta(delta_bytes)` - compression approach when raw values are replace with difference of two neighbour values. Up to `delta_bytes` are used for storing delta value.\n Possible `delta_bytes` values: 1, 2, 4, 8. Default value for delta bytes is `sizeof(type)`, if it is equals to 1, 2, 4, 8 and equals to 1 otherwise.\n+- `DoubleDelta` - stores delta of deltas in compact binary form, compressing values down to 1 bit (in the best case). Best compression rates are achieved on monotonic sequences with constant stride, e.g. time samples. Can be used against any fixed-width type. Implementation is based on [Gorilla paper](http://www.vldb.org/pvldb/vol8/p1816-teller.pdf), and extended to support 64bit types. The drawback is 1 extra bit for 32-byte wide deltas: 5-bit prefix instead of 4-bit prefix.\n+- `Gorilla` - stores (parts of) xored values in compact binary form, compressing values down to 1 bit (in the best case). Best compression rate is achieved when neighbouring values are binary equal. Basic use case - floating point data that do not change rapidly. Implementation is based on [Gorilla paper](http://www.vldb.org/pvldb/vol8/p1816-teller.pdf), and extended to support 64bit types.\n \n Syntax example:\n ```\n",
  "test_patch": "diff --git a/dbms/src/Compression/tests/gtest_compressionCodec.cpp b/dbms/src/Compression/tests/gtest_compressionCodec.cpp\nnew file mode 100644\nindex 000000000000..e1413ccd7bd8\n--- /dev/null\n+++ b/dbms/src/Compression/tests/gtest_compressionCodec.cpp\n@@ -0,0 +1,385 @@\n+#include <Compression/CompressionCodecDoubleDelta.h>\n+#include <Compression/CompressionCodecGorilla.h>\n+\n+#include <Core/Types.h>\n+#include <IO/WriteHelpers.h>\n+#include <IO/ReadBufferFromMemory.h>\n+#include <Common/PODArray.h>\n+\n+#include <boost/format.hpp>\n+\n+#include <cmath>\n+#include <initializer_list>\n+#include <iomanip>\n+#include <memory>\n+#include <vector>\n+#include <typeinfo>\n+#include <iterator>\n+#include <optional>\n+#include <iostream>\n+#include <bitset>\n+#include <string.h>\n+\n+#pragma GCC diagnostic ignored \"-Wsign-compare\"\n+#ifdef __clang__\n+#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"\n+#pragma clang diagnostic ignored \"-Wundef\"\n+#endif\n+#include <gtest/gtest.h>\n+\n+using namespace DB;\n+\n+template <typename T>\n+std::string bin(const T & value, size_t bits = sizeof(T)*8)\n+{\n+    static const UInt8 MAX_BITS = sizeof(T)*8;\n+    assert(bits <= MAX_BITS);\n+\n+    return std::bitset<sizeof(T) * 8>(static_cast<unsigned long long>(value))\n+            .to_string().substr(MAX_BITS - bits, bits);\n+}\n+\n+template <typename T>\n+const char* type_name()\n+{\n+    return typeid(T).name();\n+}\n+\n+template <>\n+const char* type_name<UInt32>()\n+{\n+    return \"uint32\";\n+}\n+\n+template <>\n+const char* type_name<Int32>()\n+{\n+    return \"int32\";\n+}\n+\n+template <>\n+const char* type_name<UInt64>()\n+{\n+    return \"uint64\";\n+}\n+\n+template <>\n+const char* type_name<Int64>()\n+{\n+    return \"int64\";\n+}\n+\n+template <>\n+const char* type_name<Float32>()\n+{\n+    return \"float\";\n+}\n+\n+template <>\n+const char* type_name<Float64>()\n+{\n+    return \"double\";\n+}\n+\n+\n+template <typename T, typename ContainerLeft, typename ContainerRight>\n+::testing::AssertionResult EqualByteContainersAs(const ContainerLeft & left, const ContainerRight & right)\n+{\n+    static_assert(sizeof(typename ContainerLeft::value_type) == 1, \"Expected byte-container\");\n+    static_assert(sizeof(typename ContainerRight::value_type) == 1, \"Expected byte-container\");\n+\n+    ::testing::AssertionResult result = ::testing::AssertionSuccess();\n+\n+    ReadBufferFromMemory left_read_buffer(left.data(), left.size());\n+    ReadBufferFromMemory right_read_buffer(right.data(), right.size());\n+\n+    const auto l_size = left.size() / sizeof(T);\n+    const auto r_size = right.size() / sizeof(T);\n+    const auto size = std::min(l_size, r_size);\n+\n+    if (l_size != r_size)\n+    {\n+        result = ::testing::AssertionFailure() << \"size mismatch\" << \" expected: \" << l_size << \" got:\" << r_size;\n+    }\n+\n+    const auto MAX_MISMATCHING_ITEMS = 5;\n+    int mismatching_items = 0;\n+    for (int i = 0; i < size; ++i)\n+    {\n+        T left_value{};\n+        left_read_buffer.readStrict(reinterpret_cast<char*>(&left_value), sizeof(left_value));\n+\n+        T right_value{};\n+        right_read_buffer.readStrict(reinterpret_cast<char*>(&right_value), sizeof(right_value));\n+\n+        if (left_value != right_value)\n+        {\n+            if (result)\n+            {\n+                result = ::testing::AssertionFailure();\n+            }\n+\n+            result << \"mismatching \" << sizeof(T) << \"-byte item #\" << i\n+                   << \"\\nexpected: \" << bin(left_value)\n+                   << \"\\ngot     : \" << bin(right_value)\n+                   << std::endl;\n+\n+            if (++mismatching_items >= MAX_MISMATCHING_ITEMS)\n+            {\n+                result << \"...\" << std::endl;\n+                break;\n+            }\n+        }\n+    }\n+\n+    return result;\n+}\n+\n+struct CodecTestParam\n+{\n+    std::vector<char> source_data;\n+    UInt8 data_byte_size;\n+    std::string case_name;\n+};\n+\n+std::ostream & operator<<(std::ostream & ostr, const CodecTestParam & param)\n+{\n+    return ostr << \"name: \" << param.case_name\n+                << \"\\nbyte size: \" << static_cast<UInt32>(param.data_byte_size)\n+                << \"\\ndata size: \" << param.source_data.size();\n+}\n+\n+template <typename T, typename... Args>\n+CodecTestParam makeParam(Args && ... args)\n+{\n+    std::initializer_list<T> vals{static_cast<T>(args)...};\n+    std::vector<char> data(sizeof(T) * std::size(vals));\n+\n+    char * write_pos = data.data();\n+    for (const auto & v : vals)\n+    {\n+        unalignedStore<T>(write_pos, v);\n+        write_pos += sizeof(v);\n+    }\n+\n+    return CodecTestParam{std::move(data), sizeof(T),\n+                (boost::format(\"%1% %2%\") % (sizeof(T) * std::size(vals)) % \" predefined values\").str()};\n+}\n+\n+template <typename T, size_t Begin = 1, size_t End = 10000, typename Generator>\n+CodecTestParam generateParam(Generator gen, const char* gen_name)\n+{\n+    static_assert (End >= Begin, \"End must be not less than Begin\");\n+\n+    std::vector<char> data(sizeof(T) * (End - Begin));\n+    char * write_pos = data.data();\n+\n+    for (size_t i = Begin; i < End; ++i)\n+    {\n+        const T v = gen(static_cast<T>(i));\n+        unalignedStore<T>(write_pos, v);\n+        write_pos += sizeof(v);\n+    }\n+\n+    return CodecTestParam{std::move(data), sizeof(T),\n+                (boost::format(\"%1% from %2% (%3% => %4%)\") % type_name<T>() % gen_name % Begin % End).str()};\n+}\n+\n+void TestTranscoding(ICompressionCodec * codec, const CodecTestParam & param)\n+{\n+    const auto & source_data = param.source_data;\n+\n+    const UInt32 encoded_max_size = codec->getCompressedReserveSize(source_data.size());\n+    PODArray<char> encoded(encoded_max_size);\n+\n+    const UInt32 encoded_size = codec->compress(source_data.data(), source_data.size(), encoded.data());\n+    encoded.resize(encoded_size);\n+\n+    PODArray<char> decoded(source_data.size());\n+    const UInt32 decoded_size = codec->decompress(encoded.data(), encoded.size(), decoded.data());\n+    decoded.resize(decoded_size);\n+\n+    switch (param.data_byte_size)\n+    {\n+        case 1:\n+            ASSERT_TRUE(EqualByteContainersAs<UInt8>(source_data, decoded));\n+            break;\n+        case 2:\n+            ASSERT_TRUE(EqualByteContainersAs<UInt16>(source_data, decoded));\n+            break;\n+        case 4:\n+            ASSERT_TRUE(EqualByteContainersAs<UInt32>(source_data, decoded));\n+            break;\n+        case 8:\n+            ASSERT_TRUE(EqualByteContainersAs<UInt64>(source_data, decoded));\n+            break;\n+        default:\n+            FAIL() << \"Invalid data_byte_size: \" << param.data_byte_size;\n+    }\n+}\n+\n+class CodecTest : public ::testing::TestWithParam<CodecTestParam>\n+{\n+public:\n+    static void SetUpTestCase()\n+    {\n+        // To make random predicatble and avoid failing test \"out of the blue\".\n+        srand(0);\n+    }\n+};\n+\n+TEST_P(CodecTest, DoubleDelta)\n+{\n+    const auto & param = GetParam();\n+    auto codec = std::make_unique<CompressionCodecDoubleDelta>(param.data_byte_size);\n+\n+    TestTranscoding(codec.get(), param);\n+}\n+\n+TEST_P(CodecTest, Gorilla)\n+{\n+    const auto & param = GetParam();\n+    auto codec = std::make_unique<CompressionCodecGorilla>(param.data_byte_size);\n+\n+    TestTranscoding(codec.get(), param);\n+}\n+\n+auto SameValueGenerator = [](auto value)\n+{\n+    return [=](auto i)\n+    {\n+        return static_cast<decltype(i)>(value);\n+    };\n+};\n+\n+auto SequentialGenerator = [](auto stride = 1)\n+{\n+    return [=](auto i)\n+    {\n+        using ValueType = decltype(i);\n+        return static_cast<ValueType>(stride * i);\n+    };\n+};\n+\n+template <typename T>\n+struct MonotonicGenerator\n+{\n+    MonotonicGenerator(T stride = 1, size_t max_step = 10)\n+        : prev_value{},\n+          stride(stride),\n+          max_step(max_step)\n+    {}\n+\n+    template <typename U>\n+    U operator()(U i)\n+    {\n+        if (!prev_value.has_value())\n+        {\n+            prev_value = i * stride;\n+        }\n+\n+        const U result = *prev_value + static_cast<T>(stride * (rand() % max_step));\n+\n+        prev_value = result;\n+        return result;\n+    }\n+\n+    std::optional<T> prev_value;\n+    const T stride;\n+    const size_t max_step;\n+};\n+\n+auto MinMaxGenerator = [](auto i)\n+{\n+    if (i % 2 == 0)\n+    {\n+        return std::numeric_limits<decltype(i)>::min();\n+    }\n+    else\n+    {\n+        return std::numeric_limits<decltype(i)>::max();\n+    }\n+};\n+\n+auto RandomGenerator = [](auto i) {return static_cast<decltype(i)>(rand());};\n+\n+auto RandomishGenerator = [](auto i)\n+{\n+    return static_cast<decltype(i)>(sin(static_cast<double>(i) * i) * i);\n+};\n+\n+INSTANTIATE_TEST_CASE_P(Basic,\n+    CodecTest,\n+    ::testing::Values(\n+        makeParam<UInt32>(1, 2, 3, 4),\n+        makeParam<UInt64>(1, 2, 3, 4),\n+        makeParam<Float32>(1.1, 2.2, 3.3, 4.4),\n+        makeParam<Float64>(1.1, 2.2, 3.3, 4.4)\n+    ),\n+);\n+\n+#define G(generator) generator, #generator\n+\n+INSTANTIATE_TEST_CASE_P(Same,\n+    CodecTest,\n+    ::testing::Values(\n+        generateParam<UInt32>(G(SameValueGenerator(1000))),\n+        generateParam<Int32>(G(SameValueGenerator(-1000))),\n+        generateParam<UInt64>(G(SameValueGenerator(1000))),\n+        generateParam<Int64>(G(SameValueGenerator(-1000))),\n+        generateParam<Float32>(G(SameValueGenerator(M_E))),\n+        generateParam<Float64>(G(SameValueGenerator(M_E)))\n+    ),\n+);\n+\n+INSTANTIATE_TEST_CASE_P(Sequential,\n+    CodecTest,\n+    ::testing::Values(\n+        generateParam<UInt32>(G(SequentialGenerator(1))),\n+        generateParam<Int32>(G(SequentialGenerator(-1))),\n+        generateParam<UInt64>(G(SequentialGenerator(1))),\n+        generateParam<Int64>(G(SequentialGenerator(-1))),\n+        generateParam<Float32>(G(SequentialGenerator(M_E))),\n+        generateParam<Float64>(G(SequentialGenerator(M_E)))\n+    ),\n+);\n+\n+INSTANTIATE_TEST_CASE_P(Monotonic,\n+    CodecTest,\n+    ::testing::Values(\n+        generateParam<UInt32>(G(MonotonicGenerator<UInt32>(1, 5))),\n+        generateParam<Int32>(G(MonotonicGenerator<Int32>(-1, 5))),\n+        generateParam<UInt64>(G(MonotonicGenerator<UInt64>(1, 5))),\n+        generateParam<Int64>(G(MonotonicGenerator<Int64>(-1, 5))),\n+        generateParam<Float32>(G(MonotonicGenerator<Float32>(M_E, 5))),\n+        generateParam<Float64>(G(MonotonicGenerator<Float64>(M_E, 5)))\n+    ),\n+);\n+\n+INSTANTIATE_TEST_CASE_P(Random,\n+    CodecTest,\n+    ::testing::Values(\n+        generateParam<UInt32>(G(RandomGenerator)),\n+        generateParam<UInt64>(G(RandomGenerator))\n+    ),\n+);\n+\n+INSTANTIATE_TEST_CASE_P(RandomLike,\n+    CodecTest,\n+    ::testing::Values(\n+        generateParam<Int32>(G(RandomishGenerator)),\n+        generateParam<Int64>(G(RandomishGenerator)),\n+        generateParam<Float32>(G(RandomishGenerator)),\n+        generateParam<Float64>(G(RandomishGenerator))\n+    ),\n+);\n+\n+INSTANTIATE_TEST_CASE_P(Overflow,\n+    CodecTest,\n+    ::testing::Values(\n+        generateParam<UInt32>(G(MinMaxGenerator)),\n+        generateParam<Int32>(G(MinMaxGenerator)),\n+        generateParam<UInt64>(G(MinMaxGenerator)),\n+        generateParam<Int64>(G(MinMaxGenerator))\n+    ),\n+);\ndiff --git a/dbms/src/IO/tests/gtest_bit_io.cpp b/dbms/src/IO/tests/gtest_bit_io.cpp\nnew file mode 100644\nindex 000000000000..abb5a53e3469\n--- /dev/null\n+++ b/dbms/src/IO/tests/gtest_bit_io.cpp\n@@ -0,0 +1,213 @@\n+#include <string.h>\n+#include <IO/BitHelpers.h>\n+\n+#include <Core/Types.h>\n+#include <IO/MemoryReadWriteBuffer.h>\n+#include <IO/ReadBufferFromMemory.h>\n+#include <Common/BitHelpers.h>\n+#include <Common/PODArray.h>\n+\n+#include <cmath>\n+#include <iomanip>\n+#include <memory>\n+#include <bitset>\n+#include <string>\n+#include <vector>\n+#include <typeinfo>\n+#include <iostream>\n+\n+#pragma GCC diagnostic ignored \"-Wsign-compare\"\n+#ifdef __clang__\n+#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"\n+#pragma clang diagnostic ignored \"-Wundef\"\n+#endif\n+\n+#include <gtest/gtest.h>\n+\n+using namespace DB;\n+\n+// Intentionally asymmetric both byte and word-size to detect read and write inconsistencies\n+// each prime bit is set to 0.\n+//                              v-61     v-53   v-47  v-41 v-37   v-31     v-23  v-17   v-11   v-5\n+const UInt64 BIT_PATTERN = 0b11101011'11101111'10111010'11101111'10101111'10111010'11101011'10101001;\n+const UInt8 PRIMES[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61};\n+\n+template <typename T>\n+std::string bin(const T & value, size_t bits = sizeof(T)*8)\n+{\n+    static const UInt8 MAX_BITS = sizeof(T)*8;\n+    assert(bits <= MAX_BITS);\n+\n+    return std::bitset<sizeof(T) * 8>(static_cast<unsigned long long>(value))\n+            .to_string().substr(MAX_BITS - bits, bits);\n+}\n+\n+template <typename T>\n+T getBits(UInt8 bits, const T & value)\n+{\n+    const T mask = ((static_cast<T>(1) << static_cast<T>(bits)) - 1);\n+    return value & mask;\n+}\n+\n+template <typename T>\n+std::ostream & dumpBuffer(const T begin,\n+                          const T end,\n+                          std::ostream * destination,\n+                          const char* col_sep = \" \",\n+                          const char* row_sep = \"\\n\",\n+                          const size_t cols_in_row = 8,\n+                          UInt32 max_bytes = 0xFFFFFFFF)\n+{\n+    size_t col = 0;\n+    for (auto p = begin; p < end && p - begin < max_bytes; ++p)\n+    {\n+        *destination << bin(*p);\n+        if (++col % cols_in_row == 0)\n+        {\n+            if (row_sep)\n+                *destination << row_sep;\n+        }\n+        else if (col_sep)\n+        {\n+            *destination << col_sep;\n+        }\n+    }\n+\n+    return *destination;\n+}\n+\n+template <typename T>\n+std::string dumpContents(const T& container,\n+                         const char* col_sep = \" \",\n+                         const char* row_sep = \"\\n\",\n+                         const size_t cols_in_row = 8)\n+\n+{\n+    std::stringstream sstr;\n+    dumpBuffer(std::begin(container), std::end(container), &sstr, col_sep, row_sep, cols_in_row);\n+\n+    return sstr.str();\n+}\n+\n+struct TestCaseParameter\n+{\n+    std::vector<std::pair<UInt8, UInt64>> bits_and_vals;\n+    std::string expected_buffer_binary;\n+\n+    explicit TestCaseParameter(std::vector<std::pair<UInt8, UInt64>> vals, std::string binary = std::string{})\n+        : bits_and_vals(std::move(vals)),\n+          expected_buffer_binary(binary)\n+    {}\n+};\n+\n+class BitIO : public ::testing::TestWithParam<TestCaseParameter>\n+{};\n+\n+TEST_P(BitIO, WriteAndRead)\n+{\n+    const auto & param = GetParam();\n+    const auto & bits_and_vals = param.bits_and_vals;\n+    const auto & expected_buffer_binary = param.expected_buffer_binary;\n+\n+    UInt64 max_buffer_size = 0;\n+    for (const auto & bv : bits_and_vals)\n+    {\n+        max_buffer_size += bv.first;\n+    }\n+    max_buffer_size = (max_buffer_size + 7) / 8;\n+    SCOPED_TRACE(max_buffer_size);\n+\n+    PODArray<char> data(max_buffer_size);\n+\n+    {\n+        WriteBuffer write_buffer(data.data(), data.size());\n+        BitWriter writer(write_buffer);\n+        for (const auto & bv : bits_and_vals)\n+        {\n+            writer.writeBits(bv.first, bv.second);\n+        }\n+        writer.flush();\n+    }\n+\n+    {\n+        ReadBufferFromMemory read_buffer(data.data(), data.size());\n+//        auto memory_read_buffer = memory_write_buffer.tryGetReadBuffer();\n+\n+        if (expected_buffer_binary != std::string{})\n+        {\n+            const auto actual_buffer_binary = dumpContents(data, \" \", \" \");\n+            ASSERT_EQ(expected_buffer_binary, actual_buffer_binary);\n+        }\n+\n+        BitReader reader(read_buffer);\n+\n+        int item = 0;\n+        for (const auto & bv : bits_and_vals)\n+        {\n+            SCOPED_TRACE(::testing::Message()\n+                         << \"item #\" << item << \", width: \" << static_cast<UInt32>(bv.first)\n+                         << \", value: \" << bin(bv.second)\n+                         << \".\\n\\n\\nBuffer memory:\\n\" << dumpContents(data));\n+\n+            //EXPECT_EQ(getBits(bv.first, bv.second), reader.peekBits(bv.first));\n+            EXPECT_EQ(getBits(bv.first, bv.second), reader.readBits(bv.first));\n+\n+            ++item;\n+        }\n+    }\n+}\n+\n+INSTANTIATE_TEST_CASE_P(Simple,\n+        BitIO,\n+        ::testing::Values(\n+            TestCaseParameter(\n+                {{9, 0xFFFFFFFF}, {9, 0x00}, {9, 0xFFFFFFFF}, {9, 0x00}, {9, 0xFFFFFFFF}},\n+                \"11111111 10000000 00111111 11100000 00001111 11111000 \"),\n+            TestCaseParameter(\n+                {{7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {3, 0xFFFF}},\n+                \"01111110 11111101 11111011 11110111 11101111 11011111 10111111 01111111 11000000 \"),\n+            TestCaseParameter({{33, 0xFF110d0b07050300}, {33, 0xAAEE29251f1d1713}}),\n+            TestCaseParameter({{33, BIT_PATTERN}, {33, BIT_PATTERN}}),\n+            TestCaseParameter({{24, 0xFFFFFFFF}},\n+                \"11111111 11111111 11111111 \")\n+),);\n+\n+TestCaseParameter primes_case(UInt8 repeat_times, UInt64 pattern)\n+{\n+    std::vector<std::pair<UInt8, UInt64>> test_data;\n+\n+    {\n+        for (UInt8 r = 0; r < repeat_times; ++r)\n+        {\n+            for (const auto p : PRIMES)\n+            {\n+                test_data.emplace_back(p, pattern);\n+            }\n+        }\n+    }\n+\n+    return TestCaseParameter(test_data);\n+}\n+\n+INSTANTIATE_TEST_CASE_P(Primes,\n+        BitIO,\n+        ::testing::Values(\n+            primes_case(11, 0xFFFFFFFFFFFFFFFFULL),\n+            primes_case(11, BIT_PATTERN)\n+),);\n+\n+TEST(BitHelpers, maskLowBits)\n+{\n+    EXPECT_EQ(0b00000111, ::maskLowBits<UInt8>(3));\n+    EXPECT_EQ(0b01111111, ::maskLowBits<UInt8>(7));\n+    EXPECT_EQ(0b0000000001111111, ::maskLowBits<UInt16>(7));\n+    EXPECT_EQ(0b0001111111111111, ::maskLowBits<UInt16>(13));\n+    EXPECT_EQ(0b00000111111111111111111111111111, ::maskLowBits<UInt32>(27));\n+    EXPECT_EQ(0b111111111111111111111111111111111, ::maskLowBits<UInt64>(33));\n+    EXPECT_EQ(0b11111111111111111111111111111111111, ::maskLowBits<UInt64>(35));\n+\n+    EXPECT_EQ(0xFF, ::maskLowBits<UInt8>(8));\n+    EXPECT_EQ(0xFFFF, ::maskLowBits<UInt16>(16));\n+    EXPECT_EQ(0xFFFFFFFF, ::maskLowBits<UInt32>(32));\n+    EXPECT_EQ(0xFFFFFFFFFFFFFFFF, ::maskLowBits<UInt64>(64));\n+}\ndiff --git a/dbms/tests/performance/codec_double_delta.xml b/dbms/tests/performance/codec_double_delta.xml\nnew file mode 100644\nindex 000000000000..a713c606eb1d\n--- /dev/null\n+++ b/dbms/tests/performance/codec_double_delta.xml\n@@ -0,0 +1,67 @@\n+<test>\n+    <name>IPv4 Functions</name>\n+\n+    <type>once</type>\n+    <stop_conditions>\n+        <any_of>\n+            <average_speed_not_changing_for_ms>1000</average_speed_not_changing_for_ms>\n+            <total_time_ms>2000</total_time_ms>\n+        </any_of>\n+    </stop_conditions>\n+\n+    <substitutions>\n+        <substitution>\n+            <name>table_suffix</name>\n+            <values>\n+                <value>dd</value>\n+                <value>lz4</value>\n+                <value>dd_lz4</value>\n+            </values>\n+        </substitution>\n+    </substitutions>\n+\n+    <create_query>CREATE TABLE IF NOT EXISTS seq_dd (n UInt64 CODEC(DoubleDelta, NONE)) ENGINE = MergeTree PARTITION BY tuple() ORDER BY tuple();</create_query>\n+    <create_query>CREATE TABLE IF NOT EXISTS mon_dd AS seq_dd;</create_query>\n+    <create_query>CREATE TABLE IF NOT EXISTS rnd_dd AS seq_dd;</create_query>\n+\n+    <create_query>CREATE TABLE IF NOT EXISTS seq_lz4 (n UInt64 CODEC(LZ4, NONE)) ENGINE = MergeTree PARTITION BY tuple() ORDER BY tuple();</create_query>\n+    <create_query>CREATE TABLE IF NOT EXISTS mon_lz4 AS seq_lz4;</create_query>\n+    <create_query>CREATE TABLE IF NOT EXISTS rnd_lz4 AS seq_lz4;</create_query>\n+\n+    <create_query>CREATE TABLE IF NOT EXISTS seq_dd_lz4 (n UInt64 CODEC(DoubleDelta, LZ4, NONE)) ENGINE = MergeTree PARTITION BY tuple() ORDER BY tuple();</create_query>\n+    <create_query>CREATE TABLE IF NOT EXISTS mon_dd_lz4 AS seq_dd_lz4;</create_query>\n+    <create_query>CREATE TABLE IF NOT EXISTS rnd_dd_lz4 AS seq_dd_lz4;</create_query>\n+\n+    <fill_query>INSERT INTO seq_{table_suffix} (n) SELECT number FROM system.numbers LIMIT 100000</fill_query>\n+    <fill_query>INSERT INTO mon_{table_suffix} (n) SELECT number*67+(rand()%67) FROM system.numbers LIMIT 100000</fill_query>\n+    <fill_query>INSERT INTO rnd_{table_suffix} (n) SELECT rand() FROM system.numbers LIMIT 100000</fill_query>\n+    \n+    <fill_query>INSERT INTO seq_{table_suffix} (n) SELECT n FROM seq_{table_suffix}</fill_query>\n+    <fill_query>INSERT INTO mon_{table_suffix} (n) SELECT n FROM mon_{table_suffix}</fill_query>\n+    <fill_query>INSERT INTO rnd_{table_suffix} (n) SELECT n FROM rnd_{table_suffix}</fill_query>\n+    <fill_query>INSERT INTO seq_{table_suffix} (n) SELECT n FROM seq_{table_suffix}</fill_query>\n+    <fill_query>INSERT INTO mon_{table_suffix} (n) SELECT n FROM mon_{table_suffix}</fill_query>\n+    <fill_query>INSERT INTO rnd_{table_suffix} (n) SELECT n FROM rnd_{table_suffix}</fill_query>\n+    <fill_query>INSERT INTO seq_{table_suffix} (n) SELECT n FROM seq_{table_suffix}</fill_query>\n+    <fill_query>INSERT INTO mon_{table_suffix} (n) SELECT n FROM mon_{table_suffix}</fill_query>\n+    <fill_query>INSERT INTO rnd_{table_suffix} (n) SELECT n FROM rnd_{table_suffix}</fill_query>\n+    <fill_query>INSERT INTO seq_{table_suffix} (n) SELECT n FROM seq_{table_suffix}</fill_query>\n+    <fill_query>INSERT INTO mon_{table_suffix} (n) SELECT n FROM mon_{table_suffix}</fill_query>\n+    <fill_query>INSERT INTO rnd_{table_suffix} (n) SELECT n FROM rnd_{table_suffix}</fill_query>\n+\n+\n+    <query>INSERT INTO seq_{table_suffix} (n) SELECT number FROM system.numbers SETTINGS max_threads=1</query>\n+    <query>INSERT INTO mon_{table_suffix} (n) SELECT number*67+(rand()%67) FROM system.numbers SETTINGS max_threads=1</query>\n+    <query>INSERT INTO rnd_{table_suffix} (n) SELECT rand() FROM system.numbers SETTINGS max_threads=1</query>\n+\n+\n+    <query>SELECT count(n) FROM seq_{table_suffix} SETTINGS max_threads=1</query>\n+    <query>SELECT count(n) FROM mon_{table_suffix} SETTINGS max_threads=1</query>\n+    <query>SELECT count(n) FROM rnd_{table_suffix} SETTINGS max_threads=1</query>\n+\n+\n+    <drop_query>DROP TABLE IF EXISTS seq_{table_suffix}</drop_query>\n+    <drop_query>DROP TABLE IF EXISTS mon_{table_suffix}</drop_query>\n+    <drop_query>DROP TABLE IF EXISTS rnd_{table_suffix}</drop_query>\n+\n+</test>\ndiff --git a/dbms/tests/performance/codec_gorilla.xml b/dbms/tests/performance/codec_gorilla.xml\nnew file mode 100644\nindex 000000000000..ba7d6297349d\n--- /dev/null\n+++ b/dbms/tests/performance/codec_gorilla.xml\n@@ -0,0 +1,67 @@\n+<test>\n+    <name>IPv4 Functions</name>\n+\n+    <type>once</type>\n+    <stop_conditions>\n+        <any_of>\n+            <average_speed_not_changing_for_ms>1000</average_speed_not_changing_for_ms>\n+            <total_time_ms>2000</total_time_ms>\n+        </any_of>\n+    </stop_conditions>\n+\n+    <substitutions>\n+        <substitution>\n+            <name>table_suffix</name>\n+            <values>\n+                <value>g</value>\n+                <value>lz4</value>\n+                <value>g_lz4</value>\n+            </values>\n+        </substitution>\n+    </substitutions>\n+\n+    <create_query>CREATE TABLE IF NOT EXISTS seq_g (n UInt64 CODEC(Gorilla, NONE)) ENGINE = MergeTree PARTITION BY tuple() ORDER BY tuple();</create_query>\n+    <create_query>CREATE TABLE IF NOT EXISTS mon_g AS seq_g;</create_query>\n+    <create_query>CREATE TABLE IF NOT EXISTS rnd_g AS seq_g;</create_query>\n+\n+    <create_query>CREATE TABLE IF NOT EXISTS seq_lz4 (n UInt64 CODEC(LZ4, NONE)) ENGINE = MergeTree PARTITION BY tuple() ORDER BY tuple();</create_query>\n+    <create_query>CREATE TABLE IF NOT EXISTS mon_lz4 AS seq_lz4;</create_query>\n+    <create_query>CREATE TABLE IF NOT EXISTS rnd_lz4 AS seq_lz4;</create_query>\n+\n+    <create_query>CREATE TABLE IF NOT EXISTS seq_g_lz4 (n UInt64 CODEC(Gorilla, LZ4, NONE)) ENGINE = MergeTree PARTITION BY tuple() ORDER BY tuple();</create_query>\n+    <create_query>CREATE TABLE IF NOT EXISTS mon_g_lz4 AS seq_g_lz4;</create_query>\n+    <create_query>CREATE TABLE IF NOT EXISTS rnd_g_lz4 AS seq_g_lz4;</create_query>\n+\n+    <fill_query>INSERT INTO seq_{table_suffix} (n) SELECT number/pi() FROM system.numbers LIMIT 100000</fill_query>\n+    <fill_query>INSERT INTO mon_{table_suffix} (n) SELECT number+sin(number) FROM system.numbers LIMIT 100000</fill_query>\n+    <fill_query>INSERT INTO rnd_{table_suffix} (n) SELECT (rand() - 4294967295)/pi() FROM system.numbers LIMIT 100000</fill_query>\n+    \n+    <fill_query>INSERT INTO seq_{table_suffix} (n) SELECT n FROM seq_{table_suffix}</fill_query>\n+    <fill_query>INSERT INTO mon_{table_suffix} (n) SELECT n FROM mon_{table_suffix}</fill_query>\n+    <fill_query>INSERT INTO rnd_{table_suffix} (n) SELECT n FROM rnd_{table_suffix}</fill_query>\n+    <fill_query>INSERT INTO seq_{table_suffix} (n) SELECT n FROM seq_{table_suffix}</fill_query>\n+    <fill_query>INSERT INTO mon_{table_suffix} (n) SELECT n FROM mon_{table_suffix}</fill_query>\n+    <fill_query>INSERT INTO rnd_{table_suffix} (n) SELECT n FROM rnd_{table_suffix}</fill_query>\n+    <fill_query>INSERT INTO seq_{table_suffix} (n) SELECT n FROM seq_{table_suffix}</fill_query>\n+    <fill_query>INSERT INTO mon_{table_suffix} (n) SELECT n FROM mon_{table_suffix}</fill_query>\n+    <fill_query>INSERT INTO rnd_{table_suffix} (n) SELECT n FROM rnd_{table_suffix}</fill_query>\n+    <fill_query>INSERT INTO seq_{table_suffix} (n) SELECT n FROM seq_{table_suffix}</fill_query>\n+    <fill_query>INSERT INTO mon_{table_suffix} (n) SELECT n FROM mon_{table_suffix}</fill_query>\n+    <fill_query>INSERT INTO rnd_{table_suffix} (n) SELECT n FROM rnd_{table_suffix}</fill_query>\n+\n+\n+    <query>INSERT INTO seq_{table_suffix} (n) SELECT number/pi() FROM system.numbers SETTINGS max_threads=1</query>\n+    <query>INSERT INTO mon_{table_suffix} (n) SELECT number+sin(number) FROM system.numbers SETTINGS max_threads=1</query>\n+    <query>INSERT INTO rnd_{table_suffix} (n) SELECT (rand() - 4294967295)/pi() FROM system.numbers SETTINGS max_threads=1</query>\n+\n+\n+    <query>SELECT count(n) FROM seq_{table_suffix} SETTINGS max_threads=1</query>\n+    <query>SELECT count(n) FROM mon_{table_suffix} SETTINGS max_threads=1</query>\n+    <query>SELECT count(n) FROM rnd_{table_suffix} SETTINGS max_threads=1</query>\n+\n+\n+    <drop_query>DROP TABLE IF EXISTS seq_{table_suffix}</drop_query>\n+    <drop_query>DROP TABLE IF EXISTS mon_{table_suffix}</drop_query>\n+    <drop_query>DROP TABLE IF EXISTS rnd_{table_suffix}</drop_query>\n+\n+</test>\ndiff --git a/dbms/tests/queries/0_stateless/00950_test_double_delta_codec.reference b/dbms/tests/queries/0_stateless/00950_test_double_delta_codec.reference\nnew file mode 100644\nindex 000000000000..5fb3bfb36290\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/00950_test_double_delta_codec.reference\n@@ -0,0 +1,10 @@\n+U64\n+U32\n+U16\n+U8\n+I64\n+I32\n+I16\n+I8\n+DT\n+D\ndiff --git a/dbms/tests/queries/0_stateless/00950_test_double_delta_codec.sql b/dbms/tests/queries/0_stateless/00950_test_double_delta_codec.sql\nnew file mode 100644\nindex 000000000000..a5ae4766ece0\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/00950_test_double_delta_codec.sql\n@@ -0,0 +1,151 @@\n+USE test;\n+\n+DROP TABLE IF EXISTS codecTest;\n+\n+CREATE TABLE codecTest (\n+    key      UInt64,\n+    ref_valueU64 UInt64,\n+    ref_valueU32 UInt32,\n+    ref_valueU16 UInt16,\n+    ref_valueU8  UInt8,\n+    ref_valueI64 Int64,\n+    ref_valueI32 Int32,\n+    ref_valueI16 Int16,\n+    ref_valueI8  Int8,\n+    ref_valueDT  DateTime,\n+    ref_valueD   Date,\n+    valueU64 UInt64   CODEC(DoubleDelta),\n+    valueU32 UInt32   CODEC(DoubleDelta),\n+    valueU16 UInt16   CODEC(DoubleDelta),\n+    valueU8  UInt8    CODEC(DoubleDelta),\n+    valueI64 Int64    CODEC(DoubleDelta),\n+    valueI32 Int32    CODEC(DoubleDelta),\n+    valueI16 Int16    CODEC(DoubleDelta),\n+    valueI8  Int8     CODEC(DoubleDelta),\n+    valueDT  DateTime CODEC(DoubleDelta),\n+    valueD   Date     CODEC(DoubleDelta)\n+) Engine = MergeTree ORDER BY key;\n+\n+\n+-- checking for overflow\n+INSERT INTO codecTest (key, ref_valueU64, valueU64, ref_valueI64, valueI64)\n+\tVALUES (101, 18446744073709551615, 18446744073709551615, 9223372036854775807, 9223372036854775807), (202, 0, 0, -9223372036854775808, -9223372036854775808), (203, 18446744073709551615, 18446744073709551615, 9223372036854775807, 9223372036854775807);\n+\n+-- n^3 covers all double delta storage cases, from small difference between neighbouref_values (stride) to big.\n+INSERT INTO codecTest (key, ref_valueU64, valueU64, ref_valueU32, valueU32, ref_valueU16, valueU16, ref_valueU8, valueU8, ref_valueI64, valueI64, ref_valueI32, valueI32, ref_valueI16, valueI16, ref_valueI8, valueI8, ref_valueDT, valueDT, ref_valueD, valueD)\n+\tSELECT number as n, n * n * n as v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, toDateTime(v), toDateTime(v), toDate(v), toDate(v)\n+\tFROM system.numbers LIMIT 101, 100;\n+\n+-- best case - constant stride\n+INSERT INTO codecTest (key, ref_valueU64, valueU64, ref_valueU32, valueU32, ref_valueU16, valueU16, ref_valueU8, valueU8, ref_valueI64, valueI64, ref_valueI32, valueI32, ref_valueI16, valueI16, ref_valueI8, valueI8, ref_valueDT, valueDT, ref_valueD, valueD)\n+\tSELECT number as n, n as v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, toDateTime(v), toDateTime(v), toDate(v), toDate(v)\n+\tFROM system.numbers LIMIT 201, 100;\n+\n+\n+-- worst case - random stride\n+INSERT INTO codecTest (key, ref_valueU64, valueU64, ref_valueU32, valueU32, ref_valueU16, valueU16, ref_valueU8, valueU8, ref_valueI64, valueI64, ref_valueI32, valueI32, ref_valueI16, valueI16, ref_valueI8, valueI8, ref_valueDT, valueDT, ref_valueD, valueD)\n+\tSELECT number as n, n + (rand64() - 9223372036854775807)/1000 as v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, toDateTime(v), toDateTime(v), toDate(v), toDate(v)\n+\tFROM system.numbers LIMIT 301, 100;\n+\n+\n+SELECT 'U64';\n+SELECT\n+\tkey,\n+\tref_valueU64, valueU64, ref_valueU64 - valueU64 as dU64\n+FROM codecTest\n+WHERE\n+\tdU64 != 0\n+LIMIT 10;\n+\n+\n+SELECT 'U32';\n+SELECT\n+\tkey,\n+\tref_valueU32, valueU32, ref_valueU32 - valueU32 as dU32\n+FROM codecTest\n+WHERE\n+\tdU32 != 0\n+LIMIT 10;\n+\n+\n+SELECT 'U16';\n+SELECT\n+\tkey,\n+\tref_valueU16, valueU16, ref_valueU16 - valueU16 as dU16\n+FROM codecTest\n+WHERE\n+\tdU16 != 0\n+LIMIT 10;\n+\n+\n+SELECT 'U8';\n+SELECT\n+\tkey,\n+\tref_valueU8, valueU8, ref_valueU8 - valueU8 as dU8\n+FROM codecTest\n+WHERE\n+\tdU8 != 0\n+LIMIT 10;\n+\n+\n+SELECT 'I64';\n+SELECT\n+\tkey,\n+\tref_valueI64, valueI64, ref_valueI64 - valueI64 as dI64\n+FROM codecTest\n+WHERE\n+\tdI64 != 0\n+LIMIT 10;\n+\n+\n+SELECT 'I32';\n+SELECT\n+\tkey,\n+\tref_valueI32, valueI32, ref_valueI32 - valueI32 as dI32\n+FROM codecTest\n+WHERE\n+\tdI32 != 0\n+LIMIT 10;\n+\n+\n+SELECT 'I16';\n+SELECT\n+\tkey,\n+\tref_valueI16, valueI16, ref_valueI16 - valueI16 as dI16\n+FROM codecTest\n+WHERE\n+\tdI16 != 0\n+LIMIT 10;\n+\n+\n+SELECT 'I8';\n+SELECT\n+\tkey,\n+\tref_valueI8, valueI8, ref_valueI8 - valueI8 as dI8\n+FROM codecTest\n+WHERE\n+\tdI8 != 0\n+LIMIT 10;\n+\n+\n+SELECT 'DT';\n+SELECT\n+\tkey,\n+\tref_valueDT, valueDT, ref_valueDT - valueDT as dDT\n+FROM codecTest\n+WHERE\n+\tdDT != 0\n+LIMIT 10;\n+\n+\n+SELECT 'D';\n+SELECT\n+\tkey,\n+\tref_valueD, valueD, ref_valueD - valueD as dD\n+FROM codecTest\n+WHERE\n+\tdD != 0\n+LIMIT 10;\n+\n+\n+DROP TABLE IF EXISTS codecTest;\n\\ No newline at end of file\ndiff --git a/dbms/tests/queries/0_stateless/00950_test_gorilla_codec.reference b/dbms/tests/queries/0_stateless/00950_test_gorilla_codec.reference\nnew file mode 100644\nindex 000000000000..5e871ea03295\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/00950_test_gorilla_codec.reference\n@@ -0,0 +1,2 @@\n+F64\n+F32\ndiff --git a/dbms/tests/queries/0_stateless/00950_test_gorilla_codec.sql b/dbms/tests/queries/0_stateless/00950_test_gorilla_codec.sql\nnew file mode 100644\nindex 000000000000..c4975cdcb5de\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/00950_test_gorilla_codec.sql\n@@ -0,0 +1,63 @@\n+USE test;\n+\n+DROP TABLE IF EXISTS codecTest;\n+\n+CREATE TABLE codecTest (\n+    key      UInt64,\n+    name     String,\n+    ref_valueF64 Float64,\n+    ref_valueF32 Float32,\n+    valueF64 Float64  CODEC(Gorilla),\n+    valueF32 Float32  CODEC(Gorilla)\n+) Engine = MergeTree ORDER BY key;\n+\n+-- best case - same value\n+INSERT INTO codecTest (key, name, ref_valueF64, valueF64, ref_valueF32, valueF32)\n+\tSELECT number AS n, 'e()', e() AS v, v, v, v FROM system.numbers LIMIT 1, 100;\n+\n+-- good case - values that grow insignificantly\n+INSERT INTO codecTest (key, name, ref_valueF64, valueF64, ref_valueF32, valueF32)\n+\tSELECT number AS n, 'log2(n)', log2(n) AS v, v, v, v FROM system.numbers LIMIT 101, 100;\n+\n+-- bad case - values differ significantly\n+INSERT INTO codecTest (key, name, ref_valueF64, valueF64, ref_valueF32, valueF32)\n+\tSELECT number AS n, 'n*sqrt(n)', n*sqrt(n) AS v, v, v, v FROM system.numbers LIMIT 201, 100;\n+\n+-- worst case - almost like a random values\n+INSERT INTO codecTest (key, name, ref_valueF64, valueF64, ref_valueF32, valueF32)\n+\tSELECT number AS n, 'sin(n*n*n)*n', sin(n * n * n * n* n) AS v, v, v, v FROM system.numbers LIMIT 301, 100;\n+\n+\n+-- These floating-point values are expected to be BINARY equal, so comparing by-value is Ok here.\n+\n+-- referencing previous row key, value, and case name to simplify debugging.\n+SELECT 'F64';\n+SELECT\n+\tc1.key, c1.name,\n+\tc1.ref_valueF64, c1.valueF64, c1.ref_valueF64 - c1.valueF64 AS dF64,\n+\t'prev:',\n+\tc2.key, c2.ref_valueF64\n+FROM\n+\tcodecTest as c1, codecTest as c2\n+WHERE\n+\tdF64 != 0\n+AND\n+\tc2.key = c1.key - 1\n+LIMIT 10;\n+\n+\n+SELECT 'F32';\n+SELECT\n+\tc1.key, c1.name,\n+\tc1.ref_valueF32, c1.valueF32, c1.ref_valueF32 - c1.valueF32 AS dF32,\n+\t'prev:',\n+\tc2.key, c2.ref_valueF32\n+FROM\n+\tcodecTest as c1, codecTest as c2\n+WHERE\n+\tdF32 != 0\n+AND\n+\tc2.key = c1.key - 1\n+LIMIT 10;\n+\n+DROP TABLE IF EXISTS codecTest;\n\\ No newline at end of file\n",
  "problem_statement": "Repair subtree2\n\n",
  "hints_text": "",
  "created_at": "2019-06-13T06:58:54Z"
}