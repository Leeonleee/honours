{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 56738,
  "instance_id": "ClickHouse__ClickHouse-56738",
  "issue_numbers": [
    "55619"
  ],
  "base_commit": "3946dbd8831cf67536197d2a8328d01cb62bd26e",
  "patch": "diff --git a/docs/en/sql-reference/functions/date-time-functions.md b/docs/en/sql-reference/functions/date-time-functions.md\nindex b65fb3d7e957..31f7c31f04c8 100644\n--- a/docs/en/sql-reference/functions/date-time-functions.md\n+++ b/docs/en/sql-reference/functions/date-time-functions.md\n@@ -1617,8 +1617,19 @@ The calculation is performed relative to specific points in time:\n \n If unit `WEEK` was specified, `toStartOfInterval` assumes that weeks start on Monday. Note that this behavior is different from that of function `toStartOfWeek` in which weeks start by default on Sunday.\n \n-**See Also**\n+**Syntax**\n+\n+```sql\n+toStartOfInterval(value, INTERVAL x unit[, time_zone])\n+toStartOfInterval(value, INTERVAL x unit[, origin[, time_zone]])\n+```\n \n+The second overload emulates TimescaleDB's `time_bucket()` function, respectively PostgreSQL's `date_bin()` function, e.g.\n+\n+``` SQL\n+SELECT toStartOfInterval(toDateTime('2023-01-01 14:45:00'), INTERVAL 1 MINUTE, toDateTime('2023-01-01 14:35:30'));\n+```\n+**See Also**\n - [date_trunc](#date_trunc)\n \n ## toTime\n@@ -3884,19 +3895,29 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n-## timeSlots(StartTime, Duration,\\[, Size\\])\n+## timeSlots\n \n For a time interval starting at \u2018StartTime\u2019 and continuing for \u2018Duration\u2019 seconds, it returns an array of moments in time, consisting of points from this interval rounded down to the \u2018Size\u2019 in seconds. \u2018Size\u2019 is an optional parameter set to 1800 (30 minutes) by default.\n This is necessary, for example, when searching for pageviews in the corresponding session.\n Accepts DateTime and DateTime64 as \u2019StartTime\u2019 argument. For DateTime, \u2019Duration\u2019 and \u2019Size\u2019 arguments must be `UInt32`. For \u2019DateTime64\u2019 they must be `Decimal64`.\n Returns an array of DateTime/DateTime64 (return type matches the type of \u2019StartTime\u2019). For DateTime64, the return value's scale can differ from the scale of \u2019StartTime\u2019 --- the highest scale among all given arguments is taken.\n \n-Example:\n+**Syntax**\n+\n+```sql\n+timeSlots(StartTime, Duration,\\[, Size\\])\n+```\n+\n+**Example**\n+\n ```sql\n SELECT timeSlots(toDateTime('2012-01-01 12:20:00'), toUInt32(600));\n SELECT timeSlots(toDateTime('1980-12-12 21:01:02', 'UTC'), toUInt32(600), 299);\n SELECT timeSlots(toDateTime64('1980-12-12 21:01:02.1234', 4, 'UTC'), toDecimal64(600.1, 1), toDecimal64(299, 0));\n ```\n+\n+Result:\n+\n ``` text\n \u250c\u2500timeSlots(toDateTime('2012-01-01 12:20:00'), toUInt32(600))\u2500\u2510\n \u2502 ['2012-01-01 12:00:00','2012-01-01 12:30:00']               \u2502\ndiff --git a/src/Functions/DateTimeTransforms.h b/src/Functions/DateTimeTransforms.h\nindex dfb4b76e5e21..d6d533f16edc 100644\n--- a/src/Functions/DateTimeTransforms.h\n+++ b/src/Functions/DateTimeTransforms.h\n@@ -492,7 +492,7 @@ struct ToStartOfInterval<IntervalKind::Kind::Nanosecond>\n     {\n         throwDateTimeIsNotSupported(TO_START_OF_INTERVAL_NAME);\n     }\n-    static Int64 execute(Int64 t, Int64 nanoseconds, const DateLUTImpl &, Int64 scale_multiplier)\n+    static Int64 execute(Int64 t, Int64 nanoseconds, const DateLUTImpl &, Int64 scale_multiplier, Int64 /*origin*/ = 0)\n     {\n         if (scale_multiplier < 1000000000)\n         {\n@@ -527,7 +527,7 @@ struct ToStartOfInterval<IntervalKind::Kind::Microsecond>\n     {\n         throwDateTimeIsNotSupported(TO_START_OF_INTERVAL_NAME);\n     }\n-    static Int64 execute(Int64 t, Int64 microseconds, const DateLUTImpl &, Int64 scale_multiplier)\n+    static Int64 execute(Int64 t, Int64 microseconds, const DateLUTImpl &, Int64 scale_multiplier, Int64 /*origin*/ = 0)\n     {\n         if (scale_multiplier < 1000000)\n         {\n@@ -570,7 +570,7 @@ struct ToStartOfInterval<IntervalKind::Kind::Millisecond>\n     {\n         throwDateTimeIsNotSupported(TO_START_OF_INTERVAL_NAME);\n     }\n-    static Int64 execute(Int64 t, Int64 milliseconds, const DateLUTImpl &, Int64 scale_multiplier)\n+    static Int64 execute(Int64 t, Int64 milliseconds, const DateLUTImpl &, Int64 scale_multiplier, Int64 /*origin*/ = 0)\n     {\n         if (scale_multiplier < 1000)\n         {\n@@ -613,7 +613,7 @@ struct ToStartOfInterval<IntervalKind::Kind::Second>\n     {\n         return time_zone.toStartOfSecondInterval(t, seconds);\n     }\n-    static Int64 execute(Int64 t, Int64 seconds, const DateLUTImpl & time_zone, Int64 scale_multiplier)\n+    static Int64 execute(Int64 t, Int64 seconds, const DateLUTImpl & time_zone, Int64 scale_multiplier, Int64 /*origin*/ = 0)\n     {\n         return time_zone.toStartOfSecondInterval(t / scale_multiplier, seconds);\n     }\n@@ -634,7 +634,7 @@ struct ToStartOfInterval<IntervalKind::Kind::Minute>\n     {\n         return time_zone.toStartOfMinuteInterval(t, minutes);\n     }\n-    static Int64 execute(Int64 t, Int64 minutes, const DateLUTImpl & time_zone, Int64 scale_multiplier)\n+    static Int64 execute(Int64 t, Int64 minutes, const DateLUTImpl & time_zone, Int64 scale_multiplier, Int64 /*origin*/ = 0)\n     {\n         return time_zone.toStartOfMinuteInterval(t / scale_multiplier, minutes);\n     }\n@@ -655,7 +655,7 @@ struct ToStartOfInterval<IntervalKind::Kind::Hour>\n     {\n         return time_zone.toStartOfHourInterval(t, hours);\n     }\n-    static Int64 execute(Int64 t, Int64 hours, const DateLUTImpl & time_zone, Int64 scale_multiplier)\n+    static Int64 execute(Int64 t, Int64 hours, const DateLUTImpl & time_zone, Int64 scale_multiplier, Int64 /*origin*/ = 0)\n     {\n         return time_zone.toStartOfHourInterval(t / scale_multiplier, hours);\n     }\n@@ -676,7 +676,7 @@ struct ToStartOfInterval<IntervalKind::Kind::Day>\n     {\n         return static_cast<UInt32>(time_zone.toStartOfDayInterval(time_zone.toDayNum(t), days));\n     }\n-    static Int64 execute(Int64 t, Int64 days, const DateLUTImpl & time_zone, Int64 scale_multiplier)\n+    static Int64 execute(Int64 t, Int64 days, const DateLUTImpl & time_zone, Int64 scale_multiplier, Int64 /*origin*/ = 0)\n     {\n         return time_zone.toStartOfDayInterval(time_zone.toDayNum(t / scale_multiplier), days);\n     }\n@@ -697,9 +697,13 @@ struct ToStartOfInterval<IntervalKind::Kind::Week>\n     {\n         return time_zone.toStartOfWeekInterval(time_zone.toDayNum(t), weeks);\n     }\n-    static UInt16 execute(Int64 t, Int64 weeks, const DateLUTImpl & time_zone, Int64 scale_multiplier)\n+    static Int64 execute(Int64 t, Int64 weeks, const DateLUTImpl & time_zone, Int64 scale_multiplier, Int64 origin = 0)\n     {\n-        return time_zone.toStartOfWeekInterval(time_zone.toDayNum(t / scale_multiplier), weeks);\n+        if (origin == 0)\n+            return time_zone.toStartOfWeekInterval(time_zone.toDayNum(t / scale_multiplier), weeks);\n+        else\n+            return ToStartOfInterval<IntervalKind::Kind::Day>::execute(t, weeks * 7, time_zone, scale_multiplier, origin);\n+\n     }\n };\n \n@@ -718,9 +722,23 @@ struct ToStartOfInterval<IntervalKind::Kind::Month>\n     {\n         return time_zone.toStartOfMonthInterval(time_zone.toDayNum(t), months);\n     }\n-    static UInt16 execute(Int64 t, Int64 months, const DateLUTImpl & time_zone, Int64 scale_multiplier)\n+    static Int64 execute(Int64 t, Int64 months, const DateLUTImpl & time_zone, Int64 scale_multiplier, Int64 origin = 0)\n     {\n-        return time_zone.toStartOfMonthInterval(time_zone.toDayNum(t / scale_multiplier), months);\n+        const Int64 scaled_time = t / scale_multiplier;\n+        if (origin == 0)\n+            return time_zone.toStartOfMonthInterval(time_zone.toDayNum(scaled_time), months);\n+        else\n+        {\n+            const Int64 scaled_origin = origin / scale_multiplier;\n+            const Int64 days = time_zone.toDayOfMonth(scaled_time + scaled_origin) - time_zone.toDayOfMonth(scaled_origin);\n+            Int64 months_to_add = time_zone.toMonth(scaled_time + scaled_origin) - time_zone.toMonth(scaled_origin);\n+            const Int64 years = time_zone.toYear(scaled_time + scaled_origin) - time_zone.toYear(scaled_origin);\n+            months_to_add = days < 0 ? months_to_add - 1 : months_to_add;\n+            months_to_add += years * 12;\n+            Int64 month_multiplier = (months_to_add / months) * months;\n+\n+            return (time_zone.addMonths(time_zone.toDate(scaled_origin), month_multiplier) - time_zone.toDate(scaled_origin));\n+        }\n     }\n };\n \n@@ -739,9 +757,12 @@ struct ToStartOfInterval<IntervalKind::Kind::Quarter>\n     {\n         return time_zone.toStartOfQuarterInterval(time_zone.toDayNum(t), quarters);\n     }\n-    static UInt16 execute(Int64 t, Int64 quarters, const DateLUTImpl & time_zone, Int64 scale_multiplier)\n+    static Int64 execute(Int64 t, Int64 quarters, const DateLUTImpl & time_zone, Int64 scale_multiplier, Int64 origin = 0)\n     {\n-        return time_zone.toStartOfQuarterInterval(time_zone.toDayNum(t / scale_multiplier), quarters);\n+        if (origin == 0)\n+            return time_zone.toStartOfQuarterInterval(time_zone.toDayNum(t / scale_multiplier), quarters);\n+        else\n+            return ToStartOfInterval<IntervalKind::Kind::Month>::execute(t, quarters * 3, time_zone, scale_multiplier, origin);\n     }\n };\n \n@@ -760,9 +781,12 @@ struct ToStartOfInterval<IntervalKind::Kind::Year>\n     {\n         return time_zone.toStartOfYearInterval(time_zone.toDayNum(t), years);\n     }\n-    static UInt16 execute(Int64 t, Int64 years, const DateLUTImpl & time_zone, Int64 scale_multiplier)\n+    static Int64 execute(Int64 t, Int64 years, const DateLUTImpl & time_zone, Int64 scale_multiplier, Int64 origin = 0)\n     {\n-        return time_zone.toStartOfYearInterval(time_zone.toDayNum(t / scale_multiplier), years);\n+        if (origin == 0)\n+            return time_zone.toStartOfYearInterval(time_zone.toDayNum(t / scale_multiplier), years);\n+        else\n+            return ToStartOfInterval<IntervalKind::Kind::Month>::execute(t, years * 12, time_zone, scale_multiplier, origin);\n     }\n };\n \ndiff --git a/src/Functions/toStartOfInterval.cpp b/src/Functions/toStartOfInterval.cpp\nindex 709f5f86d80e..6573fef66341 100644\n--- a/src/Functions/toStartOfInterval.cpp\n+++ b/src/Functions/toStartOfInterval.cpp\n@@ -10,21 +10,31 @@\n #include <Functions/FunctionFactory.h>\n #include <Functions/IFunction.h>\n #include <IO/WriteHelpers.h>\n+#include <algorithm>\n \n \n namespace DB\n {\n namespace ErrorCodes\n {\n-    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+    extern const int ARGUMENT_OUT_OF_BOUND;\n+    extern const int BAD_ARGUMENTS;\n     extern const int ILLEGAL_COLUMN;\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n-    extern const int ARGUMENT_OUT_OF_BOUND;\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n }\n \n \n class FunctionToStartOfInterval : public IFunction\n {\n+private:\n+    enum class Overload\n+    {\n+        Default,    /// toStartOfInterval(time, interval) or toStartOfInterval(time, interval, timezone)\n+        Origin      /// toStartOfInterval(time, interval, origin) or toStartOfInterval(time, interval, origin, timezone)\n+    };\n+    mutable Overload overload;\n+\n public:\n     static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionToStartOfInterval>(); }\n \n@@ -34,7 +44,7 @@ class FunctionToStartOfInterval : public IFunction\n     size_t getNumberOfArguments() const override { return 0; }\n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n     bool useDefaultImplementationForConstants() const override { return true; }\n-    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1, 2}; }\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1, 2, 3}; }\n     bool hasInformationAboutMonotonicity() const override { return true; }\n     Monotonicity getMonotonicityForRange(const IDataType &, const Field &, const Field &) const override { return { .is_monotonic = true, .is_always_monotonic = true }; }\n \n@@ -72,6 +82,9 @@ class FunctionToStartOfInterval : public IFunction\n                     \"Illegal type {} of 2nd argument of function {}, expected a time interval\",\n                     type_arg2->getName(), getName());\n \n+            overload = Overload::Default;\n+\n+            /// Determine result type for default overload (no origin)\n             switch (interval_type->getKind()) // NOLINT(bugprone-switch-missing-default-case)\n             {\n                 case IntervalKind::Kind::Nanosecond:\n@@ -97,13 +110,49 @@ class FunctionToStartOfInterval : public IFunction\n         auto check_third_argument = [&]\n         {\n             const DataTypePtr & type_arg3 = arguments[2].type;\n-            if (!isString(type_arg3))\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                    \"Illegal type {} of 3rd argument of function {}, expected a constant timezone string\",\n+            if (isString(type_arg3))\n+            {\n+                if (value_is_date && result_type == ResultType::Date)\n+                    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                        \"A timezone argument of function {} with interval type {} is allowed only when the 1st argument has the type DateTime or DateTime64\",\n+                        getName(), interval_type->getKind().toString());\n+            }\n+            else if (isDateOrDate32OrDateTimeOrDateTime64(type_arg3))\n+            {\n+                overload = Overload::Origin;\n+                const DataTypePtr & type_arg1 = arguments[0].type;\n+                if (isDate(type_arg1) && isDate(type_arg3))\n+                    result_type = ResultType::Date;\n+                else if (isDate32(type_arg1) && isDate32(type_arg3))\n+                    result_type = ResultType::Date32;\n+                else if (isDateTime(type_arg1) && isDateTime(type_arg3))\n+                    result_type = ResultType::DateTime;\n+                else if (isDateTime64(type_arg1) && isDateTime64(type_arg3))\n+                    result_type = ResultType::DateTime64;\n+                else\n+                    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Datetime argument and origin argument for function {} must have the same type\", getName());\n+            }\n+            else\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of 3rd argument of function {}. \"\n+                    \"This argument is optional and must be a constant String with timezone name or a Date/Date32/DateTime/DateTime64 with a constant origin\",\n                     type_arg3->getName(), getName());\n-            if (value_is_date && result_type == ResultType::Date) /// weird why this is && instead of || but too afraid to change it\n+        };\n+\n+        auto check_fourth_argument = [&]\n+        {\n+            if (overload != Overload::Origin) /// sanity check\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of 3rd argument of function {}. \"\n+                    \"The third argument must a Date/Date32/DateTime/DateTime64 with a constant origin\",\n+                    arguments[2].type->getName(), getName());\n+\n+            const DataTypePtr & type_arg4 = arguments[3].type;\n+            if (!isString(type_arg4))\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of 4th argument of function {}. \"\n+                    \"This argument is optional and must be a constant String with timezone name\",\n+                    type_arg4->getName(), getName());\n+            if (value_is_date && result_type == ResultType::Date)\n                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                    \"The timezone argument of function {} with interval type {} is allowed only when the 1st argument has type DateTime or DateTimt64\",\n+                    \"A timezone argument of function {} with interval type {} is allowed only when the 1st argument has the type DateTime or DateTime64\",\n                     getName(), interval_type->getKind().toString());\n         };\n \n@@ -118,10 +167,17 @@ class FunctionToStartOfInterval : public IFunction\n             check_second_argument();\n             check_third_argument();\n         }\n+        else if (arguments.size() == 4)\n+        {\n+            check_first_argument();\n+            check_second_argument();\n+            check_third_argument();\n+            check_fourth_argument();\n+        }\n         else\n         {\n             throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n-                \"Number of arguments for function {} doesn't match: passed {}, should be 2 or 3\",\n+                \"Number of arguments for function {} doesn't match: passed {}, must be 2, 3 or 4\",\n                 getName(), arguments.size());\n         }\n \n@@ -132,10 +188,19 @@ class FunctionToStartOfInterval : public IFunction\n             case ResultType::Date32:\n                 return std::make_shared<DataTypeDate32>();\n             case ResultType::DateTime:\n-                return std::make_shared<DataTypeDateTime>(extractTimeZoneNameFromFunctionArguments(arguments, 2, 0, false));\n+            {\n+                const size_t time_zone_arg_num = (overload == Overload::Default) ? 2 : 3;\n+                return std::make_shared<DataTypeDateTime>(extractTimeZoneNameFromFunctionArguments(arguments, time_zone_arg_num, 0, false));\n+            }\n             case ResultType::DateTime64:\n             {\n                 UInt32 scale = 0;\n+                if (isDateTime64(arguments[0].type) && overload == Overload::Origin)\n+                {\n+                    scale = assert_cast<const DataTypeDateTime64 &>(*arguments[0].type.get()).getScale();\n+                    if (assert_cast<const DataTypeDateTime64 &>(*arguments[2].type.get()).getScale() != scale)\n+                        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Datetime argument and origin argument for function {} must have the same scale\", getName());\n+                }\n                 if (interval_type->getKind() == IntervalKind::Kind::Nanosecond)\n                     scale = 9;\n                 else if (interval_type->getKind() == IntervalKind::Kind::Microsecond)\n@@ -143,69 +208,103 @@ class FunctionToStartOfInterval : public IFunction\n                 else if (interval_type->getKind() == IntervalKind::Kind::Millisecond)\n                     scale = 3;\n \n-                return std::make_shared<DataTypeDateTime64>(scale, extractTimeZoneNameFromFunctionArguments(arguments, 2, 0, false));\n+                const size_t time_zone_arg_num = (overload == Overload::Default) ? 2 : 3;\n+                return std::make_shared<DataTypeDateTime64>(scale, extractTimeZoneNameFromFunctionArguments(arguments, time_zone_arg_num, 0, false));\n             }\n         }\n \n         std::unreachable();\n     }\n \n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t /* input_rows_count */) const override\n     {\n         const auto & time_column = arguments[0];\n         const auto & interval_column = arguments[1];\n-        const auto & time_zone = extractTimeZoneFromFunctionArguments(arguments, 2, 0);\n-        auto result_column = dispatchForTimeColumn(time_column, interval_column, result_type, time_zone, input_rows_count);\n+\n+        ColumnWithTypeAndName origin_column;\n+        if (overload == Overload::Origin)\n+            origin_column = arguments[2];\n+\n+        const size_t time_zone_arg_num = (overload == Overload::Default) ? 2 : 3;\n+        const auto & time_zone = extractTimeZoneFromFunctionArguments(arguments, time_zone_arg_num, 0);\n+\n+        ColumnPtr result_column;\n+        if (isDate(result_type))\n+            result_column = dispatchForTimeColumn<DataTypeDate>(time_column, interval_column, origin_column, result_type, time_zone);\n+        else if (isDate32(result_type))\n+            result_column = dispatchForTimeColumn<DataTypeDate32>(time_column, interval_column, origin_column, result_type, time_zone);\n+        else if (isDateTime(result_type))\n+            result_column = dispatchForTimeColumn<DataTypeDateTime>(time_column, interval_column, origin_column, result_type, time_zone);\n+        else if (isDateTime64(result_type))\n+            result_column = dispatchForTimeColumn<DataTypeDateTime64>(time_column, interval_column, origin_column, result_type, time_zone);\n         return result_column;\n     }\n \n private:\n+    template <typename ReturnType>\n     ColumnPtr dispatchForTimeColumn(\n-        const ColumnWithTypeAndName & time_column, const ColumnWithTypeAndName & interval_column,\n-        const DataTypePtr & result_type, const DateLUTImpl & time_zone,\n-        size_t input_rows_count) const\n+        const ColumnWithTypeAndName & time_column, const ColumnWithTypeAndName & interval_column, const ColumnWithTypeAndName & origin_column, const DataTypePtr & result_type, const DateLUTImpl & time_zone) const\n     {\n         const auto & time_column_type = *time_column.type.get();\n         const auto & time_column_col = *time_column.column.get();\n \n-        if (isDateTime64(time_column_type))\n+        if (isDate(time_column_type))\n         {\n-            const auto * time_column_vec = checkAndGetColumn<ColumnDateTime64>(&time_column_col);\n-            auto scale = assert_cast<const DataTypeDateTime64 &>(time_column_type).getScale();\n+            const auto * time_column_vec = checkAndGetColumn<ColumnDate>(&time_column_col);\n \n             if (time_column_vec)\n-                return dispatchForIntervalColumn(assert_cast<const DataTypeDateTime64 &>(time_column_type), *time_column_vec, interval_column, result_type, time_zone, input_rows_count, scale);\n+                return dispatchForIntervalColumn<ReturnType, DataTypeDate, ColumnDate>(assert_cast<const DataTypeDate &>(time_column_type), *time_column_vec, interval_column, origin_column, result_type, time_zone);\n         }\n-        else if (isDateTime(time_column_type))\n+        else if (isDate32(time_column_type))\n         {\n-            const auto * time_column_vec = checkAndGetColumn<ColumnDateTime>(&time_column_col);\n+            const auto * time_column_vec = checkAndGetColumn<ColumnDate32>(&time_column_col);\n             if (time_column_vec)\n-                return dispatchForIntervalColumn(assert_cast<const DataTypeDateTime &>(time_column_type), *time_column_vec, interval_column, result_type, time_zone, input_rows_count);\n+                return dispatchForIntervalColumn<ReturnType, DataTypeDate32, ColumnDate32>(assert_cast<const DataTypeDate32 &>(time_column_type), *time_column_vec, interval_column, origin_column, result_type, time_zone);\n         }\n-        else if (isDate(time_column_type))\n+        else if (isDateTime(time_column_type))\n         {\n-            const auto * time_column_vec = checkAndGetColumn<ColumnDate>(&time_column_col);\n+            const auto * time_column_vec = checkAndGetColumn<ColumnDateTime>(&time_column_col);\n             if (time_column_vec)\n-                return dispatchForIntervalColumn(assert_cast<const DataTypeDate &>(time_column_type), *time_column_vec, interval_column, result_type, time_zone, input_rows_count);\n+                return dispatchForIntervalColumn<ReturnType, DataTypeDateTime, ColumnDateTime>(assert_cast<const DataTypeDateTime &>(time_column_type), *time_column_vec, interval_column, origin_column, result_type, time_zone);\n         }\n-        else if (isDate32(time_column_type))\n+        else if (isDateTime64(time_column_type))\n         {\n-            const auto * time_column_vec = checkAndGetColumn<ColumnDate32>(&time_column_col);\n+            const auto * time_column_vec = checkAndGetColumn<ColumnDateTime64>(&time_column_col);\n+            auto scale = assert_cast<const DataTypeDateTime64 &>(time_column_type).getScale();\n+\n             if (time_column_vec)\n-                return dispatchForIntervalColumn(assert_cast<const DataTypeDate32 &>(time_column_type), *time_column_vec, interval_column, result_type, time_zone, input_rows_count);\n+                return dispatchForIntervalColumn<ReturnType, DataTypeDateTime64, ColumnDateTime64>(assert_cast<const DataTypeDateTime64 &>(time_column_type), *time_column_vec, interval_column, origin_column, result_type, time_zone, scale);\n         }\n         throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal column for 1st argument of function {}, expected a Date, Date32, DateTime or DateTime64\", getName());\n     }\n \n-    template <typename TimeDataType, typename TimeColumnType>\n+    template <typename ReturnType, typename TimeDataType, typename TimeColumnType>\n     ColumnPtr dispatchForIntervalColumn(\n-        const TimeDataType & time_data_type, const TimeColumnType & time_column, const ColumnWithTypeAndName & interval_column,\n-        const DataTypePtr & result_type, const DateLUTImpl & time_zone, size_t input_rows_count, UInt16 scale = 1) const\n+        const TimeDataType & time_data_type, const TimeColumnType & time_column, const ColumnWithTypeAndName & interval_column, const ColumnWithTypeAndName & origin_column,\n+        const DataTypePtr & result_type, const DateLUTImpl & time_zone, UInt16 scale = 1) const\n     {\n         const auto * interval_type = checkAndGetDataType<DataTypeInterval>(interval_column.type.get());\n         if (!interval_type)\n             throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column for 2nd argument of function {}, must be a time interval\", getName());\n \n+        switch (interval_type->getKind()) // NOLINT(bugprone-switch-missing-default-case)\n+        {\n+            case IntervalKind::Kind::Nanosecond:\n+            case IntervalKind::Kind::Microsecond:\n+            case IntervalKind::Kind::Millisecond:\n+                if (isDateOrDate32(time_data_type) || isDateTime(time_data_type))\n+                    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal interval kind for argument data type {}\", isDate(time_data_type) ? \"Date\" : \"DateTime\");\n+                break;\n+            case IntervalKind::Kind::Second:\n+            case IntervalKind::Kind::Minute:\n+            case IntervalKind::Kind::Hour:\n+                if (isDateOrDate32(time_data_type))\n+                    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal interval kind for argument data type Date\");\n+                break;\n+            default:\n+                break;\n+        }\n+\n         const auto * interval_column_const_int64 = checkAndGetColumnConst<ColumnInt64>(interval_column.column.get());\n         if (!interval_column_const_int64)\n             throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column for 2nd argument of function {}, must be a const time interval\", getName());\n@@ -217,51 +316,102 @@ class FunctionToStartOfInterval : public IFunction\n         switch (interval_type->getKind()) // NOLINT(bugprone-switch-missing-default-case)\n         {\n             case IntervalKind::Kind::Nanosecond:\n-                return execute<TimeDataType, TimeColumnType, DataTypeDateTime64, IntervalKind::Kind::Nanosecond>(time_data_type, time_column, num_units, result_type, time_zone, input_rows_count, scale);\n+                return execute<ReturnType, TimeDataType, TimeColumnType, IntervalKind::Kind::Nanosecond>(time_data_type, time_column, num_units, origin_column, result_type, time_zone, scale);\n             case IntervalKind::Kind::Microsecond:\n-                return execute<TimeDataType, TimeColumnType, DataTypeDateTime64, IntervalKind::Kind::Microsecond>(time_data_type, time_column, num_units, result_type, time_zone, input_rows_count, scale);\n+                return execute<ReturnType, TimeDataType, TimeColumnType, IntervalKind::Kind::Microsecond>(time_data_type, time_column, num_units, origin_column, result_type, time_zone, scale);\n             case IntervalKind::Kind::Millisecond:\n-                return execute<TimeDataType, TimeColumnType, DataTypeDateTime64, IntervalKind::Kind::Millisecond>(time_data_type, time_column, num_units, result_type, time_zone, input_rows_count, scale);\n+                return execute<ReturnType, TimeDataType, TimeColumnType, IntervalKind::Kind::Millisecond>(time_data_type, time_column, num_units, origin_column, result_type, time_zone, scale);\n             case IntervalKind::Kind::Second:\n-                return execute<TimeDataType, TimeColumnType, DataTypeDateTime, IntervalKind::Kind::Second>(time_data_type, time_column, num_units, result_type, time_zone, input_rows_count, scale);\n+                return execute<ReturnType, TimeDataType, TimeColumnType, IntervalKind::Kind::Second>(time_data_type, time_column, num_units, origin_column, result_type, time_zone, scale);\n             case IntervalKind::Kind::Minute:\n-                return execute<TimeDataType, TimeColumnType, DataTypeDateTime, IntervalKind::Kind::Minute>(time_data_type, time_column, num_units, result_type, time_zone, input_rows_count, scale);\n+                return execute<ReturnType, TimeDataType, TimeColumnType, IntervalKind::Kind::Minute>(time_data_type, time_column, num_units, origin_column, result_type, time_zone, scale);\n             case IntervalKind::Kind::Hour:\n-                return execute<TimeDataType, TimeColumnType, DataTypeDateTime, IntervalKind::Kind::Hour>(time_data_type, time_column, num_units, result_type, time_zone, input_rows_count, scale);\n+                return execute<ReturnType, TimeDataType, TimeColumnType, IntervalKind::Kind::Hour>(time_data_type, time_column, num_units, origin_column, result_type, time_zone, scale);\n             case IntervalKind::Kind::Day:\n-                return execute<TimeDataType, TimeColumnType, DataTypeDateTime, IntervalKind::Kind::Day>(time_data_type, time_column, num_units, result_type, time_zone, input_rows_count, scale);\n+                return execute<ReturnType, TimeDataType, TimeColumnType, IntervalKind::Kind::Day>(time_data_type, time_column, num_units, origin_column, result_type, time_zone, scale);\n             case IntervalKind::Kind::Week:\n-                return execute<TimeDataType, TimeColumnType, DataTypeDate, IntervalKind::Kind::Week>(time_data_type, time_column, num_units, result_type, time_zone, input_rows_count, scale);\n+                return execute<ReturnType, TimeDataType, TimeColumnType, IntervalKind::Kind::Week>(time_data_type, time_column, num_units, origin_column, result_type, time_zone, scale);\n             case IntervalKind::Kind::Month:\n-                return execute<TimeDataType, TimeColumnType, DataTypeDate, IntervalKind::Kind::Month>(time_data_type, time_column, num_units, result_type, time_zone, input_rows_count, scale);\n+                return execute<ReturnType, TimeDataType, TimeColumnType, IntervalKind::Kind::Month>(time_data_type, time_column, num_units, origin_column, result_type, time_zone, scale);\n             case IntervalKind::Kind::Quarter:\n-                return execute<TimeDataType, TimeColumnType, DataTypeDate, IntervalKind::Kind::Quarter>(time_data_type, time_column, num_units, result_type, time_zone, input_rows_count, scale);\n+                return execute<ReturnType, TimeDataType, TimeColumnType, IntervalKind::Kind::Quarter>(time_data_type, time_column, num_units, origin_column, result_type, time_zone, scale);\n             case IntervalKind::Kind::Year:\n-                return execute<TimeDataType, TimeColumnType, DataTypeDate, IntervalKind::Kind::Year>(time_data_type, time_column, num_units, result_type, time_zone, input_rows_count, scale);\n+                return execute<ReturnType, TimeDataType, TimeColumnType, IntervalKind::Kind::Year>(time_data_type, time_column, num_units, origin_column, result_type, time_zone, scale);\n         }\n \n         std::unreachable();\n     }\n \n-    template <typename TimeDataType, typename TimeColumnType, typename ResultDataType, IntervalKind::Kind unit>\n-    ColumnPtr execute(\n-        const TimeDataType &, const TimeColumnType & time_column_type, Int64 num_units,\n-        const DataTypePtr & result_type, const DateLUTImpl & time_zone, size_t input_rows_count, UInt16 scale) const\n+    template <typename ResultDataType, typename TimeDataType, typename TimeColumnType, IntervalKind::Kind unit>\n+    ColumnPtr execute(const TimeDataType &, const TimeColumnType & time_column_type, Int64 num_units, const ColumnWithTypeAndName & origin_column, const DataTypePtr & result_type, const DateLUTImpl & time_zone, UInt16 scale) const\n     {\n         using ResultColumnType = typename ResultDataType::ColumnType;\n-        using ResultFieldType = typename ResultDataType::FieldType;\n \n         const auto & time_data = time_column_type.getData();\n+        size_t size = time_data.size();\n \n         auto result_col = result_type->createColumn();\n         auto * col_to = assert_cast<ResultColumnType *>(result_col.get());\n         auto & result_data = col_to->getData();\n-        result_data.resize(input_rows_count);\n+        result_data.resize(size);\n \n         Int64 scale_multiplier = DecimalUtils::scaleMultiplier<DateTime64>(scale);\n \n-        for (size_t i = 0; i != input_rows_count; ++i)\n-            result_data[i] = static_cast<ResultFieldType>(ToStartOfInterval<unit>::execute(time_data[i], num_units, time_zone, scale_multiplier));\n+        if (origin_column.column) // Overload: Origin\n+        {\n+            const bool is_small_interval = (unit == IntervalKind::Kind::Nanosecond || unit == IntervalKind::Kind::Microsecond || unit == IntervalKind::Kind::Millisecond);\n+            const bool is_result_date = isDateOrDate32(result_type);\n+\n+            Int64 result_scale = scale_multiplier;\n+            Int64 origin_scale = 1;\n+\n+            if (isDateTime64(result_type)) /// We have origin scale only in case if arguments are DateTime64.\n+                origin_scale = assert_cast<const DataTypeDateTime64 &>(*origin_column.type).getScaleMultiplier();\n+            else if (!is_small_interval) /// In case of large interval and arguments are not DateTime64, we should not have scale in result.\n+                result_scale = 1;\n+\n+            if (is_small_interval)\n+                result_scale = assert_cast<const DataTypeDateTime64 &>(*result_type).getScaleMultiplier();\n+\n+            /// In case if we have a difference between time arguments and Interval, we need to calculate the difference between them\n+            /// to get the right precision for the result. In case of large intervals, we should not have scale difference.\n+            Int64 scale_diff = is_small_interval ? std::max(result_scale / origin_scale, origin_scale / result_scale) : 1;\n+\n+            static constexpr Int64 SECONDS_PER_DAY = 86'400;\n+\n+            UInt64 origin = origin_column.column->get64(0);\n+            for (size_t i = 0; i != size; ++i)\n+            {\n+                UInt64 time_arg = time_data[i];\n+                if (origin > static_cast<size_t>(time_arg))\n+                    throw Exception(ErrorCodes::BAD_ARGUMENTS, \"The origin must be before the end date / date with time\");\n+\n+                if (is_result_date) /// All internal calculations of ToStartOfInterval<...> expect arguments to be seconds or milli-, micro-, nanoseconds.\n+                {\n+                    time_arg *= SECONDS_PER_DAY;\n+                    origin *= SECONDS_PER_DAY;\n+                }\n+\n+                Int64 offset = ToStartOfInterval<unit>::execute(time_arg - origin, num_units, time_zone, result_scale, origin);\n+\n+                /// In case if arguments are DateTime64 with large interval, we should apply scale on it.\n+                offset *= (!is_small_interval) ? result_scale : 1;\n+\n+                if (is_result_date) /// Convert back to date after calculations.\n+                {\n+                    offset /= SECONDS_PER_DAY;\n+                    origin /= SECONDS_PER_DAY;\n+                }\n+\n+                result_data[i] = 0;\n+                result_data[i] += (result_scale < origin_scale) ? (origin + offset) / scale_diff : (origin + offset) * scale_diff;\n+            }\n+        }\n+        else // Overload: Default\n+        {\n+            for (size_t i = 0; i != size; ++i)\n+                result_data[i] = static_cast<typename ResultDataType::FieldType>(ToStartOfInterval<unit>::execute(time_data[i], num_units, time_zone, scale_multiplier));\n+        }\n \n         return result_col;\n     }\ndiff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt\nindex d10db5f0d3df..0e08a5f8540e 100644\n--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt\n+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt\n@@ -975,6 +975,7 @@ ThreadPoolRemoteFSReaderThreads\n ThreadPoolRemoteFSReaderThreadsActive\n ThreadsActive\n ThreadsInOvercommitTracker\n+TimescaleDB's\n TimeSeries\n Timeunit\n TinyLog\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02916_to_start_of_interval_with_origin.reference b/tests/queries/0_stateless/02916_to_start_of_interval_with_origin.reference\nnew file mode 100644\nindex 000000000000..f0afdf03963d\n--- /dev/null\n+++ b/tests/queries/0_stateless/02916_to_start_of_interval_with_origin.reference\n@@ -0,0 +1,59 @@\n+-- Negative tests\n+Time and origin as Date\n+2023-02-01\n+2023-08-01\n+2023-10-08\n+2023-10-08\n+2023-10-09\n+Time and origin as Date32\n+2023-02-01\n+2023-08-01\n+2023-10-08\n+2023-10-08\n+2023-10-09\n+Time and origin as DateTime\n+2023-02-01 09:08:07\n+2023-08-01 09:08:07\n+2023-10-08 09:08:07\n+2023-10-08 09:08:07\n+2023-10-09 09:08:07\n+2023-10-09 10:10:07\n+2023-10-09 10:11:07\n+2023-10-09 10:11:12\n+Time and origin as DateTime64(9)\n+2023-02-01 09:08:07.123456789\n+2023-08-01 09:08:07.123456789\n+2023-09-10 09:08:07.123456789\n+2023-10-08 09:08:07.123456789\n+2023-10-09 09:08:07.123456789\n+2023-10-09 10:10:07.123456789\n+2023-10-09 10:11:11.123456789\n+2023-10-09 10:11:12.123456789\n+2023-10-09 10:11:12.987\n+2023-10-09 10:11:12.987654\n+2023-10-09 10:11:12.987654321\n+Time and origin as DateTime64(3)\n+2023-02-01 09:08:07.123\n+2023-08-01 09:08:07.123\n+2023-10-08 09:08:07.123\n+2023-10-08 09:08:07.123\n+2023-10-09 09:08:07.123\n+2023-10-09 10:10:07.123\n+2023-10-09 10:11:11.123\n+2023-10-09 10:11:12.123\n+2023-10-09 10:11:12.987\n+2023-10-09 10:11:12.987000\n+2023-10-09 10:11:12.987000000\n+Non-const arguments\n+2023-03-01 16:55:00.00\n+2023-02-01 16:55:00.00\n+2023-03-01 16:55:00.00\n+2023-02-01 16:55:00.00\n+2023-03-01 16:55:00.00\n+2023-03-01 16:55:00\n+2023-02-01 16:55:00\n+2023-03-01 16:55:00\n+2023-02-01 16:55:00\n+2023-03-01 16:55:00\n+2023-01-02 15:44:30\n+2023-02-01 16:44:30.00\ndiff --git a/tests/queries/0_stateless/02916_to_start_of_interval_with_origin.sql b/tests/queries/0_stateless/02916_to_start_of_interval_with_origin.sql\nnew file mode 100644\nindex 000000000000..b03ccae31d9b\n--- /dev/null\n+++ b/tests/queries/0_stateless/02916_to_start_of_interval_with_origin.sql\n@@ -0,0 +1,95 @@\n+set session_timezone = 'UTC';\n+\n+SELECT '-- Negative tests';\n+\n+-- time and origin arguments must have the same type\n+SELECT toStartOfInterval(toDate('2023-01-02 14:45:50'), toIntervalSecond(5), toDate32('2023-01-02 14:44:30')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT toStartOfInterval(toDate('2023-01-02 14:45:50'), toIntervalMillisecond(12), toDateTime('2023-01-02 14:44:30')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT toStartOfInterval(toDate32('2023-01-02 14:45:50'), toIntervalHour(5), toDate('2023-01-02 14:44:30')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT toStartOfInterval(toDateTime('2023-01-02 14:45:50'), toIntervalMinute(1), toDateTime64('2023-01-02 14:44:30', 2)); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT toStartOfInterval(toDateTime64('2023-01-02 14:45:50', 2), toIntervalMinute(1), toDate('2023-01-02 14:44:30')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+\n+-- the origin must be before the time\n+SELECT toStartOfInterval(toDateTime('2023-01-02 14:42:50'), toIntervalMinute(1), toDateTime('2023-01-02 14:44:30')); -- { serverError BAD_ARGUMENTS }\n+\n+-- the origin must be constant\n+SELECT toStartOfInterval(toDateTime('2023-01-02 14:45:50'), toIntervalMinute(1), number % 2 == 0 ? toDateTime('2023-02-01 15:55:00') : toDateTime('2023-01-01 15:55:00')) from numbers(1); -- { serverError ILLEGAL_COLUMN }\n+SELECT toStartOfInterval(toDateTime('2023-01-02 14:45:50'), toIntervalHour(1), materialize(toDateTime('2023-01-02 14:44:30')), 'Europe/Amsterdam'); -- { serverError ILLEGAL_COLUMN }\n+\n+-- with 4 arguments, the 3rd one must not be a string or an integer\n+SELECT toStartOfInterval(toDateTime('2023-01-02 14:45:50'), toIntervalYear(1), 'Europe/Amsterdam', 'Europe/Amsterdam'); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT toStartOfInterval(toDateTime('2023-01-02 14:45:50'), toIntervalYear(1), 5, 'Europe/Amsterdam'); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+\n+-- too many arguments\n+SELECT toStartOfInterval(toDateTime('2023-01-02 14:45:50'), toIntervalYear(1), toDateTime('2020-01-02 14:44:30'), 'Europe/Amsterdam', 5); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+\n+SELECT 'Time and origin as Date';\n+SELECT toStartOfInterval(toDate('2023-10-09'), toIntervalYear(1), toDate('2022-02-01'));\n+SELECT toStartOfInterval(toDate('2023-10-09'), toIntervalQuarter(1), toDate('2022-02-01'));\n+SELECT toStartOfInterval(toDate('2023-10-09'), toIntervalMonth(1), toDate('2023-09-08'));\n+SELECT toStartOfInterval(toDate('2023-10-09'), toIntervalWeek(1), toDate('2023-10-01'));\n+SELECT toStartOfInterval(toDate('2023-10-09'), toIntervalDay(1), toDate('2023-10-08'));\n+SELECT toStartOfInterval(toDate('2023-10-09'), toIntervalHour(1), toDate('2023-10-09')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT toStartOfInterval(toDate('2023-10-09'), toIntervalMinute(1), toDate('2023-10-09')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT toStartOfInterval(toDate('2023-10-09'), toIntervalSecond(1), toDate('2023-10-09')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT toStartOfInterval(toDate('2023-10-09'), toIntervalMillisecond(1), toDate('2023-10-09')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT toStartOfInterval(toDate('2023-10-09'), toIntervalMicrosecond(1), toDate('2023-10-09')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT toStartOfInterval(toDate('2023-10-09'), toIntervalNanosecond(1), toDate('2023-10-09')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+\n+SELECT 'Time and origin as Date32';\n+SELECT toStartOfInterval(toDate32('2023-10-09'), toIntervalYear(1), toDate32('2022-02-01'));\n+SELECT toStartOfInterval(toDate32('2023-10-09'), toIntervalQuarter(1), toDate32('2022-02-01'));\n+SELECT toStartOfInterval(toDate32('2023-10-09'), toIntervalMonth(1), toDate32('2023-09-08'));\n+SELECT toStartOfInterval(toDate32('2023-10-09'), toIntervalWeek(1), toDate32('2023-10-01'));\n+SELECT toStartOfInterval(toDate32('2023-10-09'), toIntervalDay(1), toDate32('2023-10-08'));\n+SELECT toStartOfInterval(toDate32('2023-10-09'), toIntervalHour(1), toDate32('2023-10-09')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT toStartOfInterval(toDate32('2023-10-09'), toIntervalMinute(1), toDate32('2023-10-09')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT toStartOfInterval(toDate32('2023-10-09'), toIntervalSecond(1), toDate32('2023-10-09')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT toStartOfInterval(toDate32('2023-10-09'), toIntervalMillisecond(1), toDate32('2023-10-09')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT toStartOfInterval(toDate32('2023-10-09'), toIntervalMicrosecond(1), toDate32('2023-10-09')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT toStartOfInterval(toDate32('2023-10-09'), toIntervalNanosecond(1), toDate32('2023-10-09')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+\n+SELECT 'Time and origin as DateTime';\n+SELECT toStartOfInterval(toDateTime('2023-10-09 10:11:12'), toIntervalYear(1), toDateTime('2022-02-01 09:08:07'));\n+SELECT toStartOfInterval(toDateTime('2023-10-09 10:11:12'), toIntervalQuarter(1), toDateTime('2022-02-01 09:08:07'));\n+SELECT toStartOfInterval(toDateTime('2023-10-09 10:11:12'), toIntervalMonth(1), toDateTime('2023-09-08 09:08:07'));\n+SELECT toStartOfInterval(toDateTime('2023-10-09 10:11:12'), toIntervalWeek(1), toDateTime('2023-10-01 09:08:07'));\n+SELECT toStartOfInterval(toDateTime('2023-10-09 10:11:12'), toIntervalDay(1), toDateTime('2023-10-08 09:08:07'));\n+SELECT toStartOfInterval(toDateTime('2023-10-09 10:11:12'), toIntervalHour(1), toDateTime('2023-10-09 09:10:07'));\n+SELECT toStartOfInterval(toDateTime('2023-10-09 10:11:12'), toIntervalMinute(1), toDateTime('2023-10-09 09:10:07'));\n+SELECT toStartOfInterval(toDateTime('2023-10-09 10:11:12'), toIntervalSecond(1), toDateTime('2023-10-09 09:10:07'));\n+SELECT toStartOfInterval(toDateTime('2023-10-09 10:11:12'), toIntervalMillisecond(1), toDateTime('2023-10-09 10:11:12')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT toStartOfInterval(toDateTime('2023-10-09 10:11:12'), toIntervalMicrosecond(1), toDateTime('2023-10-09 10:11:12')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT toStartOfInterval(toDateTime('2023-10-09 10:11:12'), toIntervalNanosecond(1), toDateTime('2023-10-09 10:11:12')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+\n+SELECT 'Time and origin as DateTime64(9)';\n+SELECT toStartOfInterval(toDateTime64('2023-10-09 10:11:12.987654321', 9), toIntervalYear(1), toDateTime64('2022-02-01 09:08:07.123456789', 9));\n+SELECT toStartOfInterval(toDateTime64('2023-10-09 10:11:12.987654321', 9), toIntervalQuarter(1), toDateTime64('2022-02-01 09:08:07.123456789', 9));\n+SELECT toStartOfInterval(toDateTime64('2023-10-09 10:11:12.987654321', 9), toIntervalMonth(1), toDateTime64('2023-09-10 09:08:07.123456789', 9));\n+SELECT toStartOfInterval(toDateTime64('2023-10-09 10:11:12.987654321', 9), toIntervalWeek(1), toDateTime64('2023-10-01 09:08:07.123456789', 9));\n+SELECT toStartOfInterval(toDateTime64('2023-10-09 10:11:12.987654321', 9), toIntervalDay(1), toDateTime64('2023-10-08 09:08:07.123456789', 9));\n+SELECT toStartOfInterval(toDateTime64('2023-10-09 10:11:12.987654321', 9), toIntervalHour(1), toDateTime64('2023-10-09 09:10:07.123456789', 9));\n+SELECT toStartOfInterval(toDateTime64('2023-10-09 10:11:12.987654321', 9), toIntervalMinute(1), toDateTime64('2023-10-09 09:10:11.123456789', 9));\n+SELECT toStartOfInterval(toDateTime64('2023-10-09 10:11:12.987654321', 9), toIntervalSecond(1), toDateTime64('2023-10-09 10:11:10.123456789', 9));\n+SELECT toStartOfInterval(toDateTime64('2023-10-09 10:11:12.987654321', 9), toIntervalMillisecond(1), toDateTime64('2023-10-09 10:11:12.123456789', 9));\n+SELECT toStartOfInterval(toDateTime64('2023-10-09 10:11:12.987654321', 9), toIntervalMicrosecond(1), toDateTime64('2023-10-09 10:11:12.123456789', 9));\n+SELECT toStartOfInterval(toDateTime64('2023-10-09 10:11:12.987654321', 9), toIntervalNanosecond(1), toDateTime64('2023-10-09 10:11:12.123456789', 9));\n+\n+SELECT 'Time and origin as DateTime64(3)';\n+SELECT toStartOfInterval(toDateTime64('2023-10-09 10:11:12.987', 3), toIntervalYear(1), toDateTime64('2022-02-01 09:08:07.123', 3));\n+SELECT toStartOfInterval(toDateTime64('2023-10-09 10:11:12.987', 3), toIntervalQuarter(1), toDateTime64('2022-02-01 09:08:07.123', 3));\n+SELECT toStartOfInterval(toDateTime64('2023-10-09 10:11:12.987', 3), toIntervalMonth(1), toDateTime64('2023-09-08 09:08:07.123', 3));\n+SELECT toStartOfInterval(toDateTime64('2023-10-09 10:11:12.987', 3), toIntervalWeek(1), toDateTime64('2023-10-01 09:08:07.123', 3));\n+SELECT toStartOfInterval(toDateTime64('2023-10-09 10:11:12.987', 3), toIntervalDay(1), toDateTime64('2023-10-08 09:08:07.123', 3));\n+SELECT toStartOfInterval(toDateTime64('2023-10-09 10:11:12.987', 3), toIntervalHour(1), toDateTime64('2023-10-09 09:10:07.123', 3));\n+SELECT toStartOfInterval(toDateTime64('2023-10-09 10:11:12.987', 3), toIntervalMinute(1), toDateTime64('2023-10-09 10:10:11.123', 3));\n+SELECT toStartOfInterval(toDateTime64('2023-10-09 10:11:12.987', 3), toIntervalSecond(1), toDateTime64('2023-10-09 10:11:10.123', 3));\n+SELECT toStartOfInterval(toDateTime64('2023-10-09 10:11:12.987', 3), toIntervalMillisecond(1), toDateTime64('2023-10-09 10:11:12.123', 3));\n+SELECT toStartOfInterval(toDateTime64('2023-10-09 10:11:12.987', 3), toIntervalMicrosecond(1), toDateTime64('2023-10-09 10:11:12.123', 3));\n+SELECT toStartOfInterval(toDateTime64('2023-10-09 10:11:12.987', 3), toIntervalNanosecond(1), toDateTime64('2023-10-09 10:11:12.123', 3));\n+\n+SELECT 'Non-const arguments';\n+SELECT toStartOfInterval(number % 2 == 0 ? toDateTime64('2023-03-01 15:55:00', 2) : toDateTime64('2023-02-01 15:55:00', 2), toIntervalMinute(1), toDateTime64('2023-01-01 13:55:00', 2), 'Europe/Amsterdam') from numbers(5);\n+SELECT toStartOfInterval(number % 2 == 0 ? toDateTime('2023-03-01 15:55:00') : toDateTime('2023-02-01 15:55:00'), toIntervalHour(1), toDateTime('2023-01-01 13:55:00'), 'Europe/Amsterdam') from numbers(5);\n+SELECT toStartOfInterval(materialize(toDateTime('2023-01-02 14:45:50')), toIntervalHour(1), toDateTime('2023-01-02 14:44:30'), 'Europe/Amsterdam');\n+SELECT toStartOfInterval(materialize(toDateTime64('2023-02-01 15:45:50', 2)), toIntervalHour(1), toDateTime64('2023-01-02 14:44:30', 2), 'Europe/Amsterdam');\n",
  "problem_statement": "Convenience function for custom start of interval\n**Use case**\r\nA way to get time buckets aligned to a custom time range. \r\n\r\n**Describe the solution you'd like**\r\n`toStartOfInterval` gets timestamps considering the calendar format, that is the start of minute/hour/day and so on. But is it not possible to mention a `start_time` so that the buckets start from it.\r\n\r\nTimescaleDB provides this facility with `time_bucket(time_column, interval, start_time, end_time)` where the buckets start from the given start_time. https://docs.timescale.com/api/latest/hyperfunctions/time_bucket/#optional-arguments-for-interval-time-inputs\r\n\r\n**Describe alternatives you've considered**\r\n\r\nCurrently a query to do this is quite verbose. Idea is to make it more concise. \r\n\r\n```sql\r\nSELECT\r\n    toDateTime(\r\n        toUInt32(\r\n            toStartOfInterval(\r\n                toDateTime(toUInt32(timestamp - toDateTime('2023-01-01 12:15:00'))),\r\n                INTERVAL 1 hour\r\n            )\r\n        )\r\n        + toDateTime('2023-01-01 12:15:00')\r\n    )\r\n     AS bucket,\r\n    COUNT(*)\r\nFROM\r\n    events\r\nWHERE timestamp > toDateTime('2023-01-01 12:15:00')\r\nGROUP BY bucket\r\nORDER BY bucket;\r\n```\r\n\n",
  "hints_text": "To whoever likes to implement this (I heard someone whisper @yariks5s \ud83d\ude04).\r\n\r\nTimescale's `time_bucket()`, respectively Postgres's `date_bin()` are generalizations of our `toStartOfInterval()`. I consider ClickHouse's naming more speaking than `time_bucket` and `date_bin`, so we might simply add another overload to SQL function `toStartOfInterval()` instead of introducing a new function. This will get us:\r\n- `toStartOfInterval(time_or_data, INTERVAL x unit [, time_zone])` and\r\n- `toStartOfInterval(time_or_data, INTERVAL x unit, origin [, time_zone])`\r\nBasically: the type of the 3rd argument (if given), i.e. String or Date/Time dispatches between the variants.\r\n\r\nThe actual calculation can be done similar to above SQL, something like this:\r\n\r\n```cpp\r\nfor (size_t i = 0; i != size; ++i)\r\n{\r\n    auto td = time_data[i];\r\n    if (origin.get() != null) // <-- assuming origin is wrapped in std::optional<>\r\n        td -= origin;\r\n    result_data[i] = static_cast<ToFieldType>(ToStartOfInterval<unit>::execute(td, num_units, time_zone, scale_multiplier));\r\n    if (origin.get() != null)\r\n         result_data[i] += origin;\r\n```\r\n\r\n(there are now two additional `if`s. Branch prediction will likely do a good job, so we don't need additional templatization / `constexpr if`)\r\n\r\nCaveat: `HOUR` intervals will produce funny results due to #54906. Consider making a variant of `toStartOfHourInterval()` (Common/DateLUTImpl.h) with rollover. It can be based on (copypasted from) the existing implementation of `toStartOfMinuteInterval()` in the same file but with an additional factor `60 *` to calculate the divisor.",
  "created_at": "2023-11-14T11:11:14Z"
}