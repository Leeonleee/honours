{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25554,
  "instance_id": "ClickHouse__ClickHouse-25554",
  "issue_numbers": [
    "24730"
  ],
  "base_commit": "1e9fbdb02c3b670e947e2c78c6533f5cda52edb5",
  "patch": "diff --git a/src/Interpreters/MutationsInterpreter.cpp b/src/Interpreters/MutationsInterpreter.cpp\nindex dbf75baad144..03a2a4da1d10 100644\n--- a/src/Interpreters/MutationsInterpreter.cpp\n+++ b/src/Interpreters/MutationsInterpreter.cpp\n@@ -388,7 +388,6 @@ ASTPtr MutationsInterpreter::prepare(bool dry_run)\n     if (commands.empty())\n         throw Exception(\"Empty mutation commands list\", ErrorCodes::LOGICAL_ERROR);\n \n-\n     const ColumnsDescription & columns_desc = metadata_snapshot->getColumns();\n     const IndicesDescription & indices_desc = metadata_snapshot->getSecondaryIndices();\n     const ProjectionsDescription & projections_desc = metadata_snapshot->getProjections();\n@@ -425,8 +424,7 @@ ASTPtr MutationsInterpreter::prepare(bool dry_run)\n         validateUpdateColumns(storage, metadata_snapshot, updated_columns, column_to_affected_materialized);\n     }\n \n-    /// Columns, that we need to read for calculation of skip indices, projections or TTL expressions.\n-    auto dependencies = getAllColumnDependencies(metadata_snapshot, updated_columns);\n+    dependencies = getAllColumnDependencies(metadata_snapshot, updated_columns);\n \n     /// First, break a sequence of commands into stages.\n     for (auto & command : commands)\n@@ -921,6 +919,10 @@ const Block & MutationsInterpreter::getUpdatedHeader() const\n     return *updated_header;\n }\n \n+const ColumnDependencies & MutationsInterpreter::getColumnDependencies() const\n+{\n+    return dependencies;\n+}\n \n size_t MutationsInterpreter::evaluateCommandsSize()\n {\ndiff --git a/src/Interpreters/MutationsInterpreter.h b/src/Interpreters/MutationsInterpreter.h\nindex 0d91da5613ce..65ad027118ad 100644\n--- a/src/Interpreters/MutationsInterpreter.h\n+++ b/src/Interpreters/MutationsInterpreter.h\n@@ -56,6 +56,8 @@ class MutationsInterpreter\n     /// Only changed columns.\n     const Block & getUpdatedHeader() const;\n \n+    const ColumnDependencies & getColumnDependencies() const;\n+\n     /// Latest mutation stage affects all columns in storage\n     bool isAffectingAllColumns() const;\n \n@@ -148,6 +150,9 @@ class MutationsInterpreter\n     NameSet materialized_projections;\n \n     MutationKind mutation_kind; /// Do we meet any index or projection mutation.\n+\n+    /// Columns, that we need to read for calculation of skip indices, projections or TTL expressions.\n+    ColumnDependencies dependencies;\n };\n \n }\ndiff --git a/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp b/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\nindex fa9094eb4a10..b6ccfc05dc2d 100644\n--- a/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\n@@ -1284,7 +1284,7 @@ MergeTreeData::MutableDataPartPtr MergeTreeDataMergerMutator::mutatePartToTempor\n     bool need_sync = needSyncPart(source_part->rows_count, source_part->getBytesOnDisk(), *data_settings);\n     bool need_remove_expired_values = false;\n \n-    if (in && shouldExecuteTTL(metadata_snapshot, in->getHeader().getNamesAndTypesList().getNames(), commands_for_part))\n+    if (in && shouldExecuteTTL(metadata_snapshot, interpreter->getColumnDependencies(), commands_for_part))\n         need_remove_expired_values = true;\n \n     /// All columns from part are changed and may be some more that were missing before in part\n@@ -1973,7 +1973,8 @@ std::set<MergeTreeProjectionPtr> MergeTreeDataMergerMutator::getProjectionsToRec\n     return projections_to_recalc;\n }\n \n-bool MergeTreeDataMergerMutator::shouldExecuteTTL(const StorageMetadataPtr & metadata_snapshot, const Names & columns, const MutationCommands & commands)\n+bool MergeTreeDataMergerMutator::shouldExecuteTTL(\n+    const StorageMetadataPtr & metadata_snapshot, const ColumnDependencies & dependencies, const MutationCommands & commands)\n {\n     if (!metadata_snapshot->hasAnyTTL())\n         return false;\n@@ -1982,7 +1983,6 @@ bool MergeTreeDataMergerMutator::shouldExecuteTTL(const StorageMetadataPtr & met\n         if (command.type == MutationCommand::MATERIALIZE_TTL)\n             return true;\n \n-    auto dependencies = metadata_snapshot->getColumnDependencies(NameSet(columns.begin(), columns.end()));\n     for (const auto & dependency : dependencies)\n         if (dependency.kind == ColumnDependency::TTL_EXPRESSION || dependency.kind == ColumnDependency::TTL_TARGET)\n             return true;\ndiff --git a/src/Storages/MergeTree/MergeTreeDataMergerMutator.h b/src/Storages/MergeTree/MergeTreeDataMergerMutator.h\nindex b082d063dcfe..ca7376d8f3e7 100644\n--- a/src/Storages/MergeTree/MergeTreeDataMergerMutator.h\n+++ b/src/Storages/MergeTree/MergeTreeDataMergerMutator.h\n@@ -200,7 +200,8 @@ class MergeTreeDataMergerMutator\n         const ProjectionsDescription & all_projections,\n         const MutationCommands & commands_for_removes);\n \n-    static bool shouldExecuteTTL(const StorageMetadataPtr & metadata_snapshot, const Names & columns, const MutationCommands & commands);\n+    static bool shouldExecuteTTL(\n+        const StorageMetadataPtr & metadata_snapshot, const ColumnDependencies & dependencies, const MutationCommands & commands);\n \n     /// Return set of indices which should be recalculated during mutation also\n     /// wraps input stream into additional expression stream\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01923_ttl_with_modify_column.reference b/tests/queries/0_stateless/01923_ttl_with_modify_column.reference\nnew file mode 100644\nindex 000000000000..2e55ea564b9e\n--- /dev/null\n+++ b/tests/queries/0_stateless/01923_ttl_with_modify_column.reference\n@@ -0,0 +1,2 @@\n+2\t['Int16']\n+2\t['Date']\ndiff --git a/tests/queries/0_stateless/01923_ttl_with_modify_column.sql b/tests/queries/0_stateless/01923_ttl_with_modify_column.sql\nnew file mode 100644\nindex 000000000000..ed2812d2a392\n--- /dev/null\n+++ b/tests/queries/0_stateless/01923_ttl_with_modify_column.sql\n@@ -0,0 +1,43 @@\n+DROP TABLE IF EXISTS t_ttl_modify_column;\n+\n+CREATE TABLE t_ttl_modify_column\n+(\n+    InsertionDateTime DateTime,\n+    TTLDays Int32 DEFAULT CAST(365, 'Int32')\n+)\n+ENGINE = MergeTree\n+ORDER BY tuple()\n+TTL InsertionDateTime + toIntervalDay(TTLDays)\n+SETTINGS min_bytes_for_wide_part = 0;\n+\n+INSERT INTO t_ttl_modify_column VALUES (now(), 23);\n+\n+SET mutations_sync = 2;\n+\n+ALTER TABLE t_ttl_modify_column modify column TTLDays Int16 DEFAULT CAST(365, 'Int16');\n+\n+INSERT INTO t_ttl_modify_column VALUES (now(), 23);\n+\n+SELECT sum(rows), groupUniqArray(type) FROM system.parts_columns\n+WHERE database = currentDatabase() AND table = 't_ttl_modify_column' AND column = 'TTLDays' AND active;\n+\n+DROP TABLE IF EXISTS t_ttl_modify_column;\n+\n+CREATE TABLE t_ttl_modify_column (InsertionDateTime DateTime)\n+ENGINE = MergeTree\n+ORDER BY tuple()\n+TTL InsertionDateTime + INTERVAL 3 DAY\n+SETTINGS min_bytes_for_wide_part = 0;\n+\n+INSERT INTO t_ttl_modify_column VALUES (now());\n+\n+ALTER TABLE t_ttl_modify_column MODIFY COLUMN InsertionDateTime Date;\n+\n+INSERT INTO t_ttl_modify_column VALUES (now());\n+\n+SELECT sum(rows), groupUniqArray(type) FROM system.parts_columns\n+WHERE database = currentDatabase() AND table = 't_ttl_modify_column' AND column = 'InsertionDateTime' AND active;\n+\n+ALTER TABLE t_ttl_modify_column MODIFY COLUMN InsertionDateTime String; -- { serverError 43 }\n+\n+DROP TABLE IF EXISTS t_ttl_modify_column;\n",
  "problem_statement": "Alter of a column participating in TTL expression can leave a table in an inconsistent state\nversion 21.5.5.12 (official build)\r\n\r\nI'm trying to change data type for a column that is used in the TTL expression.\r\nIt works well when the table is empty.\r\nWhen the table is not empty, the mutation fails.\r\nAs a result the table ends up in an inconsistent state.\r\n\r\n```\r\ncreate table test\r\n(\r\nInsertionDateTime DateTime,\r\nTTLDays Int32 DEFAULT CAST(365, 'Int32')\r\n)\r\nEngine=MergeTree()\r\norder by tuple()\r\nTTL InsertionDateTime + toIntervalDay(TTLDays);\r\n\r\nOk.\r\n\r\ninsert into test values (now(), 23);\r\n\r\nOk.\r\n\r\nALTER TABLE test modify column TTLDays Int16 DEFAULT CAST(365, 'Int16');\r\n\r\nCode: 341, e.displayText() = DB::Exception: Exception happened during execution of mutation 'mutation_2.txt' with part 'all_1_1_0' reason: 'Code: 10, e.displayText() = DB::Exception: Not found column InsertionDateTime in block. There are only columns: TTLDays (version 21.5.5.12 (official build))'. This error maybe retryable or not. In case of unretryable error, mutation can be killed with KILL MUTATION query (version 21.5.5.12 (official build)) [DB Errorcode=341]\r\n\r\ninsert into test values (now(), 23);\r\n\r\nOk.\r\n\r\nselect table, column, type, sum(rows) rows, sum(column_bytes_on_disk) on_disk\r\nfrom system.parts_columns where column like 'TTLDays'\r\ngroup by database, table, column, type\r\n\r\ntable | column  | type  | rows | on_disk\r\n------+---------+-------+------+--------\r\ntest  | TTLDays | Int32 |    1 |      86\r\ntest  | TTLDays | Int16 |    1 |      84\r\n```\n",
  "hints_text": "",
  "created_at": "2021-06-21T15:24:35Z"
}