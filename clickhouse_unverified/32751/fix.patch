diff --git a/src/Interpreters/SelectQueryOptions.h b/src/Interpreters/SelectQueryOptions.h
index 709ecdc239ce..bc95a940c18a 100644
--- a/src/Interpreters/SelectQueryOptions.h
+++ b/src/Interpreters/SelectQueryOptions.h
@@ -41,6 +41,9 @@ struct SelectQueryOptions
     /// It is needed because lazy normal projections require special planning in FetchColumns stage, such as adding WHERE transform.
     /// It is also used to avoid adding aggregating step when aggregate projection is chosen.
     bool is_projection_query = false;
+    /// This flag is needed for projection description.
+    /// Otherwise, keys for GROUP BY may be removed as constants.
+    bool ignore_ast_optimizations = false;
     bool ignore_alias = false;
     bool is_internal = false;
     bool is_subquery = false; // non-subquery can also have subquery_depth > 0, e.g. insert select
@@ -120,6 +123,12 @@ struct SelectQueryOptions
         return *this;
     }
 
+    SelectQueryOptions & ignoreASTOptimizationsAlias(bool value = true)
+    {
+        ignore_ast_optimizations = value;
+        return *this;
+    }
+
     SelectQueryOptions & setInternal(bool value = false)
     {
         is_internal = value;
diff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp
index 6b3a50d88e2a..0cb4597230ba 100644
--- a/src/Interpreters/TreeRewriter.cpp
+++ b/src/Interpreters/TreeRewriter.cpp
@@ -1121,7 +1121,7 @@ TreeRewriterResultPtr TreeRewriter::analyzeSelect(
     result.rewrite_subqueries = PredicateExpressionsOptimizer(getContext(), tables_with_columns, settings).optimize(*select_query);
 
     /// Only apply AST optimization for initial queries.
-    if (getContext()->getClientInfo().query_kind == ClientInfo::QueryKind::INITIAL_QUERY)
+    if (getContext()->getClientInfo().query_kind != ClientInfo::QueryKind::SECONDARY_QUERY && !select_options.ignore_ast_optimizations)
         TreeOptimizer::apply(query, result, tables_with_columns, getContext());
 
     /// array_join_alias_to_name, array_join_result_to_source.
diff --git a/src/Storages/ProjectionsDescription.cpp b/src/Storages/ProjectionsDescription.cpp
index f1a0372a07d1..791583e24958 100644
--- a/src/Storages/ProjectionsDescription.cpp
+++ b/src/Storages/ProjectionsDescription.cpp
@@ -201,7 +201,7 @@ ProjectionDescription ProjectionDescription::getMinMaxCountProjection(
     select_expression_list->children.push_back(makeASTFunction("count"));
     select_query->setExpression(ASTProjectionSelectQuery::Expression::SELECT, std::move(select_expression_list));
 
-    if (partition_columns)
+    if (partition_columns && !partition_columns->children.empty())
         select_query->setExpression(ASTProjectionSelectQuery::Expression::GROUP_BY, partition_columns->clone());
 
     result.definition_ast = select_query;
@@ -211,7 +211,9 @@ ProjectionDescription ProjectionDescription::getMinMaxCountProjection(
     auto external_storage_holder = std::make_shared<TemporaryTableHolder>(query_context, columns, ConstraintsDescription{});
     StoragePtr storage = external_storage_holder->getTable();
     InterpreterSelectQuery select(
-        result.query_ast, query_context, storage, {}, SelectQueryOptions{QueryProcessingStage::WithMergeableState}.modify().ignoreAlias());
+        result.query_ast, query_context, storage, {},
+        /// Here we ignore ast optimizations because otherwise aggregation keys may be removed from result header as constants.
+        SelectQueryOptions{QueryProcessingStage::WithMergeableState}.modify().ignoreAlias().ignoreASTOptimizationsAlias());
     result.required_columns = select.getRequiredColumns();
     result.sample_block = select.getSampleBlock();
 
