{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 42319,
  "instance_id": "ClickHouse__ClickHouse-42319",
  "issue_numbers": [
    "42161"
  ],
  "base_commit": "edfc388b7c55841ac80aaebbd960ddee3c7dc483",
  "patch": "diff --git a/src/Storages/MergeTree/MutateTask.cpp b/src/Storages/MergeTree/MutateTask.cpp\nindex 9f3c31003496..3d964e607981 100644\n--- a/src/Storages/MergeTree/MutateTask.cpp\n+++ b/src/Storages/MergeTree/MutateTask.cpp\n@@ -220,8 +220,11 @@ getColumnsForNewDataPart(\n     if (!isWidePart(source_part))\n         return {updated_header.getNamesAndTypesList(), new_serialization_infos};\n \n-    Names source_column_names = source_part->getColumns().getNames();\n-    NameSet source_columns_name_set(source_column_names.begin(), source_column_names.end());\n+    const auto & source_columns = source_part->getColumns();\n+    std::unordered_map<String, DataTypePtr> source_columns_name_to_type;\n+    for (const auto & it : source_columns)\n+        source_columns_name_to_type[it.name] = it.type;\n+\n     for (auto it = storage_columns.begin(); it != storage_columns.end();)\n     {\n         if (updated_header.has(it->name))\n@@ -233,14 +236,25 @@ getColumnsForNewDataPart(\n         }\n         else\n         {\n-            if (!source_columns_name_set.contains(it->name))\n+            auto source_col = source_columns_name_to_type.find(it->name);\n+            if (source_col == source_columns_name_to_type.end())\n             {\n                 /// Source part doesn't have column but some other column\n                 /// was renamed to it's name.\n                 auto renamed_it = renamed_columns_to_from.find(it->name);\n-                if (renamed_it != renamed_columns_to_from.end()\n-                    && source_columns_name_set.contains(renamed_it->second))\n-                    ++it;\n+                if (renamed_it != renamed_columns_to_from.end())\n+                {\n+                    source_col = source_columns_name_to_type.find(renamed_it->second);\n+                    if (source_col == source_columns_name_to_type.end())\n+                        it = storage_columns.erase(it);\n+                    else\n+                    {\n+                        /// Take a type from source part column.\n+                        /// It may differ from column type in storage.\n+                        it->type = source_col->second;\n+                        ++it;\n+                    }\n+                }\n                 else\n                     it = storage_columns.erase(it);\n             }\n@@ -262,7 +276,12 @@ getColumnsForNewDataPart(\n                 if (!renamed_columns_to_from.contains(it->name) && (was_renamed || was_removed))\n                     it = storage_columns.erase(it);\n                 else\n+                {\n+                    /// Take a type from source part column.\n+                    /// It may differ from column type in storage.\n+                    it->type = source_col->second;\n                     ++it;\n+                }\n             }\n         }\n     }\ndiff --git a/src/Storages/MergeTree/ReplicatedMergeTreeSink.cpp b/src/Storages/MergeTree/ReplicatedMergeTreeSink.cpp\nindex b9bd027cde26..0abea5977c31 100644\n--- a/src/Storages/MergeTree/ReplicatedMergeTreeSink.cpp\n+++ b/src/Storages/MergeTree/ReplicatedMergeTreeSink.cpp\n@@ -315,7 +315,12 @@ void ReplicatedMergeTreeSink::commitPart(\n     DataPartStorageBuilderPtr builder,\n     size_t replicas_num)\n {\n-    metadata_snapshot->check(part->getColumns());\n+    /// It is possible that we alter a part with different types of source columns.\n+    /// In this case, if column was not altered, the result type will be different with what we have in metadata.\n+    /// For now, consider it is ok. See 02461_alter_update_respect_part_column_type_bug for an example.\n+    ///\n+    /// metadata_snapshot->check(part->getColumns());\n+\n     assertSessionIsNotExpired(zookeeper);\n \n     String temporary_part_relative_path = part->data_part_storage->getPartDirectory();\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02012_zookeeper_changed_enum_type_incompatible.reference b/tests/queries/0_stateless/02012_zookeeper_changed_enum_type_incompatible.reference\nindex e69de29bb2d1..338e1edb715d 100644\n--- a/tests/queries/0_stateless/02012_zookeeper_changed_enum_type_incompatible.reference\n+++ b/tests/queries/0_stateless/02012_zookeeper_changed_enum_type_incompatible.reference\n@@ -0,0 +1,4 @@\n+one\t1\n+two\t1\n+one\t1\n+two\t1\ndiff --git a/tests/queries/0_stateless/02012_zookeeper_changed_enum_type_incompatible.sql b/tests/queries/0_stateless/02012_zookeeper_changed_enum_type_incompatible.sql\nindex e236e6d27671..b83f02dc79da 100644\n--- a/tests/queries/0_stateless/02012_zookeeper_changed_enum_type_incompatible.sql\n+++ b/tests/queries/0_stateless/02012_zookeeper_changed_enum_type_incompatible.sql\n@@ -11,5 +11,6 @@ alter table enum_alter_issue detach partition id 'all';\n alter table enum_alter_issue modify column a Enum8('one' = 1, 'two' = 2, 'three' = 3);\n insert into enum_alter_issue values ('one', 1), ('two', 1);\n \n-alter table enum_alter_issue attach partition id 'all'; -- {serverError TYPE_MISMATCH}\n+alter table enum_alter_issue attach partition id 'all';\n+select * from enum_alter_issue;\n drop table enum_alter_issue;\ndiff --git a/tests/queries/0_stateless/02461_alter_update_respect_part_column_type_bug.reference b/tests/queries/0_stateless/02461_alter_update_respect_part_column_type_bug.reference\nnew file mode 100644\nindex 000000000000..99a39410caef\n--- /dev/null\n+++ b/tests/queries/0_stateless/02461_alter_update_respect_part_column_type_bug.reference\n@@ -0,0 +1,9 @@\n+1\tone\ttest1\n+one\tone\ttest1\n+one\tone\ttest\n+one\tone\ttest\n+-----\n+1\tone\ttest1\n+one\tone\ttest1\n+one\tone\ttest\n+one\tone\ttest\ndiff --git a/tests/queries/0_stateless/02461_alter_update_respect_part_column_type_bug.sql b/tests/queries/0_stateless/02461_alter_update_respect_part_column_type_bug.sql\nnew file mode 100644\nindex 000000000000..7f48b41aa1e8\n--- /dev/null\n+++ b/tests/queries/0_stateless/02461_alter_update_respect_part_column_type_bug.sql\n@@ -0,0 +1,94 @@\n+drop table if exists src;\n+create table src( A Int64, B String, C String) Engine=MergeTree order by A SETTINGS min_bytes_for_wide_part=0;\n+insert into src values(1, 'one', 'test');\n+\n+alter table src detach partition tuple();\n+alter table src modify column B Nullable(String);\n+alter table src attach partition tuple();\n+\n+alter table src update C = 'test1' where 1 settings mutations_sync=2;\n+select * from src;\n+\n+\n+drop table if exists src;\n+create table src( A String, B String, C String) Engine=MergeTree order by A SETTINGS min_bytes_for_wide_part=0;\n+insert into src values('one', 'one', 'test');\n+\n+alter table src detach partition tuple();\n+alter table src modify column A LowCardinality(String);\n+alter table src attach partition tuple();\n+\n+alter table src update C = 'test1' where 1 settings mutations_sync=2;\n+select * from src;\n+\n+\n+drop table if exists src;\n+create table src( A String, B String, C String) Engine=MergeTree order by A SETTINGS min_bytes_for_wide_part=0;\n+insert into src values('one', 'one', 'test');\n+\n+alter table src detach partition tuple();\n+alter table src modify column A LowCardinality(String);\n+alter table src attach partition tuple();\n+\n+alter table src modify column C LowCardinality(String);\n+select * from src;\n+\n+drop table if exists src;\n+create table src( A String, B String, C String) Engine=MergeTree order by A SETTINGS min_bytes_for_wide_part=0;\n+insert into src values('one', 'one', 'test');\n+\n+alter table src detach partition tuple();\n+alter table src modify column B Nullable(String);\n+alter table src attach partition tuple();\n+\n+alter table src rename column B to D;\n+select * from src;\n+\n+select '-----';\n+\n+drop table if exists src;\n+create table src( A Int64, B String, C String) Engine=ReplicatedMergeTree('/clickhouse/{database}/test/src1', '1') order by A SETTINGS min_bytes_for_wide_part=0;\n+insert into src values(1, 'one', 'test');\n+\n+alter table src detach partition tuple();\n+alter table src modify column B Nullable(String);\n+alter table src attach partition tuple();\n+\n+alter table src update C = 'test1' where 1 settings mutations_sync=2;\n+select * from src;\n+\n+\n+drop table if exists src;\n+create table src( A String, B String, C String) Engine=ReplicatedMergeTree('/clickhouse/{database}/test/src2', '1') order by A SETTINGS min_bytes_for_wide_part=0;\n+insert into src values('one', 'one', 'test');\n+\n+alter table src detach partition tuple();\n+alter table src modify column A LowCardinality(String);\n+alter table src attach partition tuple();\n+\n+alter table src update C = 'test1' where 1 settings mutations_sync=2;\n+select * from src;\n+\n+\n+drop table if exists src;\n+create table src( A String, B String, C String) Engine=ReplicatedMergeTree('/clickhouse/{database}/test/src3', '1') order by A SETTINGS min_bytes_for_wide_part=0;\n+insert into src values('one', 'one', 'test');\n+\n+alter table src detach partition tuple();\n+alter table src modify column A LowCardinality(String);\n+alter table src attach partition tuple();\n+\n+alter table src modify column C LowCardinality(String);\n+select * from src;\n+\n+drop table if exists src;\n+create table src( A String, B String, C String) Engine=ReplicatedMergeTree('/clickhouse/{database}/test/src4', '1') order by A SETTINGS min_bytes_for_wide_part=0;\n+insert into src values('one', 'one', 'test');\n+\n+alter table src detach partition tuple();\n+alter table src modify column B Nullable(String);\n+alter table src attach partition tuple();\n+\n+alter table src rename column B to D;\n+select * from src;\n+\n",
  "problem_statement": "alter update \"corrupts\" collumns.txt\n```sql\r\ndrop table if exists src;\r\n\r\ncreate table src( A Int64, B String, C String) Engine=MergeTree order by A\r\nSETTINGS min_bytes_for_wide_part=0;\r\ninsert into src values(1, 'one', 'test');\r\n\r\nalter table src detach partition tuple();\r\n\r\nalter table src modify column B Nullable(String);\r\n\r\nalter table src attach partition tuple();\r\nselect * from src;\r\n\u250c\u2500A\u2500\u252c\u2500B\u2500\u2500\u2500\u252c\u2500C\u2500\u2500\u2500\u2500\u2510\r\n\u2502 1 \u2502 one \u2502 test \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nalter table src update C = 'test1' where 1 settings mutations_sync=2;\r\n\r\nselect * from src;\r\n\u250c\u2500A\u2500\u252c\u2500B\u2500\u2500\u2500\u2500\u252c\u2500C\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 1 \u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502 test1 \u2502   -- expected B='one'\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n```sql\r\ndrop table if exists src;\r\ncreate table src( A String, B String, C String) Engine=MergeTree order by A\r\nSETTINGS min_bytes_for_wide_part=0;\r\ninsert into src values('one', 'one', 'test');\r\n\r\nalter table src detach partition tuple();\r\n\r\nalter table src modify column A LowCardinality(String);\r\n\r\nalter table src attach partition tuple();\r\n\r\nselect * from src;\r\n\u250c\u2500A\u2500\u2500\u2500\u252c\u2500B\u2500\u2500\u2500\u252c\u2500C\u2500\u2500\u2500\u2500\u2510\r\n\u2502 one \u2502 one \u2502 test \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nalter table src update C = 'test1' where 1 settings mutations_sync=2;\r\n\r\nselect * from src;\r\n\r\nReceived exception from server (version 22.9.1):\r\nCode: 49. DB::Exception: Received from localhost:9000. DB::Exception: \r\nGot empty stream for SerializationLowCardinality keys.: (while reading column A): \r\n(while reading from part /var/lib/clickhouse/store/11b/11b74812-48b9-4c1f-9bdc-3e7a28137a9e/all_3_3_0_4/ from mark 0 with max_rows_to_read = 1): \r\nWhile executing MergeTreeInOrder. (LOGICAL_ERROR)\r\n\r\n```\r\n\r\n```sql\r\ndrop table if exists src;\r\ncreate table src( A String, B String, C String) Engine=MergeTree order by A\r\nSETTINGS min_bytes_for_wide_part=0;\r\ninsert into src values('one', 'one', 'test');\r\n\r\nalter table src detach partition tuple();\r\n\r\nalter table src modify column A LowCardinality(String);\r\n\r\nalter table src attach partition tuple();\r\n\r\nselect * from src;\r\n\u250c\u2500A\u2500\u2500\u2500\u252c\u2500B\u2500\u2500\u2500\u252c\u2500C\u2500\u2500\u2500\u2500\u2510\r\n\u2502 one \u2502 one \u2502 test \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nalter table src modify column C LowCardinality(String);\r\n\r\nselect * from src;\r\n\r\nReceived exception from server (version 22.9.3):\r\nCode: 49. DB::Exception: Received from localhost:9000. \r\nDB::Exception: Got empty stream for SerializationLowCardinality keys.: \r\n```\r\n\r\nrelated https://github.com/ClickHouse/ClickHouse/issues/42083 , https://github.com/ClickHouse/ClickHouse/issues/42074\r\n(basically it's the same one issue, but I opened this one, because I think the root issue is in `alter update`.\r\n\r\nit seems `alter update` updates columns.txt for all columns even if they are not participated in the `alter update`.\n",
  "hints_text": "",
  "created_at": "2022-10-14T15:04:18Z"
}