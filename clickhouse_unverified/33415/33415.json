{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 33415,
  "instance_id": "ClickHouse__ClickHouse-33415",
  "issue_numbers": [
    "33390"
  ],
  "base_commit": "d274c00ec7792068a7197d938887d193925a9ce5",
  "patch": "diff --git a/docs/en/sql-reference/functions/array-functions.md b/docs/en/sql-reference/functions/array-functions.md\nindex d85092d683af..234e801de4eb 100644\n--- a/docs/en/sql-reference/functions/array-functions.md\n+++ b/docs/en/sql-reference/functions/array-functions.md\n@@ -1392,6 +1392,12 @@ Returns the first element in the `arr1` array for which `func` returns something\n \n Note that the `arrayFirst` is a [higher-order function](../../sql-reference/functions/index.md#higher-order-functions). You must pass a lambda function to it as the first argument, and it can\u2019t be omitted.\n \n+## arrayLast(func, arr1, \u2026) {#array-last}\n+\n+Returns the last element in the `arr1` array for which `func` returns something other than 0.\n+\n+Note that the `arrayLast` is a [higher-order function](../../sql-reference/functions/index.md#higher-order-functions). You must pass a lambda function to it as the first argument, and it can\u2019t be omitted.\n+\n ## arrayFirstIndex(func, arr1, \u2026) {#array-first-index}\n \n Returns the index of the first element in the `arr1` array for which `func` returns something other than 0.\ndiff --git a/src/Functions/array/arrayFirst.cpp b/src/Functions/array/arrayFirst.cpp\nindex dbe545ea3875..edbf7ef6269c 100644\n--- a/src/Functions/array/arrayFirst.cpp\n+++ b/src/Functions/array/arrayFirst.cpp\n@@ -11,7 +11,14 @@ namespace ErrorCodes\n     extern const int ILLEGAL_COLUMN;\n }\n \n-struct ArrayFirstImpl\n+enum class ArrayFirstLastStrategy\n+{\n+    First,\n+    Last\n+};\n+\n+template <ArrayFirstLastStrategy strategy>\n+struct ArrayFirstLastImpl\n {\n     static bool needBoolean() { return false; }\n     static bool needExpression() { return true; }\n@@ -40,15 +47,23 @@ struct ArrayFirstImpl\n                 auto out = data.cloneEmpty();\n                 out->reserve(data.size());\n \n-                size_t pos{};\n-                for (auto offset : offsets)\n+                size_t offsets_size = offsets.size();\n+                for (size_t offset_index = 0; offset_index < offsets_size; ++offset_index)\n                 {\n-                    if (offset - pos > 0)\n-                        out->insert(data[pos]);\n+                    size_t start_offset = offsets[offset_index - 1];\n+                    size_t end_offset = offsets[offset_index];\n+\n+                    if (end_offset > start_offset)\n+                    {\n+                        if constexpr (strategy == ArrayFirstLastStrategy::First)\n+                            out->insert(data[start_offset]);\n+                        else\n+                            out->insert(data[end_offset - 1]);\n+                    }\n                     else\n+                    {\n                         out->insertDefault();\n-\n-                    pos = offset;\n+                    }\n                 }\n \n                 return out;\n@@ -67,18 +82,36 @@ struct ArrayFirstImpl\n         auto out = data.cloneEmpty();\n         out->reserve(data.size());\n \n-        size_t pos{};\n-        for (auto offset : offsets)\n+        size_t offsets_size = offsets.size();\n+        for (size_t offset_index = 0; offset_index < offsets_size; ++offset_index)\n         {\n-            auto exists = false;\n-            for (; pos < offset; ++pos)\n+            size_t start_offset = offsets[offset_index - 1];\n+            size_t end_offset = offsets[offset_index];\n+\n+            bool exists = false;\n+\n+            if constexpr (strategy == ArrayFirstLastStrategy::First)\n             {\n-                if (filter[pos])\n+                for (; start_offset != end_offset; ++start_offset)\n                 {\n-                    out->insert(data[pos]);\n-                    exists = true;\n-                    pos = offset;\n-                    break;\n+                    if (filter[start_offset])\n+                    {\n+                        out->insert(data[start_offset]);\n+                        exists = true;\n+                        break;\n+                    }\n+                }\n+            }\n+            else\n+            {\n+                for (; end_offset != start_offset; --end_offset)\n+                {\n+                    if (filter[end_offset - 1])\n+                    {\n+                        out->insert(data[end_offset - 1]);\n+                        exists = true;\n+                        break;\n+                    }\n                 }\n             }\n \n@@ -91,11 +124,17 @@ struct ArrayFirstImpl\n };\n \n struct NameArrayFirst { static constexpr auto name = \"arrayFirst\"; };\n+using ArrayFirstImpl = ArrayFirstLastImpl<ArrayFirstLastStrategy::First>;\n using FunctionArrayFirst = FunctionArrayMapped<ArrayFirstImpl, NameArrayFirst>;\n \n+struct NameArrayLast { static constexpr auto name = \"arrayLast\"; };\n+using ArrayLastImpl = ArrayFirstLastImpl<ArrayFirstLastStrategy::Last>;\n+using FunctionArrayLast = FunctionArrayMapped<ArrayLastImpl, NameArrayLast>;\n+\n void registerFunctionArrayFirst(FunctionFactory & factory)\n {\n     factory.registerFunction<FunctionArrayFirst>();\n+    factory.registerFunction<FunctionArrayLast>();\n }\n \n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02161_array_first_last.reference b/tests/queries/0_stateless/02161_array_first_last.reference\nnew file mode 100644\nindex 000000000000..25734a6f01c8\n--- /dev/null\n+++ b/tests/queries/0_stateless/02161_array_first_last.reference\n@@ -0,0 +1,18 @@\n+ArrayFirst constant predicate\n+0\n+0\n+1\n+0\n+ArrayFirst non constant predicate\n+0\n+2\n+2\n+ArrayLast constant predicate\n+0\n+0\n+3\n+0\n+ArrayLast non constant predicate\n+0\n+3\n+3\ndiff --git a/tests/queries/0_stateless/02161_array_first_last.sql b/tests/queries/0_stateless/02161_array_first_last.sql\nnew file mode 100644\nindex 000000000000..a13cdbc765dc\n--- /dev/null\n+++ b/tests/queries/0_stateless/02161_array_first_last.sql\n@@ -0,0 +1,21 @@\n+SELECT 'ArrayFirst constant predicate';\n+SELECT arrayFirst(x -> 1, emptyArrayUInt8());\n+SELECT arrayFirst(x -> 0, emptyArrayUInt8());\n+SELECT arrayFirst(x -> 1, [1, 2, 3]);\n+SELECT arrayFirst(x -> 0, [1, 2, 3]);\n+\n+SELECT 'ArrayFirst non constant predicate';\n+SELECT arrayFirst(x -> x >= 2, emptyArrayUInt8());\n+SELECT arrayFirst(x -> x >= 2, [1, 2, 3]);\n+SELECT arrayFirst(x -> x >= 2, [1, 2, 3]);\n+\n+SELECT 'ArrayLast constant predicate';\n+SELECT arrayLast(x -> 1, emptyArrayUInt8());\n+SELECT arrayLast(x -> 0, emptyArrayUInt8());\n+SELECT arrayLast(x -> 1, [1, 2, 3]);\n+SELECT arrayLast(x -> 0, [1, 2, 3]);\n+\n+SELECT 'ArrayLast non constant predicate';\n+SELECT arrayLast(x -> x >= 2, emptyArrayUInt8());\n+SELECT arrayLast(x -> x >= 2, [1, 2, 3]);\n+SELECT arrayLast(x -> x >= 2, [1, 2, 3]);\n",
  "problem_statement": "Add arrayLast function (same as arrayFirst, but get the last element instead of the first)\nCurrently we need to write smth like\r\n`select arrayFilter(...)[-1]`\r\nto get the last element. \r\nAt the same time, we have `arrayFirst` function for the first element of array.\r\n\r\nI think clickhouse community need analogy of function arrayFirst, but for last element.\r\n\r\nMy proposal is arrayLast function:\r\n```\r\nselect range(10)                               as arr,\r\n       arrayFirst((a)->(a > 3 and a < 8), arr) as first_element,\r\n       arrayLast((a)->(a > 3 and a < 8), arr)  as last_element\r\n```\r\nwith result\r\n![image](https://user-images.githubusercontent.com/4305175/148060114-81e83e9b-e02e-499e-8e1c-b48e99e46f02.png)\r\n\n",
  "hints_text": "",
  "created_at": "2022-01-05T13:16:02Z"
}