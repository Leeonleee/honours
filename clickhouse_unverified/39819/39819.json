{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 39819,
  "instance_id": "ClickHouse__ClickHouse-39819",
  "issue_numbers": [
    "31616"
  ],
  "base_commit": "f05b29d38c7ed17ab6919ef65b11069703b810d2",
  "patch": "diff --git a/src/Access/ContextAccess.cpp b/src/Access/ContextAccess.cpp\nindex 4e409946666e..7584dd2f2b11 100644\n--- a/src/Access/ContextAccess.cpp\n+++ b/src/Access/ContextAccess.cpp\n@@ -379,12 +379,12 @@ std::shared_ptr<const EnabledRowPolicies> ContextAccess::getEnabledRowPolicies()\n     return no_row_policies;\n }\n \n-ASTPtr ContextAccess::getRowPolicyFilter(const String & database, const String & table_name, RowPolicyFilterType filter_type, const ASTPtr & combine_with_expr) const\n+RowPolicyFilterPtr ContextAccess::getRowPolicyFilter(const String & database, const String & table_name, RowPolicyFilterType filter_type, RowPolicyFilterPtr combine_with_filter) const\n {\n     std::lock_guard lock{mutex};\n     if (enabled_row_policies)\n-        return enabled_row_policies->getFilter(database, table_name, filter_type, combine_with_expr);\n-    return nullptr;\n+        return enabled_row_policies->getFilter(database, table_name, filter_type, combine_with_filter);\n+    return combine_with_filter;\n }\n \n std::shared_ptr<const EnabledQuota> ContextAccess::getQuota() const\ndiff --git a/src/Access/ContextAccess.h b/src/Access/ContextAccess.h\nindex ce1ea2d12204..84ef0ab722d5 100644\n--- a/src/Access/ContextAccess.h\n+++ b/src/Access/ContextAccess.h\n@@ -1,7 +1,7 @@\n #pragma once\n \n #include <Access/AccessRights.h>\n-#include <Access/Common/RowPolicyDefs.h>\n+#include <Access/EnabledRowPolicies.h>\n #include <Interpreters/ClientInfo.h>\n #include <Core/UUID.h>\n #include <base/scope_guard.h>\n@@ -87,7 +87,7 @@ class ContextAccess : public std::enable_shared_from_this<ContextAccess>\n \n     /// Returns the row policy filter for a specified table.\n     /// The function returns nullptr if there is no filter to apply.\n-    ASTPtr getRowPolicyFilter(const String & database, const String & table_name, RowPolicyFilterType filter_type, const ASTPtr & combine_with_expr = nullptr) const;\n+    RowPolicyFilterPtr getRowPolicyFilter(const String & database, const String & table_name, RowPolicyFilterType filter_type, RowPolicyFilterPtr combine_with_filter = {}) const;\n \n     /// Returns the quota to track resource consumption.\n     std::shared_ptr<const EnabledQuota> getQuota() const;\ndiff --git a/src/Access/EnabledRowPolicies.cpp b/src/Access/EnabledRowPolicies.cpp\nindex e4f592884fe6..c00dcf9e3a7e 100644\n--- a/src/Access/EnabledRowPolicies.cpp\n+++ b/src/Access/EnabledRowPolicies.cpp\n@@ -6,12 +6,18 @@\n \n namespace DB\n {\n+\n+bool RowPolicyFilter::empty() const\n+{\n+    bool value;\n+    return !expression || (tryGetLiteralBool(expression.get(), value) && value);\n+}\n+\n size_t EnabledRowPolicies::Hash::operator()(const MixedFiltersKey & key) const\n {\n     return std::hash<std::string_view>{}(key.database) - std::hash<std::string_view>{}(key.table_name) + static_cast<size_t>(key.filter_type);\n }\n \n-\n EnabledRowPolicies::EnabledRowPolicies() : params()\n {\n }\n@@ -23,7 +29,7 @@ EnabledRowPolicies::EnabledRowPolicies(const Params & params_) : params(params_)\n EnabledRowPolicies::~EnabledRowPolicies() = default;\n \n \n-ASTPtr EnabledRowPolicies::getFilter(const String & database, const String & table_name, RowPolicyFilterType filter_type) const\n+RowPolicyFilterPtr EnabledRowPolicies::getFilter(const String & database, const String & table_name, RowPolicyFilterType filter_type) const\n {\n     /// We don't lock `mutex` here.\n     auto loaded = mixed_filters.load();\n@@ -31,26 +37,36 @@ ASTPtr EnabledRowPolicies::getFilter(const String & database, const String & tab\n     if (it == loaded->end())\n         return {};\n \n-    auto filter = it->second.ast;\n-\n-    bool value;\n-    if (tryGetLiteralBool(filter.get(), value) && value)\n-        return nullptr; /// The condition is always true, no need to check it.\n-\n-    return filter;\n+    return it->second;\n }\n \n-ASTPtr EnabledRowPolicies::getFilter(const String & database, const String & table_name, RowPolicyFilterType filter_type, const ASTPtr & combine_with_expr) const\n+RowPolicyFilterPtr EnabledRowPolicies::getFilter(const String & database, const String & table_name, RowPolicyFilterType filter_type, RowPolicyFilterPtr combine_with_filter) const\n {\n-    ASTPtr filter = getFilter(database, table_name, filter_type);\n-    if (filter && combine_with_expr)\n-        filter = makeASTForLogicalAnd({filter, combine_with_expr});\n-    else if (!filter)\n-        filter = combine_with_expr;\n+    RowPolicyFilterPtr filter = getFilter(database, table_name, filter_type);\n+    if (filter && combine_with_filter)\n+    {\n+        auto new_filter = std::make_shared<RowPolicyFilter>(*filter);\n \n-    bool value;\n-    if (tryGetLiteralBool(filter.get(), value) && value)\n-        return nullptr;  /// The condition is always true, no need to check it.\n+        if (filter->empty())\n+        {\n+            new_filter->expression = combine_with_filter->expression;\n+        }\n+        else if (combine_with_filter->empty())\n+        {\n+            new_filter->expression = filter->expression;\n+        }\n+        else\n+        {\n+            new_filter->expression = makeASTForLogicalAnd({filter->expression, combine_with_filter->expression});\n+        }\n+\n+        std::copy(combine_with_filter->policies.begin(), combine_with_filter->policies.end(), std::back_inserter(new_filter->policies));\n+        filter = new_filter;\n+    }\n+    else if (!filter)\n+    {\n+        filter = combine_with_filter;\n+    }\n \n     return filter;\n }\ndiff --git a/src/Access/EnabledRowPolicies.h b/src/Access/EnabledRowPolicies.h\nindex a3d3f009408e..b8e6b2e05493 100644\n--- a/src/Access/EnabledRowPolicies.h\n+++ b/src/Access/EnabledRowPolicies.h\n@@ -1,12 +1,16 @@\n #pragma once\n \n #include <Access/Common/RowPolicyDefs.h>\n+#include <Access/RowPolicy.h>\n #include <base/types.h>\n #include <Core/UUID.h>\n+\n #include <boost/container/flat_set.hpp>\n #include <boost/smart_ptr/atomic_shared_ptr.hpp>\n-#include <unordered_map>\n+\n #include <memory>\n+#include <unordered_map>\n+#include <vector>\n \n \n namespace DB\n@@ -14,6 +18,19 @@ namespace DB\n class IAST;\n using ASTPtr = std::shared_ptr<IAST>;\n \n+struct RowPolicyFilter;\n+using RowPolicyFilterPtr = std::shared_ptr<const RowPolicyFilter>;\n+\n+\n+struct RowPolicyFilter\n+{\n+    ASTPtr expression;\n+    std::shared_ptr<const std::pair<String, String>> database_and_table_name;\n+    std::vector<RowPolicyPtr> policies;\n+\n+    bool empty() const;\n+};\n+\n \n /// Provides fast access to row policies' conditions for a specific user and tables.\n class EnabledRowPolicies\n@@ -39,8 +56,8 @@ class EnabledRowPolicies\n     /// Returns prepared filter for a specific table and operations.\n     /// The function can return nullptr, that means there is no filters applied.\n     /// The returned filter can be a combination of the filters defined by multiple row policies.\n-    ASTPtr getFilter(const String & database, const String & table_name, RowPolicyFilterType filter_type) const;\n-    ASTPtr getFilter(const String & database, const String & table_name, RowPolicyFilterType filter_type, const ASTPtr & combine_with_expr) const;\n+    RowPolicyFilterPtr getFilter(const String & database, const String & table_name, RowPolicyFilterType filter_type) const;\n+    RowPolicyFilterPtr getFilter(const String & database, const String & table_name, RowPolicyFilterType filter_type, RowPolicyFilterPtr combine_with_filter) const;\n \n private:\n     friend class RowPolicyCache;\n@@ -57,18 +74,12 @@ class EnabledRowPolicies\n         friend bool operator!=(const MixedFiltersKey & left, const MixedFiltersKey & right) { return left.toTuple() != right.toTuple(); }\n     };\n \n-    struct MixedFiltersResult\n-    {\n-        ASTPtr ast;\n-        std::shared_ptr<const std::pair<String, String>> database_and_table_name;\n-    };\n-\n     struct Hash\n     {\n         size_t operator()(const MixedFiltersKey & key) const;\n     };\n \n-    using MixedFiltersMap = std::unordered_map<MixedFiltersKey, MixedFiltersResult, Hash>;\n+    using MixedFiltersMap = std::unordered_map<MixedFiltersKey, RowPolicyFilterPtr, Hash>;\n \n     const Params params;\n     mutable boost::atomic_shared_ptr<const MixedFiltersMap> mixed_filters;\ndiff --git a/src/Access/RowPolicyCache.cpp b/src/Access/RowPolicyCache.cpp\nindex 34549e3fa629..1036df926097 100644\n--- a/src/Access/RowPolicyCache.cpp\n+++ b/src/Access/RowPolicyCache.cpp\n@@ -212,6 +212,7 @@ void RowPolicyCache::mixFiltersFor(EnabledRowPolicies & enabled)\n     {\n         FiltersMixer mixer;\n         std::shared_ptr<const std::pair<String, String>> database_and_table_name;\n+        std::vector<RowPolicyPtr> policies;\n     };\n \n     std::unordered_map<MixedFiltersKey, MixerWithNames, Hash> mixers;\n@@ -232,7 +233,10 @@ void RowPolicyCache::mixFiltersFor(EnabledRowPolicies & enabled)\n                 auto & mixer = mixers[key];\n                 mixer.database_and_table_name = info.database_and_table_name;\n                 if (match)\n+                {\n                     mixer.mixer.add(info.parsed_filters[filter_type_i], policy.isRestrictive());\n+                    mixer.policies.push_back(info.policy);\n+                }\n             }\n         }\n     }\n@@ -240,9 +244,11 @@ void RowPolicyCache::mixFiltersFor(EnabledRowPolicies & enabled)\n     auto mixed_filters = boost::make_shared<MixedFiltersMap>();\n     for (auto & [key, mixer] : mixers)\n     {\n-        auto & mixed_filter = (*mixed_filters)[key];\n-        mixed_filter.database_and_table_name = mixer.database_and_table_name;\n-        mixed_filter.ast = std::move(mixer.mixer).getResult(access_control.isEnabledUsersWithoutRowPoliciesCanReadRows());\n+        auto mixed_filter = std::make_shared<RowPolicyFilter>();\n+        mixed_filter->database_and_table_name = std::move(mixer.database_and_table_name);\n+        mixed_filter->expression = std::move(mixer.mixer).getResult(access_control.isEnabledUsersWithoutRowPoliciesCanReadRows());\n+        mixed_filter->policies = std::move(mixer.policies);\n+        mixed_filters->emplace(key, std::move(mixed_filter));\n     }\n \n     enabled.mixed_filters.store(mixed_filters);\ndiff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp\nindex 9c949a17e644..2d3d378e9265 100644\n--- a/src/Interpreters/Context.cpp\n+++ b/src/Interpreters/Context.cpp\n@@ -987,10 +987,12 @@ std::shared_ptr<const ContextAccess> Context::getAccess() const\n     return access ? access : ContextAccess::getFullAccess();\n }\n \n-ASTPtr Context::getRowPolicyFilter(const String & database, const String & table_name, RowPolicyFilterType filter_type) const\n+RowPolicyFilterPtr Context::getRowPolicyFilter(const String & database, const String & table_name, RowPolicyFilterType filter_type) const\n {\n     auto lock = getLock();\n-    auto row_filter_of_initial_user = row_policies_of_initial_user ? row_policies_of_initial_user->getFilter(database, table_name, filter_type) : nullptr;\n+    RowPolicyFilterPtr row_filter_of_initial_user;\n+    if (row_policies_of_initial_user)\n+        row_filter_of_initial_user = row_policies_of_initial_user->getFilter(database, table_name, filter_type);\n     return getAccess()->getRowPolicyFilter(database, table_name, filter_type, row_filter_of_initial_user);\n }\n \ndiff --git a/src/Interpreters/Context.h b/src/Interpreters/Context.h\nindex eeb9e8da1483..0eaec2155885 100644\n--- a/src/Interpreters/Context.h\n+++ b/src/Interpreters/Context.h\n@@ -45,6 +45,8 @@ struct User;\n using UserPtr = std::shared_ptr<const User>;\n struct EnabledRolesInfo;\n class EnabledRowPolicies;\n+struct RowPolicyFilter;\n+using RowPolicyFilterPtr = std::shared_ptr<const RowPolicyFilter>;\n class EnabledQuota;\n struct QuotaUsage;\n class AccessFlags;\n@@ -516,7 +518,7 @@ class Context: public std::enable_shared_from_this<Context>\n \n     std::shared_ptr<const ContextAccess> getAccess() const;\n \n-    ASTPtr getRowPolicyFilter(const String & database, const String & table_name, RowPolicyFilterType filter_type) const;\n+    RowPolicyFilterPtr getRowPolicyFilter(const String & database, const String & table_name, RowPolicyFilterType filter_type) const;\n \n     /// Finds and sets extra row policies to be used based on `client_info.initial_user`,\n     /// if the initial user exists.\ndiff --git a/src/Interpreters/IInterpreterUnionOrSelectQuery.cpp b/src/Interpreters/IInterpreterUnionOrSelectQuery.cpp\nindex 6319949655bd..5df3abbb32e1 100644\n--- a/src/Interpreters/IInterpreterUnionOrSelectQuery.cpp\n+++ b/src/Interpreters/IInterpreterUnionOrSelectQuery.cpp\n@@ -6,21 +6,21 @@\n #include <QueryPipeline/QueryPipelineBuilder.h>\n #include <Parsers/ExpressionListParsers.h>\n #include <Parsers/parseQuery.h>\n-#include <Interpreters/TreeRewriter.h>\n #include <Interpreters/ActionsDAG.h>\n #include <Interpreters/ExpressionAnalyzer.h>\n+#include <Interpreters/TreeRewriter.h>\n #include <Processors/QueryPlan/IQueryPlanStep.h>\n #include <Processors/QueryPlan/FilterStep.h>\n \n+\n namespace DB\n {\n \n-void IInterpreterUnionOrSelectQuery::extendQueryLogElemImpl(QueryLogElement & elem, const ASTPtr &, ContextPtr) const\n+void IInterpreterUnionOrSelectQuery::extendQueryLogElemImpl(QueryLogElement & elem, const ASTPtr & /*ast*/, ContextPtr /*context_*/) const\n {\n     elem.query_kind = \"Select\";\n }\n \n-\n QueryPipelineBuilder IInterpreterUnionOrSelectQuery::buildQueryPipeline()\n {\n     QueryPlan query_plan;\ndiff --git a/src/Interpreters/IInterpreterUnionOrSelectQuery.h b/src/Interpreters/IInterpreterUnionOrSelectQuery.h\nindex a1c86f9de857..81554340669d 100644\n--- a/src/Interpreters/IInterpreterUnionOrSelectQuery.h\n+++ b/src/Interpreters/IInterpreterUnionOrSelectQuery.h\n@@ -44,7 +44,7 @@ class IInterpreterUnionOrSelectQuery : public IInterpreter\n \n     size_t getMaxStreams() const { return max_streams; }\n \n-    void extendQueryLogElemImpl(QueryLogElement & elem, const ASTPtr &, ContextPtr) const override;\n+    void extendQueryLogElemImpl(QueryLogElement & elem, const ASTPtr & ast, ContextPtr context) const override;\n \n     /// Returns whether the query uses the view source from the Context\n     /// The view source is a virtual storage that currently only materialized views use to replace the source table\ndiff --git a/src/Interpreters/InterpreterSelectIntersectExceptQuery.cpp b/src/Interpreters/InterpreterSelectIntersectExceptQuery.cpp\nindex a134f7bb9138..15945cbbeef6 100644\n--- a/src/Interpreters/InterpreterSelectIntersectExceptQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectIntersectExceptQuery.cpp\n@@ -1,7 +1,10 @@\n+#include <Access/AccessControl.h>\n+\n #include <Columns/getLeastSuperColumn.h>\n #include <Interpreters/Context.h>\n #include <Interpreters/InterpreterSelectIntersectExceptQuery.h>\n #include <Interpreters/InterpreterSelectQuery.h>\n+#include <Interpreters/QueryLog.h>\n #include <Parsers/ASTSelectIntersectExceptQuery.h>\n #include <Parsers/ASTSelectWithUnionQuery.h>\n #include <Processors/QueryPlan/DistinctStep.h>\n@@ -188,4 +191,25 @@ void InterpreterSelectIntersectExceptQuery::ignoreWithTotals()\n         interpreter->ignoreWithTotals();\n }\n \n+void InterpreterSelectIntersectExceptQuery::extendQueryLogElemImpl(QueryLogElement & elem, const ASTPtr & /*ast*/, ContextPtr /*context_*/) const\n+{\n+    elem.query_kind = \"Select\";\n+\n+    for (const auto & interpreter : nested_interpreters)\n+    {\n+        if (const auto * select_interpreter = dynamic_cast<const InterpreterSelectQuery *>(interpreter.get()))\n+        {\n+            auto filter = select_interpreter->getRowPolicyFilter();\n+            if (filter)\n+            {\n+                for (const auto & row_policy : filter->policies)\n+                {\n+                    auto name = row_policy->getFullName().toString();\n+                    elem.used_row_policies.emplace(std::move(name));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n }\ndiff --git a/src/Interpreters/InterpreterSelectIntersectExceptQuery.h b/src/Interpreters/InterpreterSelectIntersectExceptQuery.h\nindex 79ee32e514a2..e93ab7bd2e9a 100644\n--- a/src/Interpreters/InterpreterSelectIntersectExceptQuery.h\n+++ b/src/Interpreters/InterpreterSelectIntersectExceptQuery.h\n@@ -35,6 +35,8 @@ using Operator = ASTSelectIntersectExceptQuery::Operator;\n \n     void ignoreWithTotals() override;\n \n+    void extendQueryLogElemImpl(QueryLogElement & elem, const ASTPtr & ast, ContextPtr context) const override;\n+\n private:\n     static String getName() { return \"SelectIntersectExceptQuery\"; }\n \ndiff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex d8ac263e3d15..2948d7569868 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -1,3 +1,5 @@\n+#include <Access/AccessControl.h>\n+\n #include <DataTypes/DataTypeAggregateFunction.h>\n #include <DataTypes/DataTypeInterval.h>\n \n@@ -33,6 +35,7 @@\n #include <Interpreters/JoinedTables.h>\n #include <Interpreters/OpenTelemetrySpanLog.h>\n #include <Interpreters/QueryAliasesVisitor.h>\n+#include <Interpreters/QueryLog.h>\n #include <Interpreters/replaceAliasColumnsInQuery.h>\n #include <Interpreters/RewriteCountDistinctVisitor.h>\n \n@@ -112,7 +115,7 @@ namespace ErrorCodes\n /// Assumes `storage` is set and the table filter (row-level security) is not empty.\n FilterDAGInfoPtr generateFilterActions(\n     const StorageID & table_id,\n-    const ASTPtr & row_policy_filter,\n+    const ASTPtr & row_policy_filter_expression,\n     const ContextPtr & context,\n     const StoragePtr & storage,\n     const StorageSnapshotPtr & storage_snapshot,\n@@ -133,9 +136,9 @@ FilterDAGInfoPtr generateFilterActions(\n     auto expr_list = select_ast->select();\n \n     /// The first column is our filter expression.\n-    /// the row_policy_filter should be cloned, because it may be changed by TreeRewriter.\n+    /// the row_policy_filter_expression should be cloned, because it may be changed by TreeRewriter.\n     /// which make it possible an invalid expression, although it may be valid in whole select.\n-    expr_list->children.push_back(row_policy_filter->clone());\n+    expr_list->children.push_back(row_policy_filter_expression->clone());\n \n     /// Keep columns that are required after the filter actions.\n     for (const auto & column_str : prerequisite_columns)\n@@ -613,13 +616,13 @@ InterpreterSelectQuery::InterpreterSelectQuery(\n             query_info.filter_asts.clear();\n \n             /// Fix source_header for filter actions.\n-            if (row_policy_filter)\n+            if (row_policy_filter && !row_policy_filter->empty())\n             {\n                 filter_info = generateFilterActions(\n-                    table_id, row_policy_filter, context, storage, storage_snapshot, metadata_snapshot, required_columns,\n+                    table_id, row_policy_filter->expression, context, storage, storage_snapshot, metadata_snapshot, required_columns,\n                     prepared_sets);\n \n-                query_info.filter_asts.push_back(row_policy_filter);\n+                query_info.filter_asts.push_back(row_policy_filter->expression);\n             }\n \n             if (query_info.additional_filter_ast)\n@@ -1866,6 +1869,22 @@ void InterpreterSelectQuery::setProperClientInfo(size_t replica_num, size_t repl\n     context->getClientInfo().number_of_current_replica = replica_num;\n }\n \n+RowPolicyFilterPtr InterpreterSelectQuery::getRowPolicyFilter() const\n+{\n+    return row_policy_filter;\n+}\n+\n+void InterpreterSelectQuery::extendQueryLogElemImpl(QueryLogElement & elem, const ASTPtr & /*ast*/, ContextPtr /*context_*/) const\n+{\n+    elem.query_kind = \"Select\";\n+\n+    for (const auto & row_policy : row_policy_filter->policies)\n+    {\n+        auto name = row_policy->getFullName().toString();\n+        elem.used_row_policies.emplace(std::move(name));\n+    }\n+}\n+\n bool InterpreterSelectQuery::shouldMoveToPrewhere()\n {\n     const Settings & settings = context->getSettingsRef();\ndiff --git a/src/Interpreters/InterpreterSelectQuery.h b/src/Interpreters/InterpreterSelectQuery.h\nindex 3b933547422a..761eea8e1b8a 100644\n--- a/src/Interpreters/InterpreterSelectQuery.h\n+++ b/src/Interpreters/InterpreterSelectQuery.h\n@@ -2,6 +2,7 @@\n \n #include <memory>\n \n+#include <Access/EnabledRowPolicies.h>\n #include <Core/QueryProcessingStage.h>\n #include <Interpreters/ExpressionActions.h>\n #include <Interpreters/ExpressionAnalyzer.h>\n@@ -23,6 +24,7 @@ class Logger;\n \n namespace DB\n {\n+\n class SubqueryForSet;\n class InterpreterSelectWithUnionQuery;\n class Context;\n@@ -34,6 +36,9 @@ using GroupingSetsParamsList = std::vector<GroupingSetsParams>;\n struct TreeRewriterResult;\n using TreeRewriterResultPtr = std::shared_ptr<const TreeRewriterResult>;\n \n+struct RowPolicy;\n+using RowPolicyPtr = std::shared_ptr<const RowPolicy>;\n+\n \n /** Interprets the SELECT query. Returns the stream of blocks with the results of the query before `to_stage` stage.\n   */\n@@ -129,6 +134,10 @@ class InterpreterSelectQuery : public IInterpreterUnionOrSelectQuery\n \n     FilterDAGInfoPtr getAdditionalQueryInfo() const { return additional_filter_info; }\n \n+    RowPolicyFilterPtr getRowPolicyFilter() const;\n+\n+    void extendQueryLogElemImpl(QueryLogElement & elem, const ASTPtr & ast, ContextPtr context) const override;\n+\n     static SortDescription getSortDescription(const ASTSelectQuery & query, const ContextPtr & context);\n     static UInt64 getLimitForSorting(const ASTSelectQuery & query, const ContextPtr & context);\n \n@@ -209,7 +218,7 @@ class InterpreterSelectQuery : public IInterpreterUnionOrSelectQuery\n     /// Is calculated in getSampleBlock. Is used later in readImpl.\n     ExpressionAnalysisResult analysis_result;\n     /// For row-level security.\n-    ASTPtr row_policy_filter;\n+    RowPolicyFilterPtr row_policy_filter;\n     FilterDAGInfoPtr filter_info;\n \n     /// For additional_filter setting.\ndiff --git a/src/Interpreters/InterpreterSelectWithUnionQuery.cpp b/src/Interpreters/InterpreterSelectWithUnionQuery.cpp\nindex a679b17a5bdd..c695dae6d534 100644\n--- a/src/Interpreters/InterpreterSelectWithUnionQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectWithUnionQuery.cpp\n@@ -1,8 +1,11 @@\n+#include <Access/AccessControl.h>\n+\n #include <Columns/getLeastSuperColumn.h>\n #include <Interpreters/Context.h>\n #include <Interpreters/InterpreterSelectQuery.h>\n #include <Interpreters/InterpreterSelectWithUnionQuery.h>\n #include <Interpreters/InterpreterSelectIntersectExceptQuery.h>\n+#include <Interpreters/QueryLog.h>\n #include <Parsers/ASTSelectQuery.h>\n #include <Parsers/ASTSelectWithUnionQuery.h>\n #include <Parsers/ASTSelectIntersectExceptQuery.h>\n@@ -22,6 +25,7 @@\n \n #include <algorithm>\n \n+\n namespace DB\n {\n \n@@ -382,4 +386,25 @@ void InterpreterSelectWithUnionQuery::ignoreWithTotals()\n         interpreter->ignoreWithTotals();\n }\n \n+void InterpreterSelectWithUnionQuery::extendQueryLogElemImpl(QueryLogElement & elem, const ASTPtr & /*ast*/, ContextPtr /*context_*/) const\n+{\n+    elem.query_kind = \"Select\";\n+\n+    for (const auto & interpreter : nested_interpreters)\n+    {\n+        if (const auto * select_interpreter = dynamic_cast<const InterpreterSelectQuery *>(interpreter.get()))\n+        {\n+            auto filter = select_interpreter->getRowPolicyFilter();\n+            if (filter)\n+            {\n+                for (const auto & row_policy : filter->policies)\n+                {\n+                    auto name = row_policy->getFullName().toString();\n+                    elem.used_row_policies.emplace(std::move(name));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n }\ndiff --git a/src/Interpreters/InterpreterSelectWithUnionQuery.h b/src/Interpreters/InterpreterSelectWithUnionQuery.h\nindex ff763ec6490f..2ec4fbfceaf2 100644\n--- a/src/Interpreters/InterpreterSelectWithUnionQuery.h\n+++ b/src/Interpreters/InterpreterSelectWithUnionQuery.h\n@@ -47,6 +47,8 @@ class InterpreterSelectWithUnionQuery : public IInterpreterUnionOrSelectQuery\n \n     bool supportsTransactions() const override { return true; }\n \n+    void extendQueryLogElemImpl(QueryLogElement & elem, const ASTPtr & ast, ContextPtr context) const override;\n+\n private:\n     std::vector<std::unique_ptr<IInterpreterUnionOrSelectQuery>> nested_interpreters;\n \ndiff --git a/src/Interpreters/QueryLog.cpp b/src/Interpreters/QueryLog.cpp\nindex 72d9ce441028..224ca9f11a89 100644\n--- a/src/Interpreters/QueryLog.cpp\n+++ b/src/Interpreters/QueryLog.cpp\n@@ -1,4 +1,5 @@\n-#include <array>\n+#include <Interpreters/QueryLog.h>\n+\n #include <Columns/ColumnArray.h>\n #include <Columns/ColumnFixedString.h>\n #include <Columns/ColumnString.h>\n@@ -13,15 +14,18 @@\n #include <DataTypes/DataTypeMap.h>\n #include <DataTypes/DataTypeLowCardinality.h>\n #include <DataTypes/DataTypeString.h>\n+#include <DataTypes/DataTypeUUID.h>\n #include <DataTypes/DataTypesNumber.h>\n #include <Interpreters/ProfileEventsExt.h>\n-#include <Interpreters/QueryLog.h>\n-#include <Poco/Net/IPAddress.h>\n #include <Common/ClickHouseRevision.h>\n #include <Common/IPv6ToBinary.h>\n #include <Common/ProfileEvents.h>\n #include <Common/typeid_cast.h>\n \n+#include <Poco/Net/IPAddress.h>\n+\n+#include <array>\n+\n \n namespace DB\n {\n@@ -119,6 +123,8 @@ NamesAndTypesList QueryLogElement::getNamesAndTypes()\n         {\"used_storages\", std::make_shared<DataTypeArray>(std::make_shared<DataTypeString>())},\n         {\"used_table_functions\", std::make_shared<DataTypeArray>(std::make_shared<DataTypeString>())},\n \n+        {\"used_row_policies\", std::make_shared<DataTypeArray>(std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>()))},\n+\n         {\"transaction_id\", getTransactionIDDataType()},\n     };\n \n@@ -236,13 +242,14 @@ void QueryLogElement::appendToBlock(MutableColumns & columns) const\n         auto & column_function_factory_objects = typeid_cast<ColumnArray &>(*columns[i++]);\n         auto & column_storage_factory_objects = typeid_cast<ColumnArray &>(*columns[i++]);\n         auto & column_table_function_factory_objects = typeid_cast<ColumnArray &>(*columns[i++]);\n+        auto & column_row_policies_names = typeid_cast<ColumnArray &>(*columns[i++]);\n \n-        auto fill_column = [](const std::unordered_set<String> & data, ColumnArray & column)\n+        auto fill_column = [](const auto & data, ColumnArray & column)\n         {\n             size_t size = 0;\n-            for (const auto & name : data)\n+            for (const auto & value : data)\n             {\n-                column.getData().insertData(name.data(), name.size());\n+                column.getData().insert(value);\n                 ++size;\n             }\n             auto & offsets = column.getOffsets();\n@@ -258,6 +265,7 @@ void QueryLogElement::appendToBlock(MutableColumns & columns) const\n         fill_column(used_functions, column_function_factory_objects);\n         fill_column(used_storages, column_storage_factory_objects);\n         fill_column(used_table_functions, column_table_function_factory_objects);\n+        fill_column(used_row_policies, column_row_policies_names);\n     }\n \n     columns[i++]->insert(Tuple{tid.start_csn, tid.local_tid, tid.host_id});\ndiff --git a/src/Interpreters/QueryLog.h b/src/Interpreters/QueryLog.h\nindex bb912ccc8174..75cda9719a38 100644\n--- a/src/Interpreters/QueryLog.h\n+++ b/src/Interpreters/QueryLog.h\n@@ -7,6 +7,7 @@\n #include <Interpreters/ClientInfo.h>\n #include <Interpreters/TransactionVersionMetadata.h>\n \n+\n namespace ProfileEvents\n {\n     class Counters;\n@@ -73,6 +74,7 @@ struct QueryLogElement\n     std::unordered_set<String> used_functions;\n     std::unordered_set<String> used_storages;\n     std::unordered_set<String> used_table_functions;\n+    std::set<String> used_row_policies;\n \n     Int32 exception_code{}; // because ErrorCodes are int\n     String exception;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02131_used_row_policies_in_query_log.reference b/tests/queries/0_stateless/02131_used_row_policies_in_query_log.reference\nnew file mode 100644\nindex 000000000000..d76f37cccf38\n--- /dev/null\n+++ b/tests/queries/0_stateless/02131_used_row_policies_in_query_log.reference\n@@ -0,0 +1,57 @@\n+None\n+1\n+2\n+3\n+4\n+R1: x == 1\n+1\n+R1, R2: (x == 1) OR (x == 2)\n+1\n+2\n+R1, R2, R3: (x == 1) OR (x == 2) OR (x == 3)\n+1\n+2\n+3\n+R1, R2, R3, R4: ((x == 1) OR (x == 2) OR (x == 3)) AND (x <= 2)\n+1\n+2\n+R1, R2, R3, R4, R5: ((x == 1) OR (x == 2) OR (x == 3)) AND (x <= 2) AND (x >= 2)\n+2\n+R2, R3, R4, R5: ((x == 2) OR (x == 3)) AND (x <= 2) AND (x >= 2)\n+2\n+R3, R4, R5: (x == 3) AND (x <= 2) AND (x >= 2)\n+R4, R5: (x <= 2) AND (x >= 2)\n+2\n+R5: (x >= 2)\n+2\n+3\n+4\n+None\n+1\n+2\n+3\n+4\n+Check system.query_log\n+SELECT \\'None\\';\t[]\n+SELECT * FROM 02131_rqtable;\t[]\n+SELECT \\'R1: x == 1\\';\t[]\n+SELECT * FROM 02131_rqtable;\t['`02131_filter_1` ON default.`02131_rqtable`']\n+SELECT \\'R1, R2: (x == 1) OR (x == 2)\\';\t[]\n+SELECT * FROM 02131_rqtable;\t['`02131_filter_1` ON default.`02131_rqtable`','`02131_filter_2` ON default.`02131_rqtable`']\n+SELECT \\'R1, R2, R3: (x == 1) OR (x == 2) OR (x == 3)\\';\t[]\n+SELECT * FROM 02131_rqtable;\t['`02131_filter_1` ON default.`02131_rqtable`','`02131_filter_2` ON default.`02131_rqtable`','`02131_filter_3` ON default.`02131_rqtable`']\n+SELECT \\'R1, R2, R3, R4: ((x == 1) OR (x == 2) OR (x == 3)) AND (x <= 2)\\';\t[]\n+SELECT * FROM 02131_rqtable;\t['`02131_filter_1` ON default.`02131_rqtable`','`02131_filter_2` ON default.`02131_rqtable`','`02131_filter_3` ON default.`02131_rqtable`','`02131_filter_4` ON default.`02131_rqtable`']\n+SELECT \\'R1, R2, R3, R4, R5: ((x == 1) OR (x == 2) OR (x == 3)) AND (x <= 2) AND (x >= 2)\\';\t[]\n+SELECT * FROM 02131_rqtable;\t['`02131_filter_1` ON default.`02131_rqtable`','`02131_filter_2` ON default.`02131_rqtable`','`02131_filter_3` ON default.`02131_rqtable`','`02131_filter_4` ON default.`02131_rqtable`','`02131_filter_5` ON default.`02131_rqtable`']\n+SELECT \\'R2, R3, R4, R5: ((x == 2) OR (x == 3)) AND (x <= 2) AND (x >= 2)\\';\t[]\n+SELECT * FROM 02131_rqtable;\t['`02131_filter_2` ON default.`02131_rqtable`','`02131_filter_3` ON default.`02131_rqtable`','`02131_filter_4` ON default.`02131_rqtable`','`02131_filter_5` ON default.`02131_rqtable`']\n+SELECT \\'R3, R4, R5: (x == 3) AND (x <= 2) AND (x >= 2)\\';\t[]\n+SELECT * FROM 02131_rqtable;\t['`02131_filter_3` ON default.`02131_rqtable`','`02131_filter_4` ON default.`02131_rqtable`','`02131_filter_5` ON default.`02131_rqtable`']\n+SELECT \\'R4, R5: (x <= 2) AND (x >= 2)\\';\t[]\n+SELECT * FROM 02131_rqtable;\t['`02131_filter_4` ON default.`02131_rqtable`','`02131_filter_5` ON default.`02131_rqtable`']\n+SELECT \\'R5: (x >= 2)\\';\t[]\n+SELECT * FROM 02131_rqtable;\t['`02131_filter_5` ON default.`02131_rqtable`']\n+SELECT \\'None\\';\t[]\n+SELECT * FROM 02131_rqtable;\t[]\n+SELECT \\'Check system.query_log\\';\t[]\ndiff --git a/tests/queries/0_stateless/02131_used_row_policies_in_query_log.sql b/tests/queries/0_stateless/02131_used_row_policies_in_query_log.sql\nnew file mode 100644\nindex 000000000000..7a70d895a026\n--- /dev/null\n+++ b/tests/queries/0_stateless/02131_used_row_policies_in_query_log.sql\n@@ -0,0 +1,58 @@\n+DROP TABLE IF EXISTS 02131_rqtable;\n+CREATE TABLE 02131_rqtable (x UInt8) ENGINE = MergeTree ORDER BY x;\n+INSERT INTO 02131_rqtable VALUES (1), (2), (3), (4);\n+\n+DROP ROW POLICY IF EXISTS 02131_filter_1 ON 02131_rqtable;\n+DROP ROW POLICY IF EXISTS 02131_filter_2 ON 02131_rqtable;\n+DROP ROW POLICY IF EXISTS 02131_filter_3 ON 02131_rqtable;\n+DROP ROW POLICY IF EXISTS 02131_filter_4 ON 02131_rqtable;\n+DROP ROW POLICY IF EXISTS 02131_filter_5 ON 02131_rqtable;\n+\n+SELECT 'None';\n+SELECT * FROM 02131_rqtable;\n+\n+CREATE ROW POLICY 02131_filter_1 ON 02131_rqtable USING x=1 AS permissive TO ALL;\n+SELECT 'R1: x == 1';\n+SELECT * FROM 02131_rqtable;\n+\n+CREATE ROW POLICY 02131_filter_2 ON 02131_rqtable USING x=2 AS permissive TO ALL;\n+SELECT 'R1, R2: (x == 1) OR (x == 2)';\n+SELECT * FROM 02131_rqtable;\n+\n+CREATE ROW POLICY 02131_filter_3 ON 02131_rqtable USING x=3 AS permissive TO ALL;\n+SELECT 'R1, R2, R3: (x == 1) OR (x == 2) OR (x == 3)';\n+SELECT * FROM 02131_rqtable;\n+\n+CREATE ROW POLICY 02131_filter_4 ON 02131_rqtable USING x<=2 AS restrictive TO ALL;\n+SELECT 'R1, R2, R3, R4: ((x == 1) OR (x == 2) OR (x == 3)) AND (x <= 2)';\n+SELECT * FROM 02131_rqtable;\n+\n+CREATE ROW POLICY 02131_filter_5 ON 02131_rqtable USING x>=2 AS restrictive TO ALL;\n+SELECT 'R1, R2, R3, R4, R5: ((x == 1) OR (x == 2) OR (x == 3)) AND (x <= 2) AND (x >= 2)';\n+SELECT * FROM 02131_rqtable;\n+\n+DROP ROW POLICY 02131_filter_1 ON 02131_rqtable;\n+SELECT 'R2, R3, R4, R5: ((x == 2) OR (x == 3)) AND (x <= 2) AND (x >= 2)';\n+SELECT * FROM 02131_rqtable;\n+\n+DROP ROW POLICY 02131_filter_2 ON 02131_rqtable;\n+SELECT 'R3, R4, R5: (x == 3) AND (x <= 2) AND (x >= 2)';\n+SELECT * FROM 02131_rqtable;\n+\n+DROP ROW POLICY 02131_filter_3 ON 02131_rqtable;\n+SELECT 'R4, R5: (x <= 2) AND (x >= 2)';\n+SELECT * FROM 02131_rqtable;\n+\n+DROP ROW POLICY 02131_filter_4 ON 02131_rqtable;\n+SELECT 'R5: (x >= 2)';\n+SELECT * FROM 02131_rqtable;\n+\n+DROP ROW POLICY 02131_filter_5 ON 02131_rqtable;\n+SELECT 'None';\n+SELECT * FROM 02131_rqtable;\n+\n+DROP TABLE 02131_rqtable;\n+\n+SELECT 'Check system.query_log';\n+SYSTEM FLUSH LOGS;\n+SELECT query, used_row_policies FROM system.query_log WHERE current_database == currentDatabase() AND type == 'QueryStart' AND query_kind == 'Select' ORDER BY event_time_microseconds;\n",
  "problem_statement": "Row policy stats in the query log\nIt can be hard to understand why the same query produces different number of rows in result when row policy is in place. \r\n\r\nMaybe we can expose some counter from there? \n",
  "hints_text": "applied_row_policies: Array(LowCardinality(String)) \nCool!",
  "created_at": "2022-08-02T10:46:56Z",
  "modified_files": [
    "src/Access/ContextAccess.cpp",
    "src/Access/ContextAccess.h",
    "src/Access/EnabledRowPolicies.cpp",
    "src/Access/EnabledRowPolicies.h",
    "src/Access/RowPolicyCache.cpp",
    "src/Interpreters/Context.cpp",
    "src/Interpreters/Context.h",
    "src/Interpreters/IInterpreterUnionOrSelectQuery.cpp",
    "src/Interpreters/IInterpreterUnionOrSelectQuery.h",
    "src/Interpreters/InterpreterSelectIntersectExceptQuery.cpp",
    "src/Interpreters/InterpreterSelectIntersectExceptQuery.h",
    "src/Interpreters/InterpreterSelectQuery.cpp",
    "src/Interpreters/InterpreterSelectQuery.h",
    "src/Interpreters/InterpreterSelectWithUnionQuery.cpp",
    "src/Interpreters/InterpreterSelectWithUnionQuery.h",
    "src/Interpreters/QueryLog.cpp",
    "src/Interpreters/QueryLog.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02131_used_row_policies_in_query_log.reference",
    "b/tests/queries/0_stateless/02131_used_row_policies_in_query_log.sql"
  ]
}