{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 44860,
  "instance_id": "ClickHouse__ClickHouse-44860",
  "issue_numbers": [
    "44417"
  ],
  "base_commit": "9af70c10d041dcd0408777dd3b2140a58b098dd3",
  "patch": "diff --git a/docs/en/sql-reference/functions/date-time-functions.md b/docs/en/sql-reference/functions/date-time-functions.md\nindex 89fa72de8bf1..4ff89414e0ae 100644\n--- a/docs/en/sql-reference/functions/date-time-functions.md\n+++ b/docs/en/sql-reference/functions/date-time-functions.md\n@@ -207,9 +207,16 @@ Converts a date or date with time to a UInt8 number containing the number of the\n \n Aliases: `DAYOFMONTH`, `DAY`.\n \n-## toDayOfWeek\n+## toDayOfWeek(date\\[,mode\\])\n \n-Converts a date or date with time to a UInt8 number containing the number of the day of the week (Monday is 1, and Sunday is 7).\n+Converts a date or date with time to a UInt8 number containing the number of the day of the week. The two-argument form of toDayOfWeek() enables you to specify whether the week starts on Monday or Sunday, and whether the return value should be in the range from 0 to 6 or from 1-7. If the mode argument is ommited, the default mode is 0.\n+\n+| Mode | First day of week | Range                                          |\n+|------|-------------------|------------------------------------------------|\n+| 0    | Monday            | 1-7, Monday = 1, Tuesday = 2, ..., Sunday = 7  |\n+| 1    | Monday            | 0-6, Monday = 0, Tuesday = 1, ..., Sunday = 6  |\n+| 2    | Sunday            | 0-6, Sunday = 0, Monday = 1, ..., Saturday = 6 |\n+| 3    | Sunday            | 1-7, Sunday = 1, Monday = 2, ..., Saturday = 7 |\n \n Alias: `DAYOFWEEK`.\n \ndiff --git a/src/Common/DateLUTImpl.h b/src/Common/DateLUTImpl.h\nindex 84f063f95558..3d496e088bb9 100644\n--- a/src/Common/DateLUTImpl.h\n+++ b/src/Common/DateLUTImpl.h\n@@ -39,6 +39,15 @@ enum class WeekModeFlag : UInt8\n };\n using YearWeek = std::pair<UInt16, UInt8>;\n \n+/// Modes for toDayOfWeek() function.\n+enum class WeekDayMode\n+{\n+    WeekStartsMonday1 = 0,\n+    WeekStartsMonday0 = 1,\n+    WeekStartsSunday0 = 2,\n+    WeekStartsSunday1 = 3\n+};\n+\n /** Lookup table to conversion of time to date, and to month / year / day of week / day of month and so on.\n   * First time was implemented for OLAPServer, that needed to do billions of such transformations.\n   */\n@@ -619,9 +628,25 @@ class DateLUTImpl\n     template <typename DateOrTime>\n     inline Int16 toYear(DateOrTime v) const { return lut[toLUTIndex(v)].year; }\n \n+    /// 1-based, starts on Monday\n     template <typename DateOrTime>\n     inline UInt8 toDayOfWeek(DateOrTime v) const { return lut[toLUTIndex(v)].day_of_week; }\n \n+    template <typename DateOrTime>\n+    inline UInt8 toDayOfWeek(DateOrTime v, UInt8 week_day_mode) const\n+    {\n+        WeekDayMode mode = check_week_day_mode(week_day_mode);\n+        UInt8 res = toDayOfWeek(v);\n+\n+        bool start_from_sunday = (mode == WeekDayMode::WeekStartsSunday0 || mode == WeekDayMode::WeekStartsSunday1);\n+        bool zero_based = (mode == WeekDayMode::WeekStartsMonday0 || mode == WeekDayMode::WeekStartsSunday0);\n+        if (start_from_sunday)\n+            res = res % 7 + 1;\n+        if (zero_based)\n+            --res;\n+        return res;\n+    }\n+\n     template <typename DateOrTime>\n     inline UInt8 toDayOfMonth(DateOrTime v) const { return lut[toLUTIndex(v)].day_of_month; }\n \n@@ -844,6 +869,13 @@ class DateLUTImpl\n         return week_format;\n     }\n \n+    /// Check and change mode to effective.\n+    inline WeekDayMode check_week_day_mode(UInt8 mode) const /// NOLINT\n+    {\n+        return static_cast<WeekDayMode>(mode & 3);\n+    }\n+\n+\n     /** Calculate weekday from d.\n       * Returns 0 for monday, 1 for tuesday...\n       */\ndiff --git a/src/Functions/DateTimeTransforms.h b/src/Functions/DateTimeTransforms.h\nindex f4163a336eff..56a7a960ac99 100644\n--- a/src/Functions/DateTimeTransforms.h\n+++ b/src/Functions/DateTimeTransforms.h\n@@ -786,21 +786,21 @@ struct ToDayOfWeekImpl\n {\n     static constexpr auto name = \"toDayOfWeek\";\n \n-    static inline UInt8 execute(Int64 t, const DateLUTImpl & time_zone)\n+    static inline UInt8 execute(Int64 t, UInt8 week_day_mode, const DateLUTImpl & time_zone)\n     {\n-        return time_zone.toDayOfWeek(t);\n+        return time_zone.toDayOfWeek(t, week_day_mode);\n     }\n-    static inline UInt8 execute(UInt32 t, const DateLUTImpl & time_zone)\n+    static inline UInt8 execute(UInt32 t, UInt8 week_day_mode, const DateLUTImpl & time_zone)\n     {\n-        return time_zone.toDayOfWeek(t);\n+        return time_zone.toDayOfWeek(t, week_day_mode);\n     }\n-    static inline UInt8 execute(Int32 d, const DateLUTImpl & time_zone)\n+    static inline UInt8 execute(Int32 d, UInt8 week_day_mode, const DateLUTImpl & time_zone)\n     {\n-        return time_zone.toDayOfWeek(ExtendedDayNum(d));\n+        return time_zone.toDayOfWeek(ExtendedDayNum(d), week_day_mode);\n     }\n-    static inline UInt8 execute(UInt16 d, const DateLUTImpl & time_zone)\n+    static inline UInt8 execute(UInt16 d, UInt8 week_day_mode, const DateLUTImpl & time_zone)\n     {\n-        return time_zone.toDayOfWeek(DayNum(d));\n+        return time_zone.toDayOfWeek(DayNum(d), week_day_mode);\n     }\n \n     using FactorTransform = ToMondayImpl;\ndiff --git a/src/Functions/dateDiff.cpp b/src/Functions/dateDiff.cpp\nindex 60668f81edf1..d43ef2d4caf2 100644\n--- a/src/Functions/dateDiff.cpp\n+++ b/src/Functions/dateDiff.cpp\n@@ -225,8 +225,8 @@ class DateDiffImpl\n             }\n             else if constexpr (std::is_same_v<TransformX, TransformDateTime64<ToRelativeWeekNumImpl<ResultPrecision::Extended>>>)\n             {\n-                auto x_day_of_week = TransformDateTime64<ToDayOfWeekImpl>(transform_x.getScaleMultiplier()).execute(x, timezone_x);\n-                auto y_day_of_week = TransformDateTime64<ToDayOfWeekImpl>(transform_y.getScaleMultiplier()).execute(y, timezone_y);\n+                auto x_day_of_week = TransformDateTime64<ToDayOfWeekImpl>(transform_x.getScaleMultiplier()).execute(x, 0, timezone_x);\n+                auto y_day_of_week = TransformDateTime64<ToDayOfWeekImpl>(transform_y.getScaleMultiplier()).execute(y, 0, timezone_y);\n                 if ((x_day_of_week > y_day_of_week)\n                     || ((x_day_of_week == y_day_of_week) && (a_comp.time.hour > b_comp.time.hour))\n                     || ((a_comp.time.hour == b_comp.time.hour) && ((a_comp.time.minute > b_comp.time.minute)\ndiff --git a/src/Functions/dateName.cpp b/src/Functions/dateName.cpp\nindex 36c0be491906..bfb190b9a089 100644\n--- a/src/Functions/dateName.cpp\n+++ b/src/Functions/dateName.cpp\n@@ -276,7 +276,7 @@ class FunctionDateNameImpl : public IFunction\n     {\n         static inline void write(WriteBuffer & buffer, Time source, const DateLUTImpl & timezone)\n         {\n-            const auto day = ToDayOfWeekImpl::execute(source, timezone);\n+            const auto day = ToDayOfWeekImpl::execute(source, 0, timezone);\n             static constexpr std::string_view day_names[] =\n             {\n                 \"Monday\",\ndiff --git a/src/Functions/formatDateTime.cpp b/src/Functions/formatDateTime.cpp\nindex e7c9a1b51037..c01f32f68aee 100644\n--- a/src/Functions/formatDateTime.cpp\n+++ b/src/Functions/formatDateTime.cpp\n@@ -344,13 +344,13 @@ class FunctionFormatDateTimeImpl : public IFunction\n \n         static size_t mysqlDayOfWeek(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n-            *dest = '0' + ToDayOfWeekImpl::execute(source, timezone);\n+            *dest = '0' + ToDayOfWeekImpl::execute(source, 0, timezone);\n             return 1;\n         }\n \n         static size_t mysqlDayOfWeek0To6(char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n-            auto day = ToDayOfWeekImpl::execute(source, timezone);\n+            auto day = ToDayOfWeekImpl::execute(source, 0, timezone);\n             *dest = '0' + (day == 7 ? 0 : day);\n             return 1;\n         }\n@@ -499,13 +499,13 @@ class FunctionFormatDateTimeImpl : public IFunction\n \n         static size_t jodaDayOfWeek1Based(size_t min_represent_digits, char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n-            auto week_day = ToDayOfWeekImpl::execute(source, timezone);\n+            auto week_day = ToDayOfWeekImpl::execute(source, 0, timezone);\n             return writeNumberWithPadding(dest, week_day, min_represent_digits);\n         }\n \n         static size_t jodaDayOfWeekText(size_t min_represent_digits, char * dest, Time source, UInt64, UInt32, const DateLUTImpl & timezone)\n         {\n-            auto week_day = ToDayOfWeekImpl::execute(source, timezone);\n+            auto week_day = ToDayOfWeekImpl::execute(source, 0, timezone);\n             if (week_day == 7)\n                 week_day = 0;\n \ndiff --git a/src/Functions/toDayOfWeek.cpp b/src/Functions/toDayOfWeek.cpp\nindex 354d4dea894a..06343714b9d0 100644\n--- a/src/Functions/toDayOfWeek.cpp\n+++ b/src/Functions/toDayOfWeek.cpp\n@@ -1,13 +1,12 @@\n #include <Functions/FunctionFactory.h>\n #include <Functions/DateTimeTransforms.h>\n-#include <Functions/FunctionDateOrDateTimeToSomething.h>\n #include <DataTypes/DataTypesNumber.h>\n-\n+#include <Functions/FunctionCustomWeekToSomething.h>\n \n namespace DB\n {\n \n-using FunctionToDayOfWeek = FunctionDateOrDateTimeToSomething<DataTypeUInt8, ToDayOfWeekImpl>;\n+using FunctionToDayOfWeek = FunctionCustomWeekToSomething<DataTypeUInt8, ToDayOfWeekImpl>;\n \n REGISTER_FUNCTION(ToDayOfWeek)\n {\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00189_time_zones_long.sql b/tests/queries/0_stateless/00189_time_zones_long.sql\nindex cf1b9e9ae1d8..5760f6c04479 100644\n--- a/tests/queries/0_stateless/00189_time_zones_long.sql\n+++ b/tests/queries/0_stateless/00189_time_zones_long.sql\n@@ -120,11 +120,11 @@ SELECT toDayOfMonth(toDateTime(1412106600), 'Pacific/Pitcairn');\n /* toDayOfWeek */\n \n SELECT 'toDayOfWeek';\n-SELECT toDayOfWeek(toDateTime(1412106600), 'Asia/Istanbul');\n-SELECT toDayOfWeek(toDateTime(1412106600), 'Europe/Paris');\n-SELECT toDayOfWeek(toDateTime(1412106600), 'Europe/London');\n-SELECT toDayOfWeek(toDateTime(1412106600), 'Asia/Tokyo');\n-SELECT toDayOfWeek(toDateTime(1412106600), 'Pacific/Pitcairn');\n+SELECT toDayOfWeek(toDateTime(1412106600), 0, 'Asia/Istanbul');\n+SELECT toDayOfWeek(toDateTime(1412106600), 0, 'Europe/Paris');\n+SELECT toDayOfWeek(toDateTime(1412106600), 0, 'Europe/London');\n+SELECT toDayOfWeek(toDateTime(1412106600), 0, 'Asia/Tokyo');\n+SELECT toDayOfWeek(toDateTime(1412106600), 0, 'Pacific/Pitcairn');\n \n /* toHour */\n \ndiff --git a/tests/queries/0_stateless/00921_datetime64_compatibility_long.python b/tests/queries/0_stateless/00921_datetime64_compatibility_long.python\nindex e3cd7ee6d361..2706c0f5b122 100644\n--- a/tests/queries/0_stateless/00921_datetime64_compatibility_long.python\n+++ b/tests/queries/0_stateless/00921_datetime64_compatibility_long.python\n@@ -7,14 +7,14 @@ import sys\n import argparse\n \n # Create SQL statement to verify dateTime64 is accepted as argument to functions taking DateTime.\n-FUNCTIONS=\"\"\"\n+FUNCTIONS = \"\"\"\n toTimeZone(N, 'UTC')\n toYear(N, 'Asia/Istanbul')\n toQuarter(N, 'Asia/Istanbul')\n toMonth(N, 'Asia/Istanbul')\n toDayOfYear(N, 'Asia/Istanbul')\n toDayOfMonth(N, 'Asia/Istanbul')\n-toDayOfWeek(N, 'Asia/Istanbul')\n+toDayOfWeek(N, 0, 'Asia/Istanbul')\n toHour(N, 'Asia/Istanbul')\n toMinute(N, 'Asia/Istanbul')\n toSecond(N, 'Asia/Istanbul')\n@@ -90,68 +90,51 @@ formatDateTime(N, '%C %d %D %e %F %H %I %j %m %M %p %R %S %T %u %V %w %y %Y %%',\n extra_ops = [\n     # With same type:\n     (\n-        ['N {op} N'],\n+        [\"N {op} N\"],\n         {\n-            'op':\n-            [\n-                '- ', # does not work, but should it?\n-                '+ ', # does not work, but should it?\n-                '!=', '==', # equality and inequality supposed to take sub-second part in account\n-                '< ',\n-                '<=',\n-                '> ',\n-                '>='\n+            \"op\": [\n+                \"- \",  # does not work, but should it?\n+                \"+ \",  # does not work, but should it?\n+                \"!=\",\n+                \"==\",  # equality and inequality supposed to take sub-second part in account\n+                \"< \",\n+                \"<=\",\n+                \"> \",\n+                \">=\",\n             ]\n-        }\n+        },\n     ),\n     # With other DateTime types:\n     (\n-        [\n-            'N {op} {arg}',\n-            '{arg} {op} N'\n-        ],\n+        [\"N {op} {arg}\", \"{arg} {op} N\"],\n         {\n-            'op':\n-            [\n-                '-', # does not work, but should it?\n-                '!=', '==',\n+            \"op\": [\n+                \"-\",  # does not work, but should it?\n+                \"!=\",\n+                \"==\",\n                 # these are naturally expected to work, but they don't:\n-                '< ',\n-                '<=',\n-                '> ',\n-                '>='\n+                \"< \",\n+                \"<=\",\n+                \"> \",\n+                \">=\",\n             ],\n-            'arg': ['DT', 'D', 'DT64'],\n-        }\n+            \"arg\": [\"DT\", \"D\", \"DT64\"],\n+        },\n     ),\n     # With arithmetic types\n     (\n-        [\n-            'N {op} {arg}',\n-            '{arg} {op} N'\n-        ],\n+        [\"N {op} {arg}\", \"{arg} {op} N\"],\n         {\n-            'op':\n-            [\n-                '+ ',\n-                '- ',\n-                '==',\n-                '!=',\n-                '< ',\n-                '<=',\n-                '> ',\n-                '>='\n-            ],\n-            'arg':\n-            [\n-                'toUInt8(1)',\n-                'toInt8(-1)',\n-                'toUInt16(1)',\n-                'toInt16(-1)',\n-                'toUInt32(1)',\n-                'toInt32(-1)',\n-                'toUInt64(1)',\n-                'toInt64(-1)'\n+            \"op\": [\"+ \", \"- \", \"==\", \"!=\", \"< \", \"<=\", \"> \", \">=\"],\n+            \"arg\": [\n+                \"toUInt8(1)\",\n+                \"toInt8(-1)\",\n+                \"toUInt16(1)\",\n+                \"toInt16(-1)\",\n+                \"toUInt32(1)\",\n+                \"toInt32(-1)\",\n+                \"toUInt64(1)\",\n+                \"toInt64(-1)\",\n             ],\n         },\n     ),\n@@ -167,14 +150,17 @@ for funcs, args in extra_ops:\n \n # filter out empty lines and commented out lines\n COMMENTED_OUT_LINE_RE = re.compile(r\"^\\s*#\")\n-FUNCTIONS = list([f for f in FUNCTIONS if len(f) != 0 and COMMENTED_OUT_LINE_RE.match(f) == None])\n-TYPES = ['D', 'DT', 'DT64']\n+FUNCTIONS = list(\n+    [f for f in FUNCTIONS if len(f) != 0 and COMMENTED_OUT_LINE_RE.match(f) == None]\n+)\n+TYPES = [\"D\", \"DT\", \"DT64\"]\n+\n \n def escape_string(s):\n     if sys.version_info[0] > 2:\n-        return s.encode('unicode_escape').decode('utf-8').replace(\"'\", \"\\\\'\")\n+        return s.encode(\"unicode_escape\").decode(\"utf-8\").replace(\"'\", \"\\\\'\")\n     else:\n-        return s.encode('string-escape').decode('utf-8')\n+        return s.encode(\"string-escape\").decode(\"utf-8\")\n \n \n def execute_functions_for_types(functions, types):\n@@ -186,18 +172,39 @@ def execute_functions_for_types(functions, types):\n WITH \\\n toDateTime64('2019-09-16 19:20:11.234', 3, 'Europe/Minsk') as DT64, \\\n toDateTime('2019-09-16 19:20:11', 'Europe/Minsk') as DT, \\\n-toDate('2019-09-16') as D, {X} as N\".format(X=dt)\n-            print((\"\"\"{prologue} SELECT toTypeName(r), {func} as r FORMAT CSV;\"\"\".format(prologue=prologue, func=func)))\n+toDate('2019-09-16') as D, {X} as N\".format(\n+                X=dt\n+            )\n+            print(\n+                (\n+                    \"\"\"{prologue} SELECT toTypeName(r), {func} as r FORMAT CSV;\"\"\".format(\n+                        prologue=prologue, func=func\n+                    )\n+                )\n+            )\n         print(\"\"\"SELECT '------------------------------------------';\"\"\")\n \n+\n def main():\n     def parse_args():\n         parser = argparse.ArgumentParser()\n-        parser.add_argument('--functions_re', type=re.compile, help=\"RE to enable functions\", default=None)\n-        parser.add_argument('--types_re',\n-                type=lambda s: re.compile('^(' + s + ')$'),\n-                help=\"RE to enable types, supported types: \" + \",\".join(TYPES), default=None)\n-        parser.add_argument('--list_functions', action='store_true', help=\"List all functions to be tested and exit\")\n+        parser.add_argument(\n+            \"--functions_re\",\n+            type=re.compile,\n+            help=\"RE to enable functions\",\n+            default=None,\n+        )\n+        parser.add_argument(\n+            \"--types_re\",\n+            type=lambda s: re.compile(\"^(\" + s + \")$\"),\n+            help=\"RE to enable types, supported types: \" + \",\".join(TYPES),\n+            default=None,\n+        )\n+        parser.add_argument(\n+            \"--list_functions\",\n+            action=\"store_true\",\n+            help=\"List all functions to be tested and exit\",\n+        )\n         return parser.parse_args()\n \n     args = parse_args()\n@@ -223,5 +230,6 @@ def main():\n \n     execute_functions_for_types(functions, types)\n \n-if __name__ == '__main__':\n+\n+if __name__ == \"__main__\":\n     exit(main())\ndiff --git a/tests/queries/0_stateless/00921_datetime64_compatibility_long.reference b/tests/queries/0_stateless/00921_datetime64_compatibility_long.reference\nindex 8d28a69ff3de..8a168ed0e9e9 100644\n--- a/tests/queries/0_stateless/00921_datetime64_compatibility_long.reference\n+++ b/tests/queries/0_stateless/00921_datetime64_compatibility_long.reference\n@@ -28,7 +28,7 @@ SELECT toDayOfMonth(N, \\'Asia/Istanbul\\')\n \"UInt8\",16\n \"UInt8\",16\n ------------------------------------------\n-SELECT toDayOfWeek(N, \\'Asia/Istanbul\\')\n+SELECT toDayOfWeek(N, 0, \\'Asia/Istanbul\\')\n \"UInt8\",1\n \"UInt8\",1\n \"UInt8\",1\ndiff --git a/tests/queries/0_stateless/02521_to_custom_day_of_week.reference b/tests/queries/0_stateless/02521_to_custom_day_of_week.reference\nnew file mode 100644\nindex 000000000000..660dff37b72e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02521_to_custom_day_of_week.reference\n@@ -0,0 +1,7 @@\n+1\t7\n+1\t7\n+0\t6\n+1\t0\n+2\t1\n+1\t7\n+0\t6\ndiff --git a/tests/queries/0_stateless/02521_to_custom_day_of_week.sql b/tests/queries/0_stateless/02521_to_custom_day_of_week.sql\nnew file mode 100644\nindex 000000000000..5475e15a9843\n--- /dev/null\n+++ b/tests/queries/0_stateless/02521_to_custom_day_of_week.sql\n@@ -0,0 +1,10 @@\n+\n+with toDate('2023-01-09') as date_mon, date_mon - 1 as date_sun select toDayOfWeek(date_mon), toDayOfWeek(date_sun);\n+with toDate('2023-01-09') as date_mon, date_mon - 1 as date_sun select toDayOfWeek(date_mon, 0), toDayOfWeek(date_sun, 0);\n+with toDate('2023-01-09') as date_mon, date_mon - 1 as date_sun select toDayOfWeek(date_mon, 1), toDayOfWeek(date_sun, 1);\n+with toDate('2023-01-09') as date_mon, date_mon - 1 as date_sun select toDayOfWeek(date_mon, 2), toDayOfWeek(date_sun, 2);\n+with toDate('2023-01-09') as date_mon, date_mon - 1 as date_sun select toDayOfWeek(date_mon, 3), toDayOfWeek(date_sun, 3);\n+with toDate('2023-01-09') as date_mon, date_mon - 1 as date_sun select toDayOfWeek(date_mon, 4), toDayOfWeek(date_sun, 4);\n+with toDate('2023-01-09') as date_mon, date_mon - 1 as date_sun select toDayOfWeek(date_mon, 5), toDayOfWeek(date_sun, 5);\n+\n+select toDayOfWeek(today(), -1); -- { serverError 43 }\n",
  "problem_statement": "Support of the mode argument in toDayOfWeek function toDayOfWeek(date[,mode])\nSupport of the mode argument in toDayOfWeek function **toDayOfWeek(date[,mode])**\r\n\r\nSimilar to the support of mode argument in toWeek(date[,mode]), require the support of the mode argument in toDayOfWeek function.\r\nThe second-argument 'mode' of toDayOfWeek() should configure whether the week starts on Sunday or Monday since start of week is different in different zones.\r\n\r\nExample:\r\nCurrent implementation of clickhouse supports Monday as 1, and Sunday as 7 which implies Monday as start of week.\r\nBut consider US week number which requires Sunday as 1, and Saturday as 7 which implies Sunday as start of week.\r\n\r\nCould you please let us know if there is any other custom way this could be achieved.\n",
  "hints_text": "There is hope that this can be done: #44860.",
  "created_at": "2023-01-03T10:27:07Z",
  "modified_files": [
    "docs/en/sql-reference/functions/date-time-functions.md",
    "src/Common/DateLUTImpl.h",
    "src/Functions/DateTimeTransforms.h",
    "src/Functions/dateDiff.cpp",
    "src/Functions/dateName.cpp",
    "src/Functions/formatDateTime.cpp",
    "src/Functions/toDayOfWeek.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/00189_time_zones_long.sql",
    "tests/queries/0_stateless/00921_datetime64_compatibility_long.python",
    "tests/queries/0_stateless/00921_datetime64_compatibility_long.reference",
    "b/tests/queries/0_stateless/02521_to_custom_day_of_week.reference",
    "b/tests/queries/0_stateless/02521_to_custom_day_of_week.sql"
  ]
}