{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 45799,
  "instance_id": "ClickHouse__ClickHouse-45799",
  "issue_numbers": [
    "45773"
  ],
  "base_commit": "f46bfaa1c96b7ec226595fcccd1dcee9646bdbfd",
  "patch": "diff --git a/src/Functions/CRC.cpp b/src/Functions/CRC.cpp\nindex 677950a9f615..ba13fcf78f1e 100644\n--- a/src/Functions/CRC.cpp\n+++ b/src/Functions/CRC.cpp\n@@ -115,6 +115,16 @@ struct CRCFunctionWrapper\n         throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cannot apply function {} to UUID argument\", std::string(Impl::name));\n     }\n \n+    [[noreturn]] static void ipv6(const ColumnIPv6::Container & /*offsets*/, size_t /*n*/, PaddedPODArray<ReturnType> & /*res*/)\n+    {\n+        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cannot apply function {} to IPv6 argument\", std::string(Impl::name));\n+    }\n+\n+    [[noreturn]] static void ipv4(const ColumnIPv4::Container & /*offsets*/, size_t /*n*/, PaddedPODArray<ReturnType> & /*res*/)\n+    {\n+        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cannot apply function {} to IPv4 argument\", std::string(Impl::name));\n+    }\n+\n private:\n     static ReturnType doCRC(const ColumnString::Chars & buf, size_t offset, size_t size)\n     {\ndiff --git a/src/Functions/EmptyImpl.h b/src/Functions/EmptyImpl.h\nindex 3fcbf47240cd..52484524e6ab 100644\n--- a/src/Functions/EmptyImpl.h\n+++ b/src/Functions/EmptyImpl.h\n@@ -61,6 +61,18 @@ struct EmptyImpl\n         for (size_t i = 0; i < n; ++i)\n             res[i] = negative ^ (container[i].toUnderType() == 0);\n     }\n+\n+    static void ipv6(const ColumnIPv6::Container & container, size_t n, PaddedPODArray<UInt8> & res)\n+    {\n+        for (size_t i = 0; i < n; ++i)\n+            res[i] = negative ^ (container[i].toUnderType() == 0);\n+    }\n+\n+    static void ipv4(const ColumnIPv4::Container & container, size_t n, PaddedPODArray<UInt8> & res)\n+    {\n+        for (size_t i = 0; i < n; ++i)\n+            res[i] = negative ^ (container[i].toUnderType() == 0);\n+    }\n };\n \n }\ndiff --git a/src/Functions/FunctionStringOrArrayToT.h b/src/Functions/FunctionStringOrArrayToT.h\nindex 851fc10de928..26c740f1faca 100644\n--- a/src/Functions/FunctionStringOrArrayToT.h\n+++ b/src/Functions/FunctionStringOrArrayToT.h\n@@ -52,7 +52,9 @@ class FunctionStringOrArrayToT : public IFunction\n         if (!isStringOrFixedString(arguments[0])\n             && !isArray(arguments[0])\n             && !isMap(arguments[0])\n-            && !isUUID(arguments[0]))\n+            && !isUUID(arguments[0])\n+            && !isIPv6(arguments[0])\n+            && !isIPv4(arguments[0]))\n             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of argument of function {}\", arguments[0]->getName(), getName());\n \n         return std::make_shared<DataTypeNumber<ResultType>>();\n@@ -121,6 +123,22 @@ class FunctionStringOrArrayToT : public IFunction\n             Impl::uuid(col_uuid->getData(), input_rows_count, vec_res);\n             return col_res;\n         }\n+        else if (const ColumnIPv6 * col_ipv6 = checkAndGetColumn<ColumnIPv6>(column.get()))\n+        {\n+            auto col_res = ColumnVector<ResultType>::create();\n+            typename ColumnVector<ResultType>::Container & vec_res = col_res->getData();\n+            vec_res.resize(col_ipv6->size());\n+            Impl::ipv6(col_ipv6->getData(), input_rows_count, vec_res);\n+            return col_res;\n+        }\n+        else if (const ColumnIPv4 * col_ipv4 = checkAndGetColumn<ColumnIPv4>(column.get()))\n+        {\n+            auto col_res = ColumnVector<ResultType>::create();\n+            typename ColumnVector<ResultType>::Container & vec_res = col_res->getData();\n+            vec_res.resize(col_ipv4->size());\n+            Impl::ipv4(col_ipv4->getData(), input_rows_count, vec_res);\n+            return col_res;\n+        }\n         else\n             throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of argument of function {}\",\n                 arguments[0].column->getName(), getName());\ndiff --git a/src/Functions/array/length.cpp b/src/Functions/array/length.cpp\nindex ac1db5c406b7..65555a501e8a 100644\n--- a/src/Functions/array/length.cpp\n+++ b/src/Functions/array/length.cpp\n@@ -43,6 +43,16 @@ struct LengthImpl\n     {\n         throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cannot apply function length to UUID argument\");\n     }\n+\n+    [[noreturn]] static void ipv6(const ColumnIPv6::Container &, size_t &, PaddedPODArray<UInt64> &)\n+    {\n+        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cannot apply function length to IPv6 argument\");\n+    }\n+\n+    [[noreturn]] static void ipv4(const ColumnIPv4::Container &, size_t &, PaddedPODArray<UInt64> &)\n+    {\n+        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cannot apply function length to IPv4 argument\");\n+    }\n };\n \n \ndiff --git a/src/Functions/ascii.cpp b/src/Functions/ascii.cpp\nindex cb59be55cc1a..5632f0d15df8 100644\n--- a/src/Functions/ascii.cpp\n+++ b/src/Functions/ascii.cpp\n@@ -60,6 +60,16 @@ struct AsciiImpl\n         throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cannot apply function {} to UUID argument\", AsciiName::name);\n     }\n \n+    [[noreturn]] static void ipv6(const ColumnIPv6::Container & /*offsets*/, size_t /*n*/, PaddedPODArray<ReturnType> & /*res*/)\n+    {\n+        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cannot apply function {} to IPv6 argument\", AsciiName::name);\n+    }\n+\n+    [[noreturn]] static void ipv4(const ColumnIPv4::Container & /*offsets*/, size_t /*n*/, PaddedPODArray<ReturnType> & /*res*/)\n+    {\n+        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cannot apply function {} to IPv4 argument\", AsciiName::name);\n+    }\n+\n private:\n     static Int32 doAscii(const ColumnString::Chars & buf, size_t offset, size_t size)\n     {\ndiff --git a/src/Functions/isValidUTF8.cpp b/src/Functions/isValidUTF8.cpp\nindex adfca3f6546d..0871e82adb8c 100644\n--- a/src/Functions/isValidUTF8.cpp\n+++ b/src/Functions/isValidUTF8.cpp\n@@ -248,6 +248,16 @@ SOFTWARE.\n     {\n         throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cannot apply function isValidUTF8 to UUID argument\");\n     }\n+\n+    [[noreturn]] static void ipv6(const ColumnIPv6::Container &, size_t &, PaddedPODArray<UInt8> &)\n+    {\n+        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cannot apply function isValidUTF8 to IPv6 argument\");\n+    }\n+\n+    [[noreturn]] static void ipv4(const ColumnIPv4::Container &, size_t &, PaddedPODArray<UInt8> &)\n+    {\n+        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cannot apply function isValidUTF8 to IPv4 argument\");\n+    }\n };\n \n struct NameIsValidUTF8\ndiff --git a/src/Functions/lengthUTF8.cpp b/src/Functions/lengthUTF8.cpp\nindex 457725a57753..5a4af4934dfc 100644\n--- a/src/Functions/lengthUTF8.cpp\n+++ b/src/Functions/lengthUTF8.cpp\n@@ -58,6 +58,16 @@ struct LengthUTF8Impl\n     {\n         throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cannot apply function lengthUTF8 to UUID argument\");\n     }\n+\n+    [[noreturn]] static void ipv6(const ColumnIPv6::Container &, size_t &, PaddedPODArray<UInt64> &)\n+    {\n+        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cannot apply function lengthUTF8 to IPv6 argument\");\n+    }\n+\n+    [[noreturn]] static void ipv4(const ColumnIPv4::Container &, size_t &, PaddedPODArray<UInt64> &)\n+    {\n+        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cannot apply function lengthUTF8 to IPv4 argument\");\n+    }\n };\n \n struct NameLengthUTF8\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02541_empty_function_support_ip.reference b/tests/queries/0_stateless/02541_empty_function_support_ip.reference\nnew file mode 100644\nindex 000000000000..fa63766841ea\n--- /dev/null\n+++ b/tests/queries/0_stateless/02541_empty_function_support_ip.reference\n@@ -0,0 +1,8 @@\n+1\n+0\n+0\n+1\n+1\n+0\n+0\n+1\ndiff --git a/tests/queries/0_stateless/02541_empty_function_support_ip.sql b/tests/queries/0_stateless/02541_empty_function_support_ip.sql\nnew file mode 100644\nindex 000000000000..9362ff10d2cb\n--- /dev/null\n+++ b/tests/queries/0_stateless/02541_empty_function_support_ip.sql\n@@ -0,0 +1,9 @@\n+SELECT empty(toIPv6('::'));\n+SELECT notEmpty(toIPv6('::'));\n+SELECT empty(toIPv6('::1'));\n+SELECT notEmpty(toIPv6('::1'));\n+\n+SELECT empty(toIPv4('0.0.0.0'));\n+SELECT notEmpty(toIPv4('0.0.0.0'));\n+SELECT empty(toIPv4('127.0.0.1'));\n+SELECT notEmpty(toIPv4('127.0.0.1'));\n",
  "problem_statement": "Illegal type IPv6 of argument of function notEmpty\n**Describe what's wrong**\r\n\r\n`notEmpty` does not accept an argument of type IPv6:\r\n```\r\nDB::Exception: Illegal type IPv6 of argument of function notEmpty\r\n```\r\n\r\n**Does it reproduce on recent release?**\r\n\r\nYes, starting ClickHouse v23.\r\n\r\nExpected behavior with v22.12.3.5: https://fiddle.clickhouse.com/5abe165f-6c96-4b4f-b59e-2c7327a1b252\r\n`DB::Exception` starting with v23.1.1.3077: https://fiddle.clickhouse.com/b619dd22-343c-41cd-8359-da2a6dd76360\r\n\r\n**How to reproduce**\r\n\r\n* Which ClickHouse server version to use: v23\r\n* Queries to run that lead to unexpected result: `SELECT notEmpty(toIPv6('::1'))`\r\n\r\n**Expected behavior**\r\n\r\nThe same behavior as ClickHouse before v23: `notEmpty` should evaluate to `0` when given the all-zeroes IPv6 address (i.e. `notEmpty(toIPv6('::'))`), and `1` otherwise.\n",
  "hints_text": "Related to https://github.com/ClickHouse/ClickHouse/pull/43221\r\n@yakov-olkhovskiy please take a look\nThe previous behavior was an unwanted side-effect of domain type - please notice, that IPv4 was always incompatible for this function. I would suggest that current behavior is correct and we keep it this way unless we already have user case(s) where this issue is critical.\r\ncc @KochetovNicolai ",
  "created_at": "2023-01-30T20:40:57Z"
}