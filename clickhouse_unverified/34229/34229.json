{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 34229,
  "instance_id": "ClickHouse__ClickHouse-34229",
  "issue_numbers": [
    "34204"
  ],
  "base_commit": "805690cbdc2f79308a200090b4642c46a11ccfc7",
  "patch": "diff --git a/src/Parsers/ExpressionListParsers.cpp b/src/Parsers/ExpressionListParsers.cpp\nindex 96c1bad75c24..13af308736b0 100644\n--- a/src/Parsers/ExpressionListParsers.cpp\n+++ b/src/Parsers/ExpressionListParsers.cpp\n@@ -689,7 +689,7 @@ bool ParserUnaryExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expec\n bool ParserCastExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n     ASTPtr expr_ast;\n-    if (!ParserExpressionElement().parse(pos, expr_ast, expected))\n+    if (!elem_parser->parse(pos, expr_ast, expected))\n         return false;\n \n     ASTPtr type_ast;\n@@ -711,7 +711,7 @@ bool ParserArrayElementExpression::parseImpl(Pos & pos, ASTPtr & node, Expected\n {\n     return ParserLeftAssociativeBinaryOperatorList{\n         operators,\n-        std::make_unique<ParserCastExpression>(),\n+        std::make_unique<ParserCastExpression>(std::make_unique<ParserExpressionElement>()),\n         std::make_unique<ParserExpressionWithOptionalAlias>(false)\n     }.parse(pos, node, expected);\n }\n@@ -721,7 +721,7 @@ bool ParserTupleElementExpression::parseImpl(Pos & pos, ASTPtr & node, Expected\n {\n     return ParserLeftAssociativeBinaryOperatorList{\n         operators,\n-        std::make_unique<ParserArrayElementExpression>(),\n+        std::make_unique<ParserCastExpression>(std::make_unique<ParserArrayElementExpression>()),\n         std::make_unique<ParserUnsignedInteger>()\n     }.parse(pos, node, expected);\n }\ndiff --git a/src/Parsers/ExpressionListParsers.h b/src/Parsers/ExpressionListParsers.h\nindex a035d4a2ef0c..358fe778f91e 100644\n--- a/src/Parsers/ExpressionListParsers.h\n+++ b/src/Parsers/ExpressionListParsers.h\n@@ -203,6 +203,15 @@ class ParserPrefixUnaryOperatorExpression : public IParserBase\n /// Example: \"[1, 1 + 1, 1 + 2]::Array(UInt8)\"\n class ParserCastExpression : public IParserBase\n {\n+private:\n+    ParserPtr elem_parser;\n+\n+public:\n+    ParserCastExpression(ParserPtr && elem_parser_)\n+        : elem_parser(std::move(elem_parser_))\n+    {\n+    }\n+\n protected:\n     const char * getName() const override { return \"CAST expression\"; }\n \n@@ -238,7 +247,7 @@ class ParserUnaryExpression : public IParserBase\n {\n private:\n     static const char * operators[];\n-    ParserPrefixUnaryOperatorExpression operator_parser {operators, std::make_unique<ParserTupleElementExpression>()};\n+    ParserPrefixUnaryOperatorExpression operator_parser {operators, std::make_unique<ParserCastExpression>(std::make_unique<ParserTupleElementExpression>())};\n \n protected:\n     const char * getName() const override { return \"unary expression\"; }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01852_cast_operator_4.reference b/tests/queries/0_stateless/01852_cast_operator_4.reference\nnew file mode 100644\nindex 000000000000..ecfe62b1db46\n--- /dev/null\n+++ b/tests/queries/0_stateless/01852_cast_operator_4.reference\n@@ -0,0 +1,19 @@\n+3\n+SELECT CAST([3, 4, 5][1], \\'Int32\\')\n+4\n+SELECT CAST(CAST(\\'[3,4,5]\\', \\'Array(Int64)\\')[2], \\'Int8\\')\n+0\n+1\n+2\n+SELECT CAST(CAST(\\'[1,2,3]\\', \\'Array(UInt64)\\')[CAST(CAST([number, number], \\'Array(UInt8)\\')[number], \\'UInt64\\')], \\'UInt8\\')\n+FROM numbers(3)\n+3\n+WITH [3, 4, 5] AS x\n+SELECT CAST(x[1], \\'Int32\\')\n+3\n+SELECT CAST((3, 4, 5).1, \\'Int32\\')\n+4\n+SELECT CAST(CAST((3, 4, 5), \\'Tuple(UInt64, UInt64, UInt64)\\').1, \\'Int32\\')\n+3\n+WITH (3, 4, 5) AS x\n+SELECT CAST(x.1, \\'Int32\\')\ndiff --git a/tests/queries/0_stateless/01852_cast_operator_4.sql b/tests/queries/0_stateless/01852_cast_operator_4.sql\nnew file mode 100644\nindex 000000000000..5c33191222b5\n--- /dev/null\n+++ b/tests/queries/0_stateless/01852_cast_operator_4.sql\n@@ -0,0 +1,20 @@\n+SELECT [3,4,5][1]::Int32;\n+EXPLAIN SYNTAX SELECT [3,4,5][1]::Int32;\n+\n+SELECT [3,4,5]::Array(Int64)[2]::Int8;\n+EXPLAIN SYNTAX SELECT [3,4,5]::Array(Int64)[2]::Int8;\n+\n+SELECT [1,2,3]::Array(UInt64)[[number, number]::Array(UInt8)[number]::UInt64]::UInt8 from numbers(3);\n+EXPLAIN SYNTAX SELECT [1,2,3]::Array(UInt64)[[number, number]::Array(UInt8)[number]::UInt64]::UInt8 from numbers(3);\n+\n+WITH [3,4,5] AS x SELECT x[1]::Int32;\n+EXPLAIN SYNTAX WITH [3,4,5] AS x SELECT x[1]::Int32;\n+\n+SELECT tuple(3,4,5).1::Int32;\n+EXPLAIN SYNTAX SELECT tuple(3,4,5).1::Int32;\n+\n+SELECT tuple(3,4,5)::Tuple(UInt64, UInt64, UInt64).2::Int32;\n+EXPLAIN SYNTAX SELECT tuple(3,4,5)::Tuple(UInt64, UInt64, UInt64).1::Int32;\n+\n+WITH tuple(3,4,5) AS x SELECT x.1::Int32;\n+EXPLAIN SYNTAX WITH tuple(3,4,5) AS x SELECT x.1::Int32;\n",
  "problem_statement": "Casting and array index operators are not composable\n**Describe the issue**\r\n```\r\nSELECT x[1]::UInt64\r\n\r\nSyntax error: failed at position 12 ('::')\r\n```\r\n\n",
  "hints_text": "Should I also fix tuple index operator?\r\n\r\n```\r\nSELECT tuple(3,4,5).1::UInt8\r\n\r\nSyntax error: failed at position 22 ('::'):\r\n```\r\n",
  "created_at": "2022-02-01T16:00:13Z"
}