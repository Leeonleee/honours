{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 79561,
  "instance_id": "ClickHouse__ClickHouse-79561",
  "issue_numbers": [
    "78964"
  ],
  "base_commit": "cf3fbd0de094a73a3e729266348d29bcf07e8f02",
  "patch": "diff --git a/src/Backups/BackupIO_AzureBlobStorage.cpp b/src/Backups/BackupIO_AzureBlobStorage.cpp\nindex a9716ff02cab..7444828669f0 100644\n--- a/src/Backups/BackupIO_AzureBlobStorage.cpp\n+++ b/src/Backups/BackupIO_AzureBlobStorage.cpp\n@@ -26,6 +26,48 @@ namespace ErrorCodes\n     extern const int LOGICAL_ERROR;\n }\n \n+/// This function compares the authorization methods used to access AzureBlobStorage\n+/// It takes 2 variables of variant type as input and checks if they are the same type and value\n+static bool compareAuthMethod (AzureBlobStorage::AuthMethod auth_method_a, AzureBlobStorage::AuthMethod auth_method_b)\n+{\n+    const auto * conn_string_a = std::get_if<AzureBlobStorage::ConnectionString>(&auth_method_a);\n+    const auto * conn_string_b = std::get_if<AzureBlobStorage::ConnectionString>(&auth_method_b);\n+\n+    if (conn_string_a && conn_string_b)\n+    {\n+        return *conn_string_a == *conn_string_b;\n+    }\n+\n+    const auto * shared_key_a = std::get_if<std::shared_ptr<Azure::Storage::StorageSharedKeyCredential>>(&auth_method_a);\n+    const auto * shared_key_b = std::get_if<std::shared_ptr<Azure::Storage::StorageSharedKeyCredential>>(&auth_method_b);\n+\n+    if (shared_key_a && shared_key_b)\n+    {\n+        return (shared_key_a->get()->AccountName == shared_key_b->get()->AccountName);\n+    }\n+\n+    const auto * workload_identity_a = std::get_if<std::shared_ptr<Azure::Identity::WorkloadIdentityCredential>>(&auth_method_a);\n+    const auto * workload_identity_b = std::get_if<std::shared_ptr<Azure::Identity::WorkloadIdentityCredential>>(&auth_method_b);\n+\n+    if (workload_identity_a && workload_identity_b)\n+    {\n+        Azure::Core::Credentials::TokenRequestContext tokenRequestContext;\n+        return workload_identity_a->get()->GetToken(tokenRequestContext, {}).Token == workload_identity_b->get()->GetToken(tokenRequestContext, {}).Token;\n+    }\n+\n+    const auto * managed_identity_a = std::get_if<std::shared_ptr<Azure::Identity::ManagedIdentityCredential>>(&auth_method_a);\n+    const auto * managed_identity_b = std::get_if<std::shared_ptr<Azure::Identity::ManagedIdentityCredential>>(&auth_method_b);\n+\n+    if (managed_identity_a && managed_identity_b)\n+    {\n+        Azure::Core::Credentials::TokenRequestContext tokenRequestContext;\n+        return managed_identity_a->get()->GetToken(tokenRequestContext, {}).Token == managed_identity_b->get()->GetToken(tokenRequestContext, {}).Token;\n+    }\n+\n+    return false;\n+\n+}\n+\n BackupReaderAzureBlobStorage::BackupReaderAzureBlobStorage(\n     const AzureBlobStorage::ConnectionParams & connection_params_,\n     const String & blob_path_,\n@@ -39,10 +81,11 @@ BackupReaderAzureBlobStorage::BackupReaderAzureBlobStorage(\n     , blob_path(blob_path_)\n {\n     auto client_ptr = AzureBlobStorage::getContainerClient(connection_params, /*readonly=*/ false);\n-    auto settings_ptr = AzureBlobStorage::getRequestSettingsForBackup(context_->getSettingsRef(), allow_azure_native_copy);\n+    auto settings_ptr = AzureBlobStorage::getRequestSettingsForBackup(context_, connection_params.endpoint.storage_account_url, allow_azure_native_copy);\n \n     object_storage = std::make_unique<AzureObjectStorage>(\n         \"BackupReaderAzureBlobStorage\",\n+        connection_params.auth_method,\n         std::move(client_ptr),\n         std::move(settings_ptr),\n         connection_params.getContainer(),\n@@ -103,6 +146,7 @@ void BackupReaderAzureBlobStorage::copyFileToDisk(const String & path_in_backup,\n                 /* dest_path */ dst_blob_path[0],\n                 settings,\n                 read_settings,\n+                compareAuthMethod(connection_params.auth_method, destination_disk->getObjectStorage()->getAzureBlobStorageAuthMethod()),\n                 threadPoolCallbackRunnerUnsafe<void>(getBackupsIOThreadPool().get(), \"BackupRDAzure\"));\n \n             return file_size;\n@@ -134,15 +178,17 @@ BackupWriterAzureBlobStorage::BackupWriterAzureBlobStorage(\n         connection_params.endpoint.container_already_exists = true;\n \n     auto client_ptr = AzureBlobStorage::getContainerClient(connection_params, /*readonly=*/ false);\n-    auto settings_ptr = AzureBlobStorage::getRequestSettingsForBackup(context_->getSettingsRef(), allow_azure_native_copy);\n+    auto settings_ptr = AzureBlobStorage::getRequestSettingsForBackup(context_, connection_params.endpoint.storage_account_url, allow_azure_native_copy);\n \n     object_storage = std::make_unique<AzureObjectStorage>(\n         \"BackupWriterAzureBlobStorage\",\n+        connection_params.auth_method,\n         std::move(client_ptr),\n         std::move(settings_ptr),\n         connection_params.getContainer(),\n         connection_params.getConnectionURL());\n \n+\n     client = object_storage->getAzureBlobStorageClient();\n     settings = object_storage->getSettings();\n }\n@@ -177,6 +223,7 @@ void BackupWriterAzureBlobStorage::copyFileFromDisk(\n                 fs::path(blob_path) / path_in_backup,\n                 settings,\n                 read_settings,\n+                compareAuthMethod(src_disk->getObjectStorage()->getAzureBlobStorageAuthMethod(), connection_params.auth_method),\n                 threadPoolCallbackRunnerUnsafe<void>(getBackupsIOThreadPool().get(), \"BackupWRAzure\"));\n             return; /// copied!\n         }\n@@ -200,6 +247,7 @@ void BackupWriterAzureBlobStorage::copyFile(const String & destination, const St\n        /* dest_path */ destination,\n        settings,\n        read_settings,\n+       true,\n        threadPoolCallbackRunnerUnsafe<void>(getBackupsIOThreadPool().get(), \"BackupWRAzure\"));\n }\n \ndiff --git a/src/Backups/BackupsWorker.cpp b/src/Backups/BackupsWorker.cpp\nindex 0b968a3d6a79..fc82128b8bed 100644\n--- a/src/Backups/BackupsWorker.cpp\n+++ b/src/Backups/BackupsWorker.cpp\n@@ -866,6 +866,7 @@ BackupPtr BackupsWorker::openBackupForReading(const BackupInfo & backup_info, co\n     backup_open_params.base_backup_info = restore_settings.base_backup_info;\n     backup_open_params.password = restore_settings.password;\n     backup_open_params.allow_s3_native_copy = restore_settings.allow_s3_native_copy;\n+    backup_open_params.allow_azure_native_copy = restore_settings.allow_azure_native_copy;\n     backup_open_params.use_same_s3_credentials_for_base_backup = restore_settings.use_same_s3_credentials_for_base_backup;\n     backup_open_params.use_same_password_for_base_backup = restore_settings.use_same_password_for_base_backup;\n     backup_open_params.read_settings = getReadSettingsForRestore(context);\ndiff --git a/src/Backups/RestoreSettings.cpp b/src/Backups/RestoreSettings.cpp\nindex f77ac876f01f..ee6531d8111b 100644\n--- a/src/Backups/RestoreSettings.cpp\n+++ b/src/Backups/RestoreSettings.cpp\n@@ -164,6 +164,7 @@ namespace\n     M(Bool, skip_unresolved_access_dependencies) \\\n     M(Bool, update_access_entities_dependents) \\\n     M(RestoreUDFCreationMode, create_function) \\\n+    M(Bool, allow_azure_native_copy) \\\n     M(Bool, allow_s3_native_copy) \\\n     M(Bool, use_same_s3_credentials_for_base_backup) \\\n     M(Bool, use_same_password_for_base_backup) \\\ndiff --git a/src/Backups/RestoreSettings.h b/src/Backups/RestoreSettings.h\nindex b5456db8296f..1b3b5bae47dc 100644\n--- a/src/Backups/RestoreSettings.h\n+++ b/src/Backups/RestoreSettings.h\n@@ -127,6 +127,9 @@ struct RestoreSettings\n     /// Whether native copy is allowed (optimization for cloud storages, that sometimes could have bugs)\n     bool allow_s3_native_copy = true;\n \n+    /// Whether native copy is allowed for AzureBlobStorage\n+    bool allow_azure_native_copy = true;\n+\n     /// Whether base backup from S3 should inherit credentials from the RESTORE query.\n     bool use_same_s3_credentials_for_base_backup = false;\n \ndiff --git a/src/CMakeLists.txt b/src/CMakeLists.txt\nindex 27954fbcc50f..0f7a3cf851b1 100644\n--- a/src/CMakeLists.txt\n+++ b/src/CMakeLists.txt\n@@ -104,6 +104,7 @@ add_headers_and_sources(clickhouse_common_io IO/Archives)\n add_headers_and_sources(clickhouse_common_io IO/Protobuf)\n add_headers_and_sources(clickhouse_common_io IO/S3)\n add_headers_and_sources(clickhouse_common_io IO/AzureBlobStorage)\n+add_headers_and_sources(clickhouse_common_io Disks/ObjectStorages/AzureBlobStorage)\n list (REMOVE_ITEM clickhouse_common_io_sources Common/malloc.cpp Common/new_delete.cpp)\n \n \ndiff --git a/src/Client/BuzzHouse/Generator/TableSetttings.cpp b/src/Client/BuzzHouse/Generator/TableSetttings.cpp\nindex e6a37d59d1e3..80cdc372086c 100644\n--- a/src/Client/BuzzHouse/Generator/TableSetttings.cpp\n+++ b/src/Client/BuzzHouse/Generator/TableSetttings.cpp\n@@ -199,7 +199,8 @@ static std::unordered_map<String, CHSetting> mergeTreeTableSettings\n std::unordered_map<TableEngineValues, std::unordered_map<String, CHSetting>> allTableSettings;\n \n std::unordered_map<String, CHSetting> restoreSettings\n-    = {{\"allow_different_database_def\", CHSetting(trueOrFalse, {}, false)},\n+    = {{\"allow_azure_native_copy\", CHSetting(trueOrFalse, {}, false)},\n+       {\"allow_different_database_def\", CHSetting(trueOrFalse, {}, false)},\n        {\"allow_different_table_def\", CHSetting(trueOrFalse, {}, false)},\n        {\"allow_non_empty_tables\", CHSetting(trueOrFalse, {}, false)},\n        {\"allow_s3_native_copy\", CHSetting(trueOrFalse, {}, false)},\ndiff --git a/src/Disks/ObjectStorages/AzureBlobStorage/AzureBlobStorageCommon.cpp b/src/Disks/ObjectStorages/AzureBlobStorage/AzureBlobStorageCommon.cpp\nindex f6c2c6fdeea4..90ea8844356a 100644\n--- a/src/Disks/ObjectStorages/AzureBlobStorage/AzureBlobStorageCommon.cpp\n+++ b/src/Disks/ObjectStorages/AzureBlobStorage/AzureBlobStorageCommon.cpp\n@@ -2,16 +2,23 @@\n \n #if USE_AZURE_BLOB_STORAGE\n \n+#include <azure/identity/managed_identity_credential.hpp>\n+#include <azure/identity/workload_identity_credential.hpp>\n+#include <azure/storage/blobs/blob_options.hpp>\n+#include <azure/storage/blobs/blob_responses.hpp>\n+#include <azure/storage/blobs/rest_client.hpp>\n+#include <azure/core/credentials/credentials.hpp>\n+\n+#endif\n+\n #include <Common/Exception.h>\n #include <Common/ProfileEvents.h>\n #include <Common/re2.h>\n #include <Core/Settings.h>\n-#include <azure/identity/managed_identity_credential.hpp>\n-#include <azure/identity/workload_identity_credential.hpp>\n-#include <azure/storage/blobs/blob_options.hpp>\n #include <Poco/Util/AbstractConfiguration.h>\n #include <Interpreters/Context.h>\n #include <filesystem>\n+#include <Common/logger_useful.h>\n \n namespace ProfileEvents\n {\n@@ -54,6 +61,8 @@ namespace ErrorCodes\n namespace AzureBlobStorage\n {\n \n+#if USE_AZURE_BLOB_STORAGE\n+\n static void validateStorageAccountUrl(const String & storage_account_url)\n {\n     const auto * storage_account_url_pattern_str = R\"(http(()|s)://[a-z0-9-.:]+(()|/)[a-z0-9]*(()|/))\";\n@@ -403,6 +412,8 @@ BlobClientOptions getClientOptions(const RequestSettings & settings, bool for_di\n     return client_options;\n }\n \n+#endif\n+\n std::unique_ptr<RequestSettings> getRequestSettings(const Settings & query_settings)\n {\n     auto settings = std::make_unique<RequestSettings>();\n@@ -428,17 +439,23 @@ std::unique_ptr<RequestSettings> getRequestSettings(const Settings & query_setti\n     return settings;\n }\n \n-std::unique_ptr<RequestSettings> getRequestSettingsForBackup(const Settings & query_settings, bool use_native_copy)\n+std::unique_ptr<RequestSettings> getRequestSettingsForBackup(ContextPtr context, String endpoint, bool use_native_copy)\n {\n-    auto settings = getRequestSettings(query_settings);\n-    settings->use_native_copy = use_native_copy;\n+    auto settings = getRequestSettings(context->getSettingsRef());\n+\n+    auto endpoint_settings = context->getStorageAzureSettings().getSettings(endpoint);\n+    if (endpoint_settings)\n+        settings->use_native_copy = endpoint_settings->use_native_copy;\n+\n+    if (!use_native_copy)\n+        settings->use_native_copy = false;\n+\n     return settings;\n }\n \n-std::unique_ptr<RequestSettings> getRequestSettings(const Poco::Util::AbstractConfiguration & config, const String & config_prefix, ContextPtr context)\n+std::unique_ptr<RequestSettings> getRequestSettings(const Poco::Util::AbstractConfiguration & config, const String & config_prefix, const Settings & settings_ref)\n {\n     auto settings = std::make_unique<RequestSettings>();\n-    const auto & settings_ref = context->getSettingsRef();\n \n     settings->min_bytes_for_seek = config.getUInt64(config_prefix + \".min_bytes_for_seek\", 1024 * 1024);\n     settings->use_native_copy = config.getBool(config_prefix + \".use_native_copy\", false);\n@@ -464,6 +481,8 @@ std::unique_ptr<RequestSettings> getRequestSettings(const Poco::Util::AbstractCo\n \n     settings->check_objects_after_upload = config.getBool(config_prefix + \".check_objects_after_upload\", settings_ref[Setting::azure_check_objects_after_upload]);\n \n+\n+#if USE_AZURE_BLOB_STORAGE\n     if (config.has(config_prefix + \".curl_ip_resolve\"))\n     {\n         using CurlOptions = Azure::Core::Http::CurlTransportOptions;\n@@ -476,12 +495,76 @@ std::unique_ptr<RequestSettings> getRequestSettings(const Poco::Util::AbstractCo\n         else\n             throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Unexpected value for option 'curl_ip_resolve': {}. Expected one of 'ipv4' or 'ipv6'\", value);\n     }\n+#endif\n \n     return settings;\n }\n \n }\n \n+\n+void AzureSettingsByEndpoint::loadFromConfig(\n+    const Poco::Util::AbstractConfiguration & config,\n+    const std::string & config_prefix,\n+    const DB::Settings & settings)\n+{\n+    std::lock_guard lock(mutex);\n+    azure_settings.clear();\n+    if (!config.has(config_prefix))\n+        return;\n+\n+\n+    Poco::Util::AbstractConfiguration::Keys config_keys;\n+    config.keys(config_prefix, config_keys);\n+\n+    for (const String & key : config_keys)\n+    {\n+        const auto key_path = config_prefix + \".\" + key;\n+        String endpoint_path = key_path + \".connection_string\";\n+\n+        if (!config.has(endpoint_path))\n+        {\n+            endpoint_path = key_path + \".storage_account_url\";\n+\n+            if (!config.has(endpoint_path))\n+            {\n+                endpoint_path = key_path + \".endpoint\";\n+\n+                if (!config.has(endpoint_path))\n+                {\n+                    /// Error, shouldn't hit this todo:: throw error\n+                    continue;\n+                }\n+            }\n+        }\n+\n+        auto request_settings = AzureBlobStorage::getRequestSettings(config, key_path, settings);\n+\n+        azure_settings.emplace(\n+                config.getString(endpoint_path),\n+                std::move(*request_settings));\n+\n+    }\n+}\n+\n+std::optional<AzureBlobStorage::RequestSettings> AzureSettingsByEndpoint::getSettings(\n+    const String & endpoint) const\n+{\n+    std::lock_guard lock(mutex);\n+    auto next_prefix_setting = azure_settings.upper_bound(endpoint);\n+\n+    /// Linear time algorithm may be replaced with logarithmic with prefix tree map.\n+    for (auto possible_prefix_setting = next_prefix_setting; possible_prefix_setting != azure_settings.begin();)\n+    {\n+        std::advance(possible_prefix_setting, -1);\n+        const auto & [endpoint_prefix, settings] = *possible_prefix_setting;\n+        if (endpoint.starts_with(endpoint_prefix))\n+            return possible_prefix_setting->second;\n+    }\n+\n+    return {};\n+}\n+\n }\n \n-#endif\n+\ndiff --git a/src/Disks/ObjectStorages/AzureBlobStorage/AzureBlobStorageCommon.h b/src/Disks/ObjectStorages/AzureBlobStorage/AzureBlobStorageCommon.h\nindex cc9b102ee2a9..2808ffc4bf63 100644\n--- a/src/Disks/ObjectStorages/AzureBlobStorage/AzureBlobStorageCommon.h\n+++ b/src/Disks/ObjectStorages/AzureBlobStorage/AzureBlobStorageCommon.h\n@@ -4,14 +4,17 @@\n #if USE_AZURE_BLOB_STORAGE\n \n #include <azure/storage/blobs.hpp>\n+#include <azure/core/response.hpp>\n #include <azure/storage/blobs/blob_client.hpp>\n #include <azure/storage/blobs/blob_options.hpp>\n #include <azure/storage/blobs/blob_service_client.hpp>\n #include <azure/core/http/curl_transport.hpp>\n-#include <azure/identity/managed_identity_credential.hpp>\n-#include <azure/identity/workload_identity_credential.hpp>\n+\n+#endif\n+\n \n #include <Poco/Util/AbstractConfiguration.h>\n+#include <Disks/ObjectStorages/IObjectStorage.h>\n #include <Interpreters/Context_fwd.h>\n #include <base/strong_typedef.h>\n #include <filesystem>\n@@ -52,8 +55,10 @@ struct RequestSettings\n     bool check_objects_after_upload = false;\n     bool read_only = false;\n \n+#if USE_AZURE_BLOB_STORAGE\n     using CurlOptions = Azure::Core::Http::CurlTransportOptions;\n     CurlOptions::CurlOptIPResolve curl_ip_resolve = CurlOptions::CURL_IPRESOLVE_WHATEVER;\n+#endif\n };\n \n struct Endpoint\n@@ -97,6 +102,8 @@ struct Endpoint\n     }\n };\n \n+#if USE_AZURE_BLOB_STORAGE\n+\n using BlobClient = Azure::Storage::Blobs::BlobClient;\n using BlockBlobClient = Azure::Storage::Blobs::BlockBlobClient;\n using RawContainerClient = Azure::Storage::Blobs::BlobContainerClient;\n@@ -126,13 +133,6 @@ class ContainerClientWrapper\n using ContainerClient = ContainerClientWrapper;\n using ServiceClient = Azure::Storage::Blobs::BlobServiceClient;\n using BlobClientOptions = Azure::Storage::Blobs::BlobClientOptions;\n-using ConnectionString = StrongTypedef<String, struct ConnectionStringTag>;\n-\n-using AuthMethod = std::variant<\n-    ConnectionString,\n-    std::shared_ptr<Azure::Storage::StorageSharedKeyCredential>,\n-    std::shared_ptr<Azure::Identity::WorkloadIdentityCredential>,\n-    std::shared_ptr<Azure::Identity::ManagedIdentityCredential>>;\n \n struct ConnectionParams\n {\n@@ -155,12 +155,32 @@ std::unique_ptr<ContainerClient> getContainerClient(const ConnectionParams & par\n BlobClientOptions getClientOptions(const RequestSettings & settings, bool for_disk);\n AuthMethod getAuthMethod(const Poco::Util::AbstractConfiguration & config, const String & config_prefix);\n \n+#endif\n+\n std::unique_ptr<RequestSettings> getRequestSettings(const Settings & query_settings);\n-std::unique_ptr<RequestSettings> getRequestSettingsForBackup(const Settings & query_settings, bool use_native_copy);\n-std::unique_ptr<RequestSettings> getRequestSettings(const Poco::Util::AbstractConfiguration & config, const String & config_prefix, ContextPtr context);\n+std::unique_ptr<RequestSettings> getRequestSettingsForBackup(ContextPtr context, String endpoint, bool use_native_copy);\n+std::unique_ptr<RequestSettings> getRequestSettings(const Poco::Util::AbstractConfiguration & config, const String & config_prefix, const Settings & settings_ref);\n \n }\n \n-}\n \n-#endif\n+/// AzureSettingsByEndpoint contains a map of AzureBlobStorage endpoints and their settings, used in Context level\n+/// When any endpoint is used, the settings are looked up in this map and applied\n+class AzureSettingsByEndpoint\n+{\n+public:\n+    void loadFromConfig(\n+        const Poco::Util::AbstractConfiguration & config,\n+        const std::string & config_prefix,\n+        const DB::Settings & settings);\n+\n+    std::optional<AzureBlobStorage::RequestSettings> getSettings(\n+        const std::string & endpoint) const;\n+\n+private:\n+    mutable std::mutex mutex;\n+    std::map<const String, const AzureBlobStorage::RequestSettings> azure_settings;\n+};\n+\n+\n+}\ndiff --git a/src/Disks/ObjectStorages/AzureBlobStorage/AzureObjectStorage.cpp b/src/Disks/ObjectStorages/AzureBlobStorage/AzureObjectStorage.cpp\nindex e09a2307a8ad..25d789bef792 100644\n--- a/src/Disks/ObjectStorages/AzureBlobStorage/AzureObjectStorage.cpp\n+++ b/src/Disks/ObjectStorages/AzureBlobStorage/AzureObjectStorage.cpp\n@@ -105,11 +105,13 @@ class AzureIteratorAsync final : public IObjectStorageIteratorAsync\n \n AzureObjectStorage::AzureObjectStorage(\n     const String & name_,\n+    AzureBlobStorage::AuthMethod auth_method_,\n     ClientPtr && client_,\n     SettingsPtr && settings_,\n     const String & object_namespace_,\n     const String & description_)\n     : name(name_)\n+    , auth_method(std::move(auth_method_))\n     , client(std::move(client_))\n     , settings(std::move(settings_))\n     , object_namespace(object_namespace_)\n@@ -343,7 +345,7 @@ void AzureObjectStorage::applyNewSettings(\n     ContextPtr context,\n     const ApplyNewSettingsOptions & options)\n {\n-    auto new_settings = AzureBlobStorage::getRequestSettings(config, config_prefix, context);\n+    auto new_settings = AzureBlobStorage::getRequestSettings(config, config_prefix, context->getSettingsRef());\n     settings.set(std::move(new_settings));\n \n     if (!options.allow_client_change)\n@@ -369,7 +371,7 @@ std::unique_ptr<IObjectStorage> AzureObjectStorage::cloneObjectStorage(\n     const std::string & config_prefix,\n     ContextPtr context)\n {\n-    auto new_settings = AzureBlobStorage::getRequestSettings(config, config_prefix, context);\n+    auto new_settings = AzureBlobStorage::getRequestSettings(config, config_prefix, context->getSettingsRef());\n     bool is_client_for_disk = client.get()->IsClientForDisk();\n \n     AzureBlobStorage::ConnectionParams params\n@@ -380,7 +382,7 @@ std::unique_ptr<IObjectStorage> AzureObjectStorage::cloneObjectStorage(\n     };\n \n     auto new_client = AzureBlobStorage::getContainerClient(params, /*readonly=*/ true);\n-    return std::make_unique<AzureObjectStorage>(name, std::move(new_client), std::move(new_settings), new_namespace, params.endpoint.getServiceEndpoint());\n+    return std::make_unique<AzureObjectStorage>(name, params.auth_method, std::move(new_client), std::move(new_settings), new_namespace, params.endpoint.getServiceEndpoint());\n }\n \n }\ndiff --git a/src/Disks/ObjectStorages/AzureBlobStorage/AzureObjectStorage.h b/src/Disks/ObjectStorages/AzureBlobStorage/AzureObjectStorage.h\nindex 01af82c89689..becd0dccd70e 100644\n--- a/src/Disks/ObjectStorages/AzureBlobStorage/AzureObjectStorage.h\n+++ b/src/Disks/ObjectStorages/AzureBlobStorage/AzureObjectStorage.h\n@@ -26,6 +26,7 @@ class AzureObjectStorage : public IObjectStorage\n \n     AzureObjectStorage(\n         const String & name_,\n+        AzureBlobStorage::AuthMethod auth_method,\n         ClientPtr && client_,\n         SettingsPtr && settings_,\n         const String & object_namespace_,\n@@ -46,6 +47,8 @@ class AzureObjectStorage : public IObjectStorage\n \n     bool exists(const StoredObject & object) const override;\n \n+    AzureBlobStorage::AuthMethod getAzureBlobStorageAuthMethod() const override { return auth_method; }\n+\n     std::unique_ptr<ReadBufferFromFileBase> readObject( /// NOLINT\n         const StoredObject & object,\n         const ReadSettings & read_settings,\n@@ -111,6 +114,7 @@ class AzureObjectStorage : public IObjectStorage\n         bool if_exists);\n \n     const String name;\n+    AzureBlobStorage::AuthMethod auth_method;\n     /// client used to access the files in the Blob Storage cloud\n     MultiVersion<AzureBlobStorage::ContainerClient> client;\n     MultiVersion<AzureBlobStorage::RequestSettings> settings;\ndiff --git a/src/Disks/ObjectStorages/Cached/CachedObjectStorage.h b/src/Disks/ObjectStorages/Cached/CachedObjectStorage.h\nindex 00f236c1e89d..087f02d67539 100644\n--- a/src/Disks/ObjectStorages/Cached/CachedObjectStorage.h\n+++ b/src/Disks/ObjectStorages/Cached/CachedObjectStorage.h\n@@ -124,6 +124,11 @@ class CachedObjectStorage final : public IObjectStorage\n     {\n         return object_storage->getAzureBlobStorageClient();\n     }\n+\n+    AzureBlobStorage::AuthMethod getAzureBlobStorageAuthMethod() const override\n+    {\n+        return object_storage->getAzureBlobStorageAuthMethod();\n+    }\n #endif\n \n #if USE_AWS_S3\ndiff --git a/src/Disks/ObjectStorages/IObjectStorage.h b/src/Disks/ObjectStorages/IObjectStorage.h\nindex 26d28906c17d..3c727c50e79e 100644\n--- a/src/Disks/ObjectStorages/IObjectStorage.h\n+++ b/src/Disks/ObjectStorages/IObjectStorage.h\n@@ -5,6 +5,7 @@\n #include <mutex>\n #include <optional>\n #include <filesystem>\n+#include <variant>\n \n #include <Poco/Timestamp.h>\n #include <Poco/Util/AbstractConfiguration.h>\n@@ -28,11 +29,27 @@\n #include \"config.h\"\n \n #if USE_AZURE_BLOB_STORAGE\n+#include <azure/core/credentials/credentials.hpp>\n+#include <azure/storage/common/storage_credential.hpp>\n+#include <azure/identity/managed_identity_credential.hpp>\n+#include <azure/identity/workload_identity_credential.hpp>\n+\n namespace DB::AzureBlobStorage\n {\n class ContainerClientWrapper;\n using ContainerClient = ContainerClientWrapper;\n+\n+using ConnectionString = StrongTypedef<String, struct ConnectionStringTag>;\n+\n+using AuthMethod = std::variant<\n+    ConnectionString,\n+    std::shared_ptr<Azure::Storage::StorageSharedKeyCredential>,\n+    std::shared_ptr<Azure::Identity::WorkloadIdentityCredential>,\n+    std::shared_ptr<Azure::Identity::ManagedIdentityCredential>>;\n+\n }\n+\n+\n #endif\n \n #if USE_AWS_S3\n@@ -263,6 +280,11 @@ class IObjectStorage\n     {\n         throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"This function is only implemented for AzureBlobStorage\");\n     }\n+\n+    virtual AzureBlobStorage::AuthMethod getAzureBlobStorageAuthMethod() const\n+    {\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"This function is only implemented for AzureBlobStorage\");\n+    }\n #endif\n \n #if USE_AWS_S3\ndiff --git a/src/Disks/ObjectStorages/ObjectStorageFactory.cpp b/src/Disks/ObjectStorages/ObjectStorageFactory.cpp\nindex 7cacfc152978..39200b1571cb 100644\n--- a/src/Disks/ObjectStorages/ObjectStorageFactory.cpp\n+++ b/src/Disks/ObjectStorages/ObjectStorageFactory.cpp\n@@ -296,7 +296,7 @@ void registerAzureObjectStorage(ObjectStorageFactory & factory)\n         const ContextPtr & context,\n         bool /* skip_access_check */) -> ObjectStoragePtr\n     {\n-        auto azure_settings = AzureBlobStorage::getRequestSettings(config, config_prefix, context);\n+        auto azure_settings = AzureBlobStorage::getRequestSettings(config, config_prefix, context->getSettingsRef());\n \n         AzureBlobStorage::ConnectionParams params\n         {\n@@ -307,7 +307,7 @@ void registerAzureObjectStorage(ObjectStorageFactory & factory)\n \n         return createObjectStorage<AzureObjectStorage>(\n             ObjectStorageType::Azure, config, config_prefix, name,\n-            AzureBlobStorage::getContainerClient(params, /*readonly=*/ false), std::move(azure_settings),\n+            params.auth_method, AzureBlobStorage::getContainerClient(params, /*readonly=*/ false), std::move(azure_settings),\n             params.endpoint.prefix.empty() ? params.endpoint.container_name : params.endpoint.container_name + \"/\" + params.endpoint.prefix,\n             params.endpoint.getServiceEndpoint());\n     };\ndiff --git a/src/IO/AzureBlobStorage/copyAzureBlobStorageFile.cpp b/src/IO/AzureBlobStorage/copyAzureBlobStorageFile.cpp\nindex d9dfaccc530c..b49e34dd2d3a 100644\n--- a/src/IO/AzureBlobStorage/copyAzureBlobStorageFile.cpp\n+++ b/src/IO/AzureBlobStorage/copyAzureBlobStorageFile.cpp\n@@ -14,6 +14,12 @@\n #include <Disks/IO/WriteBufferFromAzureBlobStorage.h>\n #include <Common/getRandomASCIIString.h>\n \n+\n+#include <azure/core/credentials/credentials.hpp>\n+#include <azure/storage/common/storage_credential.hpp>\n+#include <azure/identity/managed_identity_credential.hpp>\n+#include <azure/identity/workload_identity_credential.hpp>\n+\n namespace ProfileEvents\n {\n     extern const Event AzureCopyObject;\n@@ -347,19 +353,21 @@ void copyAzureBlobStorageFile(\n     const String & dest_blob,\n     std::shared_ptr<const AzureBlobStorage::RequestSettings> settings,\n     const ReadSettings & read_settings,\n+    bool same_credentials,\n     ThreadPoolCallbackRunnerUnsafe<void> schedule)\n {\n     auto log = getLogger(\"copyAzureBlobStorageFile\");\n \n-    if (settings->use_native_copy)\n+    if (settings->use_native_copy && same_credentials)\n     {\n-        LOG_TRACE(log, \"Copying Blob: {} from Container: {} using native copy\", src_container_for_logging, src_blob);\n+        LOG_TRACE(log, \"Copying Blob: {} from Container: {} using native copy\", src_blob, src_container_for_logging);\n         ProfileEvents::increment(ProfileEvents::AzureCopyObject);\n         if (dest_client->IsClientForDisk())\n             ProfileEvents::increment(ProfileEvents::DiskAzureCopyObject);\n \n         auto block_blob_client_src = src_client->GetBlockBlobClient(src_blob);\n         auto block_blob_client_dest = dest_client->GetBlockBlobClient(dest_blob);\n+\n         auto source_uri = block_blob_client_src.GetUrl();\n \n         if (size < settings->max_single_part_copy_size)\n@@ -398,7 +406,7 @@ void copyAzureBlobStorageFile(\n     }\n     else\n     {\n-        LOG_TRACE(log, \"Reading from Container: {}, Blob: {}\", src_container_for_logging, src_blob);\n+        LOG_TRACE(log, \"Copying Blob: {} from Container: {} native copy is disabled {}\", src_blob, src_container_for_logging, same_credentials ? \"\" : \" because of different credentials\");\n         auto create_read_buffer = [&]\n         {\n             return std::make_unique<ReadBufferFromAzureBlobStorage>(\ndiff --git a/src/IO/AzureBlobStorage/copyAzureBlobStorageFile.h b/src/IO/AzureBlobStorage/copyAzureBlobStorageFile.h\nindex 79539a870862..036fbf34b0da 100644\n--- a/src/IO/AzureBlobStorage/copyAzureBlobStorageFile.h\n+++ b/src/IO/AzureBlobStorage/copyAzureBlobStorageFile.h\n@@ -30,6 +30,7 @@ void copyAzureBlobStorageFile(\n     const String & dest_blob,\n     std::shared_ptr<const AzureBlobStorage::RequestSettings> settings,\n     const ReadSettings & read_settings,\n+    bool same_credentials = true,\n     ThreadPoolCallbackRunnerUnsafe<void> schedule_ = {});\n \n \ndiff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp\nindex a351d7564483..233f7ccbba7e 100644\n--- a/src/Interpreters/Context.cpp\n+++ b/src/Interpreters/Context.cpp\n@@ -43,6 +43,7 @@\n #include <Storages/Distributed/DistributedSettings.h>\n #include <Storages/CompressionCodecSelector.h>\n #include <IO/S3Settings.h>\n+#include <Disks/ObjectStorages/AzureBlobStorage/AzureBlobStorageCommon.h>\n #include <Disks/DiskLocal.h>\n #include <Disks/ObjectStorages/DiskObjectStorage.h>\n #include <Disks/ObjectStorages/IObjectStorage.h>\n@@ -543,6 +544,7 @@ struct ContextSharedPart : boost::noncopyable\n     std::optional<Context::Dashboards> dashboards;\n \n     std::optional<S3SettingsByEndpoint> storage_s3_settings TSA_GUARDED_BY(mutex);   /// Settings of S3 storage\n+    std::optional<AzureSettingsByEndpoint> storage_azure_settings TSA_GUARDED_BY(mutex);   /// Settings of AzureBlobStorage\n     std::unordered_map<Context::WarningType, PreformattedMessage> warnings TSA_GUARDED_BY(mutex); /// Store warning messages about server.\n \n     /// Background executors for *MergeTree tables\n@@ -5235,6 +5237,12 @@ void Context::updateStorageConfiguration(const Poco::Util::AbstractConfiguration\n             shared->storage_s3_settings->loadFromConfig(config, /* config_prefix */\"s3\", getSettingsRef());\n     }\n \n+    {\n+        std::lock_guard lock(shared->mutex);\n+        if (shared->storage_azure_settings)\n+            shared->storage_azure_settings->loadFromConfig(config, /* config_prefix */\"configuration.disks.\", getSettingsRef());\n+    }\n+\n }\n \n \n@@ -5307,6 +5315,19 @@ const S3SettingsByEndpoint & Context::getStorageS3Settings() const\n     return *shared->storage_s3_settings;\n }\n \n+const AzureSettingsByEndpoint & Context::getStorageAzureSettings() const\n+{\n+    std::lock_guard lock(shared->mutex);\n+\n+    if (!shared->storage_azure_settings)\n+    {\n+        const auto & config = shared->getConfigRefWithLock(lock);\n+        shared->storage_azure_settings.emplace().loadFromConfig(config, \"storage_configuration.disks\", getSettingsRef());\n+    }\n+\n+    return *shared->storage_azure_settings;\n+}\n+\n void Context::checkCanBeDropped(const String & database, const String & table, const size_t & size, const size_t & max_size_to_drop) const\n {\n     if (!max_size_to_drop || size <= max_size_to_drop)\ndiff --git a/src/Interpreters/Context.h b/src/Interpreters/Context.h\nindex b05967a73419..000545a37f50 100644\n--- a/src/Interpreters/Context.h\n+++ b/src/Interpreters/Context.h\n@@ -140,6 +140,7 @@ struct InitialAllRangesAnnouncement;\n struct ParallelReadRequest;\n struct ParallelReadResponse;\n class S3SettingsByEndpoint;\n+class AzureSettingsByEndpoint;\n class IDatabase;\n class DDLWorker;\n class ITableFunction;\n@@ -1327,6 +1328,7 @@ class Context: public ContextData, public std::enable_shared_from_this<Context>\n     const MergeTreeSettings & getReplicatedMergeTreeSettings() const;\n     const DistributedSettings & getDistributedSettings() const;\n     const S3SettingsByEndpoint & getStorageS3Settings() const;\n+    const AzureSettingsByEndpoint & getStorageAzureSettings() const;\n \n     /// Prevents DROP TABLE if its size is greater than max_size (50GB by default, max_size=0 turn off this check)\n     void setMaxTableSizeToDrop(size_t max_size);\ndiff --git a/src/Storages/ObjectStorage/Azure/Configuration.cpp b/src/Storages/ObjectStorage/Azure/Configuration.cpp\nindex 083509c1a9c3..eec50b5aadb4 100644\n--- a/src/Storages/ObjectStorage/Azure/Configuration.cpp\n+++ b/src/Storages/ObjectStorage/Azure/Configuration.cpp\n@@ -89,6 +89,7 @@ ObjectStoragePtr StorageAzureConfiguration::createObjectStorage(ContextPtr conte\n \n     return std::make_unique<AzureObjectStorage>(\n         \"AzureBlobStorage\",\n+        connection_params.auth_method,\n         std::move(client),\n         std::move(settings),\n         connection_params.getContainer(),\n",
  "test_patch": "diff --git a/tests/integration/test_azure_blob_storage_native_copy/test.py b/tests/integration/test_azure_blob_storage_native_copy/test.py\nindex 2819da15936c..f5d24485b9e3 100644\n--- a/tests/integration/test_azure_blob_storage_native_copy/test.py\n+++ b/tests/integration/test_azure_blob_storage_native_copy/test.py\n@@ -34,11 +34,9 @@ def generate_config(port):\n                         <metadata_type>local</metadata_type>\n                         <type>object_storage</type>\n                         <object_storage_type>azure_blob_storage</object_storage_type>\n-                        <storage_account_url>http://azurite1:{port}/devstoreaccount1/</storage_account_url>\n+                        <connection_string>DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://azurite1:{port}/devstoreaccount1;</connection_string>\n                         <container_name>cont</container_name>\n                         <skip_access_check>false</skip_access_check>\n-                        <account_name>devstoreaccount1</account_name>\n-                        <account_key>Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==</account_key>\n                         <use_native_copy>true</use_native_copy>\n                     </disk_azure>\n                     <disk_azure_other_bucket>\n@@ -46,11 +44,9 @@ def generate_config(port):\n                         <type>object_storage</type>\n                         <object_storage_type>azure_blob_storage</object_storage_type>\n                         <use_native_copy>true</use_native_copy>\n-                        <storage_account_url>http://azurite1:{port}/devstoreaccount1/</storage_account_url>\n+                        <connection_string>DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://azurite1:{port}/devstoreaccount1;</connection_string>\n                         <container_name>othercontainer</container_name>\n                         <skip_access_check>false</skip_access_check>\n-                        <account_name>devstoreaccount1</account_name>\n-                        <account_key>Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==</account_key>\n                     </disk_azure_other_bucket>\n                     <disk_azure_cache>\n                         <type>cache</type>\n@@ -59,6 +55,17 @@ def generate_config(port):\n                         <max_size>1000000000</max_size>\n                         <cache_on_write_operations>1</cache_on_write_operations>\n                     </disk_azure_cache>\n+                    <disk_azure_different_auth>\n+                        <metadata_type>local</metadata_type>\n+                        <type>object_storage</type>\n+                        <object_storage_type>azure_blob_storage</object_storage_type>\n+                        <use_native_copy>true</use_native_copy>\n+                        <storage_account_url>http://azurite1:{port}/devstoreaccount1/</storage_account_url>\n+                        <container_name>othercontainer</container_name>\n+                        <skip_access_check>false</skip_access_check>\n+                        <account_name>devstoreaccount1</account_name>\n+                        <account_key>Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==</account_key>\n+                    </disk_azure_different_auth>\n                 </disks>\n                 <policies>\n                     <policy_azure>\n@@ -82,12 +89,20 @@ def generate_config(port):\n                             </main>\n                         </volumes>\n                     </policy_azure_cache>\n+                    <policy_azure_different_auth>\n+                        <volumes>\n+                            <main>\n+                                <disk>disk_azure_different_auth</disk>\n+                            </main>\n+                        </volumes>\n+                    </policy_azure_different_auth>\n                 </policies>\n             </storage_configuration>\n             <backups>\n                 <allowed_disk>disk_azure</allowed_disk>\n                 <allowed_disk>disk_azure_cache</allowed_disk>\n                 <allowed_disk>disk_azure_other_bucket</allowed_disk>\n+                <allowed_disk>disk_azure_different_auth</allowed_disk>\n             </backups>\n         </clickhouse>\n         \"\"\"\n@@ -116,6 +131,11 @@ def cluster():\n             main_configs=[path],\n             with_azurite=True,\n         )\n+        cluster.add_instance(\n+            \"node4\",\n+            main_configs=[path],\n+            with_azurite=True,\n+        )\n         cluster.start()\n \n         yield cluster\n@@ -156,7 +176,6 @@ def azure_query(\n                 node.query(query_on_retry)\n             continue\n \n-\n def test_backup_restore_on_merge_tree_same_container(cluster):\n     node1 = cluster.instances[\"node1\"]\n     azure_query(\n@@ -176,7 +195,7 @@ def test_backup_restore_on_merge_tree_same_container(cluster):\n \n     azure_query(\n         node1,\n-        f\"RESTORE TABLE test_simple_merge_tree AS test_simple_merge_tree_restored FROM {backup_destination};\",\n+        f\"RESTORE TABLE test_simple_merge_tree AS test_simple_merge_tree_restored FROM {backup_destination} SETTINGS allow_azure_native_copy = 1;\",\n     )\n     assert (\n         azure_query(node1, f\"SELECT * from test_simple_merge_tree_restored\") == \"1\\ta\\n\"\n@@ -256,3 +275,41 @@ def test_backup_restore_on_merge_tree_native_copy_async(cluster):\n \n     azure_query(node3, f\"DROP TABLE test_simple_merge_tree_async\")\n     azure_query(node3, f\"DROP TABLE test_simple_merge_tree_async_restored\")\n+\n+def test_backup_restore_native_copy_disabled_in_query(cluster):\n+    node4 = cluster.instances[\"node4\"]\n+    azure_query(\n+        node4,\n+        f\"CREATE TABLE test_simple_merge_tree_native_copy_disabled_in_query(key UInt64, data String) Engine = MergeTree() ORDER BY tuple() SETTINGS storage_policy='policy_azure'\",\n+    )\n+    azure_query(\n+        node4, f\"INSERT INTO test_simple_merge_tree_native_copy_disabled_in_query VALUES (1, 'a')\"\n+    )\n+\n+    backup_destination = f\"AzureBlobStorage('{cluster.env_variables['AZURITE_CONNECTION_STRING']}', 'cont', 'test_simple_merge_tree_native_copy_disabled_in_query_backup')\"\n+    print(\"BACKUP DEST\", backup_destination)\n+    azure_query(\n+        node4,\n+        f\"BACKUP TABLE test_simple_merge_tree_native_copy_disabled_in_query TO {backup_destination} SETTINGS allow_azure_native_copy = 0\",\n+    )\n+\n+    assert not node4.contains_in_log(\"using native copy\")\n+\n+def test_backup_restore_native_copy_disabled_due_to_different_auth(cluster):\n+    node4 = cluster.instances[\"node4\"]\n+    azure_query(\n+        node4,\n+        f\"CREATE TABLE test_simple_merge_tree_native_copy_disabled_due_to_different_auth(key UInt64, data String) Engine = MergeTree() ORDER BY tuple() SETTINGS storage_policy='policy_azure_different_auth'\",\n+    )\n+    azure_query(\n+        node4, f\"INSERT INTO test_simple_merge_tree_native_copy_disabled_due_to_different_auth VALUES (1, 'a')\"\n+    )\n+\n+    backup_destination = f\"AzureBlobStorage('{cluster.env_variables['AZURITE_CONNECTION_STRING']}', 'cont', 'test_simple_merge_tree_native_copy_disabled_due_to_different_auth_backup')\"\n+    print(\"BACKUP DEST\", backup_destination)\n+    azure_query(\n+        node4,\n+        f\"BACKUP TABLE test_simple_merge_tree_native_copy_disabled_due_to_different_auth TO {backup_destination}\",\n+    )\n+\n+    assert not node4.contains_in_log(\"using native copy\")\n\\ No newline at end of file\n",
  "problem_statement": "Implement fallback from native copy to read/write objects for Azure\nWe have this fallback for S3: https://github.com/ClickHouse/ClickHouse/pull/77401. Need to implement the same for Azure.\n",
  "hints_text": "",
  "created_at": "2025-04-24T23:35:56Z"
}