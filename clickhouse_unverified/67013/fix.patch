diff --git a/docs/en/engines/table-engines/mergetree-family/mergetree.md b/docs/en/engines/table-engines/mergetree-family/mergetree.md
index 0b693775dde8..74f1295ef964 100644
--- a/docs/en/engines/table-engines/mergetree-family/mergetree.md
+++ b/docs/en/engines/table-engines/mergetree-family/mergetree.md
@@ -989,7 +989,11 @@ ALTER TABLE tab DROP STATISTICS a;
 These lightweight statistics aggregate information about distribution of values in columns. Statistics are stored in every part and updated when every insert comes.
 They can be used for prewhere optimization only if we enable `set allow_statistics_optimize = 1`.
 
-#### Available Types of Column Statistics {#available-types-of-column-statistics}
+### Available Types of Column Statistics {#available-types-of-column-statistics}
+
+- `MinMax`
+
+    The minimum and maximum column value which allows to estimate the selectivity of range filters on numeric columns.
 
 - `TDigest`
 
@@ -1003,6 +1007,27 @@ They can be used for prewhere optimization only if we enable `set allow_statisti
 
     [Count-min](https://en.wikipedia.org/wiki/Count%E2%80%93min_sketch) sketches which provide an approximate count of the frequency of each value in a column.
 
+
+### Supported Data Types {#supported-data-types}
+
+|           | (U)Int* | Float* | Decimal(*) | Date* | Boolean | Enum* | (Fixed)String    |
+|-----------|---------|--------|------------|-------|---------|-------|------------------|
+| count_min | ✔       | ✔      | ✔          | ✔     | ✔       | ✔     | ✔                |
+| MinMax    | ✔       | ✔      | ✔          | ✔     | ✔       | ✔     | ✗                |
+| TDigest   | ✔       | ✔      | ✔          | ✔     | ✔       | ✔     | ✗                |
+| Uniq      | ✔       | ✔      | ✔          | ✔     | ✔       | ✔     | ✔                |
+
+
+### Supported Operations {#supported-operations}
+
+|           | Equality filters (==) | Range filters (>, >=, <, <=) |
+|-----------|-----------------------|------------------------------|
+| count_min | ✔                     | ✗                            |
+| MinMax    | ✗                     | ✔                            |
+| TDigest   | ✗                     | ✔                            |
+| Uniq      | ✔                     | ✗                            |
+
+
 ## Column-level Settings {#column-level-settings}
 
 Certain MergeTree settings can be overridden at column level:
diff --git a/src/Storages/Statistics/Statistics.cpp b/src/Storages/Statistics/Statistics.cpp
index 6372c804e0e9..795963bd55d6 100644
--- a/src/Storages/Statistics/Statistics.cpp
+++ b/src/Storages/Statistics/Statistics.cpp
@@ -9,6 +9,7 @@
 #include <Storages/ColumnsDescription.h>
 #include <Storages/Statistics/ConditionSelectivityEstimator.h>
 #include <Storages/Statistics/StatisticsCountMinSketch.h>
+#include <Storages/Statistics/StatisticsMinMax.h>
 #include <Storages/Statistics/StatisticsTDigest.h>
 #include <Storages/Statistics/StatisticsUniq.h>
 #include <Storages/StatisticsDescription.h>
@@ -101,6 +102,8 @@ Float64 ColumnStatistics::estimateLess(const Field & val) const
 {
     if (stats.contains(StatisticsType::TDigest))
         return stats.at(StatisticsType::TDigest)->estimateLess(val);
+    if (stats.contains(StatisticsType::MinMax))
+        return stats.at(StatisticsType::MinMax)->estimateLess(val);
     return rows * ConditionSelectivityEstimator::default_cond_range_factor;
 }
 
@@ -121,6 +124,14 @@ Float64 ColumnStatistics::estimateEqual(const Field & val) const
     if (stats.contains(StatisticsType::CountMinSketch))
         return stats.at(StatisticsType::CountMinSketch)->estimateEqual(val);
 #endif
+    if (stats.contains(StatisticsType::Uniq))
+    {
+        UInt64 cardinality = stats.at(StatisticsType::Uniq)->estimateCardinality();
+        if (cardinality == 0 || rows == 0)
+            return 0;
+        return 1.0 / cardinality * rows; /// assume uniform distribution
+    }
+
     return rows * ConditionSelectivityEstimator::default_cond_equal_factor;
 }
 
@@ -198,6 +209,9 @@ void MergeTreeStatisticsFactory::registerValidator(StatisticsType stats_type, Va
 
 MergeTreeStatisticsFactory::MergeTreeStatisticsFactory()
 {
+    registerValidator(StatisticsType::MinMax, minMaxStatisticsValidator);
+    registerCreator(StatisticsType::MinMax, minMaxStatisticsCreator);
+
     registerValidator(StatisticsType::TDigest, tdigestStatisticsValidator);
     registerCreator(StatisticsType::TDigest, tdigestStatisticsCreator);
 
@@ -234,7 +248,7 @@ ColumnStatisticsPtr MergeTreeStatisticsFactory::get(const ColumnDescription & co
     {
         auto it = creators.find(type);
         if (it == creators.end())
-            throw Exception(ErrorCodes::INCORRECT_QUERY, "Unknown statistic type '{}'. Available types: 'tdigest' 'uniq' and 'count_min'", type);
+            throw Exception(ErrorCodes::INCORRECT_QUERY, "Unknown statistic type '{}'. Available types: 'count_min', 'minmax', 'tdigest' and 'uniq'", type);
         auto stat_ptr = (it->second)(desc, column_desc.type);
         column_stat->stats[type] = stat_ptr;
     }
diff --git a/src/Storages/Statistics/StatisticsCountMinSketch.cpp b/src/Storages/Statistics/StatisticsCountMinSketch.cpp
index 6dbd0625d3d4..1a2459c230de 100644
--- a/src/Storages/Statistics/StatisticsCountMinSketch.cpp
+++ b/src/Storages/Statistics/StatisticsCountMinSketch.cpp
@@ -1,4 +1,3 @@
-
 #include <Storages/Statistics/StatisticsCountMinSketch.h>
 #include <DataTypes/DataTypeLowCardinality.h>
 #include <DataTypes/DataTypeNullable.h>
diff --git a/src/Storages/Statistics/StatisticsMinMax.cpp b/src/Storages/Statistics/StatisticsMinMax.cpp
new file mode 100644
index 000000000000..27072d225de4
--- /dev/null
+++ b/src/Storages/Statistics/StatisticsMinMax.cpp
@@ -0,0 +1,86 @@
+#include <Storages/Statistics/StatisticsMinMax.h>
+#include <DataTypes/DataTypeLowCardinality.h>
+#include <DataTypes/DataTypeNullable.h>
+#include <IO/ReadHelpers.h>
+#include <IO/WriteHelpers.h>
+
+#include <algorithm>
+
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+extern const int ILLEGAL_STATISTICS;
+}
+
+StatisticsMinMax::StatisticsMinMax(const SingleStatisticsDescription & description, const DataTypePtr & data_type_)
+    : IStatistics(description)
+    , data_type(data_type_)
+{
+}
+
+void StatisticsMinMax::update(const ColumnPtr & column)
+{
+    for (size_t row = 0; row < column->size(); ++row)
+    {
+        if (column->isNullAt(row))
+            continue;
+
+        auto value = column->getFloat64(row);
+        min = std::min(value, min);
+        max = std::max(value, max);
+    }
+    row_count += column->size();
+}
+
+void StatisticsMinMax::serialize(WriteBuffer & buf)
+{
+    writeIntBinary(row_count, buf);
+    writeFloatBinary(min, buf);
+    writeFloatBinary(max, buf);
+}
+
+void StatisticsMinMax::deserialize(ReadBuffer & buf)
+{
+    readIntBinary(row_count, buf);
+    readFloatBinary(min, buf);
+    readFloatBinary(max, buf);
+}
+
+Float64 StatisticsMinMax::estimateLess(const Field & val) const
+{
+    if (row_count == 0)
+        return 0;
+
+    auto val_as_float = StatisticsUtils::tryConvertToFloat64(val, data_type);
+    if (!val_as_float.has_value())
+        return 0;
+
+    if (val_as_float < min)
+        return 0;
+
+    if (val_as_float > max)
+        return row_count;
+
+    if (min == max)
+        return (val_as_float != max) ? 0 : row_count;
+
+    return ((*val_as_float - min) / (max - min)) * row_count;
+}
+
+void minMaxStatisticsValidator(const SingleStatisticsDescription & /*description*/, const DataTypePtr & data_type)
+{
+    auto inner_data_type = removeNullable(data_type);
+    inner_data_type = removeLowCardinalityAndNullable(inner_data_type);
+    if (!inner_data_type->isValueRepresentedByNumber())
+        throw Exception(ErrorCodes::ILLEGAL_STATISTICS, "Statistics of type 'minmax' do not support type {}", data_type->getName());
+}
+
+StatisticsPtr minMaxStatisticsCreator(const SingleStatisticsDescription & description, const DataTypePtr & data_type)
+{
+    return std::make_shared<StatisticsMinMax>(description, data_type);
+}
+
+}
diff --git a/src/Storages/Statistics/StatisticsMinMax.h b/src/Storages/Statistics/StatisticsMinMax.h
new file mode 100644
index 000000000000..c60fa810c47f
--- /dev/null
+++ b/src/Storages/Statistics/StatisticsMinMax.h
@@ -0,0 +1,33 @@
+#pragma once
+
+#include <Storages/Statistics/Statistics.h>
+#include <DataTypes/IDataType.h>
+
+
+namespace DB
+{
+
+class StatisticsMinMax : public IStatistics
+{
+public:
+    StatisticsMinMax(const SingleStatisticsDescription & statistics_description, const DataTypePtr & data_type_);
+
+    void update(const ColumnPtr & column) override;
+
+    void serialize(WriteBuffer & buf) override;
+    void deserialize(ReadBuffer & buf) override;
+
+    Float64 estimateLess(const Field & val) const override;
+
+private:
+    Float64 min = std::numeric_limits<Float64>::max();
+    Float64 max = std::numeric_limits<Float64>::min();
+    UInt64 row_count = 0;
+
+    DataTypePtr data_type;
+};
+
+void minMaxStatisticsValidator(const SingleStatisticsDescription & description, const DataTypePtr & data_type);
+StatisticsPtr minMaxStatisticsCreator(const SingleStatisticsDescription & description, const DataTypePtr & data_type);
+
+}
diff --git a/src/Storages/Statistics/StatisticsUniq.cpp b/src/Storages/Statistics/StatisticsUniq.cpp
index 07311b5b86d0..5e5b7a67b04a 100644
--- a/src/Storages/Statistics/StatisticsUniq.cpp
+++ b/src/Storages/Statistics/StatisticsUniq.cpp
@@ -56,7 +56,7 @@ void uniqStatisticsValidator(const SingleStatisticsDescription & /*description*/
 {
     DataTypePtr inner_data_type = removeNullable(data_type);
     inner_data_type = removeLowCardinalityAndNullable(inner_data_type);
-    if (!inner_data_type->isValueRepresentedByNumber())
+    if (!inner_data_type->isValueRepresentedByNumber() && !isStringOrFixedString(inner_data_type))
         throw Exception(ErrorCodes::ILLEGAL_STATISTICS, "Statistics of type 'uniq' do not support type {}", data_type->getName());
 }
 
diff --git a/src/Storages/StatisticsDescription.cpp b/src/Storages/StatisticsDescription.cpp
index 646341247580..4e0d901d0c75 100644
--- a/src/Storages/StatisticsDescription.cpp
+++ b/src/Storages/StatisticsDescription.cpp
@@ -50,7 +50,9 @@ static StatisticsType stringToStatisticsType(String type)
         return StatisticsType::Uniq;
     if (type == "count_min")
         return StatisticsType::CountMinSketch;
-    throw Exception(ErrorCodes::INCORRECT_QUERY, "Unknown statistics type: {}. Supported statistics types are 'tdigest', 'uniq' and 'count_min'.", type);
+    if (type == "minmax")
+        return StatisticsType::MinMax;
+    throw Exception(ErrorCodes::INCORRECT_QUERY, "Unknown statistics type: {}. Supported statistics types are 'count_min', 'minmax', 'tdigest' and 'uniq'.", type);
 }
 
 String SingleStatisticsDescription::getTypeName() const
@@ -63,8 +65,10 @@ String SingleStatisticsDescription::getTypeName() const
             return "Uniq";
         case StatisticsType::CountMinSketch:
             return "count_min";
+        case StatisticsType::MinMax:
+            return "minmax";
         default:
-            throw Exception(ErrorCodes::LOGICAL_ERROR, "Unknown statistics type: {}. Supported statistics types are 'tdigest', 'uniq' and 'count_min'.", type);
+            throw Exception(ErrorCodes::LOGICAL_ERROR, "Unknown statistics type: {}. Supported statistics types are 'count_min', 'minmax', 'tdigest' and 'uniq'.", type);
     }
 }
 
diff --git a/src/Storages/StatisticsDescription.h b/src/Storages/StatisticsDescription.h
index 46927f1418ce..3780de3e9679 100644
--- a/src/Storages/StatisticsDescription.h
+++ b/src/Storages/StatisticsDescription.h
@@ -14,6 +14,7 @@ enum class StatisticsType : UInt8
     TDigest = 0,
     Uniq = 1,
     CountMinSketch = 2,
+    MinMax = 3,
 
     Max = 63,
 };
