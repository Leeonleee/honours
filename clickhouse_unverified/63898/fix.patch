diff --git a/programs/client/Client.cpp b/programs/client/Client.cpp
index 3e613532f3ae..1d99d223ee9d 100644
--- a/programs/client/Client.cpp
+++ b/programs/client/Client.cpp
@@ -1135,8 +1135,6 @@ void Client::processOptions(const OptionsDescription & options_description,
 
     if ((query_fuzzer_runs = options["query-fuzzer-runs"].as<int>()))
     {
-        // Fuzzer implies multiquery.
-        config().setBool("multiquery", true);
         // Ignore errors in parsing queries.
         config().setBool("ignore-error", true);
         ignore_error = true;
@@ -1144,8 +1142,6 @@ void Client::processOptions(const OptionsDescription & options_description,
 
     if ((create_query_fuzzer_runs = options["create-query-fuzzer-runs"].as<int>()))
     {
-        // Fuzzer implies multiquery.
-        config().setBool("multiquery", true);
         // Ignore errors in parsing queries.
         config().setBool("ignore-error", true);
 
@@ -1201,9 +1197,6 @@ void Client::processConfig()
     }
     print_stack_trace = config().getBool("stacktrace", false);
 
-    if (config().has("multiquery"))
-        is_multiquery = true;
-
     pager = config().getString("pager", "");
 
     setDefaultFormatsAndCompressionFromConfiguration();
@@ -1359,13 +1352,6 @@ void Client::readArguments(
                 allow_repeated_settings = true;
             else if (arg == "--allow_merge_tree_settings")
                 allow_merge_tree_settings = true;
-            else if (arg == "--multiquery" && (arg_num + 1) < argc && !std::string_view(argv[arg_num + 1]).starts_with('-'))
-            {
-                /// Transform the abbreviated syntax '--multiquery <SQL>' into the full syntax '--multiquery -q <SQL>'
-                ++arg_num;
-                arg = argv[arg_num];
-                addMultiquery(arg, common_arguments);
-            }
             else if (arg == "--password" && ((arg_num + 1) >= argc || std::string_view(argv[arg_num + 1]).starts_with('-')))
             {
                 common_arguments.emplace_back(arg);
diff --git a/programs/local/LocalServer.cpp b/programs/local/LocalServer.cpp
index ce0e179939d7..88d5a0253d17 100644
--- a/programs/local/LocalServer.cpp
+++ b/programs/local/LocalServer.cpp
@@ -569,9 +569,6 @@ void LocalServer::processConfig()
     if (!queries.empty() && getClientConfiguration().has("queries-file"))
         throw Exception(ErrorCodes::BAD_ARGUMENTS, "Options '--query' and '--queries-file' cannot be specified at the same time");
 
-    if (getClientConfiguration().has("multiquery"))
-        is_multiquery = true;
-
     pager = getClientConfiguration().getString("pager", "");
 
     delayed_interactive = getClientConfiguration().has("interactive") && (!queries.empty() || getClientConfiguration().has("queries-file"));
@@ -936,13 +933,6 @@ void LocalServer::readArguments(int argc, char ** argv, Arguments & common_argum
                 query_parameters.emplace(param_continuation.substr(0, equal_pos), param_continuation.substr(equal_pos + 1));
             }
         }
-        else if (arg == "--multiquery" && (arg_num + 1) < argc && !std::string_view(argv[arg_num + 1]).starts_with('-'))
-        {
-            /// Transform the abbreviated syntax '--multiquery <SQL>' into the full syntax '--multiquery -q <SQL>'
-            ++arg_num;
-            arg = argv[arg_num];
-            addMultiquery(arg, common_arguments);
-        }
         else
         {
             common_arguments.emplace_back(arg);
diff --git a/src/Client/ClientBase.cpp b/src/Client/ClientBase.cpp
index 78d8e7e3d6ad..91cf737f292f 100644
--- a/src/Client/ClientBase.cpp
+++ b/src/Client/ClientBase.cpp
@@ -80,6 +80,8 @@
 
 #include <Common/config_version.h>
 #include "config.h"
+#include <IO/ReadHelpers.h>
+#include <Processors/Formats/Impl/ValuesBlockInputFormat.h>
 
 #if USE_GWP_ASAN
 #    include <Common/GWPAsan.h>
@@ -745,14 +747,6 @@ void ClientBase::adjustSettings()
 
     /// NOTE: Do not forget to set changed=false to avoid sending it to the server (to avoid breakage read only profiles)
 
-    /// In case of multi-query we allow data after semicolon since it will be
-    /// parsed by the client and interpreted as new query
-    if (is_multiquery && !global_context->getSettingsRef().input_format_values_allow_data_after_semicolon.changed)
-    {
-        settings.input_format_values_allow_data_after_semicolon = true;
-        settings.input_format_values_allow_data_after_semicolon.changed = false;
-    }
-
     /// Do not limit pretty format output in case of --pager specified or in case of stdout is not a tty.
     if (!pager.empty() || !stdout_is_a_tty)
     {
@@ -1525,13 +1519,6 @@ void ClientBase::setInsertionTable(const ASTInsertQuery & insert_query)
 }
 
 
-void ClientBase::addMultiquery(std::string_view query, Arguments & common_arguments) const
-{
-    common_arguments.emplace_back("--multiquery");
-    common_arguments.emplace_back("-q");
-    common_arguments.emplace_back(query);
-}
-
 namespace
 {
 bool isStdinNotEmptyAndValid(ReadBufferFromFileDescriptor & std_in)
@@ -2186,23 +2173,48 @@ MultiQueryProcessingStage ClientBase::analyzeMultiQueryText(
         return MultiQueryProcessingStage::PARSING_FAILED;
     }
 
-    // INSERT queries may have the inserted data in the query text
-    // that follow the query itself, e.g. "insert into t format CSV 1;2".
-    // They need special handling. First of all, here we find where the
-    // inserted data ends. In multi-query mode, it is delimited by a
-    // newline.
-    // The VALUES format needs even more handling - we also allow the
-    // data to be delimited by semicolon. This case is handled later by
-    // the format parser itself.
-    // We can't do multiline INSERTs with inline data, because most
-    // row input formats (e.g. TSV) can't tell when the input stops,
-    // unlike VALUES.
+    // INSERT queries may have the inserted data in the query text that follow the query itself, e.g. "insert into t format CSV 1,2". They
+    // need special handling.
+    // - If the INSERT statement FORMAT is VALUES, we use the VALUES format parser to skip the inserted data until we reach the trailing single semicolon.
+    // - Other formats (e.g. FORMAT CSV) are arbitrarily more complex and tricky to parse. For example, we may be unable to distinguish if the semicolon
+    //   is part of the data or ends the statement. In this case, we simply assume that the end of the INSERT statement is determined by 

 (two newlines).
     auto * insert_ast = parsed_query->as<ASTInsertQuery>();
     const char * query_to_execute_end = this_query_end;
-
     if (insert_ast && insert_ast->data)
     {
-        this_query_end = find_first_symbols<'
'>(insert_ast->data, all_queries_end);
+        if (insert_ast->format == "Values")
+        {
+            // Invoke the VALUES format parser to skip the inserted data
+            ReadBufferFromMemory data_in(insert_ast->data, all_queries_end - insert_ast->data);
+            skipBOMIfExists(data_in);
+            do
+            {
+                skipWhitespaceIfAny(data_in);
+                if (data_in.eof() || *data_in.position() == ';')
+                    break;
+            }
+            while (ValuesBlockInputFormat::skipToNextRow(&data_in, 1, 0));
+            // Handle the case of a comment followed by a semicolon
+            //   Example: INSERT INTO tab VALUES xx; -- {serverError xx}
+            // If we use this error hint, the next query should not be placed on the same line
+            this_query_end = insert_ast->data + data_in.count();
+            const auto * pos_newline = find_first_symbols<'
'>(this_query_end, all_queries_end);
+            if (pos_newline != this_query_end)
+            {
+                TestHint hint(String(this_query_end, pos_newline - this_query_end));
+                if (hint.hasClientErrors() || hint.hasServerErrors())
+                    this_query_end = pos_newline;
+            }
+        }
+        else
+        {
+            // Handling of generic formats
+            auto pos_newline = String(insert_ast->data, all_queries_end).find("

");
+            if (pos_newline != std::string::npos)
+                this_query_end = insert_ast->data + pos_newline;
+            else
+                this_query_end = all_queries_end;
+        }
         insert_ast->end = this_query_end;
         query_to_execute_end = isSyncInsertWithData(*insert_ast, client_context) ? insert_ast->data : this_query_end;
     }
@@ -2237,7 +2249,10 @@ bool ClientBase::executeMultiQuery(const String & all_queries_text)
     size_t test_tags_length = getTestTagsLength(all_queries_text);
 
     /// Several queries separated by ';'.
-    /// INSERT data is ended by the end of line, not ';'.
+    /// INSERT data is ended by the empty line (

), not ';'.
+    /// Unnecessary semicolons may cause data to be parsed containing ';'
+    /// e.g. 'insert into xx format csv val;' will insert "val;" instead of "val"
+    ///      'insert into xx format csv val
;' will insert "val" and ";"
     /// An exception is VALUES format where we also support semicolon in
     /// addition to end of line.
     const char * this_query_begin = all_queries_text.data() + test_tags_length;
@@ -2248,8 +2263,8 @@ bool ClientBase::executeMultiQuery(const String & all_queries_text)
     String query_to_execute;
     ASTPtr parsed_query;
     std::unique_ptr<Exception> current_exception;
-
     size_t retries_count = 0;
+    bool is_first = true;
 
     while (true)
     {
@@ -2258,16 +2273,24 @@ bool ClientBase::executeMultiQuery(const String & all_queries_text)
         switch (stage)
         {
             case MultiQueryProcessingStage::QUERIES_END:
+            {
+                /// Compatible with old version when run interactive, e.g. "", "\ld"
+                if (is_first && is_interactive)
+                    processTextAsSingleQuery(all_queries_text);
+                return true;
+            }
             case MultiQueryProcessingStage::PARSING_FAILED:
             {
                 return true;
             }
             case MultiQueryProcessingStage::CONTINUE_PARSING:
             {
+                is_first = false;
                 continue;
             }
             case MultiQueryProcessingStage::PARSING_EXCEPTION:
             {
+                is_first = false;
                 this_query_end = find_first_symbols<'
'>(this_query_end, all_queries_end);
 
                 // Try to find test hint for syntax error. We don't know where
@@ -2297,6 +2320,7 @@ bool ClientBase::executeMultiQuery(const String & all_queries_text)
             }
             case MultiQueryProcessingStage::EXECUTE_QUERY:
             {
+                is_first = false;
                 full_query = all_queries_text.substr(this_query_begin - all_queries_text.data(), this_query_end - this_query_begin);
                 if (query_fuzzer_runs)
                 {
@@ -2306,6 +2330,8 @@ bool ClientBase::executeMultiQuery(const String & all_queries_text)
                     this_query_begin = this_query_end;
                     continue;
                 }
+                if (suggest)
+                    updateSuggest(parsed_query);
 
                 // Now we know for sure where the query ends.
                 // Look for the hint in the text of query + insert data + trailing
@@ -2456,14 +2482,6 @@ bool ClientBase::processQueryText(const String & text)
         return processMultiQueryFromFile(file_name);
     }
 
-    if (!is_multiquery)
-    {
-        assert(!query_fuzzer_runs);
-        processTextAsSingleQuery(text);
-
-        return true;
-    }
-
     if (query_fuzzer_runs)
     {
         processWithFuzzing(text);
@@ -2901,9 +2919,9 @@ void ClientBase::init(int argc, char ** argv)
 
         ("config-file,C", po::value<std::string>(), "config-file path")
 
-        ("query,q", po::value<std::vector<std::string>>()->multitoken(), R"(query; can be specified multiple times (--query "SELECT 1" --query "SELECT 2"...))")
+        ("query,q", po::value<std::vector<std::string>>()->multitoken(), R"(Query. Can be specified multiple times (--query "SELECT 1" --query "SELECT 2") or once with multiple comma-separated queries (--query "SELECT 1; SELECT 2;"). In the latter case, INSERT queries with non-VALUE format must be separated by empty lines.)")
         ("queries-file", po::value<std::vector<std::string>>()->multitoken(), "file path with queries to execute; multiple files can be specified (--queries-file file1 file2...)")
-        ("multiquery,n", "If specified, multiple queries separated by semicolons can be listed after --query. For convenience, it is also possible to omit --query and pass the queries directly after --multiquery.")
+        ("multiquery,n", "Obsolete, does nothing")
         ("multiline,m", "If specified, allow multiline queries (do not send the query on Enter)")
         ("database,d", po::value<std::string>(), "database")
         ("query_kind", po::value<std::string>()->default_value("initial_query"), "One of initial_query/secondary_query/no_query")
@@ -2932,7 +2950,7 @@ void ClientBase::init(int argc, char ** argv)
         ("vertical,E", "vertical output format, same as --format=Vertical or FORMAT Vertical or \\G at end of command")
         ("highlight", po::value<bool>()->default_value(true), "enable or disable basic syntax highlight in interactive command line")
 
-        ("ignore-error", "do not stop processing in multiquery mode")
+        ("ignore-error", "do not stop processing when an error occurs")
         ("stacktrace", "print stack traces of exceptions")
         ("hardware-utilization", "print hardware utilization information in progress bar")
         ("print-profile-events", po::value(&profile_events.print)->zero_tokens(), "Printing ProfileEvents packets")
@@ -3025,8 +3043,6 @@ void ClientBase::init(int argc, char ** argv)
         queries_files = options["queries-file"].as<std::vector<std::string>>();
     if (options.count("multiline"))
         getClientConfiguration().setBool("multiline", true);
-    if (options.count("multiquery"))
-        getClientConfiguration().setBool("multiquery", true);
     if (options.count("ignore-error"))
         getClientConfiguration().setBool("ignore-error", true);
     if (options.count("format"))
diff --git a/src/Client/ClientBase.h b/src/Client/ClientBase.h
index e3d5fe8dc975..7689744a373b 100644
--- a/src/Client/ClientBase.h
+++ b/src/Client/ClientBase.h
@@ -156,8 +156,6 @@ class ClientBase : public Poco::Util::Application, public IHints<2>
 
     void setInsertionTable(const ASTInsertQuery & insert_query);
 
-    void addMultiquery(std::string_view query, Arguments & common_arguments) const;
-
 private:
     void receiveResult(ASTPtr parsed_query, Int32 signals_before_stop, bool partial_result_on_first_cancel);
     bool receiveAndProcessPacket(ASTPtr parsed_query, bool cancelled_);
@@ -229,7 +227,6 @@ class ClientBase : public Poco::Util::Application, public IHints<2>
     std::unique_ptr<Poco::Runnable> signal_listener;
 
     bool is_interactive = false; /// Use either interactive line editing interface or batch mode.
-    bool is_multiquery = false;
     bool delayed_interactive = false;
 
     bool echo_queries = false; /// Print queries before execution in batch mode.
diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index 3349662cb787..4fc2034b855e 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -1156,7 +1156,6 @@ class IColumn;
     M(Bool, input_format_values_interpret_expressions, true, "For Values format: if the field could not be parsed by streaming parser, run SQL parser and try to interpret it as SQL expression.", 0) \
     M(Bool, input_format_values_deduce_templates_of_expressions, true, "For Values format: if the field could not be parsed by streaming parser, run SQL parser, deduce template of the SQL expression, try to parse all rows using template and then interpret expression for all rows.", 0) \
     M(Bool, input_format_values_accurate_types_of_literals, true, "For Values format: when parsing and interpreting expressions using template, check actual type of literal to avoid possible overflow and precision issues.", 0) \
-    M(Bool, input_format_values_allow_data_after_semicolon, false, "For Values format: allow extra data after semicolon (used by client to interpret comments).", 0) \
     M(Bool, input_format_avro_allow_missing_fields, false, "For Avro/AvroConfluent format: when field is not found in schema use default value instead of error", 0) \
     /** This setting is obsolete and do nothing, left for compatibility reasons. */ \
     M(Bool, input_format_avro_null_as_default, false, "For Avro/AvroConfluent format: insert default in case of null and non Nullable column", 0) \
diff --git a/src/Formats/FormatFactory.cpp b/src/Formats/FormatFactory.cpp
index 501343d2ca95..efd467abb37c 100644
--- a/src/Formats/FormatFactory.cpp
+++ b/src/Formats/FormatFactory.cpp
@@ -215,7 +215,6 @@ FormatSettings getFormatSettings(const ContextPtr & context, const Settings & se
     format_settings.tsv.allow_variable_number_of_columns = settings.input_format_tsv_allow_variable_number_of_columns;
     format_settings.tsv.crlf_end_of_line_input = settings.input_format_tsv_crlf_end_of_line;
     format_settings.values.accurate_types_of_literals = settings.input_format_values_accurate_types_of_literals;
-    format_settings.values.allow_data_after_semicolon = settings.input_format_values_allow_data_after_semicolon;
     format_settings.values.deduce_templates_of_expressions = settings.input_format_values_deduce_templates_of_expressions;
     format_settings.values.interpret_expressions = settings.input_format_values_interpret_expressions;
     format_settings.values.escape_quote_with_quote = settings.output_format_values_escape_quote_with_quote;
diff --git a/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp b/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp
index c23d717d52f0..157b61aa2af1 100644
--- a/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp
+++ b/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp
@@ -625,8 +625,6 @@ void ValuesBlockInputFormat::readSuffix()
         skipWhitespaceIfAny(*buf);
         if (buf->hasUnreadData())
             throw Exception(ErrorCodes::CANNOT_READ_ALL_DATA, "Cannot read data after semicolon");
-        if (!format_settings.values.allow_data_after_semicolon && !buf->eof())
-            throw Exception(ErrorCodes::CANNOT_READ_ALL_DATA, "Cannot read data after semicolon (and input_format_values_allow_data_after_semicolon=0)");
         return;
     }
 
