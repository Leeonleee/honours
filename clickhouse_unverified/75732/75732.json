{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 75732,
  "instance_id": "ClickHouse__ClickHouse-75732",
  "issue_numbers": [
    "70515",
    "75008"
  ],
  "base_commit": "54e210f0e81a747fde5237ae01ac357d7e842802",
  "patch": "diff --git a/src/Analyzer/Resolve/QueryAnalyzer.cpp b/src/Analyzer/Resolve/QueryAnalyzer.cpp\nindex 564b3db6d5eb..afd337cdcc3f 100644\n--- a/src/Analyzer/Resolve/QueryAnalyzer.cpp\n+++ b/src/Analyzer/Resolve/QueryAnalyzer.cpp\n@@ -580,14 +580,28 @@ void QueryAnalyzer::evaluateScalarSubqueryIfNeeded(QueryTreeNodePtr & node, Iden\n         Settings subquery_settings = context->getSettingsCopy();\n         subquery_settings[Setting::max_result_rows] = 1;\n         subquery_settings[Setting::extremes] = false;\n-        subquery_context->setSettings(subquery_settings);\n         /// When execute `INSERT INTO t WITH ... SELECT ...`, it may lead to `Unknown columns`\n         /// exception with this settings enabled(https://github.com/ClickHouse/ClickHouse/issues/52494).\n-        subquery_context->setSetting(\"use_structure_from_insertion_table_in_table_functions\", false);\n+        subquery_settings[Setting::use_structure_from_insertion_table_in_table_functions] = false;\n+        subquery_context->setSettings(subquery_settings);\n+\n+        auto query_tree = node->clone();\n+        /// Update context for the QueryTree, because apparently Planner would use this context.\n+        if (auto * new_query_node = query_tree->as<QueryNode>())\n+            new_query_node->getMutableContext() = subquery_context;\n+        if (auto * new_union_node = query_tree->as<UnionNode>())\n+            new_union_node->getMutableContext() = subquery_context;\n \n         auto options = SelectQueryOptions(QueryProcessingStage::Complete, scope.subquery_depth, true /*is_subquery*/);\n         options.only_analyze = only_analyze;\n-        auto interpreter = std::make_unique<InterpreterSelectQueryAnalyzer>(node->toAST(), subquery_context, subquery_context->getViewSource(), options);\n+\n+        QueryTreePassManager query_tree_pass_manager(subquery_context);\n+        addQueryTreePasses(query_tree_pass_manager, options.only_analyze);\n+        query_tree_pass_manager.run(query_tree);\n+\n+        if (auto storage = subquery_context->getViewSource())\n+            replaceStorageInQueryTree(query_tree, subquery_context, storage);\n+        auto interpreter = std::make_unique<InterpreterSelectQueryAnalyzer>(query_tree, subquery_context, options);\n \n         if (only_analyze)\n         {\ndiff --git a/src/Interpreters/InterpreterSelectQueryAnalyzer.cpp b/src/Interpreters/InterpreterSelectQueryAnalyzer.cpp\nindex ef753502139e..cf58370b4276 100644\n--- a/src/Interpreters/InterpreterSelectQueryAnalyzer.cpp\n+++ b/src/Interpreters/InterpreterSelectQueryAnalyzer.cpp\n@@ -106,6 +106,8 @@ ContextMutablePtr buildContext(const ContextPtr & context, const SelectQueryOpti\n     return result_context;\n }\n \n+}\n+\n void replaceStorageInQueryTree(QueryTreeNodePtr & query_tree, const ContextPtr & context, const StoragePtr & storage)\n {\n     auto nodes = extractAllTableReferences(query_tree);\n@@ -130,7 +132,7 @@ void replaceStorageInQueryTree(QueryTreeNodePtr & query_tree, const ContextPtr &\n     query_tree = query_tree->cloneAndReplace(replacement_map);\n }\n \n-QueryTreeNodePtr buildQueryTreeAndRunPasses(const ASTPtr & query,\n+static QueryTreeNodePtr buildQueryTreeAndRunPasses(const ASTPtr & query,\n     const SelectQueryOptions & select_query_options,\n     const ContextPtr & context,\n     const StoragePtr & storage)\n@@ -154,7 +156,6 @@ QueryTreeNodePtr buildQueryTreeAndRunPasses(const ASTPtr & query,\n     return query_tree;\n }\n \n-}\n \n InterpreterSelectQueryAnalyzer::InterpreterSelectQueryAnalyzer(\n     const ASTPtr & query_,\ndiff --git a/src/Interpreters/InterpreterSelectQueryAnalyzer.h b/src/Interpreters/InterpreterSelectQueryAnalyzer.h\nindex 7e3f0ed121da..c34d4111f25d 100644\n--- a/src/Interpreters/InterpreterSelectQueryAnalyzer.h\n+++ b/src/Interpreters/InterpreterSelectQueryAnalyzer.h\n@@ -88,4 +88,6 @@ class InterpreterSelectQueryAnalyzer : public IInterpreter\n     Planner planner;\n };\n \n+void replaceStorageInQueryTree(QueryTreeNodePtr & query_tree, const ContextPtr & context, const StoragePtr & storage);\n+\n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03040_recursive_cte_postgres_6.reference b/tests/queries/0_stateless/03040_recursive_cte_postgres_6.reference\nindex 7ccc3df9f0d9..513a7bedddf0 100644\n--- a/tests/queries/0_stateless/03040_recursive_cte_postgres_6.reference\n+++ b/tests/queries/0_stateless/03040_recursive_cte_postgres_6.reference\n@@ -88,7 +88,8 @@ WITH RECURSIVE x AS (SELECT 1 AS n UNION ALL SELECT n+1 FROM x ORDER BY 1)\n WITH RECURSIVE x AS (SELECT 1 AS id\n     UNION ALL\n     SELECT (SELECT * FROM x) FROM x WHERE id < 5\n-) SELECT * FROM x; -- { serverError UNKNOWN_TABLE }\n+) SELECT * FROM x; -- { serverError UNKNOWN_TABLE, CANNOT_INSERT_NULL_IN_ORDINARY_COLUMN }\n+1\n -- mutual recursive query (not implemented)\n WITH RECURSIVE\n   x AS (SELECT 1 AS id UNION ALL SELECT id+1 FROM y WHERE id < 5),\ndiff --git a/tests/queries/0_stateless/03040_recursive_cte_postgres_6.sql b/tests/queries/0_stateless/03040_recursive_cte_postgres_6.sql\nindex 6a6044198c87..ccabb0ef725b 100644\n--- a/tests/queries/0_stateless/03040_recursive_cte_postgres_6.sql\n+++ b/tests/queries/0_stateless/03040_recursive_cte_postgres_6.sql\n@@ -103,7 +103,7 @@ WITH RECURSIVE x AS (SELECT 1 AS n UNION ALL SELECT n+1 FROM x ORDER BY 1)\n WITH RECURSIVE x AS (SELECT 1 AS id\n     UNION ALL\n     SELECT (SELECT * FROM x) FROM x WHERE id < 5\n-) SELECT * FROM x; -- { serverError UNKNOWN_TABLE }\n+) SELECT * FROM x; -- { serverError UNKNOWN_TABLE, CANNOT_INSERT_NULL_IN_ORDINARY_COLUMN }\n \n -- mutual recursive query (not implemented)\n WITH RECURSIVE\ndiff --git a/tests/queries/0_stateless/03315_array_join_scalar.reference b/tests/queries/0_stateless/03315_array_join_scalar.reference\nnew file mode 100644\nindex 000000000000..648435c40fc7\n--- /dev/null\n+++ b/tests/queries/0_stateless/03315_array_join_scalar.reference\n@@ -0,0 +1,1 @@\n+[('a','b'),('a','c')]\t[('a','b'),('a','c')]\ndiff --git a/tests/queries/0_stateless/03315_array_join_scalar.sql b/tests/queries/0_stateless/03315_array_join_scalar.sql\nnew file mode 100644\nindex 000000000000..75e706509b01\n--- /dev/null\n+++ b/tests/queries/0_stateless/03315_array_join_scalar.sql\n@@ -0,0 +1,8 @@\n+WITH\n+    table_x AS (\n+        SELECT col_a, col_b\n+        FROM (SELECT 'a' AS col_a, ['b', 'c'] AS col_b)\n+        ARRAY JOIN col_b\n+    ),\n+    (SELECT groupArray((col_a, col_b)) FROM table_x) AS group_a\n+SELECT group_a, groupArray((col_a, col_b)) FROM table_x;\n",
  "problem_statement": "array join not working in subquery with enable_analyzer=1\n> 24.9.2\r\nhttps://fiddle.clickhouse.com/04789f5f-4f83-4703-bc51-15af31eb8e58\r\n\r\n```sql\r\ncreate table merge (url String, mergedUrls Array(String)) engine = Memory;\r\ninsert into merge values ('a', ['b', 'c']);\r\n\r\nwith input as (\r\n    select distinct on (d.url) d.url as cluster_name from merge d order by d.url desc limit 100\r\n),\r\n    cluster_url_q1 as (\r\n        select distinct on (d.url) d.url as cluster_name, d.mergedUrls as url\r\n        from merge d\r\n        where d.url in input\r\n        order by d.url\r\n    ),\r\n    cluster_url_t as (\r\n        select distinct on (cluster_name, url) cluster_name, url\r\n        from cluster_url_q1\r\n        array join url\r\n    ),\r\n    (select groupArray((cluster_name, url)) from cluster_url_t) as cluster_url_a\r\nselect cluster_url_a, groupArray((cluster_name, url)) from cluster_url_t\r\nsettings enable_analyzer=1;\r\n```\r\n\r\nafter another attempt to turn on the analyzer in one of the queries, the array join stopped working.\r\nexpected `[('a','b'),('a','c')]` got `[('a',['b','c'])]`\nMultiple Array Joins not working as excepted when passed inside subquery\n### Company or project name\n\n_No response_\n\n### Describe what's wrong\n\nWhen multiple array joins are passed inside a subquery, results of 2nd array join is not working as expected. Row values are still returned as an array, whereas it should have been returned as single value.\n\nhttps://fiddle.clickhouse.com/4f1f64b7-1105-4d89-bb99-800c056b8f97\n\n\n### Does it reproduce on the most recent release?\n\nYes\n\n### How to reproduce\n\nClickHouse version - latest\n\nhttps://fiddle.clickhouse.com/4f1f64b7-1105-4d89-bb99-800c056b8f97\n\n\n```\nCREATE TABLE test_table(\n    id integer,\n    array_a Nested(\n        a1 String,\n        a2 String\n    ),\n    array_b Nested(\n        b1 String,\n        b2 String\n    )\n)\nENGINE=MergeTree()\nORDER BY id;\n\nINSERT INTO test_table (id, array_a.a1, array_a.a2, array_b.b1, array_b.b2) VALUES ('1', ['r1a1'], ['r1a2'], ['r1b1'], ['r1b2']);\n\n-- sample query with multiple array joins\nSELECT array_b.b1\nFROM\n(\n    SELECT *\n    FROM test_table\n    ARRAY JOIN array_a\n)\nARRAY JOIN array_b;\n\n-- query with multiple array joins passed inside subquery which returns wrong result\nSELECT (\n        SELECT array_b.b1\n        FROM\n        (\n            SELECT *\n            FROM test_table\n            ARRAY JOIN array_a\n        )\n        ARRAY JOIN array_b\n    ) AS rows;\n```\n\n### Expected behavior\n\nResults of multiple array join inside subquery is returning singular value in CH version <= 24.9.3\n\nhttps://fiddle.clickhouse.com/067572ae-1265-415a-ba41-1723f915af98\n\n### Error message and/or stacktrace\n\n_No response_\n\n### Additional context\n\n_No response_\n",
  "hints_text": "simplified example:\n```\nwith\n    table_x as (\n        select col_a, col_b\n        from (select 'a' as col_a, ['b', 'c'] as col_b)\n        array join col_b\n    ),\n    (select groupArray((col_a, col_b)) from table_x) as group_a\nselect group_a, groupArray((col_a, col_b)) from table_x settings enable_analyzer=1;\n```\nhttps://fiddle.clickhouse.com/cc2e2ee3-df6a-477b-84cb-043a0ff16c93\n\nProbably related to #70515",
  "created_at": "2025-02-07T16:27:02Z"
}