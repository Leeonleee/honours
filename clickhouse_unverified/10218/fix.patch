diff --git a/base/common/DateLUTImpl.cpp b/base/common/DateLUTImpl.cpp
index d7ab00469925..a7ca21c984e7 100644
--- a/base/common/DateLUTImpl.cpp
+++ b/base/common/DateLUTImpl.cpp
@@ -133,7 +133,10 @@ DateLUTImpl::DateLUTImpl(const std::string & time_zone_)
     }
 
     /// Fill lookup table for years and months.
-    for (size_t day = 0; day < DATE_LUT_SIZE && lut[day].year <= DATE_LUT_MAX_YEAR; ++day)
+    size_t year_months_lut_index = 0;
+    size_t first_day_of_last_month = 0;
+
+    for (size_t day = 0; day < DATE_LUT_SIZE; ++day)
     {
         const Values & values = lut[day];
 
@@ -141,7 +144,16 @@ DateLUTImpl::DateLUTImpl(const std::string & time_zone_)
         {
             if (values.month == 1)
                 years_lut[values.year - DATE_LUT_MIN_YEAR] = day;
-            years_months_lut[(values.year - DATE_LUT_MIN_YEAR) * 12 + values.month - 1] = day;
+
+            year_months_lut_index = (values.year - DATE_LUT_MIN_YEAR) * 12 + values.month - 1;
+            years_months_lut[year_months_lut_index] = day;
+            first_day_of_last_month = day;
         }
     }
+
+    /// Fill the rest of lookup table with the same last month (2106-02-01).
+    for (; year_months_lut_index < DATE_LUT_YEARS * 12; ++year_months_lut_index)
+    {
+        years_months_lut[year_months_lut_index] = first_day_of_last_month;
+    }
 }
diff --git a/base/common/DateLUTImpl.h b/base/common/DateLUTImpl.h
index d9d27c56ee37..ec32d62bcadd 100644
--- a/base/common/DateLUTImpl.h
+++ b/base/common/DateLUTImpl.h
@@ -12,7 +12,7 @@
 /// Table size is bigger than DATE_LUT_MAX_DAY_NUM to fill all indices within UInt16 range: this allows to remove extra check.
 #define DATE_LUT_SIZE 0x10000
 #define DATE_LUT_MIN_YEAR 1970
-#define DATE_LUT_MAX_YEAR 2105 /// Last supported year
+#define DATE_LUT_MAX_YEAR 2106 /// Last supported year (incomplete)
 #define DATE_LUT_YEARS (1 + DATE_LUT_MAX_YEAR - DATE_LUT_MIN_YEAR) /// Number of years in lookup table
 
 #if defined(__PPC__)
diff --git a/src/Storages/MergeTree/MergeTreeDataWriter.cpp b/src/Storages/MergeTree/MergeTreeDataWriter.cpp
index 34c615994f09..23a60ddab783 100644
--- a/src/Storages/MergeTree/MergeTreeDataWriter.cpp
+++ b/src/Storages/MergeTree/MergeTreeDataWriter.cpp
@@ -210,8 +210,8 @@ MergeTreeData::MutableDataPartPtr MergeTreeDataWriter::writeTempPart(BlockWithPa
 
         const auto & date_lut = DateLUT::instance();
 
-        DayNum min_month = date_lut.toFirstDayNumOfMonth(DayNum(min_date));
-        DayNum max_month = date_lut.toFirstDayNumOfMonth(DayNum(max_date));
+        auto min_month = date_lut.toNumYYYYMM(min_date);
+        auto max_month = date_lut.toNumYYYYMM(max_date);
 
         if (min_month != max_month)
             throw Exception("Logical error: part spans more than one month.", ErrorCodes::LOGICAL_ERROR);
diff --git a/src/Storages/MergeTree/MergeTreePartInfo.cpp b/src/Storages/MergeTree/MergeTreePartInfo.cpp
index 43bd9538e3ef..d30f6470bb13 100644
--- a/src/Storages/MergeTree/MergeTreePartInfo.cpp
+++ b/src/Storages/MergeTree/MergeTreePartInfo.cpp
@@ -120,8 +120,8 @@ void MergeTreePartInfo::parseMinMaxDatesFromPartName(const String & part_name, D
     min_date = date_lut.YYYYMMDDToDayNum(min_yyyymmdd);
     max_date = date_lut.YYYYMMDDToDayNum(max_yyyymmdd);
 
-    DayNum min_month = date_lut.toFirstDayNumOfMonth(min_date);
-    DayNum max_month = date_lut.toFirstDayNumOfMonth(max_date);
+    auto min_month = date_lut.toNumYYYYMM(min_date);
+    auto max_month = date_lut.toNumYYYYMM(max_date);
 
     if (min_month != max_month)
         throw Exception("Part name " + part_name + " contains different months", ErrorCodes::BAD_DATA_PART_NAME);
diff --git a/src/Storages/StorageGenerateRandom.cpp b/src/Storages/StorageGenerateRandom.cpp
index 1fd2d4ec2d87..70b84c076b74 100644
--- a/src/Storages/StorageGenerateRandom.cpp
+++ b/src/Storages/StorageGenerateRandom.cpp
@@ -14,6 +14,7 @@
 #include <DataTypes/DataTypeArray.h>
 #include <DataTypes/DataTypeString.h>
 #include <DataTypes/DataTypeFixedString.h>
+#include <DataTypes/NestedUtils.h>
 #include <Columns/ColumnArray.h>
 #include <Columns/ColumnFixedString.h>
 #include <Columns/ColumnString.h>
@@ -57,7 +58,12 @@ void fillBufferWithRandomData(char * __restrict data, size_t size, pcg64 & rng)
 
 
 ColumnPtr fillColumnWithRandomData(
-    const DataTypePtr type, UInt64 limit, UInt64 max_array_length, UInt64 max_string_length, pcg64 & rng, const Context & context)
+    const DataTypePtr type,
+    UInt64 limit,
+    UInt64 max_array_length,
+    UInt64 max_string_length,
+    pcg64 & rng,
+    const Context & context)
 {
     TypeIndex idx = type->getTypeId();
 
@@ -205,7 +211,10 @@ ColumnPtr fillColumnWithRandomData(
         {
             auto column = ColumnUInt16::create();
             column->getData().resize(limit);
-            fillBufferWithRandomData(reinterpret_cast<char *>(column->getData().data()), limit * sizeof(UInt16), rng);
+
+            for (size_t i = 0; i < limit; ++i)
+                column->getData()[i] = rng() % (DATE_LUT_MAX_DAY_NUM + 1);   /// Slow
+
             return column;
         }
         case TypeIndex::UInt32: [[fallthrough]];
@@ -337,14 +346,24 @@ class GenerateSource : public SourceWithProgress
 protected:
     Chunk generate() override
     {
+        /// To support Nested types, we will collect them to single Array of Tuple.
+        auto names_and_types = Nested::collect(block_header.getNamesAndTypesList());
+
         Columns columns;
-        columns.reserve(block_header.columns());
-        DataTypes types = block_header.getDataTypes();
+        columns.reserve(names_and_types.size());
 
-        for (const auto & type : types)
-            columns.emplace_back(fillColumnWithRandomData(type, block_size, max_array_length, max_string_length, rng, context));
+        Block compact_block;
+        for (const auto & elem : names_and_types)
+        {
+            compact_block.insert(
+            {
+                fillColumnWithRandomData(elem.type, block_size, max_array_length, max_string_length, rng, context),
+                elem.type,
+                elem.name
+            });
+        }
 
-        return {std::move(columns), block_size};
+        return {Nested::flatten(compact_block).getColumns(), block_size};
     }
 
 private:
