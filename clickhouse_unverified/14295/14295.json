{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 14295,
  "instance_id": "ClickHouse__ClickHouse-14295",
  "issue_numbers": [
    "9249",
    "14214"
  ],
  "base_commit": "9cb3c743bd0ec28942b018c5853accfc1b1259b0",
  "patch": "diff --git a/src/Databases/DatabaseOnDisk.cpp b/src/Databases/DatabaseOnDisk.cpp\nindex a2a2dd992ed0..8d9f222bf697 100644\n--- a/src/Databases/DatabaseOnDisk.cpp\n+++ b/src/Databases/DatabaseOnDisk.cpp\n@@ -54,9 +54,12 @@ std::pair<String, StoragePtr> createTableFromAST(\n \n     if (ast_create_query.as_table_function)\n     {\n-        const auto & table_function = ast_create_query.as_table_function->as<ASTFunction &>();\n         const auto & factory = TableFunctionFactory::instance();\n-        StoragePtr storage = factory.get(table_function.name, context)->execute(ast_create_query.as_table_function, context, ast_create_query.table);\n+        auto table_function = factory.get(ast_create_query.as_table_function, context);\n+        ColumnsDescription columns;\n+        if (ast_create_query.columns_list && ast_create_query.columns_list->columns)\n+            columns = InterpreterCreateQuery::getColumnsDescription(*ast_create_query.columns_list->columns, context, false);\n+        StoragePtr storage = table_function->execute(ast_create_query.as_table_function, context, ast_create_query.table, std::move(columns));\n         storage->renameInMemory(ast_create_query);\n         return {ast_create_query.table, storage};\n     }\ndiff --git a/src/Databases/DatabaseOrdinary.cpp b/src/Databases/DatabaseOrdinary.cpp\nindex 13aeb7de1485..a1d242264444 100644\n--- a/src/Databases/DatabaseOrdinary.cpp\n+++ b/src/Databases/DatabaseOrdinary.cpp\n@@ -254,9 +254,12 @@ void DatabaseOrdinary::alterTable(const Context & context, const StorageID & tab\n \n     auto & ast_create_query = ast->as<ASTCreateQuery &>();\n \n-    if (ast_create_query.as_table_function)\n-        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot alter table {} because it was created AS table function\", backQuote(table_name));\n+    bool has_structure = ast_create_query.columns_list && ast_create_query.columns_list->columns;\n+    if (ast_create_query.as_table_function && !has_structure)\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot alter table {} because it was created AS table function\"\n+                                                     \" and doesn't have structure in metadata\", backQuote(table_name));\n \n+    assert(has_structure);\n     ASTPtr new_columns = InterpreterCreateQuery::formatColumns(metadata.columns);\n     ASTPtr new_indices = InterpreterCreateQuery::formatIndices(metadata.secondary_indices);\n     ASTPtr new_constraints = InterpreterCreateQuery::formatConstraints(metadata.constraints);\ndiff --git a/src/Interpreters/ClusterProxy/SelectStreamFactory.cpp b/src/Interpreters/ClusterProxy/SelectStreamFactory.cpp\nindex ed7bd2cf71fc..6639f6ad703a 100644\n--- a/src/Interpreters/ClusterProxy/SelectStreamFactory.cpp\n+++ b/src/Interpreters/ClusterProxy/SelectStreamFactory.cpp\n@@ -160,8 +160,7 @@ void SelectStreamFactory::createForShard(\n \n         if (table_func_ptr)\n         {\n-            const auto * table_function = table_func_ptr->as<ASTFunction>();\n-            TableFunctionPtr table_function_ptr = TableFunctionFactory::instance().get(table_function->name, context);\n+            TableFunctionPtr table_function_ptr = TableFunctionFactory::instance().get(table_func_ptr, context);\n             main_table_storage = table_function_ptr->execute(table_func_ptr, context, table_function_ptr->getName());\n         }\n         else\ndiff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp\nindex 68f18ffffe85..bebf4670a214 100644\n--- a/src/Interpreters/Context.cpp\n+++ b/src/Interpreters/Context.cpp\n@@ -942,7 +942,7 @@ StoragePtr Context::executeTableFunction(const ASTPtr & table_expression)\n \n     if (!res)\n     {\n-        TableFunctionPtr table_function_ptr = TableFunctionFactory::instance().get(table_expression->as<ASTFunction>()->name, *this);\n+        TableFunctionPtr table_function_ptr = TableFunctionFactory::instance().get(table_expression, *this);\n \n         /// Run it and remember the result\n         res = table_function_ptr->execute(table_expression, *this, table_function_ptr->getName());\ndiff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp\nindex 1b9c2ca34313..08062b6e6ea5 100644\n--- a/src/Interpreters/InterpreterCreateQuery.cpp\n+++ b/src/Interpreters/InterpreterCreateQuery.cpp\n@@ -453,6 +453,9 @@ InterpreterCreateQuery::TableProperties InterpreterCreateQuery::setProperties(AS\n \n     if (create.columns_list)\n     {\n+        if (create.as_table_function && (create.columns_list->indices || create.columns_list->constraints))\n+            throw Exception(\"Indexes and constraints are not supported for table functions\", ErrorCodes::INCORRECT_QUERY);\n+\n         if (create.columns_list->columns)\n         {\n             bool sanity_check_compression_codecs = !create.attach && !context.getSettingsRef().allow_suspicious_codecs;\n@@ -489,7 +492,12 @@ InterpreterCreateQuery::TableProperties InterpreterCreateQuery::setProperties(AS\n         properties.columns = ColumnsDescription(as_select_sample.getNamesAndTypesList());\n     }\n     else if (create.as_table_function)\n-        return {};\n+    {\n+        /// Table function without columns list.\n+        auto table_function = TableFunctionFactory::instance().get(create.as_table_function, context);\n+        properties.columns = table_function->getActualTableStructure(context);\n+        assert(!properties.columns.empty());\n+    }\n     else\n         throw Exception(\"Incorrect CREATE query: required list of column descriptions or AS section or SELECT.\", ErrorCodes::INCORRECT_QUERY);\n \n@@ -575,9 +583,12 @@ void InterpreterCreateQuery::validateTableStructure(const ASTCreateQuery & creat\n \n void InterpreterCreateQuery::setEngine(ASTCreateQuery & create) const\n {\n+    if (create.as_table_function)\n+        return;\n+\n     if (create.storage || create.is_view || create.is_materialized_view || create.is_live_view || create.is_dictionary)\n     {\n-        if (create.temporary && create.storage->engine->name != \"Memory\")\n+        if (create.temporary && create.storage && create.storage->engine && create.storage->engine->name != \"Memory\")\n             throw Exception(\n                 \"Temporary tables can only be created with ENGINE = Memory, not \" + create.storage->engine->name,\n                 ErrorCodes::INCORRECT_QUERY);\n@@ -757,9 +768,8 @@ bool InterpreterCreateQuery::doCreateTable(ASTCreateQuery & create,\n     /// NOTE: CREATE query may be rewritten by Storage creator or table function\n     if (create.as_table_function)\n     {\n-        const auto & table_function = create.as_table_function->as<ASTFunction &>();\n         const auto & factory = TableFunctionFactory::instance();\n-        res = factory.get(table_function.name, context)->execute(create.as_table_function, context, create.table);\n+        res = factory.get(create.as_table_function, context)->execute(create.as_table_function, context, create.table, properties.columns);\n         res->renameInMemory({create.database, create.table, create.uuid});\n     }\n     else\ndiff --git a/src/Interpreters/InterpreterDescribeQuery.cpp b/src/Interpreters/InterpreterDescribeQuery.cpp\nindex 9c11bf147d3f..27d8ac48bc8e 100644\n--- a/src/Interpreters/InterpreterDescribeQuery.cpp\n+++ b/src/Interpreters/InterpreterDescribeQuery.cpp\n@@ -72,23 +72,16 @@ BlockInputStreamPtr InterpreterDescribeQuery::executeImpl()\n             table_expression.subquery->children.at(0), context).getNamesAndTypesList();\n         columns = ColumnsDescription(std::move(names_and_types));\n     }\n+    else if (table_expression.table_function)\n+    {\n+        TableFunctionPtr table_function_ptr = TableFunctionFactory::instance().get(table_expression.table_function, context);\n+        columns = table_function_ptr->getActualTableStructure(context);\n+    }\n     else\n     {\n-        StoragePtr table;\n-        if (table_expression.table_function)\n-        {\n-            const auto & table_function = table_expression.table_function->as<ASTFunction &>();\n-            TableFunctionPtr table_function_ptr = TableFunctionFactory::instance().get(table_function.name, context);\n-            /// Run the table function and remember the result\n-            table = table_function_ptr->execute(table_expression.table_function, context, table_function_ptr->getName());\n-        }\n-        else\n-        {\n-            auto table_id = context.resolveStorageID(table_expression.database_and_table_name);\n-            context.checkAccess(AccessType::SHOW_COLUMNS, table_id);\n-            table = DatabaseCatalog::instance().getTable(table_id, context);\n-        }\n-\n+        auto table_id = context.resolveStorageID(table_expression.database_and_table_name);\n+        context.checkAccess(AccessType::SHOW_COLUMNS, table_id);\n+        auto table = DatabaseCatalog::instance().getTable(table_id, context);\n         auto table_lock = table->lockForShare(context.getInitialQueryId(), context.getSettingsRef().lock_acquire_timeout);\n         auto metadata_snapshot = table->getInMemoryMetadataPtr();\n         columns = metadata_snapshot->getColumns();\ndiff --git a/src/Interpreters/InterpreterInsertQuery.cpp b/src/Interpreters/InterpreterInsertQuery.cpp\nindex 5985a7fb7d65..15e9ce070f46 100644\n--- a/src/Interpreters/InterpreterInsertQuery.cpp\n+++ b/src/Interpreters/InterpreterInsertQuery.cpp\n@@ -67,9 +67,8 @@ StoragePtr InterpreterInsertQuery::getTable(ASTInsertQuery & query)\n {\n     if (query.table_function)\n     {\n-        const auto * table_function = query.table_function->as<ASTFunction>();\n         const auto & factory = TableFunctionFactory::instance();\n-        TableFunctionPtr table_function_ptr = factory.get(table_function->name, context);\n+        TableFunctionPtr table_function_ptr = factory.get(query.table_function, context);\n         return table_function_ptr->execute(query.table_function, context, table_function_ptr->getName());\n     }\n \ndiff --git a/src/Interpreters/getHeaderForProcessingStage.cpp b/src/Interpreters/getHeaderForProcessingStage.cpp\nnew file mode 100644\nindex 000000000000..db7008a17794\n--- /dev/null\n+++ b/src/Interpreters/getHeaderForProcessingStage.cpp\n@@ -0,0 +1,69 @@\n+#include <Interpreters/getHeaderForProcessingStage.h>\n+#include <Interpreters/InterpreterSelectQuery.h>\n+#include <Storages/IStorage.h>\n+#include <DataStreams/OneBlockInputStream.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int LOGICAL_ERROR;\n+}\n+\n+/// Rewrite original query removing joined tables from it\n+bool removeJoin(ASTSelectQuery & select)\n+{\n+    const auto & tables = select.tables();\n+    if (!tables || tables->children.size() < 2)\n+        return false;\n+\n+    const auto & joined_table = tables->children[1]->as<ASTTablesInSelectQueryElement &>();\n+    if (!joined_table.table_join)\n+        return false;\n+\n+    /// The most simple temporary solution: leave only the first table in query.\n+    /// TODO: we also need to remove joined columns and related functions (taking in account aliases if any).\n+    tables->children.resize(1);\n+    return true;\n+}\n+\n+Block getHeaderForProcessingStage(\n+        const IStorage & storage,\n+        const Names & column_names,\n+        const StorageMetadataPtr & metadata_snapshot,\n+        const SelectQueryInfo & query_info,\n+        const Context & context,\n+        QueryProcessingStage::Enum processed_stage)\n+{\n+    switch (processed_stage)\n+    {\n+        case QueryProcessingStage::FetchColumns:\n+        {\n+            Block header = metadata_snapshot->getSampleBlockForColumns(column_names, storage.getVirtuals(), storage.getStorageID());\n+            if (query_info.prewhere_info)\n+            {\n+                query_info.prewhere_info->prewhere_actions->execute(header);\n+                if (query_info.prewhere_info->remove_prewhere_column)\n+                    header.erase(query_info.prewhere_info->prewhere_column_name);\n+            }\n+            return header;\n+        }\n+        case QueryProcessingStage::WithMergeableState:\n+        case QueryProcessingStage::Complete:\n+        case QueryProcessingStage::WithMergeableStateAfterAggregation:\n+        case QueryProcessingStage::MAX:\n+        {\n+            auto query = query_info.query->clone();\n+            removeJoin(*query->as<ASTSelectQuery>());\n+\n+            auto stream = std::make_shared<OneBlockInputStream>(\n+                    metadata_snapshot->getSampleBlockForColumns(column_names, storage.getVirtuals(), storage.getStorageID()));\n+            return InterpreterSelectQuery(query, context, stream, SelectQueryOptions(processed_stage).analyze()).getSampleBlock();\n+        }\n+    }\n+    throw Exception(\"Logical Error: unknown processed stage.\", ErrorCodes::LOGICAL_ERROR);\n+}\n+\n+}\n+\ndiff --git a/src/Interpreters/getHeaderForProcessingStage.h b/src/Interpreters/getHeaderForProcessingStage.h\nnew file mode 100644\nindex 000000000000..ec238edf7747\n--- /dev/null\n+++ b/src/Interpreters/getHeaderForProcessingStage.h\n@@ -0,0 +1,27 @@\n+#pragma once\n+#include <Core/Block.h>\n+#include <Core/Names.h>\n+#include <Core/QueryProcessingStage.h>\n+\n+\n+namespace DB\n+{\n+\n+class IStorage;\n+struct StorageInMemoryMetadata;\n+using StorageMetadataPtr = std::shared_ptr<const StorageInMemoryMetadata>;\n+struct SelectQueryInfo;\n+class Context;\n+class ASTSelectQuery;\n+\n+bool removeJoin(ASTSelectQuery & select);\n+\n+Block getHeaderForProcessingStage(\n+        const IStorage & storage,\n+        const Names & column_names,\n+        const StorageMetadataPtr & metadata_snapshot,\n+        const SelectQueryInfo & query_info,\n+        const Context & context,\n+        QueryProcessingStage::Enum processed_stage);\n+\n+}\ndiff --git a/src/Interpreters/ya.make b/src/Interpreters/ya.make\nindex bd16843517f4..a574efaa26b4 100644\n--- a/src/Interpreters/ya.make\n+++ b/src/Interpreters/ya.make\n@@ -61,6 +61,7 @@ SRCS(\n     ExtractExpressionInfoVisitor.cpp\n     FillingRow.cpp\n     getClusterName.cpp\n+    getHeaderForProcessingStage.cpp\n     getTableExpressions.cpp\n     HashJoin.cpp\n     IdentifierSemantic.cpp\ndiff --git a/src/Parsers/ASTCreateQuery.cpp b/src/Parsers/ASTCreateQuery.cpp\nindex 73903e28f84b..8c5681c3a9ca 100644\n--- a/src/Parsers/ASTCreateQuery.cpp\n+++ b/src/Parsers/ASTCreateQuery.cpp\n@@ -282,13 +282,23 @@ void ASTCreateQuery::formatQueryImpl(const FormatSettings & settings, FormatStat\n \n     if (as_table_function)\n     {\n+        if (columns_list)\n+        {\n+            frame.expression_list_always_start_on_new_line = true;\n+            settings.ostr << (settings.one_line ? \" (\" : \"\\n(\");\n+            FormatStateStacked frame_nested = frame;\n+            columns_list->formatImpl(settings, state, frame_nested);\n+            settings.ostr << (settings.one_line ? \")\" : \"\\n)\");\n+            frame.expression_list_always_start_on_new_line = false;\n+        }\n+\n         settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" AS \" << (settings.hilite ? hilite_none : \"\");\n         as_table_function->formatImpl(settings, state, frame);\n     }\n \n     frame.expression_list_always_start_on_new_line = true;\n \n-    if (columns_list)\n+    if (columns_list && !as_table_function)\n     {\n         settings.ostr << (settings.one_line ? \" (\" : \"\\n(\");\n         FormatStateStacked frame_nested = frame;\ndiff --git a/src/Parsers/ParserCreateQuery.cpp b/src/Parsers/ParserCreateQuery.cpp\nindex 55208ca41331..fb0fd20b4ed8 100644\n--- a/src/Parsers/ParserCreateQuery.cpp\n+++ b/src/Parsers/ParserCreateQuery.cpp\n@@ -416,7 +416,12 @@ bool ParserCreateTableQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expe\n             return false;\n \n         if (!storage_p.parse(pos, storage, expected) && !is_temporary)\n-            return false;\n+        {\n+            if (!s_as.ignore(pos, expected))\n+                return false;\n+            if (!table_function_p.parse(pos, as_table_function, expected))\n+                return false;\n+        }\n     }\n     else\n     {\ndiff --git a/src/Storages/StorageDistributed.cpp b/src/Storages/StorageDistributed.cpp\nindex b06434b63172..e8ce11eeff14 100644\n--- a/src/Storages/StorageDistributed.cpp\n+++ b/src/Storages/StorageDistributed.cpp\n@@ -362,12 +362,14 @@ StorageDistributed::StorageDistributed(\n     const ASTPtr & sharding_key_,\n     const String & storage_policy_name_,\n     const String & relative_data_path_,\n-    bool attach_)\n+    bool attach_,\n+    ClusterPtr owned_cluster_)\n     : IStorage(id_)\n     , remote_database(remote_database_)\n     , remote_table(remote_table_)\n     , global_context(std::make_unique<Context>(context_))\n     , log(&Poco::Logger::get(\"StorageDistributed (\" + id_.table_name + \")\"))\n+    , owned_cluster(std::move(owned_cluster_))\n     , cluster_name(global_context->getMacros()->expand(cluster_name_))\n     , has_sharding_key(sharding_key_)\n     , relative_data_path(relative_data_path_)\n@@ -413,39 +415,13 @@ StorageDistributed::StorageDistributed(\n     const ASTPtr & sharding_key_,\n     const String & storage_policy_name_,\n     const String & relative_data_path_,\n-    bool attach)\n-    : StorageDistributed(id_, columns_, constraints_, String{}, String{}, cluster_name_, context_, sharding_key_, storage_policy_name_, relative_data_path_, attach)\n+    bool attach,\n+    ClusterPtr owned_cluster_)\n+    : StorageDistributed(id_, columns_, constraints_, String{}, String{}, cluster_name_, context_, sharding_key_, storage_policy_name_, relative_data_path_, attach, std::move(owned_cluster_))\n {\n     remote_table_function_ptr = std::move(remote_table_function_ptr_);\n }\n \n-\n-StoragePtr StorageDistributed::createWithOwnCluster(\n-    const StorageID & table_id_,\n-    const ColumnsDescription & columns_,\n-    const String & remote_database_,       /// database on remote servers.\n-    const String & remote_table_,          /// The name of the table on the remote servers.\n-    ClusterPtr owned_cluster_,\n-    const Context & context_)\n-{\n-    auto res = create(table_id_, columns_, ConstraintsDescription{}, remote_database_, remote_table_, String{}, context_, ASTPtr(), String(), String(), false);\n-    res->owned_cluster = std::move(owned_cluster_);\n-    return res;\n-}\n-\n-\n-StoragePtr StorageDistributed::createWithOwnCluster(\n-    const StorageID & table_id_,\n-    const ColumnsDescription & columns_,\n-    ASTPtr & remote_table_function_ptr_,\n-    ClusterPtr & owned_cluster_,\n-    const Context & context_)\n-{\n-    auto res = create(table_id_, columns_, ConstraintsDescription{}, remote_table_function_ptr_, String{}, context_, ASTPtr(), String(), String(), false);\n-    res->owned_cluster = owned_cluster_;\n-    return res;\n-}\n-\n QueryProcessingStage::Enum StorageDistributed::getQueryProcessingStage(const Context &context, QueryProcessingStage::Enum to_stage, const ASTPtr & query_ptr) const\n {\n     const auto & settings = context.getSettingsRef();\ndiff --git a/src/Storages/StorageDistributed.h b/src/Storages/StorageDistributed.h\nindex 7e4e9f56ab46..dd043e5feeb2 100644\n--- a/src/Storages/StorageDistributed.h\n+++ b/src/Storages/StorageDistributed.h\n@@ -42,21 +42,6 @@ class StorageDistributed final : public ext::shared_ptr_helper<StorageDistribute\n public:\n     ~StorageDistributed() override;\n \n-    static StoragePtr createWithOwnCluster(\n-        const StorageID & table_id_,\n-        const ColumnsDescription & columns_,\n-        const String & remote_database_,       /// database on remote servers.\n-        const String & remote_table_,          /// The name of the table on the remote servers.\n-        ClusterPtr owned_cluster_,\n-        const Context & context_);\n-\n-    static StoragePtr createWithOwnCluster(\n-            const StorageID & table_id_,\n-        const ColumnsDescription & columns_,\n-        ASTPtr & remote_table_function_ptr_,     /// Table function ptr.\n-        ClusterPtr & owned_cluster_,\n-        const Context & context_);\n-\n     std::string getName() const override { return \"Distributed\"; }\n \n     bool supportsSampling() const override { return true; }\n@@ -165,7 +150,8 @@ class StorageDistributed final : public ext::shared_ptr_helper<StorageDistribute\n         const ASTPtr & sharding_key_,\n         const String & storage_policy_name_,\n         const String & relative_data_path_,\n-        bool attach_);\n+        bool attach_,\n+        ClusterPtr owned_cluster_ = {});\n \n     StorageDistributed(\n         const StorageID & id_,\n@@ -177,7 +163,8 @@ class StorageDistributed final : public ext::shared_ptr_helper<StorageDistribute\n         const ASTPtr & sharding_key_,\n         const String & storage_policy_name_,\n         const String & relative_data_path_,\n-        bool attach);\n+        bool attach,\n+        ClusterPtr owned_cluster_ = {});\n \n     String relative_data_path;\n \ndiff --git a/src/Storages/StorageFile.cpp b/src/Storages/StorageFile.cpp\nindex cc47047dc783..64fc2d97a4f0 100644\n--- a/src/Storages/StorageFile.cpp\n+++ b/src/Storages/StorageFile.cpp\n@@ -52,6 +52,7 @@ namespace ErrorCodes\n     extern const int UNKNOWN_IDENTIFIER;\n     extern const int INCORRECT_FILE_NAME;\n     extern const int FILE_DOESNT_EXIST;\n+    extern const int INCOMPATIBLE_COLUMNS;\n }\n \n namespace\n@@ -126,11 +127,33 @@ void checkCreationIsAllowed(const Context & context_global, const std::string &\n }\n }\n \n+Strings StorageFile::getPathsList(const String & table_path, const String & user_files_path, const Context & context)\n+{\n+    String user_files_absolute_path = Poco::Path(user_files_path).makeAbsolute().makeDirectory().toString();\n+    Poco::Path poco_path = Poco::Path(table_path);\n+    if (poco_path.isRelative())\n+        poco_path = Poco::Path(user_files_absolute_path, poco_path);\n+\n+    Strings paths;\n+    const String path = poco_path.absolute().toString();\n+    if (path.find_first_of(\"*?{\") == std::string::npos)\n+        paths.push_back(path);\n+    else\n+        paths = listFilesWithRegexpMatching(\"/\", path);\n+\n+    for (const auto & cur_path : paths)\n+        checkCreationIsAllowed(context, user_files_absolute_path, cur_path);\n+\n+    return paths;\n+}\n+\n StorageFile::StorageFile(int table_fd_, CommonArguments args)\n     : StorageFile(args)\n {\n     if (args.context.getApplicationType() == Context::ApplicationType::SERVER)\n         throw Exception(\"Using file descriptor as source of storage isn't allowed for server daemons\", ErrorCodes::DATABASE_ACCESS_DENIED);\n+    if (args.format_name == \"Distributed\")\n+        throw Exception(\"Distributed format is allowed only with explicit file path\", ErrorCodes::INCORRECT_FILE_NAME);\n \n     is_db_table = false;\n     use_table_fd = true;\n@@ -145,32 +168,22 @@ StorageFile::StorageFile(const std::string & table_path_, const std::string & us\n     : StorageFile(args)\n {\n     is_db_table = false;\n-    std::string user_files_absolute_path = Poco::Path(user_files_path).makeAbsolute().makeDirectory().toString();\n-    Poco::Path poco_path = Poco::Path(table_path_);\n-    if (poco_path.isRelative())\n-        poco_path = Poco::Path(user_files_absolute_path, poco_path);\n-\n-    const std::string path = poco_path.absolute().toString();\n-    if (path.find_first_of(\"*?{\") == std::string::npos)\n-        paths.push_back(path);\n-    else\n-        paths = listFilesWithRegexpMatching(\"/\", path);\n-\n-    for (const auto & cur_path : paths)\n-        checkCreationIsAllowed(args.context, user_files_absolute_path, cur_path);\n+    paths = getPathsList(table_path_, user_files_path, args.context);\n \n     if (args.format_name == \"Distributed\")\n     {\n-        if (!paths.empty())\n-        {\n-            auto & first_path = paths[0];\n-            Block header = StorageDistributedDirectoryMonitor::createStreamFromFile(first_path)->getHeader();\n-\n-\n-            StorageInMemoryMetadata storage_metadata;\n-            storage_metadata.setColumns(ColumnsDescription(header.getNamesAndTypesList()));\n-            setInMemoryMetadata(storage_metadata);\n-        }\n+        if (paths.empty())\n+            throw Exception(\"Cannot get table structure from file, because no files match specified name\", ErrorCodes::INCORRECT_FILE_NAME);\n+\n+        auto & first_path = paths[0];\n+        Block header = StorageDistributedDirectoryMonitor::createStreamFromFile(first_path)->getHeader();\n+\n+        StorageInMemoryMetadata storage_metadata;\n+        auto columns = ColumnsDescription(header.getNamesAndTypesList());\n+        if (!args.columns.empty() && columns != args.columns)\n+            throw Exception(\"Table structure and file structure are different\", ErrorCodes::INCOMPATIBLE_COLUMNS);\n+        storage_metadata.setColumns(columns);\n+        setInMemoryMetadata(storage_metadata);\n     }\n }\n \n@@ -179,6 +192,8 @@ StorageFile::StorageFile(const std::string & relative_table_dir_path, CommonArgu\n {\n     if (relative_table_dir_path.empty())\n         throw Exception(\"Storage \" + getName() + \" requires data path\", ErrorCodes::INCORRECT_FILE_NAME);\n+    if (args.format_name == \"Distributed\")\n+        throw Exception(\"Distributed format is allowed only with explicit file path\", ErrorCodes::INCORRECT_FILE_NAME);\n \n     String table_dir_path = base_path + relative_table_dir_path + \"/\";\n     Poco::File(table_dir_path).createDirectories();\ndiff --git a/src/Storages/StorageFile.h b/src/Storages/StorageFile.h\nindex ea70dcd5311d..f331538b4c79 100644\n--- a/src/Storages/StorageFile.h\n+++ b/src/Storages/StorageFile.h\n@@ -60,6 +60,8 @@ class StorageFile final : public ext::shared_ptr_helper<StorageFile>, public ISt\n \n     NamesAndTypesList getVirtuals() const override;\n \n+    static Strings getPathsList(const String & table_path, const String & user_files_path, const Context & context);\n+\n protected:\n     friend class StorageFileSource;\n     friend class StorageFileBlockOutputStream;\ndiff --git a/src/Storages/StorageMaterializeMySQL.cpp b/src/Storages/StorageMaterializeMySQL.cpp\nindex 7d908736bdc1..68981280619a 100644\n--- a/src/Storages/StorageMaterializeMySQL.cpp\n+++ b/src/Storages/StorageMaterializeMySQL.cpp\n@@ -23,7 +23,7 @@ namespace DB\n {\n \n StorageMaterializeMySQL::StorageMaterializeMySQL(const StoragePtr & nested_storage_, const DatabaseMaterializeMySQL * database_)\n-    : IStorage(nested_storage_->getStorageID()), nested_storage(nested_storage_), database(database_)\n+    : StorageProxy(nested_storage_->getStorageID()), nested_storage(nested_storage_), database(database_)\n {\n     auto nested_memory_metadata = nested_storage->getInMemoryMetadata();\n     StorageInMemoryMetadata in_memory_metadata;\ndiff --git a/src/Storages/StorageMaterializeMySQL.h b/src/Storages/StorageMaterializeMySQL.h\nindex 4278ce64bd73..cadafaf778cf 100644\n--- a/src/Storages/StorageMaterializeMySQL.h\n+++ b/src/Storages/StorageMaterializeMySQL.h\n@@ -4,30 +4,40 @@\n \n #if USE_MYSQL\n \n-#include <Storages/IStorage.h>\n+#include <Storages/StorageProxy.h>\n #include <Databases/MySQL/DatabaseMaterializeMySQL.h>\n \n namespace DB\n {\n \n-class StorageMaterializeMySQL final : public ext::shared_ptr_helper<StorageMaterializeMySQL>, public IStorage\n+namespace ErrorCodes\n+{\n+    extern const int NOT_IMPLEMENTED;\n+}\n+\n+class StorageMaterializeMySQL final : public ext::shared_ptr_helper<StorageMaterializeMySQL>, public StorageProxy\n {\n     friend struct ext::shared_ptr_helper<StorageMaterializeMySQL>;\n public:\n     String getName() const override { return \"MaterializeMySQL\"; }\n \n-    bool supportsFinal() const override { return nested_storage->supportsFinal(); }\n-    bool supportsSampling() const override { return nested_storage->supportsSampling(); }\n-\n     StorageMaterializeMySQL(const StoragePtr & nested_storage_, const DatabaseMaterializeMySQL * database_);\n \n     Pipe read(\n         const Names & column_names, const StorageMetadataPtr & metadata_snapshot, const SelectQueryInfo & query_info,\n         const Context & context, QueryProcessingStage::Enum processed_stage, size_t max_block_size, unsigned num_streams) override;\n \n+    BlockOutputStreamPtr write(const ASTPtr &, const StorageMetadataPtr &, const Context &) override { throwNotAllowed(); }\n+\n     NamesAndTypesList getVirtuals() const override;\n \n private:\n+    StoragePtr getNested() const override { return nested_storage; }\n+    [[noreturn]] void throwNotAllowed() const\n+    {\n+        throw Exception(\"This method is not allowed for MaterializeMySQ\", ErrorCodes::NOT_IMPLEMENTED);\n+    }\n+\n     StoragePtr nested_storage;\n     const DatabaseMaterializeMySQL * database;\n };\ndiff --git a/src/Storages/StorageMerge.cpp b/src/Storages/StorageMerge.cpp\nindex bade0810320d..46dd060e76d1 100644\n--- a/src/Storages/StorageMerge.cpp\n+++ b/src/Storages/StorageMerge.cpp\n@@ -9,6 +9,7 @@\n #include <Interpreters/ExpressionActions.h>\n #include <Interpreters/evaluateConstantExpression.h>\n #include <Interpreters/InterpreterSelectQuery.h>\n+#include <Interpreters/getHeaderForProcessingStage.h>\n #include <Parsers/ASTSelectQuery.h>\n #include <Parsers/ASTLiteral.h>\n #include <Parsers/ASTIdentifier.h>\n@@ -42,23 +43,6 @@ namespace ErrorCodes\n namespace\n {\n \n-/// Rewrite original query removing joined tables from it\n-bool removeJoin(ASTSelectQuery & select)\n-{\n-    const auto & tables = select.tables();\n-    if (!tables || tables->children.size() < 2)\n-        return false;\n-\n-    const auto & joined_table = tables->children[1]->as<ASTTablesInSelectQueryElement &>();\n-    if (!joined_table.table_join)\n-        return false;\n-\n-    /// The most simple temporary solution: leave only the first table in query.\n-    /// TODO: we also need to remove joined columns and related functions (taking in account aliases if any).\n-    tables->children.resize(1);\n-    return true;\n-}\n-\n void modifySelect(ASTSelectQuery & select, const TreeRewriterResult & rewriter_result)\n {\n     if (removeJoin(select))\n@@ -83,7 +67,6 @@ void modifySelect(ASTSelectQuery & select, const TreeRewriterResult & rewriter_r\n \n }\n \n-\n StorageMerge::StorageMerge(\n     const StorageID & table_id_,\n     const ColumnsDescription & columns_,\n@@ -203,7 +186,7 @@ Pipe StorageMerge::read(\n     modified_context->setSetting(\"optimize_move_to_prewhere\", false);\n \n     /// What will be result structure depending on query processed stage in source tables?\n-    Block header = getQueryHeader(column_names, metadata_snapshot, query_info, context, processed_stage);\n+    Block header = getHeaderForProcessingStage(*this, column_names, metadata_snapshot, query_info, context, processed_stage);\n \n     /** First we make list of selected tables to find out its size.\n       * This is necessary to correctly pass the recommended number of threads to each table.\n@@ -456,42 +439,6 @@ void StorageMerge::alter(\n     setInMemoryMetadata(storage_metadata);\n }\n \n-Block StorageMerge::getQueryHeader(\n-    const Names & column_names,\n-    const StorageMetadataPtr & metadata_snapshot,\n-    const SelectQueryInfo & query_info,\n-    const Context & context,\n-    QueryProcessingStage::Enum processed_stage)\n-{\n-    switch (processed_stage)\n-    {\n-        case QueryProcessingStage::FetchColumns:\n-        {\n-            Block header = metadata_snapshot->getSampleBlockForColumns(column_names, getVirtuals(), getStorageID());\n-            if (query_info.prewhere_info)\n-            {\n-                query_info.prewhere_info->prewhere_actions->execute(header);\n-                if (query_info.prewhere_info->remove_prewhere_column)\n-                    header.erase(query_info.prewhere_info->prewhere_column_name);\n-            }\n-            return header;\n-        }\n-        case QueryProcessingStage::WithMergeableState:\n-        case QueryProcessingStage::Complete:\n-        case QueryProcessingStage::WithMergeableStateAfterAggregation:\n-        case QueryProcessingStage::MAX:\n-        {\n-            auto query = query_info.query->clone();\n-            removeJoin(*query->as<ASTSelectQuery>());\n-\n-            auto stream = std::make_shared<OneBlockInputStream>(\n-                metadata_snapshot->getSampleBlockForColumns(column_names, getVirtuals(), getStorageID()));\n-            return InterpreterSelectQuery(query, context, stream, SelectQueryOptions(processed_stage).analyze()).getSampleBlock();\n-        }\n-    }\n-    throw Exception(\"Logical Error: unknown processed stage.\", ErrorCodes::LOGICAL_ERROR);\n-}\n-\n void StorageMerge::convertingSourceStream(\n     const Block & header,\n     const StorageMetadataPtr & metadata_snapshot,\ndiff --git a/src/Storages/StorageMerge.h b/src/Storages/StorageMerge.h\nindex 5e2d56d18c05..63d803cedf1f 100644\n--- a/src/Storages/StorageMerge.h\n+++ b/src/Storages/StorageMerge.h\n@@ -75,13 +75,6 @@ class StorageMerge final : public ext::shared_ptr_helper<StorageMerge>, public I\n         const String & table_name_regexp_,\n         const Context & context_);\n \n-    Block getQueryHeader(\n-        const Names & column_names,\n-        const StorageMetadataPtr & metadata_snapshot,\n-        const SelectQueryInfo & query_info,\n-        const Context & context,\n-        QueryProcessingStage::Enum processed_stage);\n-\n     Pipe createSources(\n         const StorageMetadataPtr & metadata_snapshot,\n         const SelectQueryInfo & query_info,\ndiff --git a/src/Storages/StorageProxy.h b/src/Storages/StorageProxy.h\nnew file mode 100644\nindex 000000000000..7b010476b22f\n--- /dev/null\n+++ b/src/Storages/StorageProxy.h\n@@ -0,0 +1,158 @@\n+#pragma once\n+\n+#include <Storages/IStorage.h>\n+#include <Processors/Pipe.h>\n+\n+\n+namespace DB\n+{\n+\n+class StorageProxy : public IStorage\n+{\n+public:\n+\n+    StorageProxy(const StorageID & table_id_) : IStorage(table_id_) {}\n+\n+    virtual StoragePtr getNested() const = 0;\n+\n+    String getName() const override { return \"StorageProxy\"; }\n+\n+    bool isRemote() const override { return getNested()->isRemote(); }\n+    bool isView() const override { return getNested()->isView(); }\n+    bool supportsSampling() const override { return getNested()->supportsSampling(); }\n+    bool supportsFinal() const override { return getNested()->supportsFinal(); }\n+    bool supportsPrewhere() const override { return getNested()->supportsPrewhere(); }\n+    bool supportsReplication() const override { return getNested()->supportsReplication(); }\n+    bool supportsParallelInsert() const override { return getNested()->supportsParallelInsert(); }\n+    bool supportsDeduplication() const override { return getNested()->supportsDeduplication(); }\n+    bool supportsSettings() const override { return getNested()->supportsSettings(); }\n+    bool noPushingToViews() const override { return getNested()->noPushingToViews(); }\n+    bool hasEvenlyDistributedRead() const override { return getNested()->hasEvenlyDistributedRead(); }\n+\n+    ColumnSizeByName getColumnSizes() const override { return getNested()->getColumnSizes(); }\n+    NamesAndTypesList getVirtuals() const override { return getNested()->getVirtuals(); }\n+    QueryProcessingStage::Enum getQueryProcessingStage(const Context & context, QueryProcessingStage::Enum to_stage, const ASTPtr & ast) const override\n+    {\n+        return getNested()->getQueryProcessingStage(context, to_stage, ast);\n+    }\n+\n+    BlockInputStreams watch(\n+        const Names & column_names,\n+        const SelectQueryInfo & query_info,\n+        const Context & context,\n+        QueryProcessingStage::Enum & processed_stage,\n+        size_t max_block_size,\n+        unsigned num_streams) override\n+    {\n+        return getNested()->watch(column_names, query_info, context, processed_stage, max_block_size, num_streams);\n+    }\n+\n+    Pipe read(\n+        const Names & column_names,\n+        const StorageMetadataPtr & metadata_snapshot,\n+        const SelectQueryInfo & query_info,\n+        const Context & context,\n+        QueryProcessingStage::Enum processed_stage,\n+        size_t max_block_size,\n+        unsigned num_streams) override\n+    {\n+        return getNested()->read(column_names, metadata_snapshot, query_info, context, processed_stage, max_block_size, num_streams);\n+    }\n+\n+    BlockOutputStreamPtr write(\n+        const ASTPtr & query,\n+        const StorageMetadataPtr & metadata_snapshot,\n+        const Context & context) override\n+    {\n+        return getNested()->write(query, metadata_snapshot, context);\n+    }\n+\n+    void drop() override { getNested()->drop(); }\n+\n+    void truncate(\n+        const ASTPtr & query,\n+        const StorageMetadataPtr & metadata_snapshot,\n+        const Context & context,\n+        TableExclusiveLockHolder & lock) override\n+    {\n+        getNested()->truncate(query, metadata_snapshot, context, lock);\n+    }\n+\n+    void rename(const String & new_path_to_table_data, const StorageID & new_table_id) override\n+    {\n+        getNested()->rename(new_path_to_table_data, new_table_id);\n+        IStorage::renameInMemory(new_table_id);\n+    }\n+\n+    void renameInMemory(const StorageID & new_table_id) override\n+    {\n+        getNested()->renameInMemory(new_table_id);\n+        IStorage::renameInMemory(new_table_id);\n+    }\n+\n+    void alter(const AlterCommands & params, const Context & context, TableLockHolder & alter_lock_holder) override\n+    {\n+        getNested()->alter(params, context, alter_lock_holder);\n+        IStorage::setInMemoryMetadata(getNested()->getInMemoryMetadata());\n+    }\n+\n+    void checkAlterIsPossible(const AlterCommands & commands, const Settings & settings) const override\n+    {\n+        getNested()->checkAlterIsPossible(commands, settings);\n+    }\n+\n+    Pipe alterPartition(\n+            const ASTPtr & query,\n+            const StorageMetadataPtr & metadata_snapshot,\n+            const PartitionCommands & commands,\n+            const Context & context) override\n+    {\n+        return getNested()->alterPartition(query, metadata_snapshot, commands, context);\n+    }\n+\n+    void checkAlterPartitionIsPossible(const PartitionCommands & commands, const StorageMetadataPtr & metadata_snapshot, const Settings & settings) const override\n+    {\n+        getNested()->checkAlterPartitionIsPossible(commands, metadata_snapshot, settings);\n+    }\n+\n+    bool optimize(\n+            const ASTPtr & query,\n+            const StorageMetadataPtr & metadata_snapshot,\n+            const ASTPtr & partition,\n+            bool final,\n+            bool deduplicate,\n+            const Context & context) override\n+    {\n+        return getNested()->optimize(query, metadata_snapshot, partition, final, deduplicate, context);\n+    }\n+\n+    void mutate(const MutationCommands & commands, const Context & context) override { getNested()->mutate(commands, context); }\n+\n+    CancellationCode killMutation(const String & mutation_id) override { return getNested()->killMutation(mutation_id); }\n+\n+    void startup() override { getNested()->startup(); }\n+    void shutdown() override { getNested()->shutdown(); }\n+\n+    ActionLock getActionLock(StorageActionBlockType action_type) override { return getNested()->getActionLock(action_type); }\n+\n+    bool supportsIndexForIn() const override { return getNested()->supportsIndexForIn(); }\n+    bool mayBenefitFromIndexForIn(const ASTPtr & left_in_operand, const Context & query_context, const StorageMetadataPtr & metadata_snapshot) const override\n+    {\n+        return getNested()->mayBenefitFromIndexForIn(left_in_operand, query_context, metadata_snapshot);\n+    }\n+\n+    CheckResults checkData(const ASTPtr & query , const Context & context) override { return getNested()->checkData(query, context); }\n+    void checkTableCanBeDropped() const override { getNested()->checkTableCanBeDropped(); }\n+    void checkPartitionCanBeDropped(const ASTPtr & partition) override { getNested()->checkPartitionCanBeDropped(partition); }\n+    Strings getDataPaths() const override { return getNested()->getDataPaths(); }\n+    StoragePolicyPtr getStoragePolicy() const override { return getNested()->getStoragePolicy(); }\n+    std::optional<UInt64> totalRows() const override { return getNested()->totalRows(); }\n+    std::optional<UInt64> totalBytes() const override { return getNested()->totalBytes(); }\n+    std::optional<UInt64> lifetimeRows() const override { return getNested()->lifetimeRows(); }\n+    std::optional<UInt64> lifetimeBytes() const override { return getNested()->lifetimeBytes(); }\n+\n+};\n+\n+\n+}\n+\ndiff --git a/src/Storages/StorageTableFunction.h b/src/Storages/StorageTableFunction.h\nnew file mode 100644\nindex 000000000000..9b698cb39540\n--- /dev/null\n+++ b/src/Storages/StorageTableFunction.h\n@@ -0,0 +1,137 @@\n+#pragma once\n+#include <Storages/IStorage.h>\n+#include <TableFunctions/ITableFunction.h>\n+#include <Processors/Pipe.h>\n+#include <Storages/StorageProxy.h>\n+#include <Common/CurrentThread.h>\n+#include <Processors/Transforms/ConvertingTransform.h>\n+#include <Interpreters/getHeaderForProcessingStage.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int INCOMPATIBLE_COLUMNS;\n+}\n+\n+using GetNestedStorageFunc = std::function<StoragePtr()>;\n+\n+/// Lazily creates underlying storage.\n+/// Adds ConversionTransform in case of structure mismatch.\n+class StorageTableFunctionProxy final : public StorageProxy\n+{\n+public:\n+    StorageTableFunctionProxy(const StorageID & table_id_, GetNestedStorageFunc get_nested_,\n+            ColumnsDescription cached_columns, bool add_conversion_ = true)\n+    : StorageProxy(table_id_), get_nested(std::move(get_nested_)), add_conversion(add_conversion_)\n+    {\n+        StorageInMemoryMetadata cached_metadata;\n+        cached_metadata.setColumns(std::move(cached_columns));\n+        setInMemoryMetadata(cached_metadata);\n+    }\n+\n+    StoragePtr getNested() const override\n+    {\n+        std::lock_guard lock{nested_mutex};\n+        if (nested)\n+            return nested;\n+\n+        auto nested_storage = get_nested();\n+        nested_storage->startup();\n+        nested_storage->renameInMemory(getStorageID());\n+        nested = nested_storage;\n+        get_nested = {};\n+        return nested;\n+    }\n+\n+    String getName() const override\n+    {\n+        std::lock_guard lock{nested_mutex};\n+        if (nested)\n+            return nested->getName();\n+        return StorageProxy::getName();\n+    }\n+\n+    void startup() override { }\n+    void shutdown() override\n+    {\n+        std::lock_guard lock{nested_mutex};\n+        if (nested)\n+            nested->shutdown();\n+    }\n+\n+    void drop() override\n+    {\n+        std::lock_guard lock{nested_mutex};\n+        if (nested)\n+            nested->drop();\n+    }\n+\n+    Pipe read(\n+            const Names & column_names,\n+            const StorageMetadataPtr & metadata_snapshot,\n+            const SelectQueryInfo & query_info,\n+            const Context & context,\n+            QueryProcessingStage::Enum processed_stage,\n+            size_t max_block_size,\n+            unsigned num_streams) override\n+    {\n+        String cnames;\n+        for (const auto & c : column_names)\n+            cnames += c + \" \";\n+        auto storage = getNested();\n+        auto nested_metadata = storage->getInMemoryMetadataPtr();\n+        auto pipe = storage->read(column_names, nested_metadata, query_info, context,\n+                                  processed_stage, max_block_size, num_streams);\n+        if (!pipe.empty() && add_conversion)\n+        {\n+            auto to_header = getHeaderForProcessingStage(*this, column_names, metadata_snapshot,\n+                                                         query_info, context, processed_stage);\n+            pipe.addSimpleTransform([&](const Block & header)\n+            {\n+                return std::make_shared<ConvertingTransform>(\n+                       header,\n+                       to_header,\n+                       ConvertingTransform::MatchColumnsMode::Name);\n+            });\n+        }\n+        return pipe;\n+    }\n+\n+    BlockOutputStreamPtr write(\n+            const ASTPtr & query,\n+            const StorageMetadataPtr & metadata_snapshot,\n+            const Context & context) override\n+    {\n+        auto storage = getNested();\n+        auto cached_structure = metadata_snapshot->getSampleBlock();\n+        auto actual_structure = storage->getInMemoryMetadataPtr()->getSampleBlock();\n+        if (!blocksHaveEqualStructure(actual_structure, cached_structure) && add_conversion)\n+        {\n+            throw Exception(\"Source storage and table function have different structure\", ErrorCodes::INCOMPATIBLE_COLUMNS);\n+        }\n+        return storage->write(query, metadata_snapshot, context);\n+    }\n+\n+    void renameInMemory(const StorageID & new_table_id) override\n+    {\n+        std::lock_guard lock{nested_mutex};\n+        if (nested)\n+            StorageProxy::renameInMemory(new_table_id);\n+        else\n+            IStorage::renameInMemory(new_table_id);\n+    }\n+\n+    bool isView() const override { return false; }\n+    void checkTableCanBeDropped() const override {}\n+\n+private:\n+    mutable std::mutex nested_mutex;\n+    mutable GetNestedStorageFunc get_nested;\n+    mutable StoragePtr nested;\n+    const bool add_conversion;\n+};\n+\n+}\ndiff --git a/src/Storages/StorageXDBC.h b/src/Storages/StorageXDBC.h\nindex 508edf226841..7f93cbcd3200 100644\n--- a/src/Storages/StorageXDBC.h\n+++ b/src/Storages/StorageXDBC.h\n@@ -34,6 +34,7 @@ class StorageXDBC : public IStorageURLBase\n \n     BlockOutputStreamPtr write(const ASTPtr & query, const StorageMetadataPtr & /*metadata_snapshot*/, const Context & context) override;\n \n+    std::string getName() const override;\n private:\n \n     BridgeHelperPtr bridge_helper;\n@@ -61,8 +62,6 @@ class StorageXDBC : public IStorageURLBase\n         size_t max_block_size) const override;\n \n     Block getHeaderBlock(const Names & column_names, const StorageMetadataPtr & metadata_snapshot) const override;\n-\n-    std::string getName() const override;\n };\n \n }\ndiff --git a/src/Storages/getStructureOfRemoteTable.cpp b/src/Storages/getStructureOfRemoteTable.cpp\nindex 7dfee90588ab..ea1be8223b2f 100644\n--- a/src/Storages/getStructureOfRemoteTable.cpp\n+++ b/src/Storages/getStructureOfRemoteTable.cpp\n@@ -73,10 +73,8 @@ ColumnsDescription getStructureOfRemoteTableInShard(\n     {\n         if (shard_info.isLocal())\n         {\n-            const auto * table_function = table_func_ptr->as<ASTFunction>();\n-            TableFunctionPtr table_function_ptr = TableFunctionFactory::instance().get(table_function->name, context);\n-            auto storage_ptr = table_function_ptr->execute(table_func_ptr, context, table_function_ptr->getName());\n-            return storage_ptr->getInMemoryMetadataPtr()->getColumns();\n+            TableFunctionPtr table_function_ptr = TableFunctionFactory::instance().get(table_func_ptr, context);\n+            return table_function_ptr->getActualTableStructure(context);\n         }\n \n         auto table_func_name = queryToString(table_func_ptr);\ndiff --git a/src/TableFunctions/CMakeLists.txt b/src/TableFunctions/CMakeLists.txt\nindex 33e900231e5c..8e9eedadf532 100644\n--- a/src/TableFunctions/CMakeLists.txt\n+++ b/src/TableFunctions/CMakeLists.txt\n@@ -6,3 +6,4 @@ list(REMOVE_ITEM clickhouse_table_functions_headers ITableFunction.h TableFuncti\n \n add_library(clickhouse_table_functions ${clickhouse_table_functions_sources})\n target_link_libraries(clickhouse_table_functions PRIVATE clickhouse_parsers clickhouse_storages_system dbms)\n+\ndiff --git a/src/TableFunctions/ITableFunction.cpp b/src/TableFunctions/ITableFunction.cpp\nindex 6a784c062dab..804a5b232ecb 100644\n--- a/src/TableFunctions/ITableFunction.cpp\n+++ b/src/TableFunctions/ITableFunction.cpp\n@@ -1,6 +1,7 @@\n #include <TableFunctions/ITableFunction.h>\n #include <Interpreters/Context.h>\n #include <Storages/StorageFactory.h>\n+#include <Storages/StorageTableFunction.h>\n #include <Access/AccessFlags.h>\n #include <Common/ProfileEvents.h>\n \n@@ -13,11 +14,23 @@ namespace ProfileEvents\n namespace DB\n {\n \n-StoragePtr ITableFunction::execute(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const\n+StoragePtr ITableFunction::execute(const ASTPtr & ast_function, const Context & context, const std::string & table_name,\n+                                   ColumnsDescription cached_columns) const\n {\n     ProfileEvents::increment(ProfileEvents::TableFunctionExecute);\n     context.checkAccess(AccessType::CREATE_TEMPORARY_TABLE | StorageFactory::instance().getSourceAccessType(getStorageTypeName()));\n-    return executeImpl(ast_function, context, table_name);\n+\n+    if (cached_columns.empty() || (hasStaticStructure() && cached_columns == getActualTableStructure(context)))\n+        return executeImpl(ast_function, context, table_name, std::move(cached_columns));\n+\n+    auto get_storage = [=, tf = shared_from_this()]() -> StoragePtr\n+    {\n+        return tf->executeImpl(ast_function, context, table_name, cached_columns);\n+    };\n+\n+    /// It will request actual table structure and create underlying storage lazily\n+    return std::make_shared<StorageTableFunctionProxy>(StorageID(getDatabaseName(), table_name), std::move(get_storage),\n+                                                       std::move(cached_columns), needStructureConversion());\n }\n \n }\ndiff --git a/src/TableFunctions/ITableFunction.h b/src/TableFunctions/ITableFunction.h\nindex 0bbd7e787a5e..4a73adbdf803 100644\n--- a/src/TableFunctions/ITableFunction.h\n+++ b/src/TableFunctions/ITableFunction.h\n@@ -2,6 +2,7 @@\n \n #include <Parsers/IAST_fwd.h>\n #include <Storages/IStorage_fwd.h>\n+#include <Storages/ColumnsDescription.h>\n \n #include <memory>\n #include <string>\n@@ -21,9 +22,18 @@ class Context;\n   * Example:\n   * SELECT count() FROM remote('example01-01-1', merge, hits)\n   * - go to `example01-01-1`, in `merge` database, `hits` table.\n+  *\n+  *\n+  * When creating table AS table_function(...) we probably don't know structure of the table\n+  * and have to request if from remote server, because structure is required to create a Storage.\n+  * To avoid failures on server startup, we write obtained structure to metadata file.\n+  * So, table function may have two different columns lists:\n+  *  - cached_columns written to metadata\n+  *  - the list returned from getActualTableStructure(...)\n+  * See StorageTableFunctionProxy.\n   */\n \n-class ITableFunction\n+class ITableFunction : public std::enable_shared_from_this<ITableFunction>\n {\n public:\n     static inline std::string getDatabaseName() { return \"_table_function\"; }\n@@ -31,13 +41,24 @@ class ITableFunction\n     /// Get the main function name.\n     virtual std::string getName() const = 0;\n \n+    /// Returns true if we always know table structure when executing table function\n+    /// (e.g. structure is specified in table function arguments)\n+    virtual bool hasStaticStructure() const { return false; }\n+    /// Returns false if storage returned by table function supports type conversion (e.g. StorageDistributed)\n+    virtual bool needStructureConversion() const { return true; }\n+\n+    virtual void parseArguments(const ASTPtr & /*ast_function*/, const Context & /*context*/) {}\n+\n+    /// Returns actual table structure probably requested from remote server, may fail\n+    virtual ColumnsDescription getActualTableStructure(const Context & /*context*/) const = 0;\n+\n     /// Create storage according to the query.\n-    StoragePtr execute(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const;\n+    StoragePtr execute(const ASTPtr & ast_function, const Context & context, const std::string & table_name, ColumnsDescription cached_columns_ = {}) const;\n \n     virtual ~ITableFunction() {}\n \n private:\n-    virtual StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const = 0;\n+    virtual StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name, ColumnsDescription cached_columns) const = 0;\n     virtual const char * getStorageTypeName() const = 0;\n };\n \ndiff --git a/src/TableFunctions/ITableFunctionFileLike.cpp b/src/TableFunctions/ITableFunctionFileLike.cpp\nindex 46a64cef7850..f876da02fd18 100644\n--- a/src/TableFunctions/ITableFunctionFileLike.cpp\n+++ b/src/TableFunctions/ITableFunctionFileLike.cpp\n@@ -9,11 +9,12 @@\n #include <Common/typeid_cast.h>\n \n #include <Storages/StorageFile.h>\n+#include <Storages/Distributed/DirectoryMonitor.h>\n+#include <DataStreams/IBlockInputStream.h>\n \n #include <Interpreters/Context.h>\n #include <Interpreters/evaluateConstantExpression.h>\n \n-\n namespace DB\n {\n \n@@ -21,9 +22,10 @@ namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+    extern const int INCORRECT_FILE_NAME;\n }\n \n-StoragePtr ITableFunctionFileLike::executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const\n+void ITableFunctionFileLike::parseArguments(const ASTPtr & ast_function, const Context & context)\n {\n     /// Parse args\n     ASTs & args_func = ast_function->children;\n@@ -39,8 +41,8 @@ StoragePtr ITableFunctionFileLike::executeImpl(const ASTPtr & ast_function, cons\n     for (auto & arg : args)\n         arg = evaluateConstantExpressionOrIdentifierAsLiteral(arg, context);\n \n-    std::string filename = args[0]->as<ASTLiteral &>().value.safeGet<String>();\n-    std::string format = args[1]->as<ASTLiteral &>().value.safeGet<String>();\n+    filename = args[0]->as<ASTLiteral &>().value.safeGet<String>();\n+    format = args[1]->as<ASTLiteral &>().value.safeGet<String>();\n \n     if (args.size() == 2 && getName() == \"file\")\n     {\n@@ -51,24 +53,33 @@ StoragePtr ITableFunctionFileLike::executeImpl(const ASTPtr & ast_function, cons\n         throw Exception(\"Table function '\" + getName() + \"' requires 3 or 4 arguments: filename, format, structure and compression method (default auto).\",\n             ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n-    ColumnsDescription columns;\n-    std::string compression_method = \"auto\";\n-\n     if (args.size() > 2)\n-    {\n-        auto structure = args[2]->as<ASTLiteral &>().value.safeGet<String>();\n-        columns = parseColumnsListFromString(structure, context);\n-    }\n+        structure = args[2]->as<ASTLiteral &>().value.safeGet<String>();\n \n     if (args.size() == 4)\n         compression_method = args[3]->as<ASTLiteral &>().value.safeGet<String>();\n+}\n \n-    /// Create table\n+StoragePtr ITableFunctionFileLike::executeImpl(const ASTPtr & /*ast_function*/, const Context & context, const std::string & table_name, ColumnsDescription /*cached_columns*/) const\n+{\n+    auto columns = getActualTableStructure(context);\n     StoragePtr storage = getStorage(filename, format, columns, const_cast<Context &>(context), table_name, compression_method);\n-\n     storage->startup();\n-\n     return storage;\n }\n \n+ColumnsDescription ITableFunctionFileLike::getActualTableStructure(const Context & context) const\n+{\n+    if (structure.empty())\n+    {\n+        assert(getName() == \"file\" && format == \"Distributed\");\n+        Strings paths = StorageFile::getPathsList(filename, context.getUserFilesPath(), context);\n+        if (paths.empty())\n+            throw Exception(\"Cannot get table structure from file, because no files match specified name\", ErrorCodes::INCORRECT_FILE_NAME);\n+        auto read_stream = StorageDistributedDirectoryMonitor::createStreamFromFile(paths[0]);\n+        return ColumnsDescription{read_stream->getHeader().getNamesAndTypesList()};\n+    }\n+    return parseColumnsListFromString(structure, context);\n+}\n+\n }\ndiff --git a/src/TableFunctions/ITableFunctionFileLike.h b/src/TableFunctions/ITableFunctionFileLike.h\nindex 101f4104cb8a..f1c648ac0aa9 100644\n--- a/src/TableFunctions/ITableFunctionFileLike.h\n+++ b/src/TableFunctions/ITableFunctionFileLike.h\n@@ -13,8 +13,21 @@ class Context;\n class ITableFunctionFileLike : public ITableFunction\n {\n private:\n-    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const override;\n+    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name, ColumnsDescription cached_columns) const override;\n+\n     virtual StoragePtr getStorage(\n-        const String & source, const String & format, const ColumnsDescription & columns, Context & global_context, const std::string & table_name, const String & compression_method) const = 0;\n+        const String & source, const String & format, const ColumnsDescription & columns, Context & global_context,\n+        const std::string & table_name, const String & compression_method) const = 0;\n+\n+    ColumnsDescription getActualTableStructure(const Context & context) const override;\n+\n+    void parseArguments(const ASTPtr & ast_function, const Context & context) override;\n+\n+    bool hasStaticStructure() const override { return true; }\n+\n+    String filename;\n+    String format;\n+    String structure;\n+    String compression_method = \"auto\";\n };\n }\ndiff --git a/src/TableFunctions/ITableFunctionXDBC.cpp b/src/TableFunctions/ITableFunctionXDBC.cpp\nindex e3b36e97525a..67d1257fe4c3 100644\n--- a/src/TableFunctions/ITableFunctionXDBC.cpp\n+++ b/src/TableFunctions/ITableFunctionXDBC.cpp\n@@ -24,11 +24,10 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n-    extern const int UNKNOWN_EXCEPTION;\n     extern const int LOGICAL_ERROR;\n }\n \n-StoragePtr ITableFunctionXDBC::executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const\n+void ITableFunctionXDBC::parseArguments(const ASTPtr & ast_function, const Context & context)\n {\n     const auto & args_func = ast_function->as<ASTFunction &>();\n \n@@ -44,10 +43,6 @@ StoragePtr ITableFunctionXDBC::executeImpl(const ASTPtr & ast_function, const Co\n     for (auto & arg : args)\n         arg = evaluateConstantExpressionOrIdentifierAsLiteral(arg, context);\n \n-    std::string connection_string;\n-    std::string schema_name;\n-    std::string remote_table_name;\n-\n     if (args.size() == 3)\n     {\n         connection_string = args[0]->as<ASTLiteral &>().value.safeGet<String>();\n@@ -60,11 +55,16 @@ StoragePtr ITableFunctionXDBC::executeImpl(const ASTPtr & ast_function, const Co\n         remote_table_name = args[1]->as<ASTLiteral &>().value.safeGet<String>();\n     }\n \n-    /* Infer external table structure */\n     /// Have to const_cast, because bridges store their commands inside context\n-    BridgeHelperPtr helper = createBridgeHelper(const_cast<Context &>(context), context.getSettingsRef().http_receive_timeout.value, connection_string);\n+    helper = createBridgeHelper(const_cast<Context &>(context), context.getSettingsRef().http_receive_timeout.value, connection_string);\n     helper->startBridgeSync();\n+}\n+\n+ColumnsDescription ITableFunctionXDBC::getActualTableStructure(const Context & context) const\n+{\n+    assert(helper);\n \n+    /* Infer external table structure */\n     Poco::URI columns_info_uri = helper->getColumnsInfoURI();\n     columns_info_uri.addQueryParameter(\"connection_string\", connection_string);\n     if (!schema_name.empty())\n@@ -73,7 +73,7 @@ StoragePtr ITableFunctionXDBC::executeImpl(const ASTPtr & ast_function, const Co\n \n     const auto use_nulls = context.getSettingsRef().external_table_functions_use_nulls;\n     columns_info_uri.addQueryParameter(\"external_table_functions_use_nulls\",\n-        Poco::NumberFormatter::format(use_nulls));\n+                                       Poco::NumberFormatter::format(use_nulls));\n \n     ReadWriteBufferFromHTTP buf(columns_info_uri, Poco::Net::HTTPRequest::HTTP_POST, {}, ConnectionTimeouts::getHTTPTimeouts(context));\n \n@@ -81,11 +81,14 @@ StoragePtr ITableFunctionXDBC::executeImpl(const ASTPtr & ast_function, const Co\n     readStringBinary(columns_info, buf);\n     NamesAndTypesList columns = NamesAndTypesList::parse(columns_info);\n \n-    auto result = std::make_shared<StorageXDBC>(StorageID(getDatabaseName(), table_name), schema_name, remote_table_name, ColumnsDescription{columns}, context, helper);\n-\n-    if (!result)\n-        throw Exception(\"Failed to instantiate storage from table function \" + getName(), ErrorCodes::UNKNOWN_EXCEPTION);\n+    return ColumnsDescription{columns};\n+}\n \n+StoragePtr ITableFunctionXDBC::executeImpl(const ASTPtr & /*ast_function*/, const Context & context, const std::string & table_name, ColumnsDescription /*cached_columns*/) const\n+{\n+    assert(helper);\n+    auto columns = getActualTableStructure(context);\n+    auto result = std::make_shared<StorageXDBC>(StorageID(getDatabaseName(), table_name), schema_name, remote_table_name, columns, context, helper);\n     result->startup();\n     return result;\n }\ndiff --git a/src/TableFunctions/ITableFunctionXDBC.h b/src/TableFunctions/ITableFunctionXDBC.h\nindex 547fda3f734d..fb0a0fd1185a 100644\n--- a/src/TableFunctions/ITableFunctionXDBC.h\n+++ b/src/TableFunctions/ITableFunctionXDBC.h\n@@ -18,12 +18,21 @@ namespace DB\n class ITableFunctionXDBC : public ITableFunction\n {\n private:\n-    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const override;\n+    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name, ColumnsDescription cached_columns) const override;\n \n     /* A factory method to create bridge helper, that will assist in remote interaction */\n     virtual BridgeHelperPtr createBridgeHelper(Context & context,\n         const Poco::Timespan & http_timeout_,\n         const std::string & connection_string_) const = 0;\n+\n+    ColumnsDescription getActualTableStructure(const Context & context) const override;\n+\n+    void parseArguments(const ASTPtr & ast_function, const Context & context) override;\n+\n+    String connection_string;\n+    String schema_name;\n+    String remote_table_name;\n+    BridgeHelperPtr helper;\n };\n \n class TableFunctionJDBC : public ITableFunctionXDBC\ndiff --git a/src/TableFunctions/TableFunctionFactory.cpp b/src/TableFunctions/TableFunctionFactory.cpp\nindex bc139edfb739..0399d83fe4d8 100644\n--- a/src/TableFunctions/TableFunctionFactory.cpp\n+++ b/src/TableFunctions/TableFunctionFactory.cpp\n@@ -3,6 +3,7 @@\n #include <Interpreters/Context.h>\n #include <Common/Exception.h>\n #include <IO/WriteHelpers.h>\n+#include <Parsers/ASTFunction.h>\n \n \n namespace DB\n@@ -28,19 +29,21 @@ void TableFunctionFactory::registerFunction(const std::string & name, Value crea\n }\n \n TableFunctionPtr TableFunctionFactory::get(\n-    const std::string & name,\n+    const ASTPtr & ast_function,\n     const Context & context) const\n {\n-    auto res = tryGet(name, context);\n+    const auto * table_function = ast_function->as<ASTFunction>();\n+    auto res = tryGet(table_function->name, context);\n     if (!res)\n     {\n-        auto hints = getHints(name);\n+        auto hints = getHints(table_function->name);\n         if (!hints.empty())\n-            throw Exception(\"Unknown table function \" + name + \". Maybe you meant: \" + toString(hints), ErrorCodes::UNKNOWN_FUNCTION);\n+            throw Exception(ErrorCodes::UNKNOWN_FUNCTION, \"Unknown table function {}. Maybe you meant: {}\", table_function->name , toString(hints));\n         else\n-            throw Exception(\"Unknown table function \" + name, ErrorCodes::UNKNOWN_FUNCTION);\n+            throw Exception(ErrorCodes::UNKNOWN_FUNCTION, \"Unknown table function {}\", table_function->name);\n     }\n \n+    res->parseArguments(ast_function, context);\n     return res;\n }\n \ndiff --git a/src/TableFunctions/TableFunctionFactory.h b/src/TableFunctions/TableFunctionFactory.h\nindex 6d0302a64ffb..820b5eb1c7ba 100644\n--- a/src/TableFunctions/TableFunctionFactory.h\n+++ b/src/TableFunctions/TableFunctionFactory.h\n@@ -41,7 +41,7 @@ class TableFunctionFactory final: private boost::noncopyable, public IFactoryWit\n     }\n \n     /// Throws an exception if not found.\n-    TableFunctionPtr get(const std::string & name, const Context & context) const;\n+    TableFunctionPtr get(const ASTPtr & ast_function, const Context & context) const;\n \n     /// Returns nullptr if not found.\n     TableFunctionPtr tryGet(const std::string & name, const Context & context) const;\ndiff --git a/src/TableFunctions/TableFunctionFile.cpp b/src/TableFunctions/TableFunctionFile.cpp\nindex 4f67f4cfd10f..39de6dce92cd 100644\n--- a/src/TableFunctions/TableFunctionFile.cpp\n+++ b/src/TableFunctions/TableFunctionFile.cpp\n@@ -9,9 +9,10 @@\n namespace DB\n {\n StoragePtr TableFunctionFile::getStorage(\n-    const String & source, const String & format, const ColumnsDescription & columns, Context & global_context, const std::string & table_name, const std::string & compression_method) const\n+    const String & source, const String & format_, const ColumnsDescription & columns, Context & global_context,\n+    const std::string & table_name, const std::string & compression_method_) const\n {\n-    StorageFile::CommonArguments args{StorageID(getDatabaseName(), table_name), format, compression_method, columns, ConstraintsDescription{}, global_context};\n+    StorageFile::CommonArguments args{StorageID(getDatabaseName(), table_name), format_, compression_method_, columns, ConstraintsDescription{}, global_context};\n \n     return StorageFile::create(source, global_context.getUserFilesPath(), args);\n }\ndiff --git a/src/TableFunctions/TableFunctionFile.h b/src/TableFunctions/TableFunctionFile.h\nindex e0d8c20ac611..91e2225a6d04 100644\n--- a/src/TableFunctions/TableFunctionFile.h\n+++ b/src/TableFunctions/TableFunctionFile.h\n@@ -23,6 +23,7 @@ class TableFunctionFile : public ITableFunctionFileLike\n \n private:\n     StoragePtr getStorage(\n-        const String & source, const String & format, const ColumnsDescription & columns, Context & global_context, const std::string & table_name, const std::string & compression_method) const override;\n+        const String & source, const String & format_, const ColumnsDescription & columns, Context & global_context,\n+        const std::string & table_name, const std::string & compression_method_) const override;\n     const char * getStorageTypeName() const override { return \"File\"; }\n };}\ndiff --git a/src/TableFunctions/TableFunctionGenerateRandom.cpp b/src/TableFunctions/TableFunctionGenerateRandom.cpp\nindex 548db38515cb..15c2c2bfa1f8 100644\n--- a/src/TableFunctions/TableFunctionGenerateRandom.cpp\n+++ b/src/TableFunctions/TableFunctionGenerateRandom.cpp\n@@ -26,7 +26,7 @@ namespace ErrorCodes\n     extern const int LOGICAL_ERROR;\n }\n \n-StoragePtr TableFunctionGenerateRandom::executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const\n+void TableFunctionGenerateRandom::parseArguments(const ASTPtr & ast_function, const Context & /*context*/)\n {\n     ASTs & args_func = ast_function->children;\n \n@@ -58,11 +58,7 @@ StoragePtr TableFunctionGenerateRandom::executeImpl(const ASTPtr & ast_function,\n     }\n \n     /// Parsing first argument as table structure and creating a sample block\n-    std::string structure = args[0]->as<const ASTLiteral &>().value.safeGet<String>();\n-\n-    UInt64 max_string_length = 10;\n-    UInt64 max_array_length = 10;\n-    std::optional<UInt64> random_seed;\n+    structure = args[0]->as<const ASTLiteral &>().value.safeGet<String>();\n \n     if (args.size() >= 2)\n     {\n@@ -76,10 +72,16 @@ StoragePtr TableFunctionGenerateRandom::executeImpl(const ASTPtr & ast_function,\n \n     if (args.size() == 4)\n         max_array_length = args[3]->as<const ASTLiteral &>().value.safeGet<UInt64>();\n+}\n \n+ColumnsDescription TableFunctionGenerateRandom::getActualTableStructure(const Context & context) const\n+{\n+    return parseColumnsListFromString(structure, context);\n+}\n \n-    ColumnsDescription columns = parseColumnsListFromString(structure, context);\n-\n+StoragePtr TableFunctionGenerateRandom::executeImpl(const ASTPtr & /*ast_function*/, const Context & context, const std::string & table_name, ColumnsDescription /*cached_columns*/) const\n+{\n+    auto columns = getActualTableStructure(context);\n     auto res = StorageGenerateRandom::create(StorageID(getDatabaseName(), table_name), columns, max_array_length, max_string_length, random_seed);\n     res->startup();\n     return res;\ndiff --git a/src/TableFunctions/TableFunctionGenerateRandom.h b/src/TableFunctions/TableFunctionGenerateRandom.h\nindex b09196087377..1d8839ba6d45 100644\n--- a/src/TableFunctions/TableFunctionGenerateRandom.h\n+++ b/src/TableFunctions/TableFunctionGenerateRandom.h\n@@ -13,9 +13,19 @@ class TableFunctionGenerateRandom : public ITableFunction\n public:\n     static constexpr auto name = \"generateRandom\";\n     std::string getName() const override { return name; }\n+    bool hasStaticStructure() const override { return true; }\n private:\n-    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const override;\n+    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name, ColumnsDescription cached_columns) const override;\n     const char * getStorageTypeName() const override { return \"GenerateRandom\"; }\n+\n+    ColumnsDescription getActualTableStructure(const Context & context) const override;\n+    void parseArguments(const ASTPtr & ast_function, const Context & context) override;\n+\n+    String structure;\n+    UInt64 max_string_length = 10;\n+    UInt64 max_array_length = 10;\n+    std::optional<UInt64> random_seed;\n+\n };\n \n \ndiff --git a/src/TableFunctions/TableFunctionHDFS.cpp b/src/TableFunctions/TableFunctionHDFS.cpp\nindex 3bd6cd3ed768..e2f227ef7b5b 100644\n--- a/src/TableFunctions/TableFunctionHDFS.cpp\n+++ b/src/TableFunctions/TableFunctionHDFS.cpp\n@@ -10,15 +10,17 @@\n namespace DB\n {\n StoragePtr TableFunctionHDFS::getStorage(\n-    const String & source, const String & format, const ColumnsDescription & columns, Context & global_context, const std::string & table_name, const String & compression_method) const\n+    const String & source, const String & format_, const ColumnsDescription & columns, Context & global_context,\n+    const std::string & table_name, const String & compression_method_) const\n {\n-    return StorageHDFS::create(source,\n+    return StorageHDFS::create(\n+        source,\n         StorageID(getDatabaseName(), table_name),\n-        format,\n+        format_,\n         columns,\n         ConstraintsDescription{},\n         global_context,\n-        compression_method);\n+        compression_method_);\n }\n \n \ndiff --git a/src/TableFunctions/TableFunctionHDFS.h b/src/TableFunctions/TableFunctionHDFS.h\nindex 5e8503b318ee..47e040f75939 100644\n--- a/src/TableFunctions/TableFunctionHDFS.h\n+++ b/src/TableFunctions/TableFunctionHDFS.h\n@@ -26,7 +26,8 @@ class TableFunctionHDFS : public ITableFunctionFileLike\n \n private:\n     StoragePtr getStorage(\n-        const String & source, const String & format, const ColumnsDescription & columns, Context & global_context, const std::string & table_name, const String & compression_method) const override;\n+        const String & source, const String & format_, const ColumnsDescription & columns, Context & global_context,\n+        const std::string & table_name, const String & compression_method_) const override;\n     const char * getStorageTypeName() const override { return \"HDFS\"; }\n };\n \ndiff --git a/src/TableFunctions/TableFunctionInput.cpp b/src/TableFunctions/TableFunctionInput.cpp\nindex 5b4a3d97ee40..41c418354344 100644\n--- a/src/TableFunctions/TableFunctionInput.cpp\n+++ b/src/TableFunctions/TableFunctionInput.cpp\n@@ -22,7 +22,7 @@ namespace ErrorCodes\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n }\n \n-StoragePtr TableFunctionInput::executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const\n+void TableFunctionInput::parseArguments(const ASTPtr & ast_function, const Context & context)\n {\n     const auto * function = ast_function->as<ASTFunction>();\n \n@@ -35,12 +35,18 @@ StoragePtr TableFunctionInput::executeImpl(const ASTPtr & ast_function, const Co\n         throw Exception(\"Table function '\" + getName() + \"' requires exactly 1 argument: structure\",\n             ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n-    String structure = evaluateConstantExpressionOrIdentifierAsLiteral(args[0], context)->as<ASTLiteral &>().value.safeGet<String>();\n-    auto columns = parseColumnsListFromString(structure, context);\n-    StoragePtr storage = StorageInput::create(StorageID(getDatabaseName(), table_name), columns);\n+    structure = evaluateConstantExpressionOrIdentifierAsLiteral(args[0], context)->as<ASTLiteral &>().value.safeGet<String>();\n+}\n \n-    storage->startup();\n+ColumnsDescription TableFunctionInput::getActualTableStructure(const Context & context) const\n+{\n+    return parseColumnsListFromString(structure, context);\n+}\n \n+StoragePtr TableFunctionInput::executeImpl(const ASTPtr & /*ast_function*/, const Context & context, const std::string & table_name, ColumnsDescription /*cached_columns*/) const\n+{\n+    auto storage = StorageInput::create(StorageID(getDatabaseName(), table_name), getActualTableStructure(context));\n+    storage->startup();\n     return storage;\n }\n \ndiff --git a/src/TableFunctions/TableFunctionInput.h b/src/TableFunctions/TableFunctionInput.h\nindex a2791533c5d8..5809d48a77c4 100644\n--- a/src/TableFunctions/TableFunctionInput.h\n+++ b/src/TableFunctions/TableFunctionInput.h\n@@ -15,10 +15,16 @@ class TableFunctionInput : public ITableFunction\n public:\n     static constexpr auto name = \"input\";\n     std::string getName() const override { return name; }\n+    bool hasStaticStructure() const override { return true; }\n \n private:\n-    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const override;\n+    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name, ColumnsDescription cached_columns) const override;\n     const char * getStorageTypeName() const override { return \"Input\"; }\n+\n+    ColumnsDescription getActualTableStructure(const Context & context) const override;\n+    void parseArguments(const ASTPtr & ast_function, const Context & context) override;\n+\n+    String structure;\n };\n \n }\ndiff --git a/src/TableFunctions/TableFunctionMerge.cpp b/src/TableFunctions/TableFunctionMerge.cpp\nindex 7c0c1fb233ff..a878909e29d9 100644\n--- a/src/TableFunctions/TableFunctionMerge.cpp\n+++ b/src/TableFunctions/TableFunctionMerge.cpp\n@@ -45,8 +45,7 @@ static NamesAndTypesList chooseColumns(const String & source_database, const Str\n     return any_table->getInMemoryMetadataPtr()->getColumns().getAllPhysical();\n }\n \n-\n-StoragePtr TableFunctionMerge::executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const\n+void TableFunctionMerge::parseArguments(const ASTPtr & ast_function, const Context & context)\n {\n     ASTs & args_func = ast_function->children;\n \n@@ -65,15 +64,24 @@ StoragePtr TableFunctionMerge::executeImpl(const ASTPtr & ast_function, const Co\n     args[0] = evaluateConstantExpressionForDatabaseName(args[0], context);\n     args[1] = evaluateConstantExpressionAsLiteral(args[1], context);\n \n-    String source_database = args[0]->as<ASTLiteral &>().value.safeGet<String>();\n-    String table_name_regexp = args[1]->as<ASTLiteral &>().value.safeGet<String>();\n+    source_database = args[0]->as<ASTLiteral &>().value.safeGet<String>();\n+    table_name_regexp = args[1]->as<ASTLiteral &>().value.safeGet<String>();\n+}\n \n+ColumnsDescription TableFunctionMerge::getActualTableStructure(const Context & context) const\n+{\n+    return ColumnsDescription{chooseColumns(source_database, table_name_regexp, context)};\n+}\n+\n+StoragePtr TableFunctionMerge::executeImpl(const ASTPtr & /*ast_function*/, const Context & context, const std::string & table_name, ColumnsDescription /*cached_columns*/) const\n+{\n     auto res = StorageMerge::create(\n         StorageID(getDatabaseName(), table_name),\n-        ColumnsDescription{chooseColumns(source_database, table_name_regexp, context)},\n+        getActualTableStructure(context),\n         source_database,\n         table_name_regexp,\n         context);\n+\n     res->startup();\n     return res;\n }\ndiff --git a/src/TableFunctions/TableFunctionMerge.h b/src/TableFunctions/TableFunctionMerge.h\nindex b11a9551d341..a9c4dd6b038d 100644\n--- a/src/TableFunctions/TableFunctionMerge.h\n+++ b/src/TableFunctions/TableFunctionMerge.h\n@@ -16,8 +16,14 @@ class TableFunctionMerge : public ITableFunction\n     static constexpr auto name = \"merge\";\n     std::string getName() const override { return name; }\n private:\n-    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const override;\n+    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name, ColumnsDescription cached_columns) const override;\n     const char * getStorageTypeName() const override { return \"Merge\"; }\n+\n+    ColumnsDescription getActualTableStructure(const Context & context) const override;\n+    void parseArguments(const ASTPtr & ast_function, const Context & context) override;\n+\n+    String source_database;\n+    String table_name_regexp;\n };\n \n \ndiff --git a/src/TableFunctions/TableFunctionMySQL.cpp b/src/TableFunctions/TableFunctionMySQL.cpp\nindex 05315d18f80b..7281ae434e5d 100644\n--- a/src/TableFunctions/TableFunctionMySQL.cpp\n+++ b/src/TableFunctions/TableFunctionMySQL.cpp\n@@ -24,8 +24,6 @@\n \n #    include <Databases/MySQL/DatabaseConnectionMySQL.h> // for fetchTablesColumnsList\n \n-#    include <mysqlxx/Pool.h>\n-\n \n namespace DB\n {\n@@ -38,8 +36,7 @@ namespace ErrorCodes\n     extern const int UNKNOWN_TABLE;\n }\n \n-\n-StoragePtr TableFunctionMySQL::executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const\n+void TableFunctionMySQL::parseArguments(const ASTPtr & ast_function, const Context & context)\n {\n     const auto & args_func = ast_function->as<ASTFunction &>();\n \n@@ -55,14 +52,12 @@ StoragePtr TableFunctionMySQL::executeImpl(const ASTPtr & ast_function, const Co\n     for (auto & arg : args)\n         arg = evaluateConstantExpressionOrIdentifierAsLiteral(arg, context);\n \n-    std::string host_port = args[0]->as<ASTLiteral &>().value.safeGet<String>();\n-    std::string remote_database_name = args[1]->as<ASTLiteral &>().value.safeGet<String>();\n-    std::string remote_table_name = args[2]->as<ASTLiteral &>().value.safeGet<String>();\n-    std::string user_name = args[3]->as<ASTLiteral &>().value.safeGet<String>();\n-    std::string password = args[4]->as<ASTLiteral &>().value.safeGet<String>();\n+    String host_port = args[0]->as<ASTLiteral &>().value.safeGet<String>();\n+    remote_database_name = args[1]->as<ASTLiteral &>().value.safeGet<String>();\n+    remote_table_name = args[2]->as<ASTLiteral &>().value.safeGet<String>();\n+    user_name = args[3]->as<ASTLiteral &>().value.safeGet<String>();\n+    password = args[4]->as<ASTLiteral &>().value.safeGet<String>();\n \n-    bool replace_query = false;\n-    std::string on_duplicate_clause;\n     if (args.size() >= 6)\n         replace_query = args[5]->as<ASTLiteral &>().value.safeGet<UInt64>() > 0;\n     if (args.size() == 7)\n@@ -74,27 +69,46 @@ StoragePtr TableFunctionMySQL::executeImpl(const ASTPtr & ast_function, const Co\n             ErrorCodes::BAD_ARGUMENTS);\n \n     /// 3306 is the default MySQL port number\n-    auto parsed_host_port = parseAddress(host_port, 3306);\n+    parsed_host_port = parseAddress(host_port, 3306);\n+}\n+\n+ColumnsDescription TableFunctionMySQL::getActualTableStructure(const Context & context) const\n+{\n+    assert(!parsed_host_port.first.empty());\n+    if (!pool)\n+        pool.emplace(remote_database_name, parsed_host_port.first, user_name, password, parsed_host_port.second);\n \n-    mysqlxx::Pool pool(remote_database_name, parsed_host_port.first, user_name, password, parsed_host_port.second);\n     const auto & settings = context.getSettingsRef();\n-    const auto tables_and_columns = fetchTablesColumnsList(pool, remote_database_name, {remote_table_name}, settings.external_table_functions_use_nulls, settings.mysql_datatypes_support_level);\n+    const auto tables_and_columns = fetchTablesColumnsList(*pool, remote_database_name, {remote_table_name}, settings.external_table_functions_use_nulls, settings.mysql_datatypes_support_level);\n \n     const auto columns = tables_and_columns.find(remote_table_name);\n     if (columns == tables_and_columns.end())\n         throw Exception(\"MySQL table \" + backQuoteIfNeed(remote_database_name) + \".\" + backQuoteIfNeed(remote_table_name) + \" doesn't exist.\", ErrorCodes::UNKNOWN_TABLE);\n \n+    return ColumnsDescription{columns->second};\n+}\n+\n+StoragePtr TableFunctionMySQL::executeImpl(const ASTPtr & /*ast_function*/, const Context & context, const std::string & table_name, ColumnsDescription /*cached_columns*/) const\n+{\n+    assert(!parsed_host_port.first.empty());\n+    if (!pool)\n+        pool.emplace(remote_database_name, parsed_host_port.first, user_name, password, parsed_host_port.second);\n+\n+    auto columns = getActualTableStructure(context);\n+\n     auto res = StorageMySQL::create(\n         StorageID(getDatabaseName(), table_name),\n-        std::move(pool),\n+        std::move(*pool),\n         remote_database_name,\n         remote_table_name,\n         replace_query,\n         on_duplicate_clause,\n-        ColumnsDescription{columns->second},\n+        columns,\n         ConstraintsDescription{},\n         context);\n \n+    pool.reset();\n+\n     res->startup();\n     return res;\n }\ndiff --git a/src/TableFunctions/TableFunctionMySQL.h b/src/TableFunctions/TableFunctionMySQL.h\nindex 850affc5887a..1fe5a4aa4aca 100644\n--- a/src/TableFunctions/TableFunctionMySQL.h\n+++ b/src/TableFunctions/TableFunctionMySQL.h\n@@ -1,6 +1,11 @@\n #pragma once\n+#if !defined(ARCADIA_BUILD)\n+#    include \"config_core.h\"\n+#endif\n \n+#if USE_MYSQL\n #include <TableFunctions/ITableFunction.h>\n+#include <mysqlxx/Pool.h>\n \n \n namespace DB\n@@ -19,8 +24,23 @@ class TableFunctionMySQL : public ITableFunction\n         return name;\n     }\n private:\n-    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const override;\n+    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name, ColumnsDescription cached_columns) const override;\n     const char * getStorageTypeName() const override { return \"MySQL\"; }\n+\n+    ColumnsDescription getActualTableStructure(const Context & context) const override;\n+    void parseArguments(const ASTPtr & ast_function, const Context & context) override;\n+\n+    std::pair<std::string, UInt16> parsed_host_port;\n+    String remote_database_name;\n+    String remote_table_name;\n+    String user_name;\n+    String password;\n+    bool replace_query = false;\n+    String on_duplicate_clause;\n+\n+    mutable std::optional<mysqlxx::Pool> pool;\n };\n \n }\n+\n+#endif\ndiff --git a/src/TableFunctions/TableFunctionNull.cpp b/src/TableFunctions/TableFunctionNull.cpp\nindex 002835540417..6abe03193949 100644\n--- a/src/TableFunctions/TableFunctionNull.cpp\n+++ b/src/TableFunctions/TableFunctionNull.cpp\n@@ -17,23 +17,30 @@ namespace ErrorCodes\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n }\n \n-StoragePtr TableFunctionNull::executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const\n+void TableFunctionNull::parseArguments(const ASTPtr & ast_function, const Context & context)\n {\n-    if (const auto * function = ast_function->as<ASTFunction>())\n-    {\n-        auto arguments = function->arguments->children;\n+    const auto * function = ast_function->as<ASTFunction>();\n+    if (!function || !function->arguments)\n+        throw Exception(\"Table function '\" + getName() + \"' requires 'structure'.\", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n-        if (arguments.size() != 1)\n-            throw Exception(\"Table function '\" + getName() + \"' requires 'structure'.\", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+    const auto & arguments = function->arguments->children;\n+    if (arguments.size() != 1)\n+        throw Exception(\"Table function '\" + getName() + \"' requires 'structure'.\", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n-        auto structure = evaluateConstantExpressionOrIdentifierAsLiteral(arguments[0], context)->as<ASTLiteral>()->value.safeGet<String>();\n-        ColumnsDescription columns = parseColumnsListFromString(structure, context);\n+    structure = evaluateConstantExpressionOrIdentifierAsLiteral(arguments[0], context)->as<ASTLiteral>()->value.safeGet<String>();\n+}\n \n-        auto res = StorageNull::create(StorageID(getDatabaseName(), table_name), columns, ConstraintsDescription());\n-        res->startup();\n-        return res;\n-    }\n-    throw Exception(\"Table function '\" + getName() + \"' requires 'structure'.\", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+ColumnsDescription TableFunctionNull::getActualTableStructure(const Context & context) const\n+{\n+    return parseColumnsListFromString(structure, context);\n+}\n+\n+StoragePtr TableFunctionNull::executeImpl(const ASTPtr & /*ast_function*/, const Context & context, const std::string & table_name, ColumnsDescription /*cached_columns*/) const\n+{\n+    auto columns = getActualTableStructure(context);\n+    auto res = StorageNull::create(StorageID(getDatabaseName(), table_name), columns, ConstraintsDescription());\n+    res->startup();\n+    return res;\n }\n \n void registerTableFunctionNull(TableFunctionFactory & factory)\ndiff --git a/src/TableFunctions/TableFunctionNull.h b/src/TableFunctions/TableFunctionNull.h\nindex 48617352b254..4d4cecb02924 100644\n--- a/src/TableFunctions/TableFunctionNull.h\n+++ b/src/TableFunctions/TableFunctionNull.h\n@@ -17,8 +17,13 @@ class TableFunctionNull : public ITableFunction\n     static constexpr auto name = \"null\";\n     std::string getName() const override { return name; }\n private:\n-    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const override;\n+    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const String & table_name, ColumnsDescription cached_columns) const override;\n     const char * getStorageTypeName() const override { return \"Null\"; }\n+\n+    void parseArguments(const ASTPtr & ast_function, const Context & context) override;\n+    ColumnsDescription getActualTableStructure(const Context & context) const override;\n+\n+    String structure;\n };\n \n }\ndiff --git a/src/TableFunctions/TableFunctionNumbers.cpp b/src/TableFunctions/TableFunctionNumbers.cpp\nindex c8c0fe96092e..4658165735a9 100644\n--- a/src/TableFunctions/TableFunctionNumbers.cpp\n+++ b/src/TableFunctions/TableFunctionNumbers.cpp\n@@ -7,6 +7,7 @@\n #include <Storages/System/StorageSystemNumbers.h>\n #include <Interpreters/evaluateConstantExpression.h>\n #include <Interpreters/Context.h>\n+#include <DataTypes/DataTypesNumber.h>\n #include \"registerTableFunctions.h\"\n \n \n@@ -18,8 +19,16 @@ namespace ErrorCodes\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n }\n \n+\n+template <bool multithreaded>\n+ColumnsDescription TableFunctionNumbers<multithreaded>::getActualTableStructure(const Context & /*context*/) const\n+{\n+    /// NOTE: https://bugs.llvm.org/show_bug.cgi?id=47418\n+    return ColumnsDescription{{{\"number\", std::make_shared<DataTypeUInt64>()}}};\n+}\n+\n template <bool multithreaded>\n-StoragePtr TableFunctionNumbers<multithreaded>::executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const\n+StoragePtr TableFunctionNumbers<multithreaded>::executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name, ColumnsDescription /*cached_columns*/) const\n {\n     if (const auto * function = ast_function->as<ASTFunction>())\n     {\n@@ -28,7 +37,6 @@ StoragePtr TableFunctionNumbers<multithreaded>::executeImpl(const ASTPtr & ast_f\n         if (arguments.size() != 1 && arguments.size() != 2)\n             throw Exception(\"Table function '\" + getName() + \"' requires 'length' or 'offset, length'.\", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n-\n         UInt64 offset = arguments.size() == 2 ? evaluateArgument(context, arguments[0]) : 0;\n         UInt64 length = arguments.size() == 2 ? evaluateArgument(context, arguments[1]) : evaluateArgument(context, arguments[0]);\n \ndiff --git a/src/TableFunctions/TableFunctionNumbers.h b/src/TableFunctions/TableFunctionNumbers.h\nindex 13064a3309e4..c27bb7319bac 100644\n--- a/src/TableFunctions/TableFunctionNumbers.h\n+++ b/src/TableFunctions/TableFunctionNumbers.h\n@@ -17,11 +17,14 @@ class TableFunctionNumbers : public ITableFunction\n public:\n     static constexpr auto name = multithreaded ? \"numbers_mt\" : \"numbers\";\n     std::string getName() const override { return name; }\n+    bool hasStaticStructure() const override { return true; }\n private:\n-    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const override;\n+    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name, ColumnsDescription cached_columns) const override;\n     const char * getStorageTypeName() const override { return \"SystemNumbers\"; }\n \n     UInt64 evaluateArgument(const Context & context, ASTPtr & argument) const;\n+\n+    ColumnsDescription getActualTableStructure(const Context & context) const override;\n };\n \n \ndiff --git a/src/TableFunctions/TableFunctionRemote.cpp b/src/TableFunctions/TableFunctionRemote.cpp\nindex 7fa3868d142e..2e34e82ce364 100644\n--- a/src/TableFunctions/TableFunctionRemote.cpp\n+++ b/src/TableFunctions/TableFunctionRemote.cpp\n@@ -27,7 +27,8 @@ namespace ErrorCodes\n     extern const int BAD_ARGUMENTS;\n }\n \n-StoragePtr TableFunctionRemote::executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const\n+\n+void TableFunctionRemote::parseArguments(const ASTPtr & ast_function, const Context & context)\n {\n     ASTs & args_func = ast_function->children;\n \n@@ -44,7 +45,6 @@ StoragePtr TableFunctionRemote::executeImpl(const ASTPtr & ast_function, const C\n     String cluster_description;\n     String remote_database;\n     String remote_table;\n-    ASTPtr remote_table_function_ptr;\n     String username;\n     String password;\n \n@@ -136,7 +136,6 @@ StoragePtr TableFunctionRemote::executeImpl(const ASTPtr & ast_function, const C\n     for (auto ast : args)\n         setIdentifierSpecial(ast);\n \n-    ClusterPtr cluster;\n     if (!cluster_name.empty())\n     {\n         /// Use an existing cluster from the main config\n@@ -189,30 +188,54 @@ StoragePtr TableFunctionRemote::executeImpl(const ASTPtr & ast_function, const C\n     if (!remote_table_function_ptr && remote_table.empty())\n         throw Exception(\"The name of remote table cannot be empty\", ErrorCodes::BAD_ARGUMENTS);\n \n-    auto remote_table_id = StorageID::createEmpty();\n     remote_table_id.database_name = remote_database;\n     remote_table_id.table_name = remote_table;\n-    auto structure_remote_table = getStructureOfRemoteTable(*cluster, remote_table_id, context, remote_table_function_ptr);\n+}\n+\n+StoragePtr TableFunctionRemote::executeImpl(const ASTPtr & /*ast_function*/, const Context & context, const std::string & table_name, ColumnsDescription cached_columns) const\n+{\n+    /// StorageDistributed supports mismatching structure of remote table, so we can use outdated structure for CREATE ... AS remote(...)\n+    /// without additional conversion in StorageTableFunctionProxy\n+    if (cached_columns.empty())\n+        cached_columns = getActualTableStructure(context);\n \n+    assert(cluster);\n     StoragePtr res = remote_table_function_ptr\n-        ? StorageDistributed::createWithOwnCluster(\n+        ? StorageDistributed::create(\n             StorageID(getDatabaseName(), table_name),\n-            structure_remote_table,\n+            cached_columns,\n+            ConstraintsDescription{},\n             remote_table_function_ptr,\n-            cluster,\n-            context)\n-        : StorageDistributed::createWithOwnCluster(\n+            String{},\n+            context,\n+            ASTPtr{},\n+            String{},\n+            String{},\n+            false,\n+            cluster)\n+        : StorageDistributed::create(\n             StorageID(getDatabaseName(), table_name),\n-            structure_remote_table,\n-            remote_database,\n-            remote_table,\n-            cluster,\n-            context);\n+            cached_columns,\n+            ConstraintsDescription{},\n+            remote_table_id.database_name,\n+            remote_table_id.table_name,\n+            String{},\n+            context,\n+            ASTPtr{},\n+            String{},\n+            String{},\n+            false,\n+            cluster);\n \n     res->startup();\n     return res;\n }\n \n+ColumnsDescription TableFunctionRemote::getActualTableStructure(const Context & context) const\n+{\n+    assert(cluster);\n+    return getStructureOfRemoteTable(*cluster, remote_table_id, context, remote_table_function_ptr);\n+}\n \n TableFunctionRemote::TableFunctionRemote(const std::string & name_, bool secure_)\n     : name{name_}, secure{secure_}\ndiff --git a/src/TableFunctions/TableFunctionRemote.h b/src/TableFunctions/TableFunctionRemote.h\nindex 2dd58a8a6a7c..6ec591a34ac7 100644\n--- a/src/TableFunctions/TableFunctionRemote.h\n+++ b/src/TableFunctions/TableFunctionRemote.h\n@@ -1,6 +1,8 @@\n #pragma once\n \n #include <TableFunctions/ITableFunction.h>\n+#include <Interpreters/Cluster.h>\n+#include <Interpreters/StorageID.h>\n \n \n namespace DB\n@@ -20,14 +22,24 @@ class TableFunctionRemote : public ITableFunction\n \n     std::string getName() const override { return name; }\n \n+    ColumnsDescription getActualTableStructure(const Context & context) const override;\n+\n+    bool needStructureConversion() const override { return false; }\n+\n private:\n-    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const override;\n+    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name, ColumnsDescription cached_columns) const override;\n     const char * getStorageTypeName() const override { return \"Distributed\"; }\n \n+    void parseArguments(const ASTPtr & ast_function, const Context & context) override;\n+\n     std::string name;\n     bool is_cluster_function;\n     std::string help_message;\n     bool secure;\n+\n+    ClusterPtr cluster;\n+    StorageID remote_table_id = StorageID::createEmpty();\n+    ASTPtr remote_table_function_ptr;\n };\n \n }\ndiff --git a/src/TableFunctions/TableFunctionS3.cpp b/src/TableFunctions/TableFunctionS3.cpp\nindex 1a0bff12ba23..dfe1cf6e7922 100644\n--- a/src/TableFunctions/TableFunctionS3.cpp\n+++ b/src/TableFunctions/TableFunctionS3.cpp\n@@ -21,7 +21,7 @@ namespace ErrorCodes\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n }\n \n-StoragePtr TableFunctionS3::executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const\n+void TableFunctionS3::parseArguments(const ASTPtr & ast_function, const Context & context)\n {\n     /// Parse args\n     ASTs & args_func = ast_function->children;\n@@ -38,11 +38,7 @@ StoragePtr TableFunctionS3::executeImpl(const ASTPtr & ast_function, const Conte\n     for (auto & arg : args)\n         arg = evaluateConstantExpressionOrIdentifierAsLiteral(arg, context);\n \n-    String filename = args[0]->as<ASTLiteral &>().value.safeGet<String>();\n-    String format;\n-    String structure;\n-    String access_key_id;\n-    String secret_access_key;\n+    filename = args[0]->as<ASTLiteral &>().value.safeGet<String>();\n \n     if (args.size() < 5)\n     {\n@@ -57,47 +53,38 @@ StoragePtr TableFunctionS3::executeImpl(const ASTPtr & ast_function, const Conte\n         structure = args[4]->as<ASTLiteral &>().value.safeGet<String>();\n     }\n \n-    String compression_method;\n     if (args.size() == 4 || args.size() == 6)\n         compression_method = args.back()->as<ASTLiteral &>().value.safeGet<String>();\n-    else\n-        compression_method = \"auto\";\n+}\n \n-    ColumnsDescription columns = parseColumnsListFromString(structure, context);\n+ColumnsDescription TableFunctionS3::getActualTableStructure(const Context & context) const\n+{\n+    return parseColumnsListFromString(structure, context);\n+}\n \n-    /// Create table\n-    StoragePtr storage = getStorage(filename, access_key_id, secret_access_key, format, columns, const_cast<Context &>(context), table_name, compression_method);\n+StoragePtr TableFunctionS3::executeImpl(const ASTPtr & /*ast_function*/, const Context & context, const std::string & table_name, ColumnsDescription /*cached_columns*/) const\n+{\n+    Poco::URI uri (filename);\n+    S3::URI s3_uri (uri);\n+    UInt64 min_upload_part_size = context.getSettingsRef().s3_min_upload_part_size;\n+\n+    StoragePtr storage = StorageS3::create(\n+            s3_uri,\n+            access_key_id,\n+            secret_access_key,\n+            StorageID(getDatabaseName(), table_name),\n+            format,\n+            min_upload_part_size,\n+            getActualTableStructure(context),\n+            ConstraintsDescription{},\n+            const_cast<Context &>(context),\n+            compression_method);\n \n     storage->startup();\n \n     return storage;\n }\n \n-StoragePtr TableFunctionS3::getStorage(\n-    const String & source,\n-    const String & access_key_id,\n-    const String & secret_access_key,\n-    const String & format,\n-    const ColumnsDescription & columns,\n-    Context & global_context,\n-    const std::string & table_name,\n-    const String & compression_method)\n-{\n-    Poco::URI uri (source);\n-    S3::URI s3_uri (uri);\n-    UInt64 min_upload_part_size = global_context.getSettingsRef().s3_min_upload_part_size;\n-    return StorageS3::create(\n-        s3_uri,\n-        access_key_id,\n-        secret_access_key,\n-        StorageID(getDatabaseName(), table_name),\n-        format,\n-        min_upload_part_size,\n-        columns,\n-        ConstraintsDescription{},\n-        global_context,\n-        compression_method);\n-}\n \n void registerTableFunctionS3(TableFunctionFactory & factory)\n {\ndiff --git a/src/TableFunctions/TableFunctionS3.h b/src/TableFunctions/TableFunctionS3.h\nindex b66da57d4faa..722fb9eb23c0 100644\n--- a/src/TableFunctions/TableFunctionS3.h\n+++ b/src/TableFunctions/TableFunctionS3.h\n@@ -22,24 +22,26 @@ class TableFunctionS3 : public ITableFunction\n     {\n         return name;\n     }\n+    bool hasStaticStructure() const override { return true; }\n \n protected:\n     StoragePtr executeImpl(\n         const ASTPtr & ast_function,\n         const Context & context,\n-        const std::string & table_name) const override;\n-\n-    static StoragePtr getStorage(\n-        const String & source,\n-        const String & access_key_id,\n-        const String & secret_access_key,\n-        const String & format,\n-        const ColumnsDescription & columns,\n-        Context & global_context,\n         const std::string & table_name,\n-        const String & compression_method);\n+        ColumnsDescription cached_columns) const override;\n \n     const char * getStorageTypeName() const override { return \"S3\"; }\n+\n+    ColumnsDescription getActualTableStructure(const Context & context) const override;\n+    void parseArguments(const ASTPtr & ast_function, const Context & context) override;\n+\n+    String filename;\n+    String format;\n+    String structure;\n+    String access_key_id;\n+    String secret_access_key;\n+    String compression_method = \"auto\";\n };\n \n class TableFunctionCOS : public TableFunctionS3\ndiff --git a/src/TableFunctions/TableFunctionURL.cpp b/src/TableFunctions/TableFunctionURL.cpp\nindex 59978ae08b16..6139e6ffecbb 100644\n--- a/src/TableFunctions/TableFunctionURL.cpp\n+++ b/src/TableFunctions/TableFunctionURL.cpp\n@@ -10,10 +10,12 @@\n namespace DB\n {\n StoragePtr TableFunctionURL::getStorage(\n-    const String & source, const String & format, const ColumnsDescription & columns, Context & global_context, const std::string & table_name, const String & compression_method) const\n+    const String & source, const String & format_, const ColumnsDescription & columns, Context & global_context,\n+    const std::string & table_name, const String & compression_method_) const\n {\n     Poco::URI uri(source);\n-    return StorageURL::create(uri, StorageID(getDatabaseName(), table_name), format, columns, ConstraintsDescription{}, global_context, compression_method);\n+    return StorageURL::create(uri, StorageID(getDatabaseName(), table_name), format_, columns, ConstraintsDescription{},\n+            global_context, compression_method_);\n }\n \n void registerTableFunctionURL(TableFunctionFactory & factory)\ndiff --git a/src/TableFunctions/TableFunctionURL.h b/src/TableFunctions/TableFunctionURL.h\nindex 366d573bcf4d..5eb027e2b8a2 100644\n--- a/src/TableFunctions/TableFunctionURL.h\n+++ b/src/TableFunctions/TableFunctionURL.h\n@@ -21,7 +21,8 @@ class TableFunctionURL : public ITableFunctionFileLike\n \n private:\n     StoragePtr getStorage(\n-        const String & source, const String & format, const ColumnsDescription & columns, Context & global_context, const std::string & table_name, const String & compression_method) const override;\n+        const String & source, const String & format_, const ColumnsDescription & columns, Context & global_context,\n+        const std::string & table_name, const String & compression_method_) const override;\n     const char * getStorageTypeName() const override { return \"URL\"; }\n };\n \ndiff --git a/src/TableFunctions/TableFunctionValues.cpp b/src/TableFunctions/TableFunctionValues.cpp\nindex b4b243416f2f..2d01d581fda5 100644\n--- a/src/TableFunctions/TableFunctionValues.cpp\n+++ b/src/TableFunctions/TableFunctionValues.cpp\n@@ -62,8 +62,10 @@ static void parseAndInsertValues(MutableColumns & res_columns, const ASTs & args\n     }\n }\n \n-StoragePtr TableFunctionValues::executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const\n+void TableFunctionValues::parseArguments(const ASTPtr & ast_function, const Context & /*context*/)\n {\n+\n+\n     ASTs & args_func = ast_function->children;\n \n     if (args_func.size() != 1)\n@@ -83,9 +85,18 @@ StoragePtr TableFunctionValues::executeImpl(const ASTPtr & ast_function, const C\n             \"Got '{}' instead\", getName(), args[0]->formatForErrorMessage()),\n             ErrorCodes::BAD_ARGUMENTS);\n     }\n-    std::string structure = args[0]->as<ASTLiteral &>().value.safeGet<String>();\n \n-    ColumnsDescription columns = parseColumnsListFromString(structure, context);\n+    structure = args[0]->as<ASTLiteral &>().value.safeGet<String>();\n+}\n+\n+ColumnsDescription TableFunctionValues::getActualTableStructure(const Context & context) const\n+{\n+    return parseColumnsListFromString(structure, context);\n+}\n+\n+StoragePtr TableFunctionValues::executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name, ColumnsDescription /*cached_columns*/) const\n+{\n+    auto columns = getActualTableStructure(context);\n \n     Block sample_block;\n     for (const auto & name_type : columns.getOrdinary())\n@@ -93,6 +104,8 @@ StoragePtr TableFunctionValues::executeImpl(const ASTPtr & ast_function, const C\n \n     MutableColumns res_columns = sample_block.cloneEmptyColumns();\n \n+    ASTs & args = ast_function->children.at(0)->children;\n+\n     /// Parsing other arguments as values and inserting them into columns\n     parseAndInsertValues(res_columns, args, sample_block, context);\n \ndiff --git a/src/TableFunctions/TableFunctionValues.h b/src/TableFunctions/TableFunctionValues.h\nindex 3cc3687dab5b..549fa2de5079 100644\n--- a/src/TableFunctions/TableFunctionValues.h\n+++ b/src/TableFunctions/TableFunctionValues.h\n@@ -12,9 +12,15 @@ class TableFunctionValues : public ITableFunction\n public:\n     static constexpr auto name = \"values\";\n     std::string getName() const override { return name; }\n+    bool hasStaticStructure() const override { return true; }\n private:\n-    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const override;\n+    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name, ColumnsDescription cached_columns) const override;\n     const char * getStorageTypeName() const override { return \"Values\"; }\n+\n+    ColumnsDescription getActualTableStructure(const Context & context) const override;\n+    void parseArguments(const ASTPtr & ast_function, const Context & context) override;\n+\n+    String structure;\n };\n \n \ndiff --git a/src/TableFunctions/TableFunctionView.cpp b/src/TableFunctions/TableFunctionView.cpp\nindex 8d3f7b06fa3a..5ec06592103e 100644\n--- a/src/TableFunctions/TableFunctionView.cpp\n+++ b/src/TableFunctions/TableFunctionView.cpp\n@@ -1,5 +1,4 @@\n #include <Interpreters/InterpreterSelectWithUnionQuery.h>\n-#include <Parsers/ASTCreateQuery.h>\n #include <Parsers/ASTFunction.h>\n #include <Parsers/ASTSelectWithUnionQuery.h>\n #include <Storages/StorageView.h>\n@@ -16,24 +15,37 @@ namespace ErrorCodes\n     extern const int BAD_ARGUMENTS;\n }\n \n-StoragePtr TableFunctionView::executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const\n+void TableFunctionView::parseArguments(const ASTPtr & ast_function, const Context & /*context*/)\n {\n-    if (const auto * function = ast_function->as<ASTFunction>())\n+    const auto * function = ast_function->as<ASTFunction>();\n+    if (function)\n     {\n         if (auto * select = function->tryGetQueryArgument())\n         {\n-            auto sample = InterpreterSelectWithUnionQuery::getSampleBlock(function->arguments->children[0] /* ASTPtr */, context);\n-            auto columns = ColumnsDescription(sample.getNamesAndTypesList());\n-            ASTCreateQuery create;\n-            create.select = select;\n-            auto res = StorageView::create(StorageID(getDatabaseName(), table_name), create, columns);\n-            res->startup();\n-            return res;\n+            create.set(create.select, select->clone());\n+            return;\n         }\n     }\n     throw Exception(\"Table function '\" + getName() + \"' requires a query argument.\", ErrorCodes::BAD_ARGUMENTS);\n }\n \n+ColumnsDescription TableFunctionView::getActualTableStructure(const Context & context) const\n+{\n+    assert(create.select);\n+    assert(create.children.size() == 1);\n+    assert(create.children[0]->as<ASTSelectWithUnionQuery>());\n+    auto sample = InterpreterSelectWithUnionQuery::getSampleBlock(create.children[0], context);\n+    return ColumnsDescription(sample.getNamesAndTypesList());\n+}\n+\n+StoragePtr TableFunctionView::executeImpl(const ASTPtr & /*ast_function*/, const Context & context, const std::string & table_name, ColumnsDescription /*cached_columns*/) const\n+{\n+    auto columns = getActualTableStructure(context);\n+    auto res = StorageView::create(StorageID(getDatabaseName(), table_name), create, columns);\n+    res->startup();\n+    return res;\n+}\n+\n void registerTableFunctionView(TableFunctionFactory & factory)\n {\n     factory.registerFunction<TableFunctionView>();\ndiff --git a/src/TableFunctions/TableFunctionView.h b/src/TableFunctions/TableFunctionView.h\nindex 43d55a7dcb8b..0ed66ff712cf 100644\n--- a/src/TableFunctions/TableFunctionView.h\n+++ b/src/TableFunctions/TableFunctionView.h\n@@ -1,9 +1,9 @@\n #pragma once\n \n #include <TableFunctions/ITableFunction.h>\n+#include <Parsers/ASTCreateQuery.h>\n #include <common/types.h>\n \n-\n namespace DB\n {\n \n@@ -17,10 +17,13 @@ class TableFunctionView : public ITableFunction\n     static constexpr auto name = \"view\";\n     std::string getName() const override { return name; }\n private:\n-    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const override;\n+    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const String & table_name, ColumnsDescription cached_columns) const override;\n     const char * getStorageTypeName() const override { return \"View\"; }\n \n-    UInt64 evaluateArgument(const Context & context, ASTPtr & argument) const;\n+    void parseArguments(const ASTPtr & ast_function, const Context & context) override;\n+    ColumnsDescription getActualTableStructure(const Context & context) const override;\n+\n+    ASTCreateQuery create;\n };\n \n \ndiff --git a/src/TableFunctions/TableFunctionZeros.cpp b/src/TableFunctions/TableFunctionZeros.cpp\nindex 13436f04e1cb..9b0c6c6e78b3 100644\n--- a/src/TableFunctions/TableFunctionZeros.cpp\n+++ b/src/TableFunctions/TableFunctionZeros.cpp\n@@ -3,8 +3,8 @@\n #include <TableFunctions/TableFunctionFactory.h>\n #include <Parsers/ASTFunction.h>\n #include <Parsers/ASTLiteral.h>\n-#include <Common/typeid_cast.h>\n #include <Storages/System/StorageSystemZeros.h>\n+#include <DataTypes/DataTypesNumber.h>\n #include <Interpreters/evaluateConstantExpression.h>\n #include <Interpreters/Context.h>\n #include \"registerTableFunctions.h\"\n@@ -18,8 +18,16 @@ namespace ErrorCodes\n extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n }\n \n+\n+template <bool multithreaded>\n+ColumnsDescription TableFunctionZeros<multithreaded>::getActualTableStructure(const Context & /*context*/) const\n+{\n+    /// NOTE: https://bugs.llvm.org/show_bug.cgi?id=47418\n+    return ColumnsDescription{{{\"zero\", std::make_shared<DataTypeUInt8>()}}};\n+}\n+\n template <bool multithreaded>\n-StoragePtr TableFunctionZeros<multithreaded>::executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const\n+StoragePtr TableFunctionZeros<multithreaded>::executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name, ColumnsDescription /*cached_columns*/) const\n {\n     if (const auto * function = ast_function->as<ASTFunction>())\n     {\ndiff --git a/src/TableFunctions/TableFunctionZeros.h b/src/TableFunctions/TableFunctionZeros.h\nindex cae4604b1d7f..48a2d8019f61 100644\n--- a/src/TableFunctions/TableFunctionZeros.h\n+++ b/src/TableFunctions/TableFunctionZeros.h\n@@ -17,11 +17,14 @@ class TableFunctionZeros : public ITableFunction\n public:\n     static constexpr auto name = multithreaded ? \"zeros_mt\" : \"zeros\";\n     std::string getName() const override { return name; }\n+    bool hasStaticStructure() const override { return true; }\n private:\n-    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const override;\n+    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name, ColumnsDescription cached_columns) const override;\n     const char * getStorageTypeName() const override { return \"SystemZeros\"; }\n \n     UInt64 evaluateArgument(const Context & context, ASTPtr & argument) const;\n+\n+    ColumnsDescription getActualTableStructure(const Context & context) const override;\n };\n \n \n",
  "test_patch": "diff --git a/docker/test/base/Dockerfile b/docker/test/base/Dockerfile\nindex 506e32c18b35..61a40673a967 100644\n--- a/docker/test/base/Dockerfile\n+++ b/docker/test/base/Dockerfile\n@@ -52,6 +52,7 @@ RUN apt-get update \\\n RUN echo \"TSAN_OPTIONS='verbosity=1000 halt_on_error=1 history_size=7'\" >> /etc/environment; \\\n   echo \"UBSAN_OPTIONS='print_stacktrace=1'\" >> /etc/environment; \\\n   echo \"MSAN_OPTIONS='abort_on_error=1'\" >> /etc/environment; \\\n+  echo \"LSAN_OPTIONS='suppressions=/usr/share/clickhouse-test/config/lsan_suppressions.txt'\" >> /etc/environment; \\\n   ln -s /usr/lib/llvm-${LLVM_VERSION}/bin/llvm-symbolizer /usr/bin/llvm-symbolizer;\n # Sanitizer options for current shell (not current, but the one that will be spawned on \"docker run\")\n # (but w/o verbosity for TSAN, otherwise test.reference will not match)\ndiff --git a/tests/config/lsan_suppressions.txt b/tests/config/lsan_suppressions.txt\nnew file mode 100644\nindex 000000000000..39eb40560d7e\n--- /dev/null\n+++ b/tests/config/lsan_suppressions.txt\n@@ -0,0 +1,2 @@\n+# See https://bugs.llvm.org/show_bug.cgi?id=47418\n+# leak:getActualTableStructure\ndiff --git a/tests/integration/test_distributed_format/test.py b/tests/integration/test_distributed_format/test.py\nindex 7e9d740c171e..607154e37f1a 100644\n--- a/tests/integration/test_distributed_format/test.py\n+++ b/tests/integration/test_distributed_format/test.py\n@@ -34,7 +34,7 @@ def test_single_file(started_cluster, cluster):\n \n     assert out == '1\\ta\\n2\\tbb\\n3\\tccc\\n'\n \n-    query = \"create table t (dummy UInt32) engine = File('Distributed', '/var/lib/clickhouse/data/test/distr_1/shard1_replica1/1.bin');\" \\\n+    query = \"create table t (x UInt64, s String) engine = File('Distributed', '/var/lib/clickhouse/data/test/distr_1/shard1_replica1/1.bin');\" \\\n             \"select * from t\"\n     out = node.exec_in_container(['/usr/bin/clickhouse', 'local', '--stacktrace', '-q', query])\n \n@@ -57,7 +57,7 @@ def test_two_files(started_cluster, cluster):\n \n     assert out == '0\\t_\\n1\\ta\\n2\\tbb\\n3\\tccc\\n'\n \n-    query = \"create table t (dummy UInt32) engine = File('Distributed', '/var/lib/clickhouse/data/test/distr_2/shard1_replica1/{1,2,3,4}.bin');\" \\\n+    query = \"create table t (x UInt64, s String) engine = File('Distributed', '/var/lib/clickhouse/data/test/distr_2/shard1_replica1/{1,2,3,4}.bin');\" \\\n             \"select * from t order by x\"\n     out = node.exec_in_container(['/usr/bin/clickhouse', 'local', '--stacktrace', '-q', query])\n \n@@ -77,7 +77,7 @@ def test_single_file_old(started_cluster, cluster):\n \n     assert out == '1\\ta\\n2\\tbb\\n3\\tccc\\n'\n \n-    query = \"create table t (dummy UInt32) engine = File('Distributed', '/var/lib/clickhouse/data/test/distr_3/default@not_existing:9000/1.bin');\" \\\n+    query = \"create table t (x UInt64, s String) engine = File('Distributed', '/var/lib/clickhouse/data/test/distr_3/default@not_existing:9000/1.bin');\" \\\n             \"select * from t\"\n     out = node.exec_in_container(['/usr/bin/clickhouse', 'local', '--stacktrace', '-q', query])\n \ndiff --git a/tests/queries/0_stateless/01083_expressions_in_engine_arguments.reference b/tests/queries/0_stateless/01083_expressions_in_engine_arguments.reference\nindex 933fda604d7b..2a5d7e6da32e 100644\n--- a/tests/queries/0_stateless/01083_expressions_in_engine_arguments.reference\n+++ b/tests/queries/0_stateless/01083_expressions_in_engine_arguments.reference\n@@ -1,11 +1,11 @@\n CREATE TABLE default.file\\n(\\n    `n` Int8\\n)\\nENGINE = File(\\'TSVWithNamesAndTypes\\')\n CREATE TABLE default.buffer\\n(\\n    `n` Int8\\n)\\nENGINE = Buffer(\\'default\\', \\'file\\', 16, 10, 200, 10000, 1000000, 10000000, 1000000000)\n CREATE TABLE default.merge\\n(\\n    `n` Int8\\n)\\nENGINE = Merge(\\'default\\', \\'distributed\\')\n-CREATE TABLE default.merge_tf AS merge(\\'default\\', \\'.*\\')\n+CREATE TABLE default.merge_tf\\n(\\n    `n` Int8\\n) AS merge(\\'default\\', \\'.*\\')\n CREATE TABLE default.distributed\\n(\\n    `n` Int8\\n)\\nENGINE = Distributed(\\'test_shard_localhost\\', \\'default\\', \\'file\\')\n-CREATE TABLE default.distributed_tf AS cluster(\\'test_shard_localhost\\', \\'default\\', \\'buffer\\')\n+CREATE TABLE default.distributed_tf\\n(\\n    `n` Int8\\n) AS cluster(\\'test_shard_localhost\\', \\'default\\', \\'buffer\\')\n CREATE TABLE default.url\\n(\\n    `n` UInt64,\\n    `col` String\\n)\\nENGINE = URL(\\'https://localhost:8443/?query=select+n,+_table+from+default.merge+format+CSV\\', \\'CSV\\')\n-CREATE TABLE default.rich_syntax AS remote(\\'localhos{x|y|t}\\', cluster(\\'test_shard_localhost\\', remote(\\'127.0.0.{1..4}\\', \\'default\\', \\'view\\')))\n+CREATE TABLE default.rich_syntax\\n(\\n    `n` Int64\\n) AS remote(\\'localhos{x|y|t}\\', cluster(\\'test_shard_localhost\\', remote(\\'127.0.0.{1..4}\\', \\'default\\', \\'view\\')))\n CREATE VIEW default.view\\n(\\n    `n` Int64\\n) AS\\nSELECT toInt64(n) AS n\\nFROM \\n(\\n    SELECT toString(n) AS n\\n    FROM default.merge\\n    WHERE _table != \\'qwerty\\'\\n    ORDER BY _table ASC\\n)\\nUNION ALL\\nSELECT *\\nFROM default.file\n CREATE DICTIONARY default.dict\\n(\\n    `n` UInt64,\\n    `col` String DEFAULT \\'42\\'\\n)\\nPRIMARY KEY n\\nSOURCE(CLICKHOUSE(HOST \\'localhost\\' PORT 9440 SECURE 1 USER \\'default\\' TABLE \\'url\\'))\\nLIFETIME(MIN 0 MAX 1)\\nLAYOUT(CACHE(SIZE_IN_CELLS 1))\n 16\ndiff --git a/tests/queries/0_stateless/01457_create_as_table_function_structure.reference b/tests/queries/0_stateless/01457_create_as_table_function_structure.reference\nnew file mode 100644\nindex 000000000000..0deaa20171a3\n--- /dev/null\n+++ b/tests/queries/0_stateless/01457_create_as_table_function_structure.reference\n@@ -0,0 +1,10 @@\n+CREATE TABLE test_01457.tf_remote\\n(\\n    `n` Int8\\n) AS remote(\\'localhost\\', \\'default\\', \\'tmp\\')\n+CREATE TABLE test_01457.tf_remote_explicit_structure\\n(\\n    `n` UInt64\\n) AS remote(\\'localhost\\', \\'default\\', \\'tmp\\')\n+CREATE TABLE test_01457.tf_numbers\\n(\\n    `number` String\\n) AS numbers(1)\n+CREATE TABLE test_01457.tf_merge\\n(\\n    `n` Int8\\n) AS merge(\\'default\\', \\'tmp\\')\n+42\n+0\tInt8\n+0\tInt8\n+0\tUInt64\n+0\tString\n+0\tInt8\ndiff --git a/tests/queries/0_stateless/01457_create_as_table_function_structure.sql b/tests/queries/0_stateless/01457_create_as_table_function_structure.sql\nnew file mode 100644\nindex 000000000000..edfab747fc46\n--- /dev/null\n+++ b/tests/queries/0_stateless/01457_create_as_table_function_structure.sql\n@@ -0,0 +1,33 @@\n+DROP DATABASE IF EXISTS test_01457;\n+\n+CREATE DATABASE test_01457;\n+\n+CREATE TABLE tmp (n Int8) ENGINE=Memory;\n+\n+CREATE TABLE test_01457.tf_remote AS remote('localhost', currentDatabase(), 'tmp');\n+SHOW CREATE TABLE test_01457.tf_remote;\n+CREATE TABLE test_01457.tf_remote_explicit_structure (n UInt64) AS remote('localhost', currentDatabase(), 'tmp');\n+SHOW CREATE TABLE test_01457.tf_remote_explicit_structure;\n+CREATE TABLE test_01457.tf_numbers (number String) AS numbers(1);\n+SHOW CREATE TABLE test_01457.tf_numbers;\n+CREATE TABLE test_01457.tf_merge AS merge(currentDatabase(), 'tmp');\n+SHOW CREATE TABLE test_01457.tf_merge;\n+\n+DROP TABLE tmp;\n+\n+DETACH DATABASE test_01457;\n+ATTACH DATABASE test_01457;\n+\n+CREATE TABLE tmp (n Int8) ENGINE=Memory;\n+INSERT INTO test_01457.tf_remote_explicit_structure VALUES ('42');\n+SELECT * FROM tmp;\n+TRUNCATE TABLE tmp;\n+INSERT INTO test_01457.tf_remote VALUES (0);\n+\n+SELECT (*,).1 AS c, toTypeName(c) FROM tmp;\n+SELECT (*,).1 AS c, toTypeName(c) FROM test_01457.tf_remote;\n+SELECT (*,).1 AS c, toTypeName(c) FROM test_01457.tf_remote_explicit_structure;\n+SELECT (*,).1 AS c, toTypeName(c) FROM test_01457.tf_numbers;\n+SELECT (*,).1 AS c, toTypeName(c) FROM test_01457.tf_merge;\n+\n+DROP DATABASE test_01457;\ndiff --git a/tests/queries/0_stateless/01461_alter_table_function.reference b/tests/queries/0_stateless/01461_alter_table_function.reference\nindex 395155967a97..b552dd81b770 100644\n--- a/tests/queries/0_stateless/01461_alter_table_function.reference\n+++ b/tests/queries/0_stateless/01461_alter_table_function.reference\n@@ -1,7 +1,6 @@\n-CREATE TABLE default.table_from_remote AS remote(\\'localhost\\', \\'system\\', \\'numbers\\')\n-CREATE TABLE default.table_from_remote AS remote(\\'localhost\\', \\'system\\', \\'numbers\\')\n-CREATE TABLE default.table_from_numbers AS numbers(1000)\n-CREATE TABLE default.table_from_numbers AS numbers(1000)\n+CREATE TABLE default.table_from_remote\\n(\\n    `number` UInt64\\n) AS remote(\\'localhost\\', \\'system\\', \\'numbers\\')\n+CREATE TABLE default.table_from_remote\\n(\\n    `number` UInt64,\\n    `col` UInt8\\n) AS remote(\\'localhost\\', \\'system\\', \\'numbers\\')\n+CREATE TABLE default.table_from_numbers\\n(\\n    `number` UInt64\\n) AS numbers(1000)\n+CREATE TABLE default.table_from_numbers\\n(\\n    `number` UInt64\\n) AS numbers(1000)\n CREATE TABLE default.table_from_select\\n(\\n    `number` UInt64\\n)\\nENGINE = MergeTree()\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\n CREATE TABLE default.table_from_select\\n(\\n    `number` UInt64,\\n    `col` UInt8\\n)\\nENGINE = MergeTree()\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\n-1\ndiff --git a/tests/queries/0_stateless/01461_alter_table_function.sql b/tests/queries/0_stateless/01461_alter_table_function.sql\nindex e242d1f0b7b3..11f643f1e3ed 100644\n--- a/tests/queries/0_stateless/01461_alter_table_function.sql\n+++ b/tests/queries/0_stateless/01461_alter_table_function.sql\n@@ -6,7 +6,7 @@ CREATE TABLE table_from_remote AS remote('localhost', 'system', 'numbers');\n \n SHOW CREATE TABLE table_from_remote;\n \n-ALTER TABLE table_from_remote ADD COLUMN col UInt8; --{serverError 48}\n+ALTER TABLE table_from_remote ADD COLUMN col UInt8;\n \n SHOW CREATE TABLE table_from_remote;\n \n@@ -26,8 +26,6 @@ ALTER TABLE table_from_select ADD COLUMN col UInt8;\n \n SHOW CREATE TABLE table_from_select;\n \n-SELECT 1;\n-\n DROP TABLE IF EXISTS table_from_remote;\n DROP TABLE IF EXISTS table_from_select;\n DROP TABLE IF EXISTS table_from_numbers;\ndiff --git a/tests/queries/0_stateless/arcadia_skip_list.txt b/tests/queries/0_stateless/arcadia_skip_list.txt\nindex e59a2634d0cd..d7ac6709e905 100644\n--- a/tests/queries/0_stateless/arcadia_skip_list.txt\n+++ b/tests/queries/0_stateless/arcadia_skip_list.txt\n@@ -141,6 +141,7 @@\n 01460_DistributedFilesToInsert\n 01474_executable_dictionary\n 01474_bad_global_join\n+01457_create_as_table_function_structure\n 01473_event_time_microseconds\n 01461_query_start_time_microseconds\n 01455_shard_leaf_max_rows_bytes_to_read\n",
  "problem_statement": "CREATE as remote(...) may lead to server startup failure\n\r\n**How to reproduce**\r\n```\r\ncreate database z;\r\ncreate table z.tmp (n Int8) engine=Memory;\r\ncreate table default.remote as remote('localhost', 'z', 'tmp');\r\n```\r\nand restart clickhouse-server\r\n\r\n**Error message and/or stacktrace**\r\n```\r\n2020.02.20 15:29:48.875097 [ 1 ] {} <Error> Application: DB::Exception: Cannot attach table 'remote' from query ATTACH TABLE remote AS remote('localhost', 'z', 'tmp'). Error: Code: 81, e.displayText() = DB::Exception: Database z doesn't exist, Stack trace (when copying this message, always include the lines below):\r\n\r\n0. 0x4832817 StackTrace::StackTrace() /home/avtokmakov/ch/ClickHouse/build/../dbms/src/Common/StackTrace.cpp:228\r\n1. 0x8196321 DB::Context::getTableImpl(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, DB::Exception*) const /home/avtokmakov/ch/ClickHouse/build/../dbms/src/Common/Exception.h:0\r\n2. 0x8195ef0 DB::Context::getTable(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&) const /home/avtokmakov/ch/ClickHouse/build/../contrib/libcxx/include/memory:3939\r\n3. 0x85fe35a DB::getStructureOfRemoteTable(DB::Cluster const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, DB::Context const&, std::__1::shared_ptr<DB::IAST> const&) /home/avtokmakov/ch/ClickHouse/build/../contrib/libcxx/include/memory:3933\r\n4. 0x7fb67ee DB::TableFunctionRemote::executeImpl(std::__1::shared_ptr<DB::IAST> const&, DB::Context const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&) const /home/avtokmakov/ch/ClickHouse/build/../contrib/libcxx/include/memory:3939\r\n5. 0x8883153 DB::ITableFunction::execute(std::__1::shared_ptr<DB::IAST> const&, DB::Context const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&) const /home/avtokmakov/ch/ClickHouse/build/../dbms/src/TableFunctions/ITableFunction.cpp:16\r\n6. 0x89aca45 DB::createTableFromAST(DB::ASTCreateQuery, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, DB::Context&, bool) /home/avtokmakov/ch/ClickHouse/build/../contrib/libcxx/include/memory:4520\r\n7. 0x89b5c2b std::__1::__function::__func<DB::DatabaseOrdinary::loadStoredObjects(DB::Context&, bool)::$_1, std::__1::allocator<DB::DatabaseOrdinary::loadStoredObjects(DB::Context&, bool)::$_1>, void ()>::operator()() /home/avtokmakov/ch/ClickHouse/build/../contrib/libcxx/include/string:3073\r\n8. 0x4867296 ThreadPoolImpl<ThreadFromGlobalPool>::worker(std::__1::__list_iterator<ThreadFromGlobalPool, void*>) /home/avtokmakov/ch/ClickHouse/build/../contrib/libcxx/include/atomic:1036\r\n9. 0x48691f8 std::__1::__function::__func<ThreadFromGlobalPool::ThreadFromGlobalPool<void ThreadPoolImpl<ThreadFromGlobalPool>::scheduleImpl<void>(std::__1::function<void ()>, int, std::__1::optional<unsigned long>)::'lambda1'()>(void&&)::'lambda'(), std::__1::allocator<ThreadFromGlobalPool::ThreadFromGlobalPool<void ThreadPoolImpl<ThreadFromGlobalPool>::scheduleImpl<void>(std::__1::function<void ()>, int, std::__1::optional<unsigned long>)::'lambda1'()>(void&&)::'lambda'()>, void ()>::operator()() /home/avtokmakov/ch/ClickHouse/build/../dbms/src/Common/ThreadPool.cpp:0\r\n10. 0x4865526 ThreadPoolImpl<std::__1::thread>::worker(std::__1::__list_iterator<std::__1::thread, void*>) /home/avtokmakov/ch/ClickHouse/build/../contrib/libcxx/include/atomic:1036\r\n11. 0x4868120 void* std::__1::__thread_proxy<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct> >, void ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, int, std::__1::optional<unsigned long>)::'lambda1'()> >(void*) /home/avtokmakov/ch/ClickHouse/build/../contrib/libcxx/include/memory:2648\r\n12. 0x7f55a7f106db start_thread /lib/x86_64-linux-gnu/libpthread-2.27.so\r\n13. 0x7f55a7a3588f clone /build/glibc-OTsEL5/glibc-2.27/misc/../sysdeps/unix/sysv/linux/x86_64/clone.S:97\r\n```\r\n\r\n**Additional context**\r\nTable function `remote(...)` creates `Distributed` storage, which requires columns description. If it cannot get columns description for some reason (table is not loaded yet, or remote server is unavailable now) server fails to start.\r\n\r\nIt cannot be fixed in the way like #8824. Probably we need rewrite CREATE query to add columns description even for table functions\nIssues related to Distributed format of StorageFile\nUnexpected behaviour (table structure is overriden):\r\n```\r\n:) create table d (n UInt64) engine=Distributed('test_shard_localhost2', 'system', 'numbers')\r\nOk.\r\n\r\n:) insert into d values (1)\r\nOk.\r\n\r\n:) create table f (s String) engine=File('Distributed', '/var/lib/clickhouse/data/default/d/default@127%2E0%2E0%2E2:9000/1.bin')\r\nOk.\r\n\r\n:) desc table f\r\n\u250c\u2500name\u2500\u252c\u2500type\u2500\u2500\u2500\u252c\u2500default_type\u2500\u252c\u2500default_expression\u2500\u252c\u2500comment\u2500\u252c\u2500codec_expression\u2500\u252c\u2500ttl_expression\u2500\u2510\r\n\u2502 n    \u2502 UInt64 \u2502              \u2502                    \u2502         \u2502                  \u2502                \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n:) show create table f\r\n\u250c\u2500statement\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 CREATE TABLE default.f\r\n(\r\n    `s` String\r\n)\r\nENGINE = File('Distributed', '/var/lib/clickhouse/data/default/d/default@127%2E0%2E0%2E2:9000/1.bin') \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\r\nconfig.xml:\r\n\r\n<user_files_path>/var/lib/clickhouse/</user_files_path>\r\n\r\n<test_shard_localhost2>\r\n            <shard>\r\n                <replica>\r\n                    <host>127.0.0.2</host>\r\n                    <port>9000</port>\r\n                </replica>\r\n            </shard>\r\n</test_shard_localhost2>\r\n\r\n```\r\n\r\n\r\n\r\nLogical error caused by empty paths list and empty columns list:\r\n```\r\n:) select count() from file('kek*', 'Distributed', 'col UInt8')\r\n\r\n2020.08.28 14:00:04.329971 [ 4338 ] {376d0a69-5a21-4fbf-ad0d-c72786c27531} <Error> : Logical error: 'No available columns'.\r\nclickhouse: ../src/Common/Exception.cpp:45: DB::Exception::Exception(const std::string &, int): Assertion `false' failed.\r\n2020.08.28 14:00:04.330861 [ 4213 ] {} <Trace> BaseDaemon: Received signal 6\r\n2020.08.28 14:00:04.331467 [ 4727 ] {} <Fatal> BaseDaemon: ########################################\r\n2020.08.28 14:00:04.332164 [ 4727 ] {} <Fatal> BaseDaemon: (version 20.8.1.1, build id: 7BF608A90FDC580802F2787C9686E2BF9B8B8690) (from thread 4338) (query_id: 376d0a69-5a21-4fbf-ad0d-c72786c27531) Received signal Aborted (6)\r\n2020.08.28 14:00:04.332568 [ 4727 ] {} <Fatal> BaseDaemon: \r\n2020.08.28 14:00:04.332913 [ 4727 ] {} <Fatal> BaseDaemon: Stack trace: 0x7f38997f7f47 0x7f38997f98b1 0x7f38997e942a 0x7f38997e94a2 0x1a3e33b1 0x2548c0aa 0x24623447 0x246247e6 0x244a72b4 0x244a5843 0x244a472c 0x24520f91 0x2451fc8d 0x2446c235 0x2446b2bf 0x246473a5 0x246465ca 0x24d27e56 0x24d2f2e8 0x2912d2dc 0x2912daec 0x29261953 0x2925e87d 0x2925d708 0x7f3899fbd6db 0x7f38998daa3f\r\n2020.08.28 14:00:04.333414 [ 4727 ] {} <Fatal> BaseDaemon: 4. /build/glibc-2ORdQG/glibc-2.27/signal/../sysdeps/unix/sysv/linux/raise.c:51: raise @ 0x3ef47 in /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.27.so\r\n2020.08.28 14:00:04.333835 [ 4727 ] {} <Fatal> BaseDaemon: 5. /build/glibc-2ORdQG/glibc-2.27/stdlib/abort.c:81: abort @ 0x408b1 in /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.27.so\r\n2020.08.28 14:00:04.334219 [ 4727 ] {} <Fatal> BaseDaemon: 6. /build/glibc-2ORdQG/glibc-2.27/assert/assert.c:89: __assert_fail_base @ 0x3042a in /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.27.so\r\n2020.08.28 14:00:04.334766 [ 4727 ] {} <Fatal> BaseDaemon: 7. ? @ 0x304a2 in /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.27.so\r\n2020.08.28 14:00:04.335421 [ 4727 ] {} <Fatal> BaseDaemon: 8. /home/avtokmakov/ch/ClickHouse/build_debug/../src/Common/Exception.cpp:48: DB::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int) @ 0x1a3e33b1 in /home/avtokmakov/ch/ClickHouse/build_debug/programs/clickhouse\r\n2020.08.28 14:00:04.393163 [ 4727 ] {} <Fatal> BaseDaemon: 9. /home/avtokmakov/ch/ClickHouse/build_debug/../src/Interpreters/ExpressionActions.cpp:729: DB::ExpressionActions::getSmallestColumn(DB::NamesAndTypesList const&) @ 0x2548c0aa in /home/avtokmakov/ch/ClickHouse/build_debug/programs/clickhouse\r\n2020.08.28 14:00:04.441110 [ 4727 ] {} <Fatal> BaseDaemon: 10. /home/avtokmakov/ch/ClickHouse/build_debug/../src/Interpreters/TreeRewriter.cpp:479: DB::TreeRewriterResult::collectUsedColumns(std::__1::shared_ptr<DB::IAST> const&, bool) @ 0x24623447 in /home/avtokmakov/ch/ClickHouse/build_debug/programs/clickhouse\r\n2020.08.28 14:00:04.488405 [ 4727 ] {} <Fatal> BaseDaemon: 11. /home/avtokmakov/ch/ClickHouse/build_debug/../src/Interpreters/TreeRewriter.cpp:619: DB::TreeRewriter::analyzeSelect(std::__1::shared_ptr<DB::IAST>&, DB::TreeRewriterResult&&, DB::SelectQueryOptions const&, std::__1::vector<DB::TableWithColumnNamesAndTypes, std::__1::allocator<DB::TableWithColumnNamesAndTypes> > const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&, std::__1::shared_ptr<DB::TableJoin>) const @ 0x246247e6 in /home/avtokmakov/ch/ClickHouse/build_debug/programs/clickhouse\r\n2020.08.28 14:00:04.536264 [ 4727 ] {} <Fatal> BaseDaemon: 12. /home/avtokmakov/ch/ClickHouse/build_debug/../src/Interpreters/InterpreterSelectQuery.cpp:315: DB::InterpreterSelectQuery::InterpreterSelectQuery(std::__1::shared_ptr<DB::IAST> const&, DB::Context const&, std::__1::shared_ptr<DB::IBlockInputStream> const&, std::__1::optional<DB::Pipe>, std::__1::shared_ptr<DB::IStorage> const&, DB::SelectQueryOptions const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&, std::__1::shared_ptr<DB::StorageInMemoryMetadata const> const&)::$_2::operator()(bool) const @ 0x244a72b4 in /home/avtokmakov/ch/ClickHouse/build_debug/programs/clickhouse\r\n2020.08.28 14:00:04.583845 [ 4727 ] {} <Fatal> BaseDaemon: 13. /home/avtokmakov/ch/ClickHouse/build_debug/../src/Interpreters/InterpreterSelectQuery.cpp:406: DB::InterpreterSelectQuery::InterpreterSelectQuery(std::__1::shared_ptr<DB::IAST> const&, DB::Context const&, std::__1::shared_ptr<DB::IBlockInputStream> const&, std::__1::optional<DB::Pipe>, std::__1::shared_ptr<DB::IStorage> const&, DB::SelectQueryOptions const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&, std::__1::shared_ptr<DB::StorageInMemoryMetadata const> const&) @ 0x244a5843 in /home/avtokmakov/ch/ClickHouse/build_debug/programs/clickhouse\r\n2020.08.28 14:00:04.629967 [ 4727 ] {} <Fatal> BaseDaemon: 14. /home/avtokmakov/ch/ClickHouse/build_debug/../src/Interpreters/InterpreterSelectQuery.cpp:147: DB::InterpreterSelectQuery::InterpreterSelectQuery(std::__1::shared_ptr<DB::IAST> const&, DB::Context const&, DB::SelectQueryOptions const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&) @ 0x244a472c in /home/avtokmakov/ch/ClickHouse/build_debug/programs/clickhouse\r\n2020.08.28 14:00:04.676387 [ 4727 ] {} <Fatal> BaseDaemon: 15. /home/avtokmakov/ch/ClickHouse/build_debug/../contrib/libcxx/include/memory:3028: std::__1::__unique_if<DB::InterpreterSelectQuery>::__unique_single std::__1::make_unique<DB::InterpreterSelectQuery, std::__1::shared_ptr<DB::IAST>&, DB::Context&, DB::SelectQueryOptions&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&>(std::__1::shared_ptr<DB::IAST>&, DB::Context&, DB::SelectQueryOptions&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&) @ 0x24520f91 in /home/avtokmakov/ch/ClickHouse/build_debug/programs/clickhouse\r\n2020.08.28 14:00:04.723045 [ 4727 ] {} <Fatal> BaseDaemon: 16. /home/avtokmakov/ch/ClickHouse/build_debug/../src/Interpreters/InterpreterSelectWithUnionQuery.cpp:84: DB::InterpreterSelectWithUnionQuery::InterpreterSelectWithUnionQuery(std::__1::shared_ptr<DB::IAST> const&, DB::Context const&, DB::SelectQueryOptions const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&) @ 0x2451fc8d in /home/avtokmakov/ch/ClickHouse/build_debug/programs/clickhouse\r\n2020.08.28 14:00:04.769170 [ 4727 ] {} <Fatal> BaseDaemon: 17. /home/avtokmakov/ch/ClickHouse/build_debug/../contrib/libcxx/include/memory:3028: std::__1::__unique_if<DB::InterpreterSelectWithUnionQuery>::__unique_single std::__1::make_unique<DB::InterpreterSelectWithUnionQuery, std::__1::shared_ptr<DB::IAST>&, DB::Context&, DB::SelectQueryOptions>(std::__1::shared_ptr<DB::IAST>&, DB::Context&, DB::SelectQueryOptions&&) @ 0x2446c235 in /home/avtokmakov/ch/ClickHouse/build_debug/programs/clickhouse\r\n2020.08.28 14:00:04.815706 [ 4727 ] {} <Fatal> BaseDaemon: 18. /home/avtokmakov/ch/ClickHouse/build_debug/../src/Interpreters/InterpreterFactory.cpp:107: DB::InterpreterFactory::get(std::__1::shared_ptr<DB::IAST>&, DB::Context&, DB::QueryProcessingStage::Enum) @ 0x2446b2bf in /home/avtokmakov/ch/ClickHouse/build_debug/programs/clickhouse\r\n2020.08.28 14:00:04.863750 [ 4727 ] {} <Fatal> BaseDaemon: 19. /home/avtokmakov/ch/ClickHouse/build_debug/../src/Interpreters/executeQuery.cpp:369: DB::executeQueryImpl(char const*, char const*, DB::Context&, bool, DB::QueryProcessingStage::Enum, bool, DB::ReadBuffer*) @ 0x246473a5 in /home/avtokmakov/ch/ClickHouse/build_debug/programs/clickhouse\r\n2020.08.28 14:00:04.911585 [ 4727 ] {} <Fatal> BaseDaemon: 20. /home/avtokmakov/ch/ClickHouse/build_debug/../src/Interpreters/executeQuery.cpp:675: DB::executeQuery(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, DB::Context&, bool, DB::QueryProcessingStage::Enum, bool) @ 0x246465ca in /home/avtokmakov/ch/ClickHouse/build_debug/programs/clickhouse\r\n2020.08.28 14:00:04.963866 [ 4727 ] {} <Fatal> BaseDaemon: 21. /home/avtokmakov/ch/ClickHouse/build_debug/../src/Server/TCPHandler.cpp:253: DB::TCPHandler::runImpl() @ 0x24d27e56 in /home/avtokmakov/ch/ClickHouse/build_debug/programs/clickhouse\r\n2020.08.28 14:00:05.016646 [ 4727 ] {} <Fatal> BaseDaemon: 22. /home/avtokmakov/ch/ClickHouse/build_debug/../src/Server/TCPHandler.cpp:1213: DB::TCPHandler::run() @ 0x24d2f2e8 in /home/avtokmakov/ch/ClickHouse/build_debug/programs/clickhouse\r\n2020.08.28 14:00:05.083860 [ 4727 ] {} <Fatal> BaseDaemon: 23. /home/avtokmakov/ch/ClickHouse/build_debug/../contrib/poco/Net/src/TCPServerConnection.cpp:43: Poco::Net::TCPServerConnection::start() @ 0x2912d2dc in /home/avtokmakov/ch/ClickHouse/build_debug/programs/clickhouse\r\n2020.08.28 14:00:05.150960 [ 4727 ] {} <Fatal> BaseDaemon: 24. /home/avtokmakov/ch/ClickHouse/build_debug/../contrib/poco/Net/src/TCPServerDispatcher.cpp:114: Poco::Net::TCPServerDispatcher::run() @ 0x2912daec in /home/avtokmakov/ch/ClickHouse/build_debug/programs/clickhouse\r\n2020.08.28 14:00:05.217901 [ 4727 ] {} <Fatal> BaseDaemon: 25. /home/avtokmakov/ch/ClickHouse/build_debug/../contrib/poco/Foundation/src/ThreadPool.cpp:199: Poco::PooledThread::run() @ 0x29261953 in /home/avtokmakov/ch/ClickHouse/build_debug/programs/clickhouse\r\n2020.08.28 14:00:05.284639 [ 4727 ] {} <Fatal> BaseDaemon: 26. /home/avtokmakov/ch/ClickHouse/build_debug/../contrib/poco/Foundation/src/Thread.cpp:56: Poco::(anonymous namespace)::RunnableHolder::run() @ 0x2925e87d in /home/avtokmakov/ch/ClickHouse/build_debug/programs/clickhouse\r\n2020.08.28 14:00:05.352017 [ 4727 ] {} <Fatal> BaseDaemon: 27. /home/avtokmakov/ch/ClickHouse/build_debug/../contrib/poco/Foundation/src/Thread_POSIX.cpp:345: Poco::ThreadImpl::runnableEntry(void*) @ 0x2925d708 in /home/avtokmakov/ch/ClickHouse/build_debug/programs/clickhouse\r\n2020.08.28 14:00:05.352684 [ 4727 ] {} <Fatal> BaseDaemon: 28. start_thread @ 0x76db in /lib/x86_64-linux-gnu/libpthread-2.27.so\r\n2020.08.28 14:00:05.353163 [ 4727 ] {} <Fatal> BaseDaemon: 29. /build/glibc-2ORdQG/glibc-2.27/misc/../sysdeps/unix/sysv/linux/x86_64/clone.S:97: __clone @ 0x121a3f in /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.27.so\r\n```\r\n\r\n\r\nProbably there are some more issues.\n",
  "hints_text": "> Probably we need rewrite CREATE query to add columns description even for table functions\r\n\r\nOk.\n",
  "created_at": "2020-08-31T19:05:12Z"
}