{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 8298,
  "instance_id": "ClickHouse__ClickHouse-8298",
  "issue_numbers": [
    "7556"
  ],
  "base_commit": "0828f86fd926943451bd9c3e352ced847e40c9b2",
  "patch": "diff --git a/dbms/src/Interpreters/AnalyzedJoin.h b/dbms/src/Interpreters/AnalyzedJoin.h\nindex f015dcddfbbc..9503e2c28e9a 100644\n--- a/dbms/src/Interpreters/AnalyzedJoin.h\n+++ b/dbms/src/Interpreters/AnalyzedJoin.h\n@@ -119,6 +119,9 @@ class AnalyzedJoin\n     const NamesAndTypesList & columnsFromJoinedTable() const { return columns_from_joined_table; }\n     const NamesAndTypesList & columnsAddedByJoin() const { return columns_added_by_join; }\n \n+    /// StorageJoin overrides key names (cause of different names qualification)\n+    void setRightKeys(const Names & keys) { key_names_right = keys; }\n+\n     static bool sameJoin(const AnalyzedJoin * x, const AnalyzedJoin * y);\n     friend JoinPtr makeJoin(std::shared_ptr<AnalyzedJoin> table_join, const Block & right_sample_block);\n };\ndiff --git a/dbms/src/Interpreters/ExpressionAnalyzer.cpp b/dbms/src/Interpreters/ExpressionAnalyzer.cpp\nindex 37239e0bd114..fef0b05ae51a 100644\n--- a/dbms/src/Interpreters/ExpressionAnalyzer.cpp\n+++ b/dbms/src/Interpreters/ExpressionAnalyzer.cpp\n@@ -451,10 +451,10 @@ bool SelectQueryExpressionAnalyzer::appendJoin(ExpressionActionsChain & chain, b\n     return true;\n }\n \n-static JoinPtr tryGetStorageJoin(const ASTTablesInSelectQueryElement & join_element, const Context & context)\n+static JoinPtr tryGetStorageJoin(const ASTTablesInSelectQueryElement & join_element, std::shared_ptr<AnalyzedJoin> analyzed_join,\n+                                 const Context & context)\n {\n     const auto & table_to_join = join_element.table_expression->as<ASTTableExpression &>();\n-    auto & join_params = join_element.table_join->as<ASTTableJoin &>();\n \n     /// TODO This syntax does not support specifying a database name.\n     if (table_to_join.database_and_table_name)\n@@ -465,14 +465,8 @@ static JoinPtr tryGetStorageJoin(const ASTTablesInSelectQueryElement & join_elem\n         if (table)\n         {\n             auto * storage_join = dynamic_cast<StorageJoin *>(table.get());\n-\n             if (storage_join)\n-            {\n-                storage_join->assertCompatible(join_params.kind, join_params.strictness);\n-                /// TODO Check the set of keys.\n-\n-                return storage_join->getJoin();\n-            }\n+                return storage_join->getJoin(analyzed_join);\n         }\n     }\n \n@@ -497,7 +491,7 @@ JoinPtr SelectQueryExpressionAnalyzer::makeTableJoin(const ASTTablesInSelectQuer\n \n     /// Special case - if table name is specified on the right of JOIN, then the table has the type Join (the previously prepared mapping).\n     if (!subquery_for_join.join)\n-        subquery_for_join.join = tryGetStorageJoin(join_element, context);\n+        subquery_for_join.join = tryGetStorageJoin(join_element, syntax->analyzed_join, context);\n \n     if (!subquery_for_join.join)\n     {\ndiff --git a/dbms/src/Interpreters/Join.cpp b/dbms/src/Interpreters/Join.cpp\nindex 4da687ac1e40..ff6e2c0690fa 100644\n--- a/dbms/src/Interpreters/Join.cpp\n+++ b/dbms/src/Interpreters/Join.cpp\n@@ -125,6 +125,7 @@ Join::Join(std::shared_ptr<AnalyzedJoin> table_join_, const Block & right_sample\n     , nullable_left_side(table_join->forceNullableLeft())\n     , any_take_last_row(any_take_last_row_)\n     , asof_inequality(table_join->getAsofInequality())\n+    , data(std::make_shared<RightTableData>())\n     , log(&Logger::get(\"Join\"))\n {\n     setSampleBlock(right_sample_block);\n@@ -260,26 +261,26 @@ struct KeyGetterForType\n \n void Join::init(Type type_)\n {\n-    type = type_;\n+    data->type = type_;\n \n     if (kind == ASTTableJoin::Kind::Cross)\n         return;\n-    joinDispatchInit(kind, strictness, maps);\n-    joinDispatch(kind, strictness, maps, [&](auto, auto, auto & map) { map.create(type); });\n+    joinDispatchInit(kind, strictness, data->maps);\n+    joinDispatch(kind, strictness, data->maps, [&](auto, auto, auto & map) { map.create(data->type); });\n }\n \n size_t Join::getTotalRowCount() const\n {\n     size_t res = 0;\n \n-    if (type == Type::CROSS)\n+    if (data->type == Type::CROSS)\n     {\n-        for (const auto & block : blocks)\n+        for (const auto & block : data->blocks)\n             res += block.rows();\n     }\n     else\n     {\n-        joinDispatch(kind, strictness, maps, [&](auto, auto, auto & map) { res += map.getTotalRowCount(type); });\n+        joinDispatch(kind, strictness, data->maps, [&](auto, auto, auto & map) { res += map.getTotalRowCount(data->type); });\n     }\n \n     return res;\n@@ -289,15 +290,15 @@ size_t Join::getTotalByteCount() const\n {\n     size_t res = 0;\n \n-    if (type == Type::CROSS)\n+    if (data->type == Type::CROSS)\n     {\n-        for (const auto & block : blocks)\n+        for (const auto & block : data->blocks)\n             res += block.bytes();\n     }\n     else\n     {\n-        joinDispatch(kind, strictness, maps, [&](auto, auto, auto & map) { res += map.getTotalByteCountImpl(type); });\n-        res += pool.size();\n+        joinDispatch(kind, strictness, data->maps, [&](auto, auto, auto & map) { res += map.getTotalByteCountImpl(data->type); });\n+        res += data->pool.size();\n     }\n \n     return res;\n@@ -482,6 +483,8 @@ void Join::initRequiredRightKeys()\n \n void Join::initRightBlockStructure()\n {\n+    auto & saved_block_sample = data->sample_block;\n+\n     if (isRightOrFull(kind))\n     {\n         /// Save keys for NonJoinedBlockInputStream\n@@ -504,7 +507,7 @@ void Join::initRightBlockStructure()\n Block Join::structureRightBlock(const Block & block) const\n {\n     Block structured_block;\n-    for (auto & sample_column : saved_block_sample.getColumnsWithTypeAndName())\n+    for (auto & sample_column : savedBlockSample().getColumnsWithTypeAndName())\n     {\n         ColumnWithTypeAndName column = block.getByName(sample_column.name);\n         if (sample_column.column->isNullable())\n@@ -543,24 +546,24 @@ bool Join::addJoinedBlock(const Block & source_block)\n     size_t total_bytes = 0;\n \n     {\n-        std::unique_lock lock(rwlock);\n+        std::unique_lock lock(data->rwlock);\n \n-        blocks.emplace_back(std::move(structured_block));\n-        Block * stored_block = &blocks.back();\n+        data->blocks.emplace_back(std::move(structured_block));\n+        Block * stored_block = &data->blocks.back();\n \n         if (rows)\n-            has_no_rows_in_maps = false;\n+            data->empty = false;\n \n         if (kind != ASTTableJoin::Kind::Cross)\n         {\n-            joinDispatch(kind, strictness, maps, [&](auto, auto strictness_, auto & map)\n+            joinDispatch(kind, strictness, data->maps, [&](auto, auto strictness_, auto & map)\n             {\n-                insertFromBlockImpl<strictness_>(*this, type, map, rows, key_columns, key_sizes, stored_block, null_map, pool);\n+                insertFromBlockImpl<strictness_>(*this, data->type, map, rows, key_columns, key_sizes, stored_block, null_map, data->pool);\n             });\n         }\n \n         if (save_nullmap)\n-            blocks_nullmaps.emplace_back(stored_block, null_map_holder);\n+            data->blocks_nullmaps.emplace_back(stored_block, null_map_holder);\n \n         /// TODO: Do not calculate them every time\n         total_rows = getTotalRowCount();\n@@ -915,12 +918,12 @@ void Join::joinBlockImpl(\n     if constexpr (is_asof_join)\n         extras.push_back(right_table_keys.getByName(key_names_right.back()));\n \n-    AddedColumns added_columns(sample_block_with_columns_to_add, block_with_columns_to_add, block, saved_block_sample,\n+    AddedColumns added_columns(sample_block_with_columns_to_add, block_with_columns_to_add, block, savedBlockSample(),\n                                extras, *this, key_columns, key_sizes);\n     bool has_required_right_keys = (required_right_keys.columns() != 0);\n     added_columns.need_filter = need_filter || has_required_right_keys;\n \n-    IColumn::Filter row_filter = switchJoinRightColumns<KIND, STRICTNESS>(maps_, added_columns, type, null_map);\n+    IColumn::Filter row_filter = switchJoinRightColumns<KIND, STRICTNESS>(maps_, added_columns, data->type, null_map);\n \n     for (size_t i = 0; i < added_columns.size(); ++i)\n         block.insert(added_columns.moveColumn(i));\n@@ -1012,7 +1015,7 @@ void Join::joinBlockImplCross(Block & block) const\n \n     for (size_t i = 0; i < rows_left; ++i)\n     {\n-        for (const Block & block_right : blocks)\n+        for (const Block & block_right : data->blocks)\n         {\n             size_t rows_right = block_right.rows();\n \n@@ -1050,7 +1053,7 @@ static void checkTypeOfKey(const Block & block_left, const Block & block_right)\n \n DataTypePtr Join::joinGetReturnType(const String & column_name) const\n {\n-    std::shared_lock lock(rwlock);\n+    std::shared_lock lock(data->rwlock);\n \n     if (!sample_block_with_columns_to_add.has(column_name))\n         throw Exception(\"StorageJoin doesn't contain column \" + column_name, ErrorCodes::LOGICAL_ERROR);\n@@ -1071,7 +1074,7 @@ void Join::joinGetImpl(Block & block, const String & column_name, const Maps & m\n // TODO: return array of values when strictness == ASTTableJoin::Strictness::All\n void Join::joinGet(Block & block, const String & column_name) const\n {\n-    std::shared_lock lock(rwlock);\n+    std::shared_lock lock(data->rwlock);\n \n     if (key_names_right.size() != 1)\n         throw Exception(\"joinGet only supports StorageJoin containing exactly one key\", ErrorCodes::LOGICAL_ERROR);\n@@ -1081,7 +1084,7 @@ void Join::joinGet(Block & block, const String & column_name) const\n     if ((strictness == ASTTableJoin::Strictness::Any || strictness == ASTTableJoin::Strictness::RightAny) &&\n         kind == ASTTableJoin::Kind::Left)\n     {\n-        joinGetImpl(block, column_name, std::get<MapsOne>(maps));\n+        joinGetImpl(block, column_name, std::get<MapsOne>(data->maps));\n     }\n     else\n         throw Exception(\"joinGet only supports StorageJoin of type Left Any\", ErrorCodes::LOGICAL_ERROR);\n@@ -1090,12 +1093,12 @@ void Join::joinGet(Block & block, const String & column_name) const\n \n void Join::joinBlock(Block & block)\n {\n-    std::shared_lock lock(rwlock);\n+    std::shared_lock lock(data->rwlock);\n \n     const Names & key_names_left = table_join->keyNamesLeft();\n     JoinCommon::checkTypesOfKeys(block, key_names_left, right_table_keys, key_names_right);\n \n-    if (joinDispatch(kind, strictness, maps, [&](auto kind_, auto strictness_, auto & map)\n+    if (joinDispatch(kind, strictness, data->maps, [&](auto kind_, auto strictness_, auto & map)\n         {\n             joinBlockImpl<kind_, strictness_>(block, key_names_left, sample_block_with_columns_to_add, map);\n         }))\n@@ -1172,7 +1175,7 @@ class NonJoinedBlockInputStream : public IBlockInputStream\n             const String & right_key_name = parent.table_join->keyNamesRight()[i];\n \n             size_t left_key_pos = result_sample_block.getPositionByName(left_key_name);\n-            size_t right_key_pos = parent.saved_block_sample.getPositionByName(right_key_name);\n+            size_t right_key_pos = parent.savedBlockSample().getPositionByName(right_key_name);\n \n             if (remap_keys && !parent.required_right_keys.has(right_key_name))\n                 left_to_right_key_remap[left_key_pos] = right_key_pos;\n@@ -1194,9 +1197,10 @@ class NonJoinedBlockInputStream : public IBlockInputStream\n                 column_indices_left.emplace_back(left_pos);\n         }\n \n-        for (size_t right_pos = 0; right_pos < parent.saved_block_sample.columns(); ++right_pos)\n+        const auto & saved_block_sample = parent.savedBlockSample();\n+        for (size_t right_pos = 0; right_pos < saved_block_sample.columns(); ++right_pos)\n         {\n-            const String & name = parent.saved_block_sample.getByPosition(right_pos).name;\n+            const String & name = saved_block_sample.getByPosition(right_pos).name;\n             if (!result_sample_block.has(name))\n                 continue;\n \n@@ -1225,7 +1229,7 @@ class NonJoinedBlockInputStream : public IBlockInputStream\n protected:\n     Block readImpl() override\n     {\n-        if (parent.blocks.empty())\n+        if (parent.data->blocks.empty())\n             return Block();\n         return createBlock();\n     }\n@@ -1262,14 +1266,14 @@ class NonJoinedBlockInputStream : public IBlockInputStream\n \n     bool hasNullabilityChange(size_t right_pos, size_t result_pos) const\n     {\n-        const auto & src = parent.saved_block_sample.getByPosition(right_pos).column;\n+        const auto & src = parent.savedBlockSample().getByPosition(right_pos).column;\n         const auto & dst = result_sample_block.getByPosition(result_pos).column;\n         return src->isNullable() != dst->isNullable();\n     }\n \n     Block createBlock()\n     {\n-        MutableColumns columns_right = parent.saved_block_sample.cloneEmptyColumns();\n+        MutableColumns columns_right = parent.savedBlockSample().cloneEmptyColumns();\n \n         size_t rows_added = 0;\n \n@@ -1278,7 +1282,7 @@ class NonJoinedBlockInputStream : public IBlockInputStream\n             rows_added = fillColumnsFromMap<strictness>(map, columns_right);\n         };\n \n-        if (!joinDispatch(parent.kind, parent.strictness, parent.maps, fill_callback))\n+        if (!joinDispatch(parent.kind, parent.strictness, parent.data->maps, fill_callback))\n             throw Exception(\"Logical error: unknown JOIN strictness (must be on of: ANY, ALL, ASOF)\", ErrorCodes::LOGICAL_ERROR);\n \n         fillNullsFromBlocks(columns_right, rows_added);\n@@ -1329,7 +1333,7 @@ class NonJoinedBlockInputStream : public IBlockInputStream\n     template <ASTTableJoin::Strictness STRICTNESS, typename Maps>\n     size_t fillColumnsFromMap(const Maps & maps, MutableColumns & columns_keys_and_right)\n     {\n-        switch (parent.type)\n+        switch (parent.data->type)\n         {\n         #define M(TYPE) \\\n             case Join::Type::TYPE: \\\n@@ -1337,7 +1341,7 @@ class NonJoinedBlockInputStream : public IBlockInputStream\n             APPLY_FOR_JOIN_VARIANTS(M)\n         #undef M\n             default:\n-                throw Exception(\"Unsupported JOIN keys. Type: \" + toString(static_cast<UInt32>(parent.type)),\n+                throw Exception(\"Unsupported JOIN keys. Type: \" + toString(static_cast<UInt32>(parent.data->type)),\n                                 ErrorCodes::UNSUPPORTED_JOIN_KEYS);\n         }\n \n@@ -1380,9 +1384,9 @@ class NonJoinedBlockInputStream : public IBlockInputStream\n     void fillNullsFromBlocks(MutableColumns & columns_keys_and_right, size_t & rows_added)\n     {\n         if (!nulls_position.has_value())\n-            nulls_position = parent.blocks_nullmaps.begin();\n+            nulls_position = parent.data->blocks_nullmaps.begin();\n \n-        auto end = parent.blocks_nullmaps.end();\n+        auto end = parent.data->blocks_nullmaps.end();\n \n         for (auto & it = *nulls_position; it != end && rows_added < max_block_size; ++it)\n         {\ndiff --git a/dbms/src/Interpreters/Join.h b/dbms/src/Interpreters/Join.h\nindex ff46380db134..378bc2ef51a3 100644\n--- a/dbms/src/Interpreters/Join.h\n+++ b/dbms/src/Interpreters/Join.h\n@@ -148,7 +148,7 @@ class Join : public IJoin\n public:\n     Join(std::shared_ptr<AnalyzedJoin> table_join_, const Block & right_sample_block, bool any_take_last_row_ = false);\n \n-    bool empty() { return type == Type::EMPTY; }\n+    bool empty() { return data->type == Type::EMPTY; }\n \n     /** Add block of data from right hand of JOIN to the map.\n       * Returns false, if some limit was exceeded and you should not insert more data.\n@@ -185,7 +185,7 @@ class Join : public IJoin\n     /// Sum size in bytes of all buffers, used for JOIN maps and for all memory pools.\n     size_t getTotalByteCount() const;\n \n-    bool alwaysReturnsEmptySet() const final { return isInnerOrRight(getKind()) && has_no_rows_in_maps; }\n+    bool alwaysReturnsEmptySet() const final { return isInnerOrRight(getKind()) && data->empty; }\n \n     ASTTableJoin::Kind getKind() const { return kind; }\n     ASTTableJoin::Strictness getStrictness() const { return strictness; }\n@@ -294,6 +294,30 @@ class Join : public IJoin\n     using MapsAsof =            MapsTemplate<JoinStuff::MappedAsof>;\n \n     using MapsVariant = std::variant<MapsOne, MapsAll, MapsOneFlagged, MapsAllFlagged, MapsAsof>;\n+    using BlockNullmapList = std::deque<std::pair<const Block *, ColumnPtr>>;\n+\n+    struct RightTableData\n+    {\n+        /// Protect state for concurrent use in insertFromBlock and joinBlock.\n+        /// @note that these methods could be called simultaneously only while use of StorageJoin.\n+        mutable std::shared_mutex rwlock;\n+\n+        Type type = Type::EMPTY;\n+        bool empty = true;\n+\n+        MapsVariant maps;\n+        Block sample_block; /// Block as it would appear in the BlockList\n+        BlocksList blocks; /// Blocks of \"right\" table.\n+        BlockNullmapList blocks_nullmaps; /// Nullmaps for blocks of \"right\" table (if needed)\n+\n+        /// Additional data - strings for string keys and continuation elements of single-linked lists of references to rows.\n+        Arena pool;\n+    };\n+\n+    void reuseJoinedData(const Join & join)\n+    {\n+        data = join.data;\n+    }\n \n private:\n     friend class NonJoinedBlockInputStream;\n@@ -306,33 +330,14 @@ class Join : public IJoin\n     /// Names of key columns in right-side table (in the order they appear in ON/USING clause). @note It could contain duplicates.\n     const Names & key_names_right;\n \n-    /// In case of LEFT and FULL joins, if use_nulls, convert right-side columns to Nullable.\n-    bool nullable_right_side;\n-    /// In case of RIGHT and FULL joins, if use_nulls, convert left-side columns to Nullable.\n-    bool nullable_left_side;\n-\n-    /// Overwrite existing values when encountering the same key again\n-    bool any_take_last_row;\n-\n-    /// Blocks of \"right\" table.\n-    BlocksList blocks;\n-\n-    /// Nullmaps for blocks of \"right\" table (if needed)\n-    using BlockNullmapList = std::deque<std::pair<const Block *, ColumnPtr>>;\n-    BlockNullmapList blocks_nullmaps;\n-\n-    MapsVariant maps;\n-    bool has_no_rows_in_maps = true;\n-\n-    /// Additional data - strings for string keys and continuation elements of single-linked lists of references to rows.\n-    Arena pool;\n-\n-    Type type = Type::EMPTY;\n+    bool nullable_right_side; /// In case of LEFT and FULL joins, if use_nulls, convert right-side columns to Nullable.\n+    bool nullable_left_side; /// In case of RIGHT and FULL joins, if use_nulls, convert left-side columns to Nullable.\n+    bool any_take_last_row; /// Overwrite existing values when encountering the same key again\n     std::optional<AsofRowRefs::Type> asof_type;\n     ASOF::Inequality asof_inequality;\n \n-    static Type chooseMethod(const ColumnRawPtrs & key_columns, Sizes & key_sizes);\n-\n+    /// Right table data. StorageJoin shares it between many Join objects.\n+    std::shared_ptr<RightTableData> data;\n     Sizes key_sizes;\n \n     /// Block with columns from the right-side table except key columns.\n@@ -344,26 +349,18 @@ class Join : public IJoin\n     /// Left table column names that are sources for required_right_keys columns\n     std::vector<String> required_right_keys_sources;\n \n-    /// Block as it would appear in the BlockList\n-    Block saved_block_sample;\n-\n     Poco::Logger * log;\n \n     Block totals;\n \n-    /** Protect state for concurrent use in insertFromBlock and joinBlock.\n-      * Note that these methods could be called simultaneously only while use of StorageJoin,\n-      *  and StorageJoin only calls these two methods.\n-      * That's why another methods are not guarded.\n-      */\n-    mutable std::shared_mutex rwlock;\n-\n     void init(Type type_);\n \n     /** Set information about structure of right hand of JOIN (joined data).\n       */\n     void setSampleBlock(const Block & block);\n \n+    const Block & savedBlockSample() const { return data->sample_block; }\n+\n     /// Modify (structure) right block to save it in block list\n     Block structureRightBlock(const Block & stored_block) const;\n     void initRightBlockStructure();\n@@ -380,6 +377,8 @@ class Join : public IJoin\n \n     template <typename Maps>\n     void joinGetImpl(Block & block, const String & column_name, const Maps & maps) const;\n+\n+    static Type chooseMethod(const ColumnRawPtrs & key_columns, Sizes & key_sizes);\n };\n \n }\ndiff --git a/dbms/src/Storages/StorageJoin.cpp b/dbms/src/Storages/StorageJoin.cpp\nindex 12444867b6b8..5e1e16cfa6ab 100644\n--- a/dbms/src/Storages/StorageJoin.cpp\n+++ b/dbms/src/Storages/StorageJoin.cpp\n@@ -67,11 +67,19 @@ void StorageJoin::truncate(const ASTPtr &, const Context &, TableStructureWriteL\n }\n \n \n-void StorageJoin::assertCompatible(ASTTableJoin::Kind kind_, ASTTableJoin::Strictness strictness_) const\n+HashJoinPtr StorageJoin::getJoin(std::shared_ptr<AnalyzedJoin> analyzed_join) const\n {\n-    /// NOTE Could be more loose.\n-    if (!(kind == kind_ && strictness == strictness_))\n+    if (!(kind == analyzed_join->kind() && strictness == analyzed_join->strictness()))\n         throw Exception(\"Table \" + table_name + \" has incompatible type of JOIN.\", ErrorCodes::INCOMPATIBLE_TYPE_OF_JOIN);\n+\n+    /// TODO: check key columns\n+\n+    /// Some HACK to remove wrong names qualifiers: table.column -> column.\n+    analyzed_join->setRightKeys(key_names);\n+\n+    HashJoinPtr join_clone = std::make_shared<Join>(analyzed_join, getSampleBlock().sortColumns());\n+    join_clone->reuseJoinedData(*join);\n+    return join_clone;\n }\n \n \n@@ -201,7 +209,7 @@ class JoinBlockInputStream : public IBlockInputStream\n {\n public:\n     JoinBlockInputStream(const Join & parent_, UInt64 max_block_size_, Block && sample_block_)\n-        : parent(parent_), lock(parent.rwlock), max_block_size(max_block_size_), sample_block(std::move(sample_block_))\n+        : parent(parent_), lock(parent.data->rwlock), max_block_size(max_block_size_), sample_block(std::move(sample_block_))\n     {\n         columns.resize(sample_block.columns());\n         column_indices.resize(sample_block.columns());\n@@ -231,11 +239,11 @@ class JoinBlockInputStream : public IBlockInputStream\n protected:\n     Block readImpl() override\n     {\n-        if (parent.blocks.empty())\n+        if (parent.data->blocks.empty())\n             return Block();\n \n         Block block;\n-        if (!joinDispatch(parent.kind, parent.strictness, parent.maps,\n+        if (!joinDispatch(parent.kind, parent.strictness, parent.data->maps,\n                 [&](auto, auto strictness, auto & map) { block = createBlock<strictness>(map); }))\n             throw Exception(\"Logical error: unknown JOIN strictness (must be ANY or ALL)\", ErrorCodes::LOGICAL_ERROR);\n         return block;\n@@ -278,7 +286,7 @@ class JoinBlockInputStream : public IBlockInputStream\n \n         size_t rows_added = 0;\n \n-        switch (parent.type)\n+        switch (parent.data->type)\n         {\n #define M(TYPE)                                           \\\n     case Join::Type::TYPE:                                \\\n@@ -288,7 +296,7 @@ class JoinBlockInputStream : public IBlockInputStream\n #undef M\n \n             default:\n-                throw Exception(\"Unsupported JOIN keys in StorageJoin. Type: \" + toString(static_cast<UInt32>(parent.type)),\n+                throw Exception(\"Unsupported JOIN keys in StorageJoin. Type: \" + toString(static_cast<UInt32>(parent.data->type)),\n                                 ErrorCodes::UNSUPPORTED_JOIN_KEYS);\n         }\n \ndiff --git a/dbms/src/Storages/StorageJoin.h b/dbms/src/Storages/StorageJoin.h\nindex cfafd118768d..ab974a07bfad 100644\n--- a/dbms/src/Storages/StorageJoin.h\n+++ b/dbms/src/Storages/StorageJoin.h\n@@ -31,6 +31,7 @@ class StorageJoin : public ext::shared_ptr_helper<StorageJoin>, public StorageSe\n \n     /// Access the innards.\n     HashJoinPtr & getJoin() { return join; }\n+    HashJoinPtr getJoin(std::shared_ptr<AnalyzedJoin> analyzed_join) const;\n \n     /// Verify that the data structure is suitable for implementing this type of JOIN.\n     void assertCompatible(ASTTableJoin::Kind kind_, ASTTableJoin::Strictness strictness_) const;\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/01050_engine_join_crash.reference b/dbms/tests/queries/0_stateless/01050_engine_join_crash.reference\nnew file mode 100644\nindex 000000000000..f1a4d615cc01\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01050_engine_join_crash.reference\n@@ -0,0 +1,12 @@\n+1\t1\n+2\t2\n+3\t3\n+1\t1\n+2\t2\n+3\t3\n+3\t3\n+2\t2\n+1\t1\n+-\n+1\t52.5\tONE\n+-\ndiff --git a/dbms/tests/queries/0_stateless/01050_engine_join_crash.sql b/dbms/tests/queries/0_stateless/01050_engine_join_crash.sql\nnew file mode 100644\nindex 000000000000..e95ab3e5022a\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01050_engine_join_crash.sql\n@@ -0,0 +1,44 @@\n+DROP TABLE IF EXISTS testJoinTable;\n+\n+CREATE TABLE testJoinTable (number UInt64, data String) ENGINE = Join(ANY, INNER, number);\n+\n+INSERT INTO testJoinTable VALUES (1, '1'), (2, '2'), (3, '3');\n+\n+SELECT * FROM (SELECT * FROM numbers(10)) INNER JOIN testJoinTable USING number;\n+SELECT * FROM (SELECT * FROM numbers(10)) INNER JOIN (SELECT * FROM testJoinTable) USING number;\n+SELECT * FROM testJoinTable;\n+\n+DROP TABLE testJoinTable;\n+\n+SELECT '-';\n+\n+SET any_join_distinct_right_table_keys = 1;\n+ \n+DROP TABLE IF EXISTS master;\n+DROP TABLE IF EXISTS transaction;\n+\n+CREATE TABLE transaction (id Int32, value Float64, master_id Int32) ENGINE = MergeTree() ORDER BY id;\n+CREATE TABLE master (id Int32, name String) ENGINE = Join (ANY, LEFT, id);\n+\n+INSERT INTO master VALUES (1, 'ONE');\n+INSERT INTO transaction VALUES (1, 52.5, 1);\n+\n+SELECT tx.id, tx.value, m.name FROM transaction tx ANY LEFT JOIN master m ON m.id = tx.master_id;\n+\n+DROP TABLE master;\n+DROP TABLE transaction;\n+\n+SELECT '-';\n+\n+DROP TABLE IF EXISTS some_join;\n+DROP TABLE IF EXISTS tbl;\n+\n+CREATE TABLE tbl (eventDate Date, id String) ENGINE = MergeTree() PARTITION BY tuple() ORDER BY eventDate;\n+CREATE TABLE some_join (id String, value String) ENGINE = Join(ANY, LEFT, id);\n+\n+SELECT * FROM tbl AS t ANY LEFT JOIN some_join USING (id);\n+SELECT * FROM tbl AS t ANY LEFT JOIN some_join AS d USING (id);\n+-- TODO SELECT t.*, d.* FROM tbl AS t ANY LEFT JOIN some_join AS d USING (id);\n+\n+DROP TABLE some_join;\n+DROP TABLE tbl;\n",
  "problem_statement": "Engine JOIN crashes ClickHouse v19.15.3.6\n1. \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0442\u0430\u0431\u043b\u0438\u0446\u044b\r\n```sql\r\nCREATE TABLE `default`.`testJoinTable`\r\n(\r\n    number UInt64,\r\n    data   String\r\n)\r\nENGINE = Join(ALL, INNER, number);\r\n\u200b\r\nINSERT INTO `default`.`testJoinTable`\r\nVALUES\r\n   (1, '1'),\r\n   (2, '2'),\r\n   (3, '3');\r\n```\r\n\r\n2. \u0417\u0430\u043f\u0440\u043e\u0441, \u0432\u044b\u0437\u044b\u0432\u0430\u044e\u0449\u0438\u0439 \u043e\u0448\u0438\u0431\u043a\u0443\r\n```sql\r\nSELECT *\r\nFROM (SELECT * FROM `system`.`numbers` LIMIT 10)\r\nALL INNER JOIN `default`.`testJoinTable` USING `number`\r\n```\r\n\r\n3. \u0417\u0430\u043f\u0440\u043e\u0441, \u043d\u0435 \u0432\u044b\u0437\u044b\u0432\u0430\u044e\u0449\u0438\u0439 \u043e\u0448\u0438\u0431\u043a\u0443\r\n```sql\r\nSELECT *\r\nFROM (SELECT * FROM `system`.`numbers` LIMIT 10)\r\nALL INNER JOIN (SELECT * FROM `default`.`testJoinTable`) USING `number`\r\n```\r\n\r\n4. \u041f\u0440\u0438 \u044d\u0442\u043e\u043c \u043c\u043e\u0436\u043d\u043e \u0441\u0434\u0435\u043b\u0430\u0442\u044c \u0442\u0430\u043a, \u0445\u043e\u0442\u044f \u0434\u043b\u044f JOIN \u0442\u0430\u0431\u043b\u0438\u0446 \u044d\u0442\u043e \u0434\u043e\u043b\u0436\u043d\u043e \u0431\u044b\u0442\u044c \u0437\u0430\u043f\u0440\u0435\u0449\u0435\u043d\u043e\r\n```sql\r\nSELECT  * FROM `default`.`testJoinTable` \r\n```\r\n\r\n5. stacktrace\r\n```\r\n2019.10.31 13:15:40.960123 [ 109 ] {} <Fatal> BaseDaemon: ########################################\r\n2019.10.31 13:15:40.960256 [ 109 ] {} <Fatal> BaseDaemon: (version 19.15.3.6 (official build)) (from thread 103) Received signal Segmentation fault (11).\r\n2019.10.31 13:15:40.960305 [ 109 ] {} <Fatal> BaseDaemon: Address: NULL pointer. Access: read. Address not mapped to object.\r\n2019.10.31 13:15:40.960358 [ 109 ] {} <Fatal> BaseDaemon: Stack trace: 0x55f42afa813a 0x55f42afd4cc7 0x55f42af7f4fd 0x55f42b64e380 0x55f42b64f335 0x55f42b4e8c0d 0x55f42af5ad3e 0x55f42af3cc25 0x55f42af5c283 0x55f42af5e188 0x55f42b067006 0x55f42b0684dc 0x55f427cb882e 0x55f427cbaba9 0x55f42bae4e49 0x55f42bae13c0 0x55f42bae1add 0x55f42d16b901 0x55f42d1696ac 0x55f42d8deeb0 0x7f752c3c56db 0x7f752bce288f\r\n2019.10.31 13:15:40.960441 [ 109 ] {} <Fatal> BaseDaemon: 3. 0x55f42afa813a ? /usr/bin/clickhouse\r\n2019.10.31 13:15:40.960561 [ 109 ] {} <Fatal> BaseDaemon: 4. 0x55f42afd4cc7 void DB::Join::joinBlockImpl<(DB::ASTTableJoin::Kind)0, (DB::ASTTableJoin::Strictness)2, DB::Join::MapsTemplate<DB::JoinStuff::WithFlags<DB::RowRefList, false> > >(DB::Block&, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&, DB::Block const&, DB::Join::MapsTemplate<DB::JoinStuff::WithFlags<DB::RowRefList, false> > const&) const /usr/bin/clickhouse\r\n2019.10.31 13:15:40.960616 [ 109 ] {} <Fatal> BaseDaemon: 5. 0x55f42af7f4fd DB::Join::joinBlock(DB::Block&) /usr/bin/clickhouse\r\n2019.10.31 13:15:40.960662 [ 109 ] {} <Fatal> BaseDaemon: 6. 0x55f42b64e380 DB::ExpressionAction::execute(DB::Block&, bool) const /usr/bin/clickhouse\r\n2019.10.31 13:15:40.960701 [ 109 ] {} <Fatal> BaseDaemon: 7. 0x55f42b64f335 DB::ExpressionActions::execute(DB::Block&, bool) const /usr/bin/clickhouse\r\n2019.10.31 13:15:40.960763 [ 109 ] {} <Fatal> BaseDaemon: 8. 0x55f42b4e8c0d DB::ExpressionBlockInputStream::ExpressionBlockInputStream(std::shared_ptr<DB::IBlockInputStream> const&, std::shared_ptr<DB::ExpressionActions> const&) /usr/bin/clickhouse\r\n2019.10.31 13:15:40.960815 [ 109 ] {} <Fatal> BaseDaemon: 9. 0x55f42af5ad3e void DB::InterpreterSelectQuery::executeImpl<DB::InterpreterSelectQuery::Pipeline>(DB::InterpreterSelectQuery::Pipeline&, std::shared_ptr<DB::IBlockInputStream> const&) /usr/bin/clickhouse\r\n2019.10.31 13:15:40.960856 [ 109 ] {} <Fatal> BaseDaemon: 10. 0x55f42af3cc25 DB::InterpreterSelectQuery::executeWithMultipleStreams() /usr/bin/clickhouse\r\n2019.10.31 13:15:40.960893 [ 109 ] {} <Fatal> BaseDaemon: 11. 0x55f42af5c283 DB::InterpreterSelectWithUnionQuery::executeWithMultipleStreams() /usr/bin/clickhouse\r\n2019.10.31 13:15:40.960930 [ 109 ] {} <Fatal> BaseDaemon: 12. 0x55f42af5e188 DB::InterpreterSelectWithUnionQuery::execute() /usr/bin/clickhouse\r\n2019.10.31 13:15:40.960964 [ 109 ] {} <Fatal> BaseDaemon: 13. 0x55f42b067006 ? /usr/bin/clickhouse\r\n2019.10.31 13:15:40.961017 [ 109 ] {} <Fatal> BaseDaemon: 14. 0x55f42b0684dc DB::executeQuery(DB::ReadBuffer&, DB::WriteBuffer&, bool, DB::Context&, std::function<void (std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)>, std::function<void (std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)>) /usr/bin/clickhouse\r\n2019.10.31 13:15:40.961075 [ 109 ] {} <Fatal> BaseDaemon: 15. 0x55f427cb882e DB::HTTPHandler::processQuery(Poco::Net::HTTPServerRequest&, HTMLForm&, Poco::Net::HTTPServerResponse&, DB::HTTPHandler::Output&) /usr/bin/clickhouse\r\n2019.10.31 13:15:40.961119 [ 109 ] {} <Fatal> BaseDaemon: 16. 0x55f427cbaba9 DB::HTTPHandler::handleRequest(Poco::Net::HTTPServerRequest&, Poco::Net::HTTPServerResponse&) /usr/bin/clickhouse\r\n2019.10.31 13:15:40.961159 [ 109 ] {} <Fatal> BaseDaemon: 17. 0x55f42bae4e49 Poco::Net::HTTPServerConnection::run() /usr/bin/clickhouse\r\n2019.10.31 13:15:40.961196 [ 109 ] {} <Fatal> BaseDaemon: 18. 0x55f42bae13c0 Poco::Net::TCPServerConnection::start() /usr/bin/clickhouse\r\n2019.10.31 13:15:40.961233 [ 109 ] {} <Fatal> BaseDaemon: 19. 0x55f42bae1add Poco::Net::TCPServerDispatcher::run() /usr/bin/clickhouse\r\n2019.10.31 13:15:40.961280 [ 109 ] {} <Fatal> BaseDaemon: 20. 0x55f42d16b901 Poco::PooledThread::run() /usr/bin/clickhouse\r\n2019.10.31 13:15:40.961318 [ 109 ] {} <Fatal> BaseDaemon: 21. 0x55f42d1696ac Poco::ThreadImpl::runnableEntry(void*) /usr/bin/clickhouse\r\n2019.10.31 13:15:40.961354 [ 109 ] {} <Fatal> BaseDaemon: 22. 0x55f42d8deeb0 ? /usr/bin/clickhouse\r\n2019.10.31 13:15:40.961399 [ 109 ] {} <Fatal> BaseDaemon: 23. 0x7f752c3c56db start_thread /lib/x86_64-linux-gnu/libpthread-2.27.so\r\n2019.10.31 13:15:40.961443 [ 109 ] {} <Fatal> BaseDaemon: 24. 0x7f752bce288f clone /lib/x86_64-linux-gnu/libc-2.27.so\r\n```\n",
  "hints_text": "\u0412 v19.16.2.2 \u043e\u0448\u0438\u0431\u043a\u0430 \u043d\u0435 \u0438\u0441\u043f\u0440\u0430\u0432\u0438\u043b\u0430\u0441\u044c",
  "created_at": "2019-12-19T15:53:15Z",
  "modified_files": [
    "dbms/src/Interpreters/AnalyzedJoin.h",
    "dbms/src/Interpreters/ExpressionAnalyzer.cpp",
    "dbms/src/Interpreters/Join.cpp",
    "dbms/src/Interpreters/Join.h",
    "dbms/src/Storages/StorageJoin.cpp",
    "dbms/src/Storages/StorageJoin.h"
  ],
  "modified_test_files": [
    "b/dbms/tests/queries/0_stateless/01050_engine_join_crash.reference",
    "b/dbms/tests/queries/0_stateless/01050_engine_join_crash.sql"
  ]
}