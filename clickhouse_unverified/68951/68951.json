{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 68951,
  "instance_id": "ClickHouse__ClickHouse-68951",
  "issue_numbers": [
    "68904"
  ],
  "base_commit": "e0dc32bc61cf34ee899f885612bc6321c4448514",
  "patch": "diff --git a/src/Analyzer/Passes/FunctionToSubcolumnsPass.cpp b/src/Analyzer/Passes/FunctionToSubcolumnsPass.cpp\nindex 1fc3eec68338..6f1c39378801 100644\n--- a/src/Analyzer/Passes/FunctionToSubcolumnsPass.cpp\n+++ b/src/Analyzer/Passes/FunctionToSubcolumnsPass.cpp\n@@ -209,7 +209,7 @@ std::map<std::pair<TypeIndex, String>, NodeToSubcolumnTransformer> node_transfor\n     },\n };\n \n-std::tuple<FunctionNode *, ColumnNode *, TableNode *> getTypedNodesForOptimization(const QueryTreeNodePtr & node)\n+std::tuple<FunctionNode *, ColumnNode *, TableNode *> getTypedNodesForOptimization(const QueryTreeNodePtr & node, const ContextPtr & context)\n {\n     auto * function_node = node->as<FunctionNode>();\n     if (!function_node)\n@@ -232,6 +232,12 @@ std::tuple<FunctionNode *, ColumnNode *, TableNode *> getTypedNodesForOptimizati\n     const auto & storage_snapshot = table_node->getStorageSnapshot();\n     auto column = first_argument_column_node->getColumn();\n \n+    /// If view source is set we cannot optimize because it doesn't support moving functions to subcolumns.\n+    /// The storage is replaced to the view source but it happens only after building a query tree and applying passes.\n+    auto view_source = context->getViewSource();\n+    if (view_source && view_source->getStorageID().getFullNameNotQuoted() == storage->getStorageID().getFullNameNotQuoted())\n+        return {};\n+\n     if (!storage->supportsOptimizationToSubcolumns() || storage->isVirtualColumn(column.name, storage_snapshot->metadata))\n         return {};\n \n@@ -266,7 +272,7 @@ class FunctionToSubcolumnsVisitorFirstPass : public InDepthQueryTreeVisitorWithC\n             return;\n         }\n \n-        auto [function_node, first_argument_node, table_node] = getTypedNodesForOptimization(node);\n+        auto [function_node, first_argument_node, table_node] = getTypedNodesForOptimization(node, getContext());\n         if (function_node && first_argument_node && table_node)\n         {\n             enterImpl(*function_node, *first_argument_node, *table_node);\n@@ -416,7 +422,7 @@ class FunctionToSubcolumnsVisitorSecondPass : public InDepthQueryTreeVisitorWith\n         if (!getSettings().optimize_functions_to_subcolumns)\n             return;\n \n-        auto [function_node, first_argument_column_node, table_node] = getTypedNodesForOptimization(node);\n+        auto [function_node, first_argument_column_node, table_node] = getTypedNodesForOptimization(node, getContext());\n         if (!function_node || !first_argument_column_node || !table_node)\n             return;\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03230_subcolumns_mv.reference b/tests/queries/0_stateless/03230_subcolumns_mv.reference\nnew file mode 100644\nindex 000000000000..03528148b493\n--- /dev/null\n+++ b/tests/queries/0_stateless/03230_subcolumns_mv.reference\n@@ -0,0 +1,1 @@\n+['key1','key2']\t['value1','value2']\ndiff --git a/tests/queries/0_stateless/03230_subcolumns_mv.sql b/tests/queries/0_stateless/03230_subcolumns_mv.sql\nnew file mode 100644\nindex 000000000000..e2e577f54c11\n--- /dev/null\n+++ b/tests/queries/0_stateless/03230_subcolumns_mv.sql\n@@ -0,0 +1,37 @@\n+DROP TABLE IF EXISTS rawtable;\n+DROP TABLE IF EXISTS raw_to_attributes_mv;\n+DROP TABLE IF EXISTS attributes;\n+\n+SET optimize_functions_to_subcolumns = 1;\n+\n+CREATE TABLE rawtable\n+(\n+  `Attributes` Map(String, String),\n+)\n+ENGINE = MergeTree\n+ORDER BY tuple();\n+\n+CREATE MATERIALIZED VIEW raw_to_attributes_mv TO attributes\n+(\n+  `AttributeKeys` Array(String),\n+  `AttributeValues` Array(String)\n+)\n+AS SELECT\n+  mapKeys(Attributes) AS AttributeKeys,\n+  mapValues(Attributes) AS AttributeValues\n+FROM rawtable;\n+\n+CREATE TABLE attributes\n+(\n+  `AttributeKeys` Array(String),\n+  `AttributeValues` Array(String)\n+)\n+ENGINE = ReplacingMergeTree\n+ORDER BY tuple();\n+\n+INSERT INTO rawtable VALUES ({'key1': 'value1', 'key2': 'value2'});\n+SELECT * FROM raw_to_attributes_mv ORDER BY AttributeKeys;\n+\n+DROP TABLE IF EXISTS rawtable;\n+DROP TABLE IF EXISTS raw_to_attributes_mv;\n+DROP TABLE IF EXISTS attributes;\n",
  "problem_statement": "DB::Exception: Not found column Attributes.keys in block NOT_FOUND_COLUMN_IN_BLOCK\n\r\n**Describe the unexpected behaviour**\r\nI am using clickhouse (24.9.1).  It looks like the latest release broke the materialized view which used to work fine in 24.3 release.\r\n\"DB::Exception: Not found column Attributes.keys in block\"\r\n\r\n\r\n**How to reproduce**\r\n```\r\nCREATE TABLE mydb.rawtable\r\n(\r\n  `Id` UInt64 CODEC(Delta(8), ZSTD(1)),\r\n  `Attributes` Map(LowCardinality(String), String) CODEC(ZSTD(1)),\r\n  `MetricName` LowCardinality(String) CODEC(ZSTD(1)),\r\n  `TimeUnix` DateTime CODEC(Delta(8), ZSTD(1))\r\n)\r\nENGINE = MergeTree\r\nPARTITION BY toYYYYMMDD(TimeUnix)\r\nORDER BY (MetricName, Attributes, toUnixTimestamp(TimeUnix))\r\n\r\nCREATE MATERIALIZED VIEW mydb.raw_to_attributes_mv TO mydb.attributes\r\n(\r\n  `Id` UInt64,\r\n  `MetricName` LowCardinality(String),\r\n  `TimeUnix` DateTime,\r\n  `AttributeKeys` Array(LowCardinality(String)),\r\n  `AttributeValues` Array(String)\r\n)\r\nAS SELECT\r\n  Id,\r\n  MetricName,\r\n  toStartOfDay(TimeUnix) AS TimeUnix,\r\n  mapKeys(Attributes) AS AttributeKeys,\r\n  mapValues(Attributes) AS AttributeValues\r\nFROM mydb.rawtable\r\n\r\nCREATE TABLE mydb.attributes\r\n(\r\n  `Id` UInt64 CODEC(Delta(8), ZSTD(1)),\r\n  `MetricName` LowCardinality(String) CODEC(ZSTD(1)),\r\n  `TimeUnix` DateTime CODEC(Delta(8), ZSTD(1)),\r\n  `AttributeKeys` Array(LowCardinality(String)) CODEC(ZSTD(1)),\r\n  `AttributeValues` Array(String) CODEC(ZSTD(1))\r\n)\r\nENGINE = ReplacingMergeTree\r\nPARTITION BY toYYYYMMDD(TimeUnix)\r\nORDER BY (MetricName, Id, TimeUnix) \r\n```\r\n\r\n* Which ClickHouse server version to use\r\n24.9.1\r\n\r\n* Queries to run that lead to unexpected result\r\n\r\ninsert into rawtable values (1, {'key1': 'value1', 'key2': 'value2'}, 'm1', now())\r\n\r\n**Expected behavior**\r\nThis used to work in 24.5. \r\n\r\n**Error message and/or stacktrace**\r\nDB::Exception: Not found column Attributes.keys in block. There are only columns: Id, Attributes, MetricName, TimeUnix: while pushing to view mydb.raw_to_attributes_mv. (NOT_FOUND_COLUMN_IN_BLOCK)\n",
  "hints_text": "Looks like a regression between `24.7` and `24.8`: \r\n- `24.8` and current version: https://fiddle.clickhouse.com/0c0e6d7e-3f5c-42cb-b5fd-0ef54fcb0ff0\r\n- `24.7` and previous versions work fine: https://fiddle.clickhouse.com/66c4d4e1-2a91-4b56-9346-8ecfcc27fc28\nFound the reason, it is `optimize_functions_to_subcolumns`.\r\nIt got enabled by default in https://github.com/ClickHouse/ClickHouse/pull/68053\r\n[SET optimize_functions_to_subcolumns = false;](https://fiddle.clickhouse.com/04974f4b-07c0-4f07-86b0-f643921b1510) removes the error\r\nThe initial problem appeared somewhere between 24.2 and 24.3",
  "created_at": "2024-08-27T12:40:01Z",
  "modified_files": [
    "src/Analyzer/Passes/FunctionToSubcolumnsPass.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03230_subcolumns_mv.reference",
    "b/tests/queries/0_stateless/03230_subcolumns_mv.sql"
  ]
}