{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 49587,
  "instance_id": "ClickHouse__ClickHouse-49587",
  "issue_numbers": [
    "49523"
  ],
  "base_commit": "3b481b9abdb991826f49d016dfb4785af6d1a03d",
  "patch": "diff --git a/src/Dictionaries/DictionaryFactory.cpp b/src/Dictionaries/DictionaryFactory.cpp\nindex d091e49d1f01..c3102632167f 100644\n--- a/src/Dictionaries/DictionaryFactory.cpp\n+++ b/src/Dictionaries/DictionaryFactory.cpp\n@@ -17,13 +17,13 @@ namespace ErrorCodes\n     extern const int UNKNOWN_ELEMENT_IN_CONFIG;\n }\n \n-void DictionaryFactory::registerLayout(const std::string & layout_type, LayoutCreateFunction create_layout, bool is_layout_complex)\n+void DictionaryFactory::registerLayout(const std::string & layout_type, LayoutCreateFunction create_layout, bool is_layout_complex, bool has_layout_complex)\n {\n     auto it = registered_layouts.find(layout_type);\n     if (it != registered_layouts.end())\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"DictionaryFactory: the layout name '{}' is not unique\", layout_type);\n \n-    RegisteredLayout layout { .layout_create_function = create_layout, .is_layout_complex = is_layout_complex };\n+    RegisteredLayout layout { .layout_create_function = create_layout, .is_layout_complex = is_layout_complex, .has_layout_complex = has_layout_complex };\n     registered_layouts.emplace(layout_type, std::move(layout));\n }\n \n@@ -89,6 +89,25 @@ bool DictionaryFactory::isComplex(const std::string & layout_type) const\n     return it->second.is_layout_complex;\n }\n \n+bool DictionaryFactory::convertToComplex(std::string & layout_type) const\n+{\n+    auto it = registered_layouts.find(layout_type);\n+\n+    if (it == registered_layouts.end())\n+    {\n+        throw Exception(ErrorCodes::UNKNOWN_ELEMENT_IN_CONFIG,\n+                        \"Unknown dictionary layout type: {}\",\n+                        layout_type);\n+    }\n+\n+    if (!it->second.is_layout_complex && it->second.has_layout_complex)\n+    {\n+        layout_type = \"complex_key_\" + layout_type;\n+        return true;\n+    }\n+    return false;\n+}\n+\n \n DictionaryFactory & DictionaryFactory::instance()\n {\ndiff --git a/src/Dictionaries/DictionaryFactory.h b/src/Dictionaries/DictionaryFactory.h\nindex b1dad340f4bc..35097a5ed246 100644\n--- a/src/Dictionaries/DictionaryFactory.h\n+++ b/src/Dictionaries/DictionaryFactory.h\n@@ -55,13 +55,18 @@ class DictionaryFactory : private boost::noncopyable\n \n     bool isComplex(const std::string & layout_type) const;\n \n-    void registerLayout(const std::string & layout_type, LayoutCreateFunction create_layout, bool is_layout_complex);\n+    /// If the argument `layout_type` is not complex layout and has corresponding complex layout,\n+    /// change `layout_type` to corresponding complex and return true; otherwise do nothing and return false.\n+    bool convertToComplex(std::string & layout_type) const;\n+\n+    void registerLayout(const std::string & layout_type, LayoutCreateFunction create_layout, bool is_layout_complex, bool has_layout_complex = true);\n \n private:\n     struct RegisteredLayout\n     {\n         LayoutCreateFunction layout_create_function;\n         bool is_layout_complex;\n+        bool has_layout_complex;\n     };\n \n     using LayoutRegistry = std::unordered_map<std::string, RegisteredLayout>;\ndiff --git a/src/Dictionaries/FlatDictionary.cpp b/src/Dictionaries/FlatDictionary.cpp\nindex d3699a150c4e..5bbb5a33fa9b 100644\n--- a/src/Dictionaries/FlatDictionary.cpp\n+++ b/src/Dictionaries/FlatDictionary.cpp\n@@ -683,7 +683,7 @@ void registerDictionaryFlat(DictionaryFactory & factory)\n         return std::make_unique<FlatDictionary>(dict_id, dict_struct, std::move(source_ptr), configuration);\n     };\n \n-    factory.registerLayout(\"flat\", create_layout, false);\n+    factory.registerLayout(\"flat\", create_layout, false, false);\n }\n \n \ndiff --git a/src/Dictionaries/getDictionaryConfigurationFromAST.cpp b/src/Dictionaries/getDictionaryConfigurationFromAST.cpp\nindex b12ffc555d4d..98f115b2ed86 100644\n--- a/src/Dictionaries/getDictionaryConfigurationFromAST.cpp\n+++ b/src/Dictionaries/getDictionaryConfigurationFromAST.cpp\n@@ -19,6 +19,7 @@\n #include <Functions/FunctionFactory.h>\n #include <Common/isLocalAddress.h>\n #include <Interpreters/Context.h>\n+#include <DataTypes/DataTypeFactory.h>\n \n \n namespace DB\n@@ -614,6 +615,16 @@ getDictionaryConfigurationFromAST(const ASTCreateQuery & query, ContextPtr conte\n \n     checkPrimaryKey(all_attr_names_and_types, pk_attrs);\n \n+    /// If the pk size is 1 and pk's DataType is not number, we should convert to complex.\n+    /// NOTE: the data type of Numeric key(simple layout) is UInt64, so if the type is not under UInt64, type casting will lead to precision loss.\n+    DataTypePtr first_key_type = DataTypeFactory::instance().get(all_attr_names_and_types.find(pk_attrs[0])->second.type);\n+    if ((pk_attrs.size() > 1 || (pk_attrs.size() == 1 && !isNumber(first_key_type)))\n+        && !complex\n+        && DictionaryFactory::instance().convertToComplex(dictionary_layout->layout_type))\n+    {\n+        complex = true;\n+    }\n+\n     buildPrimaryKeyConfiguration(xml_document, structure_element, complex, pk_attrs, query.dictionary_attributes_list);\n \n     buildLayoutConfiguration(xml_document, current_dictionary, query.dictionary->dict_settings, dictionary_layout);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01018_ddl_dictionaries_bad_queries.reference b/tests/queries/0_stateless/01018_ddl_dictionaries_bad_queries.reference\nindex abc3218ce6c3..5ee4e7592f64 100644\n--- a/tests/queries/0_stateless/01018_ddl_dictionaries_bad_queries.reference\n+++ b/tests/queries/0_stateless/01018_ddl_dictionaries_bad_queries.reference\n@@ -4,4 +4,3 @@\n 2\n 2\n 2\n-2\ndiff --git a/tests/queries/0_stateless/01018_ddl_dictionaries_bad_queries.sh b/tests/queries/0_stateless/01018_ddl_dictionaries_bad_queries.sh\nindex 6826ed677dbf..8a40129ad4f9 100755\n--- a/tests/queries/0_stateless/01018_ddl_dictionaries_bad_queries.sh\n+++ b/tests/queries/0_stateless/01018_ddl_dictionaries_bad_queries.sh\n@@ -9,21 +9,6 @@ CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n \n $CLICKHOUSE_CLIENT -q \"DROP DICTIONARY IF  EXISTS dict1\"\n \n-# Simple layout, but with two keys\n-$CLICKHOUSE_CLIENT -q \"\n-    CREATE DICTIONARY dict1\n-    (\n-        key1 UInt64,\n-        key2 UInt64,\n-        value String\n-    )\n-    PRIMARY KEY key1, key2\n-    LAYOUT(HASHED())\n-    SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() USER 'default' TABLE 'table_for_dict1' DB '$CLICKHOUSE_DATABASE'))\n-    LIFETIME(MIN 1 MAX 10)\n-\" 2>&1 | grep -c 'Primary key for simple dictionary must contain exactly one element'\n-\n-\n # Simple layout, but with non existing key\n $CLICKHOUSE_CLIENT -q \"\n     CREATE DICTIONARY dict1\ndiff --git a/tests/queries/0_stateless/02391_hashed_dictionary_shards.sql b/tests/queries/0_stateless/02391_hashed_dictionary_shards.sql\nindex ac43c12afc08..018f6b2cf4f6 100644\n--- a/tests/queries/0_stateless/02391_hashed_dictionary_shards.sql\n+++ b/tests/queries/0_stateless/02391_hashed_dictionary_shards.sql\n@@ -89,7 +89,7 @@ SOURCE(CLICKHOUSE(TABLE test_table_string))\n LAYOUT(SPARSE_HASHED(SHARDS 10))\n LIFETIME(0);\n \n-SYSTEM RELOAD DICTIONARY test_dictionary_10_shards_string; -- { serverError CANNOT_PARSE_TEXT }\n+SYSTEM RELOAD DICTIONARY test_dictionary_10_shards_string;\n \n DROP DICTIONARY test_dictionary_10_shards_string;\n \ndiff --git a/tests/queries/0_stateless/02731_auto_convert_dictionary_layout_to_complex_by_complex_keys.reference b/tests/queries/0_stateless/02731_auto_convert_dictionary_layout_to_complex_by_complex_keys.reference\nnew file mode 100644\nindex 000000000000..7616c59e4fd8\n--- /dev/null\n+++ b/tests/queries/0_stateless/02731_auto_convert_dictionary_layout_to_complex_by_complex_keys.reference\n@@ -0,0 +1,5 @@\n+dict_flat_simple\tFlat\n+dict_hashed_simple_Decimal128\tHashed\n+dict_hashed_simple_Float32\tHashed\n+dict_hashed_simple_String\tComplexKeyHashed\n+dict_hashed_simple_auto_convert\tComplexKeyHashed\ndiff --git a/tests/queries/0_stateless/02731_auto_convert_dictionary_layout_to_complex_by_complex_keys.sql b/tests/queries/0_stateless/02731_auto_convert_dictionary_layout_to_complex_by_complex_keys.sql\nnew file mode 100644\nindex 000000000000..753b9f663b5f\n--- /dev/null\n+++ b/tests/queries/0_stateless/02731_auto_convert_dictionary_layout_to_complex_by_complex_keys.sql\n@@ -0,0 +1,35 @@\n+DROP DICTIONARY IF EXISTS dict_flat_simple;\n+DROP DICTIONARY IF EXISTS dict_hashed_simple_Decimal128;\n+DROP DICTIONARY IF EXISTS dict_hashed_simple_Float32;\n+DROP DICTIONARY IF EXISTS dict_hashed_simple_String;\n+DROP DICTIONARY IF EXISTS dict_hashed_simple_auto_convert;\n+DROP TABLE IF EXISTS dict_data;\n+\n+CREATE TABLE dict_data (v0 UInt16, v1 Int16, v2 Float32, v3 Decimal128(10), v4 String) engine=Memory()  AS SELECT number, number%65535, number*1.1, number*1.1, 'foo' FROM numbers(10);;\n+\n+CREATE DICTIONARY dict_flat_simple (v0 UInt16, v1 UInt16, v2 UInt16) PRIMARY KEY v0 SOURCE(CLICKHOUSE(TABLE 'dict_data')) LIFETIME(0) LAYOUT(flat());\n+SYSTEM RELOAD DICTIONARY dict_flat_simple;\n+SELECT name, type FROM system.dictionaries WHERE database = currentDatabase() AND name = 'dict_flat_simple';\n+DROP DICTIONARY dict_flat_simple;\n+\n+CREATE DICTIONARY dict_hashed_simple_Decimal128 (v3 Decimal128(10), v1 UInt16, v2 Float32) PRIMARY KEY v3 SOURCE(CLICKHOUSE(TABLE 'dict_data')) LIFETIME(0) LAYOUT(hashed());\n+SYSTEM RELOAD DICTIONARY dict_hashed_simple_Decimal128;\n+SELECT name, type FROM system.dictionaries WHERE database = currentDatabase() AND name = 'dict_hashed_simple_Decimal128';\n+DROP DICTIONARY dict_hashed_simple_Decimal128;\n+\n+CREATE DICTIONARY dict_hashed_simple_Float32 (v2 Float32, v3 Decimal128(10), v4 String) PRIMARY KEY v2 SOURCE(CLICKHOUSE(TABLE 'dict_data')) LIFETIME(0) LAYOUT(hashed());\n+SYSTEM RELOAD DICTIONARY dict_hashed_simple_Float32;\n+SELECT name, type FROM system.dictionaries WHERE database = currentDatabase() AND name = 'dict_hashed_simple_Float32';\n+DROP DICTIONARY dict_hashed_simple_Float32;\n+\n+CREATE DICTIONARY dict_hashed_simple_String (v4 String, v3 Decimal128(10), v2 Float32) PRIMARY KEY v4 SOURCE(CLICKHOUSE(TABLE 'dict_data')) LIFETIME(0) LAYOUT(hashed());\n+SYSTEM RELOAD DICTIONARY dict_hashed_simple_String;\n+SELECT name, type FROM system.dictionaries WHERE database = currentDatabase() AND name = 'dict_hashed_simple_String';\n+DROP DICTIONARY dict_hashed_simple_String;\n+\n+CREATE DICTIONARY dict_hashed_simple_auto_convert (v0 UInt16, v1 Int16, v2 UInt16) PRIMARY KEY v0,v1 SOURCE(CLICKHOUSE(TABLE 'dict_data')) LIFETIME(0) LAYOUT(hashed());\n+SYSTEM RELOAD DICTIONARY dict_hashed_simple_auto_convert;\n+SELECT name, type FROM system.dictionaries WHERE database = currentDatabase() AND name = 'dict_hashed_simple_auto_convert';\n+DROP DICTIONARY dict_hashed_simple_auto_convert;\n+\n+DROP TABLE dict_data;\n",
  "problem_statement": "If a dictionary is created with a complex key, automatically choose the \"complex key\" layout variant.\n\n",
  "hints_text": "",
  "created_at": "2023-05-06T03:29:11Z",
  "modified_files": [
    "src/Dictionaries/DictionaryFactory.cpp",
    "src/Dictionaries/DictionaryFactory.h",
    "src/Dictionaries/FlatDictionary.cpp",
    "src/Dictionaries/getDictionaryConfigurationFromAST.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01018_ddl_dictionaries_bad_queries.reference",
    "tests/queries/0_stateless/01018_ddl_dictionaries_bad_queries.sh",
    "tests/queries/0_stateless/02391_hashed_dictionary_shards.sql",
    "b/tests/queries/0_stateless/02731_auto_convert_dictionary_layout_to_complex_by_complex_keys.reference",
    "b/tests/queries/0_stateless/02731_auto_convert_dictionary_layout_to_complex_by_complex_keys.sql"
  ]
}