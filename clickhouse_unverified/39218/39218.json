{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 39218,
  "instance_id": "ClickHouse__ClickHouse-39218",
  "issue_numbers": [
    "37728"
  ],
  "base_commit": "3e0db34ed954a791ce3fadc45250bcd81ffb64b7",
  "patch": "diff --git a/docs/en/sql-reference/functions/files.md b/docs/en/sql-reference/functions/files.md\nindex fc2f8a0e0509..b17981ed0e06 100644\n--- a/docs/en/sql-reference/functions/files.md\n+++ b/docs/en/sql-reference/functions/files.md\n@@ -12,12 +12,13 @@ Reads file as a String. The file content is not parsed, so any information is re\n **Syntax**\n \n ``` sql\n-file(path)\n+file(path[, default])\n ```\n \n **Arguments**\n \n -   `path` \u2014 The relative path to the file from [user_files_path](../../operations/server-configuration-parameters/settings.md#server_configuration_parameters-user_files_path). Path to file support following wildcards: `*`, `?`, `{abc,def}` and `{N..M}` where `N`, `M` \u2014 numbers, `'abc', 'def'` \u2014 strings.\n+-   `default` \u2014 The value that will be returned in the case when a file does not exist or cannot be accessed. Data types supported: [String](../../sql-reference/data-types/string.md) and [NULL](../../sql-reference/syntax.md#null-literal).\n \n **Example**\n \ndiff --git a/docs/ru/sql-reference/functions/files.md b/docs/ru/sql-reference/functions/files.md\nindex 1dae94784257..ef4369870edf 100644\n--- a/docs/ru/sql-reference/functions/files.md\n+++ b/docs/ru/sql-reference/functions/files.md\n@@ -12,12 +12,13 @@ sidebar_label: \"\u0424\u0443\u043d\u043a\u0446\u0438\u0438 \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u0444\u0430\u0439\u043b\u0430\u043c\u0438\"\n **\u0421\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441**\n \n ``` sql\n-file(path)\n+file(path[, default])\n ```\n \n **\u0410\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b**\n \n -   `path` \u2014 \u043e\u0442\u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u0443\u0442\u044c \u0434\u043e \u0444\u0430\u0439\u043b\u0430 \u043e\u0442 [user_files_path](../../operations/server-configuration-parameters/settings.md#server_configuration_parameters-user_files_path). \u041f\u0443\u0442\u044c \u043a \u0444\u0430\u0439\u043b\u0443 \u043c\u043e\u0436\u0435\u0442 \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u043f\u043e\u0434\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438 \u0438 \u0448\u0430\u0431\u043b\u043e\u043d\u044b: `*`, `?`, `{abc,def}` \u0438 `{N..M}`, \u0433\u0434\u0435 `N`, `M` \u2014 \u0447\u0438\u0441\u043b\u0430, `'abc', 'def'` \u2014 \u0441\u0442\u0440\u043e\u043a\u0438.\n+-   `default` \u2014 \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u043e\u0435 \u0432 \u0441\u043b\u0443\u0447\u0430\u0435, \u0435\u0441\u043b\u0438 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0444\u0430\u0439\u043b \u043d\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442. \u041f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u043c\u044b\u0435 \u0442\u0438\u043f\u044b \u0434\u0430\u043d\u043d\u044b\u0445: [String](../../sql-reference/data-types/string.md) \u0438 [NULL](../../sql-reference/syntax.md#null-literal).\n \n **\u041f\u0440\u0438\u043c\u0435\u0440\u044b**\n \ndiff --git a/src/Functions/FunctionFile.cpp b/src/Functions/FunctionFile.cpp\nindex c85051e61c02..fab9ba5571c8 100644\n--- a/src/Functions/FunctionFile.cpp\n+++ b/src/Functions/FunctionFile.cpp\n@@ -1,7 +1,10 @@\n+#include <Columns/ColumnNullable.h>\n #include <Columns/ColumnString.h>\n+#include <Columns/ColumnConst.h>\n #include <Columns/IColumn.h>\n #include <Functions/FunctionFactory.h>\n #include <DataTypes/DataTypeString.h>\n+#include <DataTypes/DataTypeNullable.h>\n #include <IO/ReadBufferFromFile.h>\n #include <IO/WriteBufferFromVector.h>\n #include <IO/copyData.h>\n@@ -19,6 +22,7 @@ namespace ErrorCodes\n {\n     extern const int ILLEGAL_COLUMN;\n     extern const int NOT_IMPLEMENTED;\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n     extern const int DATABASE_ACCESS_DENIED;\n }\n \n@@ -30,21 +34,41 @@ class FunctionFile : public IFunction, WithContext\n     static FunctionPtr create(ContextPtr context_) { return std::make_shared<FunctionFile>(context_); }\n     explicit FunctionFile(ContextPtr context_) : WithContext(context_) {}\n \n+    bool isVariadic() const override { return true; }\n     String getName() const override { return name; }\n-    size_t getNumberOfArguments() const override { return 1; }\n+    size_t getNumberOfArguments() const override { return 0; }\n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n+        if (arguments.empty() || arguments.size() > 2)\n+            throw Exception(\n+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+                \"Number of arguments for function {} doesn't match: passed {}, should be 1 or 2\",\n+                getName(), toString(arguments.size()));\n+\n         if (!isString(arguments[0].type))\n             throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"{} is only implemented for type String\", getName());\n \n+        if (arguments.size() == 2)\n+        {\n+            if (arguments[1].type->onlyNull())\n+                return makeNullable(std::make_shared<DataTypeString>());\n+\n+            if (!isString(arguments[1].type))\n+                throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"{} only accepts String or Null as second argument\", getName());\n+        }\n+\n         return std::make_shared<DataTypeString>();\n     }\n \n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n+\n+    bool useDefaultImplementationForNulls() const override { return false; }\n+\n     bool useDefaultImplementationForConstants() const override { return true; }\n \n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n     {\n         const ColumnPtr column = arguments[0].column;\n         const ColumnString * column_src = checkAndGetColumn<ColumnString>(column.get());\n@@ -53,6 +77,31 @@ class FunctionFile : public IFunction, WithContext\n                 fmt::format(\"Illegal column {} of argument of function {}\", arguments[0].column->getName(), getName()),\n                 ErrorCodes::ILLEGAL_COLUMN);\n \n+        String default_result;\n+\n+        ColumnUInt8::MutablePtr col_null_map_to;\n+        ColumnUInt8::Container * vec_null_map_to [[maybe_unused]] = nullptr;\n+\n+        if (arguments.size() == 2)\n+        {\n+            if (result_type->isNullable())\n+            {\n+                col_null_map_to = ColumnUInt8::create(input_rows_count, false);\n+                vec_null_map_to = &col_null_map_to->getData();\n+            }\n+            else\n+            {\n+                const auto & default_column = arguments[1].column;\n+                const ColumnConst * default_col = checkAndGetColumn<ColumnConst>(default_column.get());\n+\n+                if (!default_col)\n+                    throw Exception(\n+                        \"Illegal column \" + arguments[1].column->getName() + \" of argument of function \" + getName(), ErrorCodes::ILLEGAL_COLUMN);\n+\n+                default_result = default_col->getValue<String>();\n+            }\n+        }\n+\n         auto result = ColumnString::create();\n         auto & res_chars = result->getChars();\n         auto & res_offsets = result->getOffsets();\n@@ -77,18 +126,34 @@ class FunctionFile : public IFunction, WithContext\n             /// Otherwise it will not allow to work with symlinks in `user_files_path` directory.\n             file_path = fs::absolute(file_path).lexically_normal();\n \n-            if (need_check && file_path.string().find(user_files_absolute_path_string) != 0)\n-                throw Exception(ErrorCodes::DATABASE_ACCESS_DENIED, \"File is not inside {}\", user_files_absolute_path.string());\n-\n-            ReadBufferFromFile in(file_path);\n-            WriteBufferFromVector out(res_chars, AppendModeTag{});\n-            copyData(in, out);\n-            out.finalize();\n+            try\n+            {\n+                if (need_check && file_path.string().find(user_files_absolute_path_string) != 0)\n+                    throw Exception(ErrorCodes::DATABASE_ACCESS_DENIED, \"File is not inside {}\", user_files_absolute_path.string());\n+\n+                ReadBufferFromFile in(file_path);\n+                WriteBufferFromVector out(res_chars, AppendModeTag{});\n+                copyData(in, out);\n+                out.finalize();\n+            }\n+            catch (...)\n+            {\n+                if (arguments.size() == 1)\n+                    throw;\n+\n+                if (vec_null_map_to)\n+                    (*vec_null_map_to)[row] = true;\n+                else\n+                    res_chars.insert(default_result.data(), default_result.data() + default_result.size());\n+            }\n \n             res_chars.push_back(0);\n             res_offsets[row] = res_chars.size();\n         }\n \n+        if (vec_null_map_to)\n+            return ColumnNullable::create(std::move(result), std::move(col_null_map_to));\n+\n         return result;\n     }\n };\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02357_file_default_value.reference b/tests/queries/0_stateless/02357_file_default_value.reference\nnew file mode 100644\nindex 000000000000..7c0c4634e421\n--- /dev/null\n+++ b/tests/queries/0_stateless/02357_file_default_value.reference\n@@ -0,0 +1,2 @@\n+default\n+\\N\ndiff --git a/tests/queries/0_stateless/02357_file_default_value.sql b/tests/queries/0_stateless/02357_file_default_value.sql\nnew file mode 100644\nindex 000000000000..008fc4edb1f1\n--- /dev/null\n+++ b/tests/queries/0_stateless/02357_file_default_value.sql\n@@ -0,0 +1,3 @@\n+SELECT file('nonexistent.txt'); -- { serverError 107 }\n+SELECT file('nonexistent.txt', 'default');\n+SELECT file('nonexistent.txt', NULL);\ndiff --git a/tests/queries/0_stateless/02358_file_default_value.reference b/tests/queries/0_stateless/02358_file_default_value.reference\nnew file mode 100644\nindex 000000000000..5002c1e43913\n--- /dev/null\n+++ b/tests/queries/0_stateless/02358_file_default_value.reference\n@@ -0,0 +1,20 @@\n+text_0\\n\ttext_0\\n\n+default\t\\N\n+text_2\\n\ttext_2\\n\n+default\t\\N\n+default\t\\N\n+text_5\\n\ttext_5\\n\n+text_6\\n\ttext_6\\n\n+text_7\\n\ttext_7\\n\n+default\t\\N\n+text_9\\n\ttext_9\\n\n+default\t\\N\n+default\t\\N\n+text_5\\n\ttext_5\\n\n+text_6\\n\ttext_6\\n\n+text_7\\n\ttext_7\\n\n+default\t\\N\n+text_9\\n\ttext_9\\n\n+default\t\\N\n+default\t\\N\n+default\t\\N\ndiff --git a/tests/queries/0_stateless/02358_file_default_value.sh b/tests/queries/0_stateless/02358_file_default_value.sh\nnew file mode 100755\nindex 000000000000..7d2cb75c4e4f\n--- /dev/null\n+++ b/tests/queries/0_stateless/02358_file_default_value.sh\n@@ -0,0 +1,21 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+USER_FILES_PATH=$(clickhouse-client --query \"select _path,_file from file('nonexist.txt', 'CSV', 'val1 char')\" 2>&1 | grep Exception | awk '{gsub(\"/nonexist.txt\",\"\",$9); print $9}')\n+WORKING_FOLDER_02357=\"${USER_FILES_PATH}/${CLICKHOUSE_DATABASE}\"\n+\n+rm -rf \"${WORKING_FOLDER_02357}\"\n+mkdir \"${WORKING_FOLDER_02357}\"\n+\n+for i in 0 2 5 6 7 9\n+do\n+    echo \"text_${i}\" > \"${WORKING_FOLDER_02357}/file_${i}\"\n+done\n+\n+${CLICKHOUSE_CLIENT} --query \"WITH '${WORKING_FOLDER_02357}/file_' || toString(number) AS path SELECT file(path, 'default'), file(path, NULL) from numbers(10);\"\n+${CLICKHOUSE_CLIENT} --query \"WITH '${WORKING_FOLDER_02357}/file_' || toString(number) AS path SELECT file(path, 'default'), file(path, NULL) from numbers(3, 10);\"\n+\n+rm -rf \"${WORKING_FOLDER_02357}\"\n",
  "problem_statement": "Ordinary function `file`: it should take optional second argument \"default\" to return when file does not exist.\n**Use case**\r\n\r\n#18842 \r\n\r\n**Describe the solution you'd like**\r\n\r\n`SELECT file('nonexisting')` - throws exception;\r\n`SELECT file('nonexisting', '')` - returns empty string;\r\n`SELECT file('nonexisting', NULL)` - returns NULL.\r\n\n",
  "hints_text": "",
  "created_at": "2022-07-14T09:56:14Z"
}