{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 38989,
  "instance_id": "ClickHouse__ClickHouse-38989",
  "issue_numbers": [
    "38872"
  ],
  "base_commit": "a09422de7b8072454ac4f6f951ea13debc7b90b1",
  "patch": "diff --git a/src/DataTypes/DataTypeTuple.cpp b/src/DataTypes/DataTypeTuple.cpp\nindex 558b13927c18..1ef86a8c12f0 100644\n--- a/src/DataTypes/DataTypeTuple.cpp\n+++ b/src/DataTypes/DataTypeTuple.cpp\n@@ -214,6 +214,19 @@ size_t DataTypeTuple::getPositionByName(const String & name) const\n     throw Exception(\"Tuple doesn't have element with name '\" + name + \"'\", ErrorCodes::NOT_FOUND_COLUMN_IN_BLOCK);\n }\n \n+std::optional<size_t> DataTypeTuple::tryGetPositionByName(const String & name) const\n+{\n+    size_t size = elems.size();\n+    for (size_t i = 0; i < size; ++i)\n+    {\n+        if (names[i] == name)\n+        {\n+            return std::optional<size_t>(i);\n+        }\n+    }\n+    return std::nullopt;\n+}\n+\n String DataTypeTuple::getNameByPosition(size_t i) const\n {\n     if (i == 0 || i > names.size())\ndiff --git a/src/DataTypes/DataTypeTuple.h b/src/DataTypes/DataTypeTuple.h\nindex 009a2284a0a7..eed04631528b 100644\n--- a/src/DataTypes/DataTypeTuple.h\n+++ b/src/DataTypes/DataTypeTuple.h\n@@ -1,6 +1,7 @@\n #pragma once\n \n #include <DataTypes/IDataType.h>\n+#include <optional>\n \n \n namespace DB\n@@ -60,6 +61,7 @@ class DataTypeTuple final : public IDataType\n     const Strings & getElementNames() const { return names; }\n \n     size_t getPositionByName(const String & name) const;\n+    std::optional<size_t> tryGetPositionByName(const String & name) const;\n     String getNameByPosition(size_t i) const;\n \n     bool haveExplicitNames() const { return have_explicit_names; }\ndiff --git a/src/Functions/tupleElement.cpp b/src/Functions/tupleElement.cpp\nindex 023dc266b439..92ca6b85714b 100644\n--- a/src/Functions/tupleElement.cpp\n+++ b/src/Functions/tupleElement.cpp\n@@ -18,6 +18,10 @@ namespace ErrorCodes\n {\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n     extern const int ILLEGAL_INDEX;\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+    extern const int NOT_FOUND_COLUMN_IN_BLOCK;\n+    extern const int NUMBER_OF_DIMENSIONS_MISMATCHED;\n+    extern const int SIZES_OF_ARRAYS_DOESNT_MATCH;\n }\n \n namespace\n@@ -40,9 +44,11 @@ class FunctionTupleElement : public IFunction\n         return name;\n     }\n \n+    bool isVariadic() const override { return true; }\n+\n     size_t getNumberOfArguments() const override\n     {\n-        return 2;\n+        return 0;\n     }\n \n     bool useDefaultImplementationForConstants() const override\n@@ -59,8 +65,14 @@ class FunctionTupleElement : public IFunction\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        size_t count_arrays = 0;\n+        const size_t number_of_arguments = arguments.size();\n+\n+        if (number_of_arguments < 2 || number_of_arguments > 3)\n+            throw Exception(\"Number of arguments for function \" + getName() + \" doesn't match: passed \"\n+                            + toString(number_of_arguments) + \", should be 2 or 3\",\n+                            ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n+        size_t count_arrays = 0;\n         const IDataType * tuple_col = arguments[0].type.get();\n         while (const DataTypeArray * array = checkAndGetDataType<DataTypeArray>(tuple_col))\n         {\n@@ -72,16 +84,34 @@ class FunctionTupleElement : public IFunction\n         if (!tuple)\n             throw Exception(\"First argument for function \" + getName() + \" must be tuple or array of tuple.\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n-        size_t index = getElementNum(arguments[1].column, *tuple);\n-        DataTypePtr out_return_type = tuple->getElements()[index];\n+        auto index = getElementNum(arguments[1].column, *tuple, number_of_arguments);\n+        if (index.has_value())\n+        {\n+            DataTypePtr out_return_type = tuple->getElements()[index.value()];\n \n-        for (; count_arrays; --count_arrays)\n-            out_return_type = std::make_shared<DataTypeArray>(out_return_type);\n+            for (; count_arrays; --count_arrays)\n+                out_return_type = std::make_shared<DataTypeArray>(out_return_type);\n \n-        return out_return_type;\n+            return out_return_type;\n+        }\n+        else\n+        {\n+            const IDataType * default_col = arguments[2].type.get();\n+            size_t default_argument_count_arrays = 0;\n+            if (const DataTypeArray * array = checkAndGetDataType<DataTypeArray>(default_col))\n+            {\n+                default_argument_count_arrays = array->getNumberOfDimensions();\n+            }\n+\n+            if (count_arrays != default_argument_count_arrays)\n+            {\n+                throw Exception(ErrorCodes::NUMBER_OF_DIMENSIONS_MISMATCHED, \"Dimension of types mismatched between first argument and third argument. Dimension of 1st argument: {}. Dimension of 3rd argument: {}.\",count_arrays, default_argument_count_arrays);\n+            }\n+            return arguments[2].type;\n+        }\n     }\n \n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n     {\n         Columns array_offsets;\n \n@@ -89,6 +119,12 @@ class FunctionTupleElement : public IFunction\n \n         const IDataType * tuple_type = first_arg.type.get();\n         const IColumn * tuple_col = first_arg.column.get();\n+        bool first_arg_is_const = false;\n+        if (typeid_cast<const ColumnConst *>(tuple_col))\n+        {\n+            tuple_col = assert_cast<const ColumnConst *>(tuple_col)->getDataColumnPtr().get();\n+            first_arg_is_const = true;\n+        }\n         while (const DataTypeArray * array_type = checkAndGetDataType<DataTypeArray>(tuple_type))\n         {\n             const ColumnArray * array_col = assert_cast<const ColumnArray *>(tuple_col);\n@@ -103,18 +139,87 @@ class FunctionTupleElement : public IFunction\n         if (!tuple_type_concrete || !tuple_col_concrete)\n             throw Exception(\"First argument for function \" + getName() + \" must be tuple or array of tuple.\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n-        size_t index = getElementNum(arguments[1].column, *tuple_type_concrete);\n-        ColumnPtr res = tuple_col_concrete->getColumns()[index];\n+        auto index = getElementNum(arguments[1].column, *tuple_type_concrete, arguments.size());\n+\n+        if (!index.has_value())\n+        {\n+            if (!array_offsets.empty())\n+            {\n+                recursiveCheckArrayOffsets(arguments[0].column, arguments[2].column, array_offsets.size());\n+            }\n+            return arguments[2].column;\n+        }\n+\n+        ColumnPtr res = tuple_col_concrete->getColumns()[index.value()];\n \n         /// Wrap into Arrays\n         for (auto it = array_offsets.rbegin(); it != array_offsets.rend(); ++it)\n             res = ColumnArray::create(res, *it);\n \n+        if (first_arg_is_const)\n+        {\n+            res = ColumnConst::create(res, input_rows_count);\n+        }\n         return res;\n     }\n \n private:\n-    size_t getElementNum(const ColumnPtr & index_column, const DataTypeTuple & tuple) const\n+\n+    void recursiveCheckArrayOffsets(ColumnPtr col_x, ColumnPtr col_y, size_t depth) const\n+    {\n+        for (size_t i = 1; i < depth; ++i)\n+        {\n+            checkArrayOffsets(col_x, col_y);\n+            col_x = assert_cast<const ColumnArray *>(col_x.get())->getDataPtr();\n+            col_y = assert_cast<const ColumnArray *>(col_y.get())->getDataPtr();\n+        }\n+        checkArrayOffsets(col_x, col_y);\n+    }\n+\n+    void checkArrayOffsets(ColumnPtr col_x, ColumnPtr col_y) const\n+    {\n+        if (isColumnConst(*col_x))\n+        {\n+            checkArrayOffsetsWithFirstArgConst(col_x, col_y);\n+        }\n+        else if (isColumnConst(*col_y))\n+        {\n+            checkArrayOffsetsWithFirstArgConst(col_y, col_x);\n+        }\n+        else\n+        {\n+            const auto & array_x = *assert_cast<const ColumnArray *>(col_x.get());\n+            const auto & array_y = *assert_cast<const ColumnArray *>(col_y.get());\n+            if (!array_x.hasEqualOffsets(array_y))\n+            {\n+                throw Exception(\"The argument 1 and argument 3 of function \" + getName() + \" have different array sizes\", ErrorCodes::SIZES_OF_ARRAYS_DOESNT_MATCH);\n+            }\n+        }\n+    }\n+\n+    void checkArrayOffsetsWithFirstArgConst(ColumnPtr col_x, ColumnPtr col_y) const\n+    {\n+        col_x = assert_cast<const ColumnConst *>(col_x.get())->getDataColumnPtr();\n+        col_y = col_y->convertToFullColumnIfConst();\n+        const auto & array_x = *assert_cast<const ColumnArray *>(col_x.get());\n+        const auto & array_y = *assert_cast<const ColumnArray *>(col_y.get());\n+\n+        const auto & offsets_x = array_x.getOffsets();\n+        const auto & offsets_y = array_y.getOffsets();\n+\n+        ColumnArray::Offset prev_offset = 0;\n+        size_t row_size = offsets_y.size();\n+        for (size_t row = 0; row < row_size; ++row)\n+        {\n+            if (unlikely(offsets_x[0] != offsets_y[row] - prev_offset))\n+            {\n+                throw Exception(\"The argument 1 and argument 3 of function \" + getName() + \" have different array sizes\", ErrorCodes::SIZES_OF_ARRAYS_DOESNT_MATCH);\n+            }\n+            prev_offset = offsets_y[row];\n+        }\n+    }\n+\n+    std::optional<size_t> getElementNum(const ColumnPtr & index_column, const DataTypeTuple & tuple, const size_t argument_size) const\n     {\n         if (\n             checkAndGetColumnConst<ColumnUInt8>(index_column.get())\n@@ -131,11 +236,21 @@ class FunctionTupleElement : public IFunction\n             if (index > tuple.getElements().size())\n                 throw Exception(\"Index for tuple element is out of range.\", ErrorCodes::ILLEGAL_INDEX);\n \n-            return index - 1;\n+            return std::optional<size_t>(index - 1);\n         }\n         else if (const auto * name_col = checkAndGetColumnConst<ColumnString>(index_column.get()))\n         {\n-            return tuple.getPositionByName(name_col->getValue<String>());\n+            auto index = tuple.tryGetPositionByName(name_col->getValue<String>());\n+            if (index.has_value())\n+            {\n+                return index;\n+            }\n+\n+            if (argument_size == 2)\n+            {\n+                throw Exception(\"Tuple doesn't have element with name '\" + name_col->getValue<String>() + \"'\", ErrorCodes::NOT_FOUND_COLUMN_IN_BLOCK);\n+            }\n+            return std::nullopt;\n         }\n         else\n             throw Exception(\"Second argument to \" + getName() + \" must be a constant UInt or String\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02354_tuple_element_with_default.reference b/tests/queries/0_stateless/02354_tuple_element_with_default.reference\nnew file mode 100644\nindex 000000000000..d5dfff17ef19\n--- /dev/null\n+++ b/tests/queries/0_stateless/02354_tuple_element_with_default.reference\n@@ -0,0 +1,26 @@\n+z\n+SELECT tupleElement(t1, \\'z\\', \\'z\\')\n+FROM t_tuple_element_default\n+0\n+SELECT tupleElement(t1, \\'z\\', 0)\n+FROM t_tuple_element_default\n+z\n+SELECT tupleElement(t2, \\'z\\', \\'z\\')\n+FROM t_tuple_element_default\n+--------------------\n+[(3,4)]\n+SELECT tupleElement([(1, 2)], \\'a\\', [(3, 4)])\n+--------------------\n+SELECT tupleElement(t1, \\'a\\', [tuple(1)])\n+FROM t_tuple_element_default\n+--------------------\n+[(0)]\n+SELECT tupleElement(t1, \\'a\\', [tuple(0)])\n+FROM t_tuple_element_default\n+[0]\n+SELECT tupleElement(t1, \\'a\\', [0])\n+FROM t_tuple_element_default\n+[0]\n+[0]\n+SELECT tupleElement(t1, \\'a\\', [0])\n+FROM t_tuple_element_default\ndiff --git a/tests/queries/0_stateless/02354_tuple_element_with_default.sql b/tests/queries/0_stateless/02354_tuple_element_with_default.sql\nnew file mode 100644\nindex 000000000000..908a869885b5\n--- /dev/null\n+++ b/tests/queries/0_stateless/02354_tuple_element_with_default.sql\n@@ -0,0 +1,50 @@\n+DROP TABLE IF EXISTS t_tuple_element_default;\n+\n+CREATE TABLE t_tuple_element_default(t1 Tuple(a UInt32, s String), t2 Tuple(UInt32, String)) ENGINE = Memory;\n+INSERT INTO t_tuple_element_default VALUES ((1, 'a'), (2, 'b'));\n+\n+SELECT tupleElement(t1, 'z', 'z') FROM t_tuple_element_default;\n+EXPLAIN SYNTAX SELECT tupleElement(t1, 'z', 'z') FROM t_tuple_element_default;\n+SELECT tupleElement(t1, 'z', 0) FROM t_tuple_element_default;\n+EXPLAIN SYNTAX SELECT tupleElement(t1, 'z', 0) FROM t_tuple_element_default;\n+SELECT tupleElement(t2, 'z', 'z') FROM t_tuple_element_default;\n+EXPLAIN SYNTAX SELECT tupleElement(t2, 'z', 'z') FROM t_tuple_element_default;\n+\n+SELECT tupleElement(t1, 3, 'z') FROM t_tuple_element_default; -- { serverError 127 }\n+SELECT tupleElement(t1, 0, 'z') FROM t_tuple_element_default; -- { serverError 127 }\n+\n+DROP TABLE t_tuple_element_default;\n+\n+SELECT '--------------------';\n+\n+SELECT tupleElement(array(tuple(1, 2)), 'a', 0); -- { serverError 645 }\n+SELECT tupleElement(array(tuple(1, 2)), 'a', array(tuple(1, 2), tuple(3, 4))); -- { serverError 190 }\n+SELECT tupleElement(array(array(tuple(1))), 'a', array(array(1, 2, 3))); -- { serverError 190 }\n+\n+SELECT tupleElement(array(tuple(1, 2)), 'a', array(tuple(3, 4)));\n+EXPLAIN SYNTAX SELECT tupleElement(array(tuple(1, 2)), 'a', array(tuple(3, 4)));\n+\n+SELECT '--------------------';\n+\n+CREATE TABLE t_tuple_element_default(t1 Array(Tuple(UInt32)), t2 UInt32) ENGINE = Memory;\n+\n+SELECT tupleElement(t1, 'a', array(tuple(1))) FROM t_tuple_element_default;\n+EXPLAIN SYNTAX SELECT tupleElement(t1, 'a', array(tuple(1))) FROM t_tuple_element_default;\n+\n+SELECT '--------------------';\n+\n+INSERT INTO t_tuple_element_default VALUES ([(1)], 100);\n+\n+SELECT tupleElement(t1, 'a', array(tuple(0))) FROM t_tuple_element_default;\n+EXPLAIN SYNTAX SELECT tupleElement(t1, 'a', array(tuple(0))) FROM t_tuple_element_default;\n+\n+SELECT tupleElement(t1, 'a', array(0)) FROM t_tuple_element_default;\n+EXPLAIN SYNTAX SELECT tupleElement(t1, 'a', array(0)) FROM t_tuple_element_default;\n+\n+INSERT INTO t_tuple_element_default VALUES ([(2)], 200);\n+\n+SELECT tupleElement(t1, 'a', array(0)) FROM t_tuple_element_default;\n+EXPLAIN SYNTAX SELECT tupleElement(t1, 'a', array(0)) FROM t_tuple_element_default;\n+\n+DROP TABLE t_tuple_element_default;\n+\n",
  "problem_statement": "tupleElement with default value\n```\r\nselect tupleElement(CAST(tuple(1,2),'Tuple(x UInt64, y UInt64)'), 'x') \r\n-- ok\r\n\r\nselect tupleElement(CAST(tuple(1,2),'Tuple(x UInt64, y UInt64)'), 'z')\r\n\r\n-- fails\r\n-- Code: 10. DB::Exception: Received from localhost:9000. DB::Exception: Tuple doesn't have element with name 'z': While processing tupleElement(CAST((1, 2), 'Tuple(x UInt64, y UInt64)'), 'z'). (NOT_FOUND_COLUMN_IN_BLOCK)\r\n```\r\nProposal - add the 3rd parameter to the tupleElement function and return it if tuple doesn't have a member.\r\n\r\nWhy? Tuple comes from object('JSON'), sometimes some fields are missing in some jsons.\n",
  "hints_text": "",
  "created_at": "2022-07-08T06:44:15Z"
}