{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 5924,
  "instance_id": "ClickHouse__ClickHouse-5924",
  "issue_numbers": [
    "5714"
  ],
  "base_commit": "d362ffb3eed12fcdc259b681a5853c9010e7572d",
  "patch": "diff --git a/dbms/src/Client/Connection.cpp b/dbms/src/Client/Connection.cpp\nindex 9651ef54e1b5..0bc7b2fb6284 100644\n--- a/dbms/src/Client/Connection.cpp\n+++ b/dbms/src/Client/Connection.cpp\n@@ -73,7 +73,7 @@ void Connection::connect(const ConnectionTimeouts & timeouts)\n \n         current_resolved_address = DNSResolver::instance().resolveAddress(host, port);\n \n-        socket->connect(current_resolved_address, timeouts.connection_timeout);\n+        socket->connect(*current_resolved_address, timeouts.connection_timeout);\n         socket->setReceiveTimeout(timeouts.receive_timeout);\n         socket->setSendTimeout(timeouts.send_timeout);\n         socket->setNoDelay(true);\n@@ -533,12 +533,9 @@ void Connection::sendExternalTablesData(ExternalTablesData & data)\n     LOG_DEBUG(log_wrapper.get(), msg.rdbuf());\n }\n \n-Poco::Net::SocketAddress Connection::getResolvedAddress() const\n+std::optional<Poco::Net::SocketAddress> Connection::getResolvedAddress() const\n {\n-    if (connected)\n-        return current_resolved_address;\n-\n-    return DNSResolver::instance().resolveAddress(host, port);\n+    return current_resolved_address;\n }\n \n \n@@ -720,11 +717,14 @@ void Connection::initBlockLogsInput()\n void Connection::setDescription()\n {\n     auto resolved_address = getResolvedAddress();\n-    description = host + \":\" + toString(resolved_address.port());\n-    auto ip_address = resolved_address.host().toString();\n+    description = host + \":\" + toString(port);\n \n-    if (host != ip_address)\n-        description += \", \" + ip_address;\n+    if (resolved_address)\n+    {\n+        auto ip_address = resolved_address->host().toString();\n+        if (host != ip_address)\n+            description += \", \" + ip_address;\n+    }\n }\n \n \ndiff --git a/dbms/src/Client/Connection.h b/dbms/src/Client/Connection.h\nindex 2338e4c89659..03a771c257fc 100644\n--- a/dbms/src/Client/Connection.h\n+++ b/dbms/src/Client/Connection.h\n@@ -63,7 +63,7 @@ class Connection : private boost::noncopyable\n         Poco::Timespan sync_request_timeout_ = Poco::Timespan(DBMS_DEFAULT_SYNC_REQUEST_TIMEOUT_SEC, 0))\n         :\n         host(host_), port(port_), default_database(default_database_),\n-        user(user_), password(password_), current_resolved_address(host, port),\n+        user(user_), password(password_),\n         client_name(client_name_),\n         compression(compression_),\n         secure(secure_),\n@@ -168,9 +168,6 @@ class Connection : private boost::noncopyable\n     size_t outBytesCount() const { return out ? out->count() : 0; }\n     size_t inBytesCount() const { return in ? in->count() : 0; }\n \n-    /// Returns initially resolved address\n-    Poco::Net::SocketAddress getResolvedAddress() const;\n-\n private:\n     String host;\n     UInt16 port;\n@@ -180,12 +177,15 @@ class Connection : private boost::noncopyable\n \n     /// Address is resolved during the first connection (or the following reconnects)\n     /// Use it only for logging purposes\n-    Poco::Net::SocketAddress current_resolved_address;\n+    std::optional<Poco::Net::SocketAddress> current_resolved_address;\n \n     /// For messages in log and in exceptions.\n     String description;\n     void setDescription();\n \n+    /// Returns resolved address if it was resolved.\n+    std::optional<Poco::Net::SocketAddress> getResolvedAddress() const;\n+\n     String client_name;\n \n     bool connected = false;\ndiff --git a/dbms/src/Common/isLocalAddress.h b/dbms/src/Common/isLocalAddress.h\nindex 81039dff68e4..63de5e000a9a 100644\n--- a/dbms/src/Common/isLocalAddress.h\n+++ b/dbms/src/Common/isLocalAddress.h\n@@ -23,9 +23,7 @@ namespace DB\n      * - the routing rules that affect which network interface we go to the specified address are not checked.\n      */\n     bool isLocalAddress(const Poco::Net::SocketAddress & address, UInt16 clickhouse_port);\n-\n     bool isLocalAddress(const Poco::Net::SocketAddress & address);\n-\n     bool isLocalAddress(const Poco::Net::IPAddress & address);\n \n     /// Returns number of different bytes in hostnames, used for load balancing\ndiff --git a/dbms/src/Interpreters/Cluster.cpp b/dbms/src/Interpreters/Cluster.cpp\nindex 986f99e0aaf3..3c7c9bbe9dac 100644\n--- a/dbms/src/Interpreters/Cluster.cpp\n+++ b/dbms/src/Interpreters/Cluster.cpp\n@@ -29,9 +29,9 @@ namespace\n /// Default shard weight.\n static constexpr UInt32 default_weight = 1;\n \n-inline bool isLocal(const Cluster::Address & address, const Poco::Net::SocketAddress & resolved_address, UInt16 clickhouse_port)\n+inline bool isLocalImpl(const Cluster::Address & address, const Poco::Net::SocketAddress & resolved_address, UInt16 clickhouse_port)\n {\n-    ///    If there is replica, for which:\n+    /// If there is replica, for which:\n     /// - its port is the same that the server is listening;\n     /// - its host is resolved to set of addresses, one of which is the same as one of addresses of network interfaces of the server machine*;\n     /// then we must go to this shard without any inter-process communication.\n@@ -48,10 +48,31 @@ inline bool isLocal(const Cluster::Address & address, const Poco::Net::SocketAdd\n \n /// Implementation of Cluster::Address class\n \n-Cluster::Address::Address(const Poco::Util::AbstractConfiguration & config, const String & config_prefix)\n+std::optional<Poco::Net::SocketAddress> Cluster::Address::getResolvedAddress() const\n+{\n+    try\n+    {\n+        return DNSResolver::instance().resolveAddress(host_name, port);\n+    }\n+    catch (...)\n+    {\n+        /// Failure in DNS resolution in cluster initialization is Ok.\n+        tryLogCurrentException(\"Cluster\");\n+        return {};\n+    }\n+}\n+\n+\n+bool Cluster::Address::isLocal(UInt16 clickhouse_port) const\n {\n-    UInt16 clickhouse_port = static_cast<UInt16>(config.getInt(\"tcp_port\", 0));\n+    if (auto resolved = getResolvedAddress())\n+        return isLocalImpl(*this, *resolved, clickhouse_port);\n+    return false;\n+}\n+\n \n+Cluster::Address::Address(const Poco::Util::AbstractConfiguration & config, const String & config_prefix)\n+{\n     host_name = config.getString(config_prefix + \".host\");\n     port = static_cast<UInt16>(config.getInt(config_prefix + \".port\"));\n     if (config.has(config_prefix + \".user\"))\n@@ -60,10 +81,9 @@ Cluster::Address::Address(const Poco::Util::AbstractConfiguration & config, cons\n     user = config.getString(config_prefix + \".user\", \"default\");\n     password = config.getString(config_prefix + \".password\", \"\");\n     default_database = config.getString(config_prefix + \".default_database\", \"\");\n-    initially_resolved_address = DNSResolver::instance().resolveAddress(host_name, port);\n-    is_local = isLocal(*this, initially_resolved_address, clickhouse_port);\n     secure = config.getBool(config_prefix + \".secure\", false) ? Protocol::Secure::Enable : Protocol::Secure::Disable;\n     compression = config.getBool(config_prefix + \".compression\", true) ? Protocol::Compression::Enable : Protocol::Compression::Disable;\n+    is_local = isLocal(config.getInt(\"tcp_port\", 0));\n }\n \n \n@@ -74,9 +94,7 @@ Cluster::Address::Address(const String & host_port_, const String & user_, const\n     host_name = parsed_host_port.first;\n     port = parsed_host_port.second;\n     secure = secure_ ? Protocol::Secure::Enable : Protocol::Secure::Disable;\n-\n-    initially_resolved_address = DNSResolver::instance().resolveAddress(parsed_host_port.first, parsed_host_port.second);\n-    is_local = isLocal(*this, initially_resolved_address, clickhouse_port);\n+    is_local = isLocal(clickhouse_port);\n }\n \n \ndiff --git a/dbms/src/Interpreters/Cluster.h b/dbms/src/Interpreters/Cluster.h\nindex 06714da5cef4..e778c9bcf6f4 100644\n--- a/dbms/src/Interpreters/Cluster.h\n+++ b/dbms/src/Interpreters/Cluster.h\n@@ -60,7 +60,7 @@ class Cluster\n         /// This database is selected when no database is specified for Distributed table\n         String default_database;\n         /// The locality is determined at the initialization, and is not changed even if DNS is changed\n-        bool is_local;\n+        bool is_local = false;\n         bool user_specified = false;\n \n         Protocol::Compression compression = Protocol::Compression::Enable;\n@@ -84,17 +84,14 @@ class Cluster\n         String toFullString() const;\n         static Address fromFullString(const String & address_full_string);\n \n-        /// Returns initially resolved address\n-        Poco::Net::SocketAddress getResolvedAddress() const\n-        {\n-            return initially_resolved_address;\n-        }\n+        /// Returns resolved address if it does resolve.\n+        std::optional<Poco::Net::SocketAddress> getResolvedAddress() const;\n \n         auto tuple() const { return std::tie(host_name, port, secure, user, password, default_database); }\n         bool operator==(const Address & other) const { return tuple() == other.tuple(); }\n \n     private:\n-        Poco::Net::SocketAddress initially_resolved_address;\n+        bool isLocal(UInt16 clickhouse_port) const;\n     };\n \n     using Addresses = std::vector<Address>;\ndiff --git a/dbms/src/Interpreters/DDLWorker.cpp b/dbms/src/Interpreters/DDLWorker.cpp\nindex e1cea632a377..1a4113a0d9c3 100644\n--- a/dbms/src/Interpreters/DDLWorker.cpp\n+++ b/dbms/src/Interpreters/DDLWorker.cpp\n@@ -506,8 +506,9 @@ void DDLWorker::parseQueryAndResolveHost(DDLTask & task)\n         {\n             const Cluster::Address & address = shards[shard_num][replica_num];\n \n-            if (isLocalAddress(address.getResolvedAddress(), context.getTCPPort())\n-                || (context.getTCPPortSecure() && isLocalAddress(address.getResolvedAddress(), *context.getTCPPortSecure())))\n+            if (auto resolved = address.getResolvedAddress();\n+                resolved && (isLocalAddress(*resolved, context.getTCPPort())\n+                    || (context.getTCPPortSecure() && isLocalAddress(*resolved, *context.getTCPPortSecure()))))\n             {\n                 if (found_via_resolving)\n                 {\ndiff --git a/dbms/src/Storages/System/StorageSystemClusters.cpp b/dbms/src/Storages/System/StorageSystemClusters.cpp\nindex b33b2d86d0e0..d9403aba6885 100644\n--- a/dbms/src/Storages/System/StorageSystemClusters.cpp\n+++ b/dbms/src/Storages/System/StorageSystemClusters.cpp\n@@ -10,7 +10,8 @@ namespace DB\n \n NamesAndTypesList StorageSystemClusters::getNamesAndTypes()\n {\n-    return {\n+    return\n+    {\n         {\"cluster\", std::make_shared<DataTypeString>()},\n         {\"shard_num\", std::make_shared<DataTypeUInt32>()},\n         {\"shard_weight\", std::make_shared<DataTypeUInt32>()},\n@@ -48,7 +49,8 @@ void StorageSystemClusters::fillData(MutableColumns & res_columns, const Context\n                 res_columns[i++]->insert(shard_info.weight);\n                 res_columns[i++]->insert(replica_index + 1);\n                 res_columns[i++]->insert(address.host_name);\n-                res_columns[i++]->insert(DNSResolver::instance().resolveHost(address.host_name).toString());\n+                auto resolved = address.getResolvedAddress();\n+                res_columns[i++]->insert(resolved ? resolved->host().toString() : String());\n                 res_columns[i++]->insert(address.port);\n                 res_columns[i++]->insert(shard_info.isLocal());\n                 res_columns[i++]->insert(address.user);\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/00965_shard_unresolvable_addresses.reference b/dbms/tests/queries/0_stateless/00965_shard_unresolvable_addresses.reference\nnew file mode 100644\nindex 000000000000..d00491fd7e5b\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/00965_shard_unresolvable_addresses.reference\n@@ -0,0 +1,1 @@\n+1\ndiff --git a/dbms/tests/queries/0_stateless/00965_shard_unresolvable_addresses.sql b/dbms/tests/queries/0_stateless/00965_shard_unresolvable_addresses.sql\nnew file mode 100644\nindex 000000000000..b6b981c7d003\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/00965_shard_unresolvable_addresses.sql\n@@ -0,0 +1,2 @@\n+SELECT count() FROM remote('127.0.0.1,localhos', system.one); -- { serverError 279 }\n+SELECT count() FROM remote('127.0.0.1|localhos', system.one);\n",
  "problem_statement": "Distributed Query fails when DNS cannot resolve hostname in an unrelated cluster\nWe are running two ClickHouse nodes and defining a few different clusters for different purposes.  Some of the clusters are for distributed queries and some are for `ON CLUSTER` DDL.  Logically, we use one of the nodes for writing and the other for reading.  We are deployed on Kubernetes, so there are times when node names are not (DNS) resolvable (i.e., when a Pod is not running).  We use a combination of headless services and ClusterIP services where appropriate.  Given that background, we are trying to understand why if DNS cannot resolve a cluster member hostname in a cluster that's not relevant to a distributed query, it fails.\r\n\r\nFor example, assume we have the following cluster definitions, where we use the below `read` cluster for distributed queries and `admin` cluster for `ON CLUSTER` DDL:\r\n\r\n```\r\n  <remote_servers>\r\n    <read>\r\n      <shard>\r\n        <replica>\r\n          <host>node-read</host>\r\n          <port>9000</port>\r\n        </replica>\r\n      </shard>\r\n    </read>\r\n    <admin>\r\n      <shard>\r\n        <replica>\r\n          <host>node-write</host>\r\n          <port>9000</port>\r\n        </replica>\r\n        <replica>\r\n          <host>node-read</host>\r\n          <port>9000</port>\r\n        </replica>\r\n      </shard>\r\n    </admin>\r\n  </remote_servers>\r\n```\r\n\r\nWith a fully replicated table such as this:\r\n\r\n```\r\nCREATE TABLE test.rep_t\r\n  (`item_id` UInt64,\r\n  `name` String,\r\n  `last_epoch` UInt64)\r\nENGINE = ReplicatedReplacingMergeTree('/clickhouse/tables/{database}/{table}/{shard}', '{replica}', last_epoch) PARTITION BY 0 * item_id ORDER BY item_id\r\n```\r\n\r\nand a distributed table such as\r\n\r\n```\r\nCREATE TABLE test.dist_t AS rep_t ENGINE = Distributed(read, test, rep_t)\r\n```\r\n\r\nIf `node-write` is down such that DNS would not be able to resolve it's IP, we cannot issue any queries ON `node-read` against the distributed table.  For example, a select throws an error such as:\r\n\r\n```\r\nReceived exception from server (version 19.6.2):\r\nCode: 1000. DB::Exception: Received from read:9000, 10.101.129.77. DB::Exception: Host not found: node-write.\r\n```\r\n\r\nWe are running server 19.6.2.11, over the HTTP interface.\r\n\n",
  "hints_text": "",
  "created_at": "2019-07-08T01:45:24Z"
}