{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 6305,
  "instance_id": "ClickHouse__ClickHouse-6305",
  "issue_numbers": [
    "6304"
  ],
  "base_commit": "f149e3b4368fe7b7d588b0066363c595d7410486",
  "patch": "diff --git a/dbms/src/Functions/FunctionsConsistentHashing.h b/dbms/src/Functions/FunctionsConsistentHashing.h\nindex b7282c10dba5..04640e0ec570 100644\n--- a/dbms/src/Functions/FunctionsConsistentHashing.h\n+++ b/dbms/src/Functions/FunctionsConsistentHashing.h\n@@ -29,11 +29,12 @@ struct YandexConsistentHashImpl\n     static constexpr auto name = \"yandexConsistentHash\";\n \n     using HashType = UInt64;\n-    /// Actually it supports UInt64, but it is effective only if n < 65536\n-    using ResultType = UInt32;\n-    using BucketsCountType = ResultType;\n+    /// Actually it supports UInt64, but it is efficient only if n <= 32768\n+    using ResultType = UInt16;\n+    using BucketsType = ResultType;\n+    static constexpr auto max_buckets = 32768;\n \n-    static inline ResultType apply(UInt64 hash, BucketsCountType n)\n+    static inline ResultType apply(UInt64 hash, BucketsType n)\n     {\n         return ConsistentHashing(hash, n);\n     }\n@@ -59,9 +60,10 @@ struct JumpConsistentHashImpl\n \n     using HashType = UInt64;\n     using ResultType = Int32;\n-    using BucketsCountType = ResultType;\n+    using BucketsType = ResultType;\n+    static constexpr auto max_buckets = static_cast<UInt64>(std::numeric_limits<BucketsType>::max());\n \n-    static inline ResultType apply(UInt64 hash, BucketsCountType n)\n+    static inline ResultType apply(UInt64 hash, BucketsType n)\n     {\n         return JumpConsistentHash(hash, n);\n     }\n@@ -74,9 +76,10 @@ struct SumburConsistentHashImpl\n \n     using HashType = UInt32;\n     using ResultType = UInt16;\n-    using BucketsCountType = ResultType;\n+    using BucketsType = ResultType;\n+    static constexpr auto max_buckets = static_cast<UInt64>(std::numeric_limits<BucketsType>::max());\n \n-    static inline ResultType apply(HashType hash, BucketsCountType n)\n+    static inline ResultType apply(HashType hash, BucketsType n)\n     {\n         return static_cast<ResultType>(sumburConsistentHash(hash, n));\n     }\n@@ -143,8 +146,7 @@ class FunctionConsistentHashImpl : public IFunction\n private:\n     using HashType = typename Impl::HashType;\n     using ResultType = typename Impl::ResultType;\n-    using BucketsType = typename Impl::BucketsCountType;\n-    static constexpr auto max_buckets = static_cast<UInt64>(std::numeric_limits<BucketsType>::max());\n+    using BucketsType = typename Impl::BucketsType;\n \n     template <typename T>\n     inline BucketsType checkBucketsRange(T buckets)\n@@ -153,10 +155,9 @@ class FunctionConsistentHashImpl : public IFunction\n             throw Exception(\n                 \"The second argument of function \" + getName() + \" (number of buckets) must be positive number\", ErrorCodes::BAD_ARGUMENTS);\n \n-        if (unlikely(static_cast<UInt64>(buckets) > max_buckets))\n-            throw Exception(\"The value of the second argument of function \" + getName() + \" (number of buckets) is not fit to \"\n-                    + DataTypeNumber<BucketsType>().getName(),\n-                ErrorCodes::BAD_ARGUMENTS);\n+        if (unlikely(static_cast<UInt64>(buckets) > Impl::max_buckets))\n+            throw Exception(\"The value of the second argument of function \" + getName() + \" (number of buckets) must not be greater than \"\n+                    + std::to_string(Impl::max_buckets), ErrorCodes::BAD_ARGUMENTS);\n \n         return static_cast<BucketsType>(buckets);\n     }\ndiff --git a/libs/consistent-hashing/consistent_hashing.h b/libs/consistent-hashing/consistent_hashing.h\nindex fba229c2bd40..a779dc2f3a6f 100644\n--- a/libs/consistent-hashing/consistent_hashing.h\n+++ b/libs/consistent-hashing/consistent_hashing.h\n@@ -15,5 +15,5 @@\n  * It requires O(1) memory and cpu to calculate. So, it is faster than classic\n  * consistent hashing algos with points on circle.\n  */\n-std::size_t ConsistentHashing(std::uint64_t x, std::size_t n); // Works good for n < 65536\n-std::size_t ConsistentHashing(std::uint64_t lo, std::uint64_t hi, std::size_t n); // Works good for n < 4294967296\n+std::size_t ConsistentHashing(std::uint64_t x, std::size_t n); // Works for n <= 32768\n+std::size_t ConsistentHashing(std::uint64_t lo, std::uint64_t hi, std::size_t n); // Works for n <= 2^31\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/00979_yandex_consistent_hash_fpe.reference b/dbms/tests/queries/0_stateless/00979_yandex_consistent_hash_fpe.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/dbms/tests/queries/0_stateless/00979_yandex_consistent_hash_fpe.sql b/dbms/tests/queries/0_stateless/00979_yandex_consistent_hash_fpe.sql\nnew file mode 100644\nindex 000000000000..79fabeae7ef5\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/00979_yandex_consistent_hash_fpe.sql\n@@ -0,0 +1,1 @@\n+SELECT yandexConsistentHash(-1, 40000); -- { serverError 36 }\n",
  "problem_statement": "Integer division by zero in SELECT yandexConsistentHash(-6, 43966)\n**Describe the bug**\r\nFound by fuzz test.\r\n\r\n```\r\n019.08.03 00:51:53.956571 [ 48 ] {2f29ea7c-2860-4a1a-945f-f83be0bad835} <Debug> executeQuery: (from [::ffff:127.0.0.1]:44484) SELECT yandexConsistentHash(-6, 43966)\r\n2019.08.03 00:51:53.970400 [ 52 ] {} <Error> BaseDaemon: ########################################\r\n2019.08.03 00:51:53.970661 [ 52 ] {} <Error> BaseDaemon: (version 19.13.1.1) (from thread 48) Received signal Floating point exception (8).\r\n2019.08.03 00:51:53.970782 [ 52 ] {} <Error> BaseDaemon: Integer divide by zero.\r\n2019.08.03 00:51:54.728221 [ 52 ] {} <Error> BaseDaemon: #4 0xfaa2af2 unsigned long (anonymous namespace)::ConsistentHashingImpl<unsigned short>(unsigned short, unsigned short, unsigned short, unsigned short, unsigned long) /home/milovidov/work/ClickHouse/build/../libs/consistent-hashing/consistent_hashing.cpp:107\r\n#5 0xfaa295e ConsistentHashing(unsigned long, unsigned long) /home/milovidov/work/ClickHouse/build/../libs/consistent-hashing/consistent_hashing.cpp:121\r\n#6 0xda45c7b DB::YandexConsistentHashImpl::apply(unsigned long, unsigned int) /home/milovidov/work/ClickHouse/build/../dbms/src/Functions/FunctionsConsistentHashing.h:38\r\n#7 0xda45640 void DB::FunctionConsistentHashImpl<DB::YandexConsistentHashImpl>::executeType<signed char>(COW<DB::IColumn>::immutable_ptr<DB::IColumn> const&, unsigned int, DB::ColumnVector<unsigned int>*) /home/milovidov/work/ClickHouse/build/../dbms/src/Functions/FunctionsConsistentHashing.h:219\r\n#8 0xda4421b DB::FunctionConsistentHashImpl<DB::YandexConsistentHashImpl>::executeConstBuckets(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long) /home/milovidov/work/ClickHouse/build/../dbms/src/Functions/FunctionsConsistentHashing.h:192\r\n#9 0xda438ba DB::FunctionConsistentHashImpl<DB::YandexConsistentHashImpl>::executeImpl(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long, unsigned long) /home/milovidov/work/ClickHouse/build/../dbms/src/Functions/FunctionsConsistentHashing.h:137\r\n#10 0xd502b01 DB::PreparedFunctionImpl::executeImplDryRun(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long, unsigned long) /home/milovidov/work/ClickHouse/build/../dbms/src/Functions/IFunction.h:67\r\n#11 0xd500a45 DB::DefaultExecutable::executeImplDryRun(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long, unsigned long) /home/milovidov/work/ClickHouse/build/../dbms/src/Functions/IFunction.h:422\r\n#12 0x12aba40e DB::PreparedFunctionImpl::executeWithoutLowCardinalityColumns(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long, unsigned long, bool) /home/milovidov/work/ClickHouse/build/../dbms/src/Functions/IFunction.cpp:310\r\n#13 0x12ab9fb6 DB::PreparedFunctionImpl::defaultImplementationForConstantArguments(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long, unsigned long, bool) /home/milovidov/work/ClickHouse/build/../dbms/src/Functions/IFunction.cpp:259\r\n#14 0x12aba398 DB::PreparedFunctionImpl::executeWithoutLowCardinalityColumns(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long, unsigned long, bool) /home/milovidov/work/ClickHouse/build/../dbms/src/Functions/IFunction.cpp:303\r\n#15 0x12abb57a DB::PreparedFunctionImpl::execute(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long, unsigned long, bool) /home/milovidov/work/ClickHouse/build/../dbms/src/Functions/IFunction.cpp:463\r\n#16 0x11d3e063 DB::ExpressionAction::prepare(DB::Block&, DB::Settings const&) /home/milovidov/work/ClickHouse/build/../dbms/src/Interpreters/ExpressionActions.cpp:216\r\n#17 0x11d43fd9 DB::ExpressionActions::addImpl(DB::ExpressionAction, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > >&) /home/milovidov/work/ClickHouse/build/../dbms/src/Interpreters/ExpressionActions.cpp:686\r\n#18 0x11d438f3 DB::ExpressionActions::add(DB::ExpressionAction const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > >&) /home/milovidov/work/ClickHouse/build/../dbms/src/Interpreters/ExpressionActions.cpp:649\r\n#19 0x11d2584d DB::ScopeStack::addAction(DB::ExpressionAction const&) /home/milovidov/work/ClickHouse/build/../dbms/src/Interpreters/ActionsVisitor.cpp:207\r\n#20 0x11d289c5 DB::ActionsVisitor::visit(std::__1::shared_ptr<DB::IAST> const&) /home/milovidov/work/ClickHouse/build/../dbms/src/Interpreters/ActionsVisitor.cpp:515\r\n#21 0x11d28de3 DB::ActionsVisitor::visit(std::__1::shared_ptr<DB::IAST> const&) /home/milovidov/work/ClickHouse/build/../dbms/src/Interpreters/ActionsVisitor.cpp:536\r\n#22 0x11cfafaf DB::ExpressionAnalyzer::getRootActions(std::__1::shared_ptr<DB::IAST> const&, bool, std::__1::shared_ptr<DB::ExpressionActions>&, bool) /home/milovidov/work/ClickHouse/build/../dbms/src/Interpreters/ExpressionAnalyzer.cpp:348\r\n#23 0x11cff9a0 DB::ExpressionAnalyzer::appendSelect(DB::ExpressionActionsChain&, bool) /home/milovidov/work/ClickHouse/build/../dbms/src/Interpreters/ExpressionAnalyzer.cpp:811\r\n#24 0x11d9fd67 DB::InterpreterSelectQuery::analyzeExpressions(DB::QueryProcessingStage::Enum, bool, std::__1::shared_ptr<DB::FilterInfo> const&) /home/milovidov/work/ClickHouse/build/../dbms/src/Interpreters/InterpreterSelectQuery.cpp:539\r\n#25 0x11dbfa4a void DB::InterpreterSelectQuery::executeImpl<DB::InterpreterSelectQuery::Pipeline>(DB::InterpreterSelectQuery::Pipeline&, std::__1::shared_ptr<DB::IBlockInputStream> const&, bool) /home/milovidov/work/ClickHouse/build/../dbms/src/Interpreters/InterpreterSelectQuery.cpp:810\r\n#26 0x11d9df2e DB::InterpreterSelectQuery::InterpreterSelectQuery(std::__1::shared_ptr<DB::IAST> const&, DB::Context const&, std::__1::shared_ptr<DB::IBlockInputStream> const&, std::__1::shared_ptr<DB::IStorage> const&, DB::SelectQueryOptions const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&) /home/milovidov/work/ClickHouse/build/../dbms/src/Interpreters/InterpreterSelectQuery.cpp:333\r\n#27 0x11d9c4a3 DB::InterpreterSelectQuery::InterpreterSelectQuery(std::__1::shared_ptr<DB::IAST> const&, DB::Context const&, DB::SelectQueryOptions const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&) /home/milovidov/work/ClickHouse/build/../dbms/src/Interpreters/InterpreterSelectQuery.cpp:160\r\n#28 0x1202c02a std::__1::__unique_if<DB::InterpreterSelectQuery>::__unique_single std::__1::make_unique<DB::InterpreterSelectQuery, std::__1::shared_ptr<DB::IAST>&, DB::Context&, DB::SelectQueryOptions const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&>(std::__1::shared_ptr<DB::IAST>&, DB::Context&, DB::SelectQueryOptions const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&) /home/milovidov/work/ClickHouse/contrib/libcxx/include/memory:3131\r\n#29 0x1202a5ff DB::InterpreterSelectWithUnionQuery::InterpreterSelectWithUnionQuery(std::__1::shared_ptr<DB::IAST> const&, DB::Context const&, DB::SelectQueryOptions const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&) /home/milovidov/work/ClickHouse/build/../dbms/src/Interpreters/InterpreterSelectWithUnionQuery.cpp:88\r\n#30 0x11d65fbb std::__1::__unique_if<DB::InterpreterSelectWithUnionQuery>::__unique_single std::__1::make_unique<DB::InterpreterSelectWithUnionQuery, std::__1::shared_ptr<DB::IAST>&, DB::Context&, DB::SelectQueryOptions>(std::__1::shared_ptr<DB::IAST>&, DB::Context&, DB::SelectQueryOptions&&) /home/milovidov/work/ClickHouse/contrib/libcxx/include/memory:3131\r\n#31 0x11d652eb DB::InterpreterFactory::get(std::__1::shared_ptr<DB::IAST>&, DB::Context&, DB::QueryProcessingStage::Enum) /home/milovidov/work/ClickHouse/build/../dbms/src/Interpreters/InterpreterFactory.cpp:92\r\n```\n",
  "hints_text": "",
  "created_at": "2019-08-02T22:46:45Z"
}