{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 16038,
  "instance_id": "ClickHouse__ClickHouse-16038",
  "issue_numbers": [
    "15780"
  ],
  "base_commit": "41f1fd8fa0a6b4aadcb0fd27e5e03dff57f919a8",
  "patch": "diff --git a/src/Functions/array/arrayIndex.h b/src/Functions/array/arrayIndex.h\nindex d0cce3d0d58d..738899b4b8cb 100644\n--- a/src/Functions/array/arrayIndex.h\n+++ b/src/Functions/array/arrayIndex.h\n@@ -384,7 +384,7 @@ class FunctionArrayIndex : public IFunction\n \n     /**\n       * If one or both arguments passed to this function are nullable,\n-      * we create a new columns that contains non-nullable arguments:\n+      * we create a new column that contains non-nullable arguments:\n       *\n       * - if the 1st argument is a non-constant array of nullable values,\n       * it is turned into a non-constant array of ordinary values + a null\n@@ -497,7 +497,7 @@ class FunctionArrayIndex : public IFunction\n         NullMaps maps;\n         ResultColumnPtr result { ResultColumnType::create() };\n \n-        inline void move_result() { columns[result_pos].column = std::move(result); }\n+        inline void moveResult() { columns[result_pos].column = std::move(result); }\n     };\n \n     static inline bool allowNested(const DataTypePtr & left, const DataTypePtr & right)\n@@ -524,9 +524,11 @@ class FunctionArrayIndex : public IFunction\n             const DataTypePtr array_nullable_nested =\n                 checkAndGetDataType<DataTypeNullable>(array_inner_type.get())->getNestedType();\n \n+            // We also allow Nullable(T) and LC(U) if the Nullable(T) and U are allowed,\n+            // the LC(U) will be converted to U.\n             return allowNested(\n                     array_nullable_nested,\n-                    arg_or_arg_nullable_nested);\n+                    recursiveRemoveLowCardinality(arg_or_arg_nullable_nested));\n         }\n         else if (arg_is_nullable) // cannot compare Array(T) elem (namely, T) and Nullable(T)\n             return false;\n@@ -574,6 +576,9 @@ class FunctionArrayIndex : public IFunction\n                 return allowNested(array_lc_nested_or_lc_nullable_nested, arg);\n         }\n \n+        if (arg_is_lc) // Allow T and LC(U) if U and T are allowed (the low cardinality column will be converted).\n+            return allowNested(array_inner_type, arg_lc_inner_type);\n+\n         return false;\n     }\n \n@@ -644,7 +649,8 @@ class FunctionArrayIndex : public IFunction\n         if (!left)\n             return false;\n \n-        const IColumn& right = *columns[arguments[1]].column.get();\n+        const ColumnPtr right_converted_ptr = columns[arguments[1]].column->convertToFullColumnIfLowCardinality();\n+        const IColumn& right = *right_converted_ptr.get();\n \n         ExecutionData data = {\n             left->getData(),\n@@ -710,7 +716,7 @@ class FunctionArrayIndex : public IFunction\n         else\n             return false;\n \n-        data.move_result();\n+        data.moveResult();\n         return true;\n     }\n \n@@ -863,7 +869,7 @@ class FunctionArrayIndex : public IFunction\n             data.result->getData(),\n             data.maps.first, data.maps.second);\n \n-        data.move_result();\n+        data.moveResult();\n         return true;\n     }\n \n@@ -881,7 +887,8 @@ class FunctionArrayIndex : public IFunction\n         if (!left)\n             return false;\n \n-        const IColumn & right = *columns[arguments[1]].column.get();\n+        const ColumnPtr right_ptr = columns[arguments[1]].column->convertToFullColumnIfLowCardinality();\n+        const IColumn & right = *right_ptr.get();\n \n         ExecutionData data = {\n             *left, right, array->getOffsets(),\n@@ -950,7 +957,7 @@ class FunctionArrayIndex : public IFunction\n         else\n             return false;\n \n-        data.move_result();\n+        data.moveResult();\n         return true;\n     }\n \n@@ -964,7 +971,8 @@ class FunctionArrayIndex : public IFunction\n \n         Array arr = col_array->getValue<Array>();\n \n-        const IColumn * item_arg = columns[arguments[1]].column.get();\n+        const ColumnPtr right_ptr = columns[arguments[1]].column->convertToFullColumnIfLowCardinality();\n+        const IColumn * item_arg = right_ptr.get();\n \n         if (isColumnConst(*item_arg))\n         {\n@@ -1039,7 +1047,9 @@ class FunctionArrayIndex : public IFunction\n             return false;\n \n         const IColumn & col_nested = col->getData();\n-        const IColumn & item_arg = *columns[arguments[1]].column;\n+\n+        const ColumnPtr right_ptr = columns[arguments[1]].column->convertToFullColumnIfLowCardinality();\n+        const IColumn & item_arg = *right_ptr.get();\n \n         auto col_res = ResultColumnType::create();\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01441_low_cardinality_array_index.reference b/tests/queries/0_stateless/01441_low_cardinality_array_index.reference\nindex 4e68594ce22f..4e01b47292e7 100644\n--- a/tests/queries/0_stateless/01441_low_cardinality_array_index.reference\n+++ b/tests/queries/0_stateless/01441_low_cardinality_array_index.reference\n@@ -13,3 +13,5 @@\n 1000000\n 1000000\n 1000000\n+1\n+1\ndiff --git a/tests/queries/0_stateless/01441_low_cardinality_array_index.sql b/tests/queries/0_stateless/01441_low_cardinality_array_index.sql\nindex 45d69b5aa64b..8febe8f2e446 100644\n--- a/tests/queries/0_stateless/01441_low_cardinality_array_index.sql\n+++ b/tests/queries/0_stateless/01441_low_cardinality_array_index.sql\n@@ -38,4 +38,10 @@ SELECT count() FROM t_01411_num WHERE has(arr, num);\n SELECT count() FROM t_01411_num WHERE indexOf(arr, num) > 0;\n SELECT count() FROM t_01411_num WHERE indexOf(arr, num % 337) > 0;\n \n+-- Checking Arr(String) and LC(String)\n+SELECT indexOf(['a', 'b', 'c'], toLowCardinality('a'));\n+\n+-- Checking Arr(Nullable(String)) and LC(String)\n+SELECT indexOf(['a', 'b', NULL], toLowCardinality('a'));\n+\n DROP TABLE IF EXISTS t_01411_num;\n",
  "problem_statement": "20.8  Types of array and 2nd argument of function \"indexOf\" must be identical up to ...\n20.7\r\n```\r\nSELECT indexOf(['a', 'b', 'c'], toLowCardinality('a'))\r\n\r\n\u250c\u2500indexOf(['a', 'b', 'c'], toLowCardinality('a'))\u2500\u2510\r\n\u2502                                               1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n20.8\r\n```\r\nSELECT indexOf(['a', 'b', 'c'], toLowCardinality('a'))\r\n\r\n\r\nReceived exception from server (version 20.8.3):\r\nCode: 43. DB::Exception: Received from localhost:9000. DB::Exception: Types of array and 2nd argument of function \"indexOf\" must be identical up to nullability, cardinality, numeric types, or Enum and numeric type. Passed: Array(String) and LowCardinality(String).. \r\n```\r\n\r\nhttps://github.com/ClickHouse/ClickHouse/pull/12550\r\n\r\n/cc @myrrc \r\n\n",
  "hints_text": "Regression",
  "created_at": "2020-10-15T18:55:19Z",
  "modified_files": [
    "src/Functions/array/arrayIndex.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01441_low_cardinality_array_index.reference",
    "tests/queries/0_stateless/01441_low_cardinality_array_index.sql"
  ]
}