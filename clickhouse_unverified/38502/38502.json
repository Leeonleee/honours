{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 38502,
  "instance_id": "ClickHouse__ClickHouse-38502",
  "issue_numbers": [
    "38498"
  ],
  "base_commit": "71aba5b4c663716752a1677d0971f576760648fd",
  "patch": "diff --git a/src/Common/parseGlobs.cpp b/src/Common/parseGlobs.cpp\nindex 75539512b6da..8e9195f98427 100644\n--- a/src/Common/parseGlobs.cpp\n+++ b/src/Common/parseGlobs.cpp\n@@ -32,7 +32,7 @@ std::string makeRegexpPatternFromGlobs(const std::string & initial_str_with_glob\n     }\n     std::string escaped_with_globs = buf_for_escaping.str();\n \n-    static const re2::RE2 enum_or_range(R\"({([\\d]+\\.\\.[\\d]+|[^{}*,]+,[^{}*]*[^{}*,])})\");    /// regexp for {expr1,expr2,expr3} or {M..N}, where M and N - non-negative integers, expr's should be without {}*,\n+    static const re2::RE2 enum_or_range(R\"({([\\d]+\\.\\.[\\d]+|[^{}*,]+,[^{}*]*[^{}*,])})\");    /// regexp for {expr1,expr2,expr3} or {M..N}, where M and N - non-negative integers, expr's should be without \"{\", \"}\", \"*\" and \",\"\n     re2::StringPiece input(escaped_with_globs);\n     re2::StringPiece matched;\n     std::ostringstream oss_for_replacing;       // STYLE_CHECK_ALLOW_STD_STRING_STREAM\n@@ -50,16 +50,32 @@ std::string makeRegexpPatternFromGlobs(const std::string & initial_str_with_glob\n             char point;\n             ReadBufferFromString buf_range(buffer);\n             buf_range >> range_begin >> point >> point >> range_end;\n+\n+            size_t range_begin_width = buffer.find('.');\n+            size_t range_end_width = buffer.size() - buffer.find_last_of('.') - 1;\n             bool leading_zeros = buffer[0] == '0';\n-            size_t num_len = std::to_string(range_end).size();\n+            size_t output_width = 0;\n+\n+            if (range_begin > range_end)    //Descending Sequence {20..15} {9..01}\n+            {\n+                std::swap(range_begin,range_end);\n+                leading_zeros = buffer[buffer.find_last_of('.')+1]=='0';\n+                std::swap(range_begin_width,range_end_width);\n+            }\n+            if (range_begin_width == 1 && leading_zeros)\n+                output_width = 1;   ///Special Case: {0..10} {0..999}\n+            else\n+                output_width = std::max(range_begin_width, range_end_width);\n+\n             if (leading_zeros)\n-                oss_for_replacing << std::setfill('0') << std::setw(num_len);\n+                oss_for_replacing << std::setfill('0') << std::setw(output_width);\n             oss_for_replacing << range_begin;\n+\n             for (size_t i = range_begin + 1; i <= range_end; ++i)\n             {\n                 oss_for_replacing << '|';\n                 if (leading_zeros)\n-                    oss_for_replacing << std::setfill('0') << std::setw(num_len);\n+                    oss_for_replacing << std::setfill('0') << std::setw(output_width);\n                 oss_for_replacing << i;\n             }\n         }\n",
  "test_patch": "diff --git a/src/Common/tests/gtest_makeRegexpPatternFromGlobs.cpp b/src/Common/tests/gtest_makeRegexpPatternFromGlobs.cpp\nindex 42777d0bbbab..fda3a6ee1c89 100644\n--- a/src/Common/tests/gtest_makeRegexpPatternFromGlobs.cpp\n+++ b/src/Common/tests/gtest_makeRegexpPatternFromGlobs.cpp\n@@ -8,14 +8,36 @@ using namespace DB;\n \n TEST(Common, makeRegexpPatternFromGlobs)\n {\n+\n     EXPECT_EQ(makeRegexpPatternFromGlobs(\"?\"), \"[^/]\");\n     EXPECT_EQ(makeRegexpPatternFromGlobs(\"*\"), \"[^/]*\");\n     EXPECT_EQ(makeRegexpPatternFromGlobs(\"/?\"), \"/[^/]\");\n     EXPECT_EQ(makeRegexpPatternFromGlobs(\"/*\"), \"/[^/]*\");\n     EXPECT_EQ(makeRegexpPatternFromGlobs(\"*_{{a,b,c,d}}/?.csv\"), \"[^/]*_\\\\{(a|b|c|d)\\\\}/[^/]\\\\.csv\");\n-    EXPECT_EQ(makeRegexpPatternFromGlobs(\"f{01..09}\"), \"f(1|2|3|4|5|6|7|8|9)\");\n-    EXPECT_EQ(makeRegexpPatternFromGlobs(\"f{01..9}\"), \"f(1|2|3|4|5|6|7|8|9)\");\n-    EXPECT_EQ(makeRegexpPatternFromGlobs(\"f{0001..0000009}\"), \"f(1|2|3|4|5|6|7|8|9)\");\n+    /* Regex Parsing for {..} can have three possible cases\n+       1) The left range width == the right range width\n+       2) The left range width > the right range width\n+       3) The left range width < the right range width\n+    */\n+    // Ascending Sequences\n+    EXPECT_EQ(makeRegexpPatternFromGlobs(\"f{1..9}\"), \"f(1|2|3|4|5|6|7|8|9)\");\n+    EXPECT_EQ(makeRegexpPatternFromGlobs(\"f{0..10}\"), \"f(0|1|2|3|4|5|6|7|8|9|10)\");\n+    EXPECT_EQ(makeRegexpPatternFromGlobs(\"f{10..20}\"), \"f(10|11|12|13|14|15|16|17|18|19|20)\");\n+    EXPECT_EQ(makeRegexpPatternFromGlobs(\"f{00..10}\"), \"f(00|01|02|03|04|05|06|07|08|09|10)\");\n+    EXPECT_EQ(makeRegexpPatternFromGlobs(\"f{0001..0009}\"), \"f(0001|0002|0003|0004|0005|0006|0007|0008|0009)\");\n+    EXPECT_EQ(makeRegexpPatternFromGlobs(\"f{01..9}\"), \"f(01|02|03|04|05|06|07|08|09)\");\n+    EXPECT_EQ(makeRegexpPatternFromGlobs(\"f{000..9}\"), \"f(000|001|002|003|004|005|006|007|008|009)\");\n+    EXPECT_EQ(makeRegexpPatternFromGlobs(\"f{95..103}\"), \"f(95|96|97|98|99|100|101|102|103)\");\n+    EXPECT_EQ(makeRegexpPatternFromGlobs(\"f{99..109}\"), \"f(99|100|101|102|103|104|105|106|107|108|109)\");\n+    EXPECT_EQ(makeRegexpPatternFromGlobs(\"f{001..0009}\"), \"f(0001|0002|0003|0004|0005|0006|0007|0008|0009)\");\n+    // Descending Sequences\n+    EXPECT_EQ(makeRegexpPatternFromGlobs(\"f{20..15}\"), \"f(15|16|17|18|19|20)\");\n+    EXPECT_EQ(makeRegexpPatternFromGlobs(\"f{200..199}\"), \"f(199|200)\");\n+    EXPECT_EQ(makeRegexpPatternFromGlobs(\"f{0009..0001}\"), \"f(0001|0002|0003|0004|0005|0006|0007|0008|0009)\");\n+    EXPECT_EQ(makeRegexpPatternFromGlobs(\"f{100..90}\"), \"f(90|91|92|93|94|95|96|97|98|99|100)\");\n+    EXPECT_EQ(makeRegexpPatternFromGlobs(\"f{103..95}\"), \"f(95|96|97|98|99|100|101|102|103)\");\n+    EXPECT_EQ(makeRegexpPatternFromGlobs(\"f{9..01}\"), \"f(01|02|03|04|05|06|07|08|09)\");\n+    EXPECT_EQ(makeRegexpPatternFromGlobs(\"f{9..000}\"), \"f(000|001|002|003|004|005|006|007|008|009)\");\n     EXPECT_EQ(makeRegexpPatternFromGlobs(\"f{1..2}{1..2}\"), \"f(1|2)(1|2)\");\n     EXPECT_EQ(makeRegexpPatternFromGlobs(\"f{1..1}{1..1}\"), \"f(1)(1)\");\n     EXPECT_EQ(makeRegexpPatternFromGlobs(\"f{0..0}{0..0}\"), \"f(0)(0)\");\ndiff --git a/tests/queries/0_stateless/02297_regex_parsing_file_names.reference b/tests/queries/0_stateless/02297_regex_parsing_file_names.reference\nnew file mode 100644\nindex 000000000000..b4de39476753\n--- /dev/null\n+++ b/tests/queries/0_stateless/02297_regex_parsing_file_names.reference\n@@ -0,0 +1,1 @@\n+11\ndiff --git a/tests/queries/0_stateless/02297_regex_parsing_file_names.sh b/tests/queries/0_stateless/02297_regex_parsing_file_names.sh\nnew file mode 100755\nindex 000000000000..12ccb54235be\n--- /dev/null\n+++ b/tests/queries/0_stateless/02297_regex_parsing_file_names.sh\n@@ -0,0 +1,40 @@\n+#!/usr/bin/env bash\n+# Tags: no-parallel\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+# Data preparation.\n+\n+# Now we can get the user_files_path by use the table file function for trick. also we can get it by query as:\n+#  \"insert into function file('exist.txt', 'CSV', 'val1 char') values ('aaaa'); select _path from file('exist.txt', 'CSV', 'val1 char')\"\n+CLICKHOUSE_USER_FILES_PATH=$(clickhouse-client --query \"select _path, _file from file('nonexist.txt', 'CSV', 'val1 char')\" 2>&1 | grep Exception | awk '{gsub(\"/nonexist.txt\",\"\",$9); print $9}')\n+\n+mkdir -p ${CLICKHOUSE_USER_FILES_PATH}/\n+\n+rm -rf ${CLICKHOUSE_USER_FILES_PATH}/file_{0..10}.csv\n+\n+echo '0' > ${CLICKHOUSE_USER_FILES_PATH}/file_0.csv\n+echo '0' > ${CLICKHOUSE_USER_FILES_PATH}/file_1.csv\n+echo '0' > ${CLICKHOUSE_USER_FILES_PATH}/file_2.csv\n+echo '0' > ${CLICKHOUSE_USER_FILES_PATH}/file_3.csv\n+echo '0' > ${CLICKHOUSE_USER_FILES_PATH}/file_4.csv\n+echo '0' > ${CLICKHOUSE_USER_FILES_PATH}/file_5.csv\n+echo '0' > ${CLICKHOUSE_USER_FILES_PATH}/file_6.csv\n+echo '0' > ${CLICKHOUSE_USER_FILES_PATH}/file_7.csv\n+echo '0' > ${CLICKHOUSE_USER_FILES_PATH}/file_8.csv\n+echo '0' > ${CLICKHOUSE_USER_FILES_PATH}/file_9.csv\n+echo '0' > ${CLICKHOUSE_USER_FILES_PATH}/file_10.csv\n+\n+# echo '' > ${CLICKHOUSE_USER_FILES_PATH}/file_10.csv\n+\n+${CLICKHOUSE_CLIENT} -q \"DROP TABLE IF EXISTS t_regex;\"\n+\n+${CLICKHOUSE_CLIENT} -q \"CREATE TABLE t_regex (id UInt64) ENGINE = MergeTree() order by id;\"\n+\n+${CLICKHOUSE_CLIENT} -q \"INSERT INTO t_regex SELECT * FROM file('file_{0..10}.csv','CSV');\"\n+${CLICKHOUSE_CLIENT} -q \"SELECT count() from t_regex;\"\n+\n+rm -rf ${CLICKHOUSE_USER_FILES_PATH}/file_{0..10}.csv;\n+${CLICKHOUSE_CLIENT} -q \"DROP TABLE IF EXISTS t_regex;\"\n",
  "problem_statement": "`{0..10}` expansion in external file names is incorrect.\nIt is interpreted as an \"aligned\" expansion producing something like 00, 01, 02... 10 instead of 0, 1, 2... 10.\r\n\r\nhttps://pastila.nl/?09014b44/8155336bcfbf55d813814753465a1adf\n",
  "hints_text": "",
  "created_at": "2022-06-28T05:54:18Z",
  "modified_files": [
    "src/Common/parseGlobs.cpp"
  ],
  "modified_test_files": [
    "src/Common/tests/gtest_makeRegexpPatternFromGlobs.cpp",
    "b/tests/queries/0_stateless/02297_regex_parsing_file_names.reference",
    "b/tests/queries/0_stateless/02297_regex_parsing_file_names.sh"
  ]
}