{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 33478,
  "instance_id": "ClickHouse__ClickHouse-33478",
  "issue_numbers": [
    "30809"
  ],
  "base_commit": "ff645a062a306f20f844150766197604d13aac5f",
  "patch": "diff --git a/src/Dictionaries/getDictionaryConfigurationFromAST.cpp b/src/Dictionaries/getDictionaryConfigurationFromAST.cpp\nindex 36a462c533eb..d1ce665d0029 100644\n--- a/src/Dictionaries/getDictionaryConfigurationFromAST.cpp\n+++ b/src/Dictionaries/getDictionaryConfigurationFromAST.cpp\n@@ -35,7 +35,13 @@ namespace ErrorCodes\n namespace\n {\n \n-using NamesToTypeNames = std::unordered_map<std::string, std::string>;\n+struct AttributeConfiguration\n+{\n+    std::string type;\n+    std::string expression;\n+};\n+\n+using AttributeNameToConfiguration = std::unordered_map<std::string, AttributeConfiguration>;\n \n /// Get value from field and convert it to string.\n /// Also remove quotes from strings.\n@@ -46,6 +52,21 @@ String getFieldAsString(const Field & field)\n     return applyVisitor(FieldVisitorToString(), field);\n }\n \n+String getAttributeExpression(const ASTDictionaryAttributeDeclaration * dict_attr)\n+{\n+    if (!dict_attr->expression)\n+        return {};\n+\n+    /// EXPRESSION PROPERTY should be expression or string\n+    String expression_str;\n+    if (const auto * literal = dict_attr->expression->as<ASTLiteral>(); literal && literal->value.getType() == Field::Types::String)\n+        expression_str = getFieldAsString(literal->value);\n+    else\n+        expression_str = queryToString(dict_attr->expression);\n+\n+    return expression_str;\n+}\n+\n \n using namespace Poco;\n using namespace Poco::XML;\n@@ -63,20 +84,19 @@ void buildLifetimeConfiguration(\n     AutoPtr<Element> root,\n     const ASTDictionaryLifetime * lifetime)\n {\n-\n-    if (lifetime)\n-    {\n-        AutoPtr<Element> lifetime_element(doc->createElement(\"lifetime\"));\n-        AutoPtr<Element> min_element(doc->createElement(\"min\"));\n-        AutoPtr<Element> max_element(doc->createElement(\"max\"));\n-        AutoPtr<Text> min_sec(doc->createTextNode(toString(lifetime->min_sec)));\n-        min_element->appendChild(min_sec);\n-        AutoPtr<Text> max_sec(doc->createTextNode(toString(lifetime->max_sec)));\n-        max_element->appendChild(max_sec);\n-        lifetime_element->appendChild(min_element);\n-        lifetime_element->appendChild(max_element);\n-        root->appendChild(lifetime_element);\n-    }\n+    if (!lifetime)\n+        return;\n+\n+    AutoPtr<Element> lifetime_element(doc->createElement(\"lifetime\"));\n+    AutoPtr<Element> min_element(doc->createElement(\"min\"));\n+    AutoPtr<Element> max_element(doc->createElement(\"max\"));\n+    AutoPtr<Text> min_sec(doc->createTextNode(toString(lifetime->min_sec)));\n+    min_element->appendChild(min_sec);\n+    AutoPtr<Text> max_sec(doc->createTextNode(toString(lifetime->max_sec)));\n+    max_element->appendChild(max_sec);\n+    lifetime_element->appendChild(min_element);\n+    lifetime_element->appendChild(max_element);\n+    root->appendChild(lifetime_element);\n }\n \n /* Transforms next definition\n@@ -105,40 +125,43 @@ void buildLayoutConfiguration(\n     AutoPtr<Element> layout_type_element(doc->createElement(layout->layout_type));\n     layout_element->appendChild(layout_type_element);\n \n-    if (layout->parameters)\n+    if (!layout->parameters)\n+        return;\n+\n+    for (const auto & param : layout->parameters->children)\n     {\n-        for (const auto & param : layout->parameters->children)\n+        const ASTPair * pair = param->as<ASTPair>();\n+        if (!pair)\n         {\n-            const ASTPair * pair = param->as<ASTPair>();\n-            if (!pair)\n-            {\n-                throw DB::Exception(ErrorCodes::BAD_ARGUMENTS, \"Dictionary layout parameters must be key/value pairs, got '{}' instead\",\n-                    param->formatForErrorMessage());\n-            }\n-\n-            const ASTLiteral * value_literal = pair->second->as<ASTLiteral>();\n-            if (!value_literal)\n-            {\n-                throw DB::Exception(ErrorCodes::BAD_ARGUMENTS,\n-                    \"Dictionary layout parameter value must be a literal, got '{}' instead\",\n-                    pair->second->formatForErrorMessage());\n-            }\n+            throw DB::Exception(\n+                ErrorCodes::BAD_ARGUMENTS,\n+                \"Dictionary layout parameters must be key/value pairs, got '{}' instead\",\n+                param->formatForErrorMessage());\n+        }\n \n-            const auto value_field = value_literal->value;\n+        const ASTLiteral * value_literal = pair->second->as<ASTLiteral>();\n+        if (!value_literal)\n+        {\n+            throw DB::Exception(\n+                ErrorCodes::BAD_ARGUMENTS,\n+                \"Dictionary layout parameter value must be a literal, got '{}' instead\",\n+                pair->second->formatForErrorMessage());\n+        }\n \n-            if (value_field.getType() != Field::Types::UInt64\n-                && value_field.getType() != Field::Types::String)\n-            {\n-                throw DB::Exception(ErrorCodes::BAD_ARGUMENTS,\n-                    \"Dictionary layout parameter value must be an UInt64 or String, got '{}' instead\",\n-                    value_field.getTypeName());\n-            }\n+        const auto value_field = value_literal->value;\n \n-            AutoPtr<Element> layout_type_parameter_element(doc->createElement(pair->first));\n-            AutoPtr<Text> value_to_append(doc->createTextNode(toString(value_field)));\n-            layout_type_parameter_element->appendChild(value_to_append);\n-            layout_type_element->appendChild(layout_type_parameter_element);\n+        if (value_field.getType() != Field::Types::UInt64 && value_field.getType() != Field::Types::String)\n+        {\n+            throw DB::Exception(\n+                ErrorCodes::BAD_ARGUMENTS,\n+                \"Dictionary layout parameter value must be an UInt64 or String, got '{}' instead\",\n+                value_field.getTypeName());\n         }\n+\n+        AutoPtr<Element> layout_type_parameter_element(doc->createElement(pair->first));\n+        AutoPtr<Text> value_to_append(doc->createTextNode(toString(value_field)));\n+        layout_type_parameter_element->appendChild(value_to_append);\n+        layout_type_element->appendChild(layout_type_parameter_element);\n     }\n }\n \n@@ -149,10 +172,10 @@ void buildLayoutConfiguration(\n  *  <range_min><name>StartDate</name></range_min>\n  *  <range_max><name>EndDate</name></range_max>\n  */\n-void buildRangeConfiguration(AutoPtr<Document> doc, AutoPtr<Element> root, const ASTDictionaryRange * range, const NamesToTypeNames & all_attrs)\n+void buildRangeConfiguration(AutoPtr<Document> doc, AutoPtr<Element> root, const ASTDictionaryRange * range, const AttributeNameToConfiguration & all_attrs)\n {\n     // appends <key><name>value</name></key> to root\n-    auto append_element = [&doc, &root](const std::string & key, const std::string & name, const std::string & type)\n+    auto append_element = [&doc, &root](const std::string & key, const std::string & name, const AttributeConfiguration & configuration)\n     {\n         AutoPtr<Element> element(doc->createElement(key));\n         AutoPtr<Element> name_node(doc->createElement(\"name\"));\n@@ -161,22 +184,33 @@ void buildRangeConfiguration(AutoPtr<Document> doc, AutoPtr<Element> root, const\n         element->appendChild(name_node);\n \n         AutoPtr<Element> type_node(doc->createElement(\"type\"));\n-        AutoPtr<Text> type_text(doc->createTextNode(type));\n+        AutoPtr<Text> type_text(doc->createTextNode(configuration.type));\n         type_node->appendChild(type_text);\n         element->appendChild(type_node);\n \n+        if (!configuration.expression.empty())\n+        {\n+            AutoPtr<Element> expression_node(doc->createElement(\"expression\"));\n+            AutoPtr<Text> expression_text(doc->createTextNode(configuration.expression));\n+            expression_node->appendChild(expression_text);\n+            element->appendChild(expression_node);\n+        }\n+\n         root->appendChild(element);\n     };\n \n-    if (!all_attrs.count(range->min_attr_name))\n+    auto range_min_attribute_it = all_attrs.find(range->min_attr_name);\n+    if (range_min_attribute_it == all_attrs.end())\n         throw Exception(ErrorCodes::INCORRECT_DICTIONARY_DEFINITION,\n-            \"MIN ({}) attribute is not defined in the dictionary attributes\", range->min_attr_name);\n-    if (!all_attrs.count(range->max_attr_name))\n+            \"MIN {} attribute is not defined in the dictionary attributes\", range->min_attr_name);\n+\n+    auto range_max_attribute_it = all_attrs.find(range->min_attr_name);\n+    if (range_max_attribute_it == all_attrs.end())\n         throw Exception(ErrorCodes::INCORRECT_DICTIONARY_DEFINITION,\n-            \"MAX ({}) attribute is not defined in the dictionary attributes\", range->max_attr_name);\n+            \"MAX {} attribute is not defined in the dictionary attributes\", range->max_attr_name);\n \n-    append_element(\"range_min\", range->min_attr_name, all_attrs.at(range->min_attr_name));\n-    append_element(\"range_max\", range->max_attr_name, all_attrs.at(range->max_attr_name));\n+    append_element(\"range_min\", range->min_attr_name, range_min_attribute_it->second);\n+    append_element(\"range_max\", range->max_attr_name, range_max_attribute_it->second);\n }\n \n \n@@ -199,25 +233,14 @@ void buildAttributeExpressionIfNeeded(\n     AutoPtr<Element> root,\n     const ASTDictionaryAttributeDeclaration * dict_attr)\n {\n-    if (dict_attr->expression != nullptr)\n-    {\n-        AutoPtr<Element> expression_element(doc->createElement(\"expression\"));\n-\n-        /// EXPRESSION PROPERTY should be expression or string\n-        String expression_str;\n-        if (const auto * literal = dict_attr->expression->as<ASTLiteral>();\n-                literal && literal->value.getType() == Field::Types::String)\n-        {\n-            expression_str = getFieldAsString(literal->value);\n-        }\n-        else\n-            expression_str = queryToString(dict_attr->expression);\n-\n-\n-        AutoPtr<Text> expression(doc->createTextNode(expression_str));\n-        expression_element->appendChild(expression);\n-        root->appendChild(expression_element);\n-    }\n+    if (!dict_attr->expression)\n+        return;\n+\n+    AutoPtr<Element> expression_element(doc->createElement(\"expression\"));\n+    String expression_str = getAttributeExpression(dict_attr);\n+    AutoPtr<Text> expression(doc->createTextNode(expression_str));\n+    expression_element->appendChild(expression);\n+    root->appendChild(expression_element);\n }\n \n /** Transofrms single dictionary attribute to configuration\n@@ -373,25 +396,28 @@ void buildPrimaryKeyConfiguration(\n \n /** Transforms list of ASTDictionaryAttributeDeclarations to list of dictionary attributes\n   */\n-NamesToTypeNames buildDictionaryAttributesConfiguration(\n+AttributeNameToConfiguration buildDictionaryAttributesConfiguration(\n     AutoPtr<Document> doc,\n     AutoPtr<Element> root,\n     const ASTExpressionList * dictionary_attributes,\n     const Names & key_columns)\n {\n     const auto & children = dictionary_attributes->children;\n-    NamesToTypeNames attributes_names_and_types;\n+    AttributeNameToConfiguration attributes_name_to_configuration;\n+\n     for (const auto & child : children)\n     {\n         const ASTDictionaryAttributeDeclaration * dict_attr = child->as<const ASTDictionaryAttributeDeclaration>();\n         if (!dict_attr->type)\n             throw Exception(ErrorCodes::INCORRECT_DICTIONARY_DEFINITION, \"Dictionary attribute must has type\");\n \n-        attributes_names_and_types.emplace(dict_attr->name, queryToString(dict_attr->type));\n+        AttributeConfiguration attribute_configuration {queryToString(dict_attr->type), getAttributeExpression(dict_attr)};\n+        attributes_name_to_configuration.emplace(dict_attr->name, std::move(attribute_configuration));\n+\n         if (std::find(key_columns.begin(), key_columns.end(), dict_attr->name) == key_columns.end())\n             buildSingleAttribute(doc, root, dict_attr);\n     }\n-    return attributes_names_and_types;\n+    return attributes_name_to_configuration;\n }\n \n /** Transform function with key-value arguments to configuration\n@@ -513,10 +539,10 @@ void checkAST(const ASTCreateQuery & query)\n         throw Exception(ErrorCodes::INCORRECT_DICTIONARY_DEFINITION, \"Cannot create dictionary with empty source\");\n }\n \n-void checkPrimaryKey(const NamesToTypeNames & all_attrs, const Names & key_attrs)\n+void checkPrimaryKey(const AttributeNameToConfiguration & all_attrs, const Names & key_attrs)\n {\n     for (const auto & key_attr : key_attrs)\n-        if (all_attrs.count(key_attr) == 0)\n+        if (all_attrs.find(key_attr) == all_attrs.end())\n             throw Exception(ErrorCodes::INCORRECT_DICTIONARY_DEFINITION, \"Unknown key attribute '{}'\", key_attr);\n }\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02162_range_hashed_dictionary_ddl_expression.reference b/tests/queries/0_stateless/02162_range_hashed_dictionary_ddl_expression.reference\nnew file mode 100644\nindex 000000000000..d366ce64c271\n--- /dev/null\n+++ b/tests/queries/0_stateless/02162_range_hashed_dictionary_ddl_expression.reference\n@@ -0,0 +1,1 @@\n+0\t1\t1\tValue\t1\ndiff --git a/tests/queries/0_stateless/02162_range_hashed_dictionary_ddl_expression.sql b/tests/queries/0_stateless/02162_range_hashed_dictionary_ddl_expression.sql\nnew file mode 100644\nindex 000000000000..24eb08137e13\n--- /dev/null\n+++ b/tests/queries/0_stateless/02162_range_hashed_dictionary_ddl_expression.sql\n@@ -0,0 +1,29 @@\n+DROP TABLE IF EXISTS 02162_test_table;\n+CREATE TABLE 02162_test_table\n+(\n+    id UInt64,\n+    value String,\n+    range_value UInt64\n+) ENGINE=TinyLog;\n+\n+INSERT INTO 02162_test_table VALUES (0, 'Value', 1);\n+\n+DROP DICTIONARY IF EXISTS 02162_test_dictionary;\n+CREATE DICTIONARY 02162_test_dictionary\n+(\n+    id UInt64,\n+    value String,\n+    range_value UInt64,\n+    start UInt64 EXPRESSION range_value,\n+    end UInt64 EXPRESSION range_value\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(TABLE '02162_test_table'))\n+LAYOUT(RANGE_HASHED())\n+RANGE(MIN start MAX end)\n+LIFETIME(0);\n+\n+SELECT * FROM 02162_test_dictionary;\n+\n+DROP DICTIONARY 02162_test_dictionary;\n+DROP TABLE 02162_test_table;\n",
  "problem_statement": "Dictionary EXPRESSION doesn't work for range boundary columns\n**Describe the unexpected behaviour**\r\nIt's not possible to calculate min and max values for range dictionary via EXPRESSION\r\n\r\n**How to reproduce**\r\nClickHouse version 21.11\r\n\r\n```\r\nCREATE TABLE test_range_dict\r\n(\r\n    `id` UInt32,\r\n    `date` Date,\r\n    `start` Date,\r\n    `end` Date\r\n)\r\nENGINE = Memory\r\n\r\nCREATE DICTIONARY IF NOT EXISTS test_range_dict_d\r\n(\r\n    `id` UInt64,\r\n    `date` Date,\r\n    `start` Date,\r\n    `end` Date,\r\n    `start_date` Date EXPRESSION date - toIntervalDay(1),\r\n    `end_date` Date EXPRESSION any(date) OVER (PARTITION BY id ORDER BY date ASC Rows BETWEEN 1 PRECEDING AND 1 PRECEDING)\r\n)\r\nPRIMARY KEY id\r\nSOURCE(CLICKHOUSE(TABLE 'test_range_dict'))\r\nLIFETIME(MIN 0 MAX 120)\r\nLAYOUT(RANGE_HASHED())\r\nRANGE(MIN start MAX end)\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.006 sec.\r\n\r\n\r\nSELECT *\r\nFROM test_range_dict_d\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.011 sec.\r\n\r\n\r\nDROP DICTIONARY  test_range_dict_d;\r\n\r\nCREATE DICTIONARY IF NOT EXISTS test_range_dict_d\r\n(\r\n    `id` UInt64,\r\n    `date` Date,\r\n    `start` Date,\r\n    `end` Date,\r\n    `start_date` Date EXPRESSION date - toIntervalDay(1),\r\n    `end_date` Date EXPRESSION any(date) OVER (PARTITION BY id ORDER BY date ASC Rows BETWEEN 1 PRECEDING AND 1 PRECEDING)\r\n)\r\nPRIMARY KEY id\r\nSOURCE(CLICKHOUSE(TABLE 'test_range_dict'))\r\nLIFETIME(MIN 0 MAX 120)\r\nLAYOUT(RANGE_HASHED())\r\nRANGE(MIN start_date MAX end_date)\r\n\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.008 sec.\r\n\r\n\r\nSELECT *\r\nFROM test_range_dict_d\r\n\r\n\r\n0 rows in set. Elapsed: 0.002 sec.\r\n\r\nReceived exception from server (version 21.11.1):\r\nCode: 47. DB::Exception: Received from localhost:9000. DB::Exception: Missing columns: 'end_date' 'start_date' while processing query: 'SELECT id, start_date, end_date, date, start, end FROM default.test_range_dict', required columns: 'start_date' 'id' 'end' 'end_date' 'start' 'date', maybe you meant: ['id','end','start','date']. (UNKNOWN_IDENTIFIER)\r\n```\r\n\r\n**Expected behavior**\r\nDictionary works\r\n\n",
  "hints_text": "",
  "created_at": "2022-01-08T21:17:34Z"
}