{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 10318,
  "instance_id": "ClickHouse__ClickHouse-10318",
  "issue_numbers": [
    "4767"
  ],
  "base_commit": "9b66f33eb5ddd028d8cc134ef3a26c1cd84d53fc",
  "patch": "diff --git a/src/Columns/IColumn.h b/src/Columns/IColumn.h\nindex 090537d67704..4af593bb6583 100644\n--- a/src/Columns/IColumn.h\n+++ b/src/Columns/IColumn.h\n@@ -44,7 +44,7 @@ class IColumn : public COW<IColumn>\n     /// Name of a Column kind, without parameters (example: FixedString, Array).\n     virtual const char * getFamilyName() const = 0;\n \n-    /** If column isn't constant, returns nullptr (or itself).\n+    /** If column isn't constant, returns itself.\n       * If column is constant, transforms constant to full column (if column type allows such transform) and return it.\n       */\n     virtual Ptr convertToFullColumnIfConst() const { return getPtr(); }\ndiff --git a/src/Functions/least.cpp b/src/Functions/least.cpp\nindex f2e7c1f15d21..ba87e4bd7e41 100644\n--- a/src/Functions/least.cpp\n+++ b/src/Functions/least.cpp\n@@ -1,6 +1,8 @@\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionBinaryArithmetic.h>\n #include <Core/AccurateComparison.h>\n+#include <Functions/LeastGreatestGeneric.h>\n+\n \n namespace DB\n {\n@@ -57,7 +59,7 @@ using FunctionLeast = FunctionBinaryArithmetic<LeastImpl, NameLeast>;\n \n void registerFunctionLeast(FunctionFactory & factory)\n {\n-    factory.registerFunction<FunctionLeast>(FunctionFactory::CaseInsensitive);\n+    factory.registerFunction<LeastGreatestOverloadResolver<LeastGreatest::Least, FunctionLeast>>(FunctionFactory::CaseInsensitive);\n }\n \n }\n",
  "test_patch": "diff --git a/src/Functions/LeastGreatestGeneric.h b/src/Functions/LeastGreatestGeneric.h\nnew file mode 100644\nindex 000000000000..2d6d71b20c7d\n--- /dev/null\n+++ b/src/Functions/LeastGreatestGeneric.h\n@@ -0,0 +1,140 @@\n+#pragma once\n+\n+#include <DataTypes/getLeastSupertype.h>\n+#include <DataTypes/NumberTraits.h>\n+#include <Interpreters/castColumn.h>\n+#include <Columns/ColumnsNumber.h>\n+#include <Functions/IFunctionImpl.h>\n+#include <Functions/FunctionFactory.h>\n+#include <ext/map.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+}\n+\n+\n+enum class LeastGreatest\n+{\n+    Least,\n+    Greatest\n+};\n+\n+\n+template <LeastGreatest kind>\n+class FunctionLeastGreatestGeneric : public IFunction\n+{\n+public:\n+    static constexpr auto name = kind == LeastGreatest::Least ? \"least\" : \"greatest\";\n+    static FunctionPtr create(const Context &) { return std::make_shared<FunctionLeastGreatestGeneric<kind>>(); }\n+\n+private:\n+    String getName() const override { return name; }\n+    size_t getNumberOfArguments() const override { return 0; }\n+    bool isVariadic() const override { return true; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const DataTypes & types) const override\n+    {\n+        if (types.empty())\n+            throw Exception(\"Function \" + getName() + \" cannot be called without arguments\", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+\n+        return getLeastSupertype(types);\n+    }\n+\n+    void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t input_rows_count) override\n+    {\n+        size_t num_arguments = arguments.size();\n+        if (1 == num_arguments)\n+        {\n+            block.getByPosition(result).column = block.getByPosition(arguments[0]).column;\n+            return;\n+        }\n+\n+        auto result_type = block.getByPosition(result).type;\n+\n+        Columns converted_columns(num_arguments);\n+        for (size_t arg = 0; arg < num_arguments; ++arg)\n+            converted_columns[arg] = castColumn(block.getByPosition(arguments[arg]), result_type)->convertToFullColumnIfConst();\n+\n+        auto result_column = result_type->createColumn();\n+        result_column->reserve(input_rows_count);\n+\n+        for (size_t row_num = 0; row_num < input_rows_count; ++row_num)\n+        {\n+            size_t best_arg = 0;\n+            for (size_t arg = 1; arg < num_arguments; ++arg)\n+            {\n+                auto cmp_result = converted_columns[arg]->compareAt(row_num, row_num, *converted_columns[best_arg], 1);\n+\n+                if constexpr (kind == LeastGreatest::Least)\n+                {\n+                    if (cmp_result < 0)\n+                        best_arg = arg;\n+                }\n+                else\n+                {\n+                    if (cmp_result > 0)\n+                        best_arg = arg;\n+                }\n+            }\n+\n+            result_column->insertFrom(*converted_columns[best_arg], row_num);\n+        }\n+\n+        block.getByPosition(result).column = std::move(result_column);\n+    }\n+};\n+\n+\n+template <LeastGreatest kind, typename SpecializedFunction>\n+class LeastGreatestOverloadResolver : public IFunctionOverloadResolverImpl\n+{\n+public:\n+    static constexpr auto name = kind == LeastGreatest::Least ? \"least\" : \"greatest\";\n+\n+    static FunctionOverloadResolverImplPtr create(const Context & context)\n+    {\n+        return std::make_unique<LeastGreatestOverloadResolver<kind, SpecializedFunction>>(context);\n+    }\n+\n+    explicit LeastGreatestOverloadResolver(const Context & context_) : context(context_) {}\n+\n+    String getName() const override { return name; }\n+    size_t getNumberOfArguments() const override { return 0; }\n+    bool isVariadic() const override { return true; }\n+\n+    FunctionBaseImplPtr build(const ColumnsWithTypeAndName & arguments, const DataTypePtr & return_type) const override\n+    {\n+        DataTypes argument_types;\n+\n+        /// More efficient specialization for two numeric arguments.\n+        if (arguments.size() == 2 && isNumber(arguments[0].type) && isNumber(arguments[1].type))\n+            return std::make_unique<DefaultFunction>(SpecializedFunction::create(context), argument_types, return_type);\n+\n+        return std::make_unique<DefaultFunction>(\n+            FunctionLeastGreatestGeneric<kind>::create(context), argument_types, return_type);\n+    }\n+\n+    DataTypePtr getReturnType(const DataTypes & types) const override\n+    {\n+        if (types.empty())\n+            throw Exception(\"Function \" + getName() + \" cannot be called without arguments\", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+\n+        if (types.size() == 2 && isNumber(types[0]) && isNumber(types[1]))\n+            return SpecializedFunction::create(context)->getReturnTypeImpl(types);\n+\n+        return getLeastSupertype(types);\n+    }\n+\n+private:\n+    const Context & context;\n+};\n+\n+}\n+\n+\ndiff --git a/src/Functions/greatest.cpp b/src/Functions/greatest.cpp\nindex 9abf85e751be..63f08d0affe2 100644\n--- a/src/Functions/greatest.cpp\n+++ b/src/Functions/greatest.cpp\n@@ -1,6 +1,8 @@\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionBinaryArithmetic.h>\n #include <Core/AccurateComparison.h>\n+#include <Functions/LeastGreatestGeneric.h>\n+\n \n namespace DB\n {\n@@ -57,7 +59,7 @@ using FunctionGreatest = FunctionBinaryArithmetic<GreatestImpl, NameGreatest>;\n \n void registerFunctionGreatest(FunctionFactory & factory)\n {\n-    factory.registerFunction<FunctionGreatest>(FunctionFactory::CaseInsensitive);\n+    factory.registerFunction<LeastGreatestOverloadResolver<LeastGreatest::Greatest, FunctionGreatest>>(FunctionFactory::CaseInsensitive);\n }\n \n }\ndiff --git a/tests/performance/least_greatest_hits.xml b/tests/performance/least_greatest_hits.xml\nnew file mode 100644\nindex 000000000000..464656b0201e\n--- /dev/null\n+++ b/tests/performance/least_greatest_hits.xml\n@@ -0,0 +1,9 @@\n+<test>\n+    <preconditions>\n+        <table_exists>test.hits</table_exists>\n+    </preconditions>\n+\n+    <query>SELECT count() FROM test.hits WHERE NOT ignore(least(URL, Referer))</query>\n+    <query>SELECT count() FROM test.hits WHERE NOT ignore(greatest(URL, Referer, Title))</query>\n+    <query>SELECT count() FROM test.hits WHERE NOT ignore(greatest(ClientIP, RemoteIP))</query>\n+</test>\ndiff --git a/tests/queries/0_stateless/01246_least_greatest_generic.reference b/tests/queries/0_stateless/01246_least_greatest_generic.reference\nnew file mode 100644\nindex 000000000000..24c2233eed2c\n--- /dev/null\n+++ b/tests/queries/0_stateless/01246_least_greatest_generic.reference\n@@ -0,0 +1,22 @@\n+hello\n+world\n+\n+z\n+hello\n+world\n+1\n+\\N\n+\\N\n+nan\n+inf\n+-0\n+123\n+-1\n+4294967295\n+['world']\n+[[[]]]\n+[[[],[]]]\n+[]\n+[NULL]\n+[0]\n+[NULL]\ndiff --git a/tests/queries/0_stateless/01246_least_greatest_generic.sql b/tests/queries/0_stateless/01246_least_greatest_generic.sql\nnew file mode 100644\nindex 000000000000..f0dceabfcb56\n--- /dev/null\n+++ b/tests/queries/0_stateless/01246_least_greatest_generic.sql\n@@ -0,0 +1,36 @@\n+SELECT least('hello', 'world');\n+SELECT greatest('hello', 'world');\n+SELECT least('hello', 'world', '');\n+SELECT greatest('hello', 'world', 'z');\n+\n+SELECT least('hello');\n+SELECT greatest('world');\n+\n+SELECT least(1, inf, nan);\n+SELECT least(1, inf, nan, NULL);\n+SELECT greatest(1, inf, nan, NULL);\n+SELECT greatest(1, inf, nan);\n+SELECT greatest(1, inf);\n+\n+SELECT least(0., -0.);\n+SELECT least(toNullable(123), 456);\n+\n+-- This can be improved\n+SELECT LEAST(-1, 18446744073709551615); -- { serverError 43 }\n+SELECT LEAST(-1., 18446744073709551615); -- { serverError 43 }\n+\n+SELECT LEAST(-1., 18446744073709551615.);\n+SELECT greatest(-1, 1, 4294967295);\n+\n+SELECT greatest([], ['hello'], ['world']);\n+\n+SELECT least([[[], []]], [[[]]], [[[]], [[]]]);\n+SELECT greatest([[[], []]], [[[]]], [[[]], [[]]]);\n+\n+SELECT least([], [NULL]);\n+SELECT greatest([], [NULL]);\n+\n+SELECT LEAST([NULL], [0]);\n+SELECT GREATEST([NULL], [0]);\n+\n+SELECT Greatest();  -- { serverError 42 }\n",
  "problem_statement": "Function 'greatest' working for non numeric and for more than 2 arguments\nSample from MySQL documentation:\r\n\r\n```sql\r\nmysql> SELECT GREATEST(2,0);\r\n        -> 2\r\nmysql> SELECT GREATEST(34.0,3.0,5.0,767.0);\r\n        -> 767.0\r\nmysql> SELECT GREATEST('B','A','C');\r\n        -> 'C'\r\n```\n",
  "hints_text": "First make it case insensitive...\ndec3e0f986\narrayMin and arrayMax also can be worth doing.",
  "created_at": "2020-04-16T22:40:16Z"
}