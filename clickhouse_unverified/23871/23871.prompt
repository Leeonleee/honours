You will be provided with a partial code base and an issue statement explaining a problem to resolve.

<issue>
RFC. Support for Postgres-style cast expressions
**Use case**
Allow to write `0.1::Decimal(38, 38)` as an alternative to `CAST('0.1' AS Decimal(38, 38))`.
Note that `CAST(0.1 AS Decimal(38, 38))` without quotes won't work correctly because `0.1` is Float64.

```
$ clickhouse-local --query "SELECT CAST('0.1' AS Decimal(38, 38))"
0.10000000000000000000000000000000000000
$ clickhouse-local --query "SELECT CAST(0.1 AS Decimal(38, 38))"
0.10000000000000000719354278919532445696
```

**Describe the solution you'd like**
Support for `::` operator in parser. Left hand side will be parsed directly by the data type from the right hand side (in "quoted" style format as in VALUES). If the data type cannot parse the left hand side, it will be interpreted as CAST operator.

Example:

`[1, 2]::Array(UInt8)`

If array is large enough it will speed up query parsing significantly.

`[1 + 1, 2]::Array(UInt8)`

In this case, array cannot be parsed by the data type. It will be interpreted as `CAST([1 + 1, 2] AS Array(UInt8))`.

**Advantages**
- more easy way to write Decimal values in query;
- speed up parsing of long arrays and sets;
- resembles Postgres syntax that many users will find familiar;

**Caveats**
- parser will depend on data types;
- in case of complex expressions, exception will be thrown and catched (slow);
- extra syntax that already has an alternative - CAST operator;
- the syntax is non standard;
- trouble may happen in examples like `(0+1+2+3+4)::Date`

**Alternatives**
1. Implement the same technique for `CAST` operator without introducing a new syntax.
2. Special syntax for Decimal literals like `0.1::Decimal` or even `0.1d`. Don't introduce full featured `::` operator.
</issue>

I need you to solve the provided issue by generating a code fix that can be applied directly to the repository

Respond below:
