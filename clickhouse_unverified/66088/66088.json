{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 66088,
  "instance_id": "ClickHouse__ClickHouse-66088",
  "issue_numbers": [
    "64514"
  ],
  "base_commit": "196df125b1e9fa9a5292cdb27ab479c6aeef1be6",
  "patch": "diff --git a/src/Functions/array/arrayIndex.h b/src/Functions/array/arrayIndex.h\nindex fa9b3dc92dd0..0782f1091870 100644\n--- a/src/Functions/array/arrayIndex.h\n+++ b/src/Functions/array/arrayIndex.h\n@@ -1,4 +1,5 @@\n #pragma once\n+#include <cstddef>\n #include <Functions/IFunction.h>\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionHelpers.h>\n@@ -13,6 +14,8 @@\n #include <Columns/ColumnFixedString.h>\n #include <Columns/ColumnsNumber.h>\n #include <Columns/ColumnNullable.h>\n+#include \"Common/Logger.h\"\n+#include \"Common/logger_useful.h\"\n #include <Common/FieldVisitorsAccurateComparison.h>\n #include <Common/memcmpSmall.h>\n #include <Common/assert_cast.h>\n@@ -28,6 +31,7 @@ namespace ErrorCodes\n {\n     extern const int ILLEGAL_COLUMN;\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int LOGICAL_ERROR;\n }\n \n using NullMap = PaddedPODArray<UInt8>;\n@@ -424,31 +428,21 @@ class FunctionArrayIndex : public IFunction\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t /*input_rows_count*/) const override\n     {\n-        if constexpr (std::is_same_v<ConcreteAction, HasAction>)\n-        {\n-            if (isMap(arguments[0].type))\n-            {\n-                auto non_const_map_column = arguments[0].column->convertToFullColumnIfConst();\n-\n-                const auto & map_column = assert_cast<const ColumnMap &>(*non_const_map_column);\n-                const auto & map_array_column = map_column.getNestedColumn();\n-                auto offsets = map_array_column.getOffsetsPtr();\n-                auto keys = map_column.getNestedData().getColumnPtr(0);\n-                auto array_column = ColumnArray::create(keys, offsets);\n+        if (auto res = executeMap(arguments, result_type))\n+            return res;\n \n-                const auto & type_map = assert_cast<const DataTypeMap &>(*arguments[0].type);\n-                auto array_type = std::make_shared<DataTypeArray>(type_map.getKeyType());\n+        if (auto res = executeArrayLowCardinality(arguments))\n+            return res;\n \n-                auto arguments_copy = arguments;\n-                arguments_copy[0].column = std::move(array_column);\n-                arguments_copy[0].type = std::move(array_type);\n-                arguments_copy[0].name = arguments[0].name;\n+        auto new_arguments = arguments;\n \n-                return executeArrayImpl(arguments_copy, result_type);\n-            }\n+        for (auto & argument : new_arguments)\n+        {\n+            argument.column = recursiveRemoveLowCardinality(argument.column);\n+            argument.type = recursiveRemoveLowCardinality(argument.type);\n         }\n \n-        return executeArrayImpl(arguments, result_type);\n+        return executeArrayImpl(new_arguments, result_type);\n     }\n \n private:\n@@ -458,18 +452,6 @@ class FunctionArrayIndex : public IFunction\n \n     using NullMaps = std::pair<const NullMap *, const NullMap *>;\n \n-    struct ExecutionData\n-    {\n-        const IColumn& left;\n-        const IColumn& right;\n-        const ColumnArray::Offsets& offsets;\n-        ColumnPtr result_column;\n-        NullMaps maps;\n-        ResultColumnPtr result { ResultColumnType::create() };\n-\n-        void moveResult() { result_column = std::move(result); }\n-    };\n-\n     static bool allowArguments(const DataTypePtr & inner_type, const DataTypePtr & arg)\n     {\n         auto inner_type_decayed = removeNullable(removeLowCardinality(inner_type));\n@@ -574,23 +556,13 @@ class FunctionArrayIndex : public IFunction\n         }\n     }\n \n-#define INTEGRAL_TPL_PACK UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64, Float32, Float64\n+#define INTEGRAL_PACK UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64, Float32, Float64\n \n     ColumnPtr executeOnNonNullable(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type) const\n     {\n-        if (const auto* const left_arr = checkAndGetColumn<ColumnArray>(arguments[0].column.get()))\n-        {\n-            if (checkAndGetColumn<ColumnLowCardinality>(&left_arr->getData()))\n-            {\n-                if (auto res = executeLowCardinality(arguments))\n-                    return res;\n-\n-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal internal type of first argument of function {}\", getName());\n-            }\n-        }\n-\n         ColumnPtr res;\n-        if (!((res = executeIntegral<INTEGRAL_TPL_PACK>(arguments))\n+        if (!((res = executeNothing(arguments))\n+              || (res = executeIntegral<INTEGRAL_PACK>(arguments))\n               || (res = executeConst(arguments, result_type))\n               || (res = executeString(arguments))\n               || (res = executeGeneric(arguments))))\n@@ -599,6 +571,8 @@ class FunctionArrayIndex : public IFunction\n         return res;\n     }\n \n+#undef INTEGRAL_PACK\n+\n     /**\n      * The Array's internal data type may be quite tricky (containing a Nullable type somewhere). To process the\n      * Nullable types correctly, for each data type specialisation we provide two null maps (one for the data and one\n@@ -627,6 +601,14 @@ class FunctionArrayIndex : public IFunction\n         return {null_map_data, null_map_item};\n     }\n \n+    struct ExecutionData\n+    {\n+        const IColumn & left;\n+        const IColumn & right;\n+        const ColumnArray::Offsets & offsets;\n+        NullMaps null_maps;\n+    };\n+\n     /**\n      * Given a variadic pack #Integral, apply executeIntegralExpanded with such parameters:\n      * Integral s = {s1, s2, ...}\n@@ -635,39 +617,33 @@ class FunctionArrayIndex : public IFunction\n     template <typename... Integral>\n     static ColumnPtr executeIntegral(const ColumnsWithTypeAndName & arguments)\n     {\n-        const ColumnArray * const left = checkAndGetColumn<ColumnArray>(arguments[0].column.get());\n-\n-        if (!left)\n+        const auto * array = checkAndGetColumn<ColumnArray>(arguments[0].column.get());\n+        if (!array)\n             return nullptr;\n \n-        const ColumnPtr right_converted_ptr = arguments[1].column->convertToFullColumnIfLowCardinality();\n-        const IColumn& right = *right_converted_ptr.get();\n-\n-        ExecutionData data = {\n-            left->getData(),\n-            right,\n-            left->getOffsets(),\n-            nullptr,\n-            getNullMaps(arguments)\n+        ExecutionData data\n+        {\n+            .left = array->getData(),\n+            .right = *arguments[1].column,\n+            .offsets = array->getOffsets(),\n+            .null_maps = getNullMaps(arguments),\n         };\n \n-        if (executeIntegral<Integral...>(data))\n-            return data.result_column;\n-\n-        return nullptr;\n+        auto result = ResultColumnType::create();\n+        return executeIntegral<Integral...>(data, *result) ? std::move(result) : nullptr;\n     }\n \n     template <typename... Integral>\n-    static bool executeIntegral(ExecutionData& data)\n+    static bool executeIntegral(const ExecutionData & data, ResultColumnType & result)\n     {\n-        return (executeIntegralExpanded<Integral, Integral...>(data) || ...);\n+        return (executeIntegralExpanded<Integral, Integral...>(data, result) || ...);\n     }\n \n     /// Invoke executeIntegralImpl with such parameters: (A, other1), (A, other2), ...\n     template <typename A, typename... Other>\n-    static bool executeIntegralExpanded(ExecutionData& data)\n+    static bool executeIntegralExpanded(const ExecutionData & data, ResultColumnType & result)\n     {\n-        return (executeIntegralImpl<A, Other>(data) || ...);\n+        return (executeIntegralImpl<A, Other>(data, result) || ...);\n     }\n \n     /**\n@@ -676,40 +652,31 @@ class FunctionArrayIndex : public IFunction\n      * so we have to check all possible variants for #Initial and #Resulting types.\n      */\n     template <typename Initial, typename Resulting>\n-    static bool executeIntegralImpl(ExecutionData& data)\n+    static bool executeIntegralImpl(const ExecutionData & data, ResultColumnType & result)\n     {\n-        const ColumnVector<Initial> * col_nested = checkAndGetColumn<ColumnVector<Initial>>(&data.left);\n-\n-        if (!col_nested)\n+        const auto * left_typed = checkAndGetColumn<ColumnVector<Initial>>(&data.left);\n+        if (!left_typed)\n             return false;\n \n-        const auto [null_map_data, null_map_item] = data.maps;\n-\n-        if (data.right.onlyNull())\n-            Impl::Null<ConcreteAction>::process(\n-                data.offsets,\n-                data.result->getData(),\n-                null_map_data);\n-        else if (const auto item_arg_const = checkAndGetColumnConst<ColumnVector<Resulting>>(&data.right))\n+        if (const auto * item_arg_const = checkAndGetColumnConst<ColumnVector<Resulting>>(&data.right))\n             Impl::Main<ConcreteAction, true, Initial, Resulting>::vector(\n-                col_nested->getData(),\n+                left_typed->getData(),\n                 data.offsets,\n                 item_arg_const->template getValue<Resulting>(),\n-                data.result->getData(),\n-                null_map_data,\n+                result.getData(),\n+                data.null_maps.first,\n                 nullptr);\n-        else if (const auto item_arg_vector = checkAndGetColumn<ColumnVector<Resulting>>(&data.right))\n+        else if (const auto * item_arg_vector = checkAndGetColumn<ColumnVector<Resulting>>(&data.right))\n             Impl::Main<ConcreteAction, false, Initial, Resulting>::vector(\n-                col_nested->getData(),\n+                left_typed->getData(),\n                 data.offsets,\n                 item_arg_vector->getData(),\n-                data.result->getData(),\n-                null_map_data,\n-                null_map_item);\n+                result.getData(),\n+                data.null_maps.first,\n+                data.null_maps.second);\n         else\n             return false;\n \n-        data.moveResult();\n         return true;\n     }\n \n@@ -724,227 +691,161 @@ class FunctionArrayIndex : public IFunction\n      *\n      * Tips and tricks tried can be found at https://github.com/ClickHouse/ClickHouse/pull/12550 .\n      */\n-    static ColumnPtr executeLowCardinality(const ColumnsWithTypeAndName & arguments)\n+    static ColumnPtr executeArrayLowCardinality(const ColumnsWithTypeAndName & arguments)\n     {\n-        const ColumnArray * const col_array = checkAndGetColumn<ColumnArray>(arguments[0].column.get());\n+        const auto * col_array = checkAndGetColumn<ColumnArray>(arguments[0].column.get());\n+        const auto * col_array_const = checkAndGetColumnConstData<ColumnArray>(arguments[0].column.get());\n \n-        if (!col_array)\n+        if (!col_array && !col_array_const)\n             return nullptr;\n \n-        const ColumnLowCardinality * const col_lc = checkAndGetColumn<ColumnLowCardinality>(&col_array->getData());\n+        if (col_array_const)\n+            col_array = col_array_const;\n \n-        if (!col_lc)\n+        const auto * left_lc = checkAndGetColumn<ColumnLowCardinality>(&col_array->getData());\n+        if (!left_lc)\n             return nullptr;\n \n-        const auto [null_map_data, null_map_item] = getNullMaps(arguments);\n-\n-        if (const ColumnConst * col_arg_const = checkAndGetColumn<ColumnConst>(&*arguments[1].column))\n-        {\n-            const IColumnUnique & col_lc_dict = col_lc->getDictionary();\n-\n-            const DataTypeArray * const array_type = checkAndGetDataType<DataTypeArray>(arguments[0].type.get());\n-            const DataTypePtr target_type_ptr = recursiveRemoveLowCardinality(array_type->getNestedType());\n-\n-            ColumnPtr col_arg_cloned = castColumn(\n-                {col_arg_const->getDataColumnPtr(), arguments[1].type, arguments[1].name}, target_type_ptr);\n-\n-            ResultColumnPtr col_result = ResultColumnType::create();\n-            UInt64 index = 0;\n-\n-            if (!col_arg_cloned->isNullAt(0))\n-            {\n-                if (col_arg_cloned->isNullable())\n-                    col_arg_cloned = checkAndGetColumn<ColumnNullable>(*col_arg_cloned).getNestedColumnPtr();\n-\n-                StringRef elem = col_arg_cloned->getDataAt(0);\n-\n-                if (std::optional<UInt64> maybe_index = col_lc_dict.getOrFindValueIndex(elem); maybe_index)\n-                {\n-                    index = *maybe_index;\n-                }\n-                else\n-                {\n-                    const size_t offsets_size = col_array->getOffsets().size();\n-                    auto & data = col_result->getData();\n+        const auto * right_const = checkAndGetColumn<ColumnConst>(arguments[1].column.get());\n+        if (!right_const)\n+            return nullptr;\n \n-                    data.resize_fill(offsets_size);\n+        const auto & array_type  = assert_cast<const DataTypeArray &>(*arguments[0].type);\n+        const auto target_type = recursiveRemoveLowCardinality(array_type.getNestedType());\n+        auto right = recursiveRemoveLowCardinality(right_const->getDataColumnPtr());\n \n-                    return col_result;\n-                }\n-            }\n+        UInt64 index = 0;\n+        UInt64 left_size = arguments[0].column->size();\n+        ResultColumnPtr col_result = ResultColumnType::create();\n \n-            Impl::Main<ConcreteAction, true>::vector(\n-                col_lc->getIndexes(),\n-                col_array->getOffsets(),\n-                index, /** Assuming LowCardinality has index of NULL always as zero. */\n-                col_result->getData(),\n-                null_map_data,\n-                null_map_item);\n-\n-            return col_result;\n-        }\n-        else if (col_lc->nestedIsNullable()) // LowCardinality(Nullable(T)) and U\n+        if (!right->isNullAt(0))\n         {\n-            const ColumnPtr left_casted = col_lc->convertToFullColumnIfLowCardinality(); // Nullable(T)\n-            const ColumnNullable & left_nullable = checkAndGetColumn<ColumnNullable>(*left_casted);\n-\n-            const NullMap * const null_map_left_casted = &left_nullable.getNullMapColumn().getData();\n-\n-            const IColumn & left_ptr = left_nullable.getNestedColumn();\n-\n-            const ColumnPtr right_casted = arguments[1].column->convertToFullColumnIfLowCardinality();\n-            const ColumnNullable * const right_nullable = checkAndGetColumn<ColumnNullable>(right_casted.get());\n+            auto right_type = recursiveRemoveLowCardinality(arguments[1].type);\n+            right = castColumn({right, right_type, \"\"}, target_type);\n \n-            const NullMap * const null_map_right_casted = right_nullable\n-                ? &right_nullable->getNullMapColumn().getData()\n-                : null_map_item;\n+            if (right->isNullable())\n+                right = checkAndGetColumn<ColumnNullable>(*right).getNestedColumnPtr();\n \n-            const IColumn& right_ptr = right_nullable\n-                ? right_nullable->getNestedColumn()\n-                : *right_casted.get();\n+            StringRef elem = right->getDataAt(0);\n+            const auto & left_dict = left_lc->getDictionary();\n \n-            ExecutionData data =\n+            if (std::optional<UInt64> maybe_index = left_dict.getOrFindValueIndex(elem); maybe_index)\n             {\n-                left_ptr, right_ptr,\n-                col_array->getOffsets(),\n-                nullptr,\n-                {null_map_left_casted, null_map_right_casted}};\n+                index = *maybe_index;\n+            }\n+            else\n+            {\n+                col_result->getData().resize_fill(col_array->size());\n \n-            if (dispatchConvertedLowCardinalityColumns(data))\n-                return data.result_column;\n+                if (col_array_const)\n+                    return ColumnConst::create(std::move(col_result), left_size);\n+\n+                return col_result;\n+            }\n         }\n-        else // LowCardinality(T) and U, T not Nullable\n-        {\n-            if (arguments[1].column->isNullable())\n-                return nullptr;\n \n-            if (const auto* const arg_lc = checkAndGetColumn<ColumnLowCardinality>(arguments[1].column.get());\n-                arg_lc && arg_lc->isNullable())\n-                return nullptr;\n+        Impl::Main<ConcreteAction, true>::vector(\n+            left_lc->getIndexes(),\n+            col_array->getOffsets(),\n+            index, /** Assuming LowCardinality has index of NULL always as zero. */\n+            col_result->getData(),\n+            nullptr,\n+            nullptr);\n \n-            // LowCardinality(T) and U (possibly LowCardinality(V))\n+        if (col_array_const)\n+            return ColumnConst::create(std::move(col_result), left_size);\n \n-            const ColumnPtr left_casted = col_lc->convertToFullColumnIfLowCardinality();\n-            const ColumnPtr right_casted = arguments[1].column->convertToFullColumnIfLowCardinality();\n+        return col_result;\n+    }\n \n-            ExecutionData data =\n-            {\n-                *left_casted.get(), *right_casted.get(), col_array->getOffsets(),\n-                nullptr, {null_map_data, null_map_item}\n-            };\n+    ColumnPtr executeMap(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type) const\n+    {\n+        if constexpr (!std::is_same_v<ConcreteAction, HasAction>)\n+            return nullptr;\n \n-            if (dispatchConvertedLowCardinalityColumns(data))\n-                return data.result_column;\n-        }\n+        if (!isMap(arguments[0].type))\n+            return nullptr;\n \n-        return nullptr;\n-    }\n+        auto non_const_map_column = arguments[0].column->convertToFullColumnIfConst();\n \n-    static bool dispatchConvertedLowCardinalityColumns(ExecutionData & data)\n-    {\n-        if (data.left.isNumeric() && data.right.isNumeric()) // ColumnArrays\n-            return executeIntegral<INTEGRAL_TPL_PACK>(data);\n+        const auto & map_column = assert_cast<const ColumnMap &>(*non_const_map_column);\n+        const auto & map_array_column = map_column.getNestedColumn();\n+        auto offsets = map_array_column.getOffsetsPtr();\n+        auto keys = map_column.getNestedData().getColumnPtr(0);\n+        auto array_column = ColumnArray::create(keys, offsets);\n \n-        if (checkAndGetColumn<ColumnString>(&data.left))\n-            return executeStringImpl(data);\n+        const auto & type_map = assert_cast<const DataTypeMap &>(*arguments[0].type);\n+        auto array_type = std::make_shared<DataTypeArray>(type_map.getKeyType());\n \n-        Impl::Main<ConcreteAction, true>::vector(\n-            data.left,\n-            data.offsets, data.right,\n-            data.result->getData(),\n-            data.maps.first, data.maps.second);\n+        auto arguments_copy = arguments;\n+        arguments_copy[0].column = std::move(array_column);\n+        arguments_copy[0].type = std::move(array_type);\n+        arguments_copy[0].name = arguments[0].name;\n \n-        data.moveResult();\n-        return true;\n+        return executeArrayImpl(arguments_copy, result_type);\n     }\n \n-#undef INTEGRAL_TPL_PACK\n-\n     static ColumnPtr executeString(const ColumnsWithTypeAndName & arguments)\n     {\n-        const ColumnArray * array = checkAndGetColumn<ColumnArray>(arguments[0].column.get());\n-\n+        const auto * array = checkAndGetColumn<ColumnArray>(arguments[0].column.get());\n         if (!array)\n             return nullptr;\n \n-        const ColumnString * left = checkAndGetColumn<ColumnString>(&array->getData());\n-\n+        const auto * left = checkAndGetColumn<ColumnString>(&array->getData());\n         if (!left)\n             return nullptr;\n \n-        const ColumnPtr right_ptr = arguments[1].column->convertToFullColumnIfLowCardinality();\n-        const IColumn & right = *right_ptr.get();\n-\n-        ExecutionData data = {\n-            *left, right, array->getOffsets(),\n-            nullptr, getNullMaps(arguments),\n-            std::move(ResultColumnType::create())\n-        };\n-\n-        if (executeStringImpl(data))\n-            return data.result_column;\n-\n-        return nullptr;\n-    }\n+        const auto & right = *arguments[1].column;\n+        const auto [null_map_data, null_map_item] = getNullMaps(arguments);\n \n-    static bool executeStringImpl(ExecutionData& data)\n-    {\n-        const auto [null_map_data, null_map_item] = data.maps;\n-        const ColumnString& left = *typeid_cast<const ColumnString* const>(&data.left);\n+        auto result = ResultColumnType::create();\n \n-        if (data.right.onlyNull())\n-            Impl::Null<ConcreteAction>::process(\n-                data.offsets,\n-                data.result->getData(),\n-                null_map_data);\n-        else if (const auto *const item_arg_const = checkAndGetColumnConstStringOrFixedString(&data.right))\n+        if (const auto * item_arg_const = checkAndGetColumnConstStringOrFixedString(&right))\n         {\n-            const ColumnString * item_const_string =\n-                checkAndGetColumn<ColumnString>(&item_arg_const->getDataColumn());\n-\n-            const ColumnFixedString * item_const_fixedstring =\n-                checkAndGetColumn<ColumnFixedString>(&item_arg_const->getDataColumn());\n+            const auto * item_const_string = checkAndGetColumn<ColumnString>(&item_arg_const->getDataColumn());\n+            const auto * item_const_fixedstring = checkAndGetColumn<ColumnFixedString>(&item_arg_const->getDataColumn());\n \n             if (item_const_string)\n                 Impl::String<ConcreteAction>::process(\n-                    left.getChars(),\n-                    data.offsets,\n-                    left.getOffsets(),\n+                    left->getChars(),\n+                    array->getOffsets(),\n+                    left->getOffsets(),\n                     item_const_string->getChars(),\n                     item_const_string->getDataAt(0).size,\n-                    data.result->getData(),\n+                    result->getData(),\n                     null_map_data,\n                     null_map_item);\n             else if (item_const_fixedstring)\n                 Impl::String<ConcreteAction>::process(\n-                    left.getChars(),\n-                    data.offsets,\n-                    left.getOffsets(),\n+                    left->getChars(),\n+                    array->getOffsets(),\n+                    left->getOffsets(),\n                     item_const_fixedstring->getChars(),\n                     item_const_fixedstring->getN(),\n-                    data.result->getData(),\n+                    result->getData(),\n                     null_map_data,\n                     null_map_item);\n             else\n-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Logical error: ColumnConst contains not String nor FixedString column\");\n+                throw Exception(ErrorCodes::LOGICAL_ERROR, \"ColumnConst contains not String nor FixedString column\");\n         }\n-        else if (const auto *const item_arg_vector = checkAndGetColumn<ColumnString>(&data.right))\n+        else if (const auto * item_arg_vector = checkAndGetColumn<ColumnString>(&right))\n         {\n             Impl::String<ConcreteAction>::process(\n-                left.getChars(),\n-                data.offsets,\n-                left.getOffsets(),\n+                left->getChars(),\n+                array->getOffsets(),\n+                left->getOffsets(),\n                 item_arg_vector->getChars(),\n                 item_arg_vector->getOffsets(),\n-                data.result->getData(),\n+                result->getData(),\n                 null_map_data,\n                 null_map_item);\n         }\n         else\n-            return false;\n+        {\n+            return nullptr;\n+        }\n \n-        data.moveResult();\n-        return true;\n+        return result;\n     }\n \n     static ColumnPtr executeConst(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type)\n@@ -955,9 +856,7 @@ class FunctionArrayIndex : public IFunction\n             return nullptr;\n \n         Array arr = col_array->getValue<Array>();\n-\n-        const ColumnPtr right_ptr = arguments[1].column->convertToFullColumnIfLowCardinality();\n-        const IColumn * item_arg = right_ptr.get();\n+        const IColumn * item_arg = arguments[1].column.get();\n \n         if (isColumnConst(*item_arg))\n         {\n@@ -1026,48 +925,59 @@ class FunctionArrayIndex : public IFunction\n         }\n     }\n \n-    static ColumnPtr executeGeneric(const ColumnsWithTypeAndName & arguments)\n+    static ColumnPtr executeNothing(const ColumnsWithTypeAndName & arguments)\n     {\n-        const ColumnArray * col = checkAndGetColumn<ColumnArray>(arguments[0].column.get());\n+        const auto * array = checkAndGetColumn<ColumnArray>(arguments[0].column.get());\n+        if (!array)\n+            return nullptr;\n+\n+        if (arguments[1].column->onlyNull())\n+        {\n+            auto result = ResultColumnType::create();\n+            Impl::Null<ConcreteAction>::process(array->getOffsets(), result->getData(), getNullMaps(arguments).first);\n+            return result;\n+        }\n \n-        if (!col)\n+        return nullptr;\n+    }\n+\n+    static ColumnPtr executeGeneric(const ColumnsWithTypeAndName & arguments)\n+    {\n+        const auto * col_array = checkAndGetColumn<ColumnArray>(arguments[0].column.get());\n+        if (!col_array)\n             return nullptr;\n \n         DataTypePtr array_elements_type = assert_cast<const DataTypeArray &>(*arguments[0].type).getNestedType();\n         const DataTypePtr & index_type = arguments[1].type;\n \n-        DataTypePtr common_type = getLeastSupertype(DataTypes{array_elements_type, index_type});\n-\n-        ColumnPtr col_nested = castColumn({ col->getDataPtr(), array_elements_type, \"\" }, common_type);\n-\n-        const ColumnPtr right_ptr = arguments[1].column->convertToFullColumnIfLowCardinality();\n-        ColumnPtr item_arg = castColumn({ right_ptr, removeLowCardinality(index_type), \"\" }, common_type);\n+        DataTypePtr common_type = getLeastSupertype(DataTypes{array_elements_type, arguments[1].type});\n+        ColumnPtr col_nested = castColumn({ col_array->getDataPtr(), array_elements_type, \"\" }, common_type);\n+        ColumnPtr item_arg = castColumn({ arguments[1].column, removeLowCardinality(index_type), \"\" }, common_type);\n \n         auto col_res = ResultColumnType::create();\n \n         auto [null_map_data, null_map_item] = getNullMaps(arguments);\n \n-        if (item_arg->onlyNull())\n-            Impl::Null<ConcreteAction>::process(\n-                col->getOffsets(),\n-                col_res->getData(),\n-                null_map_data);\n-        else if (isColumnConst(*item_arg))\n+        if (const auto * item_arg_const = checkAndGetColumn<ColumnConst>(item_arg.get()))\n+        {\n             Impl::Main<ConcreteAction, true>::vector(\n                 *col_nested,\n-                col->getOffsets(),\n-                typeid_cast<const ColumnConst &>(*item_arg).getDataColumn(),\n+                col_array->getOffsets(),\n+                item_arg_const->getDataColumn(),\n                 col_res->getData(), /// TODO This is wrong.\n                 null_map_data,\n                 nullptr);\n+        }\n         else\n+        {\n             Impl::Main<ConcreteAction>::vector(\n                 *col_nested,\n-                col->getOffsets(),\n+                col_array->getOffsets(),\n                 *item_arg,\n                 col_res->getData(),\n                 null_map_data,\n                 null_map_item);\n+        }\n \n         return col_res;\n     }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02010_array_index_bad_cast.reference b/tests/queries/0_stateless/02010_array_index_bad_cast.reference\nindex e69de29bb2d1..e22493782f08 100644\n--- a/tests/queries/0_stateless/02010_array_index_bad_cast.reference\n+++ b/tests/queries/0_stateless/02010_array_index_bad_cast.reference\n@@ -0,0 +1,3 @@\n+1\n+0\n+0\ndiff --git a/tests/queries/0_stateless/02010_array_index_bad_cast.sql b/tests/queries/0_stateless/02010_array_index_bad_cast.sql\nindex 14162e0d2e29..590e60eb42eb 100644\n--- a/tests/queries/0_stateless/02010_array_index_bad_cast.sql\n+++ b/tests/queries/0_stateless/02010_array_index_bad_cast.sql\n@@ -1,3 +1,4 @@\n--- This query throws exception about uncomparable data types (but at least it does not introduce bad cast in code).\n SET allow_suspicious_low_cardinality_types=1;\n-SELECT has(materialize(CAST(['2021-07-14'] AS Array(LowCardinality(Nullable(DateTime))))), materialize('2021-07-14'::DateTime64(7))); -- { serverError ILLEGAL_COLUMN }\n+SELECT has(materialize(CAST(['2021-07-14'] AS Array(LowCardinality(Nullable(DateTime))))), materialize('2021-07-14'::DateTime64(7)));\n+SELECT has(materialize(CAST(['2021-07-14'] AS Array(LowCardinality(Nullable(DateTime))))), materialize('2021-07-14 00:00:01'::DateTime64(7)));\n+SELECT has(materialize(CAST(['2021-07-14'] AS Array(LowCardinality(Nullable(DateTime))))), materialize(NULL));\ndiff --git a/tests/queries/0_stateless/03199_has_lc_fixed_string.reference b/tests/queries/0_stateless/03199_has_lc_fixed_string.reference\nnew file mode 100644\nindex 000000000000..b261da18d51a\n--- /dev/null\n+++ b/tests/queries/0_stateless/03199_has_lc_fixed_string.reference\n@@ -0,0 +1,2 @@\n+1\n+0\ndiff --git a/tests/queries/0_stateless/03199_has_lc_fixed_string.sql b/tests/queries/0_stateless/03199_has_lc_fixed_string.sql\nnew file mode 100644\nindex 000000000000..3cb551804b7e\n--- /dev/null\n+++ b/tests/queries/0_stateless/03199_has_lc_fixed_string.sql\n@@ -0,0 +1,7 @@\n+DROP TABLE IF EXISTS 03199_fixedstring_array;\n+CREATE TABLE 03199_fixedstring_array (arr Array(LowCardinality(FixedString(8)))) ENGINE = Memory;\n+INSERT INTO 03199_fixedstring_array VALUES (['a', 'b']), (['c', 'd']);\n+\n+SELECT has(arr, toFixedString(materialize('a'), 1)) FROM 03199_fixedstring_array;\n+\n+DROP TABLE 03199_fixedstring_array;\n",
  "problem_statement": "Lowcardinality: Logical error: 'this->n == rhs.n'\nReport: https://s3.amazonaws.com/clickhouse-test-reports/0/2ba0d78eee6d6fc1c182c9c870e114a1\r\n\r\nMinimized:\r\n\r\n```\r\nSET allow_suspicious_low_cardinality_types=1\r\n\r\nCREATE TABLE fuzz (`ary` Array(LowCardinality(FixedString(4))),) ENGINE = MergeTree ORDER BY tuple();\r\n\r\nINSERT INTO fuzz VALUES ([]) (['o','a']) (['e','a','b']);\r\nINSERT INTO fuzz VALUES (['o','a','b','c']) (['e','a','b','c','d']);\r\n\r\nSELECT count() FROM fuzz WHERE has(ary, materialize(toFixedString('a', 1)));\r\n```\r\n\r\n```\r\n(gdb) bt\r\n#0  __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44\r\n#1  0x00007e1c3d74aeb3 in __pthread_kill_internal (threadid=<optimized out>, signo=6) at pthread_kill.c:78\r\n#2  0x00007e1c3d6f2a30 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26\r\n#3  0x00007e1c3d6da4c3 in __GI_abort () at abort.c:79\r\n#4  0x0000000013e7465a in DB::abortOnFailedAssertion (description=...) at /mnt/ch/ClickHouse/src/Common/Exception.cpp:44\r\n#5  0x000000001df9ec18 in DB::ColumnFixedString::compareAt (this=0x7e1b049bc300, p1=0, p2=0, rhs_=...) at /mnt/ch/ClickHouse/src/Columns/ColumnFixedString.h:135\r\n#6  0x0000000012b10335 in DB::Impl::Main<DB::HasAction, true, unsigned long, unsigned long>::compare (left=..., right=..., i=0, j=1) at /mnt/ch/ClickHouse/src/Functions/array/arrayIndex.h:107\r\n#7  0x0000000012b0f6b3 in DB::Impl::Main<DB::HasAction, true, unsigned long, unsigned long>::process<1ul, DB::IColumn, DB::IColumn> (data=..., offsets=..., target=..., result=..., null_map_data=0x0, null_map_item=0x0) at /mnt/ch/ClickHouse/src/Functions/array/arrayIndex.h:159\r\n#8  0x0000000012a9d1b3 in DB::Impl::Main<DB::HasAction, true, unsigned long, unsigned long>::vector<DB::IColumn, DB::IColumn> (data=..., offsets=..., value=..., result=..., null_map_data=0x0, null_map_item=0x0) at /mnt/ch/ClickHouse/src/Functions/array/arrayIndex.h:184\r\n#9  0x0000000013877c0a in DB::FunctionArrayIndex<DB::HasAction, DB::NameHas>::dispatchConvertedLowCardinalityColumns (data=...) at /mnt/ch/ClickHouse/src/Functions/array/arrayIndex.h:851\r\n#10 0x0000000013876174 in DB::FunctionArrayIndex<DB::HasAction, DB::NameHas>::executeLowCardinality (arguments=...) at /mnt/ch/ClickHouse/src/Functions/array/arrayIndex.h:836\r\n#11 0x0000000013874fa4 in DB::FunctionArrayIndex<DB::HasAction, DB::NameHas>::executeOnNonNullable (this=0x7e19aa4aaaf8, arguments=..., result_type=...) at /mnt/ch/ClickHouse/src/Functions/array/arrayIndex.h:585\r\n#12 0x00000000138749cf in DB::FunctionArrayIndex<DB::HasAction, DB::NameHas>::executeArrayImpl (this=0x7e19aa4aaaf8, arguments=..., result_type=...) at /mnt/ch/ClickHouse/src/Functions/array/arrayIndex.h:516\r\n#13 0x0000000013874192 in DB::FunctionArrayIndex<DB::HasAction, DB::NameHas>::executeImpl (this=0x7e19aa4aaaf8, arguments=..., result_type=...) at /mnt/ch/ClickHouse/src/Functions/array/arrayIndex.h:451\r\n#14 0x000000000bb3dd8d in DB::FunctionToExecutableFunctionAdaptor::executeImpl (this=0x7e19aa4aac60, arguments=..., result_type=..., input_rows_count=3) at /mnt/ch/ClickHouse/src/Functions/IFunctionAdaptors.h:21\r\n#15 0x000000001a4ba149 in DB::IExecutableFunction::executeWithoutLowCardinalityColumns (this=0x7e19aa4aac60, args=..., result_type=..., input_rows_count=3, dry_run=false) at /mnt/ch/ClickHouse/src/Functions/IFunction.cpp:248\r\n#16 0x000000001a4bb424 in DB::IExecutableFunction::executeWithoutSparseColumns (this=0x7e19aa4aac60, arguments=..., result_type=..., input_rows_count=3, dry_run=false) at /mnt/ch/ClickHouse/src/Functions/IFunction.cpp:307\r\n#17 0x000000001a4bc4c4 in DB::IExecutableFunction::execute (this=0x7e19aa4aac60, arguments=..., result_type=..., input_rows_count=3, dry_run=false) at /mnt/ch/ClickHouse/src/Functions/IFunction.cpp:378\r\n#18 0x000000001c49defc in DB::executeAction (action=..., execution_context=..., dry_run=false, allow_duplicates_in_input=false) at /mnt/ch/ClickHouse/src/Interpreters/ExpressionActions.cpp:616\r\n#19 0x000000001c49d159 in DB::ExpressionActions::execute (this=0x7e19aa1df798, block=..., num_rows=@0x7e19a71ed498: 3, dry_run=false, allow_duplicates_in_input=false) at /mnt/ch/ClickHouse/src/Interpreters/ExpressionActions.cpp:750\r\n#20 0x000000001c49ee0e in DB::ExpressionActions::execute (this=0x7e19aa1df798, block=..., dry_run=false, allow_duplicates_in_input=false) at /mnt/ch/ClickHouse/src/Interpreters/ExpressionActions.cpp:796\r\n#21 0x000000001f0fff73 in DB::MergeTreeRangeReader::executePrewhereActionsAndFilterColumns (this=0x7e1b049bd030, result=...) at /mnt/ch/ClickHouse/src/Storages/MergeTree/MergeTreeRangeReader.cpp:1482\r\n#22 0x000000001f0fe1ae in DB::MergeTreeRangeReader::read (this=0x7e1b049bd030, max_rows=3, ranges=...) at /mnt/ch/ClickHouse/src/Storages/MergeTree/MergeTreeRangeReader.cpp:1071\r\n#23 0x000000001f136a61 in DB::MergeTreeReadTask::read (this=0x7e1b049bd000, params=...) at /mnt/ch/ClickHouse/src/Storages/MergeTree/MergeTreeReadTask.cpp:161\r\n#24 0x0000000020205aec in DB::MergeTreeThreadSelectAlgorithm::readFromTask (this=0x7e1b078c64c0, task=..., params=...) at /mnt/ch/ClickHouse/src/Storages/MergeTree/MergeTreeSelectAlgorithms.h:38\r\n#25 0x000000001f1300ed in DB::MergeTreeSelectProcessor::read (this=0x7e1b07956800) at /mnt/ch/ClickHouse/src/Storages/MergeTree/MergeTreeSelectProcessor.cpp:137\r\n#26 0x0000000020266a9c in DB::MergeTreeSource::tryGenerate (this=0x7e1b078f7098) at /mnt/ch/ClickHouse/src/Storages/MergeTree/MergeTreeSource.cpp:226\r\n#27 0x000000001f8835c3 in DB::ISource::work (this=0x7e1b078f7098) at /mnt/ch/ClickHouse/src/Processors/ISource.cpp:108\r\n#28 0x000000001f8c6339 in DB::executeJob (node=0x7e19aa16ab00, read_progress_callback=0x7e1b079b91b0) at /mnt/ch/ClickHouse/src/Processors/Executors/ExecutionThreadContext.cpp:47\r\n#29 0x000000001f8c6001 in DB::ExecutionThreadContext::executeTask (this=0x7e19b5cac100) at /mnt/ch/ClickHouse/src/Processors/Executors/ExecutionThreadContext.cpp:96\r\n#30 0x000000001f8a499e in DB::PipelineExecutor::executeStepImpl (this=0x7e19aa10fdd8, thread_num=1, yield_flag=0x0) at /mnt/ch/ClickHouse/src/Processors/Executors/PipelineExecutor.cpp:272\r\n#31 0x000000001f8a4dc4 in DB::PipelineExecutor::executeSingleThread (this=0x7e19aa10fdd8, thread_num=1) at /mnt/ch/ClickHouse/src/Processors/Executors/PipelineExecutor.cpp:238\r\n#32 0x000000001f8a5ce7 in DB::PipelineExecutor::spawnThreads()::$_0::operator()() const (this=0x7e19b5c3d500) at /mnt/ch/ClickHouse/src/Processors/Executors/PipelineExecutor.cpp:372\r\n#33 0x000000001f8a5c35 in std::__1::__invoke[abi:v15000]<DB::PipelineExecutor::spawnThreads()::$_0&>(DB::PipelineExecutor::spawnThreads()::$_0&) (__f=...) at /mnt/ch/ClickHouse/contrib/llvm-project/libcxx/include/__functional/invoke.h:394\r\n#34 0x000000001f8a5c15 in std::__1::__invoke_void_return_wrapper<void, true>::__call<DB::PipelineExecutor::spawnThreads()::$_0&>(DB::PipelineExecutor::spawnThreads()::$_0&) (__args=...) at /mnt/ch/ClickHouse/contrib/llvm-project/libcxx/include/__functional/invoke.h:479\r\n#35 0x000000001f8a5bf5 in std::__1::__function::__default_alloc_func<DB::PipelineExecutor::spawnThreads()::$_0, void ()>::operator()[abi:v15000]() (this=0x7e19b5c3d500) at /mnt/ch/ClickHouse/contrib/llvm-project/libcxx/include/__functional/function.h:235\r\n#36 0x000000001f8a5bc0 in std::__1::__function::__policy_invoker<void ()>::__call_impl<std::__1::__function::__default_alloc_func<DB::PipelineExecutor::spawnThreads()::$_0, void ()> >(std::__1::__function::__policy_storage const*) (__buf=0x7e19a71ef990)\r\n    at /mnt/ch/ClickHouse/contrib/llvm-project/libcxx/include/__functional/function.h:716\r\n#37 0x00000000125a6356 in std::__1::__function::__policy_func<void ()>::operator()[abi:v15000]() const (this=0x7e19a71ef990) at /mnt/ch/ClickHouse/contrib/llvm-project/libcxx/include/__functional/function.h:848\r\n#38 0x00000000125a5fb5 in std::__1::function<void ()>::operator()() const (this=0x7e19a71ef990) at /mnt/ch/ClickHouse/contrib/llvm-project/libcxx/include/__functional/function.h:1187\r\n#39 0x0000000013fc4872 in ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true> >::worker (this=0x7e19b5cb1000, thread_it=...) at /mnt/ch/ClickHouse/src/Common/ThreadPool.cpp:462\r\n#40 0x0000000013fcfdf1 in ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true> >::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}::operator()() const (this=0x7e19a71efb50)\r\n    at /mnt/ch/ClickHouse/src/Common/ThreadPool.cpp:219\r\n#41 0x0000000013fcfdb5 in std::__1::__invoke[abi:v15000]<ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true> >::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}&>(ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true> >::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}&) (__f=...) at /mnt/ch/ClickHouse/contrib/llvm-project/libcxx/include/__functional/invoke.h:394\r\n#42 0x0000000013fcfd99 in std::__1::__apply_tuple_impl[abi:v15000]<ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true> >::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}&, std::__1::tuple<>&>(ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true> >::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}&, std::__1::tuple<>&, std::__1::__tuple_indices<>) (__f=..., __t=...)\r\n    at /mnt/ch/ClickHouse/contrib/llvm-project/libcxx/include/tuple:1789\r\n#43 0x0000000013fcfbdd in std::__1::apply[abi:v15000]<ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true> >::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}&, std::__1::tuple<>&>(ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true> >::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}&, std::__1::tuple<>&) (__f=..., __t=...) at /mnt/ch/ClickHouse/contrib/llvm-project/libcxx/include/tuple:1798\r\n#44 0x0000000013fcfa5f in ThreadFromGlobalPoolImpl<false, true>::ThreadFromGlobalPoolImpl<ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true> >::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}>(ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true> >::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}&&)::{lambda()#1}::operator()() (this=0x7e19b5c76740) at /mnt/ch/ClickHouse/src/Common/ThreadPool.h:251\r\n#45 0x0000000013fcf8f5 in std::__1::__invoke[abi:v15000]<ThreadFromGlobalPoolImpl<false, true>::ThreadFromGlobalPoolImpl<ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true> >::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}>(ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true> >::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}&&)::{lambda()#1}&>(ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true> >::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}&&) (__f=...) at /mnt/ch/ClickHouse/contrib/llvm-project/libcxx/include/__functional/invoke.h:394\r\n#46 0x0000000013fcf8d5 in std::__1::__invoke_void_return_wrapper<void, true>::__call<ThreadFromGlobalPoolImpl<false, true>::ThreadFromGlobalPoolImpl<ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true> >::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}>(ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true> >::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}&&)::{lambda()#1}&>(ThreadFromGlobalPoolImpl<false, true>::ThreadFromGlobalPoolImpl<ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true> >::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}>(ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true> >::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}&&)::{lambda()#1}&) (__args=...) at /mnt/ch/ClickHouse/contrib/llvm-project/libcxx/include/__functional/invoke.h:479\r\n#47 0x0000000013fcf8b5 in std::__1::__function::__default_alloc_func<ThreadFromGlobalPoolImpl<false, true>::ThreadFromGlobalPoolImpl<ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true> >::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}>(ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true> >::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}&&)::{lambda()#1}, void ()>::operator()[abi:v15000]() (this=0x7e19b5c76740)\r\n    at /mnt/ch/ClickHouse/contrib/llvm-project/libcxx/include/__functional/function.h:235\r\n#48 0x0000000013fcf880 in std::__1::__function::__policy_invoker<void ()>::__call_impl<std::__1::__function::__default_alloc_func<ThreadFromGlobalPoolImpl<false, true>::ThreadFromGlobalPoolImpl<ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true> >::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}>(ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true> >::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}&&)::{lambda()#1}, void ()> >(std::__1::__function::__policy_storage const*) (__buf=0x7e19a71f0150) at /mnt/ch/ClickHouse/contrib/llvm-project/libcxx/include/__functional/function.h:716\r\n#49 0x00000000125a6356 in std::__1::__function::__policy_func<void ()>::operator()[abi:v15000]() const (this=0x7e19a71f0150) at /mnt/ch/ClickHouse/contrib/llvm-project/libcxx/include/__functional/function.h:848\r\n#50 0x00000000125a5fb5 in std::__1::function<void ()>::operator()() const (this=0x7e19a71f0150) at /mnt/ch/ClickHouse/contrib/llvm-project/libcxx/include/__functional/function.h:1187\r\n#51 0x0000000013fc0d32 in ThreadPoolImpl<std::__1::thread>::worker (this=0x7e1c3c83b180, thread_it=...) at /mnt/ch/ClickHouse/src/Common/ThreadPool.cpp:462\r\n#52 0x0000000013fc9411 in ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}::operator()() const (this=0x7e1a2a0ffe68) at /mnt/ch/ClickHouse/src/Common/ThreadPool.cpp:219\r\n#53 0x0000000013fc93b5 in std::__1::__invoke[abi:v15000]<ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}>(ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}&&) (__f=...) at /mnt/ch/ClickHouse/contrib/llvm-project/libcxx/include/__functional/invoke.h:394\r\n#54 0x0000000013fc937d in std::__1::__thread_execute[abi:v15000]<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct> >, ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::{lambda()#2}>(std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct> >, ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, --Type <RET> for more, q to quit, c to continue without paging--q\r\nQuit\r\n(gdb) f 5\r\n#5  0x000000001df9ec18 in DB::ColumnFixedString::compareAt (this=0x7e1b049bc300, p1=0, p2=0, rhs_=...) at /mnt/ch/ClickHouse/src/Columns/ColumnFixedString.h:135\r\n135             chassert(this->n == rhs.n);\r\n(gdb) p n\r\n$1 = 4\r\n(gdb) p rhs.n\r\n$2 = 1\r\n```\n",
  "hints_text": "Still present. Seems an issue with the implementation of LowCardinality for `has()`\r\n```\r\nFunctionArrayIndex::useDefaultImplementationForLowCardinalityColumns() const override { return false; }\r\n```",
  "created_at": "2024-07-04T12:51:37Z"
}