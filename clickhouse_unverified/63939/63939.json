{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 63939,
  "instance_id": "ClickHouse__ClickHouse-63939",
  "issue_numbers": [
    "63790"
  ],
  "base_commit": "c38841211d6fa9a6f47b6156cc94bad2f4c921ef",
  "patch": "diff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp\nindex 98d6031edca8..c7fd71093b1a 100644\n--- a/src/Interpreters/Context.cpp\n+++ b/src/Interpreters/Context.cpp\n@@ -1607,6 +1607,21 @@ Tables Context::getExternalTables() const\n \n \n void Context::addExternalTable(const String & table_name, TemporaryTableHolder && temporary_table)\n+{\n+    addExternalTable(table_name, std::make_shared<TemporaryTableHolder>(std::move(temporary_table)));\n+}\n+\n+void Context::updateExternalTable(const String & table_name, TemporaryTableHolder && temporary_table)\n+{\n+    updateExternalTable(table_name, std::make_shared<TemporaryTableHolder>(std::move(temporary_table)));\n+}\n+\n+void Context::addOrUpdateExternalTable(const String & table_name, TemporaryTableHolder && temporary_table)\n+{\n+    addOrUpdateExternalTable(table_name, std::make_shared<TemporaryTableHolder>(std::move(temporary_table)));\n+}\n+\n+void Context::addExternalTable(const String & table_name, std::shared_ptr<TemporaryTableHolder> temporary_table)\n {\n     if (isGlobalContext())\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Global context cannot have external tables\");\n@@ -1614,34 +1629,32 @@ void Context::addExternalTable(const String & table_name, TemporaryTableHolder &\n     std::lock_guard lock(mutex);\n     if (external_tables_mapping.end() != external_tables_mapping.find(table_name))\n         throw Exception(ErrorCodes::TABLE_ALREADY_EXISTS, \"Temporary table {} already exists\", backQuoteIfNeed(table_name));\n-    external_tables_mapping.emplace(table_name, std::make_shared<TemporaryTableHolder>(std::move(temporary_table)));\n+\n+    external_tables_mapping.emplace(table_name, std::move(temporary_table));\n }\n \n-void Context::updateExternalTable(const String & table_name, TemporaryTableHolder && temporary_table)\n+void Context::updateExternalTable(const String & table_name, std::shared_ptr<TemporaryTableHolder> temporary_table)\n {\n     if (isGlobalContext())\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Global context cannot have external tables\");\n \n-    auto temporary_table_ptr = std::make_shared<TemporaryTableHolder>(std::move(temporary_table));\n-\n     std::lock_guard lock(mutex);\n     auto it = external_tables_mapping.find(table_name);\n     if (it == external_tables_mapping.end())\n         throw Exception(ErrorCodes::TABLE_ALREADY_EXISTS, \"Temporary table {} does not exists\", backQuoteIfNeed(table_name));\n-    it->second = std::move(temporary_table_ptr);\n+\n+    it->second = std::move(temporary_table);\n }\n \n-void Context::addOrUpdateExternalTable(const String & table_name, TemporaryTableHolder && temporary_table)\n+void Context::addOrUpdateExternalTable(const String & table_name, std::shared_ptr<TemporaryTableHolder> temporary_table)\n {\n     if (isGlobalContext())\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Global context cannot have external tables\");\n \n-    auto temporary_table_ptr = std::make_shared<TemporaryTableHolder>(std::move(temporary_table));\n-\n     std::lock_guard lock(mutex);\n-    auto [it, inserted] = external_tables_mapping.emplace(table_name, temporary_table_ptr);\n+    auto [it, inserted] = external_tables_mapping.emplace(table_name, temporary_table);\n     if (!inserted)\n-        it->second = std::move(temporary_table_ptr);\n+        it->second = std::move(temporary_table);\n }\n \n std::shared_ptr<TemporaryTableHolder> Context::findExternalTable(const String & table_name) const\ndiff --git a/src/Interpreters/Context.h b/src/Interpreters/Context.h\nindex a6ab503430b6..190b38401246 100644\n--- a/src/Interpreters/Context.h\n+++ b/src/Interpreters/Context.h\n@@ -685,6 +685,9 @@ class Context: public ContextData, public std::enable_shared_from_this<Context>\n     void addExternalTable(const String & table_name, TemporaryTableHolder && temporary_table);\n     void updateExternalTable(const String & table_name, TemporaryTableHolder && temporary_table);\n     void addOrUpdateExternalTable(const String & table_name, TemporaryTableHolder && temporary_table);\n+    void addExternalTable(const String & table_name, std::shared_ptr<TemporaryTableHolder> temporary_table);\n+    void updateExternalTable(const String & table_name, std::shared_ptr<TemporaryTableHolder> temporary_table);\n+    void addOrUpdateExternalTable(const String & table_name, std::shared_ptr<TemporaryTableHolder> temporary_table);\n     std::shared_ptr<TemporaryTableHolder> findExternalTable(const String & table_name) const;\n     std::shared_ptr<TemporaryTableHolder> removeExternalTable(const String & table_name);\n \ndiff --git a/src/Processors/Sources/RecursiveCTESource.cpp b/src/Processors/Sources/RecursiveCTESource.cpp\nindex b94cb1880867..93503b45aafc 100644\n--- a/src/Processors/Sources/RecursiveCTESource.cpp\n+++ b/src/Processors/Sources/RecursiveCTESource.cpp\n@@ -102,6 +102,7 @@ class RecursiveCTEChunkGenerator\n             \"Recursive CTE subquery {}. Expected projection columns to have same size in recursive and non recursive subquery.\",\n             recursive_cte_union_node->formatASTForErrorMessage());\n \n+        working_temporary_table_holder = recursive_cte_table->holder;\n         working_temporary_table_storage = recursive_cte_table->storage;\n \n         intermediate_temporary_table_holder = std::make_shared<TemporaryTableHolder>(\n@@ -147,6 +148,7 @@ class RecursiveCTEChunkGenerator\n \n             truncateTemporaryTable(working_temporary_table_storage);\n \n+            std::swap(intermediate_temporary_table_holder, working_temporary_table_holder);\n             std::swap(intermediate_temporary_table_storage, working_temporary_table_storage);\n         }\n \n@@ -172,6 +174,9 @@ class RecursiveCTEChunkGenerator\n         SelectQueryOptions select_query_options;\n         select_query_options.merge_tree_enable_remove_parts_from_snapshot_optimization = false;\n \n+        const auto & recursive_table_name = recursive_cte_union_node->as<UnionNode &>().getCTEName();\n+        recursive_query_context->addOrUpdateExternalTable(recursive_table_name, working_temporary_table_holder);\n+\n         auto interpreter = std::make_unique<InterpreterSelectQueryAnalyzer>(query_to_execute, recursive_query_context, select_query_options);\n         auto pipeline_builder = interpreter->buildQueryPipeline();\n \n@@ -225,6 +230,7 @@ class RecursiveCTEChunkGenerator\n     QueryTreeNodePtr recursive_query;\n     ContextMutablePtr recursive_query_context;\n \n+    TemporaryTableHolderPtr working_temporary_table_holder;\n     StoragePtr working_temporary_table_storage;\n \n     TemporaryTableHolderPtr intermediate_temporary_table_holder;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03154_recursive_cte_distributed.reference b/tests/queries/0_stateless/03154_recursive_cte_distributed.reference\nnew file mode 100644\nindex 000000000000..0dd6d31104dc\n--- /dev/null\n+++ b/tests/queries/0_stateless/03154_recursive_cte_distributed.reference\n@@ -0,0 +1,26 @@\n+a\t\t['']\t0\n+b\ta\t['a']\t0\n+c\ta\t['a']\t0\n+b\ta\t['','b']\t1\n+c\ta\t['','c']\t1\n+--\n+a\t\t['']\t0\n+b\ta\t['a']\t0\n+c\ta\t['a']\t0\n+b\ta\t['','b']\t1\n+c\ta\t['','c']\t1\n+--\n+a\t\t['']\t0\n+a\t\t['']\t0\n+b\ta\t['a']\t0\n+b\ta\t['a']\t0\n+c\ta\t['a']\t0\n+c\ta\t['a']\t0\n+b\ta\t['','b']\t1\n+b\ta\t['','b']\t1\n+b\ta\t['','b']\t1\n+b\ta\t['','b']\t1\n+c\ta\t['','c']\t1\n+c\ta\t['','c']\t1\n+c\ta\t['','c']\t1\n+c\ta\t['','c']\t1\ndiff --git a/tests/queries/0_stateless/03154_recursive_cte_distributed.sql b/tests/queries/0_stateless/03154_recursive_cte_distributed.sql\nnew file mode 100644\nindex 000000000000..b8c3356d5d6e\n--- /dev/null\n+++ b/tests/queries/0_stateless/03154_recursive_cte_distributed.sql\n@@ -0,0 +1,48 @@\n+-- Tags: shard\n+\n+SET allow_experimental_analyzer = 1;\n+\n+DROP TABLE IF EXISTS test_table;\n+CREATE TABLE test_table\n+(\n+    id String,\n+    parent_id String\n+)\n+ENGINE = MergeTree ORDER BY id;\n+\n+INSERT INTO test_table VALUES ('a', '');\n+INSERT INTO test_table VALUES ('b', 'a');\n+INSERT INTO test_table VALUES ('c', 'a');\n+\n+WITH RECURSIVE search_tree AS (\n+    SELECT id, parent_id, [parent_id] AS path, toUInt64(0) AS depth\n+    FROM test_table\n+    UNION ALL\n+    SELECT t.id, t.parent_id, arrayConcat(path, [t.id]) as path, depth + 1\n+    FROM test_table t, search_tree st\n+    WHERE t.parent_id = st.id)\n+SELECT * FROM search_tree ORDER BY depth, id, parent_id;\n+\n+SELECT '--';\n+\n+WITH RECURSIVE search_tree AS (\n+    SELECT id, parent_id, [parent_id] AS path, toUInt64(0) AS depth\n+    FROM remote('127.0.0.1', currentDatabase(), test_table)\n+    UNION ALL\n+    SELECT t.id, t.parent_id, arrayConcat(path, [t.id]) as path, depth + 1\n+    FROM remote('127.0.0.1', currentDatabase(), test_table) t, search_tree st\n+    WHERE t.parent_id = st.id)\n+SELECT * FROM search_tree ORDER BY depth, id, parent_id;\n+\n+SELECT '--';\n+\n+WITH RECURSIVE search_tree AS (\n+    SELECT id, parent_id, [parent_id] AS path, toUInt64(0) AS depth\n+    FROM remote('127.0.0.{1,2}', currentDatabase(), test_table)\n+    UNION ALL\n+    SELECT t.id, t.parent_id, arrayConcat(path, [t.id]) as path, depth + 1\n+    FROM remote('127.0.0.{1,2}', currentDatabase(), test_table) t, search_tree st\n+    WHERE t.parent_id = st.id)\n+SELECT * FROM search_tree ORDER BY depth, id, parent_id;;\n+\n+DROP TABLE test_table;\n",
  "problem_statement": "unknown table expression identifier for recursive CTE when base table is a remote table\nhttps://fiddle.clickhouse.com/e6d65908-e28f-4b99-b090-2917999ea1a8\r\n\r\n```\r\nReceived exception from server (version 24.4.1):\r\nCode: 60. DB::Exception: Received from localhost:9000. DB::Exception: Unknown table expression identifier 'search_tree' in scope SELECT __table1.id AS id, __table1.parent_id AS parent_id, arrayConcat(__table2.path, [__table1.id]) AS path, __table2.depth + 1 AS `plus(depth, 1)` FROM default.bug_repro_local AS __table1 ALL INNER JOIN search_tree AS __table2 ON __table1.parent_id = __table2.id: While executing RecursiveCTESource. (UNKNOWN_TABLE)\r\n```\r\n\r\n\r\n```sql\r\nCREATE TABLE bug_repro_local\r\n(\r\n    `id` String,\r\n    `parent_id` String\r\n)\r\nENGINE = Memory;\r\n\r\ninsert into bug_repro_local values ('a', '');\r\ninsert into bug_repro_local values ('b', 'a');\r\ninsert into bug_repro_local values ('c', 'a');\r\n\r\n-- local table, works\r\nWITH RECURSIVE search_tree AS (\r\n    SELECT id, parent_id, [parent_id] AS path, toUInt64(0) AS depth\r\n    FROM bug_repro_local\r\n    UNION ALL\r\n    SELECT t.id, t.parent_id, arrayConcat(path, [t.id]) as path, depth + 1\r\n    FROM bug_repro_local t, search_tree st\r\n    WHERE t.parent_id = st.id)\r\nSELECT * FROM search_tree;\r\n\r\n\r\n-- remote, fails\r\nWITH RECURSIVE search_tree AS (\r\n    SELECT id, parent_id, [parent_id] AS path, toUInt64(0) AS depth\r\n    FROM remote('127.0.0.{1,2}', default, bug_repro_local)\r\n    UNION ALL\r\n    SELECT t.id, t.parent_id, arrayConcat(path, [t.id]) as path, depth + 1\r\n    FROM remote('127.0.0.{1,2}', default, bug_repro_local) t, search_tree st\r\n    WHERE t.parent_id = st.id)\r\nSELECT * FROM search_tree;\r\n```\n",
  "hints_text": "",
  "created_at": "2024-05-16T09:08:43Z",
  "modified_files": [
    "src/Interpreters/Context.cpp",
    "src/Interpreters/Context.h",
    "src/Processors/Sources/RecursiveCTESource.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03154_recursive_cte_distributed.reference",
    "b/tests/queries/0_stateless/03154_recursive_cte_distributed.sql"
  ]
}