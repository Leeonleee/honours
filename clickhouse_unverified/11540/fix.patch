diff --git a/src/IO/ReadBufferAIO.cpp b/src/IO/ReadBufferAIO.cpp
index ffe8183f0057..8b01b67c0c05 100644
--- a/src/IO/ReadBufferAIO.cpp
+++ b/src/IO/ReadBufferAIO.cpp
@@ -4,6 +4,7 @@
 #include <IO/AIOContextPool.h>
 #include <Common/ProfileEvents.h>
 #include <Common/Stopwatch.h>
+#include <Common/MemorySanitizer.h>
 #include <Core/Defines.h>
 
 #include <sys/types.h>
@@ -95,11 +96,8 @@ bool ReadBufferAIO::nextImpl()
     if (profile_callback)
         watch.emplace(clock_type);
 
-    if (!is_aio)
-    {
+    if (!is_pending_read)
         synchronousRead();
-        is_aio = true;
-    }
     else
         receive();
 
@@ -215,7 +213,9 @@ void ReadBufferAIO::synchronousRead()
 void ReadBufferAIO::receive()
 {
     if (!waitForAIOCompletion())
-        return;
+    {
+        throw Exception("Trying to receive data from AIO, but nothing was queued. It's a bug", ErrorCodes::LOGICAL_ERROR);
+    }
     finalize();
 }
 
@@ -224,8 +224,6 @@ void ReadBufferAIO::skip()
     if (!waitForAIOCompletion())
         return;
 
-    is_aio = false;
-
     /// @todo I presume this assignment is redundant since waitForAIOCompletion() performs a similar one
 //    bytes_read = future_bytes_read.get();
     if ((bytes_read < 0) || (static_cast<size_t>(bytes_read) < region_left_padding))
@@ -274,6 +272,9 @@ void ReadBufferAIO::prepare()
     region_aligned_size = region_aligned_end - region_aligned_begin;
 
     buffer_begin = fill_buffer.internalBuffer().begin();
+
+    /// Unpoison because msan doesn't instrument linux AIO
+    __msan_unpoison(buffer_begin, fill_buffer.internalBuffer().size());
 }
 
 void ReadBufferAIO::finalize()
diff --git a/src/IO/ReadBufferAIO.h b/src/IO/ReadBufferAIO.h
index 77274c47073d..5b2cf247a452 100644
--- a/src/IO/ReadBufferAIO.h
+++ b/src/IO/ReadBufferAIO.h
@@ -100,8 +100,6 @@ class ReadBufferAIO final : public ReadBufferFromFileBase
     bool is_eof = false;
     /// At least one read request was sent.
     bool is_started = false;
-    /// Is the operation asynchronous?
-    bool is_aio = false;
     /// Did the asynchronous operation fail?
     bool aio_failed = false;
 
