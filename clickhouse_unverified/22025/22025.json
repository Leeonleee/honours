{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 22025,
  "instance_id": "ClickHouse__ClickHouse-22025",
  "issue_numbers": [
    "21835"
  ],
  "base_commit": "36898bdc4a2df3ec38e0e6befa8589564a3cef9a",
  "patch": "diff --git a/docs/en/sql-reference/aggregate-functions/parametric-functions.md b/docs/en/sql-reference/aggregate-functions/parametric-functions.md\nindex 5e7f1e4a98dc..af643e9f7e49 100644\n--- a/docs/en/sql-reference/aggregate-functions/parametric-functions.md\n+++ b/docs/en/sql-reference/aggregate-functions/parametric-functions.md\n@@ -243,7 +243,7 @@ The function works according to the algorithm:\n **Syntax**\n \n ``` sql\n-windowFunnel(window, [mode])(timestamp, cond1, cond2, ..., condN)\n+windowFunnel(window, [mode, [mode, ... ]])(timestamp, cond1, cond2, ..., condN)\n ```\n \n **Arguments**\n@@ -254,8 +254,10 @@ windowFunnel(window, [mode])(timestamp, cond1, cond2, ..., condN)\n **Parameters**\n \n -   `window` \u2014 Length of the sliding window. The unit of `window` depends on the `timestamp` itself and varies. Determined using the expression `timestamp of cond2 <= timestamp of cond1 + window`.\n--   `mode` \u2014 It is an optional argument.\n-    -   `'strict'` \u2014 When the `'strict'` is set, the windowFunnel() applies conditions only for the unique values.\n+-   `mode` \u2014 It is an optional argument. One or more modes can be set.\n+    -   `'strict'` \u2014 If same condition holds for sequence of events then such non-unique events would be skipped. \n+    -   `'strict_order'` \u2014 Don't allow interventions of other events. E.g. in the case of `A->B->D->C`, it stops finding `A->B->C` at the `D` and the max event level is 2.\n+    -   `'strict_increase'` \u2014 Apply conditions only to events with strictly increasing timestamps.\n \n **Returned value**\n \ndiff --git a/docs/ru/sql-reference/aggregate-functions/parametric-functions.md b/docs/ru/sql-reference/aggregate-functions/parametric-functions.md\nindex c2859b76c32e..e5162b63b88e 100644\n--- a/docs/ru/sql-reference/aggregate-functions/parametric-functions.md\n+++ b/docs/ru/sql-reference/aggregate-functions/parametric-functions.md\n@@ -243,7 +243,7 @@ SELECT sequenceCount('(?1).*(?2)')(time, number = 1, number = 2) FROM t\n **\u0421\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441**\n \n ``` sql\n-windowFunnel(window, [mode])(timestamp, cond1, cond2, ..., condN)\n+windowFunnel(window, [mode, [mode, ... ]])(timestamp, cond1, cond2, ..., condN)\n ```\n \n **\u0410\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b**\n@@ -254,7 +254,10 @@ windowFunnel(window, [mode])(timestamp, cond1, cond2, ..., condN)\n **\u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b**\n \n -   `window` \u2014 \u0448\u0438\u0440\u0438\u043d\u0430 \u0441\u043a\u043e\u043b\u044c\u0437\u044f\u0449\u0435\u0433\u043e \u043e\u043a\u043d\u0430 \u043f\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438. \u0415\u0434\u0438\u043d\u0438\u0446\u0430 \u0438\u0437\u043c\u0435\u0440\u0435\u043d\u0438\u044f \u0437\u0430\u0432\u0438\u0441\u0438\u0442 \u043e\u0442 `timestamp` \u0438 \u043c\u043e\u0436\u0435\u0442 \u0432\u0430\u0440\u044c\u0438\u0440\u043e\u0432\u0430\u0442\u044c\u0441\u044f. \u0414\u043e\u043b\u0436\u043d\u043e \u0441\u043e\u0431\u043b\u044e\u0434\u0430\u0442\u044c\u0441\u044f \u0443\u0441\u043b\u043e\u0432\u0438\u0435 `timestamp \u0441\u043e\u0431\u044b\u0442\u0438\u044f cond2 <= timestamp \u0441\u043e\u0431\u044b\u0442\u0438\u044f cond1 + window`.\n--   `mode` \u2014 \u043d\u0435\u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440. \u0415\u0441\u043b\u0438 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 `'strict'`, \u0442\u043e \u0444\u0443\u043d\u043a\u0446\u0438\u044f `windowFunnel()` \u043f\u0440\u0438\u043c\u0435\u043d\u044f\u0435\u0442 \u0443\u0441\u043b\u043e\u0432\u0438\u044f \u0442\u043e\u043b\u044c\u043a\u043e \u0434\u043b\u044f \u0443\u043d\u0438\u043a\u0430\u043b\u044c\u043d\u044b\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439.\n+-   `mode` \u2014 \u043d\u0435\u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440. \u041c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043d\u043e \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u043e\u0434\u043d\u043e\u0432\u0440\u0435\u043c\u0435\u043d\u043d\u043e.\n+    -   `'strict'` \u2014 \u043d\u0435 \u0443\u0447\u0438\u0442\u044b\u0432\u0430\u0442\u044c \u043f\u043e\u0434\u0440\u044f\u0434 \u0438\u0434\u0443\u0449\u0438\u0435 \u043f\u043e\u0432\u0442\u043e\u0440\u044f\u044e\u0449\u0438\u0435\u0441\u044f \u0441\u043e\u0431\u044b\u0442\u0438\u044f.\n+    -   `'strict_order'` \u2014 \u0437\u0430\u043f\u0440\u0435\u0449\u0430\u0435\u0442 \u043f\u043e\u0441\u0442\u043e\u0440\u043e\u043d\u043d\u0438\u0435 \u0441\u043e\u0431\u044b\u0442\u0438\u044f \u0432 \u0438\u0441\u043a\u043e\u043c\u043e\u0439 \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438. \u041d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, \u043f\u0440\u0438 \u043f\u043e\u0438\u0441\u043a\u0435 \u0446\u0435\u043f\u043e\u0447\u043a\u0438 `A->B->C` \u0432 `A->B->D->C` \u043f\u043e\u0438\u0441\u043a \u0431\u0443\u0434\u0435\u0442 \u043e\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d \u043d\u0430 `D` \u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0432\u0435\u0440\u043d\u0435\u0442 2.\n+    -   `'strict_increase'` \u2014 \u0443\u0441\u043b\u043e\u0432\u0438\u044f \u043f\u0440\u043c\u0435\u043d\u044f\u044e\u0442\u0441\u044f \u0442\u043e\u043b\u044c\u043a\u043e \u0434\u043b\u044f \u0441\u043e\u0431\u044b\u0442\u0438\u0439 \u0441\u043e \u0441\u0442\u0440\u043e\u0433\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u044e\u0449\u0438\u043c\u0438 \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u043c\u0438 \u043c\u0435\u0442\u043a\u0430\u043c\u0438.\n \n **\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435**\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionWindowFunnel.cpp b/src/AggregateFunctions/AggregateFunctionWindowFunnel.cpp\nindex 1e9f2782d95c..ed732a197a1c 100644\n--- a/src/AggregateFunctions/AggregateFunctionWindowFunnel.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionWindowFunnel.cpp\n@@ -6,7 +6,6 @@\n #include <DataTypes/DataTypeDateTime.h>\n \n #include <ext/range.h>\n-#include \"registerAggregateFunctions.h\"\n \n \n namespace DB\ndiff --git a/src/AggregateFunctions/AggregateFunctionWindowFunnel.h b/src/AggregateFunctions/AggregateFunctionWindowFunnel.h\nindex c765024507ed..e4a275555bf4 100644\n--- a/src/AggregateFunctions/AggregateFunctionWindowFunnel.h\n+++ b/src/AggregateFunctions/AggregateFunctionWindowFunnel.h\n@@ -29,6 +29,7 @@ struct ComparePair final\n };\n \n static constexpr auto max_events = 32;\n+\n template <typename T>\n struct AggregateFunctionWindowFunnelData\n {\n@@ -46,7 +47,7 @@ struct AggregateFunctionWindowFunnelData\n \n     void add(T timestamp, UInt8 event)\n     {\n-        // Since most events should have already been sorted by timestamp.\n+        /// Since most events should have already been sorted by timestamp.\n         if (sorted && events_list.size() > 0)\n         {\n             if (events_list.back().first == timestamp)\n@@ -145,14 +146,20 @@ class AggregateFunctionWindowFunnel final\n private:\n     UInt64 window;\n     UInt8 events_size;\n-    UInt8 strict;   // When the 'strict' is set, it applies conditions only for the not repeating values.\n-    UInt8 strict_order; // When the 'strict_order' is set, it doesn't allow interventions of other events.\n-                        // In the case of 'A->B->D->C', it stops finding 'A->B->C' at the 'D' and the max event level is 2.\n-\n-    // Loop through the entire events_list, update the event timestamp value\n-    // The level path must be 1---2---3---...---check_events_size, find the max event level that satisfied the path in the sliding window.\n-    // If found, returns the max event level, else return 0.\n-    // The Algorithm complexity is O(n).\n+    /// When the 'strict' is set, it applies conditions only for the not repeating values.\n+    bool strict;\n+\n+    /// When the 'strict_order' is set, it doesn't allow interventions of other events.\n+    /// In the case of 'A->B->D->C', it stops finding 'A->B->C' at the 'D' and the max event level is 2.\n+    bool strict_order;\n+\n+    /// Applies conditions only to events with strictly increasing timestamps\n+    bool strict_increase;\n+\n+    /// Loop through the entire events_list, update the event timestamp value\n+    /// The level path must be 1---2---3---...---check_events_size, find the max event level that satisfied the path in the sliding window.\n+    /// If found, returns the max event level, else return 0.\n+    /// The Algorithm complexity is O(n).\n     UInt8 getEventLevel(Data & data) const\n     {\n         if (data.size() == 0)\n@@ -162,16 +169,13 @@ class AggregateFunctionWindowFunnel final\n \n         data.sort();\n \n-        /// events_timestamp stores the timestamp that latest i-th level event happen within time window after previous level event.\n-        /// timestamp defaults to -1, which unsigned timestamp value never meet\n-        /// there may be some bugs when UInt64 type timstamp overflows Int64, but it works on most cases.\n-        std::vector<Int64> events_timestamp(events_size, -1);\n+        /// events_timestamp stores the timestamp of the first and previous i-th level event happen within time window\n+        std::vector<std::optional<std::pair<UInt64, UInt64>>> events_timestamp(events_size);\n         bool first_event = false;\n         for (const auto & pair : data.events_list)\n         {\n             const T & timestamp = pair.first;\n             const auto & event_idx = pair.second - 1;\n-\n             if (strict_order && event_idx == -1)\n             {\n                 if (first_event)\n@@ -181,31 +185,39 @@ class AggregateFunctionWindowFunnel final\n             }\n             else if (event_idx == 0)\n             {\n-                events_timestamp[0] = timestamp;\n+                events_timestamp[0] = std::make_pair(timestamp, timestamp);\n                 first_event = true;\n             }\n-            else if (strict && events_timestamp[event_idx] >= 0)\n+            else if (strict && events_timestamp[event_idx].has_value())\n             {\n                 return event_idx + 1;\n             }\n-            else if (strict_order && first_event && events_timestamp[event_idx - 1] == -1)\n+            else if (strict_order && first_event && !events_timestamp[event_idx - 1].has_value())\n             {\n                 for (size_t event = 0; event < events_timestamp.size(); ++event)\n                 {\n-                    if (events_timestamp[event] == -1)\n+                    if (!events_timestamp[event].has_value())\n                         return event;\n                 }\n             }\n-            else if (events_timestamp[event_idx - 1] >= 0 && timestamp <= events_timestamp[event_idx - 1] + window)\n+            else if (events_timestamp[event_idx - 1].has_value())\n             {\n-                events_timestamp[event_idx] = events_timestamp[event_idx - 1];\n-                if (event_idx + 1 == events_size)\n-                    return events_size;\n+                auto first_timestamp = events_timestamp[event_idx - 1]->first;\n+                bool time_matched = timestamp <= first_timestamp + window;\n+                if (strict_increase)\n+                    time_matched = time_matched && events_timestamp[event_idx - 1]->second < timestamp;\n+                if (time_matched)\n+                {\n+                    events_timestamp[event_idx] = std::make_pair(first_timestamp, timestamp);\n+                    if (event_idx + 1 == events_size)\n+                        return events_size;\n+                }\n             }\n         }\n+\n         for (size_t event = events_timestamp.size(); event > 0; --event)\n         {\n-            if (events_timestamp[event - 1] >= 0)\n+            if (events_timestamp[event - 1].has_value())\n                 return event;\n         }\n         return 0;\n@@ -223,15 +235,18 @@ class AggregateFunctionWindowFunnel final\n         events_size = arguments.size() - 1;\n         window = params.at(0).safeGet<UInt64>();\n \n-        strict = 0;\n-        strict_order = 0;\n+        strict = false;\n+        strict_order = false;\n+        strict_increase = false;\n         for (size_t i = 1; i < params.size(); ++i)\n         {\n             String option = params.at(i).safeGet<String>();\n-            if (option.compare(\"strict\") == 0)\n-                strict = 1;\n-            else if (option.compare(\"strict_order\") == 0)\n-                strict_order = 1;\n+            if (option == \"strict\")\n+                strict = true;\n+            else if (option == \"strict_order\")\n+                strict_order = true;\n+            else if (option == \"strict_increase\")\n+                strict_increase = true;\n             else\n                 throw Exception{\"Aggregate function \" + getName() + \" doesn't support a parameter: \" + option, ErrorCodes::BAD_ARGUMENTS};\n         }\n@@ -253,7 +268,7 @@ class AggregateFunctionWindowFunnel final\n     {\n         bool has_event = false;\n         const auto timestamp = assert_cast<const ColumnVector<T> *>(columns[0])->getData()[row_num];\n-        // reverse iteration and stable sorting are needed for events that are qualified by more than one condition.\n+        /// reverse iteration and stable sorting are needed for events that are qualified by more than one condition.\n         for (auto i = events_size; i > 0; --i)\n         {\n             auto event = assert_cast<const ColumnVector<UInt8> *>(columns[i])->getData()[row_num];\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00632_aggregation_window_funnel.reference b/tests/queries/0_stateless/00632_aggregation_window_funnel.reference\nindex 492135567ea2..2c68f277bfa0 100644\n--- a/tests/queries/0_stateless/00632_aggregation_window_funnel.reference\n+++ b/tests/queries/0_stateless/00632_aggregation_window_funnel.reference\n@@ -57,3 +57,7 @@\n [2, 0]\n [3, 1]\n [4, 1]\n+1\n+1\n+1\n+1\ndiff --git a/tests/queries/0_stateless/00632_aggregation_window_funnel.sql b/tests/queries/0_stateless/00632_aggregation_window_funnel.sql\nindex 5a1610256ac1..d9991be55839 100644\n--- a/tests/queries/0_stateless/00632_aggregation_window_funnel.sql\n+++ b/tests/queries/0_stateless/00632_aggregation_window_funnel.sql\n@@ -79,3 +79,11 @@ select u, windowFunnel(86400)(dt, a is null and b is null) as s from funnel_test\n select u, windowFunnel(86400)(dt, a is null, b = 'b3') as s from funnel_test_non_null group by u order by u format JSONCompactEachRow;\n select u, windowFunnel(86400, 'strict_order')(dt, a is null, b = 'b3') as s from funnel_test_non_null group by u order by u format JSONCompactEachRow;\n drop table funnel_test_non_null;\n+\n+create table funnel_test_strict_increase (timestamp UInt32, event UInt32) engine=Memory;\n+insert into funnel_test_strict_increase values (0,1000),(1,1001),(1,1002),(1,1003),(2,1004);\n+\n+select 5 = windowFunnel(10000)(timestamp, event = 1000, event = 1001, event = 1002, event = 1003, event = 1004) from funnel_test_strict_increase;\n+select 2 = windowFunnel(10000, 'strict_increase')(timestamp, event = 1000, event = 1001, event = 1002, event = 1003, event = 1004) from funnel_test_strict_increase;\n+select 3 = windowFunnel(10000)(timestamp, event = 1004, event = 1004, event = 1004) from funnel_test_strict_increase;\n+select 1 = windowFunnel(10000, 'strict_increase')(timestamp, event = 1004, event = 1004, event = 1004) from funnel_test_strict_increase;\n",
  "problem_statement": "windowFunnel: same event gets counted twice\n(you don't have to strictly follow this form)\r\n\r\n**Describe the unexpected behaviour**\r\nTest 1: running `windowFunnel` on different events without duplicate timestamp, it works well:\r\n```sql\r\nSELECT\r\n    uid,\r\n    windowFunnel(50)(toUInt32(event_ms), event_id = 1, event_id = 2) AS level\r\nFROM\r\n    (\r\n    /* emulate test dataset */\r\n    SELECT data.1 event_id, data.2  event_ms, data.3 uid\r\n    FROM (\r\n        SELECT arrayJoin(\r\n        [(1, 100, 123),\r\n        (1, 200, 345),\r\n        (1, 210, 345),\r\n        (2, 99, 123),\r\n        (2, 250, 234),\r\n        (2, 230, 345),\r\n        (2, 240, 345)]) data)\r\n    )\r\nWHERE\r\n    event_ms >= 0\r\n    AND event_ms <= 300\r\nGROUP BY\r\n    uid;\r\n\r\nResults:\r\n\u250c\u2500uid\u2500\u252c\u2500level\u2500\u2510\r\n\u2502 123 \u2502     1 \u2502\r\n\u2502 234 \u2502     0 \u2502\r\n\u2502 345 \u2502     2 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nTest 2: running `windowFunnel` on different events with duplicate timestamp, it count unexpected event into result.\r\nIn this case, user 123 has event 1 and event 2 both happened at 100(event_ms), theoretically, it should not count this match because timestamp of event 2 is not greater than event 1.\r\n```sql\r\nSELECT\r\n    uid,\r\n    windowFunnel(50)(toUInt32(event_ms), event_id = 1, event_id = 2) AS level\r\nFROM\r\n    (\r\n    /* emulate test dataset */\r\n    SELECT data.1 event_id, data.2  event_ms, data.3 uid\r\n    FROM (\r\n        SELECT arrayJoin(\r\n        [(1, 100, 123),\r\n        (1, 200, 345),\r\n        (1, 210, 345),\r\n        (2, 100, 123),\r\n        (2, 250, 234),\r\n        (2, 230, 345),\r\n        (2, 240, 345)]) data)\r\n    )\r\nWHERE\r\n    event_ms >= 0\r\n    AND event_ms <= 300\r\nGROUP BY\r\n    uid;\r\n\r\nResults:\r\n\u250c\u2500uid\u2500\u252c\u2500level\u2500\u2510\r\n\u2502 123 \u2502     2 \u2502\r\n\u2502 234 \u2502     0 \u2502\r\n\u2502 345 \u2502     2 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nTest 3: running `windowFunnel` on two same event count all events twice:\r\n```sql\r\nSELECT\r\n    uid,\r\n    windowFunnel(50)(toUInt32(event_ms), event_id = 1, event_id = 1) AS level\r\nFROM\r\n    (\r\n    /* emulate test dataset */\r\n    SELECT data.1 event_id, data.2  event_ms, data.3 uid\r\n    FROM (\r\n        SELECT arrayJoin(\r\n        [(1, 100, 123),\r\n        (1, 200, 345)]) data)\r\n    )\r\nWHERE\r\n    event_ms >= 0\r\n    AND event_ms <= 300\r\nGROUP BY\r\n    uid;\r\n\r\nResults:\r\n\u250c\u2500uid\u2500\u252c\u2500level\u2500\u2510\r\n\u2502 123 \u2502     2 \u2502\r\n\u2502 345 \u2502     2 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n**How to reproduce**: run SQL query pasted above\r\n* Which ClickHouse server version to use: 21.2.3.15\r\n* Which interface to use, if matters\r\n* Non-default settings, if any\r\n* `CREATE TABLE` statements for all tables involved\r\n* Sample data for all these tables, use [clickhouse-obfuscator](https://github.com/ClickHouse/ClickHouse/blob/master/programs/obfuscator/Obfuscator.cpp#L42-L80) if necessary\r\n* Queries to run that lead to unexpected result\r\n\r\n**Expected behavior**\r\nWhen searching for qualified event chain, it should satisfy: \r\n**timestamp of first event < timestamp of second event <= timestamp of first event + window**\r\n\r\nI guess currently it follows:\r\ntimestamp of first event <= timestamp of second event <= timestamp of first event + window\r\n\r\nWith that, Test 2 will generate results:\r\n```\r\n\u250c\u2500uid\u2500\u252c\u2500level\u2500\u2510\r\n\u2502 123 \u2502     1 \u2502\r\n\u2502 234 \u2502     0 \u2502\r\n\u2502 345 \u2502     2 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nTest 3 will generate results:\r\n```\r\n\u250c\u2500uid\u2500\u252c\u2500level\u2500\u2510\r\n\u2502 123 \u2502     1 \u2502\r\n\u2502 345 \u2502     1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n```\r\n\r\n\r\n**Error message and/or stacktrace**\r\nIf applicable, add screenshots to help explain your problem.\r\n\r\n**Additional context**\r\nAdd any other context about the problem here.\r\n\n",
  "hints_text": "Maybe introduced in #18884.\n> Maybe introduced in #18884.\r\n\r\nHi @ucasFL , thanks for finding the related PR! But I guess this issue existed before this PR because duplicate events cannot be avoided by changing sorting method. \r\n\r\nI wonder if we should change logic [here](https://github.com/ClickHouse/ClickHouse/blob/master/src/AggregateFunctions/AggregateFunctionWindowFunnel.h#L199)\r\nfrom \r\n```\r\nelse if (events_timestamp[event_idx - 1] >= 0 && timestamp <= events_timestamp[event_idx - 1] + window)\r\n```\r\nto\r\n```\r\nelse if (events_timestamp[event_idx - 1] >= 0 && timestamp > events_timestamp[event_idx - 1] && timestamp <= events_timestamp[event_idx - 1] + window)\r\n```\r\nso that only when timestamp of current event strictly greater than previous event, can we update the events_timestamp.\nProposal: we could add a new mode called `strictly increasing` to avoid duplicate timestamps, so that we change the matching pattern from\r\n```\r\ntimestamp of cond1 <= timestamp of cond2 <= ... <= timestamp of condN <= timestamp of cond1 + window.\r\n```\r\nto\r\n```\r\ntimestamp of cond1 < timestamp of cond2 < ... < timestamp of condN <= timestamp of cond1 + window.\r\n```\r\n@sundy-li @filimonov does that sound like a valid way to you?\nI think the test 2 case is reasonable. It's using stable sort, we can accept some timestamp by default (not in strict mode), so    (1, 100, 123) ->  (2, 100, 123) results to level 2.\r\n       \r\nI test these 3 cases in 20.3, and it works well, I did not catch the latest options like `strict` and `strict_order`.  Maybe some changes broker this function.\r\n\r\n`windowFunnel(50)(toUInt32(event_ms), event_id = 1, event_id = 1) `  I think repeated conditions in windowFunnel should be forbidden. Because I did not consider this case when introducing windowFunnel\n> I think the test 2 case is reasonable. It's using stable sort, we can accept some timestamp by default (not in strict mode), so (1, 100, 123) -> (2, 100, 123) results to level 2.\r\n> \r\n> I test these 3 cases in 20.3, and it works well, I did not catch the latest options like `strict` and `strict_order`. Maybe some changes broker this function.\r\n\r\nHi @sundy-li , thanks for looking into this issue! My ClickHouse version is 21.2.3.15, so it's possible that new changes introduced this unexpected behavior. \r\nDo you think it's reasonable to introduce a new mode to make the timestamp `strictly increasing` to avoid counting duplicate timestamps into result?\n> Do you think it's reasonable to introduce a new mode to make the timestamp `strictly increasing` to avoid counting duplicate timestamps into result?\r\n\r\nI think adding such option may be possible, but it seems that function will do some additional work (filtering), for which it is not responsible. Why filtering rows with non-unique timestamp before applying this function is not possible? For example with `GROUP BY`",
  "created_at": "2021-03-23T11:26:04Z"
}