{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 6444,
  "instance_id": "ClickHouse__ClickHouse-6444",
  "issue_numbers": [
    "6398"
  ],
  "base_commit": "f992df8cc2b861ff85519f8eaa8835a4aa5b2c76",
  "patch": "diff --git a/dbms/src/Compression/CompressionCodecGorilla.cpp b/dbms/src/Compression/CompressionCodecGorilla.cpp\nindex 79cc6d27e81e..8af6c8bfd39c 100644\n--- a/dbms/src/Compression/CompressionCodecGorilla.cpp\n+++ b/dbms/src/Compression/CompressionCodecGorilla.cpp\n@@ -78,11 +78,12 @@ binary_value_info getLeadingAndTrailingBits(const T & value)\n     const UInt8 lz = getLeadingZeroBits(value);\n     const UInt8 tz = getTrailingZeroBits(value);\n     const UInt8 data_size = value == 0 ? 0 : static_cast<UInt8>(bit_size - lz - tz);\n+\n     return binary_value_info{lz, data_size, tz};\n }\n \n template <typename T>\n-UInt32 compressDataForType(const char * source, UInt32 source_size, char * dest)\n+UInt32 compressDataForType(const char * source, UInt32 source_size, char * dest, UInt32 dest_size)\n {\n     static const auto DATA_BIT_LENGTH = getBitLengthOfLength(sizeof(T));\n     // -1 since there must be at least 1 non-zero bit.\n@@ -91,6 +92,7 @@ UInt32 compressDataForType(const char * source, UInt32 source_size, char * dest)\n     if (source_size % sizeof(T) != 0)\n         throw Exception(\"Cannot compress, data size \" + toString(source_size) + \" is not aligned to \" + toString(sizeof(T)), ErrorCodes::CANNOT_COMPRESS);\n     const char * source_end = source + source_size;\n+    const char * dest_end = dest + dest_size;\n \n     const UInt32 items_count = source_size / sizeof(T);\n \n@@ -110,7 +112,7 @@ UInt32 compressDataForType(const char * source, UInt32 source_size, char * dest)\n         dest += sizeof(prev_value);\n     }\n \n-    WriteBuffer buffer(dest, getCompressedDataSize(sizeof(T), source_size - sizeof(items_count) - sizeof(prev_value)));\n+    WriteBuffer buffer(dest, dest_end - dest);\n     BitWriter writer(buffer);\n \n     while (source < source_end)\n@@ -265,24 +267,26 @@ UInt32 CompressionCodecGorilla::doCompressData(const char * source, UInt32 sourc\n     dest[1] = bytes_to_skip;\n     memcpy(&dest[2], source, bytes_to_skip);\n     size_t start_pos = 2 + bytes_to_skip;\n-    UInt32 compressed_size = 0;\n+    UInt32 result_size = 0;\n+\n+    const UInt32 compressed_size = getMaxCompressedDataSize(source_size);\n     switch (data_bytes_size)\n     {\n     case 1:\n-        compressed_size = compressDataForType<UInt8>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);\n+        result_size = compressDataForType<UInt8>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos], compressed_size);\n         break;\n     case 2:\n-        compressed_size = compressDataForType<UInt16>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);\n+        result_size = compressDataForType<UInt16>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos], compressed_size);\n         break;\n     case 4:\n-        compressed_size = compressDataForType<UInt32>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);\n+        result_size = compressDataForType<UInt32>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos], compressed_size);\n         break;\n     case 8:\n-        compressed_size = compressDataForType<UInt64>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos]);\n+        result_size = compressDataForType<UInt64>(&source[bytes_to_skip], source_size - bytes_to_skip, &dest[start_pos], compressed_size);\n         break;\n     }\n \n-    return 1 + 1 + compressed_size;\n+    return 1 + 1 + result_size;\n }\n \n void CompressionCodecGorilla::doDecompressData(const char * source, UInt32 source_size, char * dest, UInt32 /* uncompressed_size */) const\ndiff --git a/dbms/src/Compression/ICompressionCodec.cpp b/dbms/src/Compression/ICompressionCodec.cpp\nindex a50001238daa..aafca2f5eb3c 100644\n--- a/dbms/src/Compression/ICompressionCodec.cpp\n+++ b/dbms/src/Compression/ICompressionCodec.cpp\n@@ -49,8 +49,8 @@ UInt32 ICompressionCodec::decompress(const char * source, UInt32 source_size, ch\n     UInt8 header_size = getHeaderSize();\n     UInt32 decompressed_size = unalignedLoad<UInt32>(&source[5]);\n     doDecompressData(&source[header_size], source_size - header_size, dest, decompressed_size);\n-    return decompressed_size;\n \n+    return decompressed_size;\n }\n \n UInt32 ICompressionCodec::readCompressedBlockSize(const char * source)\n",
  "test_patch": "diff --git a/dbms/src/Compression/tests/gtest_compressionCodec.cpp b/dbms/src/Compression/tests/gtest_compressionCodec.cpp\nindex 0f03070fff3d..bbfe20d88135 100644\n--- a/dbms/src/Compression/tests/gtest_compressionCodec.cpp\n+++ b/dbms/src/Compression/tests/gtest_compressionCodec.cpp\n@@ -1,10 +1,14 @@\n-#include <Compression/CompressionCodecDoubleDelta.h>\n-#include <Compression/CompressionCodecGorilla.h>\n+#include <Compression/CompressionFactory.h>\n \n+#include <Common/PODArray.h>\n #include <Core/Types.h>\n-#include <IO/WriteHelpers.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/IDataType.h>\n #include <IO/ReadBufferFromMemory.h>\n-#include <Common/PODArray.h>\n+#include <IO/WriteHelpers.h>\n+#include <Parsers/ExpressionElementParsers.h>\n+#include <Parsers/IParser.h>\n+#include <Parsers/TokenIterator.h>\n \n #include <boost/format.hpp>\n \n@@ -24,56 +28,86 @@\n \n using namespace DB;\n \n+namespace std\n+{\n template <typename T>\n-std::string bin(const T & value, size_t bits = sizeof(T)*8)\n+std::ostream & operator<<(std::ostream & ostr, const std::optional<T> & opt)\n {\n-    static const UInt8 MAX_BITS = sizeof(T)*8;\n-    assert(bits <= MAX_BITS);\n+    if (!opt)\n+    {\n+        return ostr << \"<empty optional>\";\n+    }\n \n-    return std::bitset<sizeof(T) * 8>(static_cast<unsigned long long>(value))\n-            .to_string().substr(MAX_BITS - bits, bits);\n+    return ostr << *opt;\n }\n \n template <typename T>\n-const char* type_name()\n+std::vector<T> operator+(std::vector<T> && left, std::vector<T> && right)\n {\n-    return typeid(T).name();\n-}\n+    std::vector<T> result(std::move(left));\n+    std::move(std::begin(right), std::end(right), std::back_inserter(result));\n \n-template <>\n-const char* type_name<UInt32>()\n-{\n-    return \"uint32\";\n+    return result;\n }\n \n-template <>\n-const char* type_name<Int32>()\n-{\n-    return \"int32\";\n }\n \n-template <>\n-const char* type_name<UInt64>()\n+namespace\n {\n-    return \"uint64\";\n-}\n \n-template <>\n-const char* type_name<Int64>()\n+template <typename T>\n+std::string bin(const T & value, size_t bits = sizeof(T)*8)\n {\n-    return \"int64\";\n+    static const UInt8 MAX_BITS = sizeof(T)*8;\n+    assert(bits <= MAX_BITS);\n+\n+    return std::bitset<sizeof(T) * 8>(static_cast<unsigned long long>(value))\n+            .to_string().substr(MAX_BITS - bits, bits);\n }\n \n-template <>\n-const char* type_name<Float32>()\n+template <typename T>\n+const char* type_name()\n {\n-    return \"float\";\n+#define MAKE_TYPE_NAME(TYPE) \\\n+    if constexpr (std::is_same_v<TYPE, T>) return #TYPE\n+\n+    MAKE_TYPE_NAME(UInt8);\n+    MAKE_TYPE_NAME(UInt16);\n+    MAKE_TYPE_NAME(UInt32);\n+    MAKE_TYPE_NAME(UInt64);\n+    MAKE_TYPE_NAME(Int8);\n+    MAKE_TYPE_NAME(Int16);\n+    MAKE_TYPE_NAME(Int32);\n+    MAKE_TYPE_NAME(Int64);\n+    MAKE_TYPE_NAME(Float32);\n+    MAKE_TYPE_NAME(Float64);\n+\n+#undef MAKE_TYPE_NAME\n+\n+    return typeid(T).name();\n }\n \n-template <>\n-const char* type_name<Float64>()\n+template <typename T>\n+DataTypePtr makeDataType()\n {\n-    return \"double\";\n+#define MAKE_DATA_TYPE(TYPE) \\\n+    if constexpr (std::is_same_v<T, TYPE>) return std::make_shared<DataType ## TYPE>()\n+\n+    MAKE_DATA_TYPE(UInt8);\n+    MAKE_DATA_TYPE(UInt16);\n+    MAKE_DATA_TYPE(UInt32);\n+    MAKE_DATA_TYPE(UInt64);\n+    MAKE_DATA_TYPE(Int8);\n+    MAKE_DATA_TYPE(Int16);\n+    MAKE_DATA_TYPE(Int32);\n+    MAKE_DATA_TYPE(Int64);\n+    MAKE_DATA_TYPE(Float32);\n+    MAKE_DATA_TYPE(Float64);\n+\n+#undef MAKE_DATA_TYPE\n+\n+    assert(false && \"unsupported size\");\n+    return nullptr;\n }\n \n \n@@ -135,52 +169,105 @@ ::testing::AssertionResult EqualByteContainersAs(const ContainerLeft & left, con\n     return result;\n }\n \n-struct CodecTestParam\n+struct Codec\n {\n-    std::string type_name;\n-    std::vector<char> source_data;\n-    UInt8 data_byte_size;\n-    double min_compression_ratio;\n-    std::string case_name;\n-\n-    // to allow setting ratio after building with complex builder functions.\n-    CodecTestParam && setRatio(const double & ratio) &&\n-    {\n-        this->min_compression_ratio = ratio;\n-        return std::move(*this);\n-    }\n+    std::string codec_statement;\n+    std::optional<double> expected_compression_ratio;\n+\n+    explicit Codec(std::string codec_statement_, std::optional<double> expected_compression_ratio_ = std::nullopt)\n+        : codec_statement(std::move(codec_statement_)),\n+          expected_compression_ratio(expected_compression_ratio_)\n+    {}\n+\n+    Codec()\n+        : Codec(std::string())\n+    {}\n+\n+    Codec(const Codec &) = default;\n+    Codec & operator=(const Codec &) = default;\n+    Codec(Codec &&) = default;\n+    Codec & operator=(Codec &&) = default;\n };\n \n-CodecTestParam operator+(CodecTestParam && left, CodecTestParam && right)\n+\n+struct CodecTestSequence\n {\n-    assert(left.type_name == right.type_name);\n-    assert(left.data_byte_size == right.data_byte_size);\n-\n-    std::vector data(std::move(left.source_data));\n-    data.insert(data.end(), right.source_data.begin(), right.source_data.end());\n-\n-    return CodecTestParam{\n-                        left.type_name,\n-                        std::move(data),\n-                        left.data_byte_size,\n-                        std::min(left.min_compression_ratio, right.min_compression_ratio),\n-                        left.case_name + \" + \" + right.case_name\n+    std::string name;\n+    std::vector<char> serialized_data;\n+    DataTypePtr data_type;\n+\n+    CodecTestSequence()\n+        : name(),\n+          serialized_data(),\n+          data_type()\n+    {}\n+\n+    CodecTestSequence(std::string name_, std::vector<char> serialized_data_, DataTypePtr data_type_)\n+        : name(name_),\n+          serialized_data(serialized_data_),\n+          data_type(data_type_)\n+    {}\n+\n+    CodecTestSequence(const CodecTestSequence &) = default;\n+    CodecTestSequence & operator=(const CodecTestSequence &) = default;\n+    CodecTestSequence(CodecTestSequence &&) = default;\n+    CodecTestSequence & operator=(CodecTestSequence &&) = default;\n+};\n+\n+CodecTestSequence operator+(CodecTestSequence && left, CodecTestSequence && right)\n+{\n+    assert(left.data_type->equals(*right.data_type));\n+\n+    std::vector<char> data(std::move(left.serialized_data));\n+    data.insert(data.end(), right.serialized_data.begin(), right.serialized_data.end());\n+\n+    return CodecTestSequence{\n+        left.name + \" + \" + right.name,\n+        std::move(data),\n+        std::move(left.data_type)\n     };\n }\n \n-std::ostream & operator<<(std::ostream & ostr, const CodecTestParam & param)\n+template <typename T>\n+CodecTestSequence operator*(CodecTestSequence && left, T times)\n {\n-    return ostr << \"name: \" << param.case_name\n-                << \"\\ntype name:\" << param.type_name\n-                << \"\\nbyte size: \" << static_cast<UInt32>(param.data_byte_size)\n-                << \"\\ndata size: \" << param.source_data.size();\n+    std::vector<char> data(std::move(left.serialized_data));\n+    const size_t initial_size = data.size();\n+    const size_t final_size = initial_size * times;\n+\n+    data.reserve(final_size);\n+\n+    for (T i = 0; i < times; ++i)\n+    {\n+        data.insert(data.end(), data.begin(), data.begin() + initial_size);\n+    }\n+\n+    return CodecTestSequence{\n+        left.name + \" x \" + std::to_string(times),\n+        std::move(data),\n+        std::move(left.data_type)\n+    };\n }\n \n-// compression ratio < 1.0 means that codec output is smaller than input.\n-const double DEFAULT_MIN_COMPRESSION_RATIO = 1.0;\n+std::ostream & operator<<(std::ostream & ostr, const Codec & codec)\n+{\n+    return ostr << \"Codec{\"\n+                << \"name: \" << codec.codec_statement\n+                << \", expected_compression_ratio: \" << codec.expected_compression_ratio\n+                << \"}\";\n+}\n+\n+std::ostream & operator<<(std::ostream & ostr, const CodecTestSequence & seq)\n+{\n+    return ostr << \"CodecTestSequence{\"\n+                << \"name: \" << seq.name\n+                << \", type name: \" << seq.data_type->getName()\n+                << \", data size: \" << seq.serialized_data.size() << \" bytes\"\n+                << \"}\";\n+}\n \n template <typename T, typename... Args>\n-CodecTestParam makeParam(Args && ... args)\n+CodecTestSequence makeSeq(Args && ... args)\n {\n     std::initializer_list<T> vals{static_cast<T>(args)...};\n     std::vector<char> data(sizeof(T) * std::size(vals));\n@@ -192,14 +279,17 @@ CodecTestParam makeParam(Args && ... args)\n         write_pos += sizeof(v);\n     }\n \n-    return CodecTestParam{type_name<T>(), std::move(data), sizeof(T), DEFAULT_MIN_COMPRESSION_RATIO,\n-                (boost::format(\"%1% values of %2%\") % std::size(vals) % type_name<T>()).str()};\n+    return CodecTestSequence{\n+            (boost::format(\"%1% values of %2%\") % std::size(vals) % type_name<T>()).str(),\n+            std::move(data),\n+            makeDataType<T>()\n+    };\n }\n \n-template <typename T, size_t Begin = 1, size_t End = 10001, typename Generator>\n-CodecTestParam generateParam(Generator gen, const char* gen_name)\n+template <typename T, typename Generator>\n+CodecTestSequence generateSeq(Generator gen, const char* gen_name, size_t Begin = 0, size_t End = 10000)\n {\n-    static_assert (End >= Begin, \"End must be not less than Begin\");\n+    assert (End >= Begin);\n \n     std::vector<char> data(sizeof(T) * (End - Begin));\n     char * write_pos = data.data();\n@@ -211,89 +301,104 @@ CodecTestParam generateParam(Generator gen, const char* gen_name)\n         write_pos += sizeof(v);\n     }\n \n-    return CodecTestParam{type_name<T>(), std::move(data), sizeof(T), DEFAULT_MIN_COMPRESSION_RATIO,\n-                (boost::format(\"%1% values of %2% from %3%\") % (End - Begin) % type_name<T>() % gen_name).str()};\n+    return CodecTestSequence{\n+            (boost::format(\"%1% values of %2% from %3%\") % (End - Begin) % type_name<T>() % gen_name).str(),\n+            std::move(data),\n+            makeDataType<T>()\n+    };\n }\n \n-void TestTranscoding(ICompressionCodec * codec, const CodecTestParam & param)\n+\n+class CodecTest : public ::testing::TestWithParam<std::tuple<Codec, CodecTestSequence>>\n {\n-    const auto & source_data = param.source_data;\n+public:\n+    enum MakeCodecParam\n+    {\n+        CODEC_WITH_DATA_TYPE,\n+        CODEC_WITHOUT_DATA_TYPE,\n+    };\n \n-    const UInt32 encoded_max_size = codec->getCompressedReserveSize(source_data.size());\n-    PODArray<char> encoded(encoded_max_size);\n+    CompressionCodecPtr makeCodec(MakeCodecParam with_data_type) const\n+    {\n+        const auto & codec_string = std::get<0>(GetParam()).codec_statement;\n+        const auto & data_type = with_data_type == CODEC_WITH_DATA_TYPE ? std::get<1>(GetParam()).data_type : nullptr;\n \n-    const UInt32 encoded_size = codec->compress(source_data.data(), source_data.size(), encoded.data());\n-    encoded.resize(encoded_size);\n+        const std::string codec_statement = \"(\" + codec_string + \")\";\n+        Tokens tokens(codec_statement.begin().base(), codec_statement.end().base());\n+        TokenIterator token_iterator(tokens);\n \n-    PODArray<char> decoded(source_data.size());\n-    const UInt32 decoded_size = codec->decompress(encoded.data(), encoded.size(), decoded.data());\n-    decoded.resize(decoded_size);\n+        Expected expected;\n+        ASTPtr codec_ast;\n+        ParserCodec parser;\n \n-    switch (param.data_byte_size)\n-    {\n-        case 1:\n-            ASSERT_TRUE(EqualByteContainersAs<UInt8>(source_data, decoded));\n-            break;\n-        case 2:\n-            ASSERT_TRUE(EqualByteContainersAs<UInt16>(source_data, decoded));\n-            break;\n-        case 4:\n-            ASSERT_TRUE(EqualByteContainersAs<UInt32>(source_data, decoded));\n-            break;\n-        case 8:\n-            ASSERT_TRUE(EqualByteContainersAs<UInt64>(source_data, decoded));\n-            break;\n-        default:\n-            FAIL() << \"Invalid data_byte_size: \" << param.data_byte_size;\n-    }\n-    const auto header_size = codec->getHeaderSize();\n-    const auto compression_ratio = (encoded_size - header_size) / (source_data.size() * 1.0);\n+        parser.parse(token_iterator, codec_ast, expected);\n \n-    ASSERT_LE(compression_ratio, param.min_compression_ratio)\n-            << \"\\n\\tdecoded size: \" << source_data.size()\n-            << \"\\n\\tencoded size: \" << encoded_size\n-            << \"(no header: \" << encoded_size - header_size << \")\";\n-}\n+        return CompressionCodecFactory::instance().get(codec_ast, data_type);\n+    }\n \n-class CodecTest : public ::testing::TestWithParam<CodecTestParam>\n-{\n-public:\n-    static void SetUpTestCase()\n+    void testTranscoding(ICompressionCodec & codec)\n     {\n-        // To make random predicatble and avoid failing test \"out of the blue\".\n-        srand(0);\n+        const auto & test_sequence = std::get<1>(GetParam());\n+        const auto & source_data = test_sequence.serialized_data;\n+\n+        const UInt32 encoded_max_size = codec.getCompressedReserveSize(source_data.size());\n+        PODArray<char> encoded(encoded_max_size);\n+\n+        const UInt32 encoded_size = codec.compress(source_data.data(), source_data.size(), encoded.data());\n+        encoded.resize(encoded_size);\n+\n+        PODArray<char> decoded(source_data.size());\n+        const UInt32 decoded_size = codec.decompress(encoded.data(), encoded.size(), decoded.data());\n+        decoded.resize(decoded_size);\n+\n+        switch (test_sequence.data_type->getSizeOfValueInMemory())\n+        {\n+            case 1:\n+                ASSERT_TRUE(EqualByteContainersAs<UInt8>(source_data, decoded));\n+                break;\n+            case 2:\n+                ASSERT_TRUE(EqualByteContainersAs<UInt16>(source_data, decoded));\n+                break;\n+            case 4:\n+                ASSERT_TRUE(EqualByteContainersAs<UInt32>(source_data, decoded));\n+                break;\n+            case 8:\n+                ASSERT_TRUE(EqualByteContainersAs<UInt64>(source_data, decoded));\n+                break;\n+            default:\n+                FAIL() << \"Invalid test sequence data type: \" << test_sequence.data_type->getName();\n+        }\n+        const auto header_size = codec.getHeaderSize();\n+        const auto compression_ratio = (encoded_size - header_size) / (source_data.size() * 1.0);\n+\n+        const auto & codec_spec = std::get<0>(GetParam());\n+        if (codec_spec.expected_compression_ratio)\n+        {\n+            ASSERT_LE(compression_ratio, *codec_spec.expected_compression_ratio)\n+                    << \"\\n\\tdecoded size: \" << source_data.size()\n+                    << \"\\n\\tencoded size: \" << encoded_size\n+                    << \"(no header: \" << encoded_size - header_size << \")\";\n+        }\n     }\n };\n \n-TEST_P(CodecTest, DoubleDelta)\n+TEST_P(CodecTest, TranscodingWithDataType)\n {\n-    auto param = GetParam();\n-    auto codec = std::make_unique<CompressionCodecDoubleDelta>(param.data_byte_size);\n-    if (param.type_name == type_name<Float32>() || param.type_name == type_name<Float64>())\n-    {\n-        // dd doesn't work great with many cases of integers and may result in very poor compression rate.\n-        param.min_compression_ratio *= 1.5;\n-    }\n-\n-    TestTranscoding(codec.get(), param);\n+    const auto codec = makeCodec(CODEC_WITH_DATA_TYPE);\n+    testTranscoding(*codec);\n }\n \n-TEST_P(CodecTest, Gorilla)\n+TEST_P(CodecTest, TranscodingWithoutDataType)\n {\n-    auto param = GetParam();\n-    auto codec = std::make_unique<CompressionCodecGorilla>(param.data_byte_size);\n-    if (param.type_name == type_name<UInt32>() || param.type_name == type_name<Int32>()\n-            || param.type_name == type_name<UInt64>() || param.type_name == type_name<Int64>())\n-    {\n-        // gorilla doesn't work great with many cases of integers and may result in very poor compression rate.\n-        param.min_compression_ratio *= 1.5;\n-    }\n-\n-    TestTranscoding(codec.get(), param);\n+    const auto codec = makeCodec(CODEC_WITHOUT_DATA_TYPE);\n+    testTranscoding(*codec);\n }\n \n+///////////////////////////////////////////////////////////////////////////////////////////////////\n // Here we use generators to produce test payload for codecs.\n-// Generator is a callable that should produce output value of the same type as input value.\n+// Generator is a callable that can produce infinite number of values,\n+// output value MUST be of the same type input value.\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n \n auto SameValueGenerator = [](auto value)\n {\n@@ -332,141 +437,427 @@ auto SequentialGenerator = [](auto stride = 1)\n //};\n \n template <typename T>\n+using uniform_distribution =\n+typename std::conditional_t<std::is_floating_point_v<T>, std::uniform_real_distribution<T>,\n+        typename std::conditional_t<std::is_integral_v<T>, std::uniform_int_distribution<T>, void>>;\n+\n+\n+template <typename T = Int32>\n struct MonotonicGenerator\n {\n-    MonotonicGenerator(T stride_ = 1, size_t max_step_ = 10)\n+    MonotonicGenerator(T stride_ = 1, T max_step = 10)\n         : prev_value(0),\n           stride(stride_),\n-          max_step(max_step_)\n+          random_engine(0),\n+          distribution(0, max_step)\n     {}\n \n     template <typename U>\n     U operator()(U)\n     {\n-        const U result = prev_value + static_cast<T>(stride * (rand() % max_step));\n-\n-        prev_value = result;\n-        return result;\n+        prev_value = prev_value + stride * distribution(random_engine);\n+        return static_cast<U>(prev_value);\n     }\n \n+private:\n     T prev_value;\n     const T stride;\n-    const size_t max_step;\n-};\n-\n-auto MinMaxGenerator = [](auto i)\n-{\n-    if (i % 2 == 0)\n-    {\n-        return std::numeric_limits<decltype(i)>::min();\n-    }\n-    else\n-    {\n-        return std::numeric_limits<decltype(i)>::max();\n-    }\n+    std::default_random_engine random_engine;\n+    uniform_distribution<T> distribution;\n };\n \n template <typename T>\n struct RandomGenerator\n {\n-    RandomGenerator(T seed = 0, T value_cap_ = std::numeric_limits<T>::max())\n-        : e(seed),\n-          value_cap(value_cap_)\n+    RandomGenerator(T seed = 0, T value_min = std::numeric_limits<T>::min(), T value_max = std::numeric_limits<T>::max())\n+        : random_engine(seed),\n+          distribution(value_min, value_max)\n     {\n     }\n \n     template <typename U>\n-    U operator()(U i)\n+    U operator()(U)\n     {\n-        return static_cast<decltype(i)>(distribution(e) % value_cap);\n+        return static_cast<U>(distribution(random_engine));\n     }\n \n private:\n-    std::default_random_engine e;\n-    std::uniform_int_distribution<T> distribution;\n-    const T value_cap;\n+    std::default_random_engine random_engine;\n+    uniform_distribution<T> distribution;\n };\n \n auto RandomishGenerator = [](auto i)\n {\n-    return static_cast<decltype(i)>(sin(static_cast<double>(i) * i) * i);\n+    return static_cast<decltype(i)>(sin(static_cast<double>(i * i)) * i);\n+};\n+\n+auto MinMaxGenerator = []()\n+{\n+    return [step = 0](auto i) mutable\n+    {\n+        if (step++ % 2 == 0)\n+        {\n+            return std::numeric_limits<decltype(i)>::min();\n+        }\n+        else\n+        {\n+            return std::numeric_limits<decltype(i)>::max();\n+        }\n+    };\n };\n \n-// helper macro to produce human-friendly test case name\n+// Fill dest value with 0x00 or 0xFF\n+auto FFand0Generator = []()\n+{\n+    return [step = 0](auto i) mutable\n+    {\n+        decltype(i) result;\n+        if (step++ % 2 == 0)\n+        {\n+            memset(&result, 0, sizeof(result));\n+        }\n+        else\n+        {\n+            memset(&result, 0xFF, sizeof(result));\n+        }\n+\n+        return result;\n+    };\n+};\n+\n+\n+// Makes many sequences with generator, first sequence length is 1, second is 2... up to `sequences_count`.\n+template <typename T, typename Generator>\n+std::vector<CodecTestSequence> generatePyramidOfSequences(const size_t sequences_count, Generator && generator, const char* generator_name)\n+{\n+    std::vector<CodecTestSequence> sequences;\n+    sequences.reserve(sequences_count);\n+    for (size_t i = 1; i < sequences_count; ++i)\n+    {\n+        std::string name = generator_name + std::string(\" from 0 to \") + std::to_string(i);\n+        sequences.push_back(generateSeq<T>(std::forward<decltype(generator)>(generator), name.c_str(), 0, i));\n+    }\n+\n+    return sequences;\n+};\n+\n+\n+// helper macro to produce human-friendly sequence name from generator\n #define G(generator) generator, #generator\n \n+const auto DefaultCodecsToTest = ::testing::Values(\n+    Codec(\"DoubleDelta\"),\n+    Codec(\"DoubleDelta, LZ4\"),\n+    Codec(\"DoubleDelta, ZSTD\"),\n+    Codec(\"Gorilla\"),\n+    Codec(\"Gorilla, LZ4\"),\n+    Codec(\"Gorilla, ZSTD\")\n+);\n+\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+// test cases\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+INSTANTIATE_TEST_CASE_P(Simple,\n+    CodecTest,\n+    ::testing::Combine(\n+        DefaultCodecsToTest,\n+        ::testing::Values(\n+            makeSeq<Float64>(1, 2, 3, 5, 7, 11, 13, 17, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97)\n+        )\n+    ),\n+);\n+\n+INSTANTIATE_TEST_CASE_P(SmallSequences,\n+    CodecTest,\n+    ::testing::Combine(\n+        DefaultCodecsToTest,\n+        ::testing::ValuesIn(\n+                  generatePyramidOfSequences<Int8  >(42, G(SequentialGenerator(1)))\n+                + generatePyramidOfSequences<Int16 >(42, G(SequentialGenerator(1)))\n+                + generatePyramidOfSequences<Int32 >(42, G(SequentialGenerator(1)))\n+                + generatePyramidOfSequences<Int64 >(42, G(SequentialGenerator(1)))\n+                + generatePyramidOfSequences<UInt8 >(42, G(SequentialGenerator(1)))\n+                + generatePyramidOfSequences<UInt16>(42, G(SequentialGenerator(1)))\n+                + generatePyramidOfSequences<UInt32>(42, G(SequentialGenerator(1)))\n+                + generatePyramidOfSequences<UInt64>(42, G(SequentialGenerator(1)))\n+        )\n+    ),\n+);\n+\n INSTANTIATE_TEST_CASE_P(Mixed,\n     CodecTest,\n-    ::testing::Values(\n-        generateParam<Int32,  1, 3>(G(MinMaxGenerator)) + generateParam<Int32,  1, 11>(G(SequentialGenerator(1))).setRatio(1),\n-        generateParam<UInt32, 1, 3>(G(MinMaxGenerator)) + generateParam<UInt32, 1, 11>(G(SequentialGenerator(1))).setRatio(1),\n-        generateParam<Int64,  1, 3>(G(MinMaxGenerator)) + generateParam<Int64,  1, 11>(G(SequentialGenerator(1))).setRatio(1),\n-        generateParam<UInt64, 1, 3>(G(MinMaxGenerator)) + generateParam<UInt64, 1, 11>(G(SequentialGenerator(1))).setRatio(1)\n+    ::testing::Combine(\n+        DefaultCodecsToTest,\n+        ::testing::Values(\n+            generateSeq<Int8>(G(MinMaxGenerator()), 1, 5) + generateSeq<Int8>(G(SequentialGenerator(1)), 1, 1001),\n+            generateSeq<Int16>(G(MinMaxGenerator()), 1, 5) + generateSeq<Int16>(G(SequentialGenerator(1)), 1, 1001),\n+            generateSeq<Int32>(G(MinMaxGenerator()), 1, 5) + generateSeq<Int32>(G(SequentialGenerator(1)), 1, 1001),\n+            generateSeq<Int64>(G(MinMaxGenerator()), 1, 5) + generateSeq<Int64>(G(SequentialGenerator(1)), 1, 1001),\n+            generateSeq<UInt8>(G(MinMaxGenerator()), 1, 5) + generateSeq<UInt8>(G(SequentialGenerator(1)), 1, 1001),\n+            generateSeq<UInt16>(G(MinMaxGenerator()), 1, 5) + generateSeq<UInt16>(G(SequentialGenerator(1)), 1, 1001),\n+            generateSeq<UInt32>(G(MinMaxGenerator()), 1, 5) + generateSeq<UInt32>(G(SequentialGenerator(1)), 1, 1001),\n+            generateSeq<UInt64>(G(MinMaxGenerator()), 1, 5) + generateSeq<UInt64>(G(SequentialGenerator(1)), 1, 1001)\n+        )\n     ),\n );\n \n-INSTANTIATE_TEST_CASE_P(Same,\n+INSTANTIATE_TEST_CASE_P(SameValueInt,\n     CodecTest,\n-    ::testing::Values(\n-        generateParam<UInt32>(G(SameValueGenerator(1000))),\n-        generateParam<Int32>(G(SameValueGenerator(-1000))),\n-        generateParam<UInt64>(G(SameValueGenerator(1000))),\n-        generateParam<Int64>(G(SameValueGenerator(-1000))),\n-        generateParam<Float32>(G(SameValueGenerator(M_E))),\n-        generateParam<Float64>(G(SameValueGenerator(M_E)))\n+    ::testing::Combine(\n+        DefaultCodecsToTest,\n+        ::testing::Values(\n+            generateSeq<Int8  >(G(SameValueGenerator(1000))),\n+            generateSeq<Int16 >(G(SameValueGenerator(1000))),\n+            generateSeq<Int32 >(G(SameValueGenerator(1000))),\n+            generateSeq<Int64 >(G(SameValueGenerator(1000))),\n+            generateSeq<UInt8 >(G(SameValueGenerator(1000))),\n+            generateSeq<UInt16>(G(SameValueGenerator(1000))),\n+            generateSeq<UInt32>(G(SameValueGenerator(1000))),\n+            generateSeq<UInt64>(G(SameValueGenerator(1000)))\n+        )\n     ),\n );\n \n-INSTANTIATE_TEST_CASE_P(Sequential,\n+INSTANTIATE_TEST_CASE_P(SameNegativeValueInt,\n     CodecTest,\n-    ::testing::Values(\n-        generateParam<UInt32>(G(SequentialGenerator(1))),\n-        generateParam<Int32>(G(SequentialGenerator(-1))),\n-        generateParam<UInt64>(G(SequentialGenerator(1))),\n-        generateParam<Int64>(G(SequentialGenerator(-1))),\n-        generateParam<Float32>(G(SequentialGenerator(M_E))),\n-        generateParam<Float64>(G(SequentialGenerator(M_E)))\n+    ::testing::Combine(\n+        DefaultCodecsToTest,\n+        ::testing::Values(\n+            generateSeq<Int8  >(G(SameValueGenerator(-1000))),\n+            generateSeq<Int16 >(G(SameValueGenerator(-1000))),\n+            generateSeq<Int32 >(G(SameValueGenerator(-1000))),\n+            generateSeq<Int64 >(G(SameValueGenerator(-1000))),\n+            generateSeq<UInt8 >(G(SameValueGenerator(-1000))),\n+            generateSeq<UInt16>(G(SameValueGenerator(-1000))),\n+            generateSeq<UInt32>(G(SameValueGenerator(-1000))),\n+            generateSeq<UInt64>(G(SameValueGenerator(-1000)))\n+        )\n     ),\n );\n \n-INSTANTIATE_TEST_CASE_P(Monotonic,\n+INSTANTIATE_TEST_CASE_P(SameValueFloat,\n     CodecTest,\n-    ::testing::Values(\n-        generateParam<UInt32>(G(MonotonicGenerator<UInt32>(1, 5))),\n-        generateParam<Int32>(G(MonotonicGenerator<Int32>(-1, 5))),\n-        generateParam<UInt64>(G(MonotonicGenerator<UInt64>(1, 5))),\n-        generateParam<Int64>(G(MonotonicGenerator<Int64>(-1, 5))),\n-        generateParam<Float32>(G(MonotonicGenerator<Float32>(M_E, 5))),\n-        generateParam<Float64>(G(MonotonicGenerator<Float64>(M_E, 5)))\n+    ::testing::Combine(\n+        ::testing::Values(\n+            Codec(\"Gorilla\"),\n+            Codec(\"Gorilla, LZ4\")\n+        ),\n+        ::testing::Values(\n+            generateSeq<Float32>(G(SameValueGenerator(M_E))),\n+            generateSeq<Float64>(G(SameValueGenerator(M_E)))\n+        )\n     ),\n );\n \n-INSTANTIATE_TEST_CASE_P(Random,\n+INSTANTIATE_TEST_CASE_P(SameNegativeValueFloat,\n     CodecTest,\n-    ::testing::Values(\n-        generateParam<UInt32>(G(RandomGenerator<UInt32>(0, 1000'000'000))).setRatio(1.2),\n-        generateParam<UInt64>(G(RandomGenerator<UInt64>(0, 1000'000'000))).setRatio(1.1)\n+    ::testing::Combine(\n+        ::testing::Values(\n+            Codec(\"Gorilla\"),\n+            Codec(\"Gorilla, LZ4\")\n+        ),\n+        ::testing::Values(\n+            generateSeq<Float32>(G(SameValueGenerator(-1 * M_E))),\n+            generateSeq<Float64>(G(SameValueGenerator(-1 * M_E)))\n+        )\n     ),\n );\n \n-INSTANTIATE_TEST_CASE_P(Randomish,\n+INSTANTIATE_TEST_CASE_P(SequentialInt,\n     CodecTest,\n-    ::testing::Values(\n-        generateParam<Int32>(G(RandomishGenerator)).setRatio(1.1),\n-        generateParam<Int64>(G(RandomishGenerator)).setRatio(1.1),\n-        generateParam<UInt32>(G(RandomishGenerator)).setRatio(1.1),\n-        generateParam<UInt64>(G(RandomishGenerator)).setRatio(1.1),\n-        generateParam<Float32>(G(RandomishGenerator)).setRatio(1.1),\n-        generateParam<Float64>(G(RandomishGenerator)).setRatio(1.1)\n+    ::testing::Combine(\n+        DefaultCodecsToTest,\n+        ::testing::Values(\n+            generateSeq<Int8  >(G(SequentialGenerator(1))),\n+            generateSeq<Int16 >(G(SequentialGenerator(1))),\n+            generateSeq<Int32 >(G(SequentialGenerator(1))),\n+            generateSeq<Int64 >(G(SequentialGenerator(1))),\n+            generateSeq<UInt8 >(G(SequentialGenerator(1))),\n+            generateSeq<UInt16>(G(SequentialGenerator(1))),\n+            generateSeq<UInt32>(G(SequentialGenerator(1))),\n+            generateSeq<UInt64>(G(SequentialGenerator(1)))\n+        )\n     ),\n );\n \n-INSTANTIATE_TEST_CASE_P(Overflow,\n+// -1, -2, -3, ... etc for signed\n+// 0xFF, 0xFE, 0xFD, ... for unsigned\n+INSTANTIATE_TEST_CASE_P(SequentialReverseInt,\n     CodecTest,\n-    ::testing::Values(\n-        generateParam<UInt32>(G(MinMaxGenerator)),\n-        generateParam<Int32>(G(MinMaxGenerator)),\n-        generateParam<UInt64>(G(MinMaxGenerator)),\n-        generateParam<Int64>(G(MinMaxGenerator))\n+    ::testing::Combine(\n+        DefaultCodecsToTest,\n+        ::testing::Values(\n+            generateSeq<Int8  >(G(SequentialGenerator(-1))),\n+            generateSeq<Int16 >(G(SequentialGenerator(-1))),\n+            generateSeq<Int32 >(G(SequentialGenerator(-1))),\n+            generateSeq<Int64 >(G(SequentialGenerator(-1))),\n+            generateSeq<UInt8 >(G(SequentialGenerator(-1))),\n+            generateSeq<UInt16>(G(SequentialGenerator(-1))),\n+            generateSeq<UInt32>(G(SequentialGenerator(-1))),\n+            generateSeq<UInt64>(G(SequentialGenerator(-1)))\n+        )\n     ),\n );\n+\n+INSTANTIATE_TEST_CASE_P(SequentialFloat,\n+    CodecTest,\n+    ::testing::Combine(\n+        ::testing::Values(\n+            Codec(\"Gorilla\"),\n+            Codec(\"Gorilla, LZ4\")\n+        ),\n+        ::testing::Values(\n+            generateSeq<Float32>(G(SequentialGenerator(M_E))),\n+            generateSeq<Float64>(G(SequentialGenerator(M_E)))\n+        )\n+    ),\n+);\n+\n+INSTANTIATE_TEST_CASE_P(SequentialReverseFloat,\n+    CodecTest,\n+    ::testing::Combine(\n+        ::testing::Values(\n+            Codec(\"Gorilla\"),\n+            Codec(\"Gorilla, LZ4\")\n+        ),\n+        ::testing::Values(\n+            generateSeq<Float32>(G(SequentialGenerator(-1 * M_E))),\n+            generateSeq<Float64>(G(SequentialGenerator(-1 * M_E)))\n+        )\n+    ),\n+);\n+\n+INSTANTIATE_TEST_CASE_P(MonotonicInt,\n+    CodecTest,\n+    ::testing::Combine(\n+        DefaultCodecsToTest,\n+        ::testing::Values(\n+            generateSeq<Int8  >(G(MonotonicGenerator(1, 5))),\n+            generateSeq<Int16 >(G(MonotonicGenerator(1, 5))),\n+            generateSeq<Int32 >(G(MonotonicGenerator(1, 5))),\n+            generateSeq<Int64 >(G(MonotonicGenerator(1, 5))),\n+            generateSeq<UInt8 >(G(MonotonicGenerator(1, 5))),\n+            generateSeq<UInt16>(G(MonotonicGenerator(1, 5))),\n+            generateSeq<UInt32>(G(MonotonicGenerator(1, 5))),\n+            generateSeq<UInt64>(G(MonotonicGenerator(1, 5)))\n+        )\n+    ),\n+);\n+\n+INSTANTIATE_TEST_CASE_P(MonotonicReverseInt,\n+    CodecTest,\n+    ::testing::Combine(\n+        DefaultCodecsToTest,\n+        ::testing::Values(\n+            generateSeq<Int8  >(G(MonotonicGenerator(-1, 5))),\n+            generateSeq<Int16 >(G(MonotonicGenerator(-1, 5))),\n+            generateSeq<Int32 >(G(MonotonicGenerator(-1, 5))),\n+            generateSeq<Int64 >(G(MonotonicGenerator(-1, 5))),\n+            generateSeq<UInt8 >(G(MonotonicGenerator(-1, 5))),\n+            generateSeq<UInt16>(G(MonotonicGenerator(-1, 5))),\n+            generateSeq<UInt32>(G(MonotonicGenerator(-1, 5))),\n+            generateSeq<UInt64>(G(MonotonicGenerator(-1, 5)))\n+        )\n+    ),\n+);\n+\n+INSTANTIATE_TEST_CASE_P(MonotonicFloat,\n+    CodecTest,\n+    ::testing::Combine(\n+        ::testing::Values(\n+            Codec(\"Gorilla\")\n+        ),\n+        ::testing::Values(\n+            generateSeq<Float32>(G(MonotonicGenerator<Float32>(M_E, 5))),\n+            generateSeq<Float64>(G(MonotonicGenerator<Float64>(M_E, 5)))\n+        )\n+    ),\n+);\n+\n+INSTANTIATE_TEST_CASE_P(MonotonicReverseFloat,\n+    CodecTest,\n+    ::testing::Combine(\n+        ::testing::Values(\n+            Codec(\"Gorilla\")\n+        ),\n+        ::testing::Values(\n+            generateSeq<Float32>(G(MonotonicGenerator<Float32>(-1 * M_E, 5))),\n+            generateSeq<Float64>(G(MonotonicGenerator<Float64>(-1 * M_E, 5)))\n+        )\n+    ),\n+);\n+\n+INSTANTIATE_TEST_CASE_P(RandomInt,\n+    CodecTest,\n+    ::testing::Combine(\n+        DefaultCodecsToTest,\n+        ::testing::Values(\n+            generateSeq<UInt8 >(G(RandomGenerator<UInt8>(0))),\n+            generateSeq<UInt16>(G(RandomGenerator<UInt16>(0))),\n+            generateSeq<UInt32>(G(RandomGenerator<UInt32>(0, 0, 1000'000'000))),\n+            generateSeq<UInt64>(G(RandomGenerator<UInt64>(0, 0, 1000'000'000)))\n+        )\n+    ),\n+);\n+\n+INSTANTIATE_TEST_CASE_P(RandomishInt,\n+    CodecTest,\n+    ::testing::Combine(\n+        DefaultCodecsToTest,\n+        ::testing::Values(\n+            generateSeq<Int32>(G(RandomishGenerator)),\n+            generateSeq<Int64>(G(RandomishGenerator)),\n+            generateSeq<UInt32>(G(RandomishGenerator)),\n+            generateSeq<UInt64>(G(RandomishGenerator)),\n+            generateSeq<Float32>(G(RandomishGenerator)),\n+            generateSeq<Float64>(G(RandomishGenerator))\n+        )\n+    ),\n+);\n+\n+INSTANTIATE_TEST_CASE_P(RandomishFloat,\n+    CodecTest,\n+    ::testing::Combine(\n+        DefaultCodecsToTest,\n+        ::testing::Values(\n+            generateSeq<Float32>(G(RandomishGenerator)),\n+            generateSeq<Float64>(G(RandomishGenerator))\n+        )\n+    ),\n+);\n+\n+// Double delta overflow case, deltas are out of bounds for target type\n+INSTANTIATE_TEST_CASE_P(OverflowInt,\n+    CodecTest,\n+    ::testing::Combine(\n+        ::testing::Values(\n+            Codec(\"DoubleDelta\", 1.2),\n+            Codec(\"DoubleDelta, LZ4\", 1.0)\n+        ),\n+        ::testing::Values(\n+            generateSeq<UInt32>(G(MinMaxGenerator())),\n+            generateSeq<Int32>(G(MinMaxGenerator())),\n+            generateSeq<UInt64>(G(MinMaxGenerator())),\n+            generateSeq<Int64>(G(MinMaxGenerator()))\n+        )\n+    ),\n+);\n+\n+INSTANTIATE_TEST_CASE_P(OverflowFloat,\n+    CodecTest,\n+    ::testing::Combine(\n+        ::testing::Values(\n+            Codec(\"Gorilla\", 1.1),\n+            Codec(\"Gorilla, LZ4\", 1.0)\n+        ),\n+        ::testing::Values(\n+            generateSeq<Float32>(G(MinMaxGenerator())),\n+            generateSeq<Float64>(G(MinMaxGenerator())),\n+            generateSeq<Float32>(G(FFand0Generator())),\n+            generateSeq<Float64>(G(FFand0Generator()))\n+        )\n+    ),\n+);\n+\n+}\n",
  "problem_statement": "Gorilla compression fails on merge\n**Describe the bug**\r\nWe test clickhouse with carbon-clickhouse as replacement for the graphite database.\r\nWhen we tried to use Gorilla compression for the metric values, but after a while the clickhouse server error log fills with error messages.\r\n\r\nVersion:\r\nversion 19.11.6.31 (official build)\r\n\r\nError message:\r\n2019.08.08 11:17:30.152682 [ 42 ] {909d41bd-3856-4de7-aae8-47cb91d0e56f} <Error> executeQuery: Code: 71, e.displayText() = DB::Exception: Cannot write after end of buffer. (version 19.11.6.31 (official build)) (from 127.0.0.1:51176) (in query: INSERT INTO graphite.data (Path, Value, Time, Date, Timestamp) FORMAT RowBinary ), Stack trace:\r\n\r\n0. clickhouse-server(StackTrace::StackTrace()+0x30) [0x7d258d0]\r\n1. clickhouse-server(DB::Exception::Exception(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, int)+0x25) [0x3bb8205]\r\n2. clickhouse-server(DB::WriteBuffer::nextImpl()+0x55) [0x38dc68d]\r\n3. clickhouse-server() [0x708609f]\r\n4. clickhouse-server(DB::CompressionCodecGorilla::doCompressData(char const*, unsigned int, char*) const+0x122) [0x7086202]\r\n5. clickhouse-server(DB::ICompressionCodec::compress(char const*, unsigned int, char*) const+0x33) [0x6ac6083]\r\n6. clickhouse-server(DB::CompressionCodecMultiple::doCompressData(char const*, unsigned int, char*) const+0x202) [0x7088e02]\r\n7. clickhouse-server(DB::ICompressionCodec::compress(char const*, unsigned int, char*) const+0x33) [0x6ac6083]\r\n8. clickhouse-server(DB::CompressedWriteBuffer::nextImpl()+0xae) [0x6ac0dfe]\r\n9. clickhouse-server(DB::IMergedBlockOutputStream::ColumnStream::finalize()+0x68) [0x72fbf88]\r\n10. clickhouse-server(DB::MergedBlockOutputStream::writeSuffixAndFinalizePart(std::shared_ptr<DB::MergeTreeDataPart>&, DB::NamesAndTypesList const*, DB::MergeTreeDataPartChecksums*)+0x8c9) [0x6f66399]\r\n11. clickhouse-server(DB::MergeTreeDataWriter::writeTempPart(DB::BlockWithPartition&)+0x1447) [0x6f348d7]\r\n12. clickhouse-server(DB::MergeTreeBlockOutputStream::write(DB::Block const&)+0xe4) [0x6ed41b4]\r\n13. clickhouse-server(DB::PushingToViewsBlockOutputStream::write(DB::Block const&)+0x51) [0x710d551]\r\n14. clickhouse-server(DB::SquashingBlockOutputStream::finalize()+0x143) [0x7115d03]\r\n15. clickhouse-server(DB::SquashingBlockOutputStream::writeSuffix()+0x11) [0x7115f31]\r\n16. clickhouse-server(DB::copyData(DB::IBlockInputStream&, DB::IBlockOutputStream&, std::atomic<bool>*)+0x707) [0x6aea047]\r\n17. clickhouse-server(DB::executeQuery(DB::ReadBuffer&, DB::WriteBuffer&, bool, DB::Context&, std::function<void (std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)>, std::function<void (std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)>)+0x1da) [0x6d39a7a]\r\n18. clickhouse-server(DB::HTTPHandler::processQuery(Poco::Net::HTTPServerRequest&, HTMLForm&, Poco::Net::HTTPServerResponse&, DB::HTTPHandler::Output&)+0x197e) [0x3bcd00e]\r\n19. clickhouse-server(DB::HTTPHandler::handleRequest(Poco::Net::HTTPServerRequest&, Poco::Net::HTTPServerResponse&)+0x52b) [0x3bcf42b]\r\n20. clickhouse-server(Poco::Net::HTTPServerConnection::run()+0x2a9) [0x7705979]\r\n21. clickhouse-server(Poco::Net::TCPServerConnection::start()+0x10) [0x7700750]\r\n22. clickhouse-server(Poco::Net::TCPServerDispatcher::run()+0xed) [0x7700e6d]\r\n23. clickhouse-server(Poco::PooledThread::run()+0x81) [0x7e24621]\r\n24. clickhouse-server(Poco::ThreadImpl::runnableEntry(void*)+0x3c) [0x7e223cc]\r\n25. clickhouse-server() [0xb7f7b40]\r\n26. /lib64/libpthread.so.0() [0x306fe07aa1]\r\n27. /lib64/libc.so.6(clone+0x6d) [0x306fae8bdd]\r\n\r\nOn another server we also get ABORTs:\r\n2019.08.08 11:10:06.829438 [ 4 ] {} <Warning> graphite.data: Removing temporary directory /var/lib/clickhouse/data/graphite/data/tmp_insert_201908_2736_2736_0\r\n2019.08.08 11:10:30.247196 [ 43 ] {} <Error> BaseDaemon: (version 19.11.6.31 (official build)) (from thread 41) Terminate called for uncaught exception:\r\nCode: 71, e.displayText() = DB::Exception: Cannot write after end of buffer., Stack trace:\r\n\r\n0. clickhouse-server(StackTrace::StackTrace()+0x30) [0x7d258d0]\r\n1. clickhouse-server(DB::Exception::Exception(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, int)+0x25) [0x3bb8205]\r\n2. clickhouse-server(DB::WriteBuffer::nextImpl()+0x55) [0x38dc68d]\r\n3. clickhouse-server(DB::BitWriter::doFlush()+0x165) [0x707eab5]\r\n4. clickhouse-server() [0x39a5d4f]\r\n5. clickhouse-server(DB::CompressionCodecGorilla::doCompressData(char const*, unsigned int, char*) const+0x122) [0x7086202]\r\n6. clickhouse-server(DB::ICompressionCodec::compress(char const*, unsigned int, char*) const+0x33) [0x6ac6083]\r\n7. clickhouse-server(DB::CompressionCodecMultiple::doCompressData(char const*, unsigned int, char*) const+0x202) [0x7088e02]\r\n8. clickhouse-server(DB::ICompressionCodec::compress(char const*, unsigned int, char*) const+0x33) [0x6ac6083]\r\n9. clickhouse-se\r\n2019.08.08 11:10:30.249130 [ 43 ] {} <Error> BaseDaemon: ########################################\r\n2019.08.08 11:10:30.249177 [ 43 ] {} <Error> BaseDaemon: (version 19.11.6.31 (official build)) (from thread 41) Received signal Aborted (6).\r\n2019.08.08 11:10:30.249194 [ 43 ] {} <Error> BaseDaemon: \r\n2019.08.08 11:10:30.362874 [ 43 ] {} <Error> BaseDaemon: 0. clickhouse-server(StackTrace::StackTrace(ucontext_t const&)+0x31) [0x7d25911]\r\n1. clickhouse-server() [0x3cd5a5e]\r\n2. /lib64/libpthread.so.0() [0x389ca0f7e0]\r\n3. /lib64/libc.so.6(gsignal+0x35) [0x389c232495]\r\n4. /lib64/libc.so.6(abort+0x175) [0x389c233c75]\r\n5. clickhouse-server() [0x376a23c]\r\n6. clickhouse-server(__cxxabiv1::__terminate(void (*)())+0x6) [0xb773436]\r\n7. clickhouse-server() [0xb80f759]\r\n8. clickhouse-server(__gxx_personality_v0+0x294) [0xb772e14]\r\n9. clickhouse-server() [0xb81e169]\r\n10. clickhouse-server(_Unwind_Resume+0xa7) [0xb81e3c7]\r\n11. clickhouse-server() [0x707eb67]\r\n12. clickhouse-server() [0x39a5d4f]\r\n13. clickhouse-server(DB::CompressionCodecGorilla::doCompressData(char const*, unsigned int, char*) const+0x122) [0x7086202]\r\n14. clickhouse-server(DB::ICompressionCodec::compress(char const*, unsigned int, char*) const+0x33) [0x6ac6083]\r\n15. clickhouse-server(DB::CompressionCodecMultiple::doCompressData(char const*, unsigned int, char*) const+0x202) [0x7088e02]\r\n16. clickhouse-server(DB::ICompressionCodec::compress(char const*, unsigned int, char*) const+0x33) [0x6ac6083]\r\n17. clickhouse-server(DB::CompressedWriteBuffer::nextImpl()+0xae) [0x6ac0dfe]\r\n18. clickhouse-server(DB::IMergedBlockOutputStream::ColumnStream::finalize()+0x68) [0x72fbf88]\r\n19. clickhouse-server(DB::MergedBlockOutputStream::writeSuffixAndFinalizePart(std::shared_ptr<DB::MergeTreeDataPart>&, DB::NamesAndTypesList const*, DB::MergeTreeDataPartChecksums*)+0x8c9) [0x6f66399]\r\n20. clickhouse-server(DB::MergeTreeDataWriter::writeTempPart(DB::BlockWithPartition&)+0x1447) [0x6f348d7]\r\n21. clickhouse-server(DB::MergeTreeBlockOutputStream::write(DB::Block const&)+0xe4) [0x6ed41b4]\r\n22. clickhouse-server(DB::PushingToViewsBlockOutputStream::write(DB::Block const&)+0x51) [0x710d551]\r\n23. clickhouse-server(DB::SquashingBlockOutputStream::finalize()+0x143) [0x7115d03]\r\n24. clickhouse-server(DB::SquashingBlockOutputStream::writeSuffix()+0x11) [0x7115f31]\r\n25. clickhouse-server(DB::copyData(DB::IBlockInputStream&, DB::IBlockOutputStream&, std::atomic<bool>*)+0x707) [0x6aea047]\r\n26. clickhouse-server(DB::executeQuery(DB::ReadBuffer&, DB::WriteBuffer&, bool, DB::Context&, std::function<void (std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)>, std::function<void (std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)>)+0x1da) [0x6d39a7a]\r\n27. clickhouse-server(DB::HTTPHandler::processQuery(Poco::Net::HTTPServerRequest&, HTMLForm&, Poco::Net::HTTPServerResponse&, DB::HTTPHandler::Output&)+0x197e) [0x3bcd00e]\r\n28. clickhouse-server(DB::HTTPHandler::handleRequest(Poco::Net::HTTPServerRequest&, Poco::Net::HTTPServerResponse&)+0x52b) [0x3bcf42b]\r\n29. clickhouse-server(Poco::Net::HTTPServerConnection::run()+0x2a9) [0x7705979]\r\n30. clickhouse-server(Poco::Net::TCPServerConnection::start()+0x10) [0x7700750]\r\n31. clickhouse-server(Poco::Net::TCPServerDispatcher::run()+0xed) [0x7700e6d]\r\n\r\nTable definition for graphite.data\r\nATTACH TABLE data\r\n(\r\n    `Path` String CODEC(ZSTD(1)), \r\n    `Value` Float64 CODEC(Gorilla, LZ4), \r\n    `Time` UInt32 CODEC(DoubleDelta, LZ4), \r\n    `Date` Date, \r\n    `Timestamp` UInt32 CODEC(Delta(4), ZSTD(1))\r\n)\r\nENGINE = GraphiteMergeTree('graphite_rollup')\r\nPARTITION BY toYYYYMM(Date)\r\nORDER BY (Path, Time)\r\nSETTINGS index_granularity = 8192\n",
  "hints_text": "Thank you for reporting. I was able to reproduce the issue and working on a fix.",
  "created_at": "2019-08-12T05:05:45Z",
  "modified_files": [
    "dbms/src/Compression/CompressionCodecGorilla.cpp",
    "dbms/src/Compression/ICompressionCodec.cpp"
  ],
  "modified_test_files": [
    "dbms/src/Compression/tests/gtest_compressionCodec.cpp"
  ]
}