{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 71679,
  "instance_id": "ClickHouse__ClickHouse-71679",
  "issue_numbers": [
    "71647"
  ],
  "base_commit": "49e41f23ee18a4ab90bf045a7e1eee9c74074954",
  "patch": "diff --git a/src/Functions/FunctionsComparison.h b/src/Functions/FunctionsComparison.h\nindex be0875581a5c..9b2328065fc7 100644\n--- a/src/Functions/FunctionsComparison.h\n+++ b/src/Functions/FunctionsComparison.h\n@@ -1033,6 +1033,9 @@ class FunctionComparison : public IFunction\n             size_t tuple_size,\n             size_t input_rows_count) const\n     {\n+        if (0 == tuple_size)\n+            throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Comparison of zero-sized tuples is not implemented\");\n+\n         ColumnsWithTypeAndName less_columns(tuple_size);\n         ColumnsWithTypeAndName equal_columns(tuple_size - 1);\n         ColumnsWithTypeAndName tmp_columns(2);\ndiff --git a/src/Functions/if.cpp b/src/Functions/if.cpp\nindex e03b27b3c394..5e1e7067e86e 100644\n--- a/src/Functions/if.cpp\n+++ b/src/Functions/if.cpp\n@@ -668,6 +668,9 @@ class FunctionIf : public FunctionIfBase\n         temporary_columns[0] = arguments[0];\n \n         size_t tuple_size = type1.getElements().size();\n+        if (tuple_size == 0)\n+            return ColumnTuple::create(input_rows_count);\n+\n         Columns tuple_columns(tuple_size);\n \n         for (size_t i = 0; i < tuple_size; ++i)\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03268_empty_tuple_update.reference b/tests/queries/0_stateless/03268_empty_tuple_update.reference\nnew file mode 100644\nindex 000000000000..30bc45d7a180\n--- /dev/null\n+++ b/tests/queries/0_stateless/03268_empty_tuple_update.reference\n@@ -0,0 +1,1 @@\n+()\t2\ndiff --git a/tests/queries/0_stateless/03268_empty_tuple_update.sql b/tests/queries/0_stateless/03268_empty_tuple_update.sql\nnew file mode 100644\nindex 000000000000..343117719fcd\n--- /dev/null\n+++ b/tests/queries/0_stateless/03268_empty_tuple_update.sql\n@@ -0,0 +1,11 @@\n+DROP TABLE IF EXISTS t0;\n+\n+CREATE TABLE t0 (c0 Tuple(), c1 int) ENGINE = Memory();\n+\n+INSERT INTO t0 VALUES ((), 1);\n+\n+ALTER TABLE t0 UPDATE c0 = (), c1 = 2 WHERE EXISTS (SELECT 1);\n+\n+SELECT * FROM t0;\n+\n+DROP TABLE t0;\n",
  "problem_statement": "Logical error on empty tuple update\n**Describe the bug**\r\nUpdating an empty tuple causes a logical error.\r\n\r\n**How to reproduce**\r\nRun:\r\nhttps://fiddle.clickhouse.com/98689e01-0eba-4991-a911-2f7eb6c9701d\r\n\r\nStack trace\r\n```\r\nLogical error: 'This function cannot be used to construct empty tuple. It is a bug'.\r\nStack trace (when copying this message, always include the lines below):\r\n\r\n0. std::exception::capture() @ 0x0000000019432f0b\r\n1. ./contrib/llvm-project/libcxx/include/exception:114: Poco::Exception::Exception(String const&, int) @ 0x0000000038cc0b85\r\n2. src/Common/Exception.cpp:109: DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0x000000002558d8cb\r\n3. DB::Exception::Exception(PreformattedMessage&&, int) @ 0x00000000192b1296\r\n4. DB::Exception::Exception<>(int, FormatStringHelperImpl<>) @ 0x00000000192cacef\r\n5. src/Columns/ColumnTuple.cpp:69: DB::ColumnTuple::create(std::vector<COW<DB::IColumn>::immutable_ptr<DB::IColumn>, std::allocator<COW<DB::IColumn>::immutable_ptr<DB::IColumn>>> const&) @ 0x000000003387426b\r\n6. DB::(anonymous namespace)::FunctionIf::executeTuple(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0x0000000031fe9f6e\r\n7. DB::(anonymous namespace)::FunctionIf::executeImpl(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0x0000000031fddabb\r\n8. DB::IFunction::executeImplDryRun(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0x00000000192b02e6\r\n9. DB::FunctionToExecutableFunctionAdaptor::executeDryRunImpl(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0x000000001a8a5d39\r\n10. DB::IExecutableFunction::executeWithoutLowCardinalityColumns(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x000000002f5edbe3\r\n11. DB::IExecutableFunction::executeWithoutSparseColumns(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x000000002f5ef749\r\n12. DB::IExecutableFunction::execute(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x000000002f5f1028\r\n13. src/Interpreters/ActionsDAG.cpp:734: DB::ActionsDAG::evaluatePartialResult(std::unordered_map<DB::ActionsDAG::Node const*, DB::ColumnWithTypeAndName, std::hash<DB::ActionsDAG::Node const*>, std::equal_to<DB::ActionsDAG::Node const*>, std::allocator<std::pair<DB::ActionsDAG::Node const* const, DB::ColumnWithTypeAndName>>>&, std::vector<DB::ActionsDAG::Node const*, std::allocator<DB::ActionsDAG::Node const*>> const&, unsigned long, bool) @ 0x00000000311b4420\r\n14. src/Interpreters/ActionsDAG.cpp:814: DB::ActionsDAG::updateHeader(DB::Block const&) const @ 0x00000000311b26db\r\n15. src/Processors/Transforms/ExpressionTransform.cpp:10: DB::ExpressionTransform::transformHeader(DB::Block const&, DB::ActionsDAG const&) @ 0x00000000359eec7f\r\n16. src/Processors/QueryPlan/ExpressionStep.cpp:31: DB::ExpressionStep::ExpressionStep(DB::Block const&, DB::ActionsDAG) @ 0x0000000035d5e626\r\n17. ./contrib/llvm-project/libcxx/include/__memory/unique_ptr.h:714: std::__unique_if<DB::ExpressionStep>::__unique_single std::make_unique[abi:v15007]<DB::ExpressionStep, DB::Block const&, DB::ActionsDAG>(DB::Block const&, DB::ActionsDAG&&) @ 0x000000002fccace7\r\n18. src/Interpreters/MutationsInterpreter.cpp:1332: DB::MutationsInterpreter::addStreamsForLaterStages(std::vector<DB::MutationsInterpreter::Stage, std::allocator<DB::MutationsInterpreter::Stage>> const&, DB::QueryPlan&) const @ 0x000000003268ef84\r\n19. src/Interpreters/MutationsInterpreter.cpp:1392: DB::MutationsInterpreter::validate() @ 0x00000000326932b5\r\n20. src/Interpreters/InterpreterAlterQuery.cpp:238: DB::InterpreterAlterQuery::executeToTable(DB::ASTAlterQuery const&) @ 0x0000000031e82a48\r\n21. src/Interpreters/InterpreterAlterQuery.cpp:80: DB::InterpreterAlterQuery::execute() @ 0x0000000031e7f30a\r\n22. src/Interpreters/executeQuery.cpp:1397: DB::executeQueryImpl(char const*, char const*, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum, DB::ReadBuffer*) @ 0x0000000032ac11a6\r\n23. src/Interpreters/executeQuery.cpp:1564: DB::executeQuery(String const&, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum) @ 0x0000000032ab9db3\r\n24. src/Server/TCPHandler.cpp:595: DB::TCPHandler::runImpl() @ 0x0000000035238ca6\r\n25. src/Server/TCPHandler.cpp:2528: DB::TCPHandler::run() @ 0x000000003526e796\r\n26. base/poco/Net/src/TCPServerConnection.cpp:43: Poco::Net::TCPServerConnection::start() @ 0x0000000038e121b8\r\n27. base/poco/Net/src/TCPServerDispatcher.cpp:115: Poco::Net::TCPServerDispatcher::run() @ 0x0000000038e132f2\r\n28. base/poco/Foundation/src/ThreadPool.cpp:205: Poco::PooledThread::run() @ 0x0000000038d65ce1\r\n29. ./base/poco/Foundation/src/Thread_POSIX.cpp:335: Poco::ThreadImpl::runnableEntry(void*) @ 0x0000000038d60caf\r\n30. ? @ 0x00007ffff7ca1e2e\r\n31. ? @ 0x00007ffff7d33a4c\r\n```\r\n\n",
  "hints_text": "@amosbird PTAL\ud83e\udd7a",
  "created_at": "2024-11-09T05:07:07Z"
}