{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 70853,
  "instance_id": "ClickHouse__ClickHouse-70853",
  "issue_numbers": [
    "69732"
  ],
  "base_commit": "f41d604f28f8937fb5f2445025141d5e5ad47c77",
  "patch": "diff --git a/src/AggregateFunctions/IAggregateFunction.cpp b/src/AggregateFunctions/IAggregateFunction.cpp\nindex 7da341cc5b99..4b2394d0713f 100644\n--- a/src/AggregateFunctions/IAggregateFunction.cpp\n+++ b/src/AggregateFunctions/IAggregateFunction.cpp\n@@ -10,6 +10,15 @@ DataTypePtr IAggregateFunction::getStateType() const\n     return std::make_shared<DataTypeAggregateFunction>(shared_from_this(), argument_types, parameters);\n }\n \n+DataTypePtr IAggregateFunction::getNormalizedStateType() const\n+{\n+    DataTypes normalized_argument_types;\n+    normalized_argument_types.reserve(argument_types.size());\n+    for (const auto & arg : argument_types)\n+        normalized_argument_types.emplace_back(arg->getNormalizedType());\n+    return std::make_shared<DataTypeAggregateFunction>(shared_from_this(), normalized_argument_types, parameters);\n+}\n+\n String IAggregateFunction::getDescription() const\n {\n     String description;\ndiff --git a/src/AggregateFunctions/IAggregateFunction.h b/src/AggregateFunctions/IAggregateFunction.h\nindex f8e7051d6350..4f1f53880329 100644\n--- a/src/AggregateFunctions/IAggregateFunction.h\n+++ b/src/AggregateFunctions/IAggregateFunction.h\n@@ -73,7 +73,7 @@ class IAggregateFunction : public std::enable_shared_from_this<IAggregateFunctio\n     virtual DataTypePtr getStateType() const;\n \n     /// Same as the above but normalize state types so that variants with the same binary representation will use the same type.\n-    virtual DataTypePtr getNormalizedStateType() const { return getStateType(); }\n+    virtual DataTypePtr getNormalizedStateType() const;\n \n     /// Returns true if two aggregate functions have the same state representation in memory and the same serialization,\n     /// so state of one aggregate function can be safely used with another.\ndiff --git a/src/Core/Settings.cpp b/src/Core/Settings.cpp\nindex ee7760475d95..228e5d297958 100644\n--- a/src/Core/Settings.cpp\n+++ b/src/Core/Settings.cpp\n@@ -4453,7 +4453,7 @@ Optimize GROUP BY when all keys in block are constant\n     M(Bool, legacy_column_name_of_tuple_literal, false, R\"(\n List all names of element of large tuple literals in their column names instead of hash. This settings exists only for compatibility reasons. It makes sense to set to 'true', while doing rolling update of cluster from version lower than 21.7 to higher.\n )\", 0) \\\n-    M(Bool, enable_named_columns_in_function_tuple, false, R\"(\n+    M(Bool, enable_named_columns_in_function_tuple, true, R\"(\n Generate named tuples in function tuple() when all names are unique and can be treated as unquoted identifiers.\n Beware that this setting might currently result in broken queries. It's not recommended to use in production\n )\", 0) \\\ndiff --git a/src/Core/SettingsChangesHistory.cpp b/src/Core/SettingsChangesHistory.cpp\nindex 5092e00aece6..66fed9120d2b 100644\n--- a/src/Core/SettingsChangesHistory.cpp\n+++ b/src/Core/SettingsChangesHistory.cpp\n@@ -83,7 +83,7 @@ static std::initializer_list<std::pair<ClickHouseVersion, SettingsChangesHistory\n             {\"input_format_binary_read_json_as_string\", false, false, \"Add new setting to read values of JSON type as JSON string in RowBinary input format\"},\n             {\"min_free_disk_bytes_to_perform_insert\", 0, 0, \"New setting.\"},\n             {\"min_free_disk_ratio_to_perform_insert\", 0.0, 0.0, \"New setting.\"},\n-            {\"enable_named_columns_in_function_tuple\", false, false, \"Force disable the setting since it breaks queries\"},\n+            {\"enable_named_columns_in_function_tuple\", false, true, \"Re-enable the setting since all known bugs are fixed\"},\n             {\"cloud_mode_database_engine\", 1, 1, \"A setting for ClickHouse Cloud\"},\n             {\"allow_experimental_shared_set_join\", 1, 1, \"A setting for ClickHouse Cloud\"},\n             {\"read_through_distributed_cache\", 0, 0, \"A setting for ClickHouse Cloud\"},\ndiff --git a/src/DataTypes/DataTypeArray.h b/src/DataTypes/DataTypeArray.h\nindex b242d871c367..f9ed734da0f9 100644\n--- a/src/DataTypes/DataTypeArray.h\n+++ b/src/DataTypes/DataTypeArray.h\n@@ -47,8 +47,8 @@ class DataTypeArray final : public IDataType\n \n     Field getDefault() const override;\n \n+    DataTypePtr getNormalizedType() const override { return std::make_shared<DataTypeArray>(nested->getNormalizedType()); }\n     bool equals(const IDataType & rhs) const override;\n-\n     bool isParametric() const override { return true; }\n     bool haveSubtypes() const override { return true; }\n     bool cannotBeStoredInTables() const override { return nested->cannotBeStoredInTables(); }\ndiff --git a/src/DataTypes/DataTypeMap.h b/src/DataTypes/DataTypeMap.h\nindex c506591ba798..1df93dc2b8bb 100644\n--- a/src/DataTypes/DataTypeMap.h\n+++ b/src/DataTypes/DataTypeMap.h\n@@ -43,7 +43,10 @@ class DataTypeMap final : public IDataType\n     bool isParametric() const override { return true; }\n     bool haveSubtypes() const override { return true; }\n     bool hasDynamicSubcolumnsDeprecated() const override { return nested->hasDynamicSubcolumnsDeprecated(); }\n-\n+    DataTypePtr getNormalizedType() const override\n+    {\n+        return std::make_shared<DataTypeMap>(key_type->getNormalizedType(), value_type->getNormalizedType());\n+    }\n     const DataTypePtr & getKeyType() const { return key_type; }\n     const DataTypePtr & getValueType() const { return value_type; }\n     DataTypes getKeyValueTypes() const { return {key_type, value_type}; }\ndiff --git a/src/DataTypes/DataTypeTuple.cpp b/src/DataTypes/DataTypeTuple.cpp\nindex bceb0f844c88..1267338acb95 100644\n--- a/src/DataTypes/DataTypeTuple.cpp\n+++ b/src/DataTypes/DataTypeTuple.cpp\n@@ -133,6 +133,14 @@ std::string DataTypeTuple::doGetPrettyName(size_t indent) const\n     return s.str();\n }\n \n+DataTypePtr DataTypeTuple::getNormalizedType() const\n+{\n+    DataTypes normalized_elems;\n+    normalized_elems.reserve(elems.size());\n+    for (const auto & elem : elems)\n+        normalized_elems.emplace_back(elem->getNormalizedType());\n+    return std::make_shared<DataTypeTuple>(normalized_elems);\n+}\n \n static inline IColumn & extractElementColumn(IColumn & column, size_t idx)\n {\ndiff --git a/src/DataTypes/DataTypeTuple.h b/src/DataTypes/DataTypeTuple.h\nindex fd00fce5a178..d7c97018e2e4 100644\n--- a/src/DataTypes/DataTypeTuple.h\n+++ b/src/DataTypes/DataTypeTuple.h\n@@ -61,6 +61,7 @@ class DataTypeTuple final : public IDataType\n     MutableSerializationInfoPtr createSerializationInfo(const SerializationInfoSettings & settings) const override;\n     SerializationInfoPtr getSerializationInfo(const IColumn & column) const override;\n \n+    DataTypePtr getNormalizedType() const override;\n     const DataTypePtr & getElement(size_t i) const { return elems[i]; }\n     const DataTypes & getElements() const { return elems; }\n     const Strings & getElementNames() const { return names; }\ndiff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h\nindex 2d1e1b9bc76c..33eddf8e9b89 100644\n--- a/src/DataTypes/IDataType.h\n+++ b/src/DataTypes/IDataType.h\n@@ -88,6 +88,15 @@ class IDataType : private boost::noncopyable, public std::enable_shared_from_thi\n \n     DataTypePtr getPtr() const { return shared_from_this(); }\n \n+    /// Returns the normalized form of the current type, currently handling the\n+    /// conversion of named tuples to unnamed tuples.\n+    ///\n+    /// This is useful for converting aggregate states into a normalized form with\n+    /// normalized argument types. E.g, `AggregateFunction(uniq, Tuple(a int, b int))`\n+    /// should be convertible to `AggregateFunction(uniq, Tuple(int, int))`, as both\n+    /// have same memory layouts for state representation and the same serialization.\n+    virtual DataTypePtr getNormalizedType() const { return shared_from_this(); }\n+\n     /// Name of data type family (example: FixedString, Array).\n     virtual const char * getFamilyName() const = 0;\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03254_normalize_aggregate_states_with_named_tuple_args.reference b/tests/queries/0_stateless/03254_normalize_aggregate_states_with_named_tuple_args.reference\nnew file mode 100644\nindex 000000000000..1affee4ff195\n--- /dev/null\n+++ b/tests/queries/0_stateless/03254_normalize_aggregate_states_with_named_tuple_args.reference\n@@ -0,0 +1,3 @@\n+{\"finalizeAggregation(x)\":\"1\",\"finalizeAggregation(y)\":\"1\",\"finalizeAggregation(z)\":\"1\"}\n+1\t2\n+2\t1\ndiff --git a/tests/queries/0_stateless/03254_normalize_aggregate_states_with_named_tuple_args.sql b/tests/queries/0_stateless/03254_normalize_aggregate_states_with_named_tuple_args.sql\nnew file mode 100644\nindex 000000000000..29eb6549f042\n--- /dev/null\n+++ b/tests/queries/0_stateless/03254_normalize_aggregate_states_with_named_tuple_args.sql\n@@ -0,0 +1,33 @@\n+SET enable_analyzer = 1;\n+SET enable_named_columns_in_function_tuple = 1;\n+\n+SELECT\n+    * APPLY finalizeAggregation\n+FROM\n+(\n+    WITH\n+        (1, 2)::Tuple(a int, b int) AS nt\n+    SELECT\n+        uniqState(nt)::AggregateFunction(uniq, Tuple(int, int)) x,\n+        uniqState([nt])::AggregateFunction(uniq, Array(Tuple(int, int))) y,\n+        uniqState(map(nt, nt))::AggregateFunction(uniq, Map(Tuple(int, int), Tuple(int, int))) z\n+)\n+FORMAT JSONEachRow;\n+\n+DROP TABLE IF EXISTS users;\n+DROP TABLE IF EXISTS users2;\n+DROP TABLE IF EXISTS test_mv;\n+\n+CREATE TABLE users (id UInt8, city String, name String) ENGINE=Memory;\n+CREATE TABLE users2 (id UInt8, city_name_uniq AggregateFunction(uniq, Tuple(String,String))) ENGINE=AggregatingMergeTree() ORDER BY (id);\n+CREATE MATERIALIZED VIEW test_mv TO users2 AS SELECT id, uniqState((city, name)) AS city_name_uniq FROM users GROUP BY id;\n+\n+INSERT INTO users VALUES (1, 'London', 'John');\n+INSERT INTO users VALUES (1, 'Berlin', 'Ksenia');\n+INSERT INTO users VALUES (2, 'Paris', 'Alice');\n+\n+SELECT id, uniqMerge(city_name_uniq) FROM users2 GROUP BY id ORDER BY id;\n+\n+DROP TABLE IF EXISTS users;\n+DROP TABLE IF EXISTS users2;\n+DROP TABLE IF EXISTS test_mv;\n",
  "problem_statement": "DB::Exception: Conversion from AggregateFunction(uniq, Tuple(city String, name String))\n\r\n24.6.6.6 https://fiddle.clickhouse.com/3a334edc-0f5e-49c0-9870-9a5f1c9b29b6\r\n\r\n```\r\n---- users:\r\n1\tLondon\tJohn\r\n2\tParis\tAlice\r\n1\tBerlin\tKsenia\r\n---- users2:\r\n1\t2\r\n2\t1\r\n\r\n```\r\n\r\n24.7.6.8 https://fiddle.clickhouse.com/bfbeec0c-3c7b-4170-9e29-3e1388ba8ffe\r\n\r\n```\r\n DB::Exception: Conversion from AggregateFunction(uniq, Tuple(city String, name String)) to\r\n AggregateFunction(uniq, Tuple(String, String)) is not supported: while converting source \r\ncolumn city_name_uniq to destination column city_name_uniq. (CANNOT_CONVERT_TYPE)\r\n```\r\n\r\nhttps://github.com/ClickHouse/ClickHouse/pull/54881\r\n\n",
  "hints_text": "The issue should be investigated, but as a workaround you can disable by setting `enable_named_columns_in_function_tuple=0`\nThat will be easy to fix - we should declare AggregateFunction types different only by names of tuple arguments as equivalent.",
  "created_at": "2024-10-19T03:36:37Z",
  "modified_files": [
    "src/AggregateFunctions/IAggregateFunction.cpp",
    "src/AggregateFunctions/IAggregateFunction.h",
    "src/Core/Settings.cpp",
    "src/Core/SettingsChangesHistory.cpp",
    "src/DataTypes/DataTypeArray.h",
    "src/DataTypes/DataTypeMap.h",
    "src/DataTypes/DataTypeTuple.cpp",
    "src/DataTypes/DataTypeTuple.h",
    "src/DataTypes/IDataType.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03254_normalize_aggregate_states_with_named_tuple_args.reference",
    "b/tests/queries/0_stateless/03254_normalize_aggregate_states_with_named_tuple_args.sql"
  ]
}