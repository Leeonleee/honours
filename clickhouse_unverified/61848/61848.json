{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 61848,
  "instance_id": "ClickHouse__ClickHouse-61848",
  "issue_numbers": [
    "58476"
  ],
  "base_commit": "24261476c4b8d19f3a8431d41b89e67b4590542d",
  "patch": "diff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 55e4653b9c5d..170fd4e9ca01 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -868,6 +868,8 @@ class IColumn;\n     M(Bool, use_variant_as_common_type, false, \"Use Variant as a result type for if/multiIf in case when there is no common type for arguments\", 0) \\\n     M(Bool, enable_order_by_all, true, \"Enable sorting expression ORDER BY ALL.\", 0) \\\n     M(Bool, traverse_shadow_remote_data_paths, false, \"Traverse shadow directory when query system.remote_data_paths\", 0) \\\n+    M(Bool, geo_distance_returns_float64_on_float64_arguments, true, \"If all four arguments to `geoDistance`, `greatCircleDistance`, `greatCircleAngle` functions are Float64, return Float64 and use double precision for internal calculations. In previous ClickHouse versions, the functions always returned Float32.\", 0) \\\n+    M(Bool, allow_get_client_http_header, false, \"Allow to use the function `getClientHTTPHeader` which lets to obtain a value of an the current HTTP request's header. It is not enabled by default for security reasons, because some headers, such as `Cookie`, could contain sensitive info. Note that the `X-ClickHouse-*` and `Authentication` headers are always restricted and cannot be obtained with this function.\", 0) \\\n     \\\n     /** Experimental functions */ \\\n     M(Bool, allow_experimental_materialized_postgresql_table, false, \"Allows to use the MaterializedPostgreSQL table engine. Disabled by default, because this feature is experimental\", 0) \\\n@@ -902,7 +904,6 @@ class IColumn;\n     M(Int64, ignore_cold_parts_seconds, 0, \"Only available in ClickHouse Cloud. Exclude new data parts from SELECT queries until they're either pre-warmed (see cache_populated_by_fetch) or this many seconds old. Only for Replicated-/SharedMergeTree.\", 0) \\\n     M(Int64, prefer_warmed_unmerged_parts_seconds, 0, \"Only available in ClickHouse Cloud. If a merged part is less than this many seconds old and is not pre-warmed (see cache_populated_by_fetch), but all its source parts are available and pre-warmed, SELECT queries will read from those parts instead. Only for ReplicatedMergeTree. Note that this only checks whether CacheWarmer processed the part; if the part was fetched into cache by something else, it'll still be considered cold until CacheWarmer gets to it; if it was warmed, then evicted from cache, it'll still be considered warm.\", 0) \\\n     M(Bool, iceberg_engine_ignore_schema_evolution, false, \"Ignore schema evolution in Iceberg table engine and read all data using latest schema saved on table creation. Note that it can lead to incorrect result\", 0) \\\n-    M(Bool, allow_get_client_http_header, false, \"Allow to use the function `getClientHTTPHeader` which lets to obtain a value of an the current HTTP request's header. It is not enabled by default for security reasons, because some headers, such as `Cookie`, could contain sensitive info. Note that the `X-ClickHouse-*` and `Authentication` headers are always restricted and cannot be obtained with this function.\", 0) \\\n \n // End of COMMON_SETTINGS\n // Please add settings related to formats into the FORMAT_FACTORY_SETTINGS, move obsolete settings to OBSOLETE_SETTINGS and obsolete format settings to OBSOLETE_FORMAT_SETTINGS.\ndiff --git a/src/Core/SettingsChangesHistory.h b/src/Core/SettingsChangesHistory.h\nindex 530c5796e5ed..6b31e9cd249c 100644\n--- a/src/Core/SettingsChangesHistory.h\n+++ b/src/Core/SettingsChangesHistory.h\n@@ -115,6 +115,7 @@ static std::map<ClickHouseVersion, SettingsChangesHistory::SettingsChanges> sett\n               {\"output_format_parquet_compression_method\", \"lz4\", \"zstd\", \"Parquet/ORC/Arrow support many compression methods, including lz4 and zstd. ClickHouse supports each and every compression method. Some inferior tools, such as 'duckdb', lack support for the faster `lz4` compression method, that's why we set zstd by default.\"},\n               {\"output_format_orc_compression_method\", \"lz4\", \"zstd\", \"Parquet/ORC/Arrow support many compression methods, including lz4 and zstd. ClickHouse supports each and every compression method. Some inferior tools, such as 'duckdb', lack support for the faster `lz4` compression method, that's why we set zstd by default.\"},\n               {\"output_format_pretty_highlight_digit_groups\", false, true, \"If enabled and if output is a terminal, highlight every digit corresponding to the number of thousands, millions, etc. with underline.\"},\n+              {\"geo_distance_returns_float64_on_float64_arguments\", false, true, \"Increase the default precision.\"},\n               {\"azure_max_inflight_parts_for_one_file\", 20, 20, \"The maximum number of a concurrent loaded parts in multipart upload request. 0 means unlimited.\"},\n               {\"azure_strict_upload_part_size\", 0, 0, \"The exact size of part to upload during multipart upload to Azure blob storage.\"},\n               {\"azure_min_upload_part_size\", 16*1024*1024, 16*1024*1024, \"The minimum size of part to upload during multipart upload to Azure blob storage.\"},\ndiff --git a/src/Functions/greatCircleDistance.cpp b/src/Functions/greatCircleDistance.cpp\nindex d1d1a1011871..01184f74b13e 100644\n--- a/src/Functions/greatCircleDistance.cpp\n+++ b/src/Functions/greatCircleDistance.cpp\n@@ -7,7 +7,6 @@\n #include <Functions/PerformanceAdaptors.h>\n #include <Interpreters/castColumn.h>\n #include <Common/TargetSpecific.h>\n-#include <base/range.h>\n #include <cmath>\n #include <numbers>\n \n@@ -42,140 +41,124 @@ namespace ErrorCodes\n namespace\n {\n \n-constexpr double PI = std::numbers::pi_v<double>;\n-constexpr float PI_F = std::numbers::pi_v<float>;\n-\n-constexpr float RAD_IN_DEG = static_cast<float>(PI / 180.0);\n-constexpr float RAD_IN_DEG_HALF = static_cast<float>(PI / 360.0);\n+enum class Method\n+{\n+    SPHERE_DEGREES,\n+    SPHERE_METERS,\n+    WGS84_METERS,\n+};\n \n-constexpr size_t COS_LUT_SIZE = 1024; // maxerr 0.00063%\n-constexpr float COS_LUT_SIZE_F = 1024.0f; // maxerr 0.00063%\n constexpr size_t ASIN_SQRT_LUT_SIZE = 512;\n+constexpr size_t COS_LUT_SIZE = 1024; // maxerr 0.00063%\n constexpr size_t METRIC_LUT_SIZE = 1024;\n \n-/** Earth radius in meters using WGS84 authalic radius.\n-  * We use this value to be consistent with H3 library.\n-  */\n-constexpr float EARTH_RADIUS = 6371007.180918475f;\n-constexpr float EARTH_DIAMETER = 2 * EARTH_RADIUS;\n-\n-\n-float cos_lut[COS_LUT_SIZE + 1];       /// cos(x) table\n-float asin_sqrt_lut[ASIN_SQRT_LUT_SIZE + 1]; /// asin(sqrt(x)) * earth_diameter table\n-\n-float sphere_metric_lut[METRIC_LUT_SIZE + 1]; /// sphere metric, unitless: the distance in degrees for one degree across longitude depending on latitude\n-float sphere_metric_meters_lut[METRIC_LUT_SIZE + 1]; /// sphere metric: the distance in meters for one degree across longitude depending on latitude\n-float wgs84_metric_meters_lut[2 * (METRIC_LUT_SIZE + 1)]; /// ellipsoid metric: the distance in meters across one degree latitude/longitude depending on latitude\n-\n-\n-inline double sqr(double v)\n-{\n-    return v * v;\n-}\n+/// Earth radius in meters using WGS84 authalic radius.\n+/// We use this value to be consistent with H3 library.\n+constexpr double EARTH_RADIUS = 6371007.180918475;\n+constexpr double EARTH_DIAMETER = 2.0 * EARTH_RADIUS;\n+constexpr double PI = std::numbers::pi_v<double>;\n \n-inline float sqrf(float v)\n-{\n-    return v * v;\n-}\n+template <typename T>\n+T sqr(T v) { return v * v; }\n \n-void geodistInit()\n+template <typename T>\n+struct Impl\n {\n-    for (size_t i = 0; i <= COS_LUT_SIZE; ++i)\n-        cos_lut[i] = static_cast<float>(cos(2 * PI * i / COS_LUT_SIZE)); // [0, 2 * pi] -> [0, COS_LUT_SIZE]\n+    T cos_lut[COS_LUT_SIZE + 1];       /// cos(x) table\n+    T asin_sqrt_lut[ASIN_SQRT_LUT_SIZE + 1]; /// asin(sqrt(x)) * earth_diameter table\n+    T sphere_metric_lut[METRIC_LUT_SIZE + 1]; /// sphere metric, unitless: the distance in degrees for one degree across longitude depending on latitude\n+    T sphere_metric_meters_lut[METRIC_LUT_SIZE + 1]; /// sphere metric: the distance in meters for one degree across longitude depending on latitude\n+    T wgs84_metric_meters_lut[2 * (METRIC_LUT_SIZE + 1)]; /// ellipsoid metric: the distance in meters across one degree latitude/longitude depending on latitude\n \n-    for (size_t i = 0; i <= ASIN_SQRT_LUT_SIZE; ++i)\n-        asin_sqrt_lut[i] = static_cast<float>(asin(\n-            sqrt(static_cast<double>(i) / ASIN_SQRT_LUT_SIZE))); // [0, 1] -> [0, ASIN_SQRT_LUT_SIZE]\n-\n-    for (size_t i = 0; i <= METRIC_LUT_SIZE; ++i)\n+    Impl()\n     {\n-        double latitude = i * (PI / METRIC_LUT_SIZE) - PI * 0.5; // [-pi / 2, pi / 2] -> [0, METRIC_LUT_SIZE]\n+        for (size_t i = 0; i <= COS_LUT_SIZE; ++i)\n+            cos_lut[i] = T(std::cos(2 * PI * static_cast<double>(i) / COS_LUT_SIZE)); // [0, 2 * pi] -> [0, COS_LUT_SIZE]\n \n-        /// Squared metric coefficients (for the distance in meters) on a tangent plane, for latitude and longitude (in degrees),\n-        /// depending on the latitude (in radians).\n+        for (size_t i = 0; i <= ASIN_SQRT_LUT_SIZE; ++i)\n+            asin_sqrt_lut[i] = T(std::asin(std::sqrt(static_cast<double>(i) / ASIN_SQRT_LUT_SIZE))); // [0, 1] -> [0, ASIN_SQRT_LUT_SIZE]\n \n-        /// https://github.com/mapbox/cheap-ruler/blob/master/index.js#L67\n-        wgs84_metric_meters_lut[i * 2] = static_cast<float>(sqr(111132.09 - 566.05 * cos(2 * latitude) + 1.20 * cos(4 * latitude)));\n-        wgs84_metric_meters_lut[i * 2 + 1] = static_cast<float>(sqr(111415.13 * cos(latitude) - 94.55 * cos(3 * latitude) + 0.12 * cos(5 * latitude)));\n+        for (size_t i = 0; i <= METRIC_LUT_SIZE; ++i)\n+        {\n+            double latitude = i * (PI / METRIC_LUT_SIZE) - PI * 0.5; // [-pi / 2, pi / 2] -> [0, METRIC_LUT_SIZE]\n \n-        sphere_metric_meters_lut[i] = static_cast<float>(sqr((EARTH_DIAMETER * PI / 360) * cos(latitude)));\n+            /// Squared metric coefficients (for the distance in meters) on a tangent plane, for latitude and longitude (in degrees),\n+            /// depending on the latitude (in radians).\n \n-        sphere_metric_lut[i] = static_cast<float>(sqr(cos(latitude)));\n-    }\n-}\n+            /// https://github.com/mapbox/cheap-ruler/blob/master/index.js#L67\n+            wgs84_metric_meters_lut[i * 2] = T(sqr(111132.09 - 566.05 * std::cos(2.0 * latitude) + 1.20 * std::cos(4.0 * latitude)));\n+            wgs84_metric_meters_lut[i * 2 + 1] = T(sqr(111415.13 * std::cos(latitude) - 94.55 * std::cos(3.0 * latitude) + 0.12 * std::cos(5.0 * latitude)));\n+            sphere_metric_meters_lut[i] = T(sqr((EARTH_DIAMETER * PI / 360) * std::cos(latitude)));\n \n-inline NO_SANITIZE_UNDEFINED size_t floatToIndex(float x)\n-{\n-    /// Implementation specific behaviour on overflow or infinite value.\n-    return static_cast<size_t>(x);\n-}\n-\n-inline float geodistDegDiff(float f)\n-{\n-    f = fabsf(f);\n-    if (f > 180)\n-        f = 360 - f;\n-    return f;\n-}\n-\n-inline float geodistFastCos(float x)\n-{\n-    float y = fabsf(x) * (COS_LUT_SIZE_F / PI_F / 2.0f);\n-    size_t i = floatToIndex(y);\n-    y -= i;\n-    i &= (COS_LUT_SIZE - 1);\n-    return cos_lut[i] + (cos_lut[i + 1] - cos_lut[i]) * y;\n-}\n+            sphere_metric_lut[i] = T(sqr(std::cos(latitude)));\n+        }\n+    }\n \n-inline float geodistFastSin(float x)\n-{\n-    float y = fabsf(x) * (COS_LUT_SIZE_F / PI_F / 2.0f);\n-    size_t i = floatToIndex(y);\n-    y -= i;\n-    i = (i - COS_LUT_SIZE / 4) & (COS_LUT_SIZE - 1); // cos(x - pi / 2) = sin(x), costable / 4 = pi / 2\n-    return cos_lut[i] + (cos_lut[i + 1] - cos_lut[i]) * y;\n-}\n+    static inline NO_SANITIZE_UNDEFINED size_t toIndex(T x)\n+    {\n+        /// Implementation specific behaviour on overflow or infinite value.\n+        return static_cast<size_t>(x);\n+    }\n \n-/// fast implementation of asin(sqrt(x))\n-/// max error in floats 0.00369%, in doubles 0.00072%\n-inline float geodistFastAsinSqrt(float x)\n-{\n-    if (x < 0.122f)\n+    static inline T degDiff(T f)\n     {\n-        // distance under 4546 km, Taylor error under 0.00072%\n-        float y = sqrtf(x);\n-        return y + x * y * 0.166666666666666f + x * x * y * 0.075f + x * x * x * y * 0.044642857142857f;\n+        f = std::abs(f);\n+        if (f > 180)\n+            f = 360 - f;\n+        return f;\n     }\n-    if (x < 0.948f)\n+\n+    inline T fastCos(T x)\n     {\n-        // distance under 17083 km, 512-entry LUT error under 0.00072%\n-        x *= ASIN_SQRT_LUT_SIZE;\n-        size_t i = floatToIndex(x);\n-        return asin_sqrt_lut[i] + (asin_sqrt_lut[i + 1] - asin_sqrt_lut[i]) * (x - i);\n+        T y = std::abs(x) * (T(COS_LUT_SIZE) / T(PI) / T(2.0));\n+        size_t i = toIndex(y);\n+        y -= i;\n+        i &= (COS_LUT_SIZE - 1);\n+        return cos_lut[i] + (cos_lut[i + 1] - cos_lut[i]) * y;\n     }\n-    return asinf(sqrtf(x)); // distance over 17083 km, just compute exact\n-}\n \n+    inline T fastSin(T x)\n+    {\n+        T y = std::abs(x) * (T(COS_LUT_SIZE) / T(PI) / T(2.0));\n+        size_t i = toIndex(y);\n+        y -= i;\n+        i = (i - COS_LUT_SIZE / 4) & (COS_LUT_SIZE - 1); // cos(x - pi / 2) = sin(x), costable / 4 = pi / 2\n+        return cos_lut[i] + (cos_lut[i + 1] - cos_lut[i]) * y;\n+    }\n \n-enum class Method\n-{\n-    SPHERE_DEGREES,\n-    SPHERE_METERS,\n-    WGS84_METERS,\n+    /// fast implementation of asin(sqrt(x))\n+    /// max error in floats 0.00369%, in doubles 0.00072%\n+    inline T fastAsinSqrt(T x)\n+    {\n+        if (x < T(0.122))\n+        {\n+            // distance under 4546 km, Taylor error under 0.00072%\n+            T y = std::sqrt(x);\n+            return y + x * y * T(0.166666666666666) + x * x * y * T(0.075) + x * x * x * y * T(0.044642857142857);\n+        }\n+        if (x < T(0.948))\n+        {\n+            // distance under 17083 km, 512-entry LUT error under 0.00072%\n+            x *= ASIN_SQRT_LUT_SIZE;\n+            size_t i = toIndex(x);\n+            return asin_sqrt_lut[i] + (asin_sqrt_lut[i + 1] - asin_sqrt_lut[i]) * (x - i);\n+        }\n+        return std::asin(std::sqrt(x)); /// distance is over 17083 km, just compute exact\n+    }\n };\n \n-}\n+template <typename T> Impl<T> impl;\n \n DECLARE_MULTITARGET_CODE(\n \n namespace\n {\n \n-template <Method method>\n-float distance(float lon1deg, float lat1deg, float lon2deg, float lat2deg)\n+template <Method method, typename T>\n+T distance(T lon1deg, T lat1deg, T lon2deg, T lat2deg)\n {\n-    float lat_diff = geodistDegDiff(lat1deg - lat2deg);\n-    float lon_diff = geodistDegDiff(lon1deg - lon2deg);\n+    T lat_diff = impl<T>.degDiff(lat1deg - lat2deg);\n+    T lon_diff = impl<T>.degDiff(lon1deg - lon2deg);\n \n     if (lon_diff < 13)\n     {\n@@ -187,51 +170,54 @@ float distance(float lon1deg, float lat1deg, float lon2deg, float lat2deg)\n         ///  (Remember how a plane flies from Amsterdam to New York)\n         /// But if longitude is close but latitude is different enough, there is no difference between meridian and great circle line.\n \n-        float latitude_midpoint = (lat1deg + lat2deg + 180) * METRIC_LUT_SIZE / 360; // [-90, 90] degrees -> [0, METRIC_LUT_SIZE] indexes\n-        size_t latitude_midpoint_index = floatToIndex(latitude_midpoint) & (METRIC_LUT_SIZE - 1);\n+        T latitude_midpoint = (lat1deg + lat2deg + 180) * METRIC_LUT_SIZE / 360; // [-90, 90] degrees -> [0, METRIC_LUT_SIZE] indexes\n+        size_t latitude_midpoint_index = impl<T>.toIndex(latitude_midpoint) & (METRIC_LUT_SIZE - 1);\n \n         /// This is linear interpolation between two table items at index \"latitude_midpoint_index\" and \"latitude_midpoint_index + 1\".\n \n-        float k_lat{};\n-        float k_lon{};\n+        T k_lat{};\n+        T k_lon{};\n \n         if constexpr (method == Method::SPHERE_DEGREES)\n         {\n             k_lat = 1;\n \n-            k_lon = sphere_metric_lut[latitude_midpoint_index]\n-                + (sphere_metric_lut[latitude_midpoint_index + 1] - sphere_metric_lut[latitude_midpoint_index]) * (latitude_midpoint - latitude_midpoint_index);\n+            k_lon = impl<T>.sphere_metric_lut[latitude_midpoint_index]\n+                + (impl<T>.sphere_metric_lut[latitude_midpoint_index + 1] - impl<T>.sphere_metric_lut[latitude_midpoint_index]) * (latitude_midpoint - latitude_midpoint_index);\n         }\n         else if constexpr (method == Method::SPHERE_METERS)\n         {\n-            k_lat = sqrf(EARTH_DIAMETER * PI_F / 360.0f);\n+            k_lat = sqr(T(EARTH_DIAMETER) * T(PI) / T(360.0));\n \n-            k_lon = sphere_metric_meters_lut[latitude_midpoint_index]\n-                + (sphere_metric_meters_lut[latitude_midpoint_index + 1] - sphere_metric_meters_lut[latitude_midpoint_index]) * (latitude_midpoint - latitude_midpoint_index);\n+            k_lon = impl<T>.sphere_metric_meters_lut[latitude_midpoint_index]\n+                + (impl<T>.sphere_metric_meters_lut[latitude_midpoint_index + 1] - impl<T>.sphere_metric_meters_lut[latitude_midpoint_index]) * (latitude_midpoint - latitude_midpoint_index);\n         }\n         else if constexpr (method == Method::WGS84_METERS)\n         {\n-            k_lat = wgs84_metric_meters_lut[latitude_midpoint_index * 2]\n-                + (wgs84_metric_meters_lut[(latitude_midpoint_index + 1) * 2] - wgs84_metric_meters_lut[latitude_midpoint_index * 2]) * (latitude_midpoint - latitude_midpoint_index);\n+            k_lat = impl<T>.wgs84_metric_meters_lut[latitude_midpoint_index * 2]\n+                + (impl<T>.wgs84_metric_meters_lut[(latitude_midpoint_index + 1) * 2] - impl<T>.wgs84_metric_meters_lut[latitude_midpoint_index * 2]) * (latitude_midpoint - latitude_midpoint_index);\n \n-            k_lon = wgs84_metric_meters_lut[latitude_midpoint_index * 2 + 1]\n-                + (wgs84_metric_meters_lut[(latitude_midpoint_index + 1) * 2 + 1] - wgs84_metric_meters_lut[latitude_midpoint_index * 2 + 1]) * (latitude_midpoint - latitude_midpoint_index);\n+            k_lon = impl<T>.wgs84_metric_meters_lut[latitude_midpoint_index * 2 + 1]\n+                + (impl<T>.wgs84_metric_meters_lut[(latitude_midpoint_index + 1) * 2 + 1] - impl<T>.wgs84_metric_meters_lut[latitude_midpoint_index * 2 + 1]) * (latitude_midpoint - latitude_midpoint_index);\n         }\n \n         /// Metric on a tangent plane: it differs from Euclidean metric only by scale of coordinates.\n-        return sqrtf(k_lat * lat_diff * lat_diff + k_lon * lon_diff * lon_diff);\n+        return std::sqrt(k_lat * lat_diff * lat_diff + k_lon * lon_diff * lon_diff);\n     }\n     else\n     {\n-        // points too far away; use haversine\n+        /// Points are too far away: use Haversine.\n+\n+        static constexpr T RAD_IN_DEG = T(PI / 180.0);\n+        static constexpr T RAD_IN_DEG_HALF = T(PI / 360.0);\n \n-        float a = sqrf(geodistFastSin(lat_diff * RAD_IN_DEG_HALF))\n-            + geodistFastCos(lat1deg * RAD_IN_DEG) * geodistFastCos(lat2deg * RAD_IN_DEG) * sqrf(geodistFastSin(lon_diff * RAD_IN_DEG_HALF));\n+        T a = sqr(impl<T>.fastSin(lat_diff * RAD_IN_DEG_HALF))\n+            + impl<T>.fastCos(lat1deg * RAD_IN_DEG) * impl<T>.fastCos(lat2deg * RAD_IN_DEG) * sqr(impl<T>.fastSin(lon_diff * RAD_IN_DEG_HALF));\n \n         if constexpr (method == Method::SPHERE_DEGREES)\n-            return (360.0f / PI_F) * geodistFastAsinSqrt(a);\n+            return (T(360.0) / T(PI)) * impl<T>.fastAsinSqrt(a);\n         else\n-            return EARTH_DIAMETER * geodistFastAsinSqrt(a);\n+            return T(EARTH_DIAMETER) * impl<T>.fastAsinSqrt(a);\n     }\n }\n \n@@ -241,13 +227,24 @@ template <Method method>\n class FunctionGeoDistance : public IFunction\n {\n public:\n-    static constexpr auto name =\n-        (method == Method::SPHERE_DEGREES) ? \"greatCircleAngle\"\n-        : ((method == Method::SPHERE_METERS) ? \"greatCircleDistance\"\n-            : \"geoDistance\");\n+    explicit FunctionGeoDistance(ContextPtr context)\n+    {\n+        always_float32 = !context->getSettingsRef().geo_distance_returns_float64_on_float64_arguments;\n+    }\n \n private:\n-    String getName() const override { return name; }\n+    bool always_float32;\n+\n+    String getName() const override\n+    {\n+        if constexpr (method == Method::SPHERE_DEGREES)\n+            return \"greatCircleAngle\";\n+        if constexpr (method == Method::SPHERE_METERS)\n+            return \"greatCircleDistance\";\n+        else\n+            return \"geoDistance\";\n+    }\n+\n     size_t getNumberOfArguments() const override { return 4; }\n \n     bool useDefaultImplementationForConstants() const override { return true; }\n@@ -255,22 +252,31 @@ class FunctionGeoDistance : public IFunction\n \n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n-        for (const auto arg_idx : collections::range(0, arguments.size()))\n+        bool has_float64 = false;\n+\n+        for (size_t arg_idx = 0; arg_idx < 4; ++arg_idx)\n         {\n-            const auto * arg = arguments[arg_idx].get();\n-            if (!isNumber(WhichDataType(arg)))\n+            WhichDataType which(arguments[arg_idx]);\n+\n+            if (!isNumber(which))\n                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of argument {} of function {}. \"\n-                    \"Must be numeric\", arg->getName(), std::to_string(arg_idx + 1), getName());\n+                    \"Must be numeric\", arguments[arg_idx]->getName(), std::to_string(arg_idx + 1), getName());\n+\n+            if (which.isFloat64())\n+                has_float64 = true;\n         }\n \n-        return std::make_shared<DataTypeFloat32>();\n+        if (has_float64 && !always_float32)\n+            return std::make_shared<DataTypeFloat64>();\n+        else\n+            return std::make_shared<DataTypeFloat32>();\n     }\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n     {\n-        auto dst = ColumnVector<Float32>::create();\n-        auto & dst_data = dst->getData();\n-        dst_data.resize(input_rows_count);\n+        bool returns_float64 = WhichDataType(result_type).isFloat64();\n+\n+        auto dst = result_type->createColumn();\n \n         auto arguments_copy = arguments;\n         for (auto & argument : arguments_copy)\n@@ -280,10 +286,24 @@ class FunctionGeoDistance : public IFunction\n             argument.type = result_type;\n         }\n \n-        const auto * col_lon1 = convertArgumentColumnToFloat32(arguments_copy, 0);\n-        const auto * col_lat1 = convertArgumentColumnToFloat32(arguments_copy, 1);\n-        const auto * col_lon2 = convertArgumentColumnToFloat32(arguments_copy, 2);\n-        const auto * col_lat2 = convertArgumentColumnToFloat32(arguments_copy, 3);\n+        if (returns_float64)\n+            run<Float64>(arguments_copy, dst, input_rows_count);\n+        else\n+            run<Float32>(arguments_copy, dst, input_rows_count);\n+\n+        return dst;\n+    }\n+\n+    template <typename T>\n+    void run(const ColumnsWithTypeAndName & arguments, MutableColumnPtr & dst, size_t input_rows_count) const\n+    {\n+        const auto * col_lon1 = convertArgumentColumn<T>(arguments, 0);\n+        const auto * col_lat1 = convertArgumentColumn<T>(arguments, 1);\n+        const auto * col_lon2 = convertArgumentColumn<T>(arguments, 2);\n+        const auto * col_lat2 = convertArgumentColumn<T>(arguments, 3);\n+\n+        auto & dst_data = assert_cast<ColumnVector<T> &>(*dst).getData();\n+        dst_data.resize(input_rows_count);\n \n         for (size_t row_num = 0; row_num < input_rows_count; ++row_num)\n         {\n@@ -291,20 +311,20 @@ class FunctionGeoDistance : public IFunction\n                 col_lon1->getData()[row_num], col_lat1->getData()[row_num],\n                 col_lon2->getData()[row_num], col_lat2->getData()[row_num]);\n         }\n-\n-        return dst;\n     }\n \n-    const ColumnFloat32 * convertArgumentColumnToFloat32(const ColumnsWithTypeAndName & arguments, size_t argument_index) const\n+    template <typename T>\n+    const ColumnVector<T> * convertArgumentColumn(const ColumnsWithTypeAndName & arguments, size_t argument_index) const\n     {\n-        const auto * column_typed = checkAndGetColumn<ColumnFloat32>(arguments[argument_index].column.get());\n+        const auto * column_typed = checkAndGetColumn<ColumnVector<T>>(arguments[argument_index].column.get());\n         if (!column_typed)\n             throw Exception(\n                     ErrorCodes::ILLEGAL_COLUMN,\n-                    \"Illegal type {} of argument {} of function {}. Must be Float32.\",\n+                    \"Illegal type {} of argument {} of function {}. Must be {}.\",\n                     arguments[argument_index].type->getName(),\n                     argument_index + 1,\n-                    getName());\n+                    getName(),\n+                    TypeName<T>);\n \n         return column_typed;\n     }\n@@ -316,18 +336,19 @@ template <Method method>\n class FunctionGeoDistance : public TargetSpecific::Default::FunctionGeoDistance<method>\n {\n public:\n-    explicit FunctionGeoDistance(ContextPtr context) : selector(context)\n+    explicit FunctionGeoDistance(ContextPtr context)\n+        : TargetSpecific::Default::FunctionGeoDistance<method>(context), selector(context)\n     {\n         selector.registerImplementation<TargetArch::Default,\n-            TargetSpecific::Default::FunctionGeoDistance<method>>();\n+            TargetSpecific::Default::FunctionGeoDistance<method>>(context);\n \n     #if USE_MULTITARGET_CODE\n         selector.registerImplementation<TargetArch::AVX,\n-            TargetSpecific::AVX::FunctionGeoDistance<method>>();\n+            TargetSpecific::AVX::FunctionGeoDistance<method>>(context);\n         selector.registerImplementation<TargetArch::AVX2,\n-            TargetSpecific::AVX2::FunctionGeoDistance<method>>();\n+            TargetSpecific::AVX2::FunctionGeoDistance<method>>(context);\n         selector.registerImplementation<TargetArch::AVX512F,\n-            TargetSpecific::AVX512F::FunctionGeoDistance<method>>();\n+            TargetSpecific::AVX512F::FunctionGeoDistance<method>>(context);\n     #endif\n     }\n \n@@ -345,12 +366,13 @@ class FunctionGeoDistance : public TargetSpecific::Default::FunctionGeoDistance<\n     ImplementationSelector<IFunction> selector;\n };\n \n+}\n+\n REGISTER_FUNCTION(GeoDistance)\n {\n-    geodistInit();\n-    factory.registerFunction<FunctionGeoDistance<Method::SPHERE_DEGREES>>();\n-    factory.registerFunction<FunctionGeoDistance<Method::SPHERE_METERS>>();\n-    factory.registerFunction<FunctionGeoDistance<Method::WGS84_METERS>>();\n+    factory.registerFunction(\"greatCircleAngle\", [](ContextPtr context) { return std::make_shared<FunctionGeoDistance<Method::SPHERE_DEGREES>>(std::move(context)); });\n+    factory.registerFunction(\"greatCircleDistance\", [](ContextPtr context) { return std::make_shared<FunctionGeoDistance<Method::SPHERE_METERS>>(std::move(context)); });\n+    factory.registerFunction(\"geoDistance\", [](ContextPtr context) { return std::make_shared<FunctionGeoDistance<Method::WGS84_METERS>>(std::move(context)); });\n }\n \n }\ndiff --git a/src/IO/VarInt.h b/src/IO/VarInt.h\nindex 12a86ac55f68..9e72705341df 100644\n--- a/src/IO/VarInt.h\n+++ b/src/IO/VarInt.h\n@@ -79,7 +79,7 @@ inline char * writeVarInt(Int64 x, char * ostr)\n     return writeVarUInt(static_cast<UInt64>((x << 1) ^ (x >> 63)), ostr);\n }\n \n-namespace impl\n+namespace varint_impl\n {\n \n template <bool check_eof>\n@@ -106,8 +106,8 @@ inline void readVarUInt(UInt64 & x, ReadBuffer & istr)\n inline void readVarUInt(UInt64 & x, ReadBuffer & istr)\n {\n     if (istr.buffer().end() - istr.position() >= 10)\n-        return impl::readVarUInt<false>(x, istr);\n-    return impl::readVarUInt<true>(x, istr);\n+        return varint_impl::readVarUInt<false>(x, istr);\n+    return varint_impl::readVarUInt<true>(x, istr);\n }\n \n inline void readVarUInt(UInt64 & x, std::istream & istr)\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01043_geo_distance.reference b/tests/queries/0_stateless/01043_geo_distance.reference\nindex cd8a8a6dfe93..33e1285872e7 100644\n--- a/tests/queries/0_stateless/01043_geo_distance.reference\n+++ b/tests/queries/0_stateless/01043_geo_distance.reference\n@@ -6,3 +6,11 @@\n 10007555\n 10007554\n 10001780\n+111195.05197522942\n+111195.05197522942\n+110567.32686882635\n+111699.2516454354\n+10007554.677770648\n+10007554.677770648\n+10007554.677770648\n+10001780.1\ndiff --git a/tests/queries/0_stateless/01043_geo_distance.sql b/tests/queries/0_stateless/01043_geo_distance.sql\nindex c1fb29b9eb7b..cf877d05b9f6 100644\n--- a/tests/queries/0_stateless/01043_geo_distance.sql\n+++ b/tests/queries/0_stateless/01043_geo_distance.sql\n@@ -1,3 +1,19 @@\n+SET geo_distance_returns_float64_on_float64_arguments = 0;\n+\n+SELECT greatCircleDistance(0., 0., 0., 1.);\n+SELECT greatCircleDistance(0., 89., 0, 90.);\n+\n+SELECT geoDistance(0., 0., 0., 1.);\n+SELECT geoDistance(0., 89., 0., 90.);\n+\n+SELECT greatCircleDistance(0., 0., 90., 0.);\n+SELECT greatCircleDistance(0., 0., 0., 90.);\n+\n+SELECT geoDistance(0., 0., 90., 0.);\n+SELECT geoDistance(0., 0., 0., 90.);\n+\n+SET geo_distance_returns_float64_on_float64_arguments = 1;\n+\n SELECT greatCircleDistance(0., 0., 0., 1.);\n SELECT greatCircleDistance(0., 89., 0, 90.);\n \ndiff --git a/tests/queries/0_stateless/01678_great_circle_angle.reference b/tests/queries/0_stateless/01678_great_circle_angle.reference\nindex f3382476d4af..a409e1d84b86 100644\n--- a/tests/queries/0_stateless/01678_great_circle_angle.reference\n+++ b/tests/queries/0_stateless/01678_great_circle_angle.reference\n@@ -3,3 +3,8 @@\n 0.7135\n 10007555\n 10007554\n+0.1224\n+0.7071\n+0.7135\n+10007555\n+10007554\ndiff --git a/tests/queries/0_stateless/01678_great_circle_angle.sql b/tests/queries/0_stateless/01678_great_circle_angle.sql\nindex 124c7bfadf22..595622822f13 100644\n--- a/tests/queries/0_stateless/01678_great_circle_angle.sql\n+++ b/tests/queries/0_stateless/01678_great_circle_angle.sql\n@@ -1,3 +1,14 @@\n+SET geo_distance_returns_float64_on_float64_arguments = 0;\n+\n+SELECT round(greatCircleAngle(0, 45, 0.1, 45.1), 4);\n+SELECT round(greatCircleAngle(0, 45, 1, 45), 4);\n+SELECT round(greatCircleAngle(0, 45, 1, 45.1), 4);\n+\n+SELECT round(greatCircleDistance(0, 0, 0, 90), 4);\n+SELECT round(greatCircleDistance(0, 0, 90, 0), 4);\n+\n+SET geo_distance_returns_float64_on_float64_arguments = 1;\n+\n SELECT round(greatCircleAngle(0, 45, 0.1, 45.1), 4);\n SELECT round(greatCircleAngle(0, 45, 1, 45), 4);\n SELECT round(greatCircleAngle(0, 45, 1, 45.1), 4);\n",
  "problem_statement": "Use 64bit floats for geoDistance calculation\n**Describe the unexpected behaviour**\r\n- The `geoDistance` function (and the other geographical distance functions) only uses `Float32` values for the calculation\r\n- This doesn't provide a high enough precision for high precision positioning systems (like [RTK GPS](https://en.wikipedia.org/wiki/Real-time_kinematic_positioning)) which are able to determine the position up to \u00b11cm precision\r\n- When using the `geoDistance` function with close enough positions the result is always 0, which is incorrect\r\n\r\n**How to reproduce**\r\n- most recent Clickhouse version\r\n- `SELECT geoDistance(8.623000, 49.355000, 8.6230001, 49.3550001);` returns `0`\r\n- The exact distance is `0.01327m` [(link to online calculation)](https://www.movable-type.co.uk/scripts/latlong.html)\r\n   - Latitude 1: `49.3550001`\r\n   - Latitude 2: `49.3550000`\r\n   - Longitude 1: `8.6230001`\r\n   - Longitude 1: `8.6230000`\r\n- The exact distance can be calculated with Clickhouse too when using the full `haversine` formula manually (returns `0.01327037431348616`):\r\n````\r\nSELECT (2*atan2(sqrt((sin((49.3550001-49.3550000)*pi()/360)*sin((49.3550001-49.3550000)*pi()/360))+(cos(49.3550001*pi()/180)*cos(49.3550000*pi()/180)*sin((8.6230001-8.6230000)*pi()/360)*sin((8.6230001-8.6230000)*pi()/360))),sqrt(1-(sin((49.3550001-49.3550000)*pi()/360)*sin((49.3550001-49.3550000)*pi()/360))+(cos(49.3550001*pi()/180)*cos(49.3550000*pi()/180)*sin((8.6230001-8.6230000)*pi()/360)*sin((8.6230001-8.6230000)*pi()/360)))))*6371000 distance;\r\n````\r\n\r\n**Expected behavior**\r\n- The geoDistance function should use `Float64` values for calculation to support high precision position values\r\n- `SELECT geoDistance(8.623000, 49.355000, 8.6230001, 49.3550001);` should return `0.01327`\r\n\r\n**Additional context**\r\n- Changes were introduced in #37524\r\n- I'm no c++ expert but I suppose [those lines in src/Functions/greatCircleDistance.cpp](https://github.com/ClickHouse/ClickHouse/blob/6b6f395cc7fd944f345a0ac088a6822ed05bca37/src/Functions/greatCircleDistance.cpp#L283C9-L286C83) need to be changed\n",
  "hints_text": "Let's switch to Float64 and check if there will be any noticeable difference in performance.\r\nI thought there would be no difference.\nBTW this chart clearly shows the difference between the `geoDistance` and `manual haversine formula` and the lack of precision...\r\n\r\n`![Screenshot_2024-01-04_11-24-16](https://github.com/ClickHouse/ClickHouse/assets/81422785/6e6edb68-e660-4a95-bf57-ab9981dd8948)\r\n\nI'd like to work on this.\n@geetptl, thank you! This will be very helpful.\nI'm interested in working on this issue. It aligns well with my skills and interests. I've reviewed the problem, and I believe I can contribute a solution.\n@Uzair-90, @geetptl, I don't know who will propose a working solution first, but I'd appreciate your work!\nUnsure how to link this PR here, but here's the link to it:\r\n\r\nhttps://github.com/ClickHouse/ClickHouse/pull/58847\n@alexey-milovidov Thank you for the opportunity I will give it a try and highly appreciate it.\n@alexey-milovidov What do you think about the PR from geetptl #58847?\n@dadebue, it is unfinished - there is performance degradation.",
  "created_at": "2024-03-24T22:14:48Z",
  "modified_files": [
    "src/Core/Settings.h",
    "src/Core/SettingsChangesHistory.h",
    "src/Functions/greatCircleDistance.cpp",
    "src/IO/VarInt.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01043_geo_distance.reference",
    "tests/queries/0_stateless/01043_geo_distance.sql",
    "tests/queries/0_stateless/01678_great_circle_angle.reference",
    "tests/queries/0_stateless/01678_great_circle_angle.sql"
  ]
}