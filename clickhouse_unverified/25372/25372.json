{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25372,
  "instance_id": "ClickHouse__ClickHouse-25372",
  "issue_numbers": [
    "7325"
  ],
  "base_commit": "d2df23a959d65f45a765a9b7615714b55b291245",
  "patch": "diff --git a/docs/en/sql-reference/functions/date-time-functions.md b/docs/en/sql-reference/functions/date-time-functions.md\nindex 34f8ff470fe5..5d72bb099feb 100644\n--- a/docs/en/sql-reference/functions/date-time-functions.md\n+++ b/docs/en/sql-reference/functions/date-time-functions.md\n@@ -27,17 +27,17 @@ SELECT\n \n Returns the timezone of the server.\n \n-**Syntax** \n+**Syntax**\n \n ``` sql\n timeZone()\n ```\n \n-Alias: `timezone`. \n+Alias: `timezone`.\n \n **Returned value**\n \n--   Timezone. \n+-   Timezone.\n \n Type: [String](../../sql-reference/data-types/string.md).\n \n@@ -45,7 +45,7 @@ Type: [String](../../sql-reference/data-types/string.md).\n \n Converts time or date and time to the specified time zone. The time zone is an attribute of the `Date` and `DateTime` data types. The internal value (number of seconds) of the table field or of the resultset's column does not change, the column's type changes and its string representation changes accordingly.\n \n-**Syntax** \n+**Syntax**\n \n ``` sql\n toTimezone(value, timezone)\n@@ -53,14 +53,14 @@ toTimezone(value, timezone)\n \n Alias: `toTimezone`.\n \n-**Arguments** \n+**Arguments**\n \n -   `value` \u2014 Time or date and time. [DateTime64](../../sql-reference/data-types/datetime64.md).\n -   `timezone` \u2014 Timezone for the returned value. [String](../../sql-reference/data-types/string.md).\n \n **Returned value**\n \n--   Date and time. \n+-   Date and time.\n \n Type: [DateTime](../../sql-reference/data-types/datetime.md).\n \n@@ -102,21 +102,21 @@ int32samoa: 1546300800\n \n Returns the timezone name of [DateTime](../../sql-reference/data-types/datetime.md) or [DateTime64](../../sql-reference/data-types/datetime64.md) data types.\n \n-**Syntax** \n+**Syntax**\n \n ``` sql\n timeZoneOf(value)\n ```\n \n-Alias: `timezoneOf`. \n+Alias: `timezoneOf`.\n \n **Arguments**\n \n--   `value` \u2014 Date and time. [DateTime](../../sql-reference/data-types/datetime.md) or [DateTime64](../../sql-reference/data-types/datetime64.md). \n+-   `value` \u2014 Date and time. [DateTime](../../sql-reference/data-types/datetime.md) or [DateTime64](../../sql-reference/data-types/datetime64.md).\n \n **Returned value**\n \n--   Timezone name. \n+-   Timezone name.\n \n Type: [String](../../sql-reference/data-types/string.md).\n \n@@ -149,11 +149,11 @@ Alias: `timezoneOffset`.\n \n **Arguments**\n \n--   `value` \u2014 Date and time. [DateTime](../../sql-reference/data-types/datetime.md) or [DateTime64](../../sql-reference/data-types/datetime64.md). \n+-   `value` \u2014 Date and time. [DateTime](../../sql-reference/data-types/datetime.md) or [DateTime64](../../sql-reference/data-types/datetime64.md).\n \n **Returned value**\n \n--   Offset from UTC in seconds. \n+-   Offset from UTC in seconds.\n \n Type: [Int32](../../sql-reference/data-types/int-uint.md).\n \n@@ -599,7 +599,7 @@ Aliases: `dateAdd`, `DATE_ADD`.\n     - `quarter`\n     - `year`\n \n--   `value` \u2014 Value of interval to add. [Int](../../sql-reference/data-types/int-uint.md).  \n+-   `value` \u2014 Value of interval to add. [Int](../../sql-reference/data-types/int-uint.md).\n -   `date` \u2014 The date or date with time to which `value` is added. [Date](../../sql-reference/data-types/date.md) or [DateTime](../../sql-reference/data-types/datetime.md).\n \n **Returned value**\n@@ -704,7 +704,7 @@ Aliases: `dateSub`, `DATE_SUB`.\n     - `quarter`\n     - `year`\n \n--   `value` \u2014 Value of interval to subtract. [Int](../../sql-reference/data-types/int-uint.md).    \n+-   `value` \u2014 Value of interval to subtract. [Int](../../sql-reference/data-types/int-uint.md).\n -   `date` \u2014 The date or date with time from which `value` is subtracted. [Date](../../sql-reference/data-types/date.md) or [DateTime](../../sql-reference/data-types/datetime.md).\n \n **Returned value**\n@@ -805,7 +805,7 @@ Aliases: `timeStampSub`, `TIMESTAMP_SUB`.\n     - `quarter`\n     - `year`\n \n--   `value` \u2014 Value of interval to subtract. [Int](../../sql-reference/data-types/int-uint.md).   \n+-   `value` \u2014 Value of interval to subtract. [Int](../../sql-reference/data-types/int-uint.md).\n -   `date` \u2014 Date or date with time. [Date](../../sql-reference/data-types/date.md) or [DateTime](../../sql-reference/data-types/datetime.md).\n \n **Returned value**\n@@ -963,7 +963,7 @@ formatDateTime(Time, Format\\[, Timezone\\])\n \n **Returned value(s)**\n \n-Returnes time and date values according to the determined format.\n+Returns time and date values according to the determined format.\n \n **Replacement fields**\n Using replacement fields, you can define a pattern for the resulting string. \u201cExample\u201d column shows formatting result for `2018-01-02 22:33:44`.\n@@ -1012,6 +1012,45 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## dateName {#dataname}\n+\n+Returns part of date with specified date part.\n+\n+**Syntax**\n+\n+``` sql\n+dateName(date_part, date)\n+```\n+\n+**Arguments**\n+\n+-   `date_part` - Date part. Possible values .\n+-   `date` \u2014 Date [Date](../../sql-reference/data-types/date.md) or DateTime [DateTime](../../sql-reference/data-types/datetime.md), [DateTime64](../../sql-reference/data-types/datetime64.md).\n+\n+\n+**Returned value**\n+\n+-   Specified date part of date.\n+\n+Type: [String](../../sql-reference/data-types/string.md#string)\n+\n+**Example**\n+\n+Query:\n+\n+```sql\n+WITH toDateTime('2021-04-14 11:22:33') AS date_value\n+SELECT dateName('year', date_value), dateName('month', date_value), dateName('day', date_value);\n+```\n+\n+Result:\n+\n+```text\n+\u250c\u2500dateName('year', date_value)\u2500\u252c\u2500dateName('month', date_value)\u2500\u252c\u2500dateName('day', date_value)\u2500\u2510\n+\u2502 2021                         \u2502 April                         \u2502 14                          \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+```\n+\n ## FROM\\_UNIXTIME {#fromunixfime}\n \n Function converts Unix timestamp to a calendar date and a time of a day. When there is only a single argument of [Integer](../../sql-reference/data-types/int-uint.md) type, it acts in the same way as [toDateTime](../../sql-reference/functions/type-conversion-functions.md#todatetime) and return [DateTime](../../sql-reference/data-types/datetime.md) type.\ndiff --git a/src/Functions/dateName.cpp b/src/Functions/dateName.cpp\nnew file mode 100644\nindex 000000000000..9c34b0ae55c5\n--- /dev/null\n+++ b/src/Functions/dateName.cpp\n@@ -0,0 +1,349 @@\n+#include <common/DateLUTImpl.h>\n+\n+#include <Core/DecimalFunctions.h>\n+#include <IO/WriteHelpers.h>\n+\n+#include <DataTypes/DataTypeDate.h>\n+#include <DataTypes/DataTypeDateTime.h>\n+#include <DataTypes/DataTypeDateTime64.h>\n+#include <DataTypes/DataTypeString.h>\n+#include <Columns/ColumnString.h>\n+\n+#include <Functions/DateTimeTransforms.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <Functions/extractTimeZoneFromFunctionArguments.h>\n+\n+namespace DB\n+{\n+namespace ErrorCodes\n+{\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int ILLEGAL_COLUMN;\n+    extern const int BAD_ARGUMENTS;\n+}\n+\n+namespace\n+{\n+\n+template <typename DataType> struct DataTypeToTimeTypeMap {};\n+\n+template <> struct DataTypeToTimeTypeMap<DataTypeDate>\n+{\n+    using TimeType = UInt16;\n+};\n+\n+template <> struct DataTypeToTimeTypeMap<DataTypeDateTime>\n+{\n+    using TimeType = UInt32;\n+};\n+\n+template <> struct DataTypeToTimeTypeMap<DataTypeDateTime64>\n+{\n+    using TimeType = Int64;\n+};\n+\n+template <typename DataType>\n+using DateTypeToTimeType = typename DataTypeToTimeTypeMap<DataType>::TimeType;\n+\n+class FunctionDateNameImpl : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"dateName\";\n+\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionDateNameImpl>(); }\n+\n+    String getName() const override { return name; }\n+\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {0, 2}; }\n+\n+    bool isVariadic() const override { return true; }\n+    size_t getNumberOfArguments() const override { return 0; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        if (arguments.size() != 2 && arguments.size() != 3)\n+            throw Exception(\n+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+                \"Number of arguments for function {} doesn't match: passed {}\",\n+                getName(),\n+                toString(arguments.size()));\n+\n+        if (!WhichDataType(arguments[0].type).isString())\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type {} of 1 argument of function {}. Must be string\",\n+                arguments[0].type->getName(),\n+                getName());\n+\n+        WhichDataType first_argument_type(arguments[1].type);\n+\n+        if (!(first_argument_type.isDate() || first_argument_type.isDateTime() || first_argument_type.isDateTime64()))\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type {} of 2 argument of function {}. Must be a date or a date with time\",\n+                arguments[1].type->getName(),\n+                getName());\n+\n+        if (arguments.size() == 3 && !WhichDataType(arguments[2].type).isString())\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type {} of 3 argument of function {}. Must be string\",\n+                arguments[2].type->getName(),\n+                getName());\n+\n+        return std::make_shared<DataTypeString>();\n+    }\n+\n+    ColumnPtr executeImpl(\n+        const ColumnsWithTypeAndName & arguments,\n+        const DataTypePtr & result_type,\n+        [[maybe_unused]] size_t input_rows_count) const override\n+    {\n+        ColumnPtr res;\n+\n+        if (!((res = executeType<DataTypeDate>(arguments, result_type))\n+            || (res = executeType<DataTypeDateTime>(arguments, result_type))\n+            || (res = executeType<DataTypeDateTime64>(arguments, result_type))))\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_COLUMN,\n+                \"Illegal column {} of function {], must be Date or DateTime.\",\n+                arguments[1].column->getName(),\n+                getName());\n+\n+        return res;\n+    }\n+\n+    template <typename DataType>\n+    ColumnPtr executeType(const ColumnsWithTypeAndName & arguments, const DataTypePtr &) const\n+    {\n+        auto * times = checkAndGetColumn<typename DataType::ColumnType>(arguments[1].column.get());\n+        if (!times)\n+            return nullptr;\n+\n+        const ColumnConst * date_part_column = checkAndGetColumnConst<ColumnString>(arguments[0].column.get());\n+        if (!date_part_column)\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_COLUMN,\n+                \"Illegal column {} of first ('datepart') argument of function {}. Must be constant string.\",\n+                arguments[0].column->getName(),\n+                getName());\n+\n+        String date_part = date_part_column->getValue<String>();\n+\n+        const DateLUTImpl * time_zone_tmp;\n+        if (std::is_same_v<DataType, DataTypeDateTime64> || std::is_same_v<DataType, DataTypeDateTime>)\n+            time_zone_tmp = &extractTimeZoneFromFunctionArguments(arguments, 2, 1);\n+        else\n+            time_zone_tmp = &DateLUT::instance();\n+\n+        const auto & times_data = times->getData();\n+        const DateLUTImpl & time_zone = *time_zone_tmp;\n+\n+        UInt32 scale [[maybe_unused]] = 0;\n+        if constexpr (std::is_same_v<DataType, DataTypeDateTime64>)\n+        {\n+            scale = times_data.getScale();\n+        }\n+\n+        auto result_column = ColumnString::create();\n+        auto & result_column_data = result_column->getChars();\n+        auto & result_column_offsets = result_column->getOffsets();\n+\n+        /* longest possible word 'Wednesday' with zero terminator */\n+        static constexpr size_t longest_word_length = 9 + 1;\n+\n+        result_column_data.resize_fill(times_data.size() * longest_word_length);\n+        result_column_offsets.resize(times_data.size());\n+\n+        auto * begin = reinterpret_cast<char *>(result_column_data.data());\n+\n+        WriteBuffer buffer(begin, result_column_data.size());\n+\n+        using TimeType = DateTypeToTimeType<DataType>;\n+        callOnDatePartWriter<TimeType>(date_part, [&](const auto & writer)\n+        {\n+            for (size_t i = 0; i < times_data.size(); ++i)\n+            {\n+                if constexpr (std::is_same_v<DataType, DataTypeDateTime64>)\n+                {\n+                    const auto components = DecimalUtils::split(times_data[i], scale);\n+                    writer.write(buffer, static_cast<Int64>(components.whole), time_zone);\n+                }\n+                else\n+                {\n+                    writer.write(buffer, times_data[i], time_zone);\n+                }\n+\n+                /// Null terminator\n+                ++buffer.position();\n+                result_column_offsets[i] = buffer.position() - begin;\n+            }\n+        });\n+\n+        result_column_data.resize(buffer.position() - begin);\n+\n+        return result_column;\n+    }\n+\n+private:\n+\n+    template <typename Time>\n+    struct YearWriter\n+    {\n+        static void write(WriteBuffer & buffer, Time source, const DateLUTImpl & timezone)\n+        {\n+            writeText(ToYearImpl::execute(source, timezone), buffer);\n+        }\n+    };\n+\n+    template <typename Time>\n+    struct QuarterWriter\n+    {\n+        static inline void write(WriteBuffer & buffer, Time source, const DateLUTImpl & timezone)\n+        {\n+            writeText(ToQuarterImpl::execute(source, timezone), buffer);\n+        }\n+    };\n+\n+    template <typename Time>\n+    struct MonthWriter\n+    {\n+        static inline void write(WriteBuffer & buffer, Time source, const DateLUTImpl & timezone)\n+        {\n+            const auto month = ToMonthImpl::execute(source, timezone);\n+            static constexpr std::string_view month_names[] =\n+            {\n+                \"January\",\n+                \"February\",\n+                \"March\",\n+                \"April\",\n+                \"May\",\n+                \"June\",\n+                \"July\",\n+                \"August\",\n+                \"September\",\n+                \"October\",\n+                \"November\",\n+                \"December\"\n+            };\n+\n+            writeText(month_names[month - 1], buffer);\n+        }\n+    };\n+\n+    template <typename Time>\n+    struct WeekWriter\n+    {\n+        static inline void write(WriteBuffer & buffer, Time source, const DateLUTImpl & timezone)\n+        {\n+            writeText(ToISOWeekImpl::execute(source, timezone), buffer);\n+        }\n+    };\n+\n+    template <typename Time>\n+    struct DayOfYearWriter\n+    {\n+        static inline void write(WriteBuffer & buffer, Time source, const DateLUTImpl & timezone)\n+        {\n+            writeText(ToDayOfYearImpl::execute(source, timezone), buffer);\n+        }\n+    };\n+\n+    template <typename Time>\n+    struct DayWriter\n+    {\n+        static inline void write(WriteBuffer & buffer, Time source, const DateLUTImpl & timezone)\n+        {\n+            writeText(ToDayOfMonthImpl::execute(source, timezone), buffer);\n+        }\n+    };\n+\n+    template <typename Time>\n+    struct WeekDayWriter\n+    {\n+        static inline void write(WriteBuffer & buffer, Time source, const DateLUTImpl & timezone)\n+        {\n+            const auto day = ToDayOfWeekImpl::execute(source, timezone);\n+            static constexpr std::string_view day_names[] =\n+            {\n+                \"Monday\",\n+                \"Tuesday\",\n+                \"Wednesday\",\n+                \"Thursday\",\n+                \"Friday\",\n+                \"Saturday\",\n+                \"Sunday\"\n+            };\n+\n+            writeText(day_names[day - 1], buffer);\n+        }\n+    };\n+\n+    template <typename Time>\n+    struct HourWriter\n+    {\n+        static inline void write(WriteBuffer & buffer, Time source, const DateLUTImpl & timezone)\n+        {\n+            writeText(ToHourImpl::execute(source, timezone), buffer);\n+        }\n+    };\n+\n+    template <typename Time>\n+    struct MinuteWriter\n+    {\n+        static inline void write(WriteBuffer & buffer, Time source, const DateLUTImpl & timezone)\n+        {\n+            writeText(ToMinuteImpl::execute(source, timezone), buffer);\n+        }\n+    };\n+\n+    template <typename Time>\n+    struct SecondWriter\n+    {\n+        static inline void write(WriteBuffer & buffer, Time source, const DateLUTImpl & timezone)\n+        {\n+            writeText(ToSecondImpl::execute(source, timezone), buffer);\n+        }\n+    };\n+\n+    template <typename Time, typename Call>\n+    void callOnDatePartWriter(const String & date_part, Call && call) const\n+    {\n+        if (date_part == \"year\")\n+            std::forward<Call>(call)(YearWriter<Time>());\n+        else if (date_part == \"quarter\")\n+            std::forward<Call>(call)(QuarterWriter<Time>());\n+        else if (date_part == \"month\")\n+            std::forward<Call>(call)(MonthWriter<Time>());\n+        else if (date_part == \"week\")\n+            std::forward<Call>(call)(WeekWriter<Time>());\n+        else if (date_part == \"dayofyear\")\n+            std::forward<Call>(call)(DayOfYearWriter<Time>());\n+        else if (date_part == \"day\")\n+            std::forward<Call>(call)(DayWriter<Time>());\n+        else if (date_part == \"weekday\")\n+            std::forward<Call>(call)(WeekDayWriter<Time>());\n+        else if (date_part == \"hour\")\n+            std::forward<Call>(call)(HourWriter<Time>());\n+        else if (date_part == \"minute\")\n+            std::forward<Call>(call)(MinuteWriter<Time>());\n+        else if (date_part == \"second\")\n+            std::forward<Call>(call)(SecondWriter<Time>());\n+        else\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Invalid date part {} for function {}\", date_part, getName());\n+    }\n+\n+};\n+\n+}\n+\n+void registerFunctionDateName(FunctionFactory & factory)\n+{\n+    factory.registerFunction<FunctionDateNameImpl>(FunctionFactory::CaseInsensitive);\n+}\n+\n+}\ndiff --git a/src/Functions/registerFunctionsDateTime.cpp b/src/Functions/registerFunctionsDateTime.cpp\nindex 441f28bfb54f..abbc52c8360a 100644\n--- a/src/Functions/registerFunctionsDateTime.cpp\n+++ b/src/Functions/registerFunctionsDateTime.cpp\n@@ -64,6 +64,7 @@ void registerFunctionSubtractMonths(FunctionFactory &);\n void registerFunctionSubtractQuarters(FunctionFactory &);\n void registerFunctionSubtractYears(FunctionFactory &);\n void registerFunctionDateDiff(FunctionFactory &);\n+void registerFunctionDateName(FunctionFactory &);\n void registerFunctionToTimeZone(FunctionFactory &);\n void registerFunctionFormatDateTime(FunctionFactory &);\n void registerFunctionFromModifiedJulianDay(FunctionFactory &);\n@@ -134,6 +135,7 @@ void registerFunctionsDateTime(FunctionFactory & factory)\n     registerFunctionSubtractQuarters(factory);\n     registerFunctionSubtractYears(factory);\n     registerFunctionDateDiff(factory);\n+    registerFunctionDateName(factory);\n     registerFunctionToTimeZone(factory);\n     registerFunctionFormatDateTime(factory);\n     registerFunctionFromModifiedJulianDay(factory);\ndiff --git a/src/Functions/ya.make b/src/Functions/ya.make\nindex 09ca82f5ec9c..315ce93dbded 100644\n--- a/src/Functions/ya.make\n+++ b/src/Functions/ya.make\n@@ -222,6 +222,7 @@ SRCS(\n     currentDatabase.cpp\n     currentUser.cpp\n     dateDiff.cpp\n+    dateName.cpp\n     date_trunc.cpp\n     decodeXMLComponent.cpp\n     decrypt.cpp\ndiff --git a/src/IO/WriteHelpers.h b/src/IO/WriteHelpers.h\nindex 3a79951e144a..7de6dbfa6136 100644\n--- a/src/IO/WriteHelpers.h\n+++ b/src/IO/WriteHelpers.h\n@@ -880,6 +880,7 @@ inline std::enable_if_t<std::is_floating_point_v<T>, void>\n writeText(const T & x, WriteBuffer & buf) { writeFloatText(x, buf); }\n \n inline void writeText(const String & x, WriteBuffer & buf) { writeString(x.c_str(), x.size(), buf); }\n+inline void writeText(const std::string_view & x, WriteBuffer & buf) { writeString(x.data(), x.size(), buf); }\n \n /// Implemented as template specialization (not function overload) to avoid preference over templates on arithmetic types above.\n template <> inline void writeText<bool>(const bool & x, WriteBuffer & buf) { writeBoolText(x, buf); }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01811_datename.reference b/tests/queries/0_stateless/01811_datename.reference\nnew file mode 100644\nindex 000000000000..2968fde301aa\n--- /dev/null\n+++ b/tests/queries/0_stateless/01811_datename.reference\n@@ -0,0 +1,12 @@\n+2021\t2021\t2021\n+2\t2\t2\n+April\tApril\tApril\n+104\t104\t104\n+14\t14\t14\n+15\t15\t15\n+Wednesday\tWednesday\tWednesday\n+11\t11\n+22\t22\n+33\t33\n+Wednesday\t23\t22\t33\n+Thursday\t2\t22\t33\ndiff --git a/tests/queries/0_stateless/01811_datename.sql b/tests/queries/0_stateless/01811_datename.sql\nnew file mode 100644\nindex 000000000000..0cd538b52c7d\n--- /dev/null\n+++ b/tests/queries/0_stateless/01811_datename.sql\n@@ -0,0 +1,72 @@\n+WITH\n+    toDate('2021-04-14') AS date_value,\n+    toDateTime('2021-04-14 11:22:33') AS date_time_value,\n+    toDateTime64('2021-04-14 11:22:33', 3) AS date_time_64_value\n+SELECT dateName('year', date_value), dateName('year', date_time_value), dateName('year', date_time_64_value);\n+\n+WITH\n+    toDate('2021-04-14') AS date_value,\n+    toDateTime('2021-04-14 11:22:33') AS date_time_value,\n+    toDateTime64('2021-04-14 11:22:33', 3) AS date_time_64_value\n+SELECT dateName('quarter', date_value), dateName('quarter', date_time_value), dateName('quarter', date_time_64_value);\n+\n+WITH\n+    toDate('2021-04-14') AS date_value,\n+    toDateTime('2021-04-14 11:22:33') AS date_time_value,\n+    toDateTime64('2021-04-14 11:22:33', 3) AS date_time_64_value\n+SELECT dateName('month', date_value), dateName('month', date_time_value), dateName('month', date_time_64_value);\n+\n+WITH\n+    toDate('2021-04-14') AS date_value,\n+    toDateTime('2021-04-14 11:22:33') AS date_time_value,\n+    toDateTime64('2021-04-14 11:22:33', 3) AS date_time_64_value\n+SELECT dateName('dayofyear', date_value), dateName('dayofyear', date_time_value), dateName('dayofyear', date_time_64_value);\n+\n+WITH\n+    toDate('2021-04-14') AS date_value,\n+    toDateTime('2021-04-14 11:22:33') AS date_time_value,\n+    toDateTime64('2021-04-14 11:22:33', 3) AS date_time_64_value\n+SELECT dateName('day', date_value), dateName('day', date_time_value), dateName('day', date_time_64_value);\n+\n+WITH\n+    toDate('2021-04-14') AS date_value,\n+    toDateTime('2021-04-14 11:22:33') AS date_time_value,\n+    toDateTime64('2021-04-14 11:22:33', 3) AS date_time_64_value\n+SELECT dateName('week', date_value), dateName('week', date_time_value), dateName('week', date_time_64_value);\n+\n+WITH\n+    toDate('2021-04-14') AS date_value,\n+    toDateTime('2021-04-14 11:22:33') AS date_time_value,\n+    toDateTime64('2021-04-14 11:22:33', 3) AS date_time_64_value\n+SELECT dateName('weekday', date_value), dateName('weekday', date_time_value), dateName('weekday', date_time_64_value);\n+\n+WITH\n+    toDateTime('2021-04-14 11:22:33') AS date_time_value,\n+    toDateTime64('2021-04-14 11:22:33', 3) AS date_time_64_value\n+SELECT dateName('hour', date_time_value), dateName('hour', date_time_64_value);\n+\n+WITH\n+    toDateTime('2021-04-14 11:22:33') AS date_time_value,\n+    toDateTime64('2021-04-14 11:22:33', 3) AS date_time_64_value\n+SELECT dateName('minute', date_time_value), dateName('minute', date_time_64_value);\n+\n+WITH\n+    toDateTime('2021-04-14 11:22:33') AS date_time_value,\n+    toDateTime64('2021-04-14 11:22:33', 3) AS date_time_64_value\n+SELECT dateName('second', date_time_value), dateName('second', date_time_64_value);\n+\n+WITH\n+    toDateTime('2021-04-14 23:22:33', 'UTC') as date\n+SELECT\n+    dateName('weekday', date, 'UTC'),\n+    dateName('hour', date, 'UTC'),\n+    dateName('minute', date, 'UTC'),\n+    dateName('second', date, 'UTC');\n+\n+WITH\n+    toDateTime('2021-04-14 23:22:33', 'UTC') as date\n+SELECT\n+    dateName('weekday', date, 'Europe/Moscow'),\n+    dateName('hour', date, 'Europe/Moscow'),\n+    dateName('minute', date, 'Europe/Moscow'),\n+    dateName('second', date, 'Europe/Moscow');\n",
  "problem_statement": "No way to get weekday (Monday, Tuesday, etc)\nThere is no way to produce the weekday from the date format.\r\n\r\nUsing `arrayElement(array('Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday'), toDayOfWeek(date_value))` as a workaround.\n",
  "hints_text": "The weekday names are language-dependent. It is better to come with a setting item.\nMany questions arise even for english names:\r\n- should the first letter be capitalized: `Monday` with `monday`;\r\n- should the compact format will be used: `Mon`, `Tue`...\r\n\r\nLet's look at other DBMS:\r\n\r\nMySQL, MariaDB:\r\nhttps://mariadb.com/kb/en/dayname/\r\n\r\nLooks like the most natural to implement.\r\n\r\nMS SQL Server:\r\nhttps://docs.microsoft.com/en-us/sql/t-sql/functions/datename-transact-sql?view=sql-server-ver15\n@dankondr do you want to implement it?\nSee also https://github.com/ClickHouse/ClickHouse/issues/7741",
  "created_at": "2021-06-16T18:21:55Z"
}