{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 10295,
  "instance_id": "ClickHouse__ClickHouse-10295",
  "issue_numbers": [
    "10283"
  ],
  "base_commit": "725969289ed6ae599c02f63176a2090a8e10d3b1",
  "patch": "diff --git a/programs/client/Client.cpp b/programs/client/Client.cpp\nindex e01eef980062..b1dda4b4da9c 100644\n--- a/programs/client/Client.cpp\n+++ b/programs/client/Client.cpp\n@@ -684,7 +684,7 @@ class Client : public Poco::Util::Application\n                     if (ignore_error)\n                     {\n                         Tokens tokens(begin, end);\n-                        IParser::Pos token_iterator(tokens);\n+                        IParser::Pos token_iterator(tokens, context.getSettingsRef().max_parser_depth);\n                         while (token_iterator->type != TokenType::Semicolon && token_iterator.isValid())\n                             ++token_iterator;\n                         begin = token_iterator->end;\n@@ -958,10 +958,15 @@ class Client : public Poco::Util::Application\n         ParserQuery parser(end, true);\n         ASTPtr res;\n \n+        const auto & settings = context.getSettingsRef();\n+        size_t max_length = 0;\n+        if (!allow_multi_statements)\n+            max_length = settings.max_query_size;\n+\n         if (is_interactive || ignore_error)\n         {\n             String message;\n-            res = tryParseQuery(parser, pos, end, message, true, \"\", allow_multi_statements, 0);\n+            res = tryParseQuery(parser, pos, end, message, true, \"\", allow_multi_statements, max_length, settings.max_parser_depth);\n \n             if (!res)\n             {\n@@ -970,7 +975,7 @@ class Client : public Poco::Util::Application\n             }\n         }\n         else\n-            res = parseQueryAndMovePosition(parser, pos, end, \"\", allow_multi_statements, 0);\n+            res = parseQueryAndMovePosition(parser, pos, end, \"\", allow_multi_statements, max_length, settings.max_parser_depth);\n \n         if (is_interactive)\n         {\ndiff --git a/programs/compressor/Compressor.cpp b/programs/compressor/Compressor.cpp\nindex 98a3055da28d..fecdad9bcead 100644\n--- a/programs/compressor/Compressor.cpp\n+++ b/programs/compressor/Compressor.cpp\n@@ -14,6 +14,7 @@\n #include <Parsers/ExpressionElementParsers.h>\n #include <Compression/CompressionFactory.h>\n #include <Common/TerminalSize.h>\n+#include <Core/Defines.h>\n \n \n namespace DB\n@@ -123,7 +124,7 @@ int mainEntryClickHouseCompressor(int argc, char ** argv)\n             DB::ParserCodec codec_parser;\n \n             std::string codecs_line = boost::algorithm::join(codecs, \",\");\n-            auto ast = DB::parseQuery(codec_parser, \"(\" + codecs_line + \")\", 0);\n+            auto ast = DB::parseQuery(codec_parser, \"(\" + codecs_line + \")\", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n             codec = DB::CompressionCodecFactory::instance().get(ast, nullptr);\n         }\n         else\ndiff --git a/programs/copier/ClusterCopier.cpp b/programs/copier/ClusterCopier.cpp\nindex c4714ff201fb..cd5b1e2a2cde 100644\n--- a/programs/copier/ClusterCopier.cpp\n+++ b/programs/copier/ClusterCopier.cpp\n@@ -1197,7 +1197,9 @@ TaskStatus ClusterCopier::processPartitionPieceTaskImpl(\n             query += \" LIMIT \" + limit;\n \n         ParserQuery p_query(query.data() + query.size());\n-        return parseQuery(p_query, query, 0);\n+\n+        const auto & settings = context.getSettingsRef();\n+        return parseQuery(p_query, query, settings.max_query_size, settings.max_parser_depth);\n     };\n \n     /// Load balancing\n@@ -1409,7 +1411,8 @@ TaskStatus ClusterCopier::processPartitionPieceTaskImpl(\n             query += \"INSERT INTO \" + getQuotedTable(split_table_for_current_piece) + \" VALUES \";\n \n             ParserQuery p_query(query.data() + query.size());\n-            query_insert_ast = parseQuery(p_query, query, 0);\n+            const auto & settings = context.getSettingsRef();\n+            query_insert_ast = parseQuery(p_query, query, settings.max_query_size, settings.max_parser_depth);\n \n             LOG_DEBUG(log, \"Executing INSERT query: \" << query);\n         }\n@@ -1634,7 +1637,8 @@ ASTPtr ClusterCopier::getCreateTableForPullShard(const ConnectionTimeouts & time\n             &task_cluster->settings_pull);\n \n     ParserCreateQuery parser_create_query;\n-    return parseQuery(parser_create_query, create_query_pull_str, 0);\n+    const auto & settings = context.getSettingsRef();\n+    return parseQuery(parser_create_query, create_query_pull_str, settings.max_query_size, settings.max_parser_depth);\n }\n \n /// If it is implicitly asked to create split Distributed table for certain piece on current shard, we will do it.\n@@ -1712,7 +1716,8 @@ std::set<String> ClusterCopier::getShardPartitions(const ConnectionTimeouts & ti\n     }\n \n     ParserQuery parser_query(query.data() + query.size());\n-    ASTPtr query_ast = parseQuery(parser_query, query, 0);\n+    const auto & settings = context.getSettingsRef();\n+    ASTPtr query_ast = parseQuery(parser_query, query, settings.max_query_size, settings.max_parser_depth);\n \n     LOG_DEBUG(log, \"Computing destination partition set, executing query: \" << query);\n \n@@ -1759,7 +1764,8 @@ bool ClusterCopier::checkShardHasPartition(const ConnectionTimeouts & timeouts,\n                                      << partition_quoted_name << \" existence, executing query: \" << query);\n \n     ParserQuery parser_query(query.data() + query.size());\n-    ASTPtr query_ast = parseQuery(parser_query, query, 0);\n+const auto & settings = context.getSettingsRef();\n+    ASTPtr query_ast = parseQuery(parser_query, query, settings.max_query_size, settings.max_parser_depth);\n \n     Context local_context = context;\n     local_context.setSettings(task_cluster->settings_pull);\n@@ -1793,7 +1799,8 @@ bool ClusterCopier::checkPresentPartitionPiecesOnCurrentShard(const ConnectionTi\n                    << \"existence, executing query: \" << query);\n \n     ParserQuery parser_query(query.data() + query.size());\n-    ASTPtr query_ast = parseQuery(parser_query, query, 0);\n+    const auto & settings = context.getSettingsRef();\n+    ASTPtr query_ast = parseQuery(parser_query, query, settings.max_query_size, settings.max_parser_depth);\n \n     Context local_context = context;\n     local_context.setSettings(task_cluster->settings_pull);\n@@ -1826,7 +1833,8 @@ UInt64 ClusterCopier::executeQueryOnCluster(\n     if (query_ast_ == nullptr)\n     {\n         ParserQuery p_query(query.data() + query.size());\n-        query_ast = parseQuery(p_query, query, 0);\n+        const auto & settings = context.getSettingsRef();\n+        query_ast = parseQuery(p_query, query, settings.max_query_size, settings.max_parser_depth);\n     }\n     else\n         query_ast = query_ast_;\ndiff --git a/programs/copier/TaskTableAndShard.h b/programs/copier/TaskTableAndShard.h\nindex 615ad297b799..32841e93a145 100644\n--- a/programs/copier/TaskTableAndShard.h\n+++ b/programs/copier/TaskTableAndShard.h\n@@ -4,6 +4,9 @@\n #include \"Internals.h\"\n #include \"ClusterPartition.h\"\n \n+#include <Core/Defines.h>\n+\n+\n namespace DB\n {\n namespace ErrorCodes\n@@ -260,9 +263,10 @@ inline TaskTable::TaskTable(TaskCluster & parent, const Poco::Util::AbstractConf\n                + \".\" + escapeForFileName(table_push.second);\n \n     engine_push_str = config.getString(table_prefix + \"engine\");\n+\n     {\n         ParserStorage parser_storage;\n-        engine_push_ast = parseQuery(parser_storage, engine_push_str, 0);\n+        engine_push_ast = parseQuery(parser_storage, engine_push_str, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n         engine_push_partition_key_ast = extractPartitionKey(engine_push_ast);\n         primary_key_comma_separated = createCommaSeparatedStringFrom(extractPrimaryKeyColumnNames(engine_push_ast));\n         engine_push_zk_path = extractReplicatedTableZookeeperPath(engine_push_ast);\n@@ -273,7 +277,7 @@ inline TaskTable::TaskTable(TaskCluster & parent, const Poco::Util::AbstractConf\n     auxiliary_engine_split_asts.reserve(number_of_splits);\n     {\n         ParserExpressionWithOptionalAlias parser_expression(false);\n-        sharding_key_ast = parseQuery(parser_expression, sharding_key_str, 0);\n+        sharding_key_ast = parseQuery(parser_expression, sharding_key_str, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n         main_engine_split_ast = createASTStorageDistributed(cluster_push_name, table_push.first, table_push.second,\n                                                             sharding_key_ast);\n \n@@ -291,7 +295,7 @@ inline TaskTable::TaskTable(TaskCluster & parent, const Poco::Util::AbstractConf\n     if (!where_condition_str.empty())\n     {\n         ParserExpressionWithOptionalAlias parser_expression(false);\n-        where_condition_ast = parseQuery(parser_expression, where_condition_str, 0);\n+        where_condition_ast = parseQuery(parser_expression, where_condition_str, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n \n         // Will use canonical expression form\n         where_condition_str = queryToString(where_condition_ast);\ndiff --git a/programs/format/Format.cpp b/programs/format/Format.cpp\nindex f826d6394bc0..b5a4e2d16032 100644\n--- a/programs/format/Format.cpp\n+++ b/programs/format/Format.cpp\n@@ -53,7 +53,7 @@ int mainEntryClickHouseFormat(int argc, char ** argv)\n         const char * end = pos + query.size();\n \n         ParserQuery parser(end);\n-        ASTPtr res = parseQuery(parser, pos, end, \"query\", 0);\n+        ASTPtr res = parseQuery(parser, pos, end, \"query\", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n \n         if (!quiet)\n         {\ndiff --git a/programs/local/LocalServer.cpp b/programs/local/LocalServer.cpp\nindex 26752da5d87e..1ab07d79401a 100644\n--- a/programs/local/LocalServer.cpp\n+++ b/programs/local/LocalServer.cpp\n@@ -267,8 +267,10 @@ void LocalServer::processQueries()\n     String initial_create_query = getInitialCreateTableQuery();\n     String queries_str = initial_create_query + config().getRawString(\"query\");\n \n+    const auto & settings = context->getSettingsRef();\n+\n     std::vector<String> queries;\n-    auto parse_res = splitMultipartQuery(queries_str, queries);\n+    auto parse_res = splitMultipartQuery(queries_str, queries, settings.max_query_size, settings.max_parser_depth);\n \n     if (!parse_res.second)\n         throw Exception(\"Cannot parse and execute the following part of query: \" + String(parse_res.first), ErrorCodes::SYNTAX_ERROR);\ndiff --git a/programs/odbc-bridge/ColumnInfoHandler.cpp b/programs/odbc-bridge/ColumnInfoHandler.cpp\nindex b89d50569f68..e3c00f48fb52 100644\n--- a/programs/odbc-bridge/ColumnInfoHandler.cpp\n+++ b/programs/odbc-bridge/ColumnInfoHandler.cpp\n@@ -120,12 +120,14 @@ void ODBCColumnsInfoHandler::handleRequest(Poco::Net::HTTPServerRequest & reques\n \n         SCOPE_EXIT(SQLFreeStmt(hstmt, SQL_DROP));\n \n+        const auto & context_settings = context->getSettingsRef();\n+\n         /// TODO Why not do SQLColumns instead?\n         std::string name = schema_name.empty() ? table_name : schema_name + \".\" + table_name;\n         std::stringstream ss;\n         std::string input = \"SELECT * FROM \" + name + \" WHERE 1 = 0\";\n         ParserQueryWithOutput parser;\n-        ASTPtr select = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0);\n+        ASTPtr select = parseQuery(parser, input.data(), input.data() + input.size(), \"\", context_settings.max_query_size, context_settings.max_parser_depth);\n \n         IAST::FormatSettings settings(ss, true);\n         settings.always_quote_identifiers = true;\ndiff --git a/src/Access/DiskAccessStorage.cpp b/src/Access/DiskAccessStorage.cpp\nindex 12c65e7df1e7..d7ba8563f5a1 100644\n--- a/src/Access/DiskAccessStorage.cpp\n+++ b/src/Access/DiskAccessStorage.cpp\n@@ -32,6 +32,7 @@\n #include <Interpreters/InterpreterShowCreateAccessEntityQuery.h>\n #include <Interpreters/InterpreterShowGrantsQuery.h>\n #include <Common/quoteString.h>\n+#include <Core/Defines.h>\n #include <boost/range/adaptor/map.hpp>\n #include <boost/range/algorithm/copy.hpp>\n #include <boost/range/algorithm_ext/push_back.hpp>\n@@ -93,7 +94,7 @@ namespace\n         const char * end = begin + file_contents.size();\n         while (pos < end)\n         {\n-            queries.emplace_back(parseQueryAndMovePosition(parser, pos, end, \"\", true, 0));\n+            queries.emplace_back(parseQueryAndMovePosition(parser, pos, end, \"\", true, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH));\n             while (isWhitespaceASCII(*pos) || *pos == ';')\n                 ++pos;\n         }\ndiff --git a/src/Access/RowPolicyCache.cpp b/src/Access/RowPolicyCache.cpp\nindex 44f2cd160d46..fc67b7e9b86d 100644\n--- a/src/Access/RowPolicyCache.cpp\n+++ b/src/Access/RowPolicyCache.cpp\n@@ -8,6 +8,7 @@\n #include <Common/quoteString.h>\n #include <ext/range.h>\n #include <boost/smart_ptr/make_shared.hpp>\n+#include <Core/Defines.h>\n \n \n namespace DB\n@@ -77,7 +78,7 @@ void RowPolicyCache::PolicyInfo::setPolicy(const RowPolicyPtr & policy_)\n         try\n         {\n             ParserExpression parser;\n-            parsed_conditions[type] = parseQuery(parser, condition, 0);\n+            parsed_conditions[type] = parseQuery(parser, condition, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n         }\n         catch (...)\n         {\ndiff --git a/src/AggregateFunctions/parseAggregateFunctionParameters.cpp b/src/AggregateFunctions/parseAggregateFunctionParameters.cpp\nindex bcb73f1e9d9b..2a6b9e3b4997 100644\n--- a/src/AggregateFunctions/parseAggregateFunctionParameters.cpp\n+++ b/src/AggregateFunctions/parseAggregateFunctionParameters.cpp\n@@ -2,6 +2,7 @@\n #include <Parsers/ExpressionListParsers.h>\n #include <Parsers/parseQuery.h>\n #include <Common/typeid_cast.h>\n+#include <Core/Defines.h>\n \n \n namespace DB\n@@ -65,7 +66,7 @@ void getAggregateFunctionNameAndParametersArray(\n     ParserExpressionList params_parser(false);\n     ASTPtr args_ast = parseQuery(params_parser,\n         parameters_str.data(), parameters_str.data() + parameters_str.size(),\n-        \"parameters of aggregate function in \" + error_context, 0);\n+        \"parameters of aggregate function in \" + error_context, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n \n     if (args_ast->children.empty())\n         throw Exception(\"Incorrect list of parameters to aggregate function \"\ndiff --git a/src/Core/Defines.h b/src/Core/Defines.h\nindex c797f527be97..fe614cec6bde 100644\n--- a/src/Core/Defines.h\n+++ b/src/Core/Defines.h\n@@ -95,3 +95,6 @@\n /// Actually, there may be multiple acquisitions of different locks for a given table within one query.\n /// Check with IStorage class for the list of possible locks\n #define DBMS_DEFAULT_LOCK_ACQUIRE_TIMEOUT_SEC 120\n+\n+/// Default limit on recursion depth of recursive descend parser.\n+#define DBMS_DEFAULT_MAX_PARSER_DEPTH 1000\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 725171d4a1b9..325abc16f3f0 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -404,7 +404,7 @@ struct Settings : public SettingsCollection<Settings>\n     M(SettingBool, use_compact_format_in_distributed_parts_names, false, \"Changes format of directories names for distributed table insert parts.\", 0) \\\n     M(SettingUInt64, multiple_joins_rewriter_version, 1, \"1 or 2. Second rewriter version knows about table columns and keep not clashed names as is.\", 0) \\\n     M(SettingBool, validate_polygons, true, \"Throw exception if polygon is invalid in function pointInPolygon (e.g. self-tangent, self-intersecting). If the setting is false, the function will accept invalid polygons but may silently return wrong result.\", 0) \\\n-    M(SettingUInt64, max_parser_depth, 1000, \"Maximum parser depth.\", 0) \\\n+    M(SettingUInt64, max_parser_depth, DBMS_DEFAULT_MAX_PARSER_DEPTH, \"Maximum parser depth (recursion depth of recursive descend parser).\", 0) \\\n     M(SettingSeconds, temporary_live_view_timeout, DEFAULT_TEMPORARY_LIVE_VIEW_TIMEOUT_SEC, \"Timeout after which temporary live view is deleted.\", 0) \\\n     M(SettingBool, transform_null_in, false, \"If enabled, NULL values will be matched with 'IN' operator as if they are considered equal.\", 0) \\\n     M(SettingBool, allow_nondeterministic_mutations, false, \"Allow non-deterministic functions in ALTER UPDATE/ALTER DELETE statements\", 0) \\\ndiff --git a/src/DataTypes/DataTypeFactory.cpp b/src/DataTypes/DataTypeFactory.cpp\nindex 20f7681ec1b0..f81adfe347c5 100644\n--- a/src/DataTypes/DataTypeFactory.cpp\n+++ b/src/DataTypes/DataTypeFactory.cpp\n@@ -9,6 +9,8 @@\n #include <Poco/String.h>\n #include <Common/StringUtils/StringUtils.h>\n #include <IO/WriteHelpers.h>\n+#include <Core/Defines.h>\n+\n \n namespace DB\n {\n@@ -26,7 +28,7 @@ namespace ErrorCodes\n DataTypePtr DataTypeFactory::get(const String & full_name) const\n {\n     ParserIdentifierWithOptionalParameters parser;\n-    ASTPtr ast = parseQuery(parser, full_name.data(), full_name.data() + full_name.size(), \"data type\", 0);\n+    ASTPtr ast = parseQuery(parser, full_name.data(), full_name.data() + full_name.size(), \"data type\", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n     return get(ast);\n }\n \ndiff --git a/src/Databases/DatabaseOrdinary.cpp b/src/Databases/DatabaseOrdinary.cpp\nindex a1f5ea1ae6ff..11c4a4400cdb 100644\n--- a/src/Databases/DatabaseOrdinary.cpp\n+++ b/src/Databases/DatabaseOrdinary.cpp\n@@ -234,7 +234,8 @@ void DatabaseOrdinary::alterTable(\n     }\n \n     ParserCreateQuery parser;\n-    ASTPtr ast = parseQuery(parser, statement.data(), statement.data() + statement.size(), \"in file \" + table_metadata_path, 0);\n+    ASTPtr ast = parseQuery(parser, statement.data(), statement.data() + statement.size(), \"in file \" + table_metadata_path,\n+        0, context.getSettingsRef().max_parser_depth);\n \n     auto & ast_create_query = ast->as<ASTCreateQuery &>();\n \ndiff --git a/src/Interpreters/DDLWorker.cpp b/src/Interpreters/DDLWorker.cpp\nindex 4a39cc6b8a1f..e786849d121a 100644\n--- a/src/Interpreters/DDLWorker.cpp\n+++ b/src/Interpreters/DDLWorker.cpp\n@@ -463,7 +463,7 @@ void DDLWorker::parseQueryAndResolveHost(DDLTask & task)\n \n         ParserQuery parser_query(end);\n         String description;\n-        task.query = parseQuery(parser_query, begin, end, description, 0);\n+        task.query = parseQuery(parser_query, begin, end, description, 0, context.getSettingsRef().max_parser_depth);\n     }\n \n     // XXX: serious design flaw since `ASTQueryWithOnCluster` is not inherited from `IAST`!\ndiff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp\nindex 076b654548b0..37e2c8c59453 100644\n--- a/src/Interpreters/InterpreterCreateQuery.cpp\n+++ b/src/Interpreters/InterpreterCreateQuery.cpp\n@@ -6,6 +6,8 @@\n #include <Common/escapeForFileName.h>\n #include <Common/typeid_cast.h>\n \n+#include <Core/Defines.h>\n+\n #include <IO/WriteBufferFromFile.h>\n #include <IO/WriteHelpers.h>\n \n@@ -181,7 +183,7 @@ ASTPtr InterpreterCreateQuery::formatColumns(const NamesAndTypesList & columns)\n         String type_name = column.type->getName();\n         auto pos = type_name.data();\n         const auto end = pos + type_name.size();\n-        column_declaration->type = parseQuery(storage_p, pos, end, \"data type\", 0);\n+        column_declaration->type = parseQuery(storage_p, pos, end, \"data type\", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n         columns_list->children.emplace_back(column_declaration);\n     }\n \n@@ -207,7 +209,7 @@ ASTPtr InterpreterCreateQuery::formatColumns(const ColumnsDescription & columns)\n         String type_name = column.type->getName();\n         auto type_name_pos = type_name.data();\n         const auto type_name_end = type_name_pos + type_name.size();\n-        column_declaration->type = parseQuery(storage_p, type_name_pos, type_name_end, \"data type\", 0);\n+        column_declaration->type = parseQuery(storage_p, type_name_pos, type_name_end, \"data type\", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n \n         if (column.default_desc.expression)\n         {\n@@ -227,7 +229,7 @@ ASTPtr InterpreterCreateQuery::formatColumns(const ColumnsDescription & columns)\n             auto codec_desc_pos = codec_desc.data();\n             const auto codec_desc_end = codec_desc_pos + codec_desc.size();\n             ParserIdentifierWithParameters codec_p;\n-            column_declaration->codec = parseQuery(codec_p, codec_desc_pos, codec_desc_end, \"column codec\", 0);\n+            column_declaration->codec = parseQuery(codec_p, codec_desc_pos, codec_desc_end, \"column codec\", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n         }\n \n         if (column.ttl)\ndiff --git a/src/Interpreters/InterpreterKillQueryQuery.cpp b/src/Interpreters/InterpreterKillQueryQuery.cpp\nindex b23d88524e1f..23f39ab3fc58 100644\n--- a/src/Interpreters/InterpreterKillQueryQuery.cpp\n+++ b/src/Interpreters/InterpreterKillQueryQuery.cpp\n@@ -267,7 +267,7 @@ BlockIO InterpreterKillQueryQuery::execute()\n                 else\n                 {\n                     ParserAlterCommand parser;\n-                    auto command_ast = parseQuery(parser, command_col.getDataAt(i).toString(), 0);\n+                    auto command_ast = parseQuery(parser, command_col.getDataAt(i).toString(), 0, context.getSettingsRef().max_parser_depth);\n                     required_access_rights = InterpreterAlterQuery::getRequiredAccessForCommand(command_ast->as<const ASTAlterCommand &>(), table_id.database_name, table_id.table_name);\n                     if (!access->isGranted(&Poco::Logger::get(\"InterpreterKillQueryQuery\"), required_access_rights))\n                     {\ndiff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex 82fc4d0873e5..691b3c1045b5 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -137,7 +137,7 @@ String InterpreterSelectQuery::generateFilterActions(ExpressionActionsPtr & acti\n     for (const auto & column_str : prerequisite_columns)\n     {\n         ParserExpression expr_parser;\n-        expr_list->children.push_back(parseQuery(expr_parser, column_str, 0));\n+        expr_list->children.push_back(parseQuery(expr_parser, column_str, 0, context->getSettingsRef().max_parser_depth));\n     }\n \n     select_ast->setExpression(ASTSelectQuery::Expression::TABLES, std::make_shared<ASTTablesInSelectQuery>());\ndiff --git a/src/Interpreters/InterpreterShowCreateAccessEntityQuery.cpp b/src/Interpreters/InterpreterShowCreateAccessEntityQuery.cpp\nindex 4c2dcc19a886..0d3b88facceb 100644\n--- a/src/Interpreters/InterpreterShowCreateAccessEntityQuery.cpp\n+++ b/src/Interpreters/InterpreterShowCreateAccessEntityQuery.cpp\n@@ -21,6 +21,7 @@\n #include <DataStreams/OneBlockInputStream.h>\n #include <DataTypes/DataTypeString.h>\n #include <Common/StringUtils/StringUtils.h>\n+#include <Core/Defines.h>\n #include <ext/range.h>\n #include <sstream>\n \n@@ -37,7 +38,7 @@ namespace\n     ASTPtr getCreateQueryImpl(\n         const User & user,\n         const AccessControlManager * manager /* not used if attach_mode == true */,\n-        bool attach_mode = false)\n+        bool attach_mode)\n     {\n         auto query = std::make_shared<ASTCreateUserQuery>();\n         query->name = user.getName();\n@@ -72,7 +73,7 @@ namespace\n     }\n \n \n-    ASTPtr getCreateQueryImpl(const Role & role, const AccessControlManager * manager, bool attach_mode = false)\n+    ASTPtr getCreateQueryImpl(const Role & role, const AccessControlManager * manager, bool attach_mode)\n     {\n         auto query = std::make_shared<ASTCreateRoleQuery>();\n         query->name = role.getName();\n@@ -90,7 +91,7 @@ namespace\n     }\n \n \n-    ASTPtr getCreateQueryImpl(const SettingsProfile & profile, const AccessControlManager * manager, bool attach_mode = false)\n+    ASTPtr getCreateQueryImpl(const SettingsProfile & profile, const AccessControlManager * manager, bool attach_mode)\n     {\n         auto query = std::make_shared<ASTCreateSettingsProfileQuery>();\n         query->name = profile.getName();\n@@ -121,7 +122,7 @@ namespace\n     ASTPtr getCreateQueryImpl(\n         const Quota & quota,\n         const AccessControlManager * manager /* not used if attach_mode == true */,\n-        bool attach_mode = false)\n+        bool attach_mode)\n     {\n         auto query = std::make_shared<ASTCreateQuotaQuery>();\n         query->name = quota.getName();\n@@ -156,7 +157,7 @@ namespace\n     ASTPtr getCreateQueryImpl(\n         const RowPolicy & policy,\n         const AccessControlManager * manager /* not used if attach_mode == true */,\n-        bool attach_mode = false)\n+        bool attach_mode)\n     {\n         auto query = std::make_shared<ASTCreateRowPolicyQuery>();\n         query->name_parts = RowPolicy::FullNameParts{policy.getDatabase(), policy.getTableName(), policy.getName()};\n@@ -171,7 +172,7 @@ namespace\n             if (!condition.empty())\n             {\n                 ParserExpression parser;\n-                ASTPtr expr = parseQuery(parser, condition, 0);\n+                ASTPtr expr = parseQuery(parser, condition, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n                 query->conditions.push_back(std::pair{index, expr});\n             }\n         }\n@@ -190,7 +191,7 @@ namespace\n     ASTPtr getCreateQueryImpl(\n         const IAccessEntity & entity,\n         const AccessControlManager * manager /* not used if attach_mode == true */,\n-        bool attach_mode = false)\n+        bool attach_mode)\n     {\n         if (const User * user = typeid_cast<const User *>(&entity))\n             return getCreateQueryImpl(*user, manager, attach_mode);\n@@ -264,24 +265,24 @@ ASTPtr InterpreterShowCreateAccessEntityQuery::getCreateQuery(const ASTShowCreat\n     if (show_query.current_user)\n     {\n         auto user = context.getUser();\n-        return getCreateQueryImpl(*user, &access_control);\n+        return getCreateQueryImpl(*user, &access_control, false);\n     }\n \n     if (show_query.current_quota)\n     {\n         auto quota = access_control.read<Quota>(context.getQuota()->getUsageInfo().quota_id);\n-        return getCreateQueryImpl(*quota, &access_control);\n+        return getCreateQueryImpl(*quota, &access_control, false);\n     }\n \n     auto type = getType(show_query.kind);\n     if (show_query.kind == Kind::ROW_POLICY)\n     {\n         RowPolicyPtr policy = access_control.read<RowPolicy>(show_query.row_policy_name.getFullName(context));\n-        return getCreateQueryImpl(*policy, &access_control);\n+        return getCreateQueryImpl(*policy, &access_control, false);\n     }\n \n     auto entity = access_control.read(access_control.getID(type, show_query.name));\n-    return getCreateQueryImpl(*entity, &access_control);\n+    return getCreateQueryImpl(*entity, &access_control, false);\n }\n \n \ndiff --git a/src/Interpreters/JoinToSubqueryTransformVisitor.cpp b/src/Interpreters/JoinToSubqueryTransformVisitor.cpp\nindex 331c364c5faa..6a08e11ad9ec 100644\n--- a/src/Interpreters/JoinToSubqueryTransformVisitor.cpp\n+++ b/src/Interpreters/JoinToSubqueryTransformVisitor.cpp\n@@ -14,6 +14,7 @@\n #include <Parsers/ExpressionListParsers.h>\n #include <Parsers/parseQuery.h>\n #include <IO/WriteHelpers.h>\n+#include <Core/Defines.h>\n \n \n namespace DB\n@@ -35,7 +36,7 @@ namespace\n ASTPtr makeSubqueryTemplate()\n {\n     ParserTablesInSelectQueryElement parser(true);\n-    ASTPtr subquery_template = parseQuery(parser, \"(select * from _t) as `--.s`\", 0);\n+    ASTPtr subquery_template = parseQuery(parser, \"(select * from _t) as `--.s`\", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n     if (!subquery_template)\n         throw Exception(\"Cannot parse subquery template\", ErrorCodes::LOGICAL_ERROR);\n     return subquery_template;\ndiff --git a/src/Interpreters/SyntaxAnalyzer.cpp b/src/Interpreters/SyntaxAnalyzer.cpp\nindex 5c1b6c7e62ba..e19961e7a7c2 100644\n--- a/src/Interpreters/SyntaxAnalyzer.cpp\n+++ b/src/Interpreters/SyntaxAnalyzer.cpp\n@@ -1,4 +1,5 @@\n #include <Core/Settings.h>\n+#include <Core/Defines.h>\n #include <Core/NamesAndTypes.h>\n \n #include <Interpreters/SyntaxAnalyzer.h>\n@@ -587,7 +588,7 @@ void replaceJoinedTable(const ASTSelectQuery & select_query)\n         if (table_id.alias.empty() && table_id.isShort())\n         {\n             ParserTableExpression parser;\n-            table_expr = parseQuery(parser, expr, 0)->as<ASTTableExpression &>();\n+            table_expr = parseQuery(parser, expr, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH)->as<ASTTableExpression &>();\n         }\n     }\n }\ndiff --git a/src/Interpreters/SystemLog.h b/src/Interpreters/SystemLog.h\nindex 7c8dc1606f79..9b0c273674c8 100644\n--- a/src/Interpreters/SystemLog.h\n+++ b/src/Interpreters/SystemLog.h\n@@ -9,6 +9,7 @@\n #include <boost/noncopyable.hpp>\n #include <common/logger_useful.h>\n #include <Core/Types.h>\n+#include <Core/Defines.h>\n #include <Storages/IStorage.h>\n #include <Interpreters/Context.h>\n #include <Common/Stopwatch.h>\n@@ -460,7 +461,7 @@ ASTPtr SystemLog<LogElement>::getCreateTableQuery()\n     ParserStorage storage_parser;\n     ASTPtr storage_ast = parseQuery(\n         storage_parser, storage_def.data(), storage_def.data() + storage_def.size(),\n-        \"Storage to create table for \" + LogElement::name(), 0);\n+        \"Storage to create table for \" + LogElement::name(), 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n     create->set(create->storage, storage_ast);\n \n     return create;\ndiff --git a/src/Interpreters/loadMetadata.cpp b/src/Interpreters/loadMetadata.cpp\nindex 53954faa2c0b..42bef47a5013 100644\n--- a/src/Interpreters/loadMetadata.cpp\n+++ b/src/Interpreters/loadMetadata.cpp\n@@ -36,7 +36,7 @@ static void executeCreateQuery(\n     bool has_force_restore_data_flag)\n {\n     ParserCreateQuery parser;\n-    ASTPtr ast = parseQuery(parser, query.data(), query.data() + query.size(), \"in file \" + file_name, 0);\n+    ASTPtr ast = parseQuery(parser, query.data(), query.data() + query.size(), \"in file \" + file_name, 0, context.getSettingsRef().max_parser_depth);\n \n     auto & ast_create_query = ast->as<ASTCreateQuery &>();\n     ast_create_query.attach = true;\ndiff --git a/src/Parsers/IParser.h b/src/Parsers/IParser.h\nindex 5bfbf1ed4768..69c199c201ef 100644\n--- a/src/Parsers/IParser.h\n+++ b/src/Parsers/IParser.h\n@@ -56,8 +56,6 @@ class IParser\n     /// Token iterator augmented with depth information. This allows to control recursion depth.\n     struct Pos : TokenIterator\n     {\n-        using TokenIterator::TokenIterator;\n-\n         uint32_t depth = 0;\n         uint32_t max_depth = 0;\n \ndiff --git a/src/Parsers/parseQuery.cpp b/src/Parsers/parseQuery.cpp\nindex b8ab940f2dde..ff537e0f70ee 100644\n--- a/src/Parsers/parseQuery.cpp\n+++ b/src/Parsers/parseQuery.cpp\n@@ -328,19 +328,28 @@ ASTPtr parseQuery(\n     IParser & parser,\n     const std::string & query,\n     const std::string & query_description,\n-    size_t max_query_size)\n+    size_t max_query_size,\n+    size_t max_parser_depth)\n {\n-    return parseQuery(parser, query.data(), query.data() + query.size(), query_description, max_query_size);\n+    return parseQuery(parser, query.data(), query.data() + query.size(), query_description, max_query_size, max_parser_depth);\n }\n \n \n-ASTPtr parseQuery(IParser & parser, const std::string & query, size_t max_query_size)\n+ASTPtr parseQuery(\n+    IParser & parser,\n+    const std::string & query,\n+    size_t max_query_size,\n+    size_t max_parser_depth)\n {\n-    return parseQuery(parser, query.data(), query.data() + query.size(), parser.getName(), max_query_size);\n+    return parseQuery(parser, query.data(), query.data() + query.size(), parser.getName(), max_query_size, max_parser_depth);\n }\n \n \n-std::pair<const char *, bool> splitMultipartQuery(const std::string & queries, std::vector<std::string> & queries_list)\n+std::pair<const char *, bool> splitMultipartQuery(\n+    const std::string & queries,\n+    std::vector<std::string> & queries_list,\n+    size_t max_query_size,\n+    size_t max_parser_depth)\n {\n     ASTPtr ast;\n \n@@ -356,7 +365,7 @@ std::pair<const char *, bool> splitMultipartQuery(const std::string & queries, s\n     {\n         begin = pos;\n \n-        ast = parseQueryAndMovePosition(parser, pos, end, \"\", true, 0);\n+        ast = parseQueryAndMovePosition(parser, pos, end, \"\", true, max_query_size, max_parser_depth);\n \n         auto * insert = ast->as<ASTInsertQuery>();\n \ndiff --git a/src/Parsers/parseQuery.h b/src/Parsers/parseQuery.h\nindex feea204181ea..14a9a85b22cc 100644\n--- a/src/Parsers/parseQuery.h\n+++ b/src/Parsers/parseQuery.h\n@@ -17,7 +17,7 @@ ASTPtr tryParseQuery(\n     bool allow_multi_statements,    /// If false, check for non-space characters after semicolon and set error message if any.\n     size_t max_query_size,          /// If (end - pos) > max_query_size and query is longer than max_query_size then throws \"Max query size exceeded\".\n                                     /// Disabled if zero. Is used in order to check query size if buffer can contains data for INSERT query.\n-    size_t max_parser_depth = 0);\n+    size_t max_parser_depth);\n \n \n /// Parse query or throw an exception with error message.\n@@ -27,8 +27,8 @@ ASTPtr parseQueryAndMovePosition(\n     const char * end,\n     const std::string & description,\n     bool allow_multi_statements,\n-    size_t max_query_size = 0,\n-    size_t max_parser_depth = 0);\n+    size_t max_query_size,\n+    size_t max_parser_depth);\n \n ASTPtr parseQuery(\n     IParser & parser,\n@@ -36,24 +36,30 @@ ASTPtr parseQuery(\n     const char * end,\n     const std::string & description,\n     size_t max_query_size,\n-    size_t max_parser_depth = 0);\n+    size_t max_parser_depth);\n \n ASTPtr parseQuery(\n     IParser & parser,\n     const std::string & query,\n     const std::string & query_description,\n-    size_t max_query_size);\n+    size_t max_query_size,\n+    size_t max_parser_depth);\n \n ASTPtr parseQuery(\n     IParser & parser,\n     const std::string & query,\n-    size_t max_query_size);\n+    size_t max_query_size,\n+    size_t max_parser_depth);\n \n \n /** Split queries separated by ; on to list of single queries\n   * Returns pointer to the end of last successfully parsed query (first), and true if all queries are successfully parsed (second)\n   * NOTE: INSERT's data should be placed in single line.\n   */\n-std::pair<const char *, bool> splitMultipartQuery(const std::string & queries, std::vector<std::string> & queries_list);\n+std::pair<const char *, bool> splitMultipartQuery(\n+    const std::string & queries,\n+    std::vector<std::string> & queries_list,\n+    size_t max_query_size,\n+    size_t max_parser_depth);\n \n }\ndiff --git a/src/Storages/ColumnsDescription.cpp b/src/Storages/ColumnsDescription.cpp\nindex 76a55d059eec..c4f6d11605f1 100644\n--- a/src/Storages/ColumnsDescription.cpp\n+++ b/src/Storages/ColumnsDescription.cpp\n@@ -23,11 +23,13 @@\n #include <Interpreters/Context.h>\n #include <Storages/IStorage.h>\n #include <Common/typeid_cast.h>\n+#include <Core/Defines.h>\n #include <Compression/CompressionFactory.h>\n #include <Interpreters/ExpressionAnalyzer.h>\n #include <Interpreters/SyntaxAnalyzer.h>\n #include <Interpreters/ExpressionActions.h>\n \n+\n namespace DB\n {\n \n@@ -102,7 +104,7 @@ void ColumnDescription::readText(ReadBuffer & buf)\n     ParserColumnDeclaration column_parser(/* require type */ true);\n     String column_line;\n     readEscapedStringUntilEOL(column_line, buf);\n-    ASTPtr ast = parseQuery(column_parser, column_line, \"column parser\", 0);\n+    ASTPtr ast = parseQuery(column_parser, column_line, \"column parser\", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n     if (const auto * col_ast = ast->as<ASTColumnDeclaration>())\n     {\n         name = col_ast->name;\ndiff --git a/src/Storages/ConstraintsDescription.cpp b/src/Storages/ConstraintsDescription.cpp\nindex ad0cd76733a6..8c38af0cd5eb 100644\n--- a/src/Storages/ConstraintsDescription.cpp\n+++ b/src/Storages/ConstraintsDescription.cpp\n@@ -5,6 +5,8 @@\n #include <Parsers/parseQuery.h>\n #include <Parsers/ASTExpressionList.h>\n \n+#include <Core/Defines.h>\n+\n \n namespace DB\n {\n@@ -28,7 +30,7 @@ ConstraintsDescription ConstraintsDescription::parse(const String & str)\n \n     ConstraintsDescription res;\n     ParserConstraintDeclarationList parser;\n-    ASTPtr list = parseQuery(parser, str, 0);\n+    ASTPtr list = parseQuery(parser, str, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n \n     for (const auto & constraint : list->children)\n         res.constraints.push_back(std::dynamic_pointer_cast<ASTConstraintDeclaration>(constraint));\ndiff --git a/src/Storages/IndicesDescription.cpp b/src/Storages/IndicesDescription.cpp\nindex a5772a835bfb..2363e7924bad 100644\n--- a/src/Storages/IndicesDescription.cpp\n+++ b/src/Storages/IndicesDescription.cpp\n@@ -5,6 +5,9 @@\n #include <Parsers/ParserCreateQuery.h>\n #include <Parsers/parseQuery.h>\n \n+#include <Core/Defines.h>\n+\n+\n namespace DB\n {\n \n@@ -42,7 +45,7 @@ IndicesDescription IndicesDescription::parse(const String & str)\n \n     IndicesDescription res;\n     ParserIndexDeclarationList parser;\n-    ASTPtr list = parseQuery(parser, str, 0);\n+    ASTPtr list = parseQuery(parser, str, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n \n     for (const auto & index : list->children)\n         res.indices.push_back(std::dynamic_pointer_cast<ASTIndexDeclaration>(index));\ndiff --git a/src/Storages/MutationCommands.cpp b/src/Storages/MutationCommands.cpp\nindex d48f85251623..f3569c344d99 100644\n--- a/src/Storages/MutationCommands.cpp\n+++ b/src/Storages/MutationCommands.cpp\n@@ -9,6 +9,7 @@\n #include <Parsers/ASTIdentifier.h>\n #include <Common/typeid_cast.h>\n #include <Common/quoteString.h>\n+#include <Core/Defines.h>\n #include <DataTypes/DataTypeFactory.h>\n #include <Parsers/queryToString.h>\n #include <common/logger_useful.h>\n@@ -137,7 +138,7 @@ void MutationCommands::readText(ReadBuffer & in)\n \n     ParserAlterCommandList p_alter_commands;\n     auto commands_ast = parseQuery(\n-        p_alter_commands, commands_str.data(), commands_str.data() + commands_str.length(), \"mutation commands list\", 0);\n+        p_alter_commands, commands_str.data(), commands_str.data() + commands_str.length(), \"mutation commands list\", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n     for (ASTAlterCommand * command_ast : commands_ast->as<ASTAlterCommandList &>().commands)\n     {\n         auto command = MutationCommand::parse(command_ast, true);\ndiff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp\nindex 556e7b41c52b..a19a424c6430 100644\n--- a/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -1,4 +1,5 @@\n-#include <Disks/DiskSpaceMonitor.h>\n+#include <Core/Defines.h>\n+\n #include <Common/FieldVisitors.h>\n #include <Common/Macros.h>\n #include <Common/StringUtils/StringUtils.h>\n@@ -25,6 +26,8 @@\n #include <Storages/MergeTree/ReplicatedMergeTreePartHeader.h>\n #include <Storages/VirtualColumnUtils.h>\n \n+#include <Disks/DiskSpaceMonitor.h>\n+\n #include <Databases/IDatabase.h>\n \n #include <Parsers/formatAST.h>\n@@ -479,7 +482,7 @@ void StorageReplicatedMergeTree::setTableStructure(ColumnsDescription new_column\n         if (metadata_diff.sorting_key_changed)\n         {\n             ParserNotEmptyExpressionList parser(false);\n-            auto new_sorting_key_expr_list = parseQuery(parser, metadata_diff.new_sorting_key, 0);\n+            auto new_sorting_key_expr_list = parseQuery(parser, metadata_diff.new_sorting_key, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n \n             if (new_sorting_key_expr_list->children.size() == 1)\n                 metadata.order_by_ast = new_sorting_key_expr_list->children[0];\n@@ -507,7 +510,7 @@ void StorageReplicatedMergeTree::setTableStructure(ColumnsDescription new_column\n         if (metadata_diff.ttl_table_changed)\n         {\n             ParserTTLExpressionList parser;\n-            metadata.ttl_for_table_ast = parseQuery(parser, metadata_diff.new_ttl_table, 0);\n+            metadata.ttl_for_table_ast = parseQuery(parser, metadata_diff.new_ttl_table, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n         }\n     }\n \ndiff --git a/src/Storages/getStructureOfRemoteTable.cpp b/src/Storages/getStructureOfRemoteTable.cpp\nindex eb386c66d60a..3b4ee489b461 100644\n--- a/src/Storages/getStructureOfRemoteTable.cpp\n+++ b/src/Storages/getStructureOfRemoteTable.cpp\n@@ -137,7 +137,7 @@ ColumnsDescription getStructureOfRemoteTableInShard(\n                 column.default_desc.kind = columnDefaultKindFromString(kind_name);\n                 String expr_str = (*default_expr)[i].get<const String &>();\n                 column.default_desc.expression = parseQuery(\n-                    expr_parser, expr_str.data(), expr_str.data() + expr_str.size(), \"default expression\", 0);\n+                    expr_parser, expr_str.data(), expr_str.data() + expr_str.size(), \"default expression\", 0, context.getSettingsRef().max_parser_depth);\n             }\n \n             res.add(column);\ndiff --git a/src/TableFunctions/parseColumnsListForTableFunction.cpp b/src/TableFunctions/parseColumnsListForTableFunction.cpp\nindex 9b775b704929..c419164ac38f 100644\n--- a/src/TableFunctions/parseColumnsListForTableFunction.cpp\n+++ b/src/TableFunctions/parseColumnsListForTableFunction.cpp\n@@ -19,9 +19,7 @@ ColumnsDescription parseColumnsListFromString(const std::string & structure, con\n     Expected expected;\n \n     Tokens tokens(structure.c_str(), structure.c_str() + structure.size());\n-    IParser::Pos token_iterator(tokens);\n-    const Settings & settings = context.getSettingsRef();\n-    token_iterator.max_depth = settings.max_parser_depth;\n+    IParser::Pos token_iterator(tokens, context.getSettingsRef().max_parser_depth);\n \n     ParserColumnDeclarationList parser;\n     ASTPtr columns_list_raw;\n",
  "test_patch": "diff --git a/src/Compression/tests/gtest_compressionCodec.cpp b/src/Compression/tests/gtest_compressionCodec.cpp\nindex a6bfdaebb144..f3652366a24f 100644\n--- a/src/Compression/tests/gtest_compressionCodec.cpp\n+++ b/src/Compression/tests/gtest_compressionCodec.cpp\n@@ -462,7 +462,7 @@ CompressionCodecPtr makeCodec(const std::string & codec_string, const DataTypePt\n {\n     const std::string codec_statement = \"(\" + codec_string + \")\";\n     Tokens tokens(codec_statement.begin().base(), codec_statement.end().base());\n-    IParser::Pos token_iterator(tokens);\n+    IParser::Pos token_iterator(tokens, 0);\n \n     Expected expected;\n     ASTPtr codec_ast;\ndiff --git a/src/DataStreams/tests/expression_stream.cpp b/src/DataStreams/tests/expression_stream.cpp\nindex bd4117f5aabb..fbfde018ed6f 100644\n--- a/src/DataStreams/tests/expression_stream.cpp\n+++ b/src/DataStreams/tests/expression_stream.cpp\n@@ -33,7 +33,7 @@ try\n     std::string input = \"SELECT number, number / 3, number * number\";\n \n     ParserSelectQuery parser;\n-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0);\n+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0, 0);\n \n     Context context = Context::createGlobal();\n     context.makeGlobalContext();\ndiff --git a/src/DataStreams/tests/filter_stream.cpp b/src/DataStreams/tests/filter_stream.cpp\nindex 5e324251440e..8356b90957c1 100644\n--- a/src/DataStreams/tests/filter_stream.cpp\n+++ b/src/DataStreams/tests/filter_stream.cpp\n@@ -35,7 +35,7 @@ try\n     std::string input = \"SELECT number, number % 3 == 1\";\n \n     ParserSelectQuery parser;\n-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0);\n+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0, 0);\n \n     formatAST(*ast, std::cerr);\n     std::cerr << std::endl;\ndiff --git a/src/Dictionaries/tests/gtest_dictionary_configuration.cpp b/src/Dictionaries/tests/gtest_dictionary_configuration.cpp\nindex 9c1ad9467b0d..ae9c5385b8db 100644\n--- a/src/Dictionaries/tests/gtest_dictionary_configuration.cpp\n+++ b/src/Dictionaries/tests/gtest_dictionary_configuration.cpp\n@@ -52,7 +52,7 @@ TEST(ConvertDictionaryAST, SimpleDictConfiguration)\n                    \" RANGE(MIN second_column MAX third_column)\";\n \n     ParserCreateDictionaryQuery parser;\n-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0);\n+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0, 0);\n     ASTCreateQuery * create = ast->as<ASTCreateQuery>();\n     DictionaryConfigurationPtr config = getDictionaryConfigurationFromAST(*create);\n \n@@ -120,7 +120,7 @@ TEST(ConvertDictionaryAST, TrickyAttributes)\n                    \" SOURCE(CLICKHOUSE(HOST 'localhost'))\";\n \n     ParserCreateDictionaryQuery parser;\n-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0);\n+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0, 0);\n     ASTCreateQuery * create = ast->as<ASTCreateQuery>();\n     DictionaryConfigurationPtr config = getDictionaryConfigurationFromAST(*create);\n \n@@ -165,7 +165,7 @@ TEST(ConvertDictionaryAST, ComplexKeyAndLayoutWithParams)\n                    \" LIFETIME(MIN 1 MAX 10)\";\n \n     ParserCreateDictionaryQuery parser;\n-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0);\n+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0, 0);\n     ASTCreateQuery * create = ast->as<ASTCreateQuery>();\n     DictionaryConfigurationPtr config = getDictionaryConfigurationFromAST(*create);\n \n@@ -216,7 +216,7 @@ TEST(ConvertDictionaryAST, ComplexSource)\n                    \" RANGE(MIN second_column MAX third_column)\";\n \n     ParserCreateDictionaryQuery parser;\n-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0);\n+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0, 0);\n     ASTCreateQuery * create = ast->as<ASTCreateQuery>();\n     DictionaryConfigurationPtr config = getDictionaryConfigurationFromAST(*create);\n     /// source\ndiff --git a/src/Interpreters/tests/CMakeLists.txt b/src/Interpreters/tests/CMakeLists.txt\nindex da45c1a5153c..26ebf007e6c7 100644\n--- a/src/Interpreters/tests/CMakeLists.txt\n+++ b/src/Interpreters/tests/CMakeLists.txt\n@@ -47,9 +47,6 @@ add_executable (two_level_hash_map two_level_hash_map.cpp)\n target_include_directories (two_level_hash_map SYSTEM BEFORE PRIVATE ${SPARSEHASH_INCLUDE_DIR})\n target_link_libraries (two_level_hash_map PRIVATE dbms)\n \n-add_executable (logical_expressions_optimizer logical_expressions_optimizer.cpp)\n-target_link_libraries (logical_expressions_optimizer PRIVATE dbms clickhouse_parsers)\n-\n add_executable (in_join_subqueries_preprocessor in_join_subqueries_preprocessor.cpp)\n target_link_libraries (in_join_subqueries_preprocessor PRIVATE dbms clickhouse_parsers)\n add_check(in_join_subqueries_preprocessor)\ndiff --git a/src/Interpreters/tests/create_query.cpp b/src/Interpreters/tests/create_query.cpp\nindex 20a0bfcb0620..ad006de3be67 100644\n--- a/src/Interpreters/tests/create_query.cpp\n+++ b/src/Interpreters/tests/create_query.cpp\n@@ -76,7 +76,7 @@ try\n         \") ENGINE = Log\";\n \n     ParserCreateQuery parser;\n-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0);\n+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0, 0);\n \n     Context context = Context::createGlobal();\n     context.makeGlobalContext();\ndiff --git a/src/Interpreters/tests/expression.cpp b/src/Interpreters/tests/expression.cpp\nindex 8d64b4f64ce2..5432e405d1c2 100644\n--- a/src/Interpreters/tests/expression.cpp\n+++ b/src/Interpreters/tests/expression.cpp\n@@ -41,7 +41,7 @@ int main(int argc, char ** argv)\n             \"s1 < s2 AND x % 3 < x % 5\";\n \n         ParserSelectQuery parser;\n-        ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0);\n+        ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0, 0);\n \n         formatAST(*ast, std::cerr);\n         std::cerr << std::endl;\ndiff --git a/src/Interpreters/tests/expression_analyzer.cpp b/src/Interpreters/tests/expression_analyzer.cpp\nindex 2f8b6b2aef26..66b4900584f6 100644\n--- a/src/Interpreters/tests/expression_analyzer.cpp\n+++ b/src/Interpreters/tests/expression_analyzer.cpp\n@@ -72,7 +72,7 @@ struct TestEntry\n         ParserSelectQuery parser;\n         std::string message;\n         auto text = query.data();\n-        if (ASTPtr ast = tryParseQuery(parser, text, text + query.size(), message, false, \"\", false, 0))\n+        if (ASTPtr ast = tryParseQuery(parser, text, text + query.size(), message, false, \"\", false, 0, 0))\n             return ast;\n         throw Exception(message, ErrorCodes::SYNTAX_ERROR);\n     }\ndiff --git a/src/Interpreters/tests/gtest_cycle_aliases.cpp b/src/Interpreters/tests/gtest_cycle_aliases.cpp\nindex c8037b23d845..593db93de3e9 100644\n--- a/src/Interpreters/tests/gtest_cycle_aliases.cpp\n+++ b/src/Interpreters/tests/gtest_cycle_aliases.cpp\n@@ -12,11 +12,11 @@ TEST(QueryNormalizer, SimpleCycleAlias)\n {\n     String query = \"a as b, b as a\";\n     ParserExpressionList parser(false);\n-    ASTPtr ast = parseQuery(parser, query, 0);\n+    ASTPtr ast = parseQuery(parser, query, 0, 0);\n \n     Aliases aliases;\n-    aliases[\"a\"] = parseQuery(parser, \"b as a\", 0)->children[0];\n-    aliases[\"b\"] = parseQuery(parser, \"a as b\", 0)->children[0];\n+    aliases[\"a\"] = parseQuery(parser, \"b as a\", 0, 0)->children[0];\n+    aliases[\"b\"] = parseQuery(parser, \"a as b\", 0, 0)->children[0];\n \n     Settings settings;\n     QueryNormalizer::Data normalizer_data(aliases, settings);\ndiff --git a/src/Interpreters/tests/in_join_subqueries_preprocessor.cpp b/src/Interpreters/tests/in_join_subqueries_preprocessor.cpp\nindex 9a17f03f32a7..412557f13b8c 100644\n--- a/src/Interpreters/tests/in_join_subqueries_preprocessor.cpp\n+++ b/src/Interpreters/tests/in_join_subqueries_preprocessor.cpp\n@@ -1224,7 +1224,7 @@ bool parse(DB::ASTPtr & ast, const std::string & query)\n     std::string message;\n     auto begin = query.data();\n     auto end = begin + query.size();\n-    ast = DB::tryParseQuery(parser, begin, end, message, false, \"\", false, 0);\n+    ast = DB::tryParseQuery(parser, begin, end, message, false, \"\", false, 0, 0);\n     return ast != nullptr;\n }\n \ndiff --git a/src/Interpreters/tests/logical_expressions_optimizer.cpp b/src/Interpreters/tests/logical_expressions_optimizer.cpp\ndeleted file mode 100644\nindex c21c4dda2999..000000000000\n--- a/src/Interpreters/tests/logical_expressions_optimizer.cpp\n+++ /dev/null\n@@ -1,295 +0,0 @@\n-#include <Parsers/ASTSelectQuery.h>\n-#include <Parsers/ParserSelectQuery.h>\n-#include <Parsers/parseQuery.h>\n-#include <Parsers/queryToString.h>\n-#include <Interpreters/LogicalExpressionsOptimizer.h>\n-#include <Core/Settings.h>\n-#include <Common/typeid_cast.h>\n-\n-#include <iostream>\n-#include <vector>\n-#include <utility>\n-#include <string>\n-#include <algorithm>\n-\n-\n-namespace\n-{\n-\n-struct TestEntry\n-{\n-    std::string input;\n-    std::string expected_output;\n-    UInt64 limit;\n-};\n-\n-using TestEntries = std::vector<TestEntry>;\n-using TestResult = std::pair<bool, std::string>;\n-\n-void run();\n-void performTests(const TestEntries & entries);\n-TestResult check(const TestEntry & entry);\n-bool parse(DB::ASTPtr & ast, const std::string & query);\n-bool equals(const DB::ASTPtr & lhs, const DB::ASTPtr & rhs);\n-void reorder(DB::IAST * ast);\n-\n-\n-void run()\n-{\n-    /// NOTE: Queries are not always realistic, but we are only interested in the syntax.\n-    TestEntries entries =\n-    {\n-        {\n-            \"SELECT 1\",\n-            \"SELECT 1\",\n-            3\n-        },\n-\n-        // WHERE\n-\n-        {\n-            \"SELECT name, value FROM report WHERE (name = 'Alice') OR (name = 'Bob') OR (name = 'Carol')\",\n-            \"SELECT name, value FROM report WHERE (name = 'Alice') OR (name = 'Bob') OR (name = 'Carol')\",\n-            4\n-        },\n-\n-        {\n-            \"SELECT name, value FROM report WHERE (name = 'Alice') OR (name = 'Bob') OR (name = 'Carol')\",\n-            \"SELECT name, value FROM report WHERE name IN ('Alice', 'Bob', 'Carol')\",\n-            3\n-        },\n-\n-        {\n-            \"SELECT name, value FROM report WHERE (name = 'Alice') OR (name = 'Bob') OR (name = 'Carol')\",\n-            \"SELECT name, value FROM report WHERE name IN ('Alice', 'Bob', 'Carol')\",\n-            2\n-        },\n-\n-        {\n-            \"SELECT name, value FROM report WHERE (name = 'Alice') OR (value = 1000) OR (name = 'Bob') OR (name = 'Carol')\",\n-            \"SELECT name, value FROM report WHERE (value = 1000) OR name IN ('Alice', 'Bob', 'Carol')\",\n-            2\n-        },\n-\n-        {\n-            \"SELECT name, value FROM report WHERE (name = 'Alice') OR (value = 1000) OR (name = 'Bob') OR (name = 'Carol') OR (value = 2000)\",\n-            \"SELECT name, value FROM report WHERE name IN ('Alice', 'Bob', 'Carol') OR value IN (1000, 2000)\",\n-            2\n-        },\n-\n-        {\n-            \"SELECT value FROM report WHERE ((value + 1) = 1000) OR ((2 * value) = 2000) OR ((2 * value) = 4000) OR ((value + 1) = 3000)\",\n-            \"SELECT value FROM report WHERE ((value + 1) IN (1000, 3000)) OR ((2 * value) IN (2000, 4000))\",\n-            2\n-        },\n-\n-        {\n-            \"SELECT name, value FROM report WHERE ((name = 'Alice') OR (name = 'Bob') OR (name = 'Carol')) AND ((value = 1000) OR (value = 2000))\",\n-            \"SELECT name, value FROM report WHERE name IN ('Alice', 'Bob', 'Carol') AND ((value = 1000) OR (value = 2000))\",\n-            3\n-        },\n-\n-        // PREWHERE\n-\n-        {\n-            \"SELECT name, value FROM report PREWHERE (name = 'Alice') OR (name = 'Bob') OR (name = 'Carol')\",\n-            \"SELECT name, value FROM report PREWHERE (name = 'Alice') OR (name = 'Bob') OR (name = 'Carol')\",\n-            4\n-        },\n-\n-        {\n-            \"SELECT name, value FROM report PREWHERE (name = 'Alice') OR (name = 'Bob') OR (name = 'Carol')\",\n-            \"SELECT name, value FROM report PREWHERE name IN ('Alice', 'Bob', 'Carol')\",\n-            3\n-        },\n-\n-        {\n-            \"SELECT name, value FROM report PREWHERE (name = 'Alice') OR (name = 'Bob') OR (name = 'Carol')\",\n-            \"SELECT name, value FROM report PREWHERE name IN ('Alice', 'Bob', 'Carol')\",\n-            2\n-        },\n-\n-        {\n-            \"SELECT name, value FROM report PREWHERE (name = 'Alice') OR (value = 1000) OR (name = 'Bob') OR (name = 'Carol')\",\n-            \"SELECT name, value FROM report PREWHERE (value = 1000) OR name IN ('Alice', 'Bob', 'Carol')\",\n-            2\n-        },\n-\n-        {\n-            \"SELECT name, value FROM report PREWHERE (name = 'Alice') OR (value = 1000) OR (name = 'Bob') OR (name = 'Carol') OR (value = 2000)\",\n-            \"SELECT name, value FROM report PREWHERE name IN ('Alice', 'Bob', 'Carol') OR value IN (1000, 2000)\",\n-            2\n-        },\n-\n-        {\n-            \"SELECT value FROM report PREWHERE ((value + 1) = 1000) OR ((2 * value) = 2000) OR ((2 * value) = 4000) OR ((value + 1) = 3000)\",\n-            \"SELECT value FROM report PREWHERE (value + 1) IN (1000, 3000) OR (2 * value) IN (2000, 4000)\",\n-            2\n-        },\n-\n-        // HAVING\n-\n-        {\n-            \"SELECT number, count() FROM (SELECT * FROM system.numbers LIMIT 10) GROUP BY number HAVING number = 1\",\n-            \"SELECT number, count() FROM (SELECT * FROM system.numbers LIMIT 10) GROUP BY number HAVING number = 1\",\n-            2\n-        },\n-\n-        {\n-            \"SELECT number, count() FROM (SELECT * FROM system.numbers LIMIT 10) GROUP BY number HAVING (number = 1) OR (number = 2)\",\n-            \"SELECT number, count() FROM (SELECT * FROM system.numbers LIMIT 10) GROUP BY number HAVING number IN (1, 2)\",\n-            2\n-        },\n-\n-        {\n-            \"SELECT number, count() FROM (SELECT * FROM system.numbers LIMIT 10) GROUP BY number HAVING (number = 1) OR (number = 2)\",\n-            \"SELECT number, count() FROM (SELECT * FROM system.numbers LIMIT 10) GROUP BY number HAVING (number = 1) OR (number = 2)\",\n-            3\n-        },\n-\n-        {\n-            \"SELECT number, count() FROM (SELECT * FROM system.numbers LIMIT 10) GROUP BY number HAVING ((number + 1) = 1) OR ((number + 1) = 2) OR ((number + 3) = 7)\",\n-            \"SELECT number, count() FROM (SELECT * FROM system.numbers LIMIT 10) GROUP BY number HAVING ((number + 3) = 7) OR (number + 1) IN (1, 2)\",\n-            2\n-        },\n-\n-        // PREWHERE + WHERE + HAVING\n-\n-        {\n-            \"SELECT number, count(), 1 AS T, 2 AS U FROM (SELECT * FROM system.numbers LIMIT 10) PREWHERE (U = 1) OR (U = 2) \"\n-            \"WHERE (T = 1) OR (T = 2) GROUP BY number HAVING (number = 1) OR (number = 2)\",\n-            \"SELECT number, count(), 1 AS T, 2 AS U FROM (SELECT * FROM system.numbers LIMIT 10) PREWHERE U IN (1, 2) \"\n-            \"WHERE T IN (1, 2) GROUP BY number HAVING number IN (1, 2)\",\n-            2\n-        },\n-\n-        {\n-            \"SELECT number, count(), 1 AS T, 2 AS U FROM (SELECT * FROM system.numbers LIMIT 10) PREWHERE (U = 1) OR (U = 2) OR (U = 3) \"\n-            \"WHERE (T = 1) OR (T = 2) GROUP BY number HAVING (number = 1) OR (number = 2)\",\n-            \"SELECT number, count(), 1 AS T, 2 AS U FROM (SELECT * FROM system.numbers LIMIT 10) PREWHERE U IN (1, 2, 3) \"\n-            \"WHERE (T = 1) OR (T = 2) GROUP BY number HAVING (number = 1) OR (number = 2)\",\n-            3\n-        },\n-\n-        {\n-            \"SELECT x = 1 OR x=2 OR (x = 3 AS x3) AS y, 4 AS x\",\n-            \"SELECT x IN (1, 2, 3) AS y, 4 AS x\",\n-            2\n-        }\n-    };\n-\n-    performTests(entries);\n-}\n-\n-void performTests(const TestEntries & entries)\n-{\n-    unsigned int count = 0;\n-    unsigned int i = 1;\n-\n-    for (const auto & entry : entries)\n-    {\n-        auto res = check(entry);\n-        if (res.first)\n-        {\n-            ++count;\n-            std::cout << \"Test \" << i << \" passed.\\n\";\n-        }\n-        else\n-            std::cout << \"Test \" << i << \" failed. Expected: \" << entry.expected_output << \". Received: \" << res.second << \"\\n\";\n-\n-        ++i;\n-    }\n-    std::cout << count << \" out of \" << entries.size() << \" test(s) passed.\\n\";\n-}\n-\n-TestResult check(const TestEntry & entry)\n-{\n-    try\n-    {\n-        /// Parse and optimize the incoming query.\n-        DB::ASTPtr ast_input;\n-        if (!parse(ast_input, entry.input))\n-            return TestResult(false, \"parse error\");\n-\n-        auto select_query = typeid_cast<DB::ASTSelectQuery *>(&*ast_input);\n-\n-        DB::LogicalExpressionsOptimizer optimizer(select_query, entry.limit);\n-        optimizer.perform();\n-\n-        /// Parse the expected result.\n-        DB::ASTPtr ast_expected;\n-        if (!parse(ast_expected, entry.expected_output))\n-            return TestResult(false, \"parse error\");\n-\n-        /// Compare the optimized query and the expected result.\n-        bool res = equals(ast_input, ast_expected);\n-        std::string output = DB::queryToString(ast_input);\n-\n-        return TestResult(res, output);\n-    }\n-    catch (DB::Exception & e)\n-    {\n-        return TestResult(false, e.displayText());\n-    }\n-}\n-\n-bool parse(DB::ASTPtr & ast, const std::string & query)\n-{\n-    DB::ParserSelectQuery parser;\n-    std::string message;\n-    auto begin = query.data();\n-    auto end = begin + query.size();\n-    ast = DB::tryParseQuery(parser, begin, end, message, false, \"\", false, 0);\n-    return ast != nullptr;\n-}\n-\n-bool equals(const DB::ASTPtr & lhs, const DB::ASTPtr & rhs)\n-{\n-    DB::ASTPtr lhs_reordered = lhs->clone();\n-    reorder(&*lhs_reordered);\n-\n-    DB::ASTPtr rhs_reordered = rhs->clone();\n-    reorder(&*rhs_reordered);\n-\n-    return lhs_reordered->getTreeHash() == rhs_reordered->getTreeHash();\n-}\n-\n-void reorderImpl(DB::IAST * ast)\n-{\n-    if (ast == nullptr)\n-        return;\n-\n-    auto & children = ast->children;\n-    if (children.empty())\n-        return;\n-\n-    for (auto & child : children)\n-        reorderImpl(&*child);\n-\n-    std::sort(children.begin(), children.end(), [](const DB::ASTPtr & lhs, const DB::ASTPtr & rhs)\n-    {\n-        return lhs->getTreeHash() < rhs->getTreeHash();\n-    });\n-}\n-\n-void reorder(DB::IAST * ast)\n-{\n-    if (ast == nullptr)\n-        return;\n-\n-    auto select_query = typeid_cast<DB::ASTSelectQuery *>(ast);\n-    if (select_query == nullptr)\n-        return;\n-\n-    reorderImpl(select_query->where().get());\n-    reorderImpl(select_query->prewhere().get());\n-    reorderImpl(select_query->having().get());\n-}\n-\n-}\n-\n-int main()\n-{\n-    run();\n-    return 0;\n-}\ndiff --git a/src/Parsers/tests/create_parser.cpp b/src/Parsers/tests/create_parser.cpp\nindex 6137d4d18da1..fbdc967fa2a4 100644\n--- a/src/Parsers/tests/create_parser.cpp\n+++ b/src/Parsers/tests/create_parser.cpp\n@@ -12,7 +12,7 @@ int main(int, char **)\n \n     std::string input = \"CREATE TABLE hits (URL String, UserAgentMinor2 FixedString(2), EventTime DateTime) ENGINE = Log\";\n     ParserCreateQuery parser;\n-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0);\n+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0, 0);\n \n     formatAST(*ast, std::cerr);\n     std::cerr << std::endl;\ndiff --git a/src/Parsers/tests/gtest_dictionary_parser.cpp b/src/Parsers/tests/gtest_dictionary_parser.cpp\nindex 25dcbb326add..60eeab5f6153 100644\n--- a/src/Parsers/tests/gtest_dictionary_parser.cpp\n+++ b/src/Parsers/tests/gtest_dictionary_parser.cpp\n@@ -43,7 +43,7 @@ TEST(ParserDictionaryDDL, SimpleDictionary)\n                    \" RANGE(MIN second_column MAX third_column)\";\n \n     ParserCreateDictionaryQuery parser;\n-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0);\n+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0, 0);\n     ASTCreateQuery * create = ast->as<ASTCreateQuery>();\n     EXPECT_EQ(create->table, \"dict1\");\n     EXPECT_EQ(create->database, \"test\");\n@@ -139,7 +139,7 @@ TEST(ParserDictionaryDDL, AttributesWithMultipleProperties)\n                    \" SOURCE(CLICKHOUSE(HOST 'localhost'))\";\n \n     ParserCreateDictionaryQuery parser;\n-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0);\n+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0, 0);\n     ASTCreateQuery * create = ast->as<ASTCreateQuery>();\n     EXPECT_EQ(create->table, \"dict2\");\n     EXPECT_EQ(create->database, \"\");\n@@ -186,7 +186,7 @@ TEST(ParserDictionaryDDL, CustomAttributePropertiesOrder)\n                    \" LIFETIME(300)\";\n \n     ParserCreateDictionaryQuery parser;\n-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0);\n+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0, 0);\n     ASTCreateQuery * create = ast->as<ASTCreateQuery>();\n \n     /// test attributes\n@@ -241,7 +241,7 @@ TEST(ParserDictionaryDDL, NestedSource)\n                    \" RANGE(MIN second_column MAX third_column)\";\n \n     ParserCreateDictionaryQuery parser;\n-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0);\n+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0, 0);\n     ASTCreateQuery * create = ast->as<ASTCreateQuery>();\n     EXPECT_EQ(create->table, \"dict4\");\n     EXPECT_EQ(create->database, \"\");\n@@ -289,7 +289,7 @@ TEST(ParserDictionaryDDL, Formatting)\n                    \" RANGE(MIN second_column MAX third_column)\";\n \n     ParserCreateDictionaryQuery parser;\n-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0);\n+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0, 0);\n     ASTCreateQuery * create = ast->as<ASTCreateQuery>();\n     auto str = serializeAST(*create, true);\n     EXPECT_EQ(str, \"CREATE DICTIONARY test.dict5 (`key_column1` UInt64 DEFAULT 1 HIERARCHICAL INJECTIVE, `key_column2` String DEFAULT '', `second_column` UInt8 EXPRESSION intDiv(50, rand() % 1000), `third_column` UInt8) PRIMARY KEY key_column1, key_column2 SOURCE(MYSQL(HOST 'localhost' PORT 9000 USER 'default' REPLICA (HOST '127.0.0.1' PRIORITY 1) PASSWORD '')) LIFETIME(MIN 1 MAX 10) LAYOUT(CACHE(SIZE_IN_CELLS 50)) RANGE(MIN second_column MAX third_column)\");\n@@ -300,7 +300,7 @@ TEST(ParserDictionaryDDL, ParseDropQuery)\n     String input1 = \"DROP DICTIONARY test.dict1\";\n \n     ParserDropQuery parser;\n-    ASTPtr ast1 = parseQuery(parser, input1.data(), input1.data() + input1.size(), \"\", 0);\n+    ASTPtr ast1 = parseQuery(parser, input1.data(), input1.data() + input1.size(), \"\", 0, 0);\n     ASTDropQuery * drop1 = ast1->as<ASTDropQuery>();\n \n     EXPECT_TRUE(drop1->is_dictionary);\n@@ -311,7 +311,7 @@ TEST(ParserDictionaryDDL, ParseDropQuery)\n \n     String input2 = \"DROP DICTIONARY IF EXISTS dict2\";\n \n-    ASTPtr ast2 = parseQuery(parser, input2.data(), input2.data() + input2.size(), \"\", 0);\n+    ASTPtr ast2 = parseQuery(parser, input2.data(), input2.data() + input2.size(), \"\", 0, 0);\n     ASTDropQuery * drop2 = ast2->as<ASTDropQuery>();\n \n     EXPECT_TRUE(drop2->is_dictionary);\n@@ -326,7 +326,7 @@ TEST(ParserDictionaryDDL, ParsePropertiesQueries)\n     String input1 = \"SHOW CREATE DICTIONARY test.dict1\";\n \n     ParserTablePropertiesQuery parser;\n-    ASTPtr ast1 = parseQuery(parser, input1.data(), input1.data() + input1.size(), \"\", 0);\n+    ASTPtr ast1 = parseQuery(parser, input1.data(), input1.data() + input1.size(), \"\", 0, 0);\n     ASTShowCreateDictionaryQuery * show1 = ast1->as<ASTShowCreateDictionaryQuery>();\n \n     EXPECT_EQ(show1->table, \"dict1\");\n@@ -335,7 +335,7 @@ TEST(ParserDictionaryDDL, ParsePropertiesQueries)\n \n     String input2 = \"EXISTS DICTIONARY dict2\";\n \n-    ASTPtr ast2 = parseQuery(parser, input2.data(), input2.data() + input2.size(), \"\", 0);\n+    ASTPtr ast2 = parseQuery(parser, input2.data(), input2.data() + input2.size(), \"\", 0, 0);\n     ASTExistsDictionaryQuery * show2 = ast2->as<ASTExistsDictionaryQuery>();\n \n     EXPECT_EQ(show2->table, \"dict2\");\ndiff --git a/src/Parsers/tests/select_parser.cpp b/src/Parsers/tests/select_parser.cpp\nindex f5d94746aa1a..7711f0d25270 100644\n--- a/src/Parsers/tests/select_parser.cpp\n+++ b/src/Parsers/tests/select_parser.cpp\n@@ -22,7 +22,7 @@ try\n         \" FORMAT TabSeparated\";\n \n     ParserQueryWithOutput parser;\n-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0);\n+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0, 0);\n \n     std::cout << \"Success.\" << std::endl;\n     formatAST(*ast, std::cerr);\ndiff --git a/src/Storages/tests/gtest_transform_query_for_external_database.cpp b/src/Storages/tests/gtest_transform_query_for_external_database.cpp\nindex 385e47201a51..22407ca1bd9e 100644\n--- a/src/Storages/tests/gtest_transform_query_for_external_database.cpp\n+++ b/src/Storages/tests/gtest_transform_query_for_external_database.cpp\n@@ -48,7 +48,7 @@ static State & state()\n static void check(const std::string & query, const std::string & expected, const Context & context, const NamesAndTypesList & columns)\n {\n     ParserSelectQuery parser;\n-    ASTPtr ast = parseQuery(parser, query, 1000);\n+    ASTPtr ast = parseQuery(parser, query, 1000, 1000);\n     SelectQueryInfo query_info;\n     query_info.syntax_analyzer_result = SyntaxAnalyzer(context).analyzeSelect(ast, columns);\n     query_info.query = ast;\ndiff --git a/tests/queries/0_stateless/00328_long_case_construction.sql b/tests/queries/0_stateless/00328_long_case_construction.sql\nindex d0fc90d0884c..aa653d667f7e 100644\n--- a/tests/queries/0_stateless/00328_long_case_construction.sql\n+++ b/tests/queries/0_stateless/00328_long_case_construction.sql\n@@ -1,4 +1,3 @@\n-\n /* Trivial case */\n \n SELECT CASE WHEN 1 THEN 2 WHEN 3 THEN  4 ELSE 5 END;\ndiff --git a/tests/queries/0_stateless/00990_hasToken.sh b/tests/queries/0_stateless/00990_hasToken.sh\nindex 4ccb77b8ecc9..4ef62bc69c0f 100755\n--- a/tests/queries/0_stateless/00990_hasToken.sh\n+++ b/tests/queries/0_stateless/00990_hasToken.sh\n@@ -5,4 +5,4 @@ CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n \n # We should have correct env vars from shell_config.sh to run this test\n \n-python $CURDIR/00990_hasToken.python | ${CLICKHOUSE_CLIENT} -nm\n+python $CURDIR/00990_hasToken.python | ${CLICKHOUSE_CLIENT} --max_query_size 1048576 -nm\ndiff --git a/tests/queries/0_stateless/01068_parens.sql b/tests/queries/0_stateless/01068_parens.sql\nindex 7cb4f097b15f..429487605947 100644\n--- a/tests/queries/0_stateless/01068_parens.sql\n+++ b/tests/queries/0_stateless/01068_parens.sql\n@@ -1,1 +1,2 @@\n-((((((((((((((SELECT((((((((((((((((((((((((((((((((1))))))))))))))))))))))))))))))))))))))))))))))\n+SET max_parser_depth = 10000;\n+((((((((((((((SELECT((((((((((((((((((((((((((((((((1))))))))))))))))))))))))))))))))))))))))))))));\ndiff --git a/tests/queries/0_stateless/01196_max_parser_depth.reference b/tests/queries/0_stateless/01196_max_parser_depth.reference\nnew file mode 100644\nindex 000000000000..a72c1b18aa2c\n--- /dev/null\n+++ b/tests/queries/0_stateless/01196_max_parser_depth.reference\n@@ -0,0 +1,3 @@\n+Code: 306\n+Code: 306\n+Code: 306\ndiff --git a/tests/queries/0_stateless/01196_max_parser_depth.sh b/tests/queries/0_stateless/01196_max_parser_depth.sh\nnew file mode 100755\nindex 000000000000..471c1c22ecb0\n--- /dev/null\n+++ b/tests/queries/0_stateless/01196_max_parser_depth.sh\n@@ -0,0 +1,8 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. $CURDIR/../shell_config.sh\n+\n+{ printf \"select \"; for x in {1..1000}; do printf \"coalesce(null, \"; done; printf \"1\"; for x in {1..1000}; do printf \")\"; done; } | $CLICKHOUSE_CLIENT 2>&1 | grep -o -F 'Code: 306'\n+{ printf \"select \"; for x in {1..1000}; do printf \"coalesce(null, \"; done; printf \"1\"; for x in {1..1000}; do printf \")\"; done; } | $CLICKHOUSE_LOCAL 2>&1 | grep -o -F 'Code: 306'\n+{ printf \"select \"; for x in {1..1000}; do printf \"coalesce(null, \"; done; printf \"1\"; for x in {1..1000}; do printf \")\"; done; } | $CLICKHOUSE_CURL --data-binary @- -vsS \"$CLICKHOUSE_URL\" 2>&1 | grep -o -F 'Code: 306'\n",
  "problem_statement": "clickhouse-client segfaults on a long query\nThe query is like `select coalesce(null, coalesce(null, ....repeat 1000x...., 1) ... )`:\r\n\r\n```\r\n$ { printf \"select \"; for x in {1..1000}; do printf \"coalesce(null, \"; done; printf \"1\"; for x in {1..1000}; do printf \")\"; done; } | clickhouse-client\r\nSegmentation fault (core dumped)\r\n```\n",
  "hints_text": "Reproduced successfully!\nStack overflow.\nWe have a function `checkStackSize` for this purpose.\r\nIt's strange that it's not used in parser.\nLooks like the bug was introduced in https://github.com/ClickHouse/ClickHouse/pull/8647\nNo, it was before.",
  "created_at": "2020-04-15T20:33:23Z"
}