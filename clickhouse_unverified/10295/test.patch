diff --git a/src/Compression/tests/gtest_compressionCodec.cpp b/src/Compression/tests/gtest_compressionCodec.cpp
index a6bfdaebb144..f3652366a24f 100644
--- a/src/Compression/tests/gtest_compressionCodec.cpp
+++ b/src/Compression/tests/gtest_compressionCodec.cpp
@@ -462,7 +462,7 @@ CompressionCodecPtr makeCodec(const std::string & codec_string, const DataTypePt
 {
     const std::string codec_statement = "(" + codec_string + ")";
     Tokens tokens(codec_statement.begin().base(), codec_statement.end().base());
-    IParser::Pos token_iterator(tokens);
+    IParser::Pos token_iterator(tokens, 0);
 
     Expected expected;
     ASTPtr codec_ast;
diff --git a/src/DataStreams/tests/expression_stream.cpp b/src/DataStreams/tests/expression_stream.cpp
index bd4117f5aabb..fbfde018ed6f 100644
--- a/src/DataStreams/tests/expression_stream.cpp
+++ b/src/DataStreams/tests/expression_stream.cpp
@@ -33,7 +33,7 @@ try
     std::string input = "SELECT number, number / 3, number * number";
 
     ParserSelectQuery parser;
-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0);
+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0, 0);
 
     Context context = Context::createGlobal();
     context.makeGlobalContext();
diff --git a/src/DataStreams/tests/filter_stream.cpp b/src/DataStreams/tests/filter_stream.cpp
index 5e324251440e..8356b90957c1 100644
--- a/src/DataStreams/tests/filter_stream.cpp
+++ b/src/DataStreams/tests/filter_stream.cpp
@@ -35,7 +35,7 @@ try
     std::string input = "SELECT number, number % 3 == 1";
 
     ParserSelectQuery parser;
-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0);
+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0, 0);
 
     formatAST(*ast, std::cerr);
     std::cerr << std::endl;
diff --git a/src/Dictionaries/tests/gtest_dictionary_configuration.cpp b/src/Dictionaries/tests/gtest_dictionary_configuration.cpp
index 9c1ad9467b0d..ae9c5385b8db 100644
--- a/src/Dictionaries/tests/gtest_dictionary_configuration.cpp
+++ b/src/Dictionaries/tests/gtest_dictionary_configuration.cpp
@@ -52,7 +52,7 @@ TEST(ConvertDictionaryAST, SimpleDictConfiguration)
                    " RANGE(MIN second_column MAX third_column)";
 
     ParserCreateDictionaryQuery parser;
-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0);
+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0, 0);
     ASTCreateQuery * create = ast->as<ASTCreateQuery>();
     DictionaryConfigurationPtr config = getDictionaryConfigurationFromAST(*create);
 
@@ -120,7 +120,7 @@ TEST(ConvertDictionaryAST, TrickyAttributes)
                    " SOURCE(CLICKHOUSE(HOST 'localhost'))";
 
     ParserCreateDictionaryQuery parser;
-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0);
+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0, 0);
     ASTCreateQuery * create = ast->as<ASTCreateQuery>();
     DictionaryConfigurationPtr config = getDictionaryConfigurationFromAST(*create);
 
@@ -165,7 +165,7 @@ TEST(ConvertDictionaryAST, ComplexKeyAndLayoutWithParams)
                    " LIFETIME(MIN 1 MAX 10)";
 
     ParserCreateDictionaryQuery parser;
-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0);
+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0, 0);
     ASTCreateQuery * create = ast->as<ASTCreateQuery>();
     DictionaryConfigurationPtr config = getDictionaryConfigurationFromAST(*create);
 
@@ -216,7 +216,7 @@ TEST(ConvertDictionaryAST, ComplexSource)
                    " RANGE(MIN second_column MAX third_column)";
 
     ParserCreateDictionaryQuery parser;
-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0);
+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0, 0);
     ASTCreateQuery * create = ast->as<ASTCreateQuery>();
     DictionaryConfigurationPtr config = getDictionaryConfigurationFromAST(*create);
     /// source
diff --git a/src/Interpreters/tests/CMakeLists.txt b/src/Interpreters/tests/CMakeLists.txt
index da45c1a5153c..26ebf007e6c7 100644
--- a/src/Interpreters/tests/CMakeLists.txt
+++ b/src/Interpreters/tests/CMakeLists.txt
@@ -47,9 +47,6 @@ add_executable (two_level_hash_map two_level_hash_map.cpp)
 target_include_directories (two_level_hash_map SYSTEM BEFORE PRIVATE ${SPARSEHASH_INCLUDE_DIR})
 target_link_libraries (two_level_hash_map PRIVATE dbms)
 
-add_executable (logical_expressions_optimizer logical_expressions_optimizer.cpp)
-target_link_libraries (logical_expressions_optimizer PRIVATE dbms clickhouse_parsers)
-
 add_executable (in_join_subqueries_preprocessor in_join_subqueries_preprocessor.cpp)
 target_link_libraries (in_join_subqueries_preprocessor PRIVATE dbms clickhouse_parsers)
 add_check(in_join_subqueries_preprocessor)
diff --git a/src/Interpreters/tests/create_query.cpp b/src/Interpreters/tests/create_query.cpp
index 20a0bfcb0620..ad006de3be67 100644
--- a/src/Interpreters/tests/create_query.cpp
+++ b/src/Interpreters/tests/create_query.cpp
@@ -76,7 +76,7 @@ try
         ") ENGINE = Log";
 
     ParserCreateQuery parser;
-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0);
+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0, 0);
 
     Context context = Context::createGlobal();
     context.makeGlobalContext();
diff --git a/src/Interpreters/tests/expression.cpp b/src/Interpreters/tests/expression.cpp
index 8d64b4f64ce2..5432e405d1c2 100644
--- a/src/Interpreters/tests/expression.cpp
+++ b/src/Interpreters/tests/expression.cpp
@@ -41,7 +41,7 @@ int main(int argc, char ** argv)
             "s1 < s2 AND x % 3 < x % 5";
 
         ParserSelectQuery parser;
-        ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0);
+        ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0, 0);
 
         formatAST(*ast, std::cerr);
         std::cerr << std::endl;
diff --git a/src/Interpreters/tests/expression_analyzer.cpp b/src/Interpreters/tests/expression_analyzer.cpp
index 2f8b6b2aef26..66b4900584f6 100644
--- a/src/Interpreters/tests/expression_analyzer.cpp
+++ b/src/Interpreters/tests/expression_analyzer.cpp
@@ -72,7 +72,7 @@ struct TestEntry
         ParserSelectQuery parser;
         std::string message;
         auto text = query.data();
-        if (ASTPtr ast = tryParseQuery(parser, text, text + query.size(), message, false, "", false, 0))
+        if (ASTPtr ast = tryParseQuery(parser, text, text + query.size(), message, false, "", false, 0, 0))
             return ast;
         throw Exception(message, ErrorCodes::SYNTAX_ERROR);
     }
diff --git a/src/Interpreters/tests/gtest_cycle_aliases.cpp b/src/Interpreters/tests/gtest_cycle_aliases.cpp
index c8037b23d845..593db93de3e9 100644
--- a/src/Interpreters/tests/gtest_cycle_aliases.cpp
+++ b/src/Interpreters/tests/gtest_cycle_aliases.cpp
@@ -12,11 +12,11 @@ TEST(QueryNormalizer, SimpleCycleAlias)
 {
     String query = "a as b, b as a";
     ParserExpressionList parser(false);
-    ASTPtr ast = parseQuery(parser, query, 0);
+    ASTPtr ast = parseQuery(parser, query, 0, 0);
 
     Aliases aliases;
-    aliases["a"] = parseQuery(parser, "b as a", 0)->children[0];
-    aliases["b"] = parseQuery(parser, "a as b", 0)->children[0];
+    aliases["a"] = parseQuery(parser, "b as a", 0, 0)->children[0];
+    aliases["b"] = parseQuery(parser, "a as b", 0, 0)->children[0];
 
     Settings settings;
     QueryNormalizer::Data normalizer_data(aliases, settings);
diff --git a/src/Interpreters/tests/in_join_subqueries_preprocessor.cpp b/src/Interpreters/tests/in_join_subqueries_preprocessor.cpp
index 9a17f03f32a7..412557f13b8c 100644
--- a/src/Interpreters/tests/in_join_subqueries_preprocessor.cpp
+++ b/src/Interpreters/tests/in_join_subqueries_preprocessor.cpp
@@ -1224,7 +1224,7 @@ bool parse(DB::ASTPtr & ast, const std::string & query)
     std::string message;
     auto begin = query.data();
     auto end = begin + query.size();
-    ast = DB::tryParseQuery(parser, begin, end, message, false, "", false, 0);
+    ast = DB::tryParseQuery(parser, begin, end, message, false, "", false, 0, 0);
     return ast != nullptr;
 }
 
diff --git a/src/Interpreters/tests/logical_expressions_optimizer.cpp b/src/Interpreters/tests/logical_expressions_optimizer.cpp
deleted file mode 100644
index c21c4dda2999..000000000000
--- a/src/Interpreters/tests/logical_expressions_optimizer.cpp
+++ /dev/null
@@ -1,295 +0,0 @@
-#include <Parsers/ASTSelectQuery.h>
-#include <Parsers/ParserSelectQuery.h>
-#include <Parsers/parseQuery.h>
-#include <Parsers/queryToString.h>
-#include <Interpreters/LogicalExpressionsOptimizer.h>
-#include <Core/Settings.h>
-#include <Common/typeid_cast.h>
-
-#include <iostream>
-#include <vector>
-#include <utility>
-#include <string>
-#include <algorithm>
-
-
-namespace
-{
-
-struct TestEntry
-{
-    std::string input;
-    std::string expected_output;
-    UInt64 limit;
-};
-
-using TestEntries = std::vector<TestEntry>;
-using TestResult = std::pair<bool, std::string>;
-
-void run();
-void performTests(const TestEntries & entries);
-TestResult check(const TestEntry & entry);
-bool parse(DB::ASTPtr & ast, const std::string & query);
-bool equals(const DB::ASTPtr & lhs, const DB::ASTPtr & rhs);
-void reorder(DB::IAST * ast);
-
-
-void run()
-{
-    /// NOTE: Queries are not always realistic, but we are only interested in the syntax.
-    TestEntries entries =
-    {
-        {
-            "SELECT 1",
-            "SELECT 1",
-            3
-        },
-
-        // WHERE
-
-        {
-            "SELECT name, value FROM report WHERE (name = 'Alice') OR (name = 'Bob') OR (name = 'Carol')",
-            "SELECT name, value FROM report WHERE (name = 'Alice') OR (name = 'Bob') OR (name = 'Carol')",
-            4
-        },
-
-        {
-            "SELECT name, value FROM report WHERE (name = 'Alice') OR (name = 'Bob') OR (name = 'Carol')",
-            "SELECT name, value FROM report WHERE name IN ('Alice', 'Bob', 'Carol')",
-            3
-        },
-
-        {
-            "SELECT name, value FROM report WHERE (name = 'Alice') OR (name = 'Bob') OR (name = 'Carol')",
-            "SELECT name, value FROM report WHERE name IN ('Alice', 'Bob', 'Carol')",
-            2
-        },
-
-        {
-            "SELECT name, value FROM report WHERE (name = 'Alice') OR (value = 1000) OR (name = 'Bob') OR (name = 'Carol')",
-            "SELECT name, value FROM report WHERE (value = 1000) OR name IN ('Alice', 'Bob', 'Carol')",
-            2
-        },
-
-        {
-            "SELECT name, value FROM report WHERE (name = 'Alice') OR (value = 1000) OR (name = 'Bob') OR (name = 'Carol') OR (value = 2000)",
-            "SELECT name, value FROM report WHERE name IN ('Alice', 'Bob', 'Carol') OR value IN (1000, 2000)",
-            2
-        },
-
-        {
-            "SELECT value FROM report WHERE ((value + 1) = 1000) OR ((2 * value) = 2000) OR ((2 * value) = 4000) OR ((value + 1) = 3000)",
-            "SELECT value FROM report WHERE ((value + 1) IN (1000, 3000)) OR ((2 * value) IN (2000, 4000))",
-            2
-        },
-
-        {
-            "SELECT name, value FROM report WHERE ((name = 'Alice') OR (name = 'Bob') OR (name = 'Carol')) AND ((value = 1000) OR (value = 2000))",
-            "SELECT name, value FROM report WHERE name IN ('Alice', 'Bob', 'Carol') AND ((value = 1000) OR (value = 2000))",
-            3
-        },
-
-        // PREWHERE
-
-        {
-            "SELECT name, value FROM report PREWHERE (name = 'Alice') OR (name = 'Bob') OR (name = 'Carol')",
-            "SELECT name, value FROM report PREWHERE (name = 'Alice') OR (name = 'Bob') OR (name = 'Carol')",
-            4
-        },
-
-        {
-            "SELECT name, value FROM report PREWHERE (name = 'Alice') OR (name = 'Bob') OR (name = 'Carol')",
-            "SELECT name, value FROM report PREWHERE name IN ('Alice', 'Bob', 'Carol')",
-            3
-        },
-
-        {
-            "SELECT name, value FROM report PREWHERE (name = 'Alice') OR (name = 'Bob') OR (name = 'Carol')",
-            "SELECT name, value FROM report PREWHERE name IN ('Alice', 'Bob', 'Carol')",
-            2
-        },
-
-        {
-            "SELECT name, value FROM report PREWHERE (name = 'Alice') OR (value = 1000) OR (name = 'Bob') OR (name = 'Carol')",
-            "SELECT name, value FROM report PREWHERE (value = 1000) OR name IN ('Alice', 'Bob', 'Carol')",
-            2
-        },
-
-        {
-            "SELECT name, value FROM report PREWHERE (name = 'Alice') OR (value = 1000) OR (name = 'Bob') OR (name = 'Carol') OR (value = 2000)",
-            "SELECT name, value FROM report PREWHERE name IN ('Alice', 'Bob', 'Carol') OR value IN (1000, 2000)",
-            2
-        },
-
-        {
-            "SELECT value FROM report PREWHERE ((value + 1) = 1000) OR ((2 * value) = 2000) OR ((2 * value) = 4000) OR ((value + 1) = 3000)",
-            "SELECT value FROM report PREWHERE (value + 1) IN (1000, 3000) OR (2 * value) IN (2000, 4000)",
-            2
-        },
-
-        // HAVING
-
-        {
-            "SELECT number, count() FROM (SELECT * FROM system.numbers LIMIT 10) GROUP BY number HAVING number = 1",
-            "SELECT number, count() FROM (SELECT * FROM system.numbers LIMIT 10) GROUP BY number HAVING number = 1",
-            2
-        },
-
-        {
-            "SELECT number, count() FROM (SELECT * FROM system.numbers LIMIT 10) GROUP BY number HAVING (number = 1) OR (number = 2)",
-            "SELECT number, count() FROM (SELECT * FROM system.numbers LIMIT 10) GROUP BY number HAVING number IN (1, 2)",
-            2
-        },
-
-        {
-            "SELECT number, count() FROM (SELECT * FROM system.numbers LIMIT 10) GROUP BY number HAVING (number = 1) OR (number = 2)",
-            "SELECT number, count() FROM (SELECT * FROM system.numbers LIMIT 10) GROUP BY number HAVING (number = 1) OR (number = 2)",
-            3
-        },
-
-        {
-            "SELECT number, count() FROM (SELECT * FROM system.numbers LIMIT 10) GROUP BY number HAVING ((number + 1) = 1) OR ((number + 1) = 2) OR ((number + 3) = 7)",
-            "SELECT number, count() FROM (SELECT * FROM system.numbers LIMIT 10) GROUP BY number HAVING ((number + 3) = 7) OR (number + 1) IN (1, 2)",
-            2
-        },
-
-        // PREWHERE + WHERE + HAVING
-
-        {
-            "SELECT number, count(), 1 AS T, 2 AS U FROM (SELECT * FROM system.numbers LIMIT 10) PREWHERE (U = 1) OR (U = 2) "
-            "WHERE (T = 1) OR (T = 2) GROUP BY number HAVING (number = 1) OR (number = 2)",
-            "SELECT number, count(), 1 AS T, 2 AS U FROM (SELECT * FROM system.numbers LIMIT 10) PREWHERE U IN (1, 2) "
-            "WHERE T IN (1, 2) GROUP BY number HAVING number IN (1, 2)",
-            2
-        },
-
-        {
-            "SELECT number, count(), 1 AS T, 2 AS U FROM (SELECT * FROM system.numbers LIMIT 10) PREWHERE (U = 1) OR (U = 2) OR (U = 3) "
-            "WHERE (T = 1) OR (T = 2) GROUP BY number HAVING (number = 1) OR (number = 2)",
-            "SELECT number, count(), 1 AS T, 2 AS U FROM (SELECT * FROM system.numbers LIMIT 10) PREWHERE U IN (1, 2, 3) "
-            "WHERE (T = 1) OR (T = 2) GROUP BY number HAVING (number = 1) OR (number = 2)",
-            3
-        },
-
-        {
-            "SELECT x = 1 OR x=2 OR (x = 3 AS x3) AS y, 4 AS x",
-            "SELECT x IN (1, 2, 3) AS y, 4 AS x",
-            2
-        }
-    };
-
-    performTests(entries);
-}
-
-void performTests(const TestEntries & entries)
-{
-    unsigned int count = 0;
-    unsigned int i = 1;
-
-    for (const auto & entry : entries)
-    {
-        auto res = check(entry);
-        if (res.first)
-        {
-            ++count;
-            std::cout << "Test " << i << " passed.
";
-        }
-        else
-            std::cout << "Test " << i << " failed. Expected: " << entry.expected_output << ". Received: " << res.second << "
";
-
-        ++i;
-    }
-    std::cout << count << " out of " << entries.size() << " test(s) passed.
";
-}
-
-TestResult check(const TestEntry & entry)
-{
-    try
-    {
-        /// Parse and optimize the incoming query.
-        DB::ASTPtr ast_input;
-        if (!parse(ast_input, entry.input))
-            return TestResult(false, "parse error");
-
-        auto select_query = typeid_cast<DB::ASTSelectQuery *>(&*ast_input);
-
-        DB::LogicalExpressionsOptimizer optimizer(select_query, entry.limit);
-        optimizer.perform();
-
-        /// Parse the expected result.
-        DB::ASTPtr ast_expected;
-        if (!parse(ast_expected, entry.expected_output))
-            return TestResult(false, "parse error");
-
-        /// Compare the optimized query and the expected result.
-        bool res = equals(ast_input, ast_expected);
-        std::string output = DB::queryToString(ast_input);
-
-        return TestResult(res, output);
-    }
-    catch (DB::Exception & e)
-    {
-        return TestResult(false, e.displayText());
-    }
-}
-
-bool parse(DB::ASTPtr & ast, const std::string & query)
-{
-    DB::ParserSelectQuery parser;
-    std::string message;
-    auto begin = query.data();
-    auto end = begin + query.size();
-    ast = DB::tryParseQuery(parser, begin, end, message, false, "", false, 0);
-    return ast != nullptr;
-}
-
-bool equals(const DB::ASTPtr & lhs, const DB::ASTPtr & rhs)
-{
-    DB::ASTPtr lhs_reordered = lhs->clone();
-    reorder(&*lhs_reordered);
-
-    DB::ASTPtr rhs_reordered = rhs->clone();
-    reorder(&*rhs_reordered);
-
-    return lhs_reordered->getTreeHash() == rhs_reordered->getTreeHash();
-}
-
-void reorderImpl(DB::IAST * ast)
-{
-    if (ast == nullptr)
-        return;
-
-    auto & children = ast->children;
-    if (children.empty())
-        return;
-
-    for (auto & child : children)
-        reorderImpl(&*child);
-
-    std::sort(children.begin(), children.end(), [](const DB::ASTPtr & lhs, const DB::ASTPtr & rhs)
-    {
-        return lhs->getTreeHash() < rhs->getTreeHash();
-    });
-}
-
-void reorder(DB::IAST * ast)
-{
-    if (ast == nullptr)
-        return;
-
-    auto select_query = typeid_cast<DB::ASTSelectQuery *>(ast);
-    if (select_query == nullptr)
-        return;
-
-    reorderImpl(select_query->where().get());
-    reorderImpl(select_query->prewhere().get());
-    reorderImpl(select_query->having().get());
-}
-
-}
-
-int main()
-{
-    run();
-    return 0;
-}
diff --git a/src/Parsers/tests/create_parser.cpp b/src/Parsers/tests/create_parser.cpp
index 6137d4d18da1..fbdc967fa2a4 100644
--- a/src/Parsers/tests/create_parser.cpp
+++ b/src/Parsers/tests/create_parser.cpp
@@ -12,7 +12,7 @@ int main(int, char **)
 
     std::string input = "CREATE TABLE hits (URL String, UserAgentMinor2 FixedString(2), EventTime DateTime) ENGINE = Log";
     ParserCreateQuery parser;
-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0);
+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0, 0);
 
     formatAST(*ast, std::cerr);
     std::cerr << std::endl;
diff --git a/src/Parsers/tests/gtest_dictionary_parser.cpp b/src/Parsers/tests/gtest_dictionary_parser.cpp
index 25dcbb326add..60eeab5f6153 100644
--- a/src/Parsers/tests/gtest_dictionary_parser.cpp
+++ b/src/Parsers/tests/gtest_dictionary_parser.cpp
@@ -43,7 +43,7 @@ TEST(ParserDictionaryDDL, SimpleDictionary)
                    " RANGE(MIN second_column MAX third_column)";
 
     ParserCreateDictionaryQuery parser;
-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0);
+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0, 0);
     ASTCreateQuery * create = ast->as<ASTCreateQuery>();
     EXPECT_EQ(create->table, "dict1");
     EXPECT_EQ(create->database, "test");
@@ -139,7 +139,7 @@ TEST(ParserDictionaryDDL, AttributesWithMultipleProperties)
                    " SOURCE(CLICKHOUSE(HOST 'localhost'))";
 
     ParserCreateDictionaryQuery parser;
-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0);
+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0, 0);
     ASTCreateQuery * create = ast->as<ASTCreateQuery>();
     EXPECT_EQ(create->table, "dict2");
     EXPECT_EQ(create->database, "");
@@ -186,7 +186,7 @@ TEST(ParserDictionaryDDL, CustomAttributePropertiesOrder)
                    " LIFETIME(300)";
 
     ParserCreateDictionaryQuery parser;
-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0);
+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0, 0);
     ASTCreateQuery * create = ast->as<ASTCreateQuery>();
 
     /// test attributes
@@ -241,7 +241,7 @@ TEST(ParserDictionaryDDL, NestedSource)
                    " RANGE(MIN second_column MAX third_column)";
 
     ParserCreateDictionaryQuery parser;
-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0);
+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0, 0);
     ASTCreateQuery * create = ast->as<ASTCreateQuery>();
     EXPECT_EQ(create->table, "dict4");
     EXPECT_EQ(create->database, "");
@@ -289,7 +289,7 @@ TEST(ParserDictionaryDDL, Formatting)
                    " RANGE(MIN second_column MAX third_column)";
 
     ParserCreateDictionaryQuery parser;
-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0);
+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0, 0);
     ASTCreateQuery * create = ast->as<ASTCreateQuery>();
     auto str = serializeAST(*create, true);
     EXPECT_EQ(str, "CREATE DICTIONARY test.dict5 (`key_column1` UInt64 DEFAULT 1 HIERARCHICAL INJECTIVE, `key_column2` String DEFAULT '', `second_column` UInt8 EXPRESSION intDiv(50, rand() % 1000), `third_column` UInt8) PRIMARY KEY key_column1, key_column2 SOURCE(MYSQL(HOST 'localhost' PORT 9000 USER 'default' REPLICA (HOST '127.0.0.1' PRIORITY 1) PASSWORD '')) LIFETIME(MIN 1 MAX 10) LAYOUT(CACHE(SIZE_IN_CELLS 50)) RANGE(MIN second_column MAX third_column)");
@@ -300,7 +300,7 @@ TEST(ParserDictionaryDDL, ParseDropQuery)
     String input1 = "DROP DICTIONARY test.dict1";
 
     ParserDropQuery parser;
-    ASTPtr ast1 = parseQuery(parser, input1.data(), input1.data() + input1.size(), "", 0);
+    ASTPtr ast1 = parseQuery(parser, input1.data(), input1.data() + input1.size(), "", 0, 0);
     ASTDropQuery * drop1 = ast1->as<ASTDropQuery>();
 
     EXPECT_TRUE(drop1->is_dictionary);
@@ -311,7 +311,7 @@ TEST(ParserDictionaryDDL, ParseDropQuery)
 
     String input2 = "DROP DICTIONARY IF EXISTS dict2";
 
-    ASTPtr ast2 = parseQuery(parser, input2.data(), input2.data() + input2.size(), "", 0);
+    ASTPtr ast2 = parseQuery(parser, input2.data(), input2.data() + input2.size(), "", 0, 0);
     ASTDropQuery * drop2 = ast2->as<ASTDropQuery>();
 
     EXPECT_TRUE(drop2->is_dictionary);
@@ -326,7 +326,7 @@ TEST(ParserDictionaryDDL, ParsePropertiesQueries)
     String input1 = "SHOW CREATE DICTIONARY test.dict1";
 
     ParserTablePropertiesQuery parser;
-    ASTPtr ast1 = parseQuery(parser, input1.data(), input1.data() + input1.size(), "", 0);
+    ASTPtr ast1 = parseQuery(parser, input1.data(), input1.data() + input1.size(), "", 0, 0);
     ASTShowCreateDictionaryQuery * show1 = ast1->as<ASTShowCreateDictionaryQuery>();
 
     EXPECT_EQ(show1->table, "dict1");
@@ -335,7 +335,7 @@ TEST(ParserDictionaryDDL, ParsePropertiesQueries)
 
     String input2 = "EXISTS DICTIONARY dict2";
 
-    ASTPtr ast2 = parseQuery(parser, input2.data(), input2.data() + input2.size(), "", 0);
+    ASTPtr ast2 = parseQuery(parser, input2.data(), input2.data() + input2.size(), "", 0, 0);
     ASTExistsDictionaryQuery * show2 = ast2->as<ASTExistsDictionaryQuery>();
 
     EXPECT_EQ(show2->table, "dict2");
diff --git a/src/Parsers/tests/select_parser.cpp b/src/Parsers/tests/select_parser.cpp
index f5d94746aa1a..7711f0d25270 100644
--- a/src/Parsers/tests/select_parser.cpp
+++ b/src/Parsers/tests/select_parser.cpp
@@ -22,7 +22,7 @@ try
         " FORMAT TabSeparated";
 
     ParserQueryWithOutput parser;
-    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0);
+    ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), "", 0, 0);
 
     std::cout << "Success." << std::endl;
     formatAST(*ast, std::cerr);
diff --git a/src/Storages/tests/gtest_transform_query_for_external_database.cpp b/src/Storages/tests/gtest_transform_query_for_external_database.cpp
index 385e47201a51..22407ca1bd9e 100644
--- a/src/Storages/tests/gtest_transform_query_for_external_database.cpp
+++ b/src/Storages/tests/gtest_transform_query_for_external_database.cpp
@@ -48,7 +48,7 @@ static State & state()
 static void check(const std::string & query, const std::string & expected, const Context & context, const NamesAndTypesList & columns)
 {
     ParserSelectQuery parser;
-    ASTPtr ast = parseQuery(parser, query, 1000);
+    ASTPtr ast = parseQuery(parser, query, 1000, 1000);
     SelectQueryInfo query_info;
     query_info.syntax_analyzer_result = SyntaxAnalyzer(context).analyzeSelect(ast, columns);
     query_info.query = ast;
diff --git a/tests/queries/0_stateless/00328_long_case_construction.sql b/tests/queries/0_stateless/00328_long_case_construction.sql
index d0fc90d0884c..aa653d667f7e 100644
--- a/tests/queries/0_stateless/00328_long_case_construction.sql
+++ b/tests/queries/0_stateless/00328_long_case_construction.sql
@@ -1,4 +1,3 @@
-
 /* Trivial case */
 
 SELECT CASE WHEN 1 THEN 2 WHEN 3 THEN  4 ELSE 5 END;
diff --git a/tests/queries/0_stateless/00990_hasToken.sh b/tests/queries/0_stateless/00990_hasToken.sh
index 4ccb77b8ecc9..4ef62bc69c0f 100755
--- a/tests/queries/0_stateless/00990_hasToken.sh
+++ b/tests/queries/0_stateless/00990_hasToken.sh
@@ -5,4 +5,4 @@ CURDIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
 
 # We should have correct env vars from shell_config.sh to run this test
 
-python $CURDIR/00990_hasToken.python | ${CLICKHOUSE_CLIENT} -nm
+python $CURDIR/00990_hasToken.python | ${CLICKHOUSE_CLIENT} --max_query_size 1048576 -nm
diff --git a/tests/queries/0_stateless/01068_parens.sql b/tests/queries/0_stateless/01068_parens.sql
index 7cb4f097b15f..429487605947 100644
--- a/tests/queries/0_stateless/01068_parens.sql
+++ b/tests/queries/0_stateless/01068_parens.sql
@@ -1,1 +1,2 @@
-((((((((((((((SELECT((((((((((((((((((((((((((((((((1))))))))))))))))))))))))))))))))))))))))))))))
+SET max_parser_depth = 10000;
+((((((((((((((SELECT((((((((((((((((((((((((((((((((1))))))))))))))))))))))))))))))))))))))))))))));
diff --git a/tests/queries/0_stateless/01196_max_parser_depth.reference b/tests/queries/0_stateless/01196_max_parser_depth.reference
new file mode 100644
index 000000000000..a72c1b18aa2c
--- /dev/null
+++ b/tests/queries/0_stateless/01196_max_parser_depth.reference
@@ -0,0 +1,3 @@
+Code: 306
+Code: 306
+Code: 306
diff --git a/tests/queries/0_stateless/01196_max_parser_depth.sh b/tests/queries/0_stateless/01196_max_parser_depth.sh
new file mode 100755
index 000000000000..471c1c22ecb0
--- /dev/null
+++ b/tests/queries/0_stateless/01196_max_parser_depth.sh
@@ -0,0 +1,8 @@
+#!/usr/bin/env bash
+
+CURDIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
+. $CURDIR/../shell_config.sh
+
+{ printf "select "; for x in {1..1000}; do printf "coalesce(null, "; done; printf "1"; for x in {1..1000}; do printf ")"; done; } | $CLICKHOUSE_CLIENT 2>&1 | grep -o -F 'Code: 306'
+{ printf "select "; for x in {1..1000}; do printf "coalesce(null, "; done; printf "1"; for x in {1..1000}; do printf ")"; done; } | $CLICKHOUSE_LOCAL 2>&1 | grep -o -F 'Code: 306'
+{ printf "select "; for x in {1..1000}; do printf "coalesce(null, "; done; printf "1"; for x in {1..1000}; do printf ")"; done; } | $CLICKHOUSE_CURL --data-binary @- -vsS "$CLICKHOUSE_URL" 2>&1 | grep -o -F 'Code: 306'
