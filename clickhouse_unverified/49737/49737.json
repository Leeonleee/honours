{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 49737,
  "instance_id": "ClickHouse__ClickHouse-49737",
  "issue_numbers": [
    "49509"
  ],
  "base_commit": "8adc878049b1182a9b8c7778a8f1055a545b5139",
  "patch": "diff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex 9adfcf7fef79..002211127a2a 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -3608,6 +3608,9 @@ void MergeTreeData::checkPartDynamicColumns(MutableDataPartPtr & part, DataParts\n     const auto & part_columns = part->getColumns();\n     for (const auto & part_column : part_columns)\n     {\n+        if (part_column.name == LightweightDeleteDescription::FILTER_COLUMN.name)\n+            continue;\n+\n         auto storage_column = columns.getPhysical(part_column.name);\n         if (!storage_column.type->hasDynamicSubcolumns())\n             continue;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02352_lightweight_delete_and_object_column.reference b/tests/queries/0_stateless/02352_lightweight_delete_and_object_column.reference\nnew file mode 100644\nindex 000000000000..3ad5abd03aea\n--- /dev/null\n+++ b/tests/queries/0_stateless/02352_lightweight_delete_and_object_column.reference\n@@ -0,0 +1,1 @@\n+99\ndiff --git a/tests/queries/0_stateless/02352_lightweight_delete_and_object_column.sql b/tests/queries/0_stateless/02352_lightweight_delete_and_object_column.sql\nnew file mode 100644\nindex 000000000000..cd29d0ac4458\n--- /dev/null\n+++ b/tests/queries/0_stateless/02352_lightweight_delete_and_object_column.sql\n@@ -0,0 +1,14 @@\n+DROP TABLE IF EXISTS t_obj SYNC;\n+\n+SET allow_experimental_object_type=1;\n+\n+CREATE TABLE t_obj(id Int32, name Object('json')) ENGINE = MergeTree() ORDER BY id;\n+\n+INSERT INTO t_obj select number, '{\"a\" : \"' || toString(number) || '\"}' FROM numbers(100);\n+\n+DELETE FROM t_obj WHERE id = 10;\n+\n+SELECT COUNT() FROM t_obj;\n+\n+DROP TABLE t_obj SYNC;\n+\n",
  "problem_statement": "error: There is no physical column _row_exists in table\n\r\n**Describe the unexpected behaviour**\r\nThere is still repeating error message in the log: `There is no physical column _row_exists in table. (NO_SUCH_COLUMN_IN_TABLE)` (see full trace below).  The log is full of this messages.\r\nIt is impossible for me to find out which table it is. \r\n\r\n\r\n* Which ClickHouse server version to use\r\n`23.4.2.11` as well as `23.3.1.2823`\r\n\r\n\r\n**Error message and/or stacktrace**\r\n```\r\n2023.05.04 15:09:45.563899 [ 3411394 ] {12b6cbf7-cfc3-4661-833d-cbc8ede1865a::202309_3_3_0_4} <Error> MutatePlainMergeTreeTask: Code: 16. DB::Exception: There is no physical column _row_exists in table. (NO_SUCH_COLUMN_IN_TABLE) (version 23.4.2.11 (official build))\r\n2023.05.04 15:09:45.564204 [ 3411394 ] {12b6cbf7-cfc3-4661-833d-cbc8ede1865a::202309_3_3_0_4} <Error> virtual bool DB::MutatePlainMergeTreeTask::executeStep(): Code: 16. DB::Exception: There is no physical column _row_exists in table. (NO_SUCH_COLUMN_IN_TABLE), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) in /usr/bin/clickhouse\r\n1. ? in /usr/bin/clickhouse\r\n2. DB::ColumnsDescription::getPhysical(String const&) const in /usr/bin/clickhouse\r\n3. DB::MergeTreeData::checkPartDynamicColumns(std::shared_ptr<DB::IMergeTreeDataPart>&, std::unique_lock<std::mutex>&) const in /usr/bin/clickhouse\r\n4. DB::MergeTreeData::renameTempPartAndReplaceImpl(std::shared_ptr<DB::IMergeTreeDataPart>&, DB::MergeTreeData::Transaction&, std::unique_lock<std::mutex>&, std::vector<std::shared_ptr<DB::IMergeTreeDataPart const>, std::allocator<std::shared_ptr<DB::IMergeTreeDataPart const>>>*) in /usr/bin/clickhouse\r\n5. DB::MergeTreeData::renameTempPartAndReplace(std::shared_ptr<DB::IMergeTreeDataPart>&, DB::MergeTreeData::Transaction&) in /usr/bin/clickhouse\r\n6. DB::MutatePlainMergeTreeTask::executeStep() in /usr/bin/clickhouse\r\n7. DB::MergeTreeBackgroundExecutor<DB::DynamicRuntimeQueue>::routine(std::shared_ptr<DB::TaskRuntimeData>) in /usr/bin/clickhouse\r\n8. DB::MergeTreeBackgroundExecutor<DB::DynamicRuntimeQueue>::threadFunction() in /usr/bin/clickhouse\r\n9. ThreadPoolImpl<ThreadFromGlobalPoolImpl<false>>::worker(std::__list_iterator<ThreadFromGlobalPoolImpl<false>, void*>) in /usr/bin/clickhouse\r\n10. void std::__function::__policy_invoker<void ()>::__call_impl<std::__function::__default_alloc_func<ThreadFromGlobalPoolImpl<false>::ThreadFromGlobalPoolImpl<void ThreadPoolImpl<ThreadFromGlobalPoolImpl<false>>::scheduleImpl<void>(std::function<void ()>, long, std::optional<unsigned long>, bool)::'lambda0'()>(void&&)::'lambda'(), void ()>>(std::__function::__policy_storage const*) in /usr/bin/clickhouse\r\n11. ThreadPoolImpl<std::thread>::worker(std::__list_iterator<std::thread, void*>) in /usr/bin/clickhouse\r\n12. ? in /usr/bin/clickhouse\r\n13. ? in ?\r\n14. clone in ?\r\n (version 23.4.2.11 (official build))\r\n```\r\n\n",
  "hints_text": "> It is impossible for me to find out which table it is.\r\n\r\nThe log message contains the table id:  `{12b6cbf7-cfc3-4661-833d-cbc8ede1865a::202309_3_3_0_4}`\r\n`select ... from system.tables where uuid='12b6cbf7-cfc3-4661-833d-cbc8ede1865a'`\n//update:I have added the \"DROP TABLE\" line, which I inadvertently omitted in my first version//\r\n\r\nThank you, @tavplubix, for your help.\r\nI managed to obtain a table, but when I attempted to optimize it using the command `OPTIMIZE TABLE billing.aggregated_report_1d_full FINAL;`, it didn't have the desired effect.\r\n\r\nMy solution involved executing the following SQL commands:\r\n\r\n```sql\r\nBACKUP TABLE billing.aggregated_report_1d_full TO File('billing.aggregated_report_1d_full.zip')\r\nDROP TABLE billing.aggregated_report_1d_full \r\nSET allow_experimental_object_type = 1  -- because there is an 'Object' column that uses JSON data type\r\nRESTORE TABLE billing.aggregated_report_1d_full FROM File('billing.aggregated_report_1d_full.zip')\r\n```\r\n\r\nThis approach seems to have solved the issue, but I will wait for some time before closing it, to see if it reoccurs.\ncc: @davenger, @CurtizJ \nI have made some new findings regarding this issue:\r\n\r\n* After backing up, deleting, and restoring the table, the problem seems to be resolved.\r\n* I was able to reproduce the problem by attempting to delete certain columns using the following query:\r\n\r\n```\r\nDELETE FROM billing.aggregated_report_1d_full WHERE ts > '2023-04-04'\r\n\r\nQuery id: ac9733bd-94eb-4252-8651-fea7cf3014da\r\n\r\n\r\n0 rows in set. Elapsed: 0.330 sec. \r\n\r\nReceived exception from server (version 23.4.2):\r\nCode: 341. DB::Exception: Received from localhost:9000. DB::Exception: Exception happened during execution of mutation 'mutation_6.txt' with part '202304_5_5_1' reason: 'Code: 16. DB::Exception: There is no physical column _row_exists in table. (NO_SUCH_COLUMN_IN_TABLE) (version 23.4.2.11 (official build))'. This error maybe retryable or not. In case of unretryable error, mutation can be killed with KILL MUTATION query. (UNFINISHED)\r\n```\r\n\r\nGiven that the issue is reproducible, I will keep it open for further investigation.",
  "created_at": "2023-05-10T13:45:46Z"
}