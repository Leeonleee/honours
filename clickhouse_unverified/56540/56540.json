{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 56540,
  "instance_id": "ClickHouse__ClickHouse-56540",
  "issue_numbers": [
    "55993"
  ],
  "base_commit": "4cc2d6baa59ca5bb1f8c2e921d10cc7103c5060a",
  "patch": "diff --git a/docs/en/sql-reference/functions/string-functions.md b/docs/en/sql-reference/functions/string-functions.md\nindex 4df987b5e2a5..4b6e03563013 100644\n--- a/docs/en/sql-reference/functions/string-functions.md\n+++ b/docs/en/sql-reference/functions/string-functions.md\n@@ -429,7 +429,7 @@ SELECT format('{} {}', 'Hello', 'World')\n \n ## concat\n \n-Concatenates the strings listed in the arguments without separator.\n+Concatenates the given arguments.\n \n **Syntax**\n \n@@ -439,7 +439,9 @@ concat(s1, s2, ...)\n \n **Arguments**\n \n-Values of type String or FixedString.\n+At least two values of arbitrary type.\n+\n+Arguments which are not of types [String](../../sql-reference/data-types/string.md) or [FixedString](../../sql-reference/data-types/fixedstring.md) are converted to strings using their default serialization. As this decreases performance, it is not recommended to use non-String/FixedString arguments.\n \n **Returned values**\n \n@@ -449,6 +451,8 @@ If any of arguments is `NULL`, the function returns `NULL`.\n \n **Example**\n \n+Query:\n+\n ``` sql\n SELECT concat('Hello, ', 'World!');\n ```\n@@ -461,6 +465,20 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+Query:\n+\n+```sql\n+SELECT concat(42, 144);\n+```\n+\n+Result:\n+\n+```result\n+\u250c\u2500concat(42, 144)\u2500\u2510\n+\u2502 42144           \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## concatAssumeInjective\n \n Like [concat](#concat) but assumes that `concat(s1, s2, ...) \u2192 sn` is injective. Can be used for optimization of GROUP BY.\n@@ -526,6 +544,8 @@ Concatenates the given strings with a given separator.\n concatWithSeparator(sep, expr1, expr2, expr3...)\n ```\n \n+Alias: `concat_ws`\n+\n **Arguments**\n \n - sep \u2014 separator. Const [String](../../sql-reference/data-types/string.md) or [FixedString](../../sql-reference/data-types/fixedstring.md).\ndiff --git a/src/Columns/ColumnStringHelpers.h b/src/Columns/ColumnStringHelpers.h\nindex 851486e490ad..97b52506ae0e 100644\n--- a/src/Columns/ColumnStringHelpers.h\n+++ b/src/Columns/ColumnStringHelpers.h\n@@ -62,7 +62,7 @@ class WriteHelper\n         return buffer;\n     }\n \n-    inline void rowWritten()\n+    void rowWritten()\n     {\n         if constexpr (std::is_same_v<ColumnType, ColumnFixedString>)\n         {\ndiff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex e3ec7ebd3201..d7c2c70884b6 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -1247,9 +1247,9 @@ struct ConvertImplGenericToString\n \n             FormatSettings format_settings;\n             auto serialization = type.getDefaultSerialization();\n-            for (size_t i = 0; i < size; ++i)\n+            for (size_t row = 0; row < size; ++row)\n             {\n-                serialization->serializeText(col_from, i, write_buffer, format_settings);\n+                serialization->serializeText(col_from, row, write_buffer, format_settings);\n                 write_helper.rowWritten();\n             }\n \ndiff --git a/src/Functions/concat.cpp b/src/Functions/concat.cpp\nindex 9eb222d8c093..f426f662868e 100644\n--- a/src/Functions/concat.cpp\n+++ b/src/Functions/concat.cpp\n@@ -2,14 +2,13 @@\n #include <DataTypes/DataTypeString.h>\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionHelpers.h>\n+#include <Functions/FunctionsConversion.h>\n #include <Functions/GatherUtils/Algorithms.h>\n #include <Functions/GatherUtils/Sinks.h>\n-#include <Functions/GatherUtils/Slices.h>\n #include <Functions/GatherUtils/Sources.h>\n #include <Functions/IFunction.h>\n #include <IO/WriteHelpers.h>\n #include <base/map.h>\n-#include <base/range.h>\n \n #include \"formatString.h\"\n \n@@ -17,9 +16,7 @@ namespace DB\n {\n namespace ErrorCodes\n {\n-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n-    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n-    extern const int ILLEGAL_COLUMN;\n+extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n }\n \n using namespace GatherUtils;\n@@ -32,7 +29,7 @@ class ConcatImpl : public IFunction\n {\n public:\n     static constexpr auto name = Name::name;\n-    explicit ConcatImpl(ContextPtr context_) : context(context_) {}\n+    explicit ConcatImpl(ContextPtr context_) : context(context_) { }\n     static FunctionPtr create(ContextPtr context) { return std::make_shared<ConcatImpl>(context); }\n \n     String getName() const override { return name; }\n@@ -56,18 +53,6 @@ class ConcatImpl : public IFunction\n                 getName(),\n                 arguments.size());\n \n-        for (const auto arg_idx : collections::range(0, arguments.size()))\n-        {\n-            const auto * arg = arguments[arg_idx].get();\n-            if (!isStringOrFixedString(arg))\n-                throw Exception(\n-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                    \"Illegal type {} of argument {} of function {}\",\n-                    arg->getName(),\n-                    arg_idx + 1,\n-                    getName());\n-        }\n-\n         return std::make_shared<DataTypeString>();\n     }\n \n@@ -76,11 +61,10 @@ class ConcatImpl : public IFunction\n         /// Format function is not proven to be faster for two arguments.\n         /// Actually there is overhead of 2 to 5 extra instructions for each string for checking empty strings in FormatImpl.\n         /// Though, benchmarks are really close, for most examples we saw executeBinary is slightly faster (0-3%).\n-        /// For 3 and more arguments FormatImpl is much faster (up to 50-60%).\n+        /// For 3 and more arguments FormatStringImpl is much faster (up to 50-60%).\n         if (arguments.size() == 2)\n             return executeBinary(arguments, input_rows_count);\n-        else\n-            return executeFormatImpl(arguments, input_rows_count);\n+        return executeFormatImpl(arguments, input_rows_count);\n     }\n \n private:\n@@ -123,6 +107,7 @@ class ConcatImpl : public IFunction\n         std::vector<const ColumnString::Offsets *> offsets(num_arguments);\n         std::vector<size_t> fixed_string_sizes(num_arguments);\n         std::vector<std::optional<String>> constant_strings(num_arguments);\n+        std::vector<ColumnString::MutablePtr> converted_col_ptrs(num_arguments);\n         bool has_column_string = false;\n         bool has_column_fixed_string = false;\n         for (size_t i = 0; i < num_arguments; ++i)\n@@ -145,8 +130,29 @@ class ConcatImpl : public IFunction\n                 constant_strings[i] = const_col->getValue<String>();\n             }\n             else\n-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of argument of function {}\",\n-                    column->getName(), getName());\n+            {\n+                /// A non-String/non-FixedString-type argument: use the default serialization to convert it to String\n+                auto full_column = column->convertToFullIfNeeded();\n+                auto serialization = arguments[i].type->getDefaultSerialization();\n+                auto converted_col_str = ColumnString::create();\n+                ColumnStringHelpers::WriteHelper write_helper(*converted_col_str, column->size());\n+                auto & write_buffer = write_helper.getWriteBuffer();\n+                FormatSettings format_settings;\n+                for (size_t row = 0; row < column->size(); ++row)\n+                {\n+                    serialization->serializeText(*full_column, row, write_buffer, format_settings);\n+                    write_helper.rowWritten();\n+                }\n+                write_helper.finalize();\n+\n+                /// Same as the normal `ColumnString` branch\n+                has_column_string = true;\n+                data[i] = &converted_col_str->getChars();\n+                offsets[i] = &converted_col_str->getOffsets();\n+\n+                /// Keep the pointer alive\n+                converted_col_ptrs[i] = std::move(converted_col_str);\n+            }\n         }\n \n         String pattern;\n@@ -155,7 +161,7 @@ class ConcatImpl : public IFunction\n         for (size_t i = 0; i < num_arguments; ++i)\n             pattern += \"{}\";\n \n-        FormatImpl::formatExecute(\n+        FormatStringImpl::formatExecute(\n             has_column_string,\n             has_column_fixed_string,\n             std::move(pattern),\n@@ -185,14 +191,15 @@ using FunctionConcat = ConcatImpl<NameConcat, false>;\n using FunctionConcatAssumeInjective = ConcatImpl<NameConcatAssumeInjective, true>;\n \n \n-/// Also works with arrays.\n+/// Works with arrays via `arrayConcat`, maps via `mapConcat`, and tuples via `tupleConcat`.\n+/// Additionally, allows concatenation of arbitrary types that can be cast to string using the corresponding default serialization.\n class ConcatOverloadResolver : public IFunctionOverloadResolver\n {\n public:\n     static constexpr auto name = \"concat\";\n     static FunctionOverloadResolverPtr create(ContextPtr context) { return std::make_unique<ConcatOverloadResolver>(context); }\n \n-    explicit ConcatOverloadResolver(ContextPtr context_) : context(context_) {}\n+    explicit ConcatOverloadResolver(ContextPtr context_) : context(context_) { }\n \n     String getName() const override { return name; }\n     size_t getNumberOfArguments() const override { return 0; }\n@@ -200,29 +207,26 @@ class ConcatOverloadResolver : public IFunctionOverloadResolver\n \n     FunctionBasePtr buildImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & return_type) const override\n     {\n-        if (isArray(arguments.at(0).type))\n-        {\n+        if (std::ranges::all_of(arguments, [](const auto & elem) { return isArray(elem.type); }))\n             return FunctionFactory::instance().getImpl(\"arrayConcat\", context)->build(arguments);\n-        }\n-        else if (isMap(arguments.at(0).type))\n-        {\n+        if (std::ranges::all_of(arguments, [](const auto & elem) { return isMap(elem.type); }))\n             return FunctionFactory::instance().getImpl(\"mapConcat\", context)->build(arguments);\n-        }\n-        else if (isTuple(arguments.at(0).type))\n-        {\n+        if (std::ranges::all_of(arguments, [](const auto & elem) { return isTuple(elem.type); }))\n             return FunctionFactory::instance().getImpl(\"tupleConcat\", context)->build(arguments);\n-        }\n-        else\n-            return std::make_unique<FunctionToFunctionBaseAdaptor>(\n-                FunctionConcat::create(context), collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; }), return_type);\n+        return std::make_unique<FunctionToFunctionBaseAdaptor>(\n+            FunctionConcat::create(context),\n+            collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; }),\n+            return_type);\n     }\n \n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n         if (arguments.size() < 2)\n-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+            throw Exception(\n+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n                 \"Number of arguments for function {} doesn't match: passed {}, should be at least 2.\",\n-                getName(), arguments.size());\n+                getName(),\n+                arguments.size());\n \n         /// We always return Strings from concat, even if arguments were fixed strings.\n         return std::make_shared<DataTypeString>();\ndiff --git a/src/Functions/concatWithSeparator.cpp b/src/Functions/concatWithSeparator.cpp\nindex bfd1bc392db1..f295d86943f9 100644\n--- a/src/Functions/concatWithSeparator.cpp\n+++ b/src/Functions/concatWithSeparator.cpp\n@@ -1,5 +1,5 @@\n-#include <Columns/ColumnString.h>\n #include <Columns/ColumnFixedString.h>\n+#include <Columns/ColumnString.h>\n #include <DataTypes/DataTypeString.h>\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionHelpers.h>\n@@ -14,9 +14,9 @@ namespace DB\n {\n namespace ErrorCodes\n {\n-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n-    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n-    extern const int ILLEGAL_COLUMN;\n+extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+extern const int ILLEGAL_COLUMN;\n }\n \n namespace\n@@ -26,7 +26,7 @@ class ConcatWithSeparatorImpl : public IFunction\n {\n public:\n     static constexpr auto name = Name::name;\n-    explicit ConcatWithSeparatorImpl(ContextPtr context_) : context(context_) {}\n+    explicit ConcatWithSeparatorImpl(ContextPtr context_) : context(context_) { }\n \n     static FunctionPtr create(ContextPtr context) { return std::make_shared<ConcatWithSeparatorImpl>(context); }\n \n@@ -113,8 +113,7 @@ class ConcatWithSeparatorImpl : public IFunction\n             else if (const ColumnConst * const_col = checkAndGetColumnConstStringOrFixedString(column.get()))\n                 constant_strings[2 * i] = const_col->getValue<String>();\n             else\n-                throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n-                    \"Illegal column {} of argument of function {}\", column->getName(), getName());\n+                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of argument of function {}\", column->getName(), getName());\n         }\n \n         String pattern;\n@@ -122,7 +121,7 @@ class ConcatWithSeparatorImpl : public IFunction\n         for (size_t i = 0; i < num_args; ++i)\n             pattern += \"{}\";\n \n-        FormatImpl::formatExecute(\n+        FormatStringImpl::formatExecute(\n             has_column_string,\n             has_column_fixed_string,\n             std::move(pattern),\n@@ -156,14 +155,14 @@ using FunctionConcatWithSeparatorAssumeInjective = ConcatWithSeparatorImpl<NameC\n REGISTER_FUNCTION(ConcatWithSeparator)\n {\n     factory.registerFunction<FunctionConcatWithSeparator>(FunctionDocumentation{\n-        .description=R\"(\n+        .description = R\"(\n Returns the concatenation strings separated by string separator. Syntax: concatWithSeparator(sep, expr1, expr2, expr3...)\n         )\",\n         .examples{{\"concatWithSeparator\", \"SELECT concatWithSeparator('a', '1', '2', '3')\", \"\"}},\n         .categories{\"String\"}});\n \n     factory.registerFunction<FunctionConcatWithSeparatorAssumeInjective>(FunctionDocumentation{\n-        .description=R\"(\n+        .description = R\"(\n Same as concatWithSeparator, the difference is that you need to ensure that concatWithSeparator(sep, expr1, expr2, expr3...) \u2192 result is injective, it will be used for optimization of GROUP BY.\n \n The function is named \u201cinjective\u201d if it always returns different result for different values of arguments. In other words: different arguments never yield identical result.\n@@ -171,7 +170,7 @@ The function is named \u201cinjective\u201d if it always returns different result for\n         .examples{{\"concatWithSeparatorAssumeInjective\", \"SELECT concatWithSeparatorAssumeInjective('a', '1', '2', '3')\", \"\"}},\n         .categories{\"String\"}});\n \n-    /// Compatibility with Spark:\n+    /// Compatibility with Spark and MySQL:\n     factory.registerAlias(\"concat_ws\", \"concatWithSeparator\", FunctionFactory::CaseInsensitive);\n }\n \ndiff --git a/src/Functions/formatString.cpp b/src/Functions/formatString.cpp\nindex ee6e26b775ad..8e0b3a238cb2 100644\n--- a/src/Functions/formatString.cpp\n+++ b/src/Functions/formatString.cpp\n@@ -110,7 +110,7 @@ class FormatFunction : public IFunction\n                     column->getName(), getName());\n         }\n \n-        FormatImpl::formatExecute(\n+        FormatStringImpl::formatExecute(\n             has_column_string,\n             has_column_fixed_string,\n             std::move(pattern),\ndiff --git a/src/Functions/formatString.h b/src/Functions/formatString.h\nindex 44fbdac93786..315e5c06227e 100644\n--- a/src/Functions/formatString.h\n+++ b/src/Functions/formatString.h\n@@ -1,24 +1,19 @@\n #pragma once\n \n #include <Columns/ColumnString.h>\n-#include <base/types.h>\n-#include <Common/Exception.h>\n-#include <Common/StringUtils/StringUtils.h>\n #include <Common/format.h>\n #include <Common/memcpySmall.h>\n-\n+#include <base/types.h>\n \n #include <algorithm>\n #include <optional>\n #include <string>\n-#include <utility>\n #include <vector>\n \n-\n namespace DB\n {\n \n-struct FormatImpl\n+struct FormatStringImpl\n {\n     static constexpr size_t right_padding = 15;\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00727_concat.reference b/tests/queries/0_stateless/00727_concat.reference\nindex af5626b4a114..1e102051fd0f 100644\n--- a/tests/queries/0_stateless/00727_concat.reference\n+++ b/tests/queries/0_stateless/00727_concat.reference\n@@ -1,1 +1,67 @@\n-Hello, world!\n+-- Const string + non-const arbitrary type\n+With 42\n+With 43\n+With 44\n+With 45\n+With 46\n+With 47\n+With 48\n+With 49\n+With 50\n+With 51\n+With 52\n+With 53\n+With 42.42\n+With 43.43\n+With 44\n+With true\n+With false\n+With foo\n+With bar\n+With foo\n+With bar\n+With foo\n+With bar\n+With foo\n+With bar\n+With 42\n+With 42\n+With fae310ca-d52a-4923-9e9b-02bf67f4b009\n+With 2023-11-14\n+With 2123-11-14\n+With 2023-11-14 05:50:12\n+With 2023-11-14 05:50:12.123\n+With hallo\n+With [\\'foo\\',\\'bar\\']\n+With {\"foo\":\"bar\"}\n+With (42,\\'foo\\')\n+With {42:\\'foo\\'}\n+With 122.233.64.201\n+With 2001:1:130f:2:3:9c0:876a:130b\n+With (42,43)\n+With [(0,0),(10,0),(10,10),(0,10)]\n+With [[(20,20),(50,20),(50,50),(20,50)],[(30,30),(50,50),(50,30)]]\n+With [[[(0,0),(10,0),(10,10),(0,10)]],[[(20,20),(50,20),(50,50),(20,50)],[(30,30),(50,50),(50,30)]]]\n+-- SimpleAggregateFunction\n+With 42\n+With 4\n+-- Nested\n+With [\\'foo\\',\\'bar\\'][\\'qaz\\',\\'qux\\']\n+-- NULL arguments\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+-- Various arguments tests\n+Non-const strings\n+Two arguments test\n+Three arguments test\n+3 arguments test with int type\n+42144\n+42144255\n+42144\n+42144255\n+Testing the alias\ndiff --git a/tests/queries/0_stateless/00727_concat.sql b/tests/queries/0_stateless/00727_concat.sql\nindex 800ebd5ec539..edeaf9340ddc 100644\n--- a/tests/queries/0_stateless/00727_concat.sql\n+++ b/tests/queries/0_stateless/00727_concat.sql\n@@ -1,1 +1,89 @@\n-SELECT CONCAT('Hello', ', ', 'world!');\n+-- Tags: no-fasttest\n+-- no-fasttest: json type needs rapidjson library, geo types need s2 geometry\n+\n+SET allow_experimental_object_type = 1;\n+SET allow_suspicious_low_cardinality_types=1;\n+\n+SELECT '-- Const string + non-const arbitrary type';\n+SELECT concat('With ', materialize(42 :: Int8));\n+SELECT concat('With ', materialize(43 :: Int16));\n+SELECT concat('With ', materialize(44 :: Int32));\n+SELECT concat('With ', materialize(45 :: Int64));\n+SELECT concat('With ', materialize(46 :: Int128));\n+SELECT concat('With ', materialize(47 :: Int256));\n+SELECT concat('With ', materialize(48 :: UInt8));\n+SELECT concat('With ', materialize(49 :: UInt16));\n+SELECT concat('With ', materialize(50 :: UInt32));\n+SELECT concat('With ', materialize(51 :: UInt64));\n+SELECT concat('With ', materialize(52 :: UInt128));\n+SELECT concat('With ', materialize(53 :: UInt256));\n+SELECT concat('With ', materialize(42.42 :: Float32));\n+SELECT concat('With ', materialize(43.43 :: Float64));\n+SELECT concat('With ', materialize(44.44 :: Decimal(2)));\n+SELECT concat('With ', materialize(true :: Bool));\n+SELECT concat('With ', materialize(false :: Bool));\n+SELECT concat('With ', materialize('foo' :: String));\n+SELECT concat('With ', materialize('bar' :: FixedString(3)));\n+SELECT concat('With ', materialize('foo' :: Nullable(String)));\n+SELECT concat('With ', materialize('bar' :: Nullable(FixedString(3))));\n+SELECT concat('With ', materialize('foo' :: LowCardinality(String)));\n+SELECT concat('With ', materialize('bar' :: LowCardinality(FixedString(3))));\n+SELECT concat('With ', materialize('foo' :: LowCardinality(Nullable(String))));\n+SELECT concat('With ', materialize('bar' :: LowCardinality(Nullable(FixedString(3)))));\n+SELECT concat('With ', materialize(42 :: LowCardinality(Nullable(UInt32))));\n+SELECT concat('With ', materialize(42 :: LowCardinality(UInt32)));\n+SELECT concat('With ', materialize('fae310ca-d52a-4923-9e9b-02bf67f4b009' :: UUID));\n+SELECT concat('With ', materialize('2023-11-14' :: Date));\n+SELECT concat('With ', materialize('2123-11-14' :: Date32));\n+SELECT concat('With ', materialize('2023-11-14 05:50:12' :: DateTime('Europe/Amsterdam')));\n+SELECT concat('With ', materialize('2023-11-14 05:50:12.123' :: DateTime64(3, 'Europe/Amsterdam')));\n+SELECT concat('With ', materialize('hallo' :: Enum('hallo' = 1)));\n+SELECT concat('With ', materialize(['foo', 'bar'] :: Array(String)));\n+SELECT concat('With ', materialize('{\"foo\": \"bar\"}' :: JSON));\n+SELECT concat('With ', materialize((42, 'foo') :: Tuple(Int32, String)));\n+SELECT concat('With ', materialize(map(42, 'foo') :: Map(Int32, String)));\n+SELECT concat('With ', materialize('122.233.64.201' :: IPv4));\n+SELECT concat('With ', materialize('2001:0001:130F:0002:0003:09C0:876A:130B' :: IPv6));\n+SELECT concat('With ', materialize((42, 43) :: Point));\n+SELECT concat('With ', materialize([(0,0),(10,0),(10,10),(0,10)] :: Ring));\n+SELECT concat('With ', materialize([[(20, 20), (50, 20), (50, 50), (20, 50)], [(30, 30), (50, 50), (50, 30)]] :: Polygon));\n+SELECT concat('With ', materialize([[[(0, 0), (10, 0), (10, 10), (0, 10)]], [[(20, 20), (50, 20), (50, 50), (20, 50)],[(30, 30), (50, 50), (50, 30)]]] :: MultiPolygon));\n+\n+SELECT '-- SimpleAggregateFunction';\n+DROP TABLE IF EXISTS concat_saf_test;\n+CREATE TABLE concat_saf_test(x SimpleAggregateFunction(max, Int32)) ENGINE=MergeTree ORDER BY tuple();\n+INSERT INTO concat_saf_test VALUES (42);\n+INSERT INTO concat_saf_test SELECT max(number) FROM numbers(5);\n+SELECT concat('With ', x) FROM concat_saf_test ORDER BY x DESC;\n+DROP TABLE concat_saf_test;\n+\n+SELECT '-- Nested';\n+DROP TABLE IF EXISTS concat_nested_test;\n+CREATE TABLE concat_nested_test(attrs Nested(k String, v String)) ENGINE = MergeTree ORDER BY tuple();\n+INSERT INTO concat_nested_test VALUES (['foo', 'bar'], ['qaz', 'qux']);\n+SELECT concat('With ', attrs.k, attrs.v) FROM concat_nested_test;\n+DROP TABLE concat_nested_test;\n+\n+SELECT '-- NULL arguments';\n+SELECT concat(NULL, NULL);\n+SELECT concat(NULL, materialize(NULL :: Nullable(UInt64)));\n+SELECT concat(materialize(NULL :: Nullable(UInt64)), materialize(NULL :: Nullable(UInt64)));\n+SELECT concat(42, materialize(NULL :: Nullable(UInt64)));\n+SELECT concat('42', materialize(NULL :: Nullable(UInt64)));\n+SELECT concat(42, materialize(NULL :: Nullable(UInt64)), materialize(NULL :: Nullable(UInt64)));\n+SELECT concat('42', materialize(NULL :: Nullable(UInt64)), materialize(NULL :: Nullable(UInt64)));\n+\n+SELECT '-- Various arguments tests';\n+SELECT concat(materialize('Non-const'), materialize(' strings'));\n+SELECT concat('Two arguments ', 'test');\n+SELECT concat('Three ', 'arguments', ' test');\n+SELECT concat(materialize(3 :: Int64), ' arguments test', ' with int type');\n+SELECT concat(materialize(42 :: Int32), materialize(144 :: UInt64));\n+SELECT concat(materialize(42 :: Int32), materialize(144 :: UInt64), materialize(255 :: UInt32));\n+SELECT concat(42, 144);\n+SELECT concat(42, 144, 255);\n+\n+SELECT CONCAT('Testing the ', 'alias');\n+\n+SELECT concat();  -- { serverError 42 }\n+SELECT concat(1); -- { serverError 42 }\ndiff --git a/tests/queries/0_stateless/02233_interpolate_1.sql b/tests/queries/0_stateless/02233_interpolate_1.sql\nindex 3d416b27f452..d589a18421be 100644\n--- a/tests/queries/0_stateless/02233_interpolate_1.sql\n+++ b/tests/queries/0_stateless/02233_interpolate_1.sql\n@@ -26,7 +26,7 @@ SELECT n, source, inter FROM (\n # Test INTERPOLATE with incompatible expression - should produce error\n SELECT n, source, inter FROM (\n    SELECT toFloat32(number % 10) AS n, 'original' AS source, number as inter FROM numbers(10) WHERE number % 3 = 1\n-) ORDER BY n WITH FILL FROM 0 TO 11.51 STEP 0.5 INTERPOLATE (inter AS inter||'inter'); -- { serverError 44 }\n+) ORDER BY n WITH FILL FROM 0 TO 11.51 STEP 0.5 INTERPOLATE (inter AS reverse(inter)); -- { serverError 44 }\n \n # Test INTERPOLATE with column from WITH FILL expression - should produce error\n SELECT n, source, inter FROM (\ndiff --git a/tests/queries/0_stateless/02389_analyzer_nested_lambda.reference b/tests/queries/0_stateless/02389_analyzer_nested_lambda.reference\nindex 935c53358c05..68eb282a6a1b 100644\n--- a/tests/queries/0_stateless/02389_analyzer_nested_lambda.reference\n+++ b/tests/queries/0_stateless/02389_analyzer_nested_lambda.reference\n@@ -117,5 +117,5 @@ SELECT arrayMap(x -> concat(concat(concat(concat(concat(toString(id), '___\\0____\n FROM test_table WHERE concat(concat(concat(toString(id), '___\\0_______\\0____'), toString(id)), concat(toString(id), NULL), toString(id));\n SELECT '--';\n --\n-SELECT arrayMap(x -> concat(toString(id), arrayMap(x -> toString(1), [NULL])), [NULL]) FROM test_table; -- { serverError 44 };\n+SELECT arrayMap(x -> splitByChar(toString(id), arrayMap(x -> toString(1), [NULL])), [NULL]) FROM test_table; -- { serverError 44 };\n DROP TABLE test_table;\ndiff --git a/tests/queries/0_stateless/02389_analyzer_nested_lambda.sql b/tests/queries/0_stateless/02389_analyzer_nested_lambda.sql\nindex 8f8b5537da90..48e84246d1c9 100644\n--- a/tests/queries/0_stateless/02389_analyzer_nested_lambda.sql\n+++ b/tests/queries/0_stateless/02389_analyzer_nested_lambda.sql\n@@ -122,7 +122,7 @@ FROM test_table WHERE concat(concat(concat(toString(id), '___\\0_______\\0____'),\n \n SELECT '--';\n \n-SELECT arrayMap(x -> concat(toString(id), arrayMap(x -> toString(1), [NULL])), [NULL]) FROM test_table; -- { serverError 44 };\n+SELECT arrayMap(x -> splitByChar(toString(id), arrayMap(x -> toString(1), [NULL])), [NULL]) FROM test_table; -- { serverError 44 };\n \n DROP TABLE test_table;\n \ndiff --git a/tests/queries/0_stateless/02521_analyzer_array_join_crash.reference b/tests/queries/0_stateless/02521_analyzer_array_join_crash.reference\nindex 59da8ccad1a7..5e7728e05908 100644\n--- a/tests/queries/0_stateless/02521_analyzer_array_join_crash.reference\n+++ b/tests/queries/0_stateless/02521_analyzer_array_join_crash.reference\n@@ -8,4 +8,4 @@ SELECT id, value_element, value FROM test_table ARRAY JOIN [[1,2,3]] AS value_el\n 0\t[1,2,3]\t3\n SELECT value_element, value FROM test_table ARRAY JOIN [1048577] AS value_element, arrayMap(x -> value_element, ['']) AS value;\n 1048577\t[1048577]\n-SELECT arrayFilter(x -> notEmpty(concat(x)), [NULL, NULL]) FROM system.one ARRAY JOIN [1048577] AS elem, arrayMap(x -> concat(x, elem, ''), ['']) AS unused; -- { serverError 44 }\n+SELECT arrayFilter(x -> notEmpty(concat(x)), [NULL, NULL]) FROM system.one ARRAY JOIN [1048577] AS elem, arrayMap(x -> splitByChar(x, elem), ['']) AS unused; -- { serverError 44 }\ndiff --git a/tests/queries/0_stateless/02521_analyzer_array_join_crash.sql b/tests/queries/0_stateless/02521_analyzer_array_join_crash.sql\nindex c7641a3bee04..53606e01ab7b 100644\n--- a/tests/queries/0_stateless/02521_analyzer_array_join_crash.sql\n+++ b/tests/queries/0_stateless/02521_analyzer_array_join_crash.sql\n@@ -17,7 +17,7 @@ SELECT id, value_element, value FROM test_table ARRAY JOIN [[1,2,3]] AS value_el\n \n SELECT value_element, value FROM test_table ARRAY JOIN [1048577] AS value_element, arrayMap(x -> value_element, ['']) AS value;\n \n-SELECT arrayFilter(x -> notEmpty(concat(x)), [NULL, NULL]) FROM system.one ARRAY JOIN [1048577] AS elem, arrayMap(x -> concat(x, elem, ''), ['']) AS unused; -- { serverError 44 }\n+SELECT arrayFilter(x -> notEmpty(concat(x)), [NULL, NULL]) FROM system.one ARRAY JOIN [1048577] AS elem, arrayMap(x -> splitByChar(x, elem), ['']) AS unused; -- { serverError 44 }\n \n -- { echoOff }\n \ndiff --git a/tests/queries/0_stateless/02775_show_columns_called_from_clickhouse.sql b/tests/queries/0_stateless/02775_show_columns_called_from_clickhouse.sql\nindex 89073bd2943d..3bbcbb1a535c 100644\n--- a/tests/queries/0_stateless/02775_show_columns_called_from_clickhouse.sql\n+++ b/tests/queries/0_stateless/02775_show_columns_called_from_clickhouse.sql\n@@ -5,7 +5,7 @@\n -- Tests the output of SHOW COLUMNS when called through the ClickHouse protocol.\n \n -- -----------------------------------------------------------------------------------\n--- Please keep this test in-sync with 02775_show_columns_called_through_mysql.sql\n+-- Please keep this test in-sync with 02775_show_columns_called_from_clickhouse.expect\n -- -----------------------------------------------------------------------------------\n \n DROP TABLE IF EXISTS tab;\ndiff --git a/tests/queries/0_stateless/02775_show_columns_called_from_mysql.expect b/tests/queries/0_stateless/02775_show_columns_called_from_mysql.expect\nindex bef5bd10ff31..8ba5774820e3 100755\n--- a/tests/queries/0_stateless/02775_show_columns_called_from_mysql.expect\n+++ b/tests/queries/0_stateless/02775_show_columns_called_from_mysql.expect\n@@ -6,7 +6,7 @@\n # Tests the output of SHOW COLUMNS when called through the MySQL protocol.\n \n # -----------------------------------------------------------------------------------\n-# Please keep this test in-sync with 02775_show_columns_called_through_clickhouse.sql\n+# Please keep this test in-sync with 02775_show_columns_called_from_clickhouse.sql\n # -----------------------------------------------------------------------------------\n \n set basedir [file dirname $argv0]\n",
  "problem_statement": "MySQL compatibility: concat and mixed String/Integer arguments\nRequired for Tableau Online (group by quarter)\r\n\r\n```\r\nSELECT `cell_towers`.`radio`                              AS `radio`,\r\n       SUM(`cell_towers`.`area`)                          AS `sum_area_ok`,\r\n       ADDDATE(CONCAT(DATE_FORMAT(`cell_towers`.`created`, '%Y-'), (3 * (QUARTER(`cell_towers`.`created`) - 1) + 1),\r\n                      '-01 00:00:00'), INTERVAL 0 SECOND) AS `tqr_created_ok`\r\nFROM `cell_towers`\r\nGROUP BY 1, 3\r\n\r\n```\r\n\r\nfails with\r\n\r\n```\r\nDB::Exception: Illegal column Int64 of argument of function concat. (ILLEGAL_COLUMN) (version 23.10.1.1) (from 127.0.0.1:45220) (in query: SELECT `cell_towers`.`radio` AS `radio`, SUM(`cell_towers`.`area`) AS `sum_area_ok`, ADDDATE( CONCAT( DATE_FORMAT( `cell_towers`.`created`, '%Y-' ), (3*(QUARTER(`cell_towers`.`created`)-1)+1), '-01 00:00:00' ), INTERVAL 0 SECOND ) AS `tqr_created_ok` FROM `cell_towers` GROUP BY 1, 3)\r\n```\r\n\r\n**How to reproduce**\r\n* Which ClickHouse server version to use: latest master + https://github.com/ClickHouse/ClickHouse/pull/55960\r\n* Which interface to use, if matters: MySQL\r\n* Sample data for all these tables: [cell towers](https://clickhouse.com/docs/en/getting-started/example-datasets/cell-towers)\r\n\r\n**Expected behavior**\r\n\r\nThis \"construction\"\r\n```\r\nSELECT \r\n  ADDDATE(\r\n     CONCAT(\r\n       DATE_FORMAT(`cell_towers`.`created`, '%Y-'),      -- concat arg #1 (String)\r\n       (3 * (QUARTER(`cell_towers`.`created`) - 1) + 1), -- concat arg #2 (UInt64)\r\n       '-01 00:00:00'                                    -- concat arg #3 (String)\r\n     ), \r\n     INTERVAL 0 SECOND\r\n  )\r\nFROM cell_towers\r\nLIMIT 5;\r\n```\r\nworks with mixed String/Integer arguments.\n",
  "hints_text": "`concat` in PG and mysql supports all types which can be cast to a String.\r\n\r\n```sql\r\nselect now() || ' time';\r\n             ?column?\r\n-----------------------------------\r\n 2023-10-24 22:20:06.83634+00 time\r\n\r\nselect concat ( now() ,  ' time', ' ', .1, ' ' , 111);\r\n+------------------------------------------------+\r\n| concat ( now() ,  ' time', ' ', .1, ' ' , 111) |\r\n+------------------------------------------------+\r\n| 2023-10-24 22:26:23 time 0.1 111               |\r\n+------------------------------------------------+\r\n```",
  "created_at": "2023-11-09T16:55:57Z",
  "modified_files": [
    "docs/en/sql-reference/functions/string-functions.md",
    "src/Columns/ColumnStringHelpers.h",
    "src/Functions/FunctionsConversion.h",
    "src/Functions/concat.cpp",
    "src/Functions/concatWithSeparator.cpp",
    "src/Functions/formatString.cpp",
    "src/Functions/formatString.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/00727_concat.reference",
    "tests/queries/0_stateless/00727_concat.sql",
    "tests/queries/0_stateless/02233_interpolate_1.sql",
    "tests/queries/0_stateless/02389_analyzer_nested_lambda.reference",
    "tests/queries/0_stateless/02389_analyzer_nested_lambda.sql",
    "tests/queries/0_stateless/02521_analyzer_array_join_crash.reference",
    "tests/queries/0_stateless/02521_analyzer_array_join_crash.sql",
    "tests/queries/0_stateless/02775_show_columns_called_from_clickhouse.sql",
    "tests/queries/0_stateless/02775_show_columns_called_from_mysql.expect"
  ]
}