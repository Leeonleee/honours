diff --git a/src/Client/ClientBase.cpp b/src/Client/ClientBase.cpp
index 78d8e7e3d6ad..cabe3aa01f01 100644
--- a/src/Client/ClientBase.cpp
+++ b/src/Client/ClientBase.cpp
@@ -70,7 +70,6 @@
 
 #include <boost/algorithm/string/case_conv.hpp>
 #include <boost/algorithm/string/replace.hpp>
-#include <boost/algorithm/string/split.hpp>
 #include <iostream>
 #include <filesystem>
 #include <limits>
diff --git a/src/DataTypes/DataTypeAggregateFunction.cpp b/src/DataTypes/DataTypeAggregateFunction.cpp
index ef7d86d2a812..09175617bf1c 100644
--- a/src/DataTypes/DataTypeAggregateFunction.cpp
+++ b/src/DataTypes/DataTypeAggregateFunction.cpp
@@ -257,8 +257,8 @@ static DataTypePtr create(const ASTPtr & arguments)
     }
     else
         throw Exception(ErrorCodes::BAD_ARGUMENTS,
-                        "Unexpected AST element passed as aggregate function name for data type AggregateFunction. "
-                        "Must be identifier or function.");
+                        "Unexpected AST element {} passed as aggregate function name for data type AggregateFunction. "
+                        "Must be identifier or function", data_type_ast->getID());
 
     for (size_t i = argument_types_start_idx; i < arguments->children.size(); ++i)
         argument_types.push_back(DataTypeFactory::instance().get(arguments->children[i]));
diff --git a/src/DataTypes/DataTypeFactory.cpp b/src/DataTypes/DataTypeFactory.cpp
index eb3bc973857c..6f7dcd65b835 100644
--- a/src/DataTypes/DataTypeFactory.cpp
+++ b/src/DataTypes/DataTypeFactory.cpp
@@ -2,7 +2,7 @@
 #include <DataTypes/DataTypeCustom.h>
 #include <Parsers/parseQuery.h>
 #include <Parsers/ParserCreateQuery.h>
-#include <Parsers/ASTFunction.h>
+#include <Parsers/ASTDataType.h>
 #include <Parsers/ASTIdentifier.h>
 #include <Parsers/ASTLiteral.h>
 #include <Common/typeid_cast.h>
@@ -22,7 +22,6 @@ namespace ErrorCodes
 {
     extern const int LOGICAL_ERROR;
     extern const int UNKNOWN_TYPE;
-    extern const int ILLEGAL_SYNTAX_FOR_DATA_TYPE;
     extern const int UNEXPECTED_AST_STRUCTURE;
     extern const int DATA_TYPE_CANNOT_HAVE_ARGUMENTS;
 }
@@ -83,15 +82,9 @@ DataTypePtr DataTypeFactory::tryGet(const ASTPtr & ast) const
 template <bool nullptr_on_error>
 DataTypePtr DataTypeFactory::getImpl(const ASTPtr & ast) const
 {
-    if (const auto * func = ast->as<ASTFunction>())
+    if (const auto * type = ast->as<ASTDataType>())
     {
-        if (func->parameters)
-        {
-            if constexpr (nullptr_on_error)
-                return nullptr;
-            throw Exception(ErrorCodes::ILLEGAL_SYNTAX_FOR_DATA_TYPE, "Data type cannot have multiple parenthesized parameters.");
-        }
-        return getImpl<nullptr_on_error>(func->name, func->arguments);
+        return getImpl<nullptr_on_error>(type->name, type->arguments);
     }
 
     if (const auto * ident = ast->as<ASTIdentifier>())
@@ -107,7 +100,7 @@ DataTypePtr DataTypeFactory::getImpl(const ASTPtr & ast) const
 
     if constexpr (nullptr_on_error)
         return nullptr;
-    throw Exception(ErrorCodes::UNEXPECTED_AST_STRUCTURE, "Unexpected AST element for data type.");
+    throw Exception(ErrorCodes::UNEXPECTED_AST_STRUCTURE, "Unexpected AST element for data type: {}.", ast->getID());
 }
 
 DataTypePtr DataTypeFactory::get(const String & family_name_param, const ASTPtr & parameters) const
diff --git a/src/DataTypes/DataTypeObject.cpp b/src/DataTypes/DataTypeObject.cpp
index 5636a46373f9..91b9bfcb2a58 100644
--- a/src/DataTypes/DataTypeObject.cpp
+++ b/src/DataTypes/DataTypeObject.cpp
@@ -4,9 +4,10 @@
 
 #include <Parsers/IAST.h>
 #include <Parsers/ASTLiteral.h>
-#include <Parsers/ASTFunction.h>
+#include <Parsers/ASTDataType.h>
 #include <IO/Operators.h>
 
+
 namespace DB
 {
 
@@ -53,13 +54,13 @@ static DataTypePtr create(const ASTPtr & arguments)
     ASTPtr schema_argument = arguments->children[0];
     bool is_nullable = false;
 
-    if (const auto * func = schema_argument->as<ASTFunction>())
+    if (const auto * type = schema_argument->as<ASTDataType>())
     {
-        if (func->name != "Nullable" || func->arguments->children.size() != 1)
+        if (type->name != "Nullable" || type->arguments->children.size() != 1)
             throw Exception(ErrorCodes::UNEXPECTED_AST_STRUCTURE,
-                "Expected 'Nullable(<schema_name>)' as parameter for type Object (function: {})", func->name);
+                "Expected 'Nullable(<schema_name>)' as parameter for type Object (function: {})", type->name);
 
-        schema_argument = func->arguments->children[0];
+        schema_argument = type->arguments->children[0];
         is_nullable = true;
     }
 
diff --git a/src/Databases/DatabasesCommon.cpp b/src/Databases/DatabasesCommon.cpp
index b8e9231f5c6f..d8151cf340a4 100644
--- a/src/Databases/DatabasesCommon.cpp
+++ b/src/Databases/DatabasesCommon.cpp
@@ -149,7 +149,7 @@ ASTPtr getCreateQueryFromStorage(const StoragePtr & storage, const ASTPtr & ast_
             columns = metadata_ptr->columns.getAll();
         for (const auto & column_name_and_type: columns)
         {
-            const auto & ast_column_declaration = std::make_shared<ASTColumnDeclaration>();
+            const auto ast_column_declaration = std::make_shared<ASTColumnDeclaration>();
             ast_column_declaration->name = column_name_and_type.name;
             /// parser typename
             {
@@ -164,7 +164,7 @@ ASTPtr getCreateQueryFromStorage(const StoragePtr & storage, const ASTPtr & ast_
                 if (!parser.parse(pos, ast_type, expected))
                 {
                     if (throw_on_error)
-                        throw Exception(ErrorCodes::LOGICAL_ERROR, "Cannot parser metadata of {}.{}",
+                        throw Exception(ErrorCodes::LOGICAL_ERROR, "Cannot parse metadata of {}.{}",
                                         backQuote(table_id.database_name), backQuote(table_id.table_name));
                     else
                         return nullptr;
diff --git a/src/Databases/PostgreSQL/DatabasePostgreSQL.cpp b/src/Databases/PostgreSQL/DatabasePostgreSQL.cpp
index a846e23cd4f8..032fc33ea164 100644
--- a/src/Databases/PostgreSQL/DatabasePostgreSQL.cpp
+++ b/src/Databases/PostgreSQL/DatabasePostgreSQL.cpp
@@ -12,9 +12,9 @@
 #include <Interpreters/evaluateConstantExpression.h>
 #include <Parsers/ASTCreateQuery.h>
 #include <Parsers/ASTFunction.h>
+#include <Parsers/ASTDataType.h>
 #include <Parsers/ParserCreateQuery.h>
 #include <Parsers/parseQuery.h>
-#include <Parsers/queryToString.h>
 #include <Common/escapeForFileName.h>
 #include <Common/parseRemoteDescription.h>
 #include <Databases/DatabaseFactory.h>
@@ -25,6 +25,7 @@
 #include <Core/Settings.h>
 #include <filesystem>
 
+
 namespace fs = std::filesystem;
 
 namespace DB
@@ -432,7 +433,7 @@ ASTPtr DatabasePostgreSQL::getCreateTableQueryImpl(const String & table_name, Co
     auto metadata_snapshot = storage->getInMemoryMetadataPtr();
     for (const auto & column_type_and_name : metadata_snapshot->getColumns().getOrdinary())
     {
-        const auto & column_declaration = std::make_shared<ASTColumnDeclaration>();
+        const auto column_declaration = std::make_shared<ASTColumnDeclaration>();
         column_declaration->name = column_type_and_name.name;
         column_declaration->type = getColumnDeclaration(column_type_and_name.type);
         columns_expression_list->children.emplace_back(column_declaration);
@@ -470,17 +471,15 @@ ASTPtr DatabasePostgreSQL::getColumnDeclaration(const DataTypePtr & data_type) c
     WhichDataType which(data_type);
 
     if (which.isNullable())
-        return makeASTFunction("Nullable", getColumnDeclaration(typeid_cast<const DataTypeNullable *>(data_type.get())->getNestedType()));
+        return makeASTDataType("Nullable", getColumnDeclaration(typeid_cast<const DataTypeNullable *>(data_type.get())->getNestedType()));
 
     if (which.isArray())
-        return makeASTFunction("Array", getColumnDeclaration(typeid_cast<const DataTypeArray *>(data_type.get())->getNestedType()));
+        return makeASTDataType("Array", getColumnDeclaration(typeid_cast<const DataTypeArray *>(data_type.get())->getNestedType()));
 
     if (which.isDateTime64())
-    {
-        return makeASTFunction("DateTime64", std::make_shared<ASTLiteral>(static_cast<UInt32>(6)));
-    }
+        return makeASTDataType("DateTime64", std::make_shared<ASTLiteral>(static_cast<UInt32>(6)));
 
-    return std::make_shared<ASTIdentifier>(data_type->getName());
+    return makeASTDataType(data_type->getName());
 }
 
 void registerDatabasePostgreSQL(DatabaseFactory & factory)
diff --git a/src/IO/WithFileSize.cpp b/src/IO/WithFileSize.cpp
index cbbcab83de2e..54747cef8afc 100644
--- a/src/IO/WithFileSize.cpp
+++ b/src/IO/WithFileSize.cpp
@@ -5,6 +5,7 @@
 #include <IO/ReadBufferFromFileDecorator.h>
 #include <IO/PeekableReadBuffer.h>
 
+
 namespace DB
 {
 
@@ -88,5 +89,4 @@ size_t getDataOffsetMaybeCompressed(const ReadBuffer & in)
     return in.count();
 }
 
-
 }
diff --git a/src/Interpreters/InterpreterShowCreateQuery.cpp b/src/Interpreters/InterpreterShowCreateQuery.cpp
index 16add79d2261..e5549b2e5396 100644
--- a/src/Interpreters/InterpreterShowCreateQuery.cpp
+++ b/src/Interpreters/InterpreterShowCreateQuery.cpp
@@ -1,9 +1,7 @@
 #include <Storages/IStorage.h>
 #include <Parsers/TablePropertiesQueriesASTs.h>
-#include <Parsers/formatAST.h>
 #include <Processors/Sources/SourceFromSingleChunk.h>
 #include <QueryPipeline/BlockIO.h>
-#include <DataTypes/DataTypesNumber.h>
 #include <DataTypes/DataTypeString.h>
 #include <Columns/ColumnString.h>
 #include <Common/typeid_cast.h>
diff --git a/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp b/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp
index 4821d607d0eb..3917ffb8823c 100644
--- a/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp
+++ b/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp
@@ -3,6 +3,7 @@
 #include <Parsers/IAST.h>
 #include <Parsers/ASTLiteral.h>
 #include <Parsers/ASTFunction.h>
+#include <Parsers/ASTDataType.h>
 #include <Parsers/ASTIdentifier.h>
 #include <Parsers/ASTAlterQuery.h>
 #include <Parsers/ASTCreateQuery.h>
@@ -16,7 +17,6 @@
 #include <Parsers/MySQL/ASTCreateDefines.h>
 
 #include <DataTypes/DataTypeFactory.h>
-#include <DataTypes/DataTypesNumber.h>
 #include <DataTypes/DataTypeNullable.h>
 #include <Parsers/MySQL/ASTDeclareIndex.h>
 #include <Common/quoteString.h>
@@ -29,6 +29,7 @@
 #include <Interpreters/applyTableOverride.h>
 #include <Storages/IStorage.h>
 
+
 namespace DB
 {
 
@@ -95,22 +96,22 @@ NamesAndTypesList getColumnsList(const ASTExpressionList * columns_definition)
         }
 
         ASTPtr data_type = declare_column->data_type;
-        auto * data_type_function = data_type->as<ASTFunction>();
+        auto * data_type_node = data_type->as<ASTDataType>();
 
-        if (data_type_function)
+        if (data_type_node)
         {
-            String type_name_upper = Poco::toUpper(data_type_function->name);
+            String type_name_upper = Poco::toUpper(data_type_node->name);
 
             if (is_unsigned)
             {
                 /// For example(in MySQL): CREATE TABLE test(column_name INT NOT NULL ... UNSIGNED)
                 if (type_name_upper.find("INT") != String::npos && !endsWith(type_name_upper, "SIGNED")
                     && !endsWith(type_name_upper, "UNSIGNED"))
-                    data_type_function->name = type_name_upper + " UNSIGNED";
+                    data_type_node->name = type_name_upper + " UNSIGNED";
             }
 
             if (type_name_upper == "SET")
-                data_type_function->arguments.reset();
+                data_type_node->arguments.reset();
 
             /// Transforms MySQL ENUM's list of strings to ClickHouse string-integer pairs
             /// For example ENUM('a', 'b', 'c') -> ENUM('a'=1, 'b'=2, 'c'=3)
@@ -119,7 +120,7 @@ NamesAndTypesList getColumnsList(const ASTExpressionList * columns_definition)
             if (type_name_upper.find("ENUM") != String::npos)
             {
                 UInt16 i = 0;
-                for (ASTPtr & child : data_type_function->arguments->children)
+                for (ASTPtr & child : data_type_node->arguments->children)
                 {
                     auto new_child = std::make_shared<ASTFunction>();
                     new_child->name = "equals";
@@ -133,10 +134,10 @@ NamesAndTypesList getColumnsList(const ASTExpressionList * columns_definition)
             }
 
             if (type_name_upper == "DATE")
-                data_type_function->name = "Date32";
+                data_type_node->name = "Date32";
         }
         if (is_nullable)
-            data_type = makeASTFunction("Nullable", data_type);
+            data_type = makeASTDataType("Nullable", data_type);
 
         columns_name_and_type.emplace_back(declare_column->name, DataTypeFactory::instance().get(data_type));
     }
@@ -156,7 +157,7 @@ static ColumnsDescription createColumnsDescription(const NamesAndTypesList & col
     /// (see git blame for details).
     auto column_name_and_type = columns_name_and_type.begin();
     const auto * declare_column_ast = columns_definition->children.begin();
-    for (; column_name_and_type != columns_name_and_type.end(); column_name_and_type++, declare_column_ast++)
+    for (; column_name_and_type != columns_name_and_type.end(); ++column_name_and_type, ++declare_column_ast)
     {
         const auto & declare_column = (*declare_column_ast)->as<MySQLParser::ASTDeclareColumn>();
         String comment;
@@ -482,7 +483,7 @@ ASTs InterpreterCreateImpl::getRewrittenQueries(
     {
         auto column_declaration = std::make_shared<ASTColumnDeclaration>();
         column_declaration->name = name;
-        column_declaration->type = makeASTFunction(type);
+        column_declaration->type = makeASTDataType(type);
         column_declaration->default_specifier = "MATERIALIZED";
         column_declaration->default_expression = std::make_shared<ASTLiteral>(default_value);
         column_declaration->children.emplace_back(column_declaration->type);
diff --git a/src/Interpreters/formatWithPossiblyHidingSecrets.h b/src/Interpreters/formatWithPossiblyHidingSecrets.h
index 039bcbc2bca8..ea8c295b1695 100644
--- a/src/Interpreters/formatWithPossiblyHidingSecrets.h
+++ b/src/Interpreters/formatWithPossiblyHidingSecrets.h
@@ -1,11 +1,14 @@
 #pragma once
-#include "Access/ContextAccess.h"
-#include "Interpreters/Context.h"
+
+#include <Access/ContextAccess.h>
+#include <Interpreters/Context.h>
+
 
 #include <Core/Settings.h>
 
 namespace DB
 {
+
 struct SecretHidingFormatSettings
 {
     // We can't store const Context& as there's a dangerous usage {.ctx = *getContext()}
@@ -24,4 +27,5 @@ inline String format(const SecretHidingFormatSettings & settings)
 
     return settings.query.formatWithPossiblyHidingSensitiveData(settings.max_length, settings.one_line, show_secrets);
 }
+
 }
diff --git a/src/Parsers/ASTColumnDeclaration.cpp b/src/Parsers/ASTColumnDeclaration.cpp
index 4a8a3d2967d3..c96499095d54 100644
--- a/src/Parsers/ASTColumnDeclaration.cpp
+++ b/src/Parsers/ASTColumnDeclaration.cpp
@@ -1,8 +1,6 @@
 #include <Parsers/ASTColumnDeclaration.h>
 #include <Common/quoteString.h>
 #include <IO/Operators.h>
-#include <Parsers/ASTLiteral.h>
-#include <DataTypes/DataTypeFactory.h>
 
 
 namespace DB
@@ -15,8 +13,6 @@ ASTPtr ASTColumnDeclaration::clone() const
 
     if (type)
     {
-        // Type may be an ASTFunction (e.g. `create table t (a Decimal(9,0))`),
-        // so we have to clone it properly as well.
         res->type = type->clone();
         res->children.push_back(res->type);
     }
diff --git a/src/Parsers/ASTDataType.cpp b/src/Parsers/ASTDataType.cpp
new file mode 100644
index 000000000000..3c17ae8c380a
--- /dev/null
+++ b/src/Parsers/ASTDataType.cpp
@@ -0,0 +1,57 @@
+#include <Parsers/ASTDataType.h>
+#include <Common/SipHash.h>
+#include <IO/Operators.h>
+
+
+namespace DB
+{
+
+String ASTDataType::getID(char delim) const
+{
+    return "DataType" + (delim + name);
+}
+
+ASTPtr ASTDataType::clone() const
+{
+    auto res = std::make_shared<ASTDataType>(*this);
+    res->children.clear();
+
+    if (arguments)
+    {
+        res->arguments = arguments->clone();
+        res->children.push_back(res->arguments);
+    }
+
+    return res;
+}
+
+void ASTDataType::updateTreeHashImpl(SipHash & hash_state, bool) const
+{
+    hash_state.update(name.size());
+    hash_state.update(name);
+    /// Children are hashed automatically.
+}
+
+void ASTDataType::formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const
+{
+    settings.ostr << (settings.hilite ? hilite_function : "") << name;
+
+    if (arguments && !arguments->children.empty())
+    {
+        settings.ostr << '(' << (settings.hilite ? hilite_none : "");
+
+        for (size_t i = 0, size = arguments->children.size(); i < size; ++i)
+        {
+            if (i != 0)
+                settings.ostr << ", ";
+
+            arguments->children[i]->formatImpl(settings, state, frame);
+        }
+
+        settings.ostr << (settings.hilite ? hilite_function : "") << ')';
+    }
+
+    settings.ostr << (settings.hilite ? hilite_none : "");
+}
+
+}
diff --git a/src/Parsers/ASTDataType.h b/src/Parsers/ASTDataType.h
new file mode 100644
index 000000000000..71d3aeaa4eb1
--- /dev/null
+++ b/src/Parsers/ASTDataType.h
@@ -0,0 +1,38 @@
+#pragma once
+
+#include <Parsers/ASTExpressionList.h>
+
+
+namespace DB
+{
+
+/// AST for data types, e.g. UInt8 or Tuple(x UInt8, y Enum(a = 1))
+class ASTDataType : public IAST
+{
+public:
+    String name;
+    ASTPtr arguments;
+
+    String getID(char delim) const override;
+    ASTPtr clone() const override;
+    void updateTreeHashImpl(SipHash & hash_state, bool ignore_aliases) const override;
+    void formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const override;
+};
+
+template <typename... Args>
+std::shared_ptr<ASTDataType> makeASTDataType(const String & name, Args &&... args)
+{
+    auto data_type = std::make_shared<ASTDataType>();
+    data_type->name = name;
+
+    if constexpr (sizeof...(args))
+    {
+        data_type->arguments = std::make_shared<ASTExpressionList>();
+        data_type->children.push_back(data_type->arguments);
+        data_type->arguments->children = { std::forward<Args>(args)... };
+    }
+
+    return data_type;
+}
+
+}
diff --git a/src/Parsers/ASTFunction.h b/src/Parsers/ASTFunction.h
index 3a94691f25da..be2b6beae54e 100644
--- a/src/Parsers/ASTFunction.h
+++ b/src/Parsers/ASTFunction.h
@@ -46,7 +46,7 @@ class ASTFunction : public ASTWithAlias
 
     NullsAction nulls_action = NullsAction::EMPTY;
 
-    /// do not print empty parentheses if there are no args - compatibility with new AST for data types and engine names.
+    /// do not print empty parentheses if there are no args - compatibility with engine names.
     bool no_empty_args = false;
 
     /// Specifies where this function-like expression is used.
diff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp
index d4fc9a4bc4d3..865d07faaa78 100644
--- a/src/Parsers/ExpressionElementParsers.cpp
+++ b/src/Parsers/ExpressionElementParsers.cpp
@@ -9,8 +9,8 @@
 #include <Common/PODArray.h>
 #include <Common/StringUtils.h>
 #include <Common/typeid_cast.h>
-#include "Parsers/CommonParsers.h"
 
+#include <Parsers/CommonParsers.h>
 #include <Parsers/DumpASTNode.h>
 #include <Parsers/ASTAsterisk.h>
 #include <Parsers/ASTCollation.h>
@@ -725,7 +725,6 @@ bool ParserStatisticsType::parseImpl(Pos & pos, ASTPtr & node, Expected & expect
     function_node->name = "STATISTICS";
     function_node->arguments = stat_type;
     function_node->children.push_back(function_node->arguments);
-
     node = function_node;
     return true;
 }
diff --git a/src/Parsers/ExpressionListParsers.cpp b/src/Parsers/ExpressionListParsers.cpp
index f97c042e91e9..d38dc6d5f370 100644
--- a/src/Parsers/ExpressionListParsers.cpp
+++ b/src/Parsers/ExpressionListParsers.cpp
@@ -2388,6 +2388,24 @@ bool ParserFunction::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
     }
 }
 
+bool ParserExpressionWithOptionalArguments::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
+{
+    ParserIdentifier id_p;
+    ParserFunction func_p;
+
+    if (ParserFunction(false, false).parse(pos, node, expected))
+        return true;
+
+    if (ParserIdentifier().parse(pos, node, expected))
+    {
+        node = makeASTFunction(node->as<ASTIdentifier>()->name());
+        node->as<ASTFunction &>().no_empty_args = true;
+        return true;
+    }
+
+    return false;
+}
+
 const std::vector<std::pair<std::string_view, Operator>> ParserExpressionImpl::operators_table
 {
     {"->",            Operator("lambda",          1,  2, OperatorType::Lambda)},
diff --git a/src/Parsers/ExpressionListParsers.h b/src/Parsers/ExpressionListParsers.h
index 235d5782630c..6ab38416f322 100644
--- a/src/Parsers/ExpressionListParsers.h
+++ b/src/Parsers/ExpressionListParsers.h
@@ -144,6 +144,16 @@ class ParserFunction : public IParserBase
 };
 
 
+/** Similar to ParserFunction (and yields ASTFunction), but can also parse identifiers without braces.
+  */
+class ParserExpressionWithOptionalArguments : public IParserBase
+{
+protected:
+    const char * getName() const override { return "expression with optional parameters"; }
+    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
+};
+
+
 /** An expression with an infix binary left-associative operator.
   * For example, a + b - c + d.
   */
diff --git a/src/Parsers/IAST.h b/src/Parsers/IAST.h
index 4f8edac8597d..d70c1cd0b6cc 100644
--- a/src/Parsers/IAST.h
+++ b/src/Parsers/IAST.h
@@ -271,16 +271,15 @@ class IAST : public std::enable_shared_from_this<IAST>, public TypePromotion<IAS
         throw Exception(ErrorCodes::LOGICAL_ERROR, "Unknown element in AST: {}", getID());
     }
 
-    // Secrets are displayed regarding show_secrets, then SensitiveDataMasker is applied.
-    // You can use Interpreters/formatWithPossiblyHidingSecrets.h for convenience.
+    /// Secrets are displayed regarding show_secrets, then SensitiveDataMasker is applied.
+    /// You can use Interpreters/formatWithPossiblyHidingSecrets.h for convenience.
     String formatWithPossiblyHidingSensitiveData(size_t max_length, bool one_line, bool show_secrets) const;
 
-    /*
-     * formatForLogging and formatForErrorMessage always hide secrets. This inconsistent
-     * behaviour is due to the fact such functions are called from Client which knows nothing about
-     * access rights and settings. Moreover, the only use case for displaying secrets are backups,
-     * and backup tools use only direct input and ignore logs and error messages.
-     */
+    /** formatForLogging and formatForErrorMessage always hide secrets. This inconsistent
+      * behaviour is due to the fact such functions are called from Client which knows nothing about
+      * access rights and settings. Moreover, the only use case for displaying secrets are backups,
+      * and backup tools use only direct input and ignore logs and error messages.
+      */
     String formatForLogging(size_t max_length = 0) const
     {
         return formatWithPossiblyHidingSensitiveData(max_length, true, false);
diff --git a/src/Parsers/ParserAlterQuery.cpp b/src/Parsers/ParserAlterQuery.cpp
index 28dbf7810112..dbefb0cb966b 100644
--- a/src/Parsers/ParserAlterQuery.cpp
+++ b/src/Parsers/ParserAlterQuery.cpp
@@ -9,8 +9,6 @@
 #include <Parsers/ParserRefreshStrategy.h>
 #include <Parsers/ParserSelectWithUnionQuery.h>
 #include <Parsers/ParserSetQuery.h>
-#include <Parsers/ASTIdentifier.h>
-#include <Parsers/ASTIndexDeclaration.h>
 #include <Parsers/ASTAlterQuery.h>
 #include <Parsers/ASTLiteral.h>
 #include <Parsers/parseDatabaseAndTableName.h>
diff --git a/src/Parsers/ParserCreateIndexQuery.cpp b/src/Parsers/ParserCreateIndexQuery.cpp
index 2fa34696c58f..9ebee4cc852e 100644
--- a/src/Parsers/ParserCreateIndexQuery.cpp
+++ b/src/Parsers/ParserCreateIndexQuery.cpp
@@ -7,9 +7,9 @@
 #include <Parsers/ASTLiteral.h>
 #include <Parsers/CommonParsers.h>
 #include <Parsers/ExpressionListParsers.h>
-#include <Parsers/ParserDataType.h>
 #include <Parsers/parseDatabaseAndTableName.h>
 
+
 namespace DB
 {
 
@@ -21,7 +21,7 @@ bool ParserCreateIndexDeclaration::parseImpl(Pos & pos, ASTPtr & node, Expected
     ParserToken close_p(TokenType::ClosingRoundBracket);
     ParserOrderByExpressionList order_list_p;
 
-    ParserDataType data_type_p;
+    ParserExpressionWithOptionalArguments type_p;
     ParserExpression expression_p;
     ParserUnsignedInteger granularity_p;
 
@@ -68,7 +68,7 @@ bool ParserCreateIndexDeclaration::parseImpl(Pos & pos, ASTPtr & node, Expected
 
     if (s_type.ignore(pos, expected))
     {
-        if (!data_type_p.parse(pos, type, expected))
+        if (!type_p.parse(pos, type, expected))
             return false;
     }
 
diff --git a/src/Parsers/ParserCreateQuery.cpp b/src/Parsers/ParserCreateQuery.cpp
index 1cc565a41d15..a592975613bd 100644
--- a/src/Parsers/ParserCreateQuery.cpp
+++ b/src/Parsers/ParserCreateQuery.cpp
@@ -5,6 +5,7 @@
 #include <Parsers/ASTExpressionList.h>
 #include <Parsers/ASTForeignKeyDeclaration.h>
 #include <Parsers/ASTFunction.h>
+#include <Parsers/ASTDataType.h>
 #include <Parsers/ASTIdentifier.h>
 #include <Parsers/ASTIndexDeclaration.h>
 #include <Parsers/ASTStatisticsDeclaration.h>
@@ -76,9 +77,9 @@ bool ParserNestedTable::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
     if (!close.ignore(pos, expected))
         return false;
 
-    auto func = std::make_shared<ASTFunction>();
+    auto func = std::make_shared<ASTDataType>();
     tryGetIdentifierNameInto(name, func->name);
-    // FIXME(ilezhankin): func->no_empty_args = true; ?
+
     func->arguments = columns;
     func->children.push_back(columns);
     node = func;
@@ -179,7 +180,7 @@ bool ParserIndexDeclaration::parseImpl(Pos & pos, ASTPtr & node, Expected & expe
     ParserKeyword s_granularity(Keyword::GRANULARITY);
 
     ParserIdentifier name_p;
-    ParserDataType data_type_p;
+    ParserExpressionWithOptionalArguments type_p;
     ParserExpression expression_p;
     ParserUnsignedInteger granularity_p;
 
@@ -197,7 +198,7 @@ bool ParserIndexDeclaration::parseImpl(Pos & pos, ASTPtr & node, Expected & expe
     if (!s_type.ignore(pos, expected))
         return false;
 
-    if (!data_type_p.parse(pos, type, expected))
+    if (!type_p.parse(pos, type, expected))
         return false;
 
     if (s_granularity.ignore(pos, expected))
@@ -231,7 +232,7 @@ bool ParserStatisticsDeclaration::parseImpl(Pos & pos, ASTPtr & node, Expected &
     ParserKeyword s_type(Keyword::TYPE);
 
     ParserList columns_p(std::make_unique<ParserIdentifier>(), std::make_unique<ParserToken>(TokenType::Comma), false);
-    ParserList types_p(std::make_unique<ParserDataType>(), std::make_unique<ParserToken>(TokenType::Comma), false);
+    ParserList types_p(std::make_unique<ParserExpressionWithOptionalArguments>(), std::make_unique<ParserToken>(TokenType::Comma), false);
 
     ASTPtr columns;
     ASTPtr types;
@@ -751,7 +752,7 @@ bool ParserCreateTableQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expe
 
     auto * table_id = table->as<ASTTableIdentifier>();
 
-    // Shortcut for ATTACH a previously detached table
+    /// A shortcut for ATTACH a previously detached table.
     bool short_attach = attach && !from_path;
     if (short_attach && (!pos.isValid() || pos.get().type == TokenType::Semicolon))
     {
diff --git a/src/Parsers/ParserCreateQuery.h b/src/Parsers/ParserCreateQuery.h
index bb37491a3660..53a62deb22b8 100644
--- a/src/Parsers/ParserCreateQuery.h
+++ b/src/Parsers/ParserCreateQuery.h
@@ -1,6 +1,7 @@
 #pragma once
 
 #include <Parsers/ASTFunction.h>
+#include <Parsers/ASTDataType.h>
 #include <Parsers/ASTColumnDeclaration.h>
 #include <Parsers/ASTIdentifier_fwd.h>
 #include <Parsers/ASTLiteral.h>
@@ -13,6 +14,7 @@
 #include <Parsers/ParserSetQuery.h>
 #include <Poco/String.h>
 
+
 namespace DB
 {
 
@@ -101,17 +103,15 @@ class IParserColumnDeclaration : public IParserBase
 {
 public:
     explicit IParserColumnDeclaration(bool require_type_ = true, bool allow_null_modifiers_ = false, bool check_keywords_after_name_ = false)
-    : require_type(require_type_)
-    , allow_null_modifiers(allow_null_modifiers_)
-    , check_keywords_after_name(check_keywords_after_name_)
+        : require_type(require_type_)
+        , allow_null_modifiers(allow_null_modifiers_)
+        , check_keywords_after_name(check_keywords_after_name_)
     {
     }
 
     void enableCheckTypeKeyword() { check_type_keyword = true; }
 
 protected:
-    using ASTDeclarePtr = std::shared_ptr<ASTColumnDeclaration>;
-
     const char * getName() const  override{ return "column declaration"; }
 
     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
@@ -270,9 +270,8 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E
             auto default_function = std::make_shared<ASTFunction>();
             default_function->name = "defaultValueOfTypeName";
             default_function->arguments = std::make_shared<ASTExpressionList>();
-            // Ephemeral columns don't really have secrets but we need to format
-            // into a String, hence the strange call
-            default_function->arguments->children.emplace_back(std::make_shared<ASTLiteral>(type->as<ASTFunction>()->formatForLogging()));
+            /// Ephemeral columns don't really have secrets but we need to format into a String, hence the strange call
+            default_function->arguments->children.emplace_back(std::make_shared<ASTLiteral>(type->as<ASTDataType>()->formatForLogging()));
             default_expression = default_function;
         }
 
diff --git a/src/Parsers/ParserDataType.cpp b/src/Parsers/ParserDataType.cpp
index ad33c7e4558b..2edb0141e122 100644
--- a/src/Parsers/ParserDataType.cpp
+++ b/src/Parsers/ParserDataType.cpp
@@ -1,8 +1,8 @@
 #include <Parsers/ParserDataType.h>
 
 #include <boost/algorithm/string/case_conv.hpp>
+#include <Parsers/ASTDataType.h>
 #include <Parsers/ASTFunction.h>
-#include <Parsers/ASTIdentifier.h>
 #include <Parsers/ASTIdentifier_fwd.h>
 #include <Parsers/CommonParsers.h>
 #include <Parsers/ExpressionElementParsers.h>
@@ -46,48 +46,6 @@ class DynamicArgumentsParser : public IParserBase
     }
 };
 
-/// Wrapper to allow mixed lists of nested and normal types.
-/// Parameters are either:
-/// - Nested table elements;
-/// - Enum element in form of 'a' = 1;
-/// - literal;
-/// - Dynamic type arguments;
-/// - another data type (or identifier);
-class ParserDataTypeArgument : public IParserBase
-{
-public:
-    explicit ParserDataTypeArgument(std::string_view type_name_) : type_name(type_name_)
-    {
-    }
-
-private:
-    const char * getName() const override { return "data type argument"; }
-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override
-    {
-        if (type_name == "Dynamic")
-        {
-            DynamicArgumentsParser parser;
-            return parser.parse(pos, node, expected);
-        }
-
-        ParserNestedTable nested_parser;
-        ParserDataType data_type_parser;
-        ParserAllCollectionsOfLiterals literal_parser(false);
-
-        const char * operators[] = {"=", "equals", nullptr};
-        ParserLeftAssociativeBinaryOperatorList enum_parser(operators, std::make_unique<ParserLiteral>());
-
-        if (pos->type == TokenType::BareWord && std::string_view(pos->begin, pos->size()) == "Nested")
-            return nested_parser.parse(pos, node, expected);
-
-        return enum_parser.parse(pos, node, expected)
-            || literal_parser.parse(pos, node, expected)
-            || data_type_parser.parse(pos, node, expected);
-    }
-
-    std::string_view type_name;
-};
-
 }
 
 bool ParserDataType::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
@@ -198,23 +156,102 @@ bool ParserDataType::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
         }
     }
 
-    auto function_node = std::make_shared<ASTFunction>();
-    function_node->name = type_name;
-    function_node->no_empty_args = true;
+    auto data_type_node = std::make_shared<ASTDataType>();
+    data_type_node->name = type_name;
 
     if (pos->type != TokenType::OpeningRoundBracket)
     {
-        node = function_node;
+        node = data_type_node;
         return true;
     }
     ++pos;
 
     /// Parse optional parameters
-    ParserList args_parser(std::make_unique<ParserDataTypeArgument>(type_name), std::make_unique<ParserToken>(TokenType::Comma));
-    ASTPtr expr_list_args;
+    ASTPtr expr_list_args = std::make_shared<ASTExpressionList>();
+
+    /// Allow mixed lists of nested and normal types.
+    /// Parameters are either:
+    /// - Nested table elements;
+    /// - Enum element in form of 'a' = 1;
+    /// - literal;
+    /// - Dynamic type arguments;
+    /// - another data type (or identifier);
+
+    size_t arg_num = 0;
+    bool have_version_of_aggregate_function = false;
+    while (true)
+    {
+        if (arg_num > 0)
+        {
+            if (pos->type == TokenType::Comma)
+                ++pos;
+            else
+                break;
+        }
+
+        ASTPtr arg;
+        if (type_name == "Dynamic")
+        {
+            DynamicArgumentsParser parser;
+            parser.parse(pos, arg, expected);
+        }
+        else if (type_name == "Nested")
+        {
+            ParserNestedTable nested_parser;
+            nested_parser.parse(pos, arg, expected);
+        }
+        else if (type_name == "AggregateFunction" || type_name == "SimpleAggregateFunction")
+        {
+            /// This is less trivial.
+            /// The first optional argument for AggregateFunction is a numeric literal, defining the version.
+            /// The next argument is the function name, optionally with parameters.
+            /// Subsequent arguments are data types.
+
+            if (arg_num == 0 && type_name == "AggregateFunction")
+            {
+                ParserUnsignedInteger version_parser;
+                if (version_parser.parse(pos, arg, expected))
+                {
+                    have_version_of_aggregate_function = true;
+                    expr_list_args->children.emplace_back(std::move(arg));
+                    ++arg_num;
+                    continue;
+                }
+            }
+
+            if (arg_num == (have_version_of_aggregate_function ? 1 : 0))
+            {
+                ParserFunction function_parser;
+                ParserIdentifier identifier_parser;
+                function_parser.parse(pos, arg, expected)
+                    || identifier_parser.parse(pos, arg, expected);
+            }
+            else
+            {
+                ParserDataType data_type_parser;
+                data_type_parser.parse(pos, arg, expected);
+            }
+        }
+        else
+        {
+            ParserDataType data_type_parser;
+            ParserAllCollectionsOfLiterals literal_parser(false);
+
+            const char * operators[] = {"=", "equals", nullptr};
+            ParserLeftAssociativeBinaryOperatorList enum_parser(operators, std::make_unique<ParserLiteral>());
+
+            enum_parser.parse(pos, arg, expected)
+               || literal_parser.parse(pos, arg, expected)
+               || data_type_parser.parse(pos, arg, expected);
+        }
+
+        if (!arg)
+            break;
+
+        expr_list_args->children.emplace_back(std::move(arg));
+        ++arg_num;
+    }
 
-    if (!args_parser.parse(pos, expr_list_args, expected))
-        return false;
     if (pos->type == TokenType::Comma)
         // ignore trailing comma inside Nested structures like Tuple(Int, Tuple(Int, String),)
         ++pos;
@@ -222,10 +259,10 @@ bool ParserDataType::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
         return false;
     ++pos;
 
-    function_node->arguments = expr_list_args;
-    function_node->children.push_back(function_node->arguments);
+    data_type_node->arguments = expr_list_args;
+    data_type_node->children.push_back(data_type_node->arguments);
 
-    node = function_node;
+    node = data_type_node;
     return true;
 }
 
diff --git a/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp b/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp
index f4c38a52a3fc..a9778d5d04d9 100644
--- a/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp
+++ b/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp
@@ -10,7 +10,6 @@
 #include <Core/Settings.h>
 #include <Core/PostgreSQL/Connection.h>
 
-#include <DataTypes/DataTypeString.h>
 #include <DataTypes/DataTypeNullable.h>
 #include <DataTypes/DataTypeArray.h>
 #include <DataTypes/DataTypesDecimal.h>
@@ -22,6 +21,7 @@
 #include <Processors/QueryPlan/QueryPlan.h>
 #include <Processors/QueryPlan/ReadFromPreparedSource.h>
 #include <Parsers/ASTFunction.h>
+#include <Parsers/ASTDataType.h>
 #include <Parsers/ASTIdentifier.h>
 #include <Parsers/ASTTablesInSelectQuery.h>
 #include <Parsers/ExpressionListParsers.h>
@@ -295,7 +295,7 @@ std::shared_ptr<ASTColumnDeclaration> StorageMaterializedPostgreSQL::getMaterial
     auto column_declaration = std::make_shared<ASTColumnDeclaration>();
 
     column_declaration->name = std::move(name);
-    column_declaration->type = makeASTFunction(type);
+    column_declaration->type = makeASTDataType(type);
 
     column_declaration->default_specifier = "MATERIALIZED";
     column_declaration->default_expression = std::make_shared<ASTLiteral>(default_value);
@@ -312,17 +312,17 @@ ASTPtr StorageMaterializedPostgreSQL::getColumnDeclaration(const DataTypePtr & d
     WhichDataType which(data_type);
 
     if (which.isNullable())
-        return makeASTFunction("Nullable", getColumnDeclaration(typeid_cast<const DataTypeNullable *>(data_type.get())->getNestedType()));
+        return makeASTDataType("Nullable", getColumnDeclaration(typeid_cast<const DataTypeNullable *>(data_type.get())->getNestedType()));
 
     if (which.isArray())
-        return makeASTFunction("Array", getColumnDeclaration(typeid_cast<const DataTypeArray *>(data_type.get())->getNestedType()));
+        return makeASTDataType("Array", getColumnDeclaration(typeid_cast<const DataTypeArray *>(data_type.get())->getNestedType()));
 
     /// getName() for decimal returns 'Decimal(precision, scale)', will get an error with it
     if (which.isDecimal())
     {
         auto make_decimal_expression = [&](std::string type_name)
         {
-            auto ast_expression = std::make_shared<ASTFunction>();
+            auto ast_expression = std::make_shared<ASTDataType>();
 
             ast_expression->name = type_name;
             ast_expression->arguments = std::make_shared<ASTExpressionList>();
@@ -346,7 +346,7 @@ ASTPtr StorageMaterializedPostgreSQL::getColumnDeclaration(const DataTypePtr & d
 
     if (which.isDateTime64())
     {
-        auto ast_expression = std::make_shared<ASTFunction>();
+        auto ast_expression = std::make_shared<ASTDataType>();
 
         ast_expression->name = "DateTime64";
         ast_expression->arguments = std::make_shared<ASTExpressionList>();
@@ -354,7 +354,7 @@ ASTPtr StorageMaterializedPostgreSQL::getColumnDeclaration(const DataTypePtr & d
         return ast_expression;
     }
 
-    return std::make_shared<ASTIdentifier>(data_type->getName());
+    return makeASTDataType(data_type->getName());
 }
 
 
diff --git a/src/Storages/WindowView/StorageWindowView.cpp b/src/Storages/WindowView/StorageWindowView.cpp
index 8975f9327b14..36b6fbe46f05 100644
--- a/src/Storages/WindowView/StorageWindowView.cpp
+++ b/src/Storages/WindowView/StorageWindowView.cpp
@@ -20,6 +20,7 @@
 #include <Parsers/ASTAsterisk.h>
 #include <Parsers/ASTCreateQuery.h>
 #include <Parsers/ASTDropQuery.h>
+#include <Parsers/ASTDataType.h>
 #include <Parsers/ASTIdentifier.h>
 #include <Parsers/ASTLiteral.h>
 #include <Parsers/ASTOrderByElement.h>
@@ -805,7 +806,7 @@ ASTPtr StorageWindowView::getInnerTableCreateQuery(const ASTPtr & inner_query, c
     {
         auto column_window = std::make_shared<ASTColumnDeclaration>();
         column_window->name = window_id_name;
-        column_window->type = std::make_shared<ASTIdentifier>("UInt32");
+        column_window->type = makeASTDataType("UInt32");
         columns_list->children.push_back(column_window);
     }
 
diff --git a/src/TableFunctions/ITableFunction.cpp b/src/TableFunctions/ITableFunction.cpp
index e5676c5c25dc..916ff7ec0222 100644
--- a/src/TableFunctions/ITableFunction.cpp
+++ b/src/TableFunctions/ITableFunction.cpp
@@ -1,5 +1,4 @@
 #include <TableFunctions/ITableFunction.h>
-#include <Interpreters/Context.h>
 #include <Storages/StorageFactory.h>
 #include <Storages/StorageTableFunction.h>
 #include <Access/Common/AccessFlags.h>
