{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 66506,
  "instance_id": "ClickHouse__ClickHouse-66506",
  "issue_numbers": [
    "67445",
    "61611",
    "61711",
    "66807"
  ],
  "base_commit": "b23cdc865491db201b2188e696f4abdea13d3575",
  "patch": "diff --git a/src/Client/ClientBase.cpp b/src/Client/ClientBase.cpp\nindex 78d8e7e3d6ad..cabe3aa01f01 100644\n--- a/src/Client/ClientBase.cpp\n+++ b/src/Client/ClientBase.cpp\n@@ -70,7 +70,6 @@\n \n #include <boost/algorithm/string/case_conv.hpp>\n #include <boost/algorithm/string/replace.hpp>\n-#include <boost/algorithm/string/split.hpp>\n #include <iostream>\n #include <filesystem>\n #include <limits>\ndiff --git a/src/DataTypes/DataTypeAggregateFunction.cpp b/src/DataTypes/DataTypeAggregateFunction.cpp\nindex ef7d86d2a812..09175617bf1c 100644\n--- a/src/DataTypes/DataTypeAggregateFunction.cpp\n+++ b/src/DataTypes/DataTypeAggregateFunction.cpp\n@@ -257,8 +257,8 @@ static DataTypePtr create(const ASTPtr & arguments)\n     }\n     else\n         throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                        \"Unexpected AST element passed as aggregate function name for data type AggregateFunction. \"\n-                        \"Must be identifier or function.\");\n+                        \"Unexpected AST element {} passed as aggregate function name for data type AggregateFunction. \"\n+                        \"Must be identifier or function\", data_type_ast->getID());\n \n     for (size_t i = argument_types_start_idx; i < arguments->children.size(); ++i)\n         argument_types.push_back(DataTypeFactory::instance().get(arguments->children[i]));\ndiff --git a/src/DataTypes/DataTypeFactory.cpp b/src/DataTypes/DataTypeFactory.cpp\nindex eb3bc973857c..6f7dcd65b835 100644\n--- a/src/DataTypes/DataTypeFactory.cpp\n+++ b/src/DataTypes/DataTypeFactory.cpp\n@@ -2,7 +2,7 @@\n #include <DataTypes/DataTypeCustom.h>\n #include <Parsers/parseQuery.h>\n #include <Parsers/ParserCreateQuery.h>\n-#include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTDataType.h>\n #include <Parsers/ASTIdentifier.h>\n #include <Parsers/ASTLiteral.h>\n #include <Common/typeid_cast.h>\n@@ -22,7 +22,6 @@ namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n     extern const int UNKNOWN_TYPE;\n-    extern const int ILLEGAL_SYNTAX_FOR_DATA_TYPE;\n     extern const int UNEXPECTED_AST_STRUCTURE;\n     extern const int DATA_TYPE_CANNOT_HAVE_ARGUMENTS;\n }\n@@ -83,15 +82,9 @@ DataTypePtr DataTypeFactory::tryGet(const ASTPtr & ast) const\n template <bool nullptr_on_error>\n DataTypePtr DataTypeFactory::getImpl(const ASTPtr & ast) const\n {\n-    if (const auto * func = ast->as<ASTFunction>())\n+    if (const auto * type = ast->as<ASTDataType>())\n     {\n-        if (func->parameters)\n-        {\n-            if constexpr (nullptr_on_error)\n-                return nullptr;\n-            throw Exception(ErrorCodes::ILLEGAL_SYNTAX_FOR_DATA_TYPE, \"Data type cannot have multiple parenthesized parameters.\");\n-        }\n-        return getImpl<nullptr_on_error>(func->name, func->arguments);\n+        return getImpl<nullptr_on_error>(type->name, type->arguments);\n     }\n \n     if (const auto * ident = ast->as<ASTIdentifier>())\n@@ -107,7 +100,7 @@ DataTypePtr DataTypeFactory::getImpl(const ASTPtr & ast) const\n \n     if constexpr (nullptr_on_error)\n         return nullptr;\n-    throw Exception(ErrorCodes::UNEXPECTED_AST_STRUCTURE, \"Unexpected AST element for data type.\");\n+    throw Exception(ErrorCodes::UNEXPECTED_AST_STRUCTURE, \"Unexpected AST element for data type: {}.\", ast->getID());\n }\n \n DataTypePtr DataTypeFactory::get(const String & family_name_param, const ASTPtr & parameters) const\ndiff --git a/src/DataTypes/DataTypeObject.cpp b/src/DataTypes/DataTypeObject.cpp\nindex 5636a46373f9..91b9bfcb2a58 100644\n--- a/src/DataTypes/DataTypeObject.cpp\n+++ b/src/DataTypes/DataTypeObject.cpp\n@@ -4,9 +4,10 @@\n \n #include <Parsers/IAST.h>\n #include <Parsers/ASTLiteral.h>\n-#include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTDataType.h>\n #include <IO/Operators.h>\n \n+\n namespace DB\n {\n \n@@ -53,13 +54,13 @@ static DataTypePtr create(const ASTPtr & arguments)\n     ASTPtr schema_argument = arguments->children[0];\n     bool is_nullable = false;\n \n-    if (const auto * func = schema_argument->as<ASTFunction>())\n+    if (const auto * type = schema_argument->as<ASTDataType>())\n     {\n-        if (func->name != \"Nullable\" || func->arguments->children.size() != 1)\n+        if (type->name != \"Nullable\" || type->arguments->children.size() != 1)\n             throw Exception(ErrorCodes::UNEXPECTED_AST_STRUCTURE,\n-                \"Expected 'Nullable(<schema_name>)' as parameter for type Object (function: {})\", func->name);\n+                \"Expected 'Nullable(<schema_name>)' as parameter for type Object (function: {})\", type->name);\n \n-        schema_argument = func->arguments->children[0];\n+        schema_argument = type->arguments->children[0];\n         is_nullable = true;\n     }\n \ndiff --git a/src/Databases/DatabasesCommon.cpp b/src/Databases/DatabasesCommon.cpp\nindex b8e9231f5c6f..d8151cf340a4 100644\n--- a/src/Databases/DatabasesCommon.cpp\n+++ b/src/Databases/DatabasesCommon.cpp\n@@ -149,7 +149,7 @@ ASTPtr getCreateQueryFromStorage(const StoragePtr & storage, const ASTPtr & ast_\n             columns = metadata_ptr->columns.getAll();\n         for (const auto & column_name_and_type: columns)\n         {\n-            const auto & ast_column_declaration = std::make_shared<ASTColumnDeclaration>();\n+            const auto ast_column_declaration = std::make_shared<ASTColumnDeclaration>();\n             ast_column_declaration->name = column_name_and_type.name;\n             /// parser typename\n             {\n@@ -164,7 +164,7 @@ ASTPtr getCreateQueryFromStorage(const StoragePtr & storage, const ASTPtr & ast_\n                 if (!parser.parse(pos, ast_type, expected))\n                 {\n                     if (throw_on_error)\n-                        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cannot parser metadata of {}.{}\",\n+                        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cannot parse metadata of {}.{}\",\n                                         backQuote(table_id.database_name), backQuote(table_id.table_name));\n                     else\n                         return nullptr;\ndiff --git a/src/Databases/PostgreSQL/DatabasePostgreSQL.cpp b/src/Databases/PostgreSQL/DatabasePostgreSQL.cpp\nindex a846e23cd4f8..032fc33ea164 100644\n--- a/src/Databases/PostgreSQL/DatabasePostgreSQL.cpp\n+++ b/src/Databases/PostgreSQL/DatabasePostgreSQL.cpp\n@@ -12,9 +12,9 @@\n #include <Interpreters/evaluateConstantExpression.h>\n #include <Parsers/ASTCreateQuery.h>\n #include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTDataType.h>\n #include <Parsers/ParserCreateQuery.h>\n #include <Parsers/parseQuery.h>\n-#include <Parsers/queryToString.h>\n #include <Common/escapeForFileName.h>\n #include <Common/parseRemoteDescription.h>\n #include <Databases/DatabaseFactory.h>\n@@ -25,6 +25,7 @@\n #include <Core/Settings.h>\n #include <filesystem>\n \n+\n namespace fs = std::filesystem;\n \n namespace DB\n@@ -432,7 +433,7 @@ ASTPtr DatabasePostgreSQL::getCreateTableQueryImpl(const String & table_name, Co\n     auto metadata_snapshot = storage->getInMemoryMetadataPtr();\n     for (const auto & column_type_and_name : metadata_snapshot->getColumns().getOrdinary())\n     {\n-        const auto & column_declaration = std::make_shared<ASTColumnDeclaration>();\n+        const auto column_declaration = std::make_shared<ASTColumnDeclaration>();\n         column_declaration->name = column_type_and_name.name;\n         column_declaration->type = getColumnDeclaration(column_type_and_name.type);\n         columns_expression_list->children.emplace_back(column_declaration);\n@@ -470,17 +471,15 @@ ASTPtr DatabasePostgreSQL::getColumnDeclaration(const DataTypePtr & data_type) c\n     WhichDataType which(data_type);\n \n     if (which.isNullable())\n-        return makeASTFunction(\"Nullable\", getColumnDeclaration(typeid_cast<const DataTypeNullable *>(data_type.get())->getNestedType()));\n+        return makeASTDataType(\"Nullable\", getColumnDeclaration(typeid_cast<const DataTypeNullable *>(data_type.get())->getNestedType()));\n \n     if (which.isArray())\n-        return makeASTFunction(\"Array\", getColumnDeclaration(typeid_cast<const DataTypeArray *>(data_type.get())->getNestedType()));\n+        return makeASTDataType(\"Array\", getColumnDeclaration(typeid_cast<const DataTypeArray *>(data_type.get())->getNestedType()));\n \n     if (which.isDateTime64())\n-    {\n-        return makeASTFunction(\"DateTime64\", std::make_shared<ASTLiteral>(static_cast<UInt32>(6)));\n-    }\n+        return makeASTDataType(\"DateTime64\", std::make_shared<ASTLiteral>(static_cast<UInt32>(6)));\n \n-    return std::make_shared<ASTIdentifier>(data_type->getName());\n+    return makeASTDataType(data_type->getName());\n }\n \n void registerDatabasePostgreSQL(DatabaseFactory & factory)\ndiff --git a/src/IO/WithFileSize.cpp b/src/IO/WithFileSize.cpp\nindex cbbcab83de2e..54747cef8afc 100644\n--- a/src/IO/WithFileSize.cpp\n+++ b/src/IO/WithFileSize.cpp\n@@ -5,6 +5,7 @@\n #include <IO/ReadBufferFromFileDecorator.h>\n #include <IO/PeekableReadBuffer.h>\n \n+\n namespace DB\n {\n \n@@ -88,5 +89,4 @@ size_t getDataOffsetMaybeCompressed(const ReadBuffer & in)\n     return in.count();\n }\n \n-\n }\ndiff --git a/src/Interpreters/InterpreterShowCreateQuery.cpp b/src/Interpreters/InterpreterShowCreateQuery.cpp\nindex 16add79d2261..e5549b2e5396 100644\n--- a/src/Interpreters/InterpreterShowCreateQuery.cpp\n+++ b/src/Interpreters/InterpreterShowCreateQuery.cpp\n@@ -1,9 +1,7 @@\n #include <Storages/IStorage.h>\n #include <Parsers/TablePropertiesQueriesASTs.h>\n-#include <Parsers/formatAST.h>\n #include <Processors/Sources/SourceFromSingleChunk.h>\n #include <QueryPipeline/BlockIO.h>\n-#include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/DataTypeString.h>\n #include <Columns/ColumnString.h>\n #include <Common/typeid_cast.h>\ndiff --git a/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp b/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp\nindex 4821d607d0eb..3917ffb8823c 100644\n--- a/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp\n+++ b/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp\n@@ -3,6 +3,7 @@\n #include <Parsers/IAST.h>\n #include <Parsers/ASTLiteral.h>\n #include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTDataType.h>\n #include <Parsers/ASTIdentifier.h>\n #include <Parsers/ASTAlterQuery.h>\n #include <Parsers/ASTCreateQuery.h>\n@@ -16,7 +17,6 @@\n #include <Parsers/MySQL/ASTCreateDefines.h>\n \n #include <DataTypes/DataTypeFactory.h>\n-#include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/DataTypeNullable.h>\n #include <Parsers/MySQL/ASTDeclareIndex.h>\n #include <Common/quoteString.h>\n@@ -29,6 +29,7 @@\n #include <Interpreters/applyTableOverride.h>\n #include <Storages/IStorage.h>\n \n+\n namespace DB\n {\n \n@@ -95,22 +96,22 @@ NamesAndTypesList getColumnsList(const ASTExpressionList * columns_definition)\n         }\n \n         ASTPtr data_type = declare_column->data_type;\n-        auto * data_type_function = data_type->as<ASTFunction>();\n+        auto * data_type_node = data_type->as<ASTDataType>();\n \n-        if (data_type_function)\n+        if (data_type_node)\n         {\n-            String type_name_upper = Poco::toUpper(data_type_function->name);\n+            String type_name_upper = Poco::toUpper(data_type_node->name);\n \n             if (is_unsigned)\n             {\n                 /// For example(in MySQL): CREATE TABLE test(column_name INT NOT NULL ... UNSIGNED)\n                 if (type_name_upper.find(\"INT\") != String::npos && !endsWith(type_name_upper, \"SIGNED\")\n                     && !endsWith(type_name_upper, \"UNSIGNED\"))\n-                    data_type_function->name = type_name_upper + \" UNSIGNED\";\n+                    data_type_node->name = type_name_upper + \" UNSIGNED\";\n             }\n \n             if (type_name_upper == \"SET\")\n-                data_type_function->arguments.reset();\n+                data_type_node->arguments.reset();\n \n             /// Transforms MySQL ENUM's list of strings to ClickHouse string-integer pairs\n             /// For example ENUM('a', 'b', 'c') -> ENUM('a'=1, 'b'=2, 'c'=3)\n@@ -119,7 +120,7 @@ NamesAndTypesList getColumnsList(const ASTExpressionList * columns_definition)\n             if (type_name_upper.find(\"ENUM\") != String::npos)\n             {\n                 UInt16 i = 0;\n-                for (ASTPtr & child : data_type_function->arguments->children)\n+                for (ASTPtr & child : data_type_node->arguments->children)\n                 {\n                     auto new_child = std::make_shared<ASTFunction>();\n                     new_child->name = \"equals\";\n@@ -133,10 +134,10 @@ NamesAndTypesList getColumnsList(const ASTExpressionList * columns_definition)\n             }\n \n             if (type_name_upper == \"DATE\")\n-                data_type_function->name = \"Date32\";\n+                data_type_node->name = \"Date32\";\n         }\n         if (is_nullable)\n-            data_type = makeASTFunction(\"Nullable\", data_type);\n+            data_type = makeASTDataType(\"Nullable\", data_type);\n \n         columns_name_and_type.emplace_back(declare_column->name, DataTypeFactory::instance().get(data_type));\n     }\n@@ -156,7 +157,7 @@ static ColumnsDescription createColumnsDescription(const NamesAndTypesList & col\n     /// (see git blame for details).\n     auto column_name_and_type = columns_name_and_type.begin();\n     const auto * declare_column_ast = columns_definition->children.begin();\n-    for (; column_name_and_type != columns_name_and_type.end(); column_name_and_type++, declare_column_ast++)\n+    for (; column_name_and_type != columns_name_and_type.end(); ++column_name_and_type, ++declare_column_ast)\n     {\n         const auto & declare_column = (*declare_column_ast)->as<MySQLParser::ASTDeclareColumn>();\n         String comment;\n@@ -482,7 +483,7 @@ ASTs InterpreterCreateImpl::getRewrittenQueries(\n     {\n         auto column_declaration = std::make_shared<ASTColumnDeclaration>();\n         column_declaration->name = name;\n-        column_declaration->type = makeASTFunction(type);\n+        column_declaration->type = makeASTDataType(type);\n         column_declaration->default_specifier = \"MATERIALIZED\";\n         column_declaration->default_expression = std::make_shared<ASTLiteral>(default_value);\n         column_declaration->children.emplace_back(column_declaration->type);\ndiff --git a/src/Interpreters/formatWithPossiblyHidingSecrets.h b/src/Interpreters/formatWithPossiblyHidingSecrets.h\nindex 039bcbc2bca8..ea8c295b1695 100644\n--- a/src/Interpreters/formatWithPossiblyHidingSecrets.h\n+++ b/src/Interpreters/formatWithPossiblyHidingSecrets.h\n@@ -1,11 +1,14 @@\n #pragma once\n-#include \"Access/ContextAccess.h\"\n-#include \"Interpreters/Context.h\"\n+\n+#include <Access/ContextAccess.h>\n+#include <Interpreters/Context.h>\n+\n \n #include <Core/Settings.h>\n \n namespace DB\n {\n+\n struct SecretHidingFormatSettings\n {\n     // We can't store const Context& as there's a dangerous usage {.ctx = *getContext()}\n@@ -24,4 +27,5 @@ inline String format(const SecretHidingFormatSettings & settings)\n \n     return settings.query.formatWithPossiblyHidingSensitiveData(settings.max_length, settings.one_line, show_secrets);\n }\n+\n }\ndiff --git a/src/Parsers/ASTColumnDeclaration.cpp b/src/Parsers/ASTColumnDeclaration.cpp\nindex 4a8a3d2967d3..c96499095d54 100644\n--- a/src/Parsers/ASTColumnDeclaration.cpp\n+++ b/src/Parsers/ASTColumnDeclaration.cpp\n@@ -1,8 +1,6 @@\n #include <Parsers/ASTColumnDeclaration.h>\n #include <Common/quoteString.h>\n #include <IO/Operators.h>\n-#include <Parsers/ASTLiteral.h>\n-#include <DataTypes/DataTypeFactory.h>\n \n \n namespace DB\n@@ -15,8 +13,6 @@ ASTPtr ASTColumnDeclaration::clone() const\n \n     if (type)\n     {\n-        // Type may be an ASTFunction (e.g. `create table t (a Decimal(9,0))`),\n-        // so we have to clone it properly as well.\n         res->type = type->clone();\n         res->children.push_back(res->type);\n     }\ndiff --git a/src/Parsers/ASTDataType.cpp b/src/Parsers/ASTDataType.cpp\nnew file mode 100644\nindex 000000000000..3c17ae8c380a\n--- /dev/null\n+++ b/src/Parsers/ASTDataType.cpp\n@@ -0,0 +1,57 @@\n+#include <Parsers/ASTDataType.h>\n+#include <Common/SipHash.h>\n+#include <IO/Operators.h>\n+\n+\n+namespace DB\n+{\n+\n+String ASTDataType::getID(char delim) const\n+{\n+    return \"DataType\" + (delim + name);\n+}\n+\n+ASTPtr ASTDataType::clone() const\n+{\n+    auto res = std::make_shared<ASTDataType>(*this);\n+    res->children.clear();\n+\n+    if (arguments)\n+    {\n+        res->arguments = arguments->clone();\n+        res->children.push_back(res->arguments);\n+    }\n+\n+    return res;\n+}\n+\n+void ASTDataType::updateTreeHashImpl(SipHash & hash_state, bool) const\n+{\n+    hash_state.update(name.size());\n+    hash_state.update(name);\n+    /// Children are hashed automatically.\n+}\n+\n+void ASTDataType::formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const\n+{\n+    settings.ostr << (settings.hilite ? hilite_function : \"\") << name;\n+\n+    if (arguments && !arguments->children.empty())\n+    {\n+        settings.ostr << '(' << (settings.hilite ? hilite_none : \"\");\n+\n+        for (size_t i = 0, size = arguments->children.size(); i < size; ++i)\n+        {\n+            if (i != 0)\n+                settings.ostr << \", \";\n+\n+            arguments->children[i]->formatImpl(settings, state, frame);\n+        }\n+\n+        settings.ostr << (settings.hilite ? hilite_function : \"\") << ')';\n+    }\n+\n+    settings.ostr << (settings.hilite ? hilite_none : \"\");\n+}\n+\n+}\ndiff --git a/src/Parsers/ASTDataType.h b/src/Parsers/ASTDataType.h\nnew file mode 100644\nindex 000000000000..71d3aeaa4eb1\n--- /dev/null\n+++ b/src/Parsers/ASTDataType.h\n@@ -0,0 +1,38 @@\n+#pragma once\n+\n+#include <Parsers/ASTExpressionList.h>\n+\n+\n+namespace DB\n+{\n+\n+/// AST for data types, e.g. UInt8 or Tuple(x UInt8, y Enum(a = 1))\n+class ASTDataType : public IAST\n+{\n+public:\n+    String name;\n+    ASTPtr arguments;\n+\n+    String getID(char delim) const override;\n+    ASTPtr clone() const override;\n+    void updateTreeHashImpl(SipHash & hash_state, bool ignore_aliases) const override;\n+    void formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const override;\n+};\n+\n+template <typename... Args>\n+std::shared_ptr<ASTDataType> makeASTDataType(const String & name, Args &&... args)\n+{\n+    auto data_type = std::make_shared<ASTDataType>();\n+    data_type->name = name;\n+\n+    if constexpr (sizeof...(args))\n+    {\n+        data_type->arguments = std::make_shared<ASTExpressionList>();\n+        data_type->children.push_back(data_type->arguments);\n+        data_type->arguments->children = { std::forward<Args>(args)... };\n+    }\n+\n+    return data_type;\n+}\n+\n+}\ndiff --git a/src/Parsers/ASTFunction.h b/src/Parsers/ASTFunction.h\nindex 3a94691f25da..be2b6beae54e 100644\n--- a/src/Parsers/ASTFunction.h\n+++ b/src/Parsers/ASTFunction.h\n@@ -46,7 +46,7 @@ class ASTFunction : public ASTWithAlias\n \n     NullsAction nulls_action = NullsAction::EMPTY;\n \n-    /// do not print empty parentheses if there are no args - compatibility with new AST for data types and engine names.\n+    /// do not print empty parentheses if there are no args - compatibility with engine names.\n     bool no_empty_args = false;\n \n     /// Specifies where this function-like expression is used.\ndiff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp\nindex d4fc9a4bc4d3..865d07faaa78 100644\n--- a/src/Parsers/ExpressionElementParsers.cpp\n+++ b/src/Parsers/ExpressionElementParsers.cpp\n@@ -9,8 +9,8 @@\n #include <Common/PODArray.h>\n #include <Common/StringUtils.h>\n #include <Common/typeid_cast.h>\n-#include \"Parsers/CommonParsers.h\"\n \n+#include <Parsers/CommonParsers.h>\n #include <Parsers/DumpASTNode.h>\n #include <Parsers/ASTAsterisk.h>\n #include <Parsers/ASTCollation.h>\n@@ -725,7 +725,6 @@ bool ParserStatisticsType::parseImpl(Pos & pos, ASTPtr & node, Expected & expect\n     function_node->name = \"STATISTICS\";\n     function_node->arguments = stat_type;\n     function_node->children.push_back(function_node->arguments);\n-\n     node = function_node;\n     return true;\n }\ndiff --git a/src/Parsers/ExpressionListParsers.cpp b/src/Parsers/ExpressionListParsers.cpp\nindex f97c042e91e9..d38dc6d5f370 100644\n--- a/src/Parsers/ExpressionListParsers.cpp\n+++ b/src/Parsers/ExpressionListParsers.cpp\n@@ -2388,6 +2388,24 @@ bool ParserFunction::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     }\n }\n \n+bool ParserExpressionWithOptionalArguments::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+{\n+    ParserIdentifier id_p;\n+    ParserFunction func_p;\n+\n+    if (ParserFunction(false, false).parse(pos, node, expected))\n+        return true;\n+\n+    if (ParserIdentifier().parse(pos, node, expected))\n+    {\n+        node = makeASTFunction(node->as<ASTIdentifier>()->name());\n+        node->as<ASTFunction &>().no_empty_args = true;\n+        return true;\n+    }\n+\n+    return false;\n+}\n+\n const std::vector<std::pair<std::string_view, Operator>> ParserExpressionImpl::operators_table\n {\n     {\"->\",            Operator(\"lambda\",          1,  2, OperatorType::Lambda)},\ndiff --git a/src/Parsers/ExpressionListParsers.h b/src/Parsers/ExpressionListParsers.h\nindex 235d5782630c..6ab38416f322 100644\n--- a/src/Parsers/ExpressionListParsers.h\n+++ b/src/Parsers/ExpressionListParsers.h\n@@ -144,6 +144,16 @@ class ParserFunction : public IParserBase\n };\n \n \n+/** Similar to ParserFunction (and yields ASTFunction), but can also parse identifiers without braces.\n+  */\n+class ParserExpressionWithOptionalArguments : public IParserBase\n+{\n+protected:\n+    const char * getName() const override { return \"expression with optional parameters\"; }\n+    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n+};\n+\n+\n /** An expression with an infix binary left-associative operator.\n   * For example, a + b - c + d.\n   */\ndiff --git a/src/Parsers/IAST.h b/src/Parsers/IAST.h\nindex 4f8edac8597d..d70c1cd0b6cc 100644\n--- a/src/Parsers/IAST.h\n+++ b/src/Parsers/IAST.h\n@@ -271,16 +271,15 @@ class IAST : public std::enable_shared_from_this<IAST>, public TypePromotion<IAS\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unknown element in AST: {}\", getID());\n     }\n \n-    // Secrets are displayed regarding show_secrets, then SensitiveDataMasker is applied.\n-    // You can use Interpreters/formatWithPossiblyHidingSecrets.h for convenience.\n+    /// Secrets are displayed regarding show_secrets, then SensitiveDataMasker is applied.\n+    /// You can use Interpreters/formatWithPossiblyHidingSecrets.h for convenience.\n     String formatWithPossiblyHidingSensitiveData(size_t max_length, bool one_line, bool show_secrets) const;\n \n-    /*\n-     * formatForLogging and formatForErrorMessage always hide secrets. This inconsistent\n-     * behaviour is due to the fact such functions are called from Client which knows nothing about\n-     * access rights and settings. Moreover, the only use case for displaying secrets are backups,\n-     * and backup tools use only direct input and ignore logs and error messages.\n-     */\n+    /** formatForLogging and formatForErrorMessage always hide secrets. This inconsistent\n+      * behaviour is due to the fact such functions are called from Client which knows nothing about\n+      * access rights and settings. Moreover, the only use case for displaying secrets are backups,\n+      * and backup tools use only direct input and ignore logs and error messages.\n+      */\n     String formatForLogging(size_t max_length = 0) const\n     {\n         return formatWithPossiblyHidingSensitiveData(max_length, true, false);\ndiff --git a/src/Parsers/ParserAlterQuery.cpp b/src/Parsers/ParserAlterQuery.cpp\nindex 28dbf7810112..dbefb0cb966b 100644\n--- a/src/Parsers/ParserAlterQuery.cpp\n+++ b/src/Parsers/ParserAlterQuery.cpp\n@@ -9,8 +9,6 @@\n #include <Parsers/ParserRefreshStrategy.h>\n #include <Parsers/ParserSelectWithUnionQuery.h>\n #include <Parsers/ParserSetQuery.h>\n-#include <Parsers/ASTIdentifier.h>\n-#include <Parsers/ASTIndexDeclaration.h>\n #include <Parsers/ASTAlterQuery.h>\n #include <Parsers/ASTLiteral.h>\n #include <Parsers/parseDatabaseAndTableName.h>\ndiff --git a/src/Parsers/ParserCreateIndexQuery.cpp b/src/Parsers/ParserCreateIndexQuery.cpp\nindex 2fa34696c58f..9ebee4cc852e 100644\n--- a/src/Parsers/ParserCreateIndexQuery.cpp\n+++ b/src/Parsers/ParserCreateIndexQuery.cpp\n@@ -7,9 +7,9 @@\n #include <Parsers/ASTLiteral.h>\n #include <Parsers/CommonParsers.h>\n #include <Parsers/ExpressionListParsers.h>\n-#include <Parsers/ParserDataType.h>\n #include <Parsers/parseDatabaseAndTableName.h>\n \n+\n namespace DB\n {\n \n@@ -21,7 +21,7 @@ bool ParserCreateIndexDeclaration::parseImpl(Pos & pos, ASTPtr & node, Expected\n     ParserToken close_p(TokenType::ClosingRoundBracket);\n     ParserOrderByExpressionList order_list_p;\n \n-    ParserDataType data_type_p;\n+    ParserExpressionWithOptionalArguments type_p;\n     ParserExpression expression_p;\n     ParserUnsignedInteger granularity_p;\n \n@@ -68,7 +68,7 @@ bool ParserCreateIndexDeclaration::parseImpl(Pos & pos, ASTPtr & node, Expected\n \n     if (s_type.ignore(pos, expected))\n     {\n-        if (!data_type_p.parse(pos, type, expected))\n+        if (!type_p.parse(pos, type, expected))\n             return false;\n     }\n \ndiff --git a/src/Parsers/ParserCreateQuery.cpp b/src/Parsers/ParserCreateQuery.cpp\nindex 1cc565a41d15..a592975613bd 100644\n--- a/src/Parsers/ParserCreateQuery.cpp\n+++ b/src/Parsers/ParserCreateQuery.cpp\n@@ -5,6 +5,7 @@\n #include <Parsers/ASTExpressionList.h>\n #include <Parsers/ASTForeignKeyDeclaration.h>\n #include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTDataType.h>\n #include <Parsers/ASTIdentifier.h>\n #include <Parsers/ASTIndexDeclaration.h>\n #include <Parsers/ASTStatisticsDeclaration.h>\n@@ -76,9 +77,9 @@ bool ParserNestedTable::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     if (!close.ignore(pos, expected))\n         return false;\n \n-    auto func = std::make_shared<ASTFunction>();\n+    auto func = std::make_shared<ASTDataType>();\n     tryGetIdentifierNameInto(name, func->name);\n-    // FIXME(ilezhankin): func->no_empty_args = true; ?\n+\n     func->arguments = columns;\n     func->children.push_back(columns);\n     node = func;\n@@ -179,7 +180,7 @@ bool ParserIndexDeclaration::parseImpl(Pos & pos, ASTPtr & node, Expected & expe\n     ParserKeyword s_granularity(Keyword::GRANULARITY);\n \n     ParserIdentifier name_p;\n-    ParserDataType data_type_p;\n+    ParserExpressionWithOptionalArguments type_p;\n     ParserExpression expression_p;\n     ParserUnsignedInteger granularity_p;\n \n@@ -197,7 +198,7 @@ bool ParserIndexDeclaration::parseImpl(Pos & pos, ASTPtr & node, Expected & expe\n     if (!s_type.ignore(pos, expected))\n         return false;\n \n-    if (!data_type_p.parse(pos, type, expected))\n+    if (!type_p.parse(pos, type, expected))\n         return false;\n \n     if (s_granularity.ignore(pos, expected))\n@@ -231,7 +232,7 @@ bool ParserStatisticsDeclaration::parseImpl(Pos & pos, ASTPtr & node, Expected &\n     ParserKeyword s_type(Keyword::TYPE);\n \n     ParserList columns_p(std::make_unique<ParserIdentifier>(), std::make_unique<ParserToken>(TokenType::Comma), false);\n-    ParserList types_p(std::make_unique<ParserDataType>(), std::make_unique<ParserToken>(TokenType::Comma), false);\n+    ParserList types_p(std::make_unique<ParserExpressionWithOptionalArguments>(), std::make_unique<ParserToken>(TokenType::Comma), false);\n \n     ASTPtr columns;\n     ASTPtr types;\n@@ -751,7 +752,7 @@ bool ParserCreateTableQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expe\n \n     auto * table_id = table->as<ASTTableIdentifier>();\n \n-    // Shortcut for ATTACH a previously detached table\n+    /// A shortcut for ATTACH a previously detached table.\n     bool short_attach = attach && !from_path;\n     if (short_attach && (!pos.isValid() || pos.get().type == TokenType::Semicolon))\n     {\ndiff --git a/src/Parsers/ParserCreateQuery.h b/src/Parsers/ParserCreateQuery.h\nindex bb37491a3660..53a62deb22b8 100644\n--- a/src/Parsers/ParserCreateQuery.h\n+++ b/src/Parsers/ParserCreateQuery.h\n@@ -1,6 +1,7 @@\n #pragma once\n \n #include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTDataType.h>\n #include <Parsers/ASTColumnDeclaration.h>\n #include <Parsers/ASTIdentifier_fwd.h>\n #include <Parsers/ASTLiteral.h>\n@@ -13,6 +14,7 @@\n #include <Parsers/ParserSetQuery.h>\n #include <Poco/String.h>\n \n+\n namespace DB\n {\n \n@@ -101,17 +103,15 @@ class IParserColumnDeclaration : public IParserBase\n {\n public:\n     explicit IParserColumnDeclaration(bool require_type_ = true, bool allow_null_modifiers_ = false, bool check_keywords_after_name_ = false)\n-    : require_type(require_type_)\n-    , allow_null_modifiers(allow_null_modifiers_)\n-    , check_keywords_after_name(check_keywords_after_name_)\n+        : require_type(require_type_)\n+        , allow_null_modifiers(allow_null_modifiers_)\n+        , check_keywords_after_name(check_keywords_after_name_)\n     {\n     }\n \n     void enableCheckTypeKeyword() { check_type_keyword = true; }\n \n protected:\n-    using ASTDeclarePtr = std::shared_ptr<ASTColumnDeclaration>;\n-\n     const char * getName() const  override{ return \"column declaration\"; }\n \n     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n@@ -270,9 +270,8 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E\n             auto default_function = std::make_shared<ASTFunction>();\n             default_function->name = \"defaultValueOfTypeName\";\n             default_function->arguments = std::make_shared<ASTExpressionList>();\n-            // Ephemeral columns don't really have secrets but we need to format\n-            // into a String, hence the strange call\n-            default_function->arguments->children.emplace_back(std::make_shared<ASTLiteral>(type->as<ASTFunction>()->formatForLogging()));\n+            /// Ephemeral columns don't really have secrets but we need to format into a String, hence the strange call\n+            default_function->arguments->children.emplace_back(std::make_shared<ASTLiteral>(type->as<ASTDataType>()->formatForLogging()));\n             default_expression = default_function;\n         }\n \ndiff --git a/src/Parsers/ParserDataType.cpp b/src/Parsers/ParserDataType.cpp\nindex ad33c7e4558b..2edb0141e122 100644\n--- a/src/Parsers/ParserDataType.cpp\n+++ b/src/Parsers/ParserDataType.cpp\n@@ -1,8 +1,8 @@\n #include <Parsers/ParserDataType.h>\n \n #include <boost/algorithm/string/case_conv.hpp>\n+#include <Parsers/ASTDataType.h>\n #include <Parsers/ASTFunction.h>\n-#include <Parsers/ASTIdentifier.h>\n #include <Parsers/ASTIdentifier_fwd.h>\n #include <Parsers/CommonParsers.h>\n #include <Parsers/ExpressionElementParsers.h>\n@@ -46,48 +46,6 @@ class DynamicArgumentsParser : public IParserBase\n     }\n };\n \n-/// Wrapper to allow mixed lists of nested and normal types.\n-/// Parameters are either:\n-/// - Nested table elements;\n-/// - Enum element in form of 'a' = 1;\n-/// - literal;\n-/// - Dynamic type arguments;\n-/// - another data type (or identifier);\n-class ParserDataTypeArgument : public IParserBase\n-{\n-public:\n-    explicit ParserDataTypeArgument(std::string_view type_name_) : type_name(type_name_)\n-    {\n-    }\n-\n-private:\n-    const char * getName() const override { return \"data type argument\"; }\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override\n-    {\n-        if (type_name == \"Dynamic\")\n-        {\n-            DynamicArgumentsParser parser;\n-            return parser.parse(pos, node, expected);\n-        }\n-\n-        ParserNestedTable nested_parser;\n-        ParserDataType data_type_parser;\n-        ParserAllCollectionsOfLiterals literal_parser(false);\n-\n-        const char * operators[] = {\"=\", \"equals\", nullptr};\n-        ParserLeftAssociativeBinaryOperatorList enum_parser(operators, std::make_unique<ParserLiteral>());\n-\n-        if (pos->type == TokenType::BareWord && std::string_view(pos->begin, pos->size()) == \"Nested\")\n-            return nested_parser.parse(pos, node, expected);\n-\n-        return enum_parser.parse(pos, node, expected)\n-            || literal_parser.parse(pos, node, expected)\n-            || data_type_parser.parse(pos, node, expected);\n-    }\n-\n-    std::string_view type_name;\n-};\n-\n }\n \n bool ParserDataType::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n@@ -198,23 +156,102 @@ bool ParserDataType::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n         }\n     }\n \n-    auto function_node = std::make_shared<ASTFunction>();\n-    function_node->name = type_name;\n-    function_node->no_empty_args = true;\n+    auto data_type_node = std::make_shared<ASTDataType>();\n+    data_type_node->name = type_name;\n \n     if (pos->type != TokenType::OpeningRoundBracket)\n     {\n-        node = function_node;\n+        node = data_type_node;\n         return true;\n     }\n     ++pos;\n \n     /// Parse optional parameters\n-    ParserList args_parser(std::make_unique<ParserDataTypeArgument>(type_name), std::make_unique<ParserToken>(TokenType::Comma));\n-    ASTPtr expr_list_args;\n+    ASTPtr expr_list_args = std::make_shared<ASTExpressionList>();\n+\n+    /// Allow mixed lists of nested and normal types.\n+    /// Parameters are either:\n+    /// - Nested table elements;\n+    /// - Enum element in form of 'a' = 1;\n+    /// - literal;\n+    /// - Dynamic type arguments;\n+    /// - another data type (or identifier);\n+\n+    size_t arg_num = 0;\n+    bool have_version_of_aggregate_function = false;\n+    while (true)\n+    {\n+        if (arg_num > 0)\n+        {\n+            if (pos->type == TokenType::Comma)\n+                ++pos;\n+            else\n+                break;\n+        }\n+\n+        ASTPtr arg;\n+        if (type_name == \"Dynamic\")\n+        {\n+            DynamicArgumentsParser parser;\n+            parser.parse(pos, arg, expected);\n+        }\n+        else if (type_name == \"Nested\")\n+        {\n+            ParserNestedTable nested_parser;\n+            nested_parser.parse(pos, arg, expected);\n+        }\n+        else if (type_name == \"AggregateFunction\" || type_name == \"SimpleAggregateFunction\")\n+        {\n+            /// This is less trivial.\n+            /// The first optional argument for AggregateFunction is a numeric literal, defining the version.\n+            /// The next argument is the function name, optionally with parameters.\n+            /// Subsequent arguments are data types.\n+\n+            if (arg_num == 0 && type_name == \"AggregateFunction\")\n+            {\n+                ParserUnsignedInteger version_parser;\n+                if (version_parser.parse(pos, arg, expected))\n+                {\n+                    have_version_of_aggregate_function = true;\n+                    expr_list_args->children.emplace_back(std::move(arg));\n+                    ++arg_num;\n+                    continue;\n+                }\n+            }\n+\n+            if (arg_num == (have_version_of_aggregate_function ? 1 : 0))\n+            {\n+                ParserFunction function_parser;\n+                ParserIdentifier identifier_parser;\n+                function_parser.parse(pos, arg, expected)\n+                    || identifier_parser.parse(pos, arg, expected);\n+            }\n+            else\n+            {\n+                ParserDataType data_type_parser;\n+                data_type_parser.parse(pos, arg, expected);\n+            }\n+        }\n+        else\n+        {\n+            ParserDataType data_type_parser;\n+            ParserAllCollectionsOfLiterals literal_parser(false);\n+\n+            const char * operators[] = {\"=\", \"equals\", nullptr};\n+            ParserLeftAssociativeBinaryOperatorList enum_parser(operators, std::make_unique<ParserLiteral>());\n+\n+            enum_parser.parse(pos, arg, expected)\n+               || literal_parser.parse(pos, arg, expected)\n+               || data_type_parser.parse(pos, arg, expected);\n+        }\n+\n+        if (!arg)\n+            break;\n+\n+        expr_list_args->children.emplace_back(std::move(arg));\n+        ++arg_num;\n+    }\n \n-    if (!args_parser.parse(pos, expr_list_args, expected))\n-        return false;\n     if (pos->type == TokenType::Comma)\n         // ignore trailing comma inside Nested structures like Tuple(Int, Tuple(Int, String),)\n         ++pos;\n@@ -222,10 +259,10 @@ bool ParserDataType::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n         return false;\n     ++pos;\n \n-    function_node->arguments = expr_list_args;\n-    function_node->children.push_back(function_node->arguments);\n+    data_type_node->arguments = expr_list_args;\n+    data_type_node->children.push_back(data_type_node->arguments);\n \n-    node = function_node;\n+    node = data_type_node;\n     return true;\n }\n \ndiff --git a/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp b/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp\nindex f4c38a52a3fc..a9778d5d04d9 100644\n--- a/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp\n+++ b/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp\n@@ -10,7 +10,6 @@\n #include <Core/Settings.h>\n #include <Core/PostgreSQL/Connection.h>\n \n-#include <DataTypes/DataTypeString.h>\n #include <DataTypes/DataTypeNullable.h>\n #include <DataTypes/DataTypeArray.h>\n #include <DataTypes/DataTypesDecimal.h>\n@@ -22,6 +21,7 @@\n #include <Processors/QueryPlan/QueryPlan.h>\n #include <Processors/QueryPlan/ReadFromPreparedSource.h>\n #include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTDataType.h>\n #include <Parsers/ASTIdentifier.h>\n #include <Parsers/ASTTablesInSelectQuery.h>\n #include <Parsers/ExpressionListParsers.h>\n@@ -295,7 +295,7 @@ std::shared_ptr<ASTColumnDeclaration> StorageMaterializedPostgreSQL::getMaterial\n     auto column_declaration = std::make_shared<ASTColumnDeclaration>();\n \n     column_declaration->name = std::move(name);\n-    column_declaration->type = makeASTFunction(type);\n+    column_declaration->type = makeASTDataType(type);\n \n     column_declaration->default_specifier = \"MATERIALIZED\";\n     column_declaration->default_expression = std::make_shared<ASTLiteral>(default_value);\n@@ -312,17 +312,17 @@ ASTPtr StorageMaterializedPostgreSQL::getColumnDeclaration(const DataTypePtr & d\n     WhichDataType which(data_type);\n \n     if (which.isNullable())\n-        return makeASTFunction(\"Nullable\", getColumnDeclaration(typeid_cast<const DataTypeNullable *>(data_type.get())->getNestedType()));\n+        return makeASTDataType(\"Nullable\", getColumnDeclaration(typeid_cast<const DataTypeNullable *>(data_type.get())->getNestedType()));\n \n     if (which.isArray())\n-        return makeASTFunction(\"Array\", getColumnDeclaration(typeid_cast<const DataTypeArray *>(data_type.get())->getNestedType()));\n+        return makeASTDataType(\"Array\", getColumnDeclaration(typeid_cast<const DataTypeArray *>(data_type.get())->getNestedType()));\n \n     /// getName() for decimal returns 'Decimal(precision, scale)', will get an error with it\n     if (which.isDecimal())\n     {\n         auto make_decimal_expression = [&](std::string type_name)\n         {\n-            auto ast_expression = std::make_shared<ASTFunction>();\n+            auto ast_expression = std::make_shared<ASTDataType>();\n \n             ast_expression->name = type_name;\n             ast_expression->arguments = std::make_shared<ASTExpressionList>();\n@@ -346,7 +346,7 @@ ASTPtr StorageMaterializedPostgreSQL::getColumnDeclaration(const DataTypePtr & d\n \n     if (which.isDateTime64())\n     {\n-        auto ast_expression = std::make_shared<ASTFunction>();\n+        auto ast_expression = std::make_shared<ASTDataType>();\n \n         ast_expression->name = \"DateTime64\";\n         ast_expression->arguments = std::make_shared<ASTExpressionList>();\n@@ -354,7 +354,7 @@ ASTPtr StorageMaterializedPostgreSQL::getColumnDeclaration(const DataTypePtr & d\n         return ast_expression;\n     }\n \n-    return std::make_shared<ASTIdentifier>(data_type->getName());\n+    return makeASTDataType(data_type->getName());\n }\n \n \ndiff --git a/src/Storages/WindowView/StorageWindowView.cpp b/src/Storages/WindowView/StorageWindowView.cpp\nindex 8975f9327b14..36b6fbe46f05 100644\n--- a/src/Storages/WindowView/StorageWindowView.cpp\n+++ b/src/Storages/WindowView/StorageWindowView.cpp\n@@ -20,6 +20,7 @@\n #include <Parsers/ASTAsterisk.h>\n #include <Parsers/ASTCreateQuery.h>\n #include <Parsers/ASTDropQuery.h>\n+#include <Parsers/ASTDataType.h>\n #include <Parsers/ASTIdentifier.h>\n #include <Parsers/ASTLiteral.h>\n #include <Parsers/ASTOrderByElement.h>\n@@ -805,7 +806,7 @@ ASTPtr StorageWindowView::getInnerTableCreateQuery(const ASTPtr & inner_query, c\n     {\n         auto column_window = std::make_shared<ASTColumnDeclaration>();\n         column_window->name = window_id_name;\n-        column_window->type = std::make_shared<ASTIdentifier>(\"UInt32\");\n+        column_window->type = makeASTDataType(\"UInt32\");\n         columns_list->children.push_back(column_window);\n     }\n \ndiff --git a/src/TableFunctions/ITableFunction.cpp b/src/TableFunctions/ITableFunction.cpp\nindex e5676c5c25dc..916ff7ec0222 100644\n--- a/src/TableFunctions/ITableFunction.cpp\n+++ b/src/TableFunctions/ITableFunction.cpp\n@@ -1,5 +1,4 @@\n #include <TableFunctions/ITableFunction.h>\n-#include <Interpreters/Context.h>\n #include <Storages/StorageFactory.h>\n #include <Storages/StorageTableFunction.h>\n #include <Access/Common/AccessFlags.h>\n",
  "test_patch": "diff --git a/src/Interpreters/MySQL/tests/gtest_create_rewritten.cpp b/src/Interpreters/MySQL/tests/gtest_create_rewritten.cpp\nindex 6d6077a0295d..81e6e6a87611 100644\n--- a/src/Interpreters/MySQL/tests/gtest_create_rewritten.cpp\n+++ b/src/Interpreters/MySQL/tests/gtest_create_rewritten.cpp\n@@ -2,12 +2,10 @@\n \n #include <gtest/gtest.h>\n \n-#include <Parsers/IAST.h>\n #include <Parsers/queryToString.h>\n #include <Parsers/ASTExternalDDLQuery.h>\n #include <Parsers/ParserExternalDDLQuery.h>\n #include <Parsers/parseQuery.h>\n-#include <Interpreters/Context.h>\n #include <Interpreters/MySQL/InterpretersMySQLDDLQuery.h>\n #include <Common/tests/gtest_global_context.h>\n #include <Common/tests/gtest_global_register.h>\n@@ -26,8 +24,8 @@ static inline ASTPtr tryRewrittenCreateQuery(const String & query, ContextPtr co\n         context, \"test_database\", \"test_database\")[0];\n }\n \n-static const char MATERIALIZEDMYSQL_TABLE_COLUMNS[] = \", `_sign` Int8() MATERIALIZED 1\"\n-                                                     \", `_version` UInt64() MATERIALIZED 1\"\n+static const char MATERIALIZEDMYSQL_TABLE_COLUMNS[] = \", `_sign` Int8 MATERIALIZED 1\"\n+                                                     \", `_version` UInt64 MATERIALIZED 1\"\n                                                      \", INDEX _version _version TYPE minmax GRANULARITY 1\";\n \n TEST(MySQLCreateRewritten, ColumnsDataType)\ndiff --git a/src/Parsers/MySQL/tests/gtest_column_parser.cpp b/src/Parsers/MySQL/tests/gtest_column_parser.cpp\nindex 21c37e4ee2e1..3a9a0690f060 100644\n--- a/src/Parsers/MySQL/tests/gtest_column_parser.cpp\n+++ b/src/Parsers/MySQL/tests/gtest_column_parser.cpp\n@@ -1,13 +1,14 @@\n #include <gtest/gtest.h>\n #include <Parsers/parseQuery.h>\n #include <Parsers/ASTLiteral.h>\n-#include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTDataType.h>\n #include <Parsers/ASTIdentifier.h>\n #include <Parsers/MySQL/ASTDeclareColumn.h>\n #include <Parsers/MySQL/ASTDeclareOption.h>\n #include <Parsers/MySQL/ASTDeclareReference.h>\n #include <Parsers/MySQL/ASTDeclareConstraint.h>\n \n+\n using namespace DB;\n using namespace DB::MySQLParser;\n \n@@ -19,8 +20,8 @@ TEST(ParserColumn, AllNonGeneratedColumnOption)\n                    \"COLUMN_FORMAT FIXED STORAGE MEMORY REFERENCES tbl_name (col_01) CHECK 1\";\n     ASTPtr ast = parseQuery(p_column, input.data(), input.data() + input.size(), \"\", 0, 0, 0);\n     EXPECT_EQ(ast->as<ASTDeclareColumn>()->name, \"col_01\");\n-    EXPECT_EQ(ast->as<ASTDeclareColumn>()->data_type->as<ASTFunction>()->name, \"VARCHAR\");\n-    EXPECT_EQ(ast->as<ASTDeclareColumn>()->data_type->as<ASTFunction>()->arguments->children[0]->as<ASTLiteral>()->value.safeGet<UInt64>(), 100);\n+    EXPECT_EQ(ast->as<ASTDeclareColumn>()->data_type->as<ASTDataType>()->name, \"VARCHAR\");\n+    EXPECT_EQ(ast->as<ASTDeclareColumn>()->data_type->as<ASTDataType>()->arguments->children[0]->as<ASTLiteral>()->value.safeGet<UInt64>(), 100);\n \n     ASTDeclareOptions * declare_options = ast->as<ASTDeclareColumn>()->column_options->as<ASTDeclareOptions>();\n     EXPECT_EQ(declare_options->changes[\"is_null\"]->as<ASTLiteral>()->value.safeGet<UInt64>(), 0);\n@@ -44,8 +45,8 @@ TEST(ParserColumn, AllGeneratedColumnOption)\n                    \"REFERENCES tbl_name (col_01) CHECK 1 GENERATED ALWAYS AS (1) STORED\";\n     ASTPtr ast = parseQuery(p_column, input.data(), input.data() + input.size(), \"\", 0, 0, 0);\n     EXPECT_EQ(ast->as<ASTDeclareColumn>()->name, \"col_01\");\n-    EXPECT_EQ(ast->as<ASTDeclareColumn>()->data_type->as<ASTFunction>()->name, \"VARCHAR\");\n-    EXPECT_EQ(ast->as<ASTDeclareColumn>()->data_type->as<ASTFunction>()->arguments->children[0]->as<ASTLiteral>()->value.safeGet<UInt64>(), 100);\n+    EXPECT_EQ(ast->as<ASTDeclareColumn>()->data_type->as<ASTDataType>()->name, \"VARCHAR\");\n+    EXPECT_EQ(ast->as<ASTDeclareColumn>()->data_type->as<ASTDataType>()->arguments->children[0]->as<ASTLiteral>()->value.safeGet<UInt64>(), 100);\n \n     ASTDeclareOptions * declare_options = ast->as<ASTDeclareColumn>()->column_options->as<ASTDeclareOptions>();\n     EXPECT_EQ(declare_options->changes[\"is_null\"]->as<ASTLiteral>()->value.safeGet<UInt64>(), 1);\ndiff --git a/tests/integration/test_postgresql_replica_database_engine_2/test.py b/tests/integration/test_postgresql_replica_database_engine_2/test.py\nindex 5e04c9e4d125..406b50bc486a 100644\n--- a/tests/integration/test_postgresql_replica_database_engine_2/test.py\n+++ b/tests/integration/test_postgresql_replica_database_engine_2/test.py\n@@ -654,7 +654,7 @@ def test_table_override(started_cluster):\n         instance.query(f\"SELECT count() FROM {materialized_database}.{table_name}\")\n     )\n \n-    expected = \"CREATE TABLE test_database.table_override\\\\n(\\\\n    `key` Int32,\\\\n    `value` String,\\\\n    `_sign` Int8() MATERIALIZED 1,\\\\n    `_version` UInt64() MATERIALIZED 1\\\\n)\\\\nENGINE = ReplacingMergeTree(_version)\\\\nPARTITION BY key\\\\nORDER BY tuple(key)\"\n+    expected = \"CREATE TABLE test_database.table_override\\\\n(\\\\n    `key` Int32,\\\\n    `value` String,\\\\n    `_sign` Int8 MATERIALIZED 1,\\\\n    `_version` UInt64 MATERIALIZED 1\\\\n)\\\\nENGINE = ReplacingMergeTree(_version)\\\\nPARTITION BY key\\\\nORDER BY tuple(key)\"\n     assert (\n         expected\n         == instance.query(\ndiff --git a/tests/queries/0_stateless/01600_parts_states_metrics_long.sh b/tests/queries/0_stateless/01600_parts_states_metrics_long.sh\nindex 2e47034e5286..7215f270a4cb 100755\n--- a/tests/queries/0_stateless/01600_parts_states_metrics_long.sh\n+++ b/tests/queries/0_stateless/01600_parts_states_metrics_long.sh\n@@ -1,4 +1,5 @@\n #!/usr/bin/env bash\n+# Tags: long\n \n CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n # shellcheck source=../shell_config.sh\n@@ -15,17 +16,26 @@ verify_sql=\"SELECT\n # In case of test failure, this code will do infinite loop and timeout.\n verify()\n {\n-    while true\n+    for i in {1..5000}\n     do\n-        result=$( $CLICKHOUSE_CLIENT -m --query=\"$verify_sql\" )\n-        [ \"$result\" = \"1\" ] && break\n+        result=$( $CLICKHOUSE_CLIENT --query=\"$verify_sql\" )\n+        [ \"$result\" = \"1\" ] && echo \"$result\" && break\n         sleep 0.1\n+\n+        if [[ $i -eq 5000 ]]\n+        then\n+            $CLICKHOUSE_CLIENT --multiquery \"\n+              SELECT sumIf(value, metric = 'PartsActive'), sumIf(value, metric = 'PartsOutdated') FROM system.metrics;\n+              SELECT sum(active), sum(NOT active) FROM system.parts;\n+              SELECT sum(active), sum(NOT active) FROM system.projection_parts;\n+              SELECT count() FROM system.dropped_tables_parts;\n+            \"\n+        fi\n     done\n-    echo 1\n }\n \n $CLICKHOUSE_CLIENT --database_atomic_wait_for_drop_and_detach_synchronously=1 --query=\"DROP TABLE IF EXISTS test_table\"\n-$CLICKHOUSE_CLIENT --query=\"CREATE TABLE test_table(data Date) ENGINE = MergeTree  PARTITION BY toYear(data) ORDER BY data;\"\n+$CLICKHOUSE_CLIENT --query=\"CREATE TABLE test_table (data Date) ENGINE = MergeTree PARTITION BY toYear(data) ORDER BY data;\"\n \n $CLICKHOUSE_CLIENT --query=\"INSERT INTO test_table VALUES ('1992-01-01')\"\n verify\ndiff --git a/tests/queries/0_stateless/03210_inconsistent_formatting_of_data_types.reference b/tests/queries/0_stateless/03210_inconsistent_formatting_of_data_types.reference\nnew file mode 100644\nindex 000000000000..836b526905ae\n--- /dev/null\n+++ b/tests/queries/0_stateless/03210_inconsistent_formatting_of_data_types.reference\n@@ -0,0 +1,7 @@\n+ALTER TABLE columns_with_multiple_streams MODIFY COLUMN `field1` Nullable(tupleElement(x, 2), UInt8)\n+ALTER TABLE t_update_empty_nested ADD COLUMN `nested.arr2` Array(tuple('- ON NULL -', toLowCardinality(11), 11, 11, toLowCardinality(11), 11), UInt64)\n+ALTER TABLE t ADD COLUMN `x` Array(tuple(1), UInt8)\n+ALTER TABLE enum_alter_issue MODIFY COLUMN `a` Enum8(equals('one', timeSlots(timeSlots(arrayEnumerateDense(tuple('0.2147483646', toLowCardinality(toUInt128)), NULL), 4, 12.34, materialize(73), 2)), 1))\n+ALTER TABLE t_sparse_mutations_3 MODIFY COLUMN `s` Tuple(Nullable(tupleElement(s, 1), UInt64), Nullable(UInt64), Nullable(UInt64), Nullable(UInt64), Nullable(String))\n+Syntax error\n+Syntax error\ndiff --git a/tests/queries/0_stateless/03210_inconsistent_formatting_of_data_types.sh b/tests/queries/0_stateless/03210_inconsistent_formatting_of_data_types.sh\nnew file mode 100755\nindex 000000000000..86c7a5469ca3\n--- /dev/null\n+++ b/tests/queries/0_stateless/03210_inconsistent_formatting_of_data_types.sh\n@@ -0,0 +1,16 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+# Ensure that these (possibly incorrect) queries can at least be parsed back after formatting.\n+$CLICKHOUSE_FORMAT --oneline --query \"ALTER TABLE columns_with_multiple_streams MODIFY COLUMN field1 Nullable(tupleElement(x, 2), UInt8)\" | $CLICKHOUSE_FORMAT --oneline\n+$CLICKHOUSE_FORMAT --oneline --query \"ALTER TABLE t_update_empty_nested ADD COLUMN \\`nested.arr2\\` Array(tuple('- ON NULL -', toLowCardinality(11), 11, 11, toLowCardinality(11), 11), UInt64)\" | $CLICKHOUSE_FORMAT --oneline\n+$CLICKHOUSE_FORMAT --oneline --query \"ALTER TABLE t ADD COLUMN x Array((1), UInt8)\" | $CLICKHOUSE_FORMAT --oneline\n+$CLICKHOUSE_FORMAT --oneline --query \"ALTER TABLE enum_alter_issue (MODIFY COLUMN a Enum8(equals('one', timeSlots(timeSlots(arrayEnumerateDense(tuple('0.2147483646', toLowCardinality(toUInt128(12))), NULL), 4, 12.34, materialize(73), 2)), 1)))\" | $CLICKHOUSE_FORMAT --oneline\n+$CLICKHOUSE_FORMAT --oneline --query \"ALTER TABLE t_sparse_mutations_3 MODIFY COLUMN s Tuple(Nullable(tupleElement(s, 1), UInt64), Nullable(UInt64), Nullable(UInt64), Nullable(UInt64), Nullable(String))\" | $CLICKHOUSE_FORMAT --oneline\n+\n+# These invalid queries don't parse and this is normal.\n+$CLICKHOUSE_FORMAT --oneline --query \"ALTER TABLE alter_compression_codec1 MODIFY COLUMN alter_column CODEC((2 + ignore(1, toUInt128(materialize(2)), 2 + toNullable(toNullable(3))), 3), NONE)\" 2>&1 | grep -o -F 'Syntax error'\n+$CLICKHOUSE_FORMAT --oneline --query \"ALTER TABLE test_table ADD COLUMN \\`array\\` Array(('110', 3, toLowCardinality(3), 3, toNullable(3), toLowCardinality(toNullable(3)), 3), UInt8) DEFAULT [1, 2, 3]\" 2>&1 | grep -o -F 'Syntax error'\n",
  "problem_statement": "Logical error found by fuzzer `Inconsistent AST formatting: the query: ALTER TABLE enum_alter_issue MODIFY COLUMN` (related to Enum)\n```\r\n2024.07.30 03:00:45.294456 [ 188 ] {3e92d4fd-fb5f-4e7f-8d07-7ba7e95cec0e} <Fatal> : Logical error: 'Inconsistent AST formatting: the query:\r\nALTER TABLE enum_alter_issue MODIFY COLUMN `a` Enum8(equals(arrayExists(toNullable(18), range(arrayExists(range(toUInt256 % 10)), 51)), 'one', 1), 'two' = 2, 'three' = 3)\r\ncannot parse.'.\r\n2024.07.30 03:00:45.304329 [ 188 ] {3e92d4fd-fb5f-4e7f-8d07-7ba7e95cec0e} <Fatal> : Stack trace (when copying this message, always include the lines below):\r\n\r\n0. /build/contrib/llvm-project/libcxx/include/exception:141: Poco::Exception::Exception(String const&, int) @ 0x0000000016005212\r\n1. /build/src/Common/Exception.cpp:111: DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0x000000000c3fa4b9\r\n2. /build/contrib/llvm-project/libcxx/include/string:1499: DB::Exception::Exception(PreformattedMessage&&, int) @ 0x0000000006e0014c\r\n3. /build/contrib/llvm-project/libcxx/include/vector:438: DB::Exception::Exception<String&>(int, FormatStringHelperImpl<std::type_identity<String&>::type>, String&) @ 0x0000000006e2916b\r\n4. /build/src/Interpreters/executeQuery.cpp:800: DB::executeQueryImpl(char const*, char const*, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum, DB::ReadBuffer*) @ 0x0000000011606c7a\r\n5. /build/src/Interpreters/executeQuery.cpp:1390: DB::executeQuery(String const&, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum) @ 0x000000001160097d\r\n6. /build/contrib/llvm-project/libcxx/include/__memory/shared_ptr.h:612: DB::TCPHandler::runImpl() @ 0x00000000128792db\r\n7. /build/contrib/llvm-project/libcxx/include/__memory/shared_ptr.h:593: DB::TCPHandler::run() @ 0x000000001288e7f9\r\n8. /build/base/poco/Net/src/TCPServerConnection.cpp:57: Poco::Net::TCPServerConnection::start() @ 0x00000000160aa6e7\r\n9. /build/contrib/llvm-project/libcxx/include/__memory/unique_ptr.h:48: Poco::Net::TCPServerDispatcher::run() @ 0x00000000160aabbe\r\n10. /build/base/poco/Foundation/src/ThreadPool.cpp:219: Poco::PooledThread::run() @ 0x00000000160574d2\r\n11. /build/base/poco/Foundation/include/Poco/AutoPtr.h:77: Poco::ThreadImpl::runnableEntry(void*) @ 0x00000000160551e3\r\n12. ? @ 0x00007f08b25efac3\r\n13. ? @ 0x00007f08b2681850\r\n```\r\nLink: https://s3.amazonaws.com/clickhouse-test-reports/67392/c2a40940dbc6a2bac3623bef2ac56bc842d837fd/ast_fuzzer__debug_.html\nInconsistent AST formatting in ALTER ADD COLUMN\n```\r\nset allow_suspicious_low_cardinality_types=1;\r\nCREATE TABLE t_update_empty_nested__fuzz_48\r\n(\r\n    `id` LowCardinality(DateTime),\r\n    `nested.arr\\n1` Nullable(UInt32)\r\n)\r\nENGINE = MergeTree\r\nORDER BY id\r\nSETTINGS min_bytes_for_wide_part = 0, index_granularity = 8192, index_granularity_bytes = '10Mi'\r\n\r\n:) ALTER TABLE t_update_empty_nested ADD COLUMN `nested.arr2` Array(tuple('- ON NULL -', toLowCardinality(11), 11, 11, toLowCardinality(11), 11), UInt64)\r\n\r\nALTER TABLE t_update_empty_nested\r\n    (ADD COLUMN `nested.arr2` Array(('- ON NULL -', toLowCardinality(11), 11, 11, toLowCardinality(11), 11), UInt64))\r\n\r\nQuery id: f7a05155-9fb8-4b96-9c04-7fb31e6da948\r\n\r\n[ip-172-31-26-174] 2024.03.19 17:48:52.502892 [ 3442780 ] {f7a05155-9fb8-4b96-9c04-7fb31e6da948} <Fatal> : Logical error: 'Inconsistent AST formatting: the query:\r\nALTER TABLE t_update_empty_nested ADD COLUMN `nested.arr2` Array(('- ON NULL -', toLowCardinality(11), 11, 11, toLowCardinality(11), 11), UInt64)\r\ncannot parse.'.\r\n[ip-172-31-26-174] 2024.03.19 17:48:52.505249 [ 3444530 ] <Fatal> BaseDaemon: ########################################\r\n[ip-172-31-26-174] 2024.03.19 17:48:52.505520 [ 3444530 ] <Fatal> BaseDaemon: (version 24.3.1.1 (official build), build id: E6503786404A306C322D73174D84F3796AB9C150, git hash: 240242da229fa93a45eb3581e0a8763259b42b72) (from thread 3442780) (query_id: f7a05155-9fb8-4b96-9c04-7fb31e6da948) (query: ) Received signal Aborted (6)\r\n[ip-172-31-26-174] 2024.03.19 17:48:52.505764 [ 3444530 ] <Fatal> BaseDaemon: \r\n[ip-172-31-26-174] 2024.03.19 17:48:52.505961 [ 3444530 ] <Fatal> BaseDaemon: Stack trace: 0x00007ff580cbb00b 0x00007ff580c9a859 0x00000000138773df 0x0000000013877455 0x0000000013877991 0x000000000a97f36a 0x000000000a9d1413 0x000000001c0a64b7 0x000000001c0a4d8a 0x000000001d8d2372 0x000000001d8e72a5 0x0000000022caa739 0x0000000022caaf88 0x0000000022e82414 0x0000000022e7f1ba 0x0000000022e7defe 0x00007ff580e72609 0x00007ff580d97353\r\n[ip-172-31-26-174] 2024.03.19 17:48:52.506206 [ 3444530 ] <Fatal> BaseDaemon: 4. ? @ 0x00007ff580cbb00b\r\n[ip-172-31-26-174] 2024.03.19 17:48:52.506379 [ 3444530 ] <Fatal> BaseDaemon: 5. ? @ 0x00007ff580c9a859\r\n[ip-172-31-26-174] 2024.03.19 17:48:52.605578 [ 3444530 ] <Fatal> BaseDaemon: 6. /build/src/Common/Exception.cpp:0: DB::abortOnFailedAssertion(String const&) @ 0x00000000138773df\r\n[ip-172-31-26-174] 2024.03.19 17:48:52.703194 [ 3444530 ] <Fatal> BaseDaemon: 7. /build/src/Common/Exception.cpp:63: DB::handle_error_code(String const&, int, bool, std::vector<void*, std::allocator<void*>> const&) @ 0x0000000013877455\r\n[ip-172-31-26-174] 2024.03.19 17:48:52.783727 [ 3444530 ] <Fatal> BaseDaemon: 8. /build/src/Common/Exception.cpp:100: DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0x0000000013877991\r\n[ip-172-31-26-174] 2024.03.19 17:48:52.857562 [ 3444530 ] <Fatal> BaseDaemon: 9. /build/src/Common/Exception.h:90: DB::Exception::Exception(String&&, int, bool) @ 0x000000000a97f36a\r\n[ip-172-31-26-174] 2024.03.19 17:48:52.975837 [ 3444530 ] <Fatal> BaseDaemon: 10. /build/src/Common/Exception.h:109: DB::Exception::Exception<String&>(int, FormatStringHelperImpl<std::type_identity<String&>::type>, String&) @ 0x000000000a9d1413\r\n[ip-172-31-26-174] 2024.03.19 17:48:53.283622 [ 3444530 ] <Fatal> BaseDaemon: 11. /build/src/Interpreters/executeQuery.cpp:782: DB::executeQueryImpl(char const*, char const*, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum, DB::ReadBuffer*) @ 0x000000001c0a64b7\r\n[ip-172-31-26-174] 2024.03.19 17:48:53.590988 [ 3444530 ] <Fatal> BaseDaemon: 12. /build/src/Interpreters/executeQuery.cpp:1374: DB::executeQuery(String const&, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum) @ 0x000000001c0a4d8a\r\n[ip-172-31-26-174] 2024.03.19 17:48:53.886809 [ 3444530 ] <Fatal> BaseDaemon: 13. /build/src/Server/TCPHandler.cpp:518: DB::TCPHandler::runImpl() @ 0x000000001d8d2372\r\n[ip-172-31-26-174] 2024.03.19 17:48:54.216028 [ 3444530 ] <Fatal> BaseDaemon: 14. /build/src/Server/TCPHandler.cpp:2329: DB::TCPHandler::run() @ 0x000000001d8e72a5\r\n[ip-172-31-26-174] 2024.03.19 17:48:54.233338 [ 3444530 ] <Fatal> BaseDaemon: 15. /build/base/poco/Net/src/TCPServerConnection.cpp:43: Poco::Net::TCPServerConnection::start() @ 0x0000000022caa739\r\n[ip-172-31-26-174] 2024.03.19 17:48:54.258407 [ 3444530 ] <Fatal> BaseDaemon: 16. /build/base/poco/Net/src/TCPServerDispatcher.cpp:115: Poco::Net::TCPServerDispatcher::run() @ 0x0000000022caaf88\r\n[ip-172-31-26-174] 2024.03.19 17:48:54.285033 [ 3444530 ] <Fatal> BaseDaemon: 17. /build/base/poco/Foundation/src/ThreadPool.cpp:188: Poco::PooledThread::run() @ 0x0000000022e82414\r\n[ip-172-31-26-174] 2024.03.19 17:48:54.310898 [ 3444530 ] <Fatal> BaseDaemon: 18. /build/base/poco/Foundation/src/Thread.cpp:46: Poco::(anonymous namespace)::RunnableHolder::run() @ 0x0000000022e7f1ba\r\n[ip-172-31-26-174] 2024.03.19 17:48:54.335155 [ 3444530 ] <Fatal> BaseDaemon: 19. /build/base/poco/Foundation/src/Thread_POSIX.cpp:335: Poco::ThreadImpl::runnableEntry(void*) @ 0x0000000022e7defe\r\n[ip-172-31-26-174] 2024.03.19 17:48:54.335412 [ 3444530 ] <Fatal> BaseDaemon: 20. ? @ 0x00007ff580e72609\r\n[ip-172-31-26-174] 2024.03.19 17:48:54.335623 [ 3444530 ] <Fatal> BaseDaemon: 21. ? @ 0x00007ff580d97353\r\n[ip-172-31-26-174] 2024.03.19 17:48:57.125336 [ 3444530 ] <Fatal> BaseDaemon: Integrity check of the executable successfully passed (checksum: 501D917F05D565E1D31926ECB0CC920B)\r\n[ip-172-31-26-174] 2024.03.19 17:48:57.125741 [ 3444530 ] <Fatal> BaseDaemon: Report this error to https://github.com/ClickHouse/ClickHouse/issues\r\n[ip-172-31-26-174] 2024.03.19 17:48:57.126136 [ 3444530 ] <Fatal> BaseDaemon: Changed settings: use_uncompressed_cache = false, load_balancing = 'random', allow_suspicious_low_cardinality_types = true, max_memory_usage = 10000000000, async_insert_max_data_size = 5\r\nException on client:\r\nCode: 32. DB::Exception: Attempt to read after eof: while receiving packet from localhost:9000. (ATTEMPT_TO_READ_AFTER_EOF)\r\n```\r\n\r\n```\r\n :) ALTER TABLE t_update_empty_nested (ADD COLUMN `nested.arr2` Array((((((255, 1), '- ON NULL -', 3, ('- ON NULL -'), 11, 11, (11))), ((255, (1), 11, 1), 11)), (255, (1), 11, (1)), 11), UInt64))\r\n\r\nALTER TABLE t_update_empty_nested\r\n    (ADD COLUMN `nested.arr2` Array(((tuple(((255, 1), '- ON NULL -', 3, tuple('- ON NULL -'), 11, 11, tuple(11))), ((255, tuple(1), 11, 1), 11)), (255, tuple(1), 11, tuple(1)), 11), UInt64))\r\n```\r\n\r\n```\r\nALTER TABLE t ADD COLUMN x Array((1), UInt8)\r\n```\r\n\r\nhttps://s3.amazonaws.com/clickhouse-test-reports/0/ebaee8e5f62551b7c11d76ccdd7abac0bf4c23a0/ast_fuzzer__debug_.html\nFix column declaration formatting\n### Changelog category (leave one):\r\n- Not for changelog (changelog entry is not required)\r\n\r\n\r\n### Changelog entry (a user-readable short description of the changes that goes to CHANGELOG.md):\r\nCloses https://github.com/ClickHouse/ClickHouse/issues/61611.\nInconsistent formatting: `ALTER TABLE columns_with_multiple_streams MODIFY COLUMN field1 Nullable(tupleElement(x, 2), UInt8)`\nIf this query is formatted, it cannot be parsed back:\r\n\r\n```\r\nALTER TABLE columns_with_multiple_streams MODIFY COLUMN `field1` Nullable(tupleElement(x, 2), UInt8);\r\nALTER TABLE columns_with_multiple_streams (MODIFY COLUMN `field1` Nullable(x.2, UInt8));\r\n```\n",
  "hints_text": "\n`ALTER TABLE t ADD COLUMN x Array((1), UInt8)`\nhttps://s3.amazonaws.com/clickhouse-test-reports/0/c17b7954970f6672f49aa0ca2dd1e5a5b2fc9b7c/ast_fuzzer__debug_/fatal.log\nhttps://s3.amazonaws.com/clickhouse-test-reports/61908/99e25d762c2db3c544dd5590726fc039b1828d16/ast_fuzzer__debug_.html seems like the same issue:\r\n```\r\nALTER TABLE enum_alter_issue\r\n    (MODIFY COLUMN `a` Enum8(equals('one', timeSlots(timeSlots(arrayEnumerateDense(tuple('0.2147483646', toLowCardinality(toUInt128(12))), NULL), 4, 12.34, materialize(73), 2)), 1)))\r\n```\nhttps://s3.amazonaws.com/clickhouse-test-reports/64362/9794a193cfb88d7a49b12b9a60986884bf3ebfda/ast_fuzzer__debug_/fatal.log\r\n\r\n```\r\nALTER TABLE alter_compression_codec1 MODIFY COLUMN `alter_column` CODEC((2 + ignore(1, toUInt128(materialize(2)), 2 + toNullable(toNullable(3))), 3), NONE)\r\n```\n<!-- automatic status comment for PR #61711 from evillique/ClickHouse:fix-column-declaration-formatting -->\n*This is an automated comment for commit e6e24ef7a35b9bf6c5abe07f93e7012e516fcd9d with description of existing statuses. It's updated for the latest CI running*\n\n[\u274c Click here](https://s3.amazonaws.com/clickhouse-test-reports/61711/e6e24ef7a35b9bf6c5abe07f93e7012e516fcd9d/ci_running.html) to open a full report in a separate page\n\n<table>\n<thead><tr><th>Check name</th><th>Description</th><th>Status</th></tr></thead>\n<tbody>\n<tr><td>CI running</td><td>A meta-check that indicates the running CI. Normally, it's in <b>success</b> or <b>pending</b> state. The failed status indicates some problems with the PR</td><td><a href=\"https://s3.amazonaws.com/clickhouse-test-reports/61711/e6e24ef7a35b9bf6c5abe07f93e7012e516fcd9d/ci_running.html\">\u23f3 pending</a></td></tr>\n<tr><td>ClickHouse build check</td><td>Builds ClickHouse in various configurations for use in further steps. You have to fix the builds that fail. Build logs often has enough information to fix the error, but you might have to reproduce the failure locally. The <b>cmake</b> options can be found in the build log, grepping for <b>cmake</b>. Use these options and follow the <a href=\"https://clickhouse.com/docs/en/development/build\">general build process</a></td><td><a href=\"https://s3.amazonaws.com/clickhouse-test-reports/61711/e6e24ef7a35b9bf6c5abe07f93e7012e516fcd9d/clickhouse_build_check/report.html\">\u23f3 pending</a></td></tr>\n<tr><td>Fast test</td><td>Normally this is the first check that is ran for a PR. It builds ClickHouse and runs most of <a href=\"https://clickhouse.com/docs/en/development/tests#functional-tests\">stateless functional tests</a>, omitting some. If it fails, further checks are not started until it is fixed. Look at the report to see which tests fail, then reproduce the failure locally as described <a href=\"https://clickhouse.com/docs/en/development/tests#functional-test-locally\">here</a></td><td><a href=\"https://s3.amazonaws.com/clickhouse-test-reports/61711/e6e24ef7a35b9bf6c5abe07f93e7012e516fcd9d/fast_test.html\">\u274c failure</a></td></tr>\n<tr><td>Mergeable Check</td><td>Checks if all other necessary checks are successful</td><td><a href=\"https://github.com/ClickHouse/ClickHouse/actions/runs/8375853539\">\u274c failure</a></td></tr>\n<tbody>\n</table>\n<details><summary>Successful checks</summary>\n<table>\n<thead><tr><th>Check name</th><th>Description</th><th>Status</th></tr></thead>\n<tbody>\n<tr><td>A Sync</td><td>There's no description for the check yet, please add it to tests/ci/ci_config.py:CHECK_DESCRIPTIONS</td><td><a href=\"https://github.com/search?q=head%3Async-upstream%2Fpr%2F61711+org%3AClickHouse+type%3Apr\">\u2705 success</a></td></tr>\n<tr><td>Docs check</td><td>Builds and tests the documentation</td><td>\u2705 success</td></tr>\n<tr><td>PR Check</td><td>There's no description for the check yet, please add it to tests/ci/ci_config.py:CHECK_DESCRIPTIONS</td><td>\u2705 success</td></tr>\n<tr><td>Style check</td><td>Runs a set of checks to keep the code style clean. If some of tests failed, see the related log from the report</td><td><a href=\"https://s3.amazonaws.com/clickhouse-test-reports/61711/e6e24ef7a35b9bf6c5abe07f93e7012e516fcd9d/style_check.html\">\u2705 success</a></td></tr>\n<tbody>\n</table>\n</details>\n\nMaybe update the changelog entry so the fix can be easier to understand without opening the github issue.\nDear @antaljanosbenjamin, this PR hasn't been updated for a while. You will be unassigned. Will you continue working on it? If so, please feel free to reassign yourself.\n",
  "created_at": "2024-07-15T00:55:58Z"
}