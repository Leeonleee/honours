{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 19885,
  "instance_id": "ClickHouse__ClickHouse-19885",
  "issue_numbers": [
    "18567"
  ],
  "base_commit": "11f2a271a20664eab916af4dd08f13c7b765f04c",
  "patch": "diff --git a/src/Interpreters/ActionsDAG.cpp b/src/Interpreters/ActionsDAG.cpp\nindex 12942371d4f7..91862fbe8ba8 100644\n--- a/src/Interpreters/ActionsDAG.cpp\n+++ b/src/Interpreters/ActionsDAG.cpp\n@@ -679,7 +679,9 @@ ActionsDAGPtr ActionsDAG::makeConvertingActions(\n     const ColumnsWithTypeAndName & source,\n     const ColumnsWithTypeAndName & result,\n     MatchColumnsMode mode,\n-    bool ignore_constant_values)\n+    bool ignore_constant_values,\n+    bool add_casted_columns,\n+    NameToNameMap * new_names)\n {\n     size_t num_input_columns = source.size();\n     size_t num_result_columns = result.size();\n@@ -687,6 +689,9 @@ ActionsDAGPtr ActionsDAG::makeConvertingActions(\n     if (mode == MatchColumnsMode::Position && num_input_columns != num_result_columns)\n         throw Exception(\"Number of columns doesn't match\", ErrorCodes::NUMBER_OF_COLUMNS_DOESNT_MATCH);\n \n+    if (add_casted_columns && mode != MatchColumnsMode::Name)\n+        throw Exception(\"Converting with add_casted_columns supported only for MatchColumnsMode::Name\", ErrorCodes::LOGICAL_ERROR);\n+\n     auto actions_dag = std::make_shared<ActionsDAG>(source);\n     std::vector<Node *> projection(num_result_columns);\n \n@@ -706,12 +711,13 @@ ActionsDAGPtr ActionsDAG::makeConvertingActions(\n     {\n         const auto & res_elem = result[result_col_num];\n         Node * src_node = nullptr;\n+        Node * dst_node = nullptr;\n \n         switch (mode)\n         {\n             case MatchColumnsMode::Position:\n             {\n-                src_node = actions_dag->inputs[result_col_num];\n+                src_node = dst_node = actions_dag->inputs[result_col_num];\n                 break;\n             }\n \n@@ -722,7 +728,7 @@ ActionsDAGPtr ActionsDAG::makeConvertingActions(\n                     throw Exception(\"Cannot find column \" + backQuote(res_elem.name) + \" in source stream\",\n                                     ErrorCodes::THERE_IS_NO_COLUMN);\n \n-                src_node = actions_dag->inputs[input.front()];\n+                src_node = dst_node = actions_dag->inputs[input.front()];\n                 input.pop_front();\n                 break;\n             }\n@@ -731,10 +737,10 @@ ActionsDAGPtr ActionsDAG::makeConvertingActions(\n         /// Check constants.\n         if (const auto * res_const = typeid_cast<const ColumnConst *>(res_elem.column.get()))\n         {\n-            if (const auto * src_const = typeid_cast<const ColumnConst *>(src_node->column.get()))\n+            if (const auto * src_const = typeid_cast<const ColumnConst *>(dst_node->column.get()))\n             {\n                 if (ignore_constant_values)\n-                   src_node = const_cast<Node *>(&actions_dag->addColumn(res_elem, true));\n+                    dst_node = const_cast<Node *>(&actions_dag->addColumn(res_elem, true));\n                 else if (res_const->getField() != src_const->getField())\n                     throw Exception(\"Cannot convert column \" + backQuote(res_elem.name) + \" because \"\n                                     \"it is constant but values of constants are different in source and result\",\n@@ -747,7 +753,7 @@ ActionsDAGPtr ActionsDAG::makeConvertingActions(\n         }\n \n         /// Add CAST function to convert into result type if needed.\n-        if (!res_elem.type->equals(*src_node->result_type))\n+        if (!res_elem.type->equals(*dst_node->result_type))\n         {\n             ColumnWithTypeAndName column;\n             column.name = res_elem.type->getName();\n@@ -755,27 +761,49 @@ ActionsDAGPtr ActionsDAG::makeConvertingActions(\n             column.type = std::make_shared<DataTypeString>();\n \n             auto * right_arg = const_cast<Node *>(&actions_dag->addColumn(std::move(column), true));\n-            auto * left_arg = src_node;\n+            auto * left_arg = dst_node;\n \n-            FunctionCast::Diagnostic diagnostic = {src_node->result_name, res_elem.name};\n+            FunctionCast::Diagnostic diagnostic = {dst_node->result_name, res_elem.name};\n             FunctionOverloadResolverPtr func_builder_cast =\n                     std::make_shared<FunctionOverloadResolverAdaptor>(\n                             CastOverloadResolver<CastType::nonAccurate>::createImpl(false, std::move(diagnostic)));\n \n             Inputs children = { left_arg, right_arg };\n-            src_node = &actions_dag->addFunction(func_builder_cast, std::move(children), {}, true);\n+            dst_node = &actions_dag->addFunction(func_builder_cast, std::move(children), {}, true);\n         }\n \n-        if (src_node->column && isColumnConst(*src_node->column) && !(res_elem.column && isColumnConst(*res_elem.column)))\n+        if (dst_node->column && isColumnConst(*dst_node->column) && !(res_elem.column && isColumnConst(*res_elem.column)))\n         {\n-            Inputs children = {src_node};\n-            src_node = &actions_dag->addFunction(func_builder_materialize, std::move(children), {}, true);\n+            Inputs children = {dst_node};\n+            dst_node = &actions_dag->addFunction(func_builder_materialize, std::move(children), {}, true);\n         }\n \n-        if (src_node->result_name != res_elem.name)\n-            src_node = &actions_dag->addAlias(*src_node, res_elem.name, true);\n+        if (dst_node->result_name != res_elem.name)\n+        {\n+            if (add_casted_columns)\n+            {\n+                if (inputs.contains(dst_node->result_name))\n+                    throw Exception(\"Cannot convert column \" + backQuote(res_elem.name) +\n+                                    \" to \"+ backQuote(dst_node->result_name) +\n+                                    \" because other column have same name\",\n+                                    ErrorCodes::ILLEGAL_COLUMN);\n+                if (new_names)\n+                    new_names->emplace(res_elem.name, dst_node->result_name);\n \n-        projection[result_col_num] = src_node;\n+                /// Leave current column on same place, add converted to back\n+                projection[result_col_num] = src_node;\n+                projection.push_back(dst_node);\n+            }\n+            else\n+            {\n+                dst_node = &actions_dag->addAlias(*dst_node, res_elem.name, true);\n+                projection[result_col_num] = dst_node;\n+            }\n+        }\n+        else\n+        {\n+            projection[result_col_num] = dst_node;\n+        }\n     }\n \n     actions_dag->removeUnusedActions(projection);\ndiff --git a/src/Interpreters/ActionsDAG.h b/src/Interpreters/ActionsDAG.h\nindex 3c8778e239a0..48cc3449d39f 100644\n--- a/src/Interpreters/ActionsDAG.h\n+++ b/src/Interpreters/ActionsDAG.h\n@@ -248,11 +248,15 @@ class ActionsDAG\n     /// Create ActionsDAG which converts block structure from source to result.\n     /// It is needed to convert result from different sources to the same structure, e.g. for UNION query.\n     /// Conversion should be possible with only usage of CAST function and renames.\n+    /// @param ignore_constant_values - Do not check that constants are same. Use value from result_header.\n+    /// @param add_casted_columns - Create new columns with converted values instead of replacing original.\n     static ActionsDAGPtr makeConvertingActions(\n         const ColumnsWithTypeAndName & source,\n         const ColumnsWithTypeAndName & result,\n         MatchColumnsMode mode,\n-        bool ignore_constant_values = false); /// Do not check that constants are same. Use value from result_header.\n+        bool ignore_constant_values = false,\n+        bool add_casted_columns = false,\n+        NameToNameMap * new_names = nullptr);\n \n     /// Create expression which add const column and then materialize it.\n     static ActionsDAGPtr makeAddingColumnActions(ColumnWithTypeAndName column);\ndiff --git a/src/Interpreters/ActionsVisitor.cpp b/src/Interpreters/ActionsVisitor.cpp\nindex ca78c3708343..cf9f937736d7 100644\n--- a/src/Interpreters/ActionsVisitor.cpp\n+++ b/src/Interpreters/ActionsVisitor.cpp\n@@ -674,7 +674,7 @@ void ActionsMatcher::visit(const ASTIdentifier & identifier, const ASTPtr & ast,\n             if (column_name_type.name == column_name)\n             {\n                 throw Exception(\"Column \" + backQuote(column_name) + \" is not under aggregate function and not in GROUP BY\",\n-                ErrorCodes::NOT_AN_AGGREGATE);\n+                                ErrorCodes::NOT_AN_AGGREGATE);\n             }\n         }\n \ndiff --git a/src/Interpreters/ExpressionActions.cpp b/src/Interpreters/ExpressionActions.cpp\nindex b1fd23d43114..f06f8248fec2 100644\n--- a/src/Interpreters/ExpressionActions.cpp\n+++ b/src/Interpreters/ExpressionActions.cpp\n@@ -726,7 +726,7 @@ ExpressionActionsChain::JoinStep::JoinStep(\n     for (const auto & column : result_columns)\n         required_columns.emplace_back(column.name, column.type);\n \n-    analyzed_join->addJoinedColumnsAndCorrectNullability(result_columns);\n+    analyzed_join->addJoinedColumnsAndCorrectTypes(result_columns);\n }\n \n void ExpressionActionsChain::JoinStep::finalize(const Names & required_output_)\n@@ -747,8 +747,8 @@ void ExpressionActionsChain::JoinStep::finalize(const Names & required_output_)\n     }\n \n     /// Result will also contain joined columns.\n-    for (const auto & column : analyzed_join->columnsAddedByJoin())\n-        required_names.emplace(column.name);\n+    for (const auto & column_name : analyzed_join->columnsAddedByJoin())\n+        required_names.emplace(column_name);\n \n     for (const auto & column : result_columns)\n     {\ndiff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp\nindex 55dc622a976f..dd53717a189c 100644\n--- a/src/Interpreters/ExpressionAnalyzer.cpp\n+++ b/src/Interpreters/ExpressionAnalyzer.cpp\n@@ -42,14 +42,13 @@\n \n #include <DataTypes/DataTypeFactory.h>\n #include <Parsers/parseQuery.h>\n-#include <Interpreters/interpretSubquery.h>\n-#include <Interpreters/DatabaseAndTableWithAlias.h>\n-#include <Interpreters/misc.h>\n \n #include <Interpreters/ActionsVisitor.h>\n-\n-#include <Interpreters/GlobalSubqueriesVisitor.h>\n #include <Interpreters/GetAggregatesVisitor.h>\n+#include <Interpreters/GlobalSubqueriesVisitor.h>\n+#include <Interpreters/interpretSubquery.h>\n+#include <Interpreters/join_common.h>\n+#include <Interpreters/misc.h>\n \n #include <IO/Operators.h>\n #include <IO/WriteBufferFromString.h>\n@@ -208,13 +207,12 @@ void ExpressionAnalyzer::analyzeAggregation()\n         {\n             getRootActionsNoMakeSet(analyzedJoin().leftKeysList(), true, temp_actions, false);\n             auto sample_columns = temp_actions->getResultColumns();\n-            analyzedJoin().addJoinedColumnsAndCorrectNullability(sample_columns);\n+            analyzedJoin().addJoinedColumnsAndCorrectTypes(sample_columns);\n             temp_actions = std::make_shared<ActionsDAG>(sample_columns);\n         }\n \n         columns_after_join = columns_after_array_join;\n-        const auto & added_by_join = analyzedJoin().columnsAddedByJoin();\n-        columns_after_join.insert(columns_after_join.end(), added_by_join.begin(), added_by_join.end());\n+        analyzedJoin().addJoinedColumnsAndCorrectTypes(columns_after_join, false);\n     }\n \n     has_aggregation = makeAggregateDescriptions(temp_actions);\n@@ -724,13 +722,17 @@ bool SelectQueryExpressionAnalyzer::appendJoinLeftKeys(ExpressionActionsChain &\n \n JoinPtr SelectQueryExpressionAnalyzer::appendJoin(ExpressionActionsChain & chain)\n {\n-    JoinPtr table_join = makeTableJoin(*syntax->ast_join);\n-\n-    ExpressionActionsChain::Step & step = chain.lastStep(columns_after_array_join);\n+    const ColumnsWithTypeAndName & left_sample_columns = chain.getLastStep().getResultColumns();\n+    JoinPtr table_join = makeTableJoin(*syntax->ast_join, left_sample_columns);\n \n-    chain.steps.push_back(std::make_unique<ExpressionActionsChain::JoinStep>(\n-            syntax->analyzed_join, table_join, step.getResultColumns()));\n+    if (syntax->analyzed_join->needConvert())\n+    {\n+        chain.steps.push_back(std::make_unique<ExpressionActionsChain::ExpressionActionsStep>(syntax->analyzed_join->leftConvertingActions()));\n+        chain.addStep();\n+    }\n \n+    ExpressionActionsChain::Step & step = chain.lastStep(columns_after_array_join);\n+    chain.steps.push_back(std::make_unique<ExpressionActionsChain::JoinStep>(syntax->analyzed_join, table_join, step.getResultColumns()));\n     chain.addStep();\n     return table_join;\n }\n@@ -795,7 +797,8 @@ static std::shared_ptr<IJoin> makeJoin(std::shared_ptr<TableJoin> analyzed_join,\n     return std::make_shared<JoinSwitcher>(analyzed_join, sample_block);\n }\n \n-JoinPtr SelectQueryExpressionAnalyzer::makeTableJoin(const ASTTablesInSelectQueryElement & join_element)\n+JoinPtr SelectQueryExpressionAnalyzer::makeTableJoin(\n+    const ASTTablesInSelectQueryElement & join_element, const ColumnsWithTypeAndName & left_sample_columns)\n {\n     /// Two JOINs are not supported with the same subquery, but different USINGs.\n     auto join_hash = join_element.getTreeHash();\n@@ -831,7 +834,13 @@ JoinPtr SelectQueryExpressionAnalyzer::makeTableJoin(const ASTTablesInSelectQuer\n         }\n \n         /// TODO You do not need to set this up when JOIN is only needed on remote servers.\n-        subquery_for_join.setJoinActions(joined_block_actions); /// changes subquery_for_join.sample_block inside\n+        subquery_for_join.addJoinActions(joined_block_actions); /// changes subquery_for_join.sample_block inside\n+\n+        const ColumnsWithTypeAndName & right_sample_columns = subquery_for_join.sample_block.getColumnsWithTypeAndName();\n+        bool need_convert = syntax->analyzed_join->applyJoinKeyConvert(left_sample_columns, right_sample_columns);\n+        if (need_convert)\n+            subquery_for_join.addJoinActions(std::make_shared<ExpressionActions>(syntax->analyzed_join->rightConvertingActions()));\n+\n         subquery_for_join.join = makeJoin(syntax->analyzed_join, subquery_for_join.sample_block, context);\n \n         /// Do not make subquery for join over dictionary.\n@@ -1426,9 +1435,9 @@ ExpressionAnalysisResult::ExpressionAnalysisResult(\n         if (query_analyzer.hasTableJoin())\n         {\n             query_analyzer.appendJoinLeftKeys(chain, only_types || !first_stage);\n-\n             before_join = chain.getLastActions();\n             join = query_analyzer.appendJoin(chain);\n+            converting_join_columns = query_analyzer.analyzedJoin().leftConvertingActions();\n             chain.addStep();\n         }\n \ndiff --git a/src/Interpreters/ExpressionAnalyzer.h b/src/Interpreters/ExpressionAnalyzer.h\nindex 319be9c1409a..1a0f88f95ac5 100644\n--- a/src/Interpreters/ExpressionAnalyzer.h\n+++ b/src/Interpreters/ExpressionAnalyzer.h\n@@ -1,15 +1,16 @@\n #pragma once\n \n-#include <DataStreams/IBlockStream_fwd.h>\n #include <Columns/FilterDescription.h>\n+#include <DataStreams/IBlockStream_fwd.h>\n #include <Interpreters/AggregateDescription.h>\n-#include <Interpreters/WindowDescription.h>\n-#include <Interpreters/TreeRewriter.h>\n+#include <Interpreters/DatabaseCatalog.h>\n #include <Interpreters/SubqueryForSet.h>\n+#include <Interpreters/TreeRewriter.h>\n+#include <Interpreters/WindowDescription.h>\n+#include <Interpreters/join_common.h>\n #include <Parsers/IAST_fwd.h>\n #include <Storages/IStorage_fwd.h>\n #include <Storages/SelectQueryInfo.h>\n-#include <Interpreters/DatabaseCatalog.h>\n \n namespace DB\n {\n@@ -199,6 +200,7 @@ struct ExpressionAnalysisResult\n     ActionsDAGPtr before_array_join;\n     ArrayJoinActionPtr array_join;\n     ActionsDAGPtr before_join;\n+    ActionsDAGPtr converting_join_columns;\n     JoinPtr join;\n     ActionsDAGPtr before_where;\n     ActionsDAGPtr before_aggregation;\n@@ -313,7 +315,9 @@ class SelectQueryExpressionAnalyzer : public ExpressionAnalyzer\n     /// Create Set-s that we make from IN section to use index on them.\n     void makeSetsForIndex(const ASTPtr & node);\n \n-    JoinPtr makeTableJoin(const ASTTablesInSelectQueryElement & join_element);\n+    JoinPtr makeTableJoin(\n+        const ASTTablesInSelectQueryElement & join_element,\n+        const ColumnsWithTypeAndName & left_sample_columns);\n \n     const ASTSelectQuery * getAggregatingQuery() const;\n \ndiff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex da6ad7ab102d..5e3b878f795a 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -493,7 +493,10 @@ InterpreterSelectQuery::InterpreterSelectQuery(\n \n     if (need_analyze_again)\n     {\n-        subquery_for_sets = std::move(query_analyzer->getSubqueriesForSets());\n+        LOG_TRACE(log, \"Running 'analyze' second time\");\n+        query_analyzer->getSubqueriesForSets().clear();\n+        subquery_for_sets = SubqueriesForSets();\n+\n         /// Do not try move conditions to PREWHERE for the second time.\n         /// Otherwise, we won't be able to fallback from inefficient PREWHERE to WHERE later.\n         analyze(/* try_move_to_prewhere = */ false);\n@@ -1002,14 +1005,22 @@ void InterpreterSelectQuery::executeImpl(QueryPlan & query_plan, const BlockInpu\n                 query_plan.addStep(std::move(before_join_step));\n             }\n \n+            /// Optional step to convert key columns to common supertype.\n+            /// Columns with changed types will be returned to user,\n+            ///  so its only suitable for `USING` join.\n+            if (expressions.converting_join_columns)\n+            {\n+                QueryPlanStepPtr convert_join_step = std::make_unique<ExpressionStep>(\n+                    query_plan.getCurrentDataStream(),\n+                    expressions.converting_join_columns);\n+                convert_join_step->setStepDescription(\"Convert JOIN columns\");\n+                query_plan.addStep(std::move(convert_join_step));\n+            }\n+\n             if (expressions.hasJoin())\n             {\n-                Block join_result_sample;\n                 JoinPtr join = expressions.join;\n \n-                join_result_sample = JoiningTransform::transformHeader(\n-                    query_plan.getCurrentDataStream().header, expressions.join);\n-\n                 QueryPlanStepPtr join_step = std::make_unique<JoinStep>(\n                     query_plan.getCurrentDataStream(),\n                     expressions.join);\n@@ -1019,6 +1030,7 @@ void InterpreterSelectQuery::executeImpl(QueryPlan & query_plan, const BlockInpu\n \n                 if (expressions.join_has_delayed_stream)\n                 {\n+                    const Block & join_result_sample = query_plan.getCurrentDataStream().header;\n                     auto stream = std::make_shared<LazyNonJoinedBlockInputStream>(*join, join_result_sample, settings.max_block_size);\n                     auto source = std::make_shared<SourceFromInputStream>(std::move(stream));\n                     auto add_non_joined_rows_step = std::make_unique<AddingDelayedSourceStep>(\ndiff --git a/src/Interpreters/SubqueryForSet.cpp b/src/Interpreters/SubqueryForSet.cpp\nindex 6ca0ecc50c82..c81b7a710aef 100644\n--- a/src/Interpreters/SubqueryForSet.cpp\n+++ b/src/Interpreters/SubqueryForSet.cpp\n@@ -39,10 +39,20 @@ void SubqueryForSet::renameColumns(Block & block)\n     }\n }\n \n-void SubqueryForSet::setJoinActions(ExpressionActionsPtr actions)\n+void SubqueryForSet::addJoinActions(ExpressionActionsPtr actions)\n {\n     actions->execute(sample_block);\n-    joined_block_actions = actions;\n+    if (joined_block_actions == nullptr)\n+    {\n+        joined_block_actions = actions;\n+    }\n+    else\n+    {\n+        auto new_dag = ActionsDAG::merge(\n+            std::move(*joined_block_actions->getActionsDAG().clone()),\n+            std::move(*actions->getActionsDAG().clone()));\n+        joined_block_actions = std::make_shared<ExpressionActions>(new_dag);\n+    }\n }\n \n bool SubqueryForSet::insertJoinedBlock(Block & block)\ndiff --git a/src/Interpreters/SubqueryForSet.h b/src/Interpreters/SubqueryForSet.h\nindex fd073500dc2d..a42bf296d6c4 100644\n--- a/src/Interpreters/SubqueryForSet.h\n+++ b/src/Interpreters/SubqueryForSet.h\n@@ -40,7 +40,7 @@ struct SubqueryForSet\n     void makeSource(std::shared_ptr<InterpreterSelectWithUnionQuery> & interpreter,\n                     NamesWithAliases && joined_block_aliases_);\n \n-    void setJoinActions(ExpressionActionsPtr actions);\n+    void addJoinActions(ExpressionActionsPtr actions);\n \n     bool insertJoinedBlock(Block & block);\n     void setTotals(Block totals);\ndiff --git a/src/Interpreters/TableJoin.cpp b/src/Interpreters/TableJoin.cpp\nindex c1777711d9ec..c50c61c418c4 100644\n--- a/src/Interpreters/TableJoin.cpp\n+++ b/src/Interpreters/TableJoin.cpp\n@@ -1,5 +1,7 @@\n #include <Interpreters/TableJoin.h>\n \n+#include <common/logger_useful.h>\n+\n #include <Parsers/ASTExpressionList.h>\n \n #include <Core/Settings.h>\n@@ -15,6 +17,11 @@\n namespace DB\n {\n \n+namespace ErrorCodes\n+{\n+    extern const int TYPE_MISMATCH;\n+}\n+\n TableJoin::TableJoin(const Settings & settings, VolumePtr tmp_volume_)\n     : size_limits(SizeLimits{settings.max_rows_in_join, settings.max_bytes_in_join, settings.join_overflow_mode})\n     , default_max_bytes(settings.default_max_bytes_in_join)\n@@ -40,6 +47,10 @@ void TableJoin::resetCollected()\n     columns_added_by_join.clear();\n     original_names.clear();\n     renames.clear();\n+    left_type_map.clear();\n+    right_type_map.clear();\n+    left_converting_actions = nullptr;\n+    right_converting_actions = nullptr;\n }\n \n void TableJoin::addUsingKey(const ASTPtr & ast)\n@@ -105,14 +116,6 @@ void TableJoin::deduplicateAndQualifyColumnNames(const NameSet & left_table_colu\n     columns_from_joined_table.swap(dedup_columns);\n }\n \n-NameSet TableJoin::getQualifiedColumnsSet() const\n-{\n-    NameSet out;\n-    for (const auto & names : original_names)\n-        out.insert(names.first);\n-    return out;\n-}\n-\n NamesWithAliases TableJoin::getNamesWithAliases(const NameSet & required_columns) const\n {\n     NamesWithAliases out;\n@@ -221,49 +224,54 @@ bool TableJoin::rightBecomeNullable(const DataTypePtr & column_type) const\n \n void TableJoin::addJoinedColumn(const NameAndTypePair & joined_column)\n {\n-    if (rightBecomeNullable(joined_column.type))\n-        columns_added_by_join.emplace_back(NameAndTypePair(joined_column.name, makeNullable(joined_column.type)));\n-    else\n-        columns_added_by_join.push_back(joined_column);\n+    DataTypePtr type = joined_column.type;\n+\n+    if (hasUsing())\n+    {\n+        if (auto it = right_type_map.find(joined_column.name); it != right_type_map.end())\n+            type = it->second;\n+    }\n+\n+    if (rightBecomeNullable(type))\n+        type = makeNullable(type);\n+\n+    columns_added_by_join.emplace_back(joined_column.name, type);\n+}\n+\n+void TableJoin::addJoinedColumnsAndCorrectTypes(NamesAndTypesList & names_and_types, bool correct_nullability) const\n+{\n+    ColumnsWithTypeAndName columns;\n+    for (auto & pair : names_and_types)\n+        columns.emplace_back(nullptr, std::move(pair.type), std::move(pair.name));\n+    names_and_types.clear();\n+\n+    addJoinedColumnsAndCorrectTypes(columns, correct_nullability);\n+\n+    for (auto & col : columns)\n+        names_and_types.emplace_back(std::move(col.name), std::move(col.type));\n }\n \n-void TableJoin::addJoinedColumnsAndCorrectNullability(ColumnsWithTypeAndName & columns) const\n+void TableJoin::addJoinedColumnsAndCorrectTypes(ColumnsWithTypeAndName & columns, bool correct_nullability) const\n {\n     for (auto & col : columns)\n     {\n-        if (leftBecomeNullable(col.type))\n+        if (hasUsing())\n+        {\n+            if (auto it = left_type_map.find(col.name); it != left_type_map.end())\n+                col.type = it->second;\n+        }\n+        if (correct_nullability && leftBecomeNullable(col.type))\n         {\n             /// No need to nullify constants\n-            if (!(col.column && isColumnConst(*col.column)))\n-            {\n+            bool is_column_const = col.column && isColumnConst(*col.column);\n+            if (!is_column_const)\n                 col.type = makeNullable(col.type);\n-            }\n         }\n     }\n \n+    /// Types in columns_added_by_join already converted and set nullable if needed\n     for (const auto & col : columns_added_by_join)\n-    {\n-        auto res_type = col.type;\n-\n-        if (rightBecomeNullable(res_type))\n-            res_type = makeNullable(res_type);\n-\n-        columns.emplace_back(nullptr, res_type, col.name);\n-    }\n-}\n-\n-bool TableJoin::sameJoin(const TableJoin * x, const TableJoin * y)\n-{\n-    if (!x && !y)\n-        return true;\n-    if (!x || !y)\n-        return false;\n-\n-    return x->table_join.kind == y->table_join.kind\n-        && x->table_join.strictness == y->table_join.strictness\n-        && x->key_names_left == y->key_names_left\n-        && x->key_names_right == y->key_names_right\n-        && x->columns_added_by_join == y->columns_added_by_join;\n+        columns.emplace_back(nullptr, col.type, col.name);\n }\n \n bool TableJoin::sameStrictnessAndKind(ASTTableJoin::Strictness strictness_, ASTTableJoin::Kind kind_) const\n@@ -336,4 +344,124 @@ bool TableJoin::allowDictJoin(const String & dict_key, const Block & sample_bloc\n     return true;\n }\n \n+bool TableJoin::applyJoinKeyConvert(const ColumnsWithTypeAndName & left_sample_columns, const ColumnsWithTypeAndName & right_sample_columns)\n+{\n+    bool need_convert = needConvert();\n+    if (!need_convert && !hasUsing())\n+    {\n+        /// For `USING` we already inferred common type an syntax analyzer stage\n+        NamesAndTypesList left_list;\n+        NamesAndTypesList right_list;\n+        for (const auto & col : left_sample_columns)\n+            left_list.emplace_back(col.name, col.type);\n+        for (const auto & col : right_sample_columns)\n+            right_list.emplace_back(col.name, col.type);\n+\n+        need_convert = inferJoinKeyCommonType(left_list, right_list);\n+    }\n+\n+    if (need_convert)\n+    {\n+        left_converting_actions = applyKeyConvertToTable(left_sample_columns, left_type_map, key_names_left);\n+        right_converting_actions = applyKeyConvertToTable(right_sample_columns, right_type_map, key_names_right);\n+    }\n+\n+    return need_convert;\n+}\n+\n+bool TableJoin::inferJoinKeyCommonType(const NamesAndTypesList & left, const NamesAndTypesList & right)\n+{\n+    std::unordered_map<String, DataTypePtr> left_types;\n+    for (const auto & col : left)\n+    {\n+        left_types[col.name] = col.type;\n+    }\n+\n+    std::unordered_map<String, DataTypePtr> right_types;\n+    for (const auto & col : right)\n+    {\n+        if (auto it = renames.find(col.name); it != renames.end())\n+            right_types[it->second] = col.type;\n+        else\n+            right_types[col.name] = col.type;\n+    }\n+\n+    for (size_t i = 0; i < key_names_left.size(); ++i)\n+    {\n+        auto ltype = left_types.find(key_names_left[i]);\n+        auto rtype = right_types.find(key_names_right[i]);\n+        if (ltype == left_types.end() || rtype == right_types.end())\n+        {\n+            /// Name mismatch, give up\n+            left_type_map.clear();\n+            right_type_map.clear();\n+            return false;\n+        }\n+\n+        if (JoinCommon::typesEqualUpToNullability(ltype->second, rtype->second))\n+            continue;\n+\n+        DataTypePtr supertype;\n+        try\n+        {\n+            supertype = DB::getLeastSupertype({ltype->second, rtype->second});\n+        }\n+        catch (DB::Exception & ex)\n+        {\n+            throw Exception(\n+                \"Type mismatch of columns to JOIN by: \" +\n+                    key_names_left[i] + \": \" + ltype->second->getName() + \" at left, \" +\n+                    key_names_right[i] + \": \" + rtype->second->getName() + \" at right. \" +\n+                    \"Can't get supertype: \" + ex.message(),\n+                ErrorCodes::TYPE_MISMATCH);\n+        }\n+        left_type_map[key_names_left[i]] = right_type_map[key_names_right[i]] = supertype;\n+    }\n+\n+    if (!left_type_map.empty() || !right_type_map.empty())\n+    {\n+        auto format_type_map = [](NameToTypeMap mapping) -> std::string\n+        {\n+            std::vector<std::string> text;\n+            for (const auto & [k, v] : mapping)\n+                text.push_back(k + \": \" + v->getName());\n+            return fmt::format(\"{}\", fmt::join(text, \", \"));\n+        };\n+        LOG_TRACE(\n+            &Poco::Logger::get(\"TableJoin\"),\n+            \"Infer supertype for joined columns. Left: [{}], Right: [{}]\",\n+            format_type_map(left_type_map),\n+            format_type_map(right_type_map));\n+    }\n+\n+    return !left_type_map.empty();\n+}\n+\n+ActionsDAGPtr TableJoin::applyKeyConvertToTable(\n+    const ColumnsWithTypeAndName & cols_src, const NameToTypeMap & type_mapping, Names & names_to_rename) const\n+{\n+    ColumnsWithTypeAndName cols_dst = cols_src;\n+    for (auto & col : cols_dst)\n+    {\n+        if (auto it = type_mapping.find(col.name); it != type_mapping.end())\n+        {\n+            col.type = it->second;\n+            col.column = nullptr;\n+        }\n+    }\n+\n+    NameToNameMap key_column_rename;\n+    /// Returns converting actions for tables that need to be performed before join\n+    auto dag = ActionsDAG::makeConvertingActions(\n+        cols_src, cols_dst, ActionsDAG::MatchColumnsMode::Name, true, !hasUsing(), &key_column_rename);\n+\n+    for (auto & name : names_to_rename)\n+    {\n+        const auto it = key_column_rename.find(name);\n+        if (it != key_column_rename.end())\n+            name = it->second;\n+    }\n+    return dag;\n+}\n+\n }\ndiff --git a/src/Interpreters/TableJoin.h b/src/Interpreters/TableJoin.h\nindex 9dcbc30f07b7..71a27849297d 100644\n--- a/src/Interpreters/TableJoin.h\n+++ b/src/Interpreters/TableJoin.h\n@@ -5,9 +5,11 @@\n #include <Core/SettingsEnums.h>\n #include <Parsers/ASTTablesInSelectQuery.h>\n #include <Interpreters/IJoin.h>\n+#include <Interpreters/join_common.h>\n #include <Interpreters/asof.h>\n #include <DataStreams/IBlockStream_fwd.h>\n #include <DataStreams/SizeLimits.h>\n+#include <DataTypes/getLeastSupertype.h>\n #include <Storages/IStorage_fwd.h>\n \n #include <utility>\n@@ -32,6 +34,11 @@ using VolumePtr = std::shared_ptr<IVolume>;\n \n class TableJoin\n {\n+\n+public:\n+    using NameToTypeMap = std::unordered_map<String, DataTypePtr>;\n+\n+private:\n     /** Query of the form `SELECT expr(x) AS k FROM t1 ANY LEFT JOIN (SELECT expr(x) AS k FROM t2) USING k`\n       * The join is made by column k.\n       * During the JOIN,\n@@ -59,23 +66,39 @@ class TableJoin\n \n     Names key_names_left;\n     Names key_names_right; /// Duplicating names are qualified.\n+\n     ASTs key_asts_left;\n     ASTs key_asts_right;\n     ASTTableJoin table_join;\n+\n     ASOF::Inequality asof_inequality = ASOF::Inequality::GreaterOrEquals;\n \n     /// All columns which can be read from joined table. Duplicating names are qualified.\n     NamesAndTypesList columns_from_joined_table;\n-    /// Columns will be added to block by JOIN. It's a subset of columns_from_joined_table with corrected Nullability\n+    /// Columns will be added to block by JOIN.\n+    /// It's a subset of columns_from_joined_table with corrected Nullability and type (if inplace type conversion is required)\n     NamesAndTypesList columns_added_by_join;\n \n+    /// Target type to convert key columns before join\n+    NameToTypeMap left_type_map;\n+    NameToTypeMap right_type_map;\n+\n+    ActionsDAGPtr left_converting_actions;\n+    ActionsDAGPtr right_converting_actions;\n+\n     /// Name -> original name. Names are the same as in columns_from_joined_table list.\n     std::unordered_map<String, String> original_names;\n-    /// Original name -> name. Only ranamed columns.\n+    /// Original name -> name. Only renamed columns.\n     std::unordered_map<String, String> renames;\n \n     VolumePtr tmp_volume;\n \n+    Names requiredJoinedNames() const;\n+\n+    /// Create converting actions and change key column names if required\n+    ActionsDAGPtr applyKeyConvertToTable(\n+        const ColumnsWithTypeAndName & cols_src, const NameToTypeMap & type_mapping, Names & names_to_rename) const;\n+\n public:\n     TableJoin() = default;\n     TableJoin(const Settings &, VolumePtr tmp_volume);\n@@ -125,7 +148,6 @@ class TableJoin\n     bool hasUsing() const { return table_join.using_expression_list != nullptr; }\n     bool hasOn() const { return table_join.on_expression != nullptr; }\n \n-    NameSet getQualifiedColumnsSet() const;\n     NamesWithAliases getNamesWithAliases(const NameSet & required_columns) const;\n     NamesWithAliases getRequiredColumns(const Block & sample, const Names & action_required_columns) const;\n \n@@ -136,7 +158,23 @@ class TableJoin\n     bool leftBecomeNullable(const DataTypePtr & column_type) const;\n     bool rightBecomeNullable(const DataTypePtr & column_type) const;\n     void addJoinedColumn(const NameAndTypePair & joined_column);\n-    void addJoinedColumnsAndCorrectNullability(ColumnsWithTypeAndName & columns) const;\n+\n+    void addJoinedColumnsAndCorrectTypes(NamesAndTypesList & names_and_types, bool correct_nullability = true) const;\n+    void addJoinedColumnsAndCorrectTypes(ColumnsWithTypeAndName & columns, bool correct_nullability = true) const;\n+\n+    /// Calculates common supertypes for corresponding join key columns.\n+    bool inferJoinKeyCommonType(const NamesAndTypesList & left, const NamesAndTypesList & right);\n+\n+    /// Calculate converting actions, rename key columns in required\n+    /// For `USING` join we will convert key columns inplace and affect into types in the result table\n+    /// For `JOIN ON` we will create new columns with converted keys to join by.\n+    bool applyJoinKeyConvert(const ColumnsWithTypeAndName & left_sample_columns, const ColumnsWithTypeAndName & right_sample_columns);\n+\n+    bool needConvert() const { return !left_type_map.empty(); }\n+\n+    /// Key columns should be converted before join.\n+    ActionsDAGPtr leftConvertingActions() const { return left_converting_actions; }\n+    ActionsDAGPtr rightConvertingActions() const { return right_converting_actions; }\n \n     void setAsofInequality(ASOF::Inequality inequality) { asof_inequality = inequality; }\n     ASOF::Inequality getAsofInequality() { return asof_inequality; }\n@@ -144,11 +182,16 @@ class TableJoin\n     ASTPtr leftKeysList() const;\n     ASTPtr rightKeysList() const; /// For ON syntax only\n \n-    Names requiredJoinedNames() const;\n     const Names & keyNamesLeft() const { return key_names_left; }\n     const Names & keyNamesRight() const { return key_names_right; }\n     const NamesAndTypesList & columnsFromJoinedTable() const { return columns_from_joined_table; }\n-    const NamesAndTypesList & columnsAddedByJoin() const { return columns_added_by_join; }\n+    Names columnsAddedByJoin() const\n+    {\n+        Names res;\n+        for (const auto & col : columns_added_by_join)\n+            res.push_back(col.name);\n+        return res;\n+    }\n \n     /// StorageJoin overrides key names (cause of different names qualification)\n     void setRightKeys(const Names & keys) { key_names_right = keys; }\n@@ -156,8 +199,6 @@ class TableJoin\n     /// Split key and other columns by keys name list\n     void splitAdditionalColumns(const Block & sample_block, Block & block_keys, Block & block_others) const;\n     Block getRequiredRightKeys(const Block & right_table_keys, std::vector<String> & keys_sources) const;\n-\n-    static bool sameJoin(const TableJoin * x, const TableJoin * y);\n };\n \n }\ndiff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp\nindex bcfdf6869c3b..9318f87175ad 100644\n--- a/src/Interpreters/TreeRewriter.cpp\n+++ b/src/Interpreters/TreeRewriter.cpp\n@@ -418,6 +418,13 @@ void collectJoinedColumns(TableJoin & analyzed_join, const ASTSelectQuery & sele\n         const auto & keys = table_join.using_expression_list->as<ASTExpressionList &>();\n         for (const auto & key : keys.children)\n             analyzed_join.addUsingKey(key);\n+\n+        /// `USING` semantic allows to have columns with changed types in result table.\n+        /// `JOIN ON` should preserve types from original table\n+        /// We can infer common type on syntax stage for `USING` because join is performed only by columns (not expressions)\n+        /// We need to know  changed types in result tables because some analysis (e.g. analyzeAggregation) performed before join\n+        /// For `JOIN ON expr1 == expr2` we will infer common type later in ExpressionAnalyzer, when types of expression will be known\n+        analyzed_join.inferJoinKeyCommonType(tables[0].columns, tables[1].columns);\n     }\n     else if (table_join.on_expression)\n     {\n@@ -571,7 +578,6 @@ void TreeRewriterResult::collectUsedColumns(const ASTPtr & query, bool is_select\n         source_column_names.insert(column.name);\n \n     NameSet required = columns_context.requiredColumns();\n-\n     if (columns_context.has_table_join)\n     {\n         NameSet available_columns;\ndiff --git a/src/Interpreters/join_common.cpp b/src/Interpreters/join_common.cpp\nindex 69727a2a6bb5..4c124f99e571 100644\n--- a/src/Interpreters/join_common.cpp\n+++ b/src/Interpreters/join_common.cpp\n@@ -1,9 +1,11 @@\n #include <Interpreters/join_common.h>\n #include <Interpreters/TableJoin.h>\n+#include <Interpreters/ActionsDAG.h>\n #include <Columns/ColumnNullable.h>\n #include <Columns/ColumnLowCardinality.h>\n #include <DataTypes/DataTypeNullable.h>\n #include <DataTypes/DataTypeLowCardinality.h>\n+#include <DataTypes/getLeastSupertype.h>\n #include <DataStreams/materializeBlock.h>\n #include <IO/WriteHelpers.h>\n \n@@ -293,6 +295,13 @@ void addDefaultValues(IColumn & column, const DataTypePtr & type, size_t count)\n         type->insertDefaultInto(column);\n }\n \n+bool typesEqualUpToNullability(DataTypePtr left_type, DataTypePtr right_type)\n+{\n+    DataTypePtr left_type_strict = removeNullable(recursiveRemoveLowCardinality(left_type));\n+    DataTypePtr right_type_strict = removeNullable(recursiveRemoveLowCardinality(right_type));\n+    return left_type_strict->equals(*right_type_strict);\n+}\n+\n }\n \n \n@@ -307,19 +316,21 @@ NotJoined::NotJoined(const TableJoin & table_join, const Block & saved_block_sam\n     table_join.splitAdditionalColumns(right_sample_block, right_table_keys, sample_block_with_columns_to_add);\n     Block required_right_keys = table_join.getRequiredRightKeys(right_table_keys, tmp);\n \n-    bool remap_keys = table_join.hasUsing();\n     std::unordered_map<size_t, size_t> left_to_right_key_remap;\n \n-    for (size_t i = 0; i < table_join.keyNamesLeft().size(); ++i)\n+    if (table_join.hasUsing())\n     {\n-        const String & left_key_name = table_join.keyNamesLeft()[i];\n-        const String & right_key_name = table_join.keyNamesRight()[i];\n+        for (size_t i = 0; i < table_join.keyNamesLeft().size(); ++i)\n+        {\n+            const String & left_key_name = table_join.keyNamesLeft()[i];\n+            const String & right_key_name = table_join.keyNamesRight()[i];\n \n-        size_t left_key_pos = result_sample_block.getPositionByName(left_key_name);\n-        size_t right_key_pos = saved_block_sample.getPositionByName(right_key_name);\n+            size_t left_key_pos = result_sample_block.getPositionByName(left_key_name);\n+            size_t right_key_pos = saved_block_sample.getPositionByName(right_key_name);\n \n-        if (remap_keys && !required_right_keys.has(right_key_name))\n-            left_to_right_key_remap[left_key_pos] = right_key_pos;\n+            if (!required_right_keys.has(right_key_name))\n+                left_to_right_key_remap[left_key_pos] = right_key_pos;\n+        }\n     }\n \n     /// result_sample_block: left_sample_block + left expressions, right not key columns, required right keys\ndiff --git a/src/Interpreters/join_common.h b/src/Interpreters/join_common.h\nindex 76fbcf8d87d5..cec414384484 100644\n--- a/src/Interpreters/join_common.h\n+++ b/src/Interpreters/join_common.h\n@@ -2,6 +2,8 @@\n \n #include <Core/Block.h>\n #include <Interpreters/IJoin.h>\n+#include <Interpreters/ActionsDAG.h>\n+#include <Interpreters/ExpressionActions.h>\n \n namespace DB\n {\n@@ -36,6 +38,8 @@ void joinTotals(const Block & totals, const Block & columns_to_add, const TableJ\n \n void addDefaultValues(IColumn & column, const DataTypePtr & type, size_t count);\n \n+bool typesEqualUpToNullability(DataTypePtr left_type, DataTypePtr right_type);\n+\n }\n \n /// Creates result from right table data in RIGHT and FULL JOIN when keys are not present in left table.\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01710_join_use_nulls.reference b/tests/queries/0_stateless/01710_join_use_nulls.reference\nindex 8bd111e04162..069117803a7f 100644\n--- a/tests/queries/0_stateless/01710_join_use_nulls.reference\n+++ b/tests/queries/0_stateless/01710_join_use_nulls.reference\n@@ -1,3 +1,4 @@\n 3\n+3\n 1\n 1\ndiff --git a/tests/queries/0_stateless/01710_join_use_nulls.sql b/tests/queries/0_stateless/01710_join_use_nulls.sql\nindex b024227d4e25..980ac48dd133 100644\n--- a/tests/queries/0_stateless/01710_join_use_nulls.sql\n+++ b/tests/queries/0_stateless/01710_join_use_nulls.sql\n@@ -4,15 +4,15 @@ DROP TABLE IF EXISTS Y;\n CREATE TABLE X (id Int) ENGINE=Memory;\n CREATE TABLE Y (id Int) ENGINE=Memory;\n \n--- Type mismatch of columns to JOIN by: plus(id, 1) Int64 at left, Y.id Int32 at right.\n-SELECT Y.id - 1 FROM X RIGHT JOIN Y ON (X.id + 1) = Y.id SETTINGS join_use_nulls=1; -- { serverError 53 }\n+SELECT Y.id - 1 FROM X RIGHT JOIN Y ON (X.id + 1) = Y.id SETTINGS join_use_nulls=1;\n SELECT Y.id - 1 FROM X RIGHT JOIN Y ON (X.id + 1) = toInt64(Y.id) SETTINGS join_use_nulls=1;\n \n--- Logical error: 'Arguments of 'plus' have incorrect data types: '2' of type 'UInt8', '1' of type 'UInt8''.\n+-- Fix issue #20366 \n+-- Arguments of 'plus' have incorrect data types: '2' of type 'UInt8', '1' of type 'UInt8'.\n -- Because 1 became toNullable(1), i.e.:\n --     2 UInt8 Const(size = 1, UInt8(size = 1))\n --     1 UInt8 Const(size = 1, Nullable(size = 1, UInt8(size = 1), UInt8(size = 1)))\n-SELECT 2+1 FROM system.one X RIGHT JOIN system.one Y ON X.dummy+1 = Y.dummy SETTINGS join_use_nulls = 1; -- { serverError 53 }\n+SELECT 2+1 FROM system.one X RIGHT JOIN system.one Y ON X.dummy+1 = Y.dummy SETTINGS join_use_nulls = 1;\n SELECT 2+1 FROM system.one X RIGHT JOIN system.one Y ON X.dummy+1 = toUInt16(Y.dummy) SETTINGS join_use_nulls = 1;\n SELECT X.dummy+1 FROM system.one X RIGHT JOIN system.one Y ON X.dummy = Y.dummy SETTINGS join_use_nulls = 1;\n SELECT Y.dummy+1 FROM system.one X RIGHT JOIN system.one Y ON X.dummy = Y.dummy SETTINGS join_use_nulls = 1;\ndiff --git a/tests/queries/0_stateless/01720_join_implicit_cast.reference b/tests/queries/0_stateless/01720_join_implicit_cast.reference\nnew file mode 100644\nindex 000000000000..3cca6a264fae\n--- /dev/null\n+++ b/tests/queries/0_stateless/01720_join_implicit_cast.reference\n@@ -0,0 +1,102 @@\n+=== hash ===\n+= full =\n+1\t1\n+2\t2\n+-1\t1\n+1\t\\N\n+1\t257\n+1\t-1\n+= left =\n+1\t1\n+2\t2\n+= right =\n+1\t1\n+-1\t1\n+1\t\\N\n+1\t257\n+1\t-1\n+= inner =\n+1\t1\n+= full =\n+1\t1\t1\t1\n+2\t2\t0\t\\N\n+0\t0\t-1\t1\n+0\t0\t1\t\\N\n+0\t0\t1\t257\n+0\t0\t1\t-1\n+= left =\n+1\t1\t1\t1\n+2\t2\t0\t\\N\n+= right =\n+1\t1\t1\t1\n+0\t0\t-1\t1\n+0\t0\t1\t\\N\n+0\t0\t1\t257\n+0\t0\t1\t-1\n+= inner =\n+1\t1\t1\t1\n+= agg =\n+5\t260\n+3\t3\n+3\t258\n+1\t1\n+5\t260\n+3\t3\n+3\t258\n+1\t1\n+= types =\n+1\n+1\n+1\n+1\n+=== partial_merge ===\n+= full =\n+1\t1\n+2\t2\n+-1\t1\n+1\t\\N\n+1\t257\n+1\t-1\n+= left =\n+1\t1\n+2\t2\n+= right =\n+1\t1\n+-1\t1\n+1\t\\N\n+1\t257\n+1\t-1\n+= inner =\n+1\t1\n+= full =\n+1\t1\t1\t1\n+2\t2\t0\t\\N\n+0\t0\t-1\t1\n+0\t0\t1\t\\N\n+0\t0\t1\t257\n+0\t0\t1\t-1\n+= left =\n+1\t1\t1\t1\n+2\t2\t0\t\\N\n+= right =\n+1\t1\t1\t1\n+0\t0\t-1\t1\n+0\t0\t1\t\\N\n+0\t0\t1\t257\n+0\t0\t1\t-1\n+= inner =\n+1\t1\t1\t1\n+= agg =\n+5\t260\n+3\t3\n+3\t258\n+1\t1\n+5\t260\n+3\t3\n+3\t258\n+1\t1\n+= types =\n+1\n+1\n+1\n+1\ndiff --git a/tests/queries/0_stateless/01720_join_implicit_cast.sql b/tests/queries/0_stateless/01720_join_implicit_cast.sql\nnew file mode 100644\nindex 000000000000..cf4a3bdcef68\n--- /dev/null\n+++ b/tests/queries/0_stateless/01720_join_implicit_cast.sql\n@@ -0,0 +1,96 @@\n+DROP TABLE IF EXISTS t_ab1;\n+DROP TABLE IF EXISTS t_ab2;\n+\n+CREATE TABLE t_ab1 (id Nullable(Int32), a UInt16, b UInt8) ENGINE = TinyLog;\n+CREATE TABLE t_ab2 (id Nullable(Int32), a Int16, b Nullable(Int64)) ENGINE = TinyLog;\n+INSERT INTO t_ab1 VALUES (0, 1, 1), (1, 2, 2);\n+INSERT INTO t_ab2 VALUES (2, -1, 1), (3, 1, NULL), (4, 1, 257), (5, 1, -1), (6, 1, 1);\n+\n+SELECT '=== hash ===';\n+\n+SET join_algorithm = 'hash';\n+\n+SELECT '= full =';\n+SELECT a, b FROM t_ab1 FULL JOIN t_ab2 USING (a, b) ORDER BY ifNull(t_ab1.id, t_ab2.id);\n+SELECT '= left =';\n+SELECT a, b FROM t_ab1 LEFT JOIN t_ab2 USING (a, b) ORDER BY ifNull(t_ab1.id, t_ab2.id);\n+SELECT '= right =';\n+SELECT a, b FROM t_ab1 RIGHT JOIN t_ab2 USING (a, b) ORDER BY ifNull(t_ab1.id, t_ab2.id);\n+SELECT '= inner =';\n+SELECT a, b FROM t_ab1 INNER JOIN t_ab2 USING (a, b) ORDER BY ifNull(t_ab1.id, t_ab2.id);\n+\n+SELECT '= full =';\n+SELECT a, b, t_ab2.a, t_ab2.b FROM t_ab1 FULL JOIN t_ab2 ON (t_ab1.a == t_ab2.a AND t_ab1.b == t_ab2.b) ORDER BY ifNull(t_ab1.id, t_ab2.id);\n+SELECT '= left =';\n+SELECT a, b, t_ab2.a, t_ab2.b FROM t_ab1 LEFT JOIN t_ab2 ON (t_ab1.a == t_ab2.a AND t_ab1.b == t_ab2.b) ORDER BY ifNull(t_ab1.id, t_ab2.id);\n+SELECT '= right =';\n+SELECT a, b, t_ab2.a, t_ab2.b FROM t_ab1 RIGHT JOIN t_ab2 ON (t_ab1.a == t_ab2.a AND t_ab1.b == t_ab2.b) ORDER BY ifNull(t_ab1.id, t_ab2.id);\n+SELECT '= inner =';\n+SELECT a, b, t_ab2.a, t_ab2.b FROM t_ab1 INNER JOIN t_ab2 ON (t_ab1.a == t_ab2.a AND t_ab1.b == t_ab2.b) ORDER BY ifNull(t_ab1.id, t_ab2.id);\n+\n+SELECT '= agg =';\n+SELECT sum(a), sum(b) FROM t_ab1 FULL JOIN t_ab2 USING (a, b);\n+SELECT sum(a), sum(b) FROM t_ab1 LEFT JOIN t_ab2 USING (a, b);\n+SELECT sum(a), sum(b) FROM t_ab1 RIGHT JOIN t_ab2 USING (a, b);\n+SELECT sum(a), sum(b) FROM t_ab1 INNER JOIN t_ab2 USING (a, b);\n+\n+SELECT sum(a) + sum(t_ab2.a) - 1, sum(b) + sum(t_ab2.b) - 1 FROM t_ab1 FULL JOIN t_ab2 ON (t_ab1.a == t_ab2.a AND t_ab1.b == t_ab2.b);\n+SELECT sum(a) + sum(t_ab2.a) - 1, sum(b) + sum(t_ab2.b) - 1 FROM t_ab1 LEFT JOIN t_ab2 ON (t_ab1.a == t_ab2.a AND t_ab1.b == t_ab2.b);\n+SELECT sum(a) + sum(t_ab2.a) - 1, sum(b) + sum(t_ab2.b) - 1 FROM t_ab1 RIGHT JOIN t_ab2 ON (t_ab1.a == t_ab2.a AND t_ab1.b == t_ab2.b);\n+SELECT sum(a) + sum(t_ab2.a) - 1, sum(b) + sum(t_ab2.b) - 1 FROM t_ab1 INNER JOIN t_ab2 ON (t_ab1.a == t_ab2.a AND t_ab1.b == t_ab2.b);\n+\n+SELECT '= types =';\n+\n+SELECT any(toTypeName(a)) == 'Int32' AND any(toTypeName(b)) == 'Nullable(Int64)' FROM t_ab1 FULL JOIN t_ab2 USING (a, b);\n+SELECT any(toTypeName(a)) == 'Int32' AND any(toTypeName(b)) == 'Nullable(Int64)' FROM t_ab1 LEFT JOIN t_ab2 USING (a, b);\n+SELECT any(toTypeName(a)) == 'Int32' AND any(toTypeName(b)) == 'Nullable(Int64)' FROM t_ab1 RIGHT JOIN t_ab2 USING (a, b);\n+SELECT any(toTypeName(a)) == 'Int32' AND any(toTypeName(b)) == 'Nullable(Int64)' FROM t_ab1 INNER JOIN t_ab2 USING (a, b);\n+\n+SELECT * FROM ( SELECT a, b as \"CAST(a, Int32)\" FROM t_ab1 ) t_ab1 FULL JOIN t_ab2 ON (t_ab1.a == t_ab2.a); -- { serverError 44 }\n+SELECT * FROM ( SELECT a, b as \"CAST(a, Int32)\" FROM t_ab1 ) t_ab1 FULL JOIN t_ab2 USING (a) FORMAT Null;\n+\n+SELECT '=== partial_merge ===';\n+\n+SET join_algorithm = 'partial_merge';\n+\n+SELECT '= full =';\n+SELECT a, b FROM t_ab1 FULL JOIN t_ab2 USING (a, b) ORDER BY ifNull(t_ab1.id, t_ab2.id);\n+SELECT '= left =';\n+SELECT a, b FROM t_ab1 LEFT JOIN t_ab2 USING (a, b) ORDER BY ifNull(t_ab1.id, t_ab2.id);\n+SELECT '= right =';\n+SELECT a, b FROM t_ab1 RIGHT JOIN t_ab2 USING (a, b) ORDER BY ifNull(t_ab1.id, t_ab2.id);\n+SELECT '= inner =';\n+SELECT a, b FROM t_ab1 INNER JOIN t_ab2 USING (a, b) ORDER BY ifNull(t_ab1.id, t_ab2.id);\n+\n+SELECT '= full =';\n+SELECT a, b, t_ab2.a, t_ab2.b FROM t_ab1 FULL JOIN t_ab2 ON (t_ab1.a == t_ab2.a AND t_ab1.b == t_ab2.b) ORDER BY ifNull(t_ab1.id, t_ab2.id);\n+SELECT '= left =';\n+SELECT a, b, t_ab2.a, t_ab2.b FROM t_ab1 LEFT JOIN t_ab2 ON (t_ab1.a == t_ab2.a AND t_ab1.b == t_ab2.b) ORDER BY ifNull(t_ab1.id, t_ab2.id);\n+SELECT '= right =';\n+SELECT a, b, t_ab2.a, t_ab2.b FROM t_ab1 RIGHT JOIN t_ab2 ON (t_ab1.a == t_ab2.a AND t_ab1.b == t_ab2.b) ORDER BY ifNull(t_ab1.id, t_ab2.id);\n+SELECT '= inner =';\n+SELECT a, b, t_ab2.a, t_ab2.b FROM t_ab1 INNER JOIN t_ab2 ON (t_ab1.a == t_ab2.a AND t_ab1.b == t_ab2.b) ORDER BY ifNull(t_ab1.id, t_ab2.id);\n+\n+SELECT '= agg =';\n+SELECT sum(a), sum(b) FROM t_ab1 FULL JOIN t_ab2 USING (a, b);\n+SELECT sum(a), sum(b) FROM t_ab1 LEFT JOIN t_ab2 USING (a, b);\n+SELECT sum(a), sum(b) FROM t_ab1 RIGHT JOIN t_ab2 USING (a, b);\n+SELECT sum(a), sum(b) FROM t_ab1 INNER JOIN t_ab2 USING (a, b);\n+\n+SELECT sum(a) + sum(t_ab2.a) - 1, sum(b) + sum(t_ab2.b) - 1 FROM t_ab1 FULL JOIN t_ab2 ON (t_ab1.a == t_ab2.a AND t_ab1.b == t_ab2.b);\n+SELECT sum(a) + sum(t_ab2.a) - 1, sum(b) + sum(t_ab2.b) - 1 FROM t_ab1 LEFT JOIN t_ab2 ON (t_ab1.a == t_ab2.a AND t_ab1.b == t_ab2.b);\n+SELECT sum(a) + sum(t_ab2.a) - 1, sum(b) + sum(t_ab2.b) - 1 FROM t_ab1 RIGHT JOIN t_ab2 ON (t_ab1.a == t_ab2.a AND t_ab1.b == t_ab2.b);\n+SELECT sum(a) + sum(t_ab2.a) - 1, sum(b) + sum(t_ab2.b) - 1 FROM t_ab1 INNER JOIN t_ab2 ON (t_ab1.a == t_ab2.a AND t_ab1.b == t_ab2.b);\n+\n+SELECT '= types =';\n+\n+SELECT any(toTypeName(a)) == 'Int32' AND any(toTypeName(b)) == 'Nullable(Int64)' FROM t_ab1 FULL JOIN t_ab2 USING (a, b);\n+SELECT any(toTypeName(a)) == 'Int32' AND any(toTypeName(b)) == 'Nullable(Int64)' FROM t_ab1 LEFT JOIN t_ab2 USING (a, b);\n+SELECT any(toTypeName(a)) == 'Int32' AND any(toTypeName(b)) == 'Nullable(Int64)' FROM t_ab1 RIGHT JOIN t_ab2 USING (a, b);\n+SELECT any(toTypeName(a)) == 'Int32' AND any(toTypeName(b)) == 'Nullable(Int64)' FROM t_ab1 INNER JOIN t_ab2 USING (a, b);\n+\n+SELECT * FROM ( SELECT a, b as \"CAST(a, Int32)\" FROM t_ab1 ) t_ab1 FULL JOIN t_ab2 ON (t_ab1.a == t_ab2.a); -- { serverError 44 }\n+SELECT * FROM ( SELECT a, b as \"CAST(a, Int32)\" FROM t_ab1 ) t_ab1 FULL JOIN t_ab2 USING (a) FORMAT Null;\n+\n+DROP TABLE IF EXISTS t_ab1;\n+DROP TABLE IF EXISTS t_ab2;\ndiff --git a/tests/queries/0_stateless/01721_join_implicit_cast_long.reference b/tests/queries/0_stateless/01721_join_implicit_cast_long.reference\nnew file mode 100644\nindex 000000000000..d78307175f96\n--- /dev/null\n+++ b/tests/queries/0_stateless/01721_join_implicit_cast_long.reference\n@@ -0,0 +1,804 @@\n+=== hash ===\n+= full =\n+-4\t0\t196\n+-3\t0\t197\n+-2\t0\t198\n+-1\t0\t199\n+0\t0\t200\n+1\t101\t201\n+2\t102\t202\n+3\t103\t203\n+4\t104\t204\n+5\t105\t205\n+6\t106\t\\N\n+7\t107\t\\N\n+8\t108\t\\N\n+9\t109\t\\N\n+10\t110\t\\N\n+= left =\n+1\t101\t201\n+2\t102\t202\n+3\t103\t203\n+4\t104\t204\n+5\t105\t205\n+6\t106\t\\N\n+7\t107\t\\N\n+8\t108\t\\N\n+9\t109\t\\N\n+10\t110\t\\N\n+= right =\n+-4\t0\t196\n+-3\t0\t197\n+-2\t0\t198\n+-1\t0\t199\n+0\t0\t200\n+1\t101\t201\n+2\t102\t202\n+3\t103\t203\n+4\t104\t204\n+5\t105\t205\n+= inner =\n+1\t101\t201\n+2\t102\t202\n+3\t103\t203\n+4\t104\t204\n+5\t105\t205\n+= full =\n+0\t0\t-4\n+0\t0\t-3\n+0\t0\t-2\n+0\t0\t-1\n+0\t0\t0\n+1\t1\t1\n+2\t2\t2\n+3\t3\t3\n+4\t4\t4\n+5\t5\t5\n+6\t6\t0\n+7\t7\t0\n+8\t8\t0\n+9\t9\t0\n+10\t10\t0\n+= left =\n+1\t1\t1\n+2\t2\t2\n+3\t3\t3\n+4\t4\t4\n+5\t5\t5\n+6\t6\t0\n+7\t7\t0\n+8\t8\t0\n+9\t9\t0\n+10\t10\t0\n+= right =\n+0\t0\t-4\n+0\t0\t-3\n+0\t0\t-2\n+0\t0\t-1\n+0\t0\t0\n+1\t1\t1\n+2\t2\t2\n+3\t3\t3\n+4\t4\t4\n+5\t5\t5\n+= inner =\n+1\t1\t1\n+2\t2\t2\n+3\t3\t3\n+4\t4\t4\n+5\t5\t5\n+= join on =\n+= full =\n+0\t0\t-4\t196\n+0\t0\t-3\t197\n+0\t0\t-2\t198\n+0\t0\t-1\t199\n+0\t0\t0\t200\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+6\t106\t0\t\\N\n+7\t107\t0\t\\N\n+8\t108\t0\t\\N\n+9\t109\t0\t\\N\n+10\t110\t0\t\\N\n+= left =\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+6\t106\t0\t\\N\n+7\t107\t0\t\\N\n+8\t108\t0\t\\N\n+9\t109\t0\t\\N\n+10\t110\t0\t\\N\n+= right =\n+0\t0\t-4\t196\n+0\t0\t-3\t197\n+0\t0\t-2\t198\n+0\t0\t-1\t199\n+0\t0\t0\t200\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+= inner =\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+= full =\n+0\t0\t-4\t196\n+0\t0\t-3\t197\n+0\t0\t-2\t198\n+0\t0\t-1\t199\n+0\t0\t0\t200\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+6\t106\t0\t\\N\n+7\t107\t0\t\\N\n+8\t108\t0\t\\N\n+9\t109\t0\t\\N\n+10\t110\t0\t\\N\n+= left =\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+6\t106\t0\t\\N\n+7\t107\t0\t\\N\n+8\t108\t0\t\\N\n+9\t109\t0\t\\N\n+10\t110\t0\t\\N\n+= right =\n+0\t0\t-4\t196\n+0\t0\t-3\t197\n+0\t0\t-2\t198\n+0\t0\t-1\t199\n+0\t0\t0\t200\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+= inner =\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+= agg =\n+1\n+1\n+1\n+1\n+1\n+1\n+0\t-10\t0\n+1\t55\t1055\n+0\t0\t-10\t0\t990\n+1\t55\t15\t1055\t1015\n+= types =\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+=== partial_merge ===\n+= full =\n+-4\t0\t196\n+-3\t0\t197\n+-2\t0\t198\n+-1\t0\t199\n+0\t0\t200\n+1\t101\t201\n+2\t102\t202\n+3\t103\t203\n+4\t104\t204\n+5\t105\t205\n+6\t106\t\\N\n+7\t107\t\\N\n+8\t108\t\\N\n+9\t109\t\\N\n+10\t110\t\\N\n+= left =\n+1\t101\t201\n+2\t102\t202\n+3\t103\t203\n+4\t104\t204\n+5\t105\t205\n+6\t106\t\\N\n+7\t107\t\\N\n+8\t108\t\\N\n+9\t109\t\\N\n+10\t110\t\\N\n+= right =\n+-4\t0\t196\n+-3\t0\t197\n+-2\t0\t198\n+-1\t0\t199\n+0\t0\t200\n+1\t101\t201\n+2\t102\t202\n+3\t103\t203\n+4\t104\t204\n+5\t105\t205\n+= inner =\n+1\t101\t201\n+2\t102\t202\n+3\t103\t203\n+4\t104\t204\n+5\t105\t205\n+= full =\n+0\t0\t-4\n+0\t0\t-3\n+0\t0\t-2\n+0\t0\t-1\n+0\t0\t0\n+1\t1\t1\n+2\t2\t2\n+3\t3\t3\n+4\t4\t4\n+5\t5\t5\n+6\t6\t0\n+7\t7\t0\n+8\t8\t0\n+9\t9\t0\n+10\t10\t0\n+= left =\n+1\t1\t1\n+2\t2\t2\n+3\t3\t3\n+4\t4\t4\n+5\t5\t5\n+6\t6\t0\n+7\t7\t0\n+8\t8\t0\n+9\t9\t0\n+10\t10\t0\n+= right =\n+0\t0\t-4\n+0\t0\t-3\n+0\t0\t-2\n+0\t0\t-1\n+0\t0\t0\n+1\t1\t1\n+2\t2\t2\n+3\t3\t3\n+4\t4\t4\n+5\t5\t5\n+= inner =\n+1\t1\t1\n+2\t2\t2\n+3\t3\t3\n+4\t4\t4\n+5\t5\t5\n+= join on =\n+= full =\n+0\t0\t-4\t196\n+0\t0\t-3\t197\n+0\t0\t-2\t198\n+0\t0\t-1\t199\n+0\t0\t0\t200\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+6\t106\t0\t\\N\n+7\t107\t0\t\\N\n+8\t108\t0\t\\N\n+9\t109\t0\t\\N\n+10\t110\t0\t\\N\n+= left =\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+6\t106\t0\t\\N\n+7\t107\t0\t\\N\n+8\t108\t0\t\\N\n+9\t109\t0\t\\N\n+10\t110\t0\t\\N\n+= right =\n+0\t0\t-4\t196\n+0\t0\t-3\t197\n+0\t0\t-2\t198\n+0\t0\t-1\t199\n+0\t0\t0\t200\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+= inner =\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+= full =\n+0\t0\t-4\t196\n+0\t0\t-3\t197\n+0\t0\t-2\t198\n+0\t0\t-1\t199\n+0\t0\t0\t200\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+6\t106\t0\t\\N\n+7\t107\t0\t\\N\n+8\t108\t0\t\\N\n+9\t109\t0\t\\N\n+10\t110\t0\t\\N\n+= left =\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+6\t106\t0\t\\N\n+7\t107\t0\t\\N\n+8\t108\t0\t\\N\n+9\t109\t0\t\\N\n+10\t110\t0\t\\N\n+= right =\n+0\t0\t-4\t196\n+0\t0\t-3\t197\n+0\t0\t-2\t198\n+0\t0\t-1\t199\n+0\t0\t0\t200\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+= inner =\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+= agg =\n+1\n+1\n+1\n+1\n+1\n+1\n+0\t-10\t0\n+1\t55\t1055\n+0\t0\t-10\t0\t990\n+1\t55\t15\t1055\t1015\n+= types =\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+=== switch ===\n+= full =\n+-4\t0\t196\n+-3\t0\t197\n+-2\t0\t198\n+-1\t0\t199\n+0\t0\t200\n+1\t101\t201\n+2\t102\t202\n+3\t103\t203\n+4\t104\t204\n+5\t105\t205\n+6\t106\t\\N\n+7\t107\t\\N\n+8\t108\t\\N\n+9\t109\t\\N\n+10\t110\t\\N\n+= left =\n+1\t101\t201\n+2\t102\t202\n+3\t103\t203\n+4\t104\t204\n+5\t105\t205\n+6\t106\t\\N\n+7\t107\t\\N\n+8\t108\t\\N\n+9\t109\t\\N\n+10\t110\t\\N\n+= right =\n+-4\t0\t196\n+-3\t0\t197\n+-2\t0\t198\n+-1\t0\t199\n+0\t0\t200\n+1\t101\t201\n+2\t102\t202\n+3\t103\t203\n+4\t104\t204\n+5\t105\t205\n+= inner =\n+1\t101\t201\n+2\t102\t202\n+3\t103\t203\n+4\t104\t204\n+5\t105\t205\n+= full =\n+0\t0\t-4\n+0\t0\t-3\n+0\t0\t-2\n+0\t0\t-1\n+0\t0\t0\n+1\t1\t1\n+2\t2\t2\n+3\t3\t3\n+4\t4\t4\n+5\t5\t5\n+6\t6\t0\n+7\t7\t0\n+8\t8\t0\n+9\t9\t0\n+10\t10\t0\n+= left =\n+1\t1\t1\n+2\t2\t2\n+3\t3\t3\n+4\t4\t4\n+5\t5\t5\n+6\t6\t0\n+7\t7\t0\n+8\t8\t0\n+9\t9\t0\n+10\t10\t0\n+= right =\n+0\t0\t-4\n+0\t0\t-3\n+0\t0\t-2\n+0\t0\t-1\n+0\t0\t0\n+1\t1\t1\n+2\t2\t2\n+3\t3\t3\n+4\t4\t4\n+5\t5\t5\n+= inner =\n+1\t1\t1\n+2\t2\t2\n+3\t3\t3\n+4\t4\t4\n+5\t5\t5\n+= join on =\n+= full =\n+0\t0\t-4\t196\n+0\t0\t-3\t197\n+0\t0\t-2\t198\n+0\t0\t-1\t199\n+0\t0\t0\t200\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+6\t106\t0\t\\N\n+7\t107\t0\t\\N\n+8\t108\t0\t\\N\n+9\t109\t0\t\\N\n+10\t110\t0\t\\N\n+= left =\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+6\t106\t0\t\\N\n+7\t107\t0\t\\N\n+8\t108\t0\t\\N\n+9\t109\t0\t\\N\n+10\t110\t0\t\\N\n+= right =\n+0\t0\t-4\t196\n+0\t0\t-3\t197\n+0\t0\t-2\t198\n+0\t0\t-1\t199\n+0\t0\t0\t200\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+= inner =\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+= full =\n+0\t0\t-4\t196\n+0\t0\t-3\t197\n+0\t0\t-2\t198\n+0\t0\t-1\t199\n+0\t0\t0\t200\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+6\t106\t0\t\\N\n+7\t107\t0\t\\N\n+8\t108\t0\t\\N\n+9\t109\t0\t\\N\n+10\t110\t0\t\\N\n+= left =\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+6\t106\t0\t\\N\n+7\t107\t0\t\\N\n+8\t108\t0\t\\N\n+9\t109\t0\t\\N\n+10\t110\t0\t\\N\n+= right =\n+0\t0\t-4\t196\n+0\t0\t-3\t197\n+0\t0\t-2\t198\n+0\t0\t-1\t199\n+0\t0\t0\t200\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+= inner =\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+= agg =\n+1\n+1\n+1\n+1\n+1\n+1\n+0\t-10\t0\n+1\t55\t1055\n+0\t0\t-10\t0\t990\n+1\t55\t15\t1055\t1015\n+= types =\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+=== join use nulls ===\n+= full =\n+-4\t\\N\t196\n+-3\t\\N\t197\n+-2\t\\N\t198\n+-1\t\\N\t199\n+0\t\\N\t200\n+1\t101\t201\n+2\t102\t202\n+3\t103\t203\n+4\t104\t204\n+5\t105\t205\n+6\t106\t\\N\n+7\t107\t\\N\n+8\t108\t\\N\n+9\t109\t\\N\n+10\t110\t\\N\n+= left =\n+1\t101\t201\n+2\t102\t202\n+3\t103\t203\n+4\t104\t204\n+5\t105\t205\n+6\t106\t\\N\n+7\t107\t\\N\n+8\t108\t\\N\n+9\t109\t\\N\n+10\t110\t\\N\n+= right =\n+-4\t\\N\t196\n+-3\t\\N\t197\n+-2\t\\N\t198\n+-1\t\\N\t199\n+0\t\\N\t200\n+1\t101\t201\n+2\t102\t202\n+3\t103\t203\n+4\t104\t204\n+5\t105\t205\n+= inner =\n+1\t101\t201\n+2\t102\t202\n+3\t103\t203\n+4\t104\t204\n+5\t105\t205\n+= full =\n+1\t1\t1\n+2\t2\t2\n+3\t3\t3\n+4\t4\t4\n+5\t5\t5\n+6\t6\t\\N\n+7\t7\t\\N\n+8\t8\t\\N\n+9\t9\t\\N\n+10\t10\t\\N\n+\\N\t\\N\t-4\n+\\N\t\\N\t-3\n+\\N\t\\N\t-2\n+\\N\t\\N\t-1\n+\\N\t\\N\t0\n+= left =\n+1\t1\t1\n+2\t2\t2\n+3\t3\t3\n+4\t4\t4\n+5\t5\t5\n+6\t6\t\\N\n+7\t7\t\\N\n+8\t8\t\\N\n+9\t9\t\\N\n+10\t10\t\\N\n+= right =\n+1\t1\t1\n+2\t2\t2\n+3\t3\t3\n+4\t4\t4\n+5\t5\t5\n+\\N\t\\N\t-4\n+\\N\t\\N\t-3\n+\\N\t\\N\t-2\n+\\N\t\\N\t-1\n+\\N\t\\N\t0\n+= inner =\n+1\t1\t1\n+2\t2\t2\n+3\t3\t3\n+4\t4\t4\n+5\t5\t5\n+= join on =\n+= full =\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+6\t106\t\\N\t\\N\n+7\t107\t\\N\t\\N\n+8\t108\t\\N\t\\N\n+9\t109\t\\N\t\\N\n+10\t110\t\\N\t\\N\n+\\N\t\\N\t-4\t196\n+\\N\t\\N\t-3\t197\n+\\N\t\\N\t-2\t198\n+\\N\t\\N\t-1\t199\n+\\N\t\\N\t0\t200\n+= left =\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+6\t106\t\\N\t\\N\n+7\t107\t\\N\t\\N\n+8\t108\t\\N\t\\N\n+9\t109\t\\N\t\\N\n+10\t110\t\\N\t\\N\n+= right =\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+\\N\t\\N\t-4\t196\n+\\N\t\\N\t-3\t197\n+\\N\t\\N\t-2\t198\n+\\N\t\\N\t-1\t199\n+\\N\t\\N\t0\t200\n+= inner =\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+= full =\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+6\t106\t\\N\t\\N\n+7\t107\t\\N\t\\N\n+8\t108\t\\N\t\\N\n+9\t109\t\\N\t\\N\n+10\t110\t\\N\t\\N\n+\\N\t\\N\t-4\t196\n+\\N\t\\N\t-3\t197\n+\\N\t\\N\t-2\t198\n+\\N\t\\N\t-1\t199\n+\\N\t\\N\t0\t200\n+= left =\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+6\t106\t\\N\t\\N\n+7\t107\t\\N\t\\N\n+8\t108\t\\N\t\\N\n+9\t109\t\\N\t\\N\n+10\t110\t\\N\t\\N\n+= right =\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+\\N\t\\N\t-4\t196\n+\\N\t\\N\t-3\t197\n+\\N\t\\N\t-2\t198\n+\\N\t\\N\t-1\t199\n+\\N\t\\N\t0\t200\n+= inner =\n+1\t101\t1\t201\n+2\t102\t2\t202\n+3\t103\t3\t203\n+4\t104\t4\t204\n+5\t105\t5\t205\n+= agg =\n+1\n+1\n+1\n+1\n+1\n+1\n+0\t-10\t\\N\n+1\t55\t1055\n+1\t55\t15\t1055\t1015\n+\\N\t\\N\t-10\t\\N\t990\n+= types =\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\ndiff --git a/tests/queries/0_stateless/01721_join_implicit_cast_long.sql b/tests/queries/0_stateless/01721_join_implicit_cast_long.sql\nnew file mode 100644\nindex 000000000000..a6b411fadde2\n--- /dev/null\n+++ b/tests/queries/0_stateless/01721_join_implicit_cast_long.sql\n@@ -0,0 +1,316 @@\n+DROP TABLE IF EXISTS t1;\n+DROP TABLE IF EXISTS t2;\n+\n+CREATE TABLE t1 (a UInt16, b UInt16) ENGINE = TinyLog;\n+CREATE TABLE t2 (a Int16, b Nullable(Int64)) ENGINE = TinyLog;\n+\n+INSERT INTO t1 SELECT number as a, 100 + number as b FROM system.numbers LIMIT 1, 10;\n+INSERT INTO t2 SELECT number - 5 as a, 200 + number - 5 as b FROM system.numbers LIMIT 1, 10;\n+\n+SELECT '=== hash ===';\n+SET join_algorithm = 'hash';\n+\n+SELECT '= full =';\n+SELECT a, b, t2.b FROM t1 FULL JOIN t2 USING (a) ORDER BY (a);\n+SELECT '= left =';\n+SELECT a, b, t2.b FROM t1 LEFT JOIN t2 USING (a) ORDER BY (a);\n+SELECT '= right =';\n+SELECT a, b, t2.b FROM t1 RIGHT JOIN t2 USING (a) ORDER BY (a);\n+SELECT '= inner =';\n+SELECT a, b, t2.b FROM t1 INNER JOIN t2 USING (a) ORDER BY (a);\n+\n+SELECT '= full =';\n+SELECT a, t1.a, t2.a FROM t1 FULL JOIN t2 USING (a) ORDER BY (t1.a, t2.a);\n+SELECT '= left =';\n+SELECT a, t1.a, t2.a FROM t1 LEFT JOIN t2 USING (a) ORDER BY (t1.a, t2.a);\n+SELECT '= right =';\n+SELECT a, t1.a, t2.a FROM t1 RIGHT JOIN t2 USING (a) ORDER BY (t1.a, t2.a);\n+SELECT '= inner =';\n+SELECT a, t1.a, t2.a FROM t1 INNER JOIN t2 USING (a) ORDER BY (t1.a, t2.a);\n+\n+SELECT '= join on =';\n+SELECT '= full =';\n+SELECT a, b, t2.a, t2.b FROM t1 FULL JOIN t2 ON (t1.a == t2.a) ORDER BY (t1.a, t2.a);\n+SELECT '= left =';\n+SELECT a, b, t2.a, t2.b FROM t1 LEFT JOIN t2 ON (t1.a == t2.a) ORDER BY (t1.a, t2.a);\n+SELECT '= right =';\n+SELECT a, b, t2.a, t2.b FROM t1 RIGHT JOIN t2 ON (t1.a == t2.a) ORDER BY (t1.a, t2.a);\n+SELECT '= inner =';\n+SELECT a, b, t2.a, t2.b FROM t1 INNER JOIN t2 ON (t1.a == t2.a) ORDER BY (t1.a, t2.a);\n+\n+SELECT '= full =';\n+SELECT * FROM t1 FULL JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) ORDER BY (t1.a, t2.a);\n+SELECT '= left =';\n+SELECT * FROM t1 LEFT JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) ORDER BY (t1.a, t2.a);\n+SELECT '= right =';\n+SELECT * FROM t1 RIGHT JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) ORDER BY (t1.a, t2.a);\n+SELECT '= inner =';\n+SELECT * FROM t1 INNER JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) ORDER BY (t1.a, t2.a);\n+\n+-- Int64 and UInt64 has no supertype\n+SELECT * FROM t1 FULL JOIN t2 ON (t1.a + t1.b + 100 = t2.a + t2.b) ORDER BY (t1.a, t2.a); -- { serverError 53 }\n+SELECT * FROM t1 LEFT JOIN t2 ON (t1.a + t1.b + 100 = t2.a + t2.b) ORDER BY (t1.a, t2.a); -- { serverError 53 }\n+SELECT * FROM t1 RIGHT JOIN t2 ON (t1.a + t1.b + 100 = t2.a + t2.b) ORDER BY (t1.a, t2.a); -- { serverError 53 }\n+SELECT * FROM t1 INNER JOIN t2 ON (t1.a + t1.b + 100 = t2.a + t2.b) ORDER BY (t1.a, t2.a); -- { serverError 53 }\n+\n+SELECT '= agg =';\n+SELECT sum(a) == 7 FROM t1 FULL JOIN t2 USING (a) WHERE b > 102 AND t2.b <= 204;\n+SELECT sum(a) == 7 FROM t1 INNER JOIN t2 USING (a) WHERE b > 102 AND t2.b <= 204;\n+\n+SELECT sum(b) = 103 FROM t1 LEFT JOIN t2 USING (a) WHERE b > 102 AND t2.b < 204;\n+SELECT sum(t2.b) = 203 FROM t1 RIGHT JOIN t2 USING (a) WHERE b > 102 AND t2.b < 204;\n+\n+SELECT sum(a) == 2 + 3 + 4 FROM t1 FULL JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) WHERE t1.b < 105 AND t2.b > 201;\n+SELECT sum(a) == 55 FROM t1 FULL JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) WHERE 1;\n+\n+SELECT a > 0, sum(a), sum(b) FROM t1 FULL JOIN t2 USING (a) GROUP BY (a > 0) ORDER BY a > 0;\n+SELECT a > 0, sum(a), sum(t2.a), sum(b), sum(t2.b) FROM t1 FULL JOIN t2 ON (t1.a == t2.a) GROUP BY (a > 0) ORDER BY a > 0;\n+\n+SELECT '= types =';\n+SELECT any(toTypeName(a)) == 'Int32' AND any(toTypeName(t2.a)) == 'Int32' FROM t1 FULL JOIN t2 USING (a);\n+SELECT any(toTypeName(a)) == 'Int32' AND any(toTypeName(t2.a)) == 'Int32' FROM t1 LEFT JOIN t2 USING (a);\n+SELECT any(toTypeName(a)) == 'Int32' AND any(toTypeName(t2.a)) == 'Int32' FROM t1 RIGHT JOIN t2 USING (a);\n+SELECT any(toTypeName(a)) == 'Int32' AND any(toTypeName(t2.a)) == 'Int32' FROM t1 INNER JOIN t2 USING (a);\n+\n+SELECT toTypeName(any(a)) == 'Int32' AND toTypeName(any(t2.a)) == 'Int32' FROM t1 FULL JOIN t2 USING (a);\n+SELECT min(toTypeName(a) == 'Int32' AND toTypeName(t2.a) == 'Int32') FROM t1 FULL JOIN t2 USING (a);\n+\n+SELECT any(toTypeName(a)) == 'UInt16' AND any(toTypeName(t2.a)) == 'Int16' FROM t1 FULL JOIN t2 ON (t1.a == t2.a);\n+SELECT any(toTypeName(a)) == 'UInt16' AND any(toTypeName(t2.a)) == 'Int16' FROM t1 LEFT JOIN t2 ON (t1.a == t2.a);\n+SELECT any(toTypeName(a)) == 'UInt16' AND any(toTypeName(t2.a)) == 'Int16' FROM t1 RIGHT JOIN t2 ON (t1.a == t2.a);\n+SELECT any(toTypeName(a)) == 'UInt16' AND any(toTypeName(t2.a)) == 'Int16' FROM t1 INNER JOIN t2 ON (t1.a == t2.a);\n+SELECT toTypeName(any(a)) == 'UInt16' AND toTypeName(any(t2.a)) == 'Int16' FROM t1 FULL JOIN t2 ON (t1.a == t2.a);\n+\n+SELECT '=== partial_merge ===';\n+\n+SET join_algorithm = 'partial_merge';\n+\n+SELECT '= full =';\n+SELECT a, b, t2.b FROM t1 FULL JOIN t2 USING (a) ORDER BY (a);\n+SELECT '= left =';\n+SELECT a, b, t2.b FROM t1 LEFT JOIN t2 USING (a) ORDER BY (a);\n+SELECT '= right =';\n+SELECT a, b, t2.b FROM t1 RIGHT JOIN t2 USING (a) ORDER BY (a);\n+SELECT '= inner =';\n+SELECT a, b, t2.b FROM t1 INNER JOIN t2 USING (a) ORDER BY (a);\n+\n+SELECT '= full =';\n+SELECT a, t1.a, t2.a FROM t1 FULL JOIN t2 USING (a) ORDER BY (t1.a, t2.a);\n+SELECT '= left =';\n+SELECT a, t1.a, t2.a FROM t1 LEFT JOIN t2 USING (a) ORDER BY (t1.a, t2.a);\n+SELECT '= right =';\n+SELECT a, t1.a, t2.a FROM t1 RIGHT JOIN t2 USING (a) ORDER BY (t1.a, t2.a);\n+SELECT '= inner =';\n+SELECT a, t1.a, t2.a FROM t1 INNER JOIN t2 USING (a) ORDER BY (t1.a, t2.a);\n+\n+SELECT '= join on =';\n+SELECT '= full =';\n+SELECT a, b, t2.a, t2.b FROM t1 FULL JOIN t2 ON (t1.a == t2.a) ORDER BY (t1.a, t2.a);\n+SELECT '= left =';\n+SELECT a, b, t2.a, t2.b FROM t1 LEFT JOIN t2 ON (t1.a == t2.a) ORDER BY (t1.a, t2.a);\n+SELECT '= right =';\n+SELECT a, b, t2.a, t2.b FROM t1 RIGHT JOIN t2 ON (t1.a == t2.a) ORDER BY (t1.a, t2.a);\n+SELECT '= inner =';\n+SELECT a, b, t2.a, t2.b FROM t1 INNER JOIN t2 ON (t1.a == t2.a) ORDER BY (t1.a, t2.a);\n+\n+SELECT '= full =';\n+SELECT * FROM t1 FULL JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) ORDER BY (t1.a, t2.a);\n+SELECT '= left =';\n+SELECT * FROM t1 LEFT JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) ORDER BY (t1.a, t2.a);\n+SELECT '= right =';\n+SELECT * FROM t1 RIGHT JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) ORDER BY (t1.a, t2.a);\n+SELECT '= inner =';\n+SELECT * FROM t1 INNER JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) ORDER BY (t1.a, t2.a);\n+\n+-- Int64 and UInt64 has no supertype\n+SELECT * FROM t1 FULL JOIN t2 ON (t1.a + t1.b + 100 = t2.a + t2.b) ORDER BY (t1.a, t2.a); -- { serverError 53 }\n+SELECT * FROM t1 LEFT JOIN t2 ON (t1.a + t1.b + 100 = t2.a + t2.b) ORDER BY (t1.a, t2.a); -- { serverError 53 }\n+SELECT * FROM t1 RIGHT JOIN t2 ON (t1.a + t1.b + 100 = t2.a + t2.b) ORDER BY (t1.a, t2.a); -- { serverError 53 }\n+SELECT * FROM t1 INNER JOIN t2 ON (t1.a + t1.b + 100 = t2.a + t2.b) ORDER BY (t1.a, t2.a); -- { serverError 53 }\n+\n+SELECT '= agg =';\n+SELECT sum(a) == 7 FROM t1 FULL JOIN t2 USING (a) WHERE b > 102 AND t2.b <= 204;\n+SELECT sum(a) == 7 FROM t1 INNER JOIN t2 USING (a) WHERE b > 102 AND t2.b <= 204;\n+\n+SELECT sum(b) = 103 FROM t1 LEFT JOIN t2 USING (a) WHERE b > 102 AND t2.b < 204;\n+SELECT sum(t2.b) = 203 FROM t1 RIGHT JOIN t2 USING (a) WHERE b > 102 AND t2.b < 204;\n+\n+SELECT sum(a) == 2 + 3 + 4 FROM t1 FULL JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) WHERE t1.b < 105 AND t2.b > 201;\n+SELECT sum(a) == 55 FROM t1 FULL JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) WHERE 1;\n+\n+SELECT a > 0, sum(a), sum(b) FROM t1 FULL JOIN t2 USING (a) GROUP BY (a > 0) ORDER BY a > 0;\n+SELECT a > 0, sum(a), sum(t2.a), sum(b), sum(t2.b) FROM t1 FULL JOIN t2 ON (t1.a == t2.a) GROUP BY (a > 0) ORDER BY a > 0;\n+\n+SELECT '= types =';\n+SELECT any(toTypeName(a)) == 'Int32' AND any(toTypeName(t2.a)) == 'Int32' FROM t1 FULL JOIN t2 USING (a);\n+SELECT any(toTypeName(a)) == 'Int32' AND any(toTypeName(t2.a)) == 'Int32' FROM t1 LEFT JOIN t2 USING (a);\n+SELECT any(toTypeName(a)) == 'Int32' AND any(toTypeName(t2.a)) == 'Int32' FROM t1 RIGHT JOIN t2 USING (a);\n+SELECT any(toTypeName(a)) == 'Int32' AND any(toTypeName(t2.a)) == 'Int32' FROM t1 INNER JOIN t2 USING (a);\n+\n+SELECT toTypeName(any(a)) == 'Int32' AND toTypeName(any(t2.a)) == 'Int32' FROM t1 FULL JOIN t2 USING (a);\n+SELECT min(toTypeName(a) == 'Int32' AND toTypeName(t2.a) == 'Int32') FROM t1 FULL JOIN t2 USING (a);\n+\n+SELECT any(toTypeName(a)) == 'UInt16' AND any(toTypeName(t2.a)) == 'Int16' FROM t1 FULL JOIN t2 ON (t1.a == t2.a);\n+SELECT any(toTypeName(a)) == 'UInt16' AND any(toTypeName(t2.a)) == 'Int16' FROM t1 LEFT JOIN t2 ON (t1.a == t2.a);\n+SELECT any(toTypeName(a)) == 'UInt16' AND any(toTypeName(t2.a)) == 'Int16' FROM t1 RIGHT JOIN t2 ON (t1.a == t2.a);\n+SELECT any(toTypeName(a)) == 'UInt16' AND any(toTypeName(t2.a)) == 'Int16' FROM t1 INNER JOIN t2 ON (t1.a == t2.a);\n+SELECT toTypeName(any(a)) == 'UInt16' AND toTypeName(any(t2.a)) == 'Int16' FROM t1 FULL JOIN t2 ON (t1.a == t2.a);\n+\n+SELECT '=== switch ===';\n+\n+SET join_algorithm = 'auto';\n+SET max_bytes_in_join = 100;\n+\n+SELECT '= full =';\n+SELECT a, b, t2.b FROM t1 FULL JOIN t2 USING (a) ORDER BY (a);\n+SELECT '= left =';\n+SELECT a, b, t2.b FROM t1 LEFT JOIN t2 USING (a) ORDER BY (a);\n+SELECT '= right =';\n+SELECT a, b, t2.b FROM t1 RIGHT JOIN t2 USING (a) ORDER BY (a);\n+SELECT '= inner =';\n+SELECT a, b, t2.b FROM t1 INNER JOIN t2 USING (a) ORDER BY (a);\n+\n+SELECT '= full =';\n+SELECT a, t1.a, t2.a FROM t1 FULL JOIN t2 USING (a) ORDER BY (t1.a, t2.a);\n+SELECT '= left =';\n+SELECT a, t1.a, t2.a FROM t1 LEFT JOIN t2 USING (a) ORDER BY (t1.a, t2.a);\n+SELECT '= right =';\n+SELECT a, t1.a, t2.a FROM t1 RIGHT JOIN t2 USING (a) ORDER BY (t1.a, t2.a);\n+SELECT '= inner =';\n+SELECT a, t1.a, t2.a FROM t1 INNER JOIN t2 USING (a) ORDER BY (t1.a, t2.a);\n+\n+SELECT '= join on =';\n+SELECT '= full =';\n+SELECT a, b, t2.a, t2.b FROM t1 FULL JOIN t2 ON (t1.a == t2.a) ORDER BY (t1.a, t2.a);\n+SELECT '= left =';\n+SELECT a, b, t2.a, t2.b FROM t1 LEFT JOIN t2 ON (t1.a == t2.a) ORDER BY (t1.a, t2.a);\n+SELECT '= right =';\n+SELECT a, b, t2.a, t2.b FROM t1 RIGHT JOIN t2 ON (t1.a == t2.a) ORDER BY (t1.a, t2.a);\n+SELECT '= inner =';\n+SELECT a, b, t2.a, t2.b FROM t1 INNER JOIN t2 ON (t1.a == t2.a) ORDER BY (t1.a, t2.a);\n+\n+SELECT '= full =';\n+SELECT * FROM t1 FULL JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) ORDER BY (t1.a, t2.a);\n+SELECT '= left =';\n+SELECT * FROM t1 LEFT JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) ORDER BY (t1.a, t2.a);\n+SELECT '= right =';\n+SELECT * FROM t1 RIGHT JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) ORDER BY (t1.a, t2.a);\n+SELECT '= inner =';\n+SELECT * FROM t1 INNER JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) ORDER BY (t1.a, t2.a);\n+\n+-- Int64 and UInt64 has no supertype\n+SELECT * FROM t1 FULL JOIN t2 ON (t1.a + t1.b + 100 = t2.a + t2.b) ORDER BY (t1.a, t2.a); -- { serverError 53 }\n+SELECT * FROM t1 LEFT JOIN t2 ON (t1.a + t1.b + 100 = t2.a + t2.b) ORDER BY (t1.a, t2.a); -- { serverError 53 }\n+SELECT * FROM t1 RIGHT JOIN t2 ON (t1.a + t1.b + 100 = t2.a + t2.b) ORDER BY (t1.a, t2.a); -- { serverError 53 }\n+SELECT * FROM t1 INNER JOIN t2 ON (t1.a + t1.b + 100 = t2.a + t2.b) ORDER BY (t1.a, t2.a); -- { serverError 53 }\n+\n+SELECT '= agg =';\n+SELECT sum(a) == 7 FROM t1 FULL JOIN t2 USING (a) WHERE b > 102 AND t2.b <= 204;\n+SELECT sum(a) == 7 FROM t1 INNER JOIN t2 USING (a) WHERE b > 102 AND t2.b <= 204;\n+\n+SELECT sum(b) = 103 FROM t1 LEFT JOIN t2 USING (a) WHERE b > 102 AND t2.b < 204;\n+SELECT sum(t2.b) = 203 FROM t1 RIGHT JOIN t2 USING (a) WHERE b > 102 AND t2.b < 204;\n+\n+SELECT sum(a) == 2 + 3 + 4 FROM t1 FULL JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) WHERE t1.b < 105 AND t2.b > 201;\n+SELECT sum(a) == 55 FROM t1 FULL JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) WHERE 1;\n+\n+SELECT a > 0, sum(a), sum(b) FROM t1 FULL JOIN t2 USING (a) GROUP BY (a > 0) ORDER BY a > 0;\n+SELECT a > 0, sum(a), sum(t2.a), sum(b), sum(t2.b) FROM t1 FULL JOIN t2 ON (t1.a == t2.a) GROUP BY (a > 0) ORDER BY a > 0;\n+\n+SELECT '= types =';\n+SELECT any(toTypeName(a)) == 'Int32' AND any(toTypeName(t2.a)) == 'Int32' FROM t1 FULL JOIN t2 USING (a);\n+SELECT any(toTypeName(a)) == 'Int32' AND any(toTypeName(t2.a)) == 'Int32' FROM t1 LEFT JOIN t2 USING (a);\n+SELECT any(toTypeName(a)) == 'Int32' AND any(toTypeName(t2.a)) == 'Int32' FROM t1 RIGHT JOIN t2 USING (a);\n+SELECT any(toTypeName(a)) == 'Int32' AND any(toTypeName(t2.a)) == 'Int32' FROM t1 INNER JOIN t2 USING (a);\n+\n+SELECT toTypeName(any(a)) == 'Int32' AND toTypeName(any(t2.a)) == 'Int32' FROM t1 FULL JOIN t2 USING (a);\n+SELECT min(toTypeName(a) == 'Int32' AND toTypeName(t2.a) == 'Int32') FROM t1 FULL JOIN t2 USING (a);\n+\n+SELECT any(toTypeName(a)) == 'UInt16' AND any(toTypeName(t2.a)) == 'Int16' FROM t1 FULL JOIN t2 ON (t1.a == t2.a);\n+SELECT any(toTypeName(a)) == 'UInt16' AND any(toTypeName(t2.a)) == 'Int16' FROM t1 LEFT JOIN t2 ON (t1.a == t2.a);\n+SELECT any(toTypeName(a)) == 'UInt16' AND any(toTypeName(t2.a)) == 'Int16' FROM t1 RIGHT JOIN t2 ON (t1.a == t2.a);\n+SELECT any(toTypeName(a)) == 'UInt16' AND any(toTypeName(t2.a)) == 'Int16' FROM t1 INNER JOIN t2 ON (t1.a == t2.a);\n+SELECT toTypeName(any(a)) == 'UInt16' AND toTypeName(any(t2.a)) == 'Int16' FROM t1 FULL JOIN t2 ON (t1.a == t2.a);\n+\n+SET max_bytes_in_join = 0;\n+\n+SELECT '=== join use nulls ===';\n+\n+SET join_use_nulls = 1;\n+\n+\n+SELECT '= full =';\n+SELECT a, b, t2.b FROM t1 FULL JOIN t2 USING (a) ORDER BY (a);\n+SELECT '= left =';\n+SELECT a, b, t2.b FROM t1 LEFT JOIN t2 USING (a) ORDER BY (a);\n+SELECT '= right =';\n+SELECT a, b, t2.b FROM t1 RIGHT JOIN t2 USING (a) ORDER BY (a);\n+SELECT '= inner =';\n+SELECT a, b, t2.b FROM t1 INNER JOIN t2 USING (a) ORDER BY (a);\n+\n+SELECT '= full =';\n+SELECT a, t1.a, t2.a FROM t1 FULL JOIN t2 USING (a) ORDER BY (t1.a, t2.a);\n+SELECT '= left =';\n+SELECT a, t1.a, t2.a FROM t1 LEFT JOIN t2 USING (a) ORDER BY (t1.a, t2.a);\n+SELECT '= right =';\n+SELECT a, t1.a, t2.a FROM t1 RIGHT JOIN t2 USING (a) ORDER BY (t1.a, t2.a);\n+SELECT '= inner =';\n+SELECT a, t1.a, t2.a FROM t1 INNER JOIN t2 USING (a) ORDER BY (t1.a, t2.a);\n+\n+SELECT '= join on =';\n+SELECT '= full =';\n+SELECT a, b, t2.a, t2.b FROM t1 FULL JOIN t2 ON (t1.a == t2.a) ORDER BY (t1.a, t2.a);\n+SELECT '= left =';\n+SELECT a, b, t2.a, t2.b FROM t1 LEFT JOIN t2 ON (t1.a == t2.a) ORDER BY (t1.a, t2.a);\n+SELECT '= right =';\n+SELECT a, b, t2.a, t2.b FROM t1 RIGHT JOIN t2 ON (t1.a == t2.a) ORDER BY (t1.a, t2.a);\n+SELECT '= inner =';\n+SELECT a, b, t2.a, t2.b FROM t1 INNER JOIN t2 ON (t1.a == t2.a) ORDER BY (t1.a, t2.a);\n+\n+SELECT '= full =';\n+SELECT * FROM t1 FULL JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) ORDER BY (t1.a, t2.a);\n+SELECT '= left =';\n+SELECT * FROM t1 LEFT JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) ORDER BY (t1.a, t2.a);\n+SELECT '= right =';\n+SELECT * FROM t1 RIGHT JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) ORDER BY (t1.a, t2.a);\n+SELECT '= inner =';\n+SELECT * FROM t1 INNER JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) ORDER BY (t1.a, t2.a);\n+\n+-- Int64 and UInt64 has no supertype\n+SELECT * FROM t1 FULL JOIN t2 ON (t1.a + t1.b + 100 = t2.a + t2.b) ORDER BY (t1.a, t2.a); -- { serverError 53 }\n+SELECT * FROM t1 LEFT JOIN t2 ON (t1.a + t1.b + 100 = t2.a + t2.b) ORDER BY (t1.a, t2.a); -- { serverError 53 }\n+SELECT * FROM t1 RIGHT JOIN t2 ON (t1.a + t1.b + 100 = t2.a + t2.b) ORDER BY (t1.a, t2.a); -- { serverError 53 }\n+SELECT * FROM t1 INNER JOIN t2 ON (t1.a + t1.b + 100 = t2.a + t2.b) ORDER BY (t1.a, t2.a); -- { serverError 53 }\n+\n+SELECT '= agg =';\n+SELECT sum(a) == 7 FROM t1 FULL JOIN t2 USING (a) WHERE b > 102 AND t2.b <= 204;\n+SELECT sum(a) == 7 FROM t1 INNER JOIN t2 USING (a) WHERE b > 102 AND t2.b <= 204;\n+\n+SELECT sum(b) = 103 FROM t1 LEFT JOIN t2 USING (a) WHERE b > 102 AND t2.b < 204;\n+SELECT sum(t2.b) = 203 FROM t1 RIGHT JOIN t2 USING (a) WHERE b > 102 AND t2.b < 204;\n+\n+SELECT sum(a) == 2 + 3 + 4 FROM t1 FULL JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) WHERE t1.b < 105 AND t2.b > 201;\n+SELECT sum(a) == 55 FROM t1 FULL JOIN t2 ON (t1.a + t1.b = t2.a + t2.b - 100) WHERE 1;\n+\n+SELECT a > 0, sum(a), sum(b) FROM t1 FULL JOIN t2 USING (a) GROUP BY (a > 0) ORDER BY a > 0;\n+SELECT a > 0, sum(a), sum(t2.a), sum(b), sum(t2.b) FROM t1 FULL JOIN t2 ON (t1.a == t2.a) GROUP BY (a > 0) ORDER BY a > 0;\n+\n+SELECT '= types =';\n+SELECT any(toTypeName(a)) == 'Nullable(Int32)' AND any(toTypeName(t2.a)) == 'Nullable(Int32)' FROM t1 FULL JOIN t2 USING (a);\n+SELECT any(toTypeName(a)) == 'Int32' AND any(toTypeName(t2.a)) == 'Nullable(Int32)' FROM t1 LEFT JOIN t2 USING (a);\n+SELECT any(toTypeName(a)) == 'Nullable(Int32)' AND any(toTypeName(t2.a)) == 'Int32' FROM t1 RIGHT JOIN t2 USING (a);\n+SELECT any(toTypeName(a)) == 'Int32' AND any(toTypeName(t2.a)) == 'Int32' FROM t1 INNER JOIN t2 USING (a);\n+\n+SELECT toTypeName(any(a)) == 'Nullable(Int32)' AND toTypeName(any(t2.a)) == 'Nullable(Int32)' FROM t1 FULL JOIN t2 USING (a);\n+SELECT min(toTypeName(a) == 'Nullable(Int32)' AND toTypeName(t2.a) == 'Nullable(Int32)') FROM t1 FULL JOIN t2 USING (a);\n+\n+SELECT any(toTypeName(a)) == 'Nullable(UInt16)' AND any(toTypeName(t2.a)) == 'Nullable(Int16)' FROM t1 FULL JOIN t2 ON (t1.a == t2.a);\n+SELECT any(toTypeName(a)) == 'UInt16' AND any(toTypeName(t2.a)) == 'Nullable(Int16)' FROM t1 LEFT JOIN t2 ON (t1.a == t2.a);\n+SELECT any(toTypeName(a)) == 'Nullable(UInt16)' AND any(toTypeName(t2.a)) == 'Int16' FROM t1 RIGHT JOIN t2 ON (t1.a == t2.a);\n+SELECT any(toTypeName(a)) == 'UInt16' AND any(toTypeName(t2.a)) == 'Int16' FROM t1 INNER JOIN t2 ON (t1.a == t2.a);\n+SELECT toTypeName(any(a)) == 'Nullable(UInt16)' AND toTypeName(any(t2.a)) == 'Nullable(Int16)' FROM t1 FULL JOIN t2 ON (t1.a == t2.a);\n+\n+SET join_use_nulls = 0;\n+\n+DROP TABLE IF EXISTS t1;\n+DROP TABLE IF EXISTS t2;\n",
  "problem_statement": "Type conversions for JOIN keys.\n**Use case**\r\n```\r\nSELECT *\r\nFROM \r\n(\r\n    SELECT 1 AS k\r\n) AS t1\r\nINNER JOIN \r\n(\r\n    SELECT -1 AS k\r\n) AS t2 USING (k)\r\n\r\nReceived exception from server (version 20.13.1):\r\nCode: 53. DB::Exception: Received from localhost:9000. DB::Exception: Type mismatch of columns to JOIN by: k UInt8 at left, t2.k Int8 at right.\r\n```\r\n\r\n```\r\nSELECT *\r\nFROM \r\n(\r\n    SELECT 1 AS k\r\n) AS t1\r\nINNER JOIN \r\n(\r\n    SELECT -1 AS k\r\n) AS t2 ON t1.k = t2.k\r\n\r\nReceived exception from server (version 20.13.1):\r\nCode: 53. DB::Exception: Received from localhost:9000. DB::Exception: Type mismatch of columns to JOIN by: k UInt8 at left, t2.k Int8 at right.\r\n```\r\n\r\n**Describe the solution you'd like**\r\nCalculate `getLeastSupertype` and convert columns to it before joining.\r\n\r\n**Details**\r\n\r\nIt can be implemented in more sophisticated way, for example, if it is INNER or LEFT join, we can avoid type conversions for left table skip all records from right table that are not convertible. See the example in implementation of IN operator.\r\n\r\nThere can be also some difficulties due to the fact that the type of `k` in the result will be changed.\n",
  "hints_text": "",
  "created_at": "2021-01-31T19:28:35Z"
}