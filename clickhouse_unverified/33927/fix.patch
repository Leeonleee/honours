diff --git a/src/Common/IntervalTree.h b/src/Common/IntervalTree.h
index dc2987247d8d..608bd5cf12cb 100644
--- a/src/Common/IntervalTree.h
+++ b/src/Common/IntervalTree.h
@@ -291,6 +291,15 @@ class IntervalTree
 
     size_t getIntervalsSize() const { return intervals_size; }
 
+    size_t getSizeInBytes() const
+    {
+        size_t nodes_size_in_bytes = nodes.size() * sizeof(Node);
+        size_t intervals_size_in_bytes = sorted_intervals.size() * sizeof(IntervalWithValue);
+        size_t result = nodes_size_in_bytes + intervals_size_in_bytes;
+
+        return result;
+    }
+
 private:
     struct Node
     {
diff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h
index 416f759924c5..5bc089e085fd 100644
--- a/src/DataTypes/IDataType.h
+++ b/src/DataTypes/IDataType.h
@@ -523,6 +523,7 @@ inline bool isBool(const DataTypePtr & data_type)
 template <typename DataType> constexpr bool IsDataTypeDecimal = false;
 template <typename DataType> constexpr bool IsDataTypeNumber = false;
 template <typename DataType> constexpr bool IsDataTypeDateOrDateTime = false;
+template <typename DataType> constexpr bool IsDataTypeEnum = false;
 
 template <typename DataType> constexpr bool IsDataTypeDecimalOrNumber = IsDataTypeDecimal<DataType> || IsDataTypeNumber<DataType>;
 
@@ -547,4 +548,9 @@ template <> inline constexpr bool IsDataTypeDateOrDateTime<DataTypeDate32> = tru
 template <> inline constexpr bool IsDataTypeDateOrDateTime<DataTypeDateTime> = true;
 template <> inline constexpr bool IsDataTypeDateOrDateTime<DataTypeDateTime64> = true;
 
+template <typename T>
+class DataTypeEnum;
+
+template <typename T> inline constexpr bool IsDataTypeEnum<DataTypeEnum<T>> = true;
+
 }
diff --git a/src/Dictionaries/DictionarySource.cpp b/src/Dictionaries/DictionarySource.cpp
index d3058db87f48..526d9fc85cdc 100644
--- a/src/Dictionaries/DictionarySource.cpp
+++ b/src/Dictionaries/DictionarySource.cpp
@@ -60,8 +60,8 @@ class DictionarySource : public SourceWithProgress
         const auto & attributes_types_to_read = coordinator->getAttributesTypesToRead();
         const auto & attributes_default_values_columns = coordinator->getAttributesDefaultValuesColumns();
 
-        const auto & dictionary = coordinator->getDictionary();
-        auto attributes_columns = dictionary->getColumns(
+        const auto & read_columns_func = coordinator->getReadColumnsFunc();
+        auto attributes_columns = read_columns_func(
             attributes_names_to_read,
             attributes_types_to_read,
             key_columns,
diff --git a/src/Dictionaries/DictionarySource.h b/src/Dictionaries/DictionarySource.h
index 0237e1338dfb..7809c9584198 100644
--- a/src/Dictionaries/DictionarySource.h
+++ b/src/Dictionaries/DictionarySource.h
@@ -19,6 +19,8 @@ class DictionarySourceCoordinator final : public shared_ptr_helper<DictionarySou
 
 public:
 
+    using ReadColumnsFunc = std::function<Columns (const Strings &, const DataTypes &, const Columns &, const DataTypes &, const Columns &)>;
+
     Pipe read(size_t num_streams);
 
 private:
@@ -31,6 +33,15 @@ class DictionarySourceCoordinator final : public shared_ptr_helper<DictionarySou
         : dictionary(std::move(dictionary_))
         , key_columns_with_type(std::move(key_columns_with_type_))
         , max_block_size(max_block_size_)
+        , read_columns_func([this](
+            const Strings & attribute_names,
+            const DataTypes & result_types,
+            const Columns & key_columns,
+            const DataTypes & key_types,
+            const Columns & default_values_columns)
+        {
+            return dictionary->getColumns(attribute_names, result_types, key_columns, key_types, default_values_columns);
+        })
     {
         initialize(column_names);
     }
@@ -45,6 +56,31 @@ class DictionarySourceCoordinator final : public shared_ptr_helper<DictionarySou
         , key_columns_with_type(std::move(key_columns_with_type_))
         , data_columns_with_type(std::move(data_columns_with_type_))
         , max_block_size(max_block_size_)
+        , read_columns_func([this](
+            const Strings & attribute_names,
+            const DataTypes & result_types,
+            const Columns & key_columns,
+            const DataTypes & key_types,
+            const Columns & default_values_columns)
+        {
+            return dictionary->getColumns(attribute_names, result_types, key_columns, key_types, default_values_columns);
+        })
+    {
+        initialize(column_names);
+    }
+
+    explicit DictionarySourceCoordinator(
+        std::shared_ptr<const IDictionary> dictionary_,
+        const Names & column_names,
+        ColumnsWithTypeAndName && key_columns_with_type_,
+        ColumnsWithTypeAndName && data_columns_with_type_,
+        size_t max_block_size_,
+        ReadColumnsFunc read_columns_func_)
+        : dictionary(std::move(dictionary_))
+        , key_columns_with_type(std::move(key_columns_with_type_))
+        , data_columns_with_type(std::move(data_columns_with_type_))
+        , max_block_size(max_block_size_)
+        , read_columns_func(std::move(read_columns_func_))
     {
         initialize(column_names);
     }
@@ -61,6 +97,8 @@ class DictionarySourceCoordinator final : public shared_ptr_helper<DictionarySou
 
     const std::vector<ColumnPtr> & getAttributesDefaultValuesColumns() const { return attributes_default_values_columns; }
 
+    const ReadColumnsFunc & getReadColumnsFunc() const { return read_columns_func; }
+
     const std::shared_ptr<const IDictionary> & getDictionary() const { return dictionary; }
 
     void initialize(const Names & column_names);
@@ -79,6 +117,8 @@ class DictionarySourceCoordinator final : public shared_ptr_helper<DictionarySou
     std::vector<ColumnPtr> attributes_default_values_columns;
 
     const size_t max_block_size;
+    ReadColumnsFunc read_columns_func;
+
     std::atomic<size_t> parallel_read_block_index = 0;
 };
 
diff --git a/src/Dictionaries/DictionaryStructure.cpp b/src/Dictionaries/DictionaryStructure.cpp
index 2a0e1279050f..3e29f3efe766 100644
--- a/src/Dictionaries/DictionaryStructure.cpp
+++ b/src/Dictionaries/DictionaryStructure.cpp
@@ -382,7 +382,8 @@ std::vector<DictionaryAttribute> DictionaryStructure::getAttributes(
 
 void DictionaryStructure::parseRangeConfiguration(const Poco::Util::AbstractConfiguration & config, const std::string & structure_prefix)
 {
-    const char * range_default_type = "Date";
+    static constexpr auto range_default_type = "Date";
+
     if (config.has(structure_prefix + ".range_min"))
         range_min.emplace(makeDictionaryTypedSpecialAttribute(config, structure_prefix + ".range_min", range_default_type));
 
@@ -395,7 +396,10 @@ void DictionaryStructure::parseRangeConfiguration(const Poco::Util::AbstractConf
             "Dictionary structure should have both 'range_min' and 'range_max' either specified or not.");
     }
 
-    if (range_min && range_max && !range_min->type->equals(*range_max->type))
+    if (!range_min)
+        return;
+
+    if (!range_min->type->equals(*range_max->type))
     {
         throw Exception(ErrorCodes::BAD_ARGUMENTS,
             "Dictionary structure 'range_min' and 'range_max' should have same type, "
@@ -405,15 +409,20 @@ void DictionaryStructure::parseRangeConfiguration(const Poco::Util::AbstractConf
             range_max->type->getName());
     }
 
-    if (range_min && !range_min->type->isValueRepresentedByInteger())
+    WhichDataType range_type(range_min->type);
+
+    bool valid_range = range_type.isInt() || range_type.isUInt() || range_type.isDecimal() || range_type.isFloat() || range_type.isEnum()
+        || range_type.isDate() || range_type.isDate32() || range_type.isDateTime() || range_type.isDateTime64();
+
+    if (!valid_range)
     {
         throw Exception(ErrorCodes::BAD_ARGUMENTS,
-            "Dictionary structure type of 'range_min' and 'range_max' should be an integer, Date, DateTime, or Enum."
+            "Dictionary structure type of 'range_min' and 'range_max' should be an Integer, Float, Decimal, Date, Date32, DateTime DateTime64, or Enum."
             " Actual 'range_min' and 'range_max' type is {}",
             range_min->type->getName());
     }
 
-    if ((range_min && !range_min->expression.empty()) || (range_max && !range_max->expression.empty()))
+    if (!range_min->expression.empty() || !range_max->expression.empty())
         has_expressions = true;
 }
 
diff --git a/src/Dictionaries/RangeHashedDictionary.cpp b/src/Dictionaries/RangeHashedDictionary.cpp
index 979cfce6ce22..14c8fc7c7493 100644
--- a/src/Dictionaries/RangeHashedDictionary.cpp
+++ b/src/Dictionaries/RangeHashedDictionary.cpp
@@ -1,56 +1,21 @@
 #include <Dictionaries/RangeHashedDictionary.h>
 
-#include <Columns/ColumnNullable.h>
-#include <Functions/FunctionHelpers.h>
-#include <Interpreters/castColumn.h>
+#include <DataTypes/DataTypesNumber.h>
 #include <DataTypes/DataTypesDecimal.h>
+#include <DataTypes/DataTypeEnum.h>
 #include <DataTypes/DataTypeDate.h>
 #include <DataTypes/DataTypeDate32.h>
 #include <DataTypes/DataTypeDateTime.h>
-#include <Dictionaries/DictionaryFactory.h>
-#include <Dictionaries/DictionarySource.h>
-
-
-namespace
-{
-
-using RangeStorageType = DB::RangeStorageType;
-
-// Null values mean that specified boundary, either min or max is not set on range.
-// To simplify comparison, null value of min bound should be bigger than any other value,
-// and null value of maxbound - less than any value.
-const RangeStorageType RANGE_MIN_NULL_VALUE = std::numeric_limits<RangeStorageType>::max();
-const RangeStorageType RANGE_MAX_NULL_VALUE = std::numeric_limits<RangeStorageType>::lowest();
-
-bool isCorrectDate(const RangeStorageType & date)
-{
-    return 0 < date && date <= DATE_LUT_MAX_DAY_NUM;
-}
-
-// Handle both kinds of null values: explicit nulls of NullableColumn and 'implicit' nulls of Date type.
-RangeStorageType getColumnIntValueOrDefault(const DB::IColumn & column, size_t index, bool isDate, const RangeStorageType & default_value)
-{
-    if (column.isNullAt(index))
-        return default_value;
-
-    const RangeStorageType result = static_cast<RangeStorageType>(column.getInt(index));
-    if (isDate && !isCorrectDate(result))
-        return default_value;
+#include <DataTypes/DataTypeDateTime64.h>
 
-    return result;
-}
+#include <Columns/ColumnNullable.h>
 
-const DB::IColumn & unwrapNullableColumn(const DB::IColumn & column)
-{
-    if (const auto * m = DB::checkAndGetColumn<DB::ColumnNullable>(&column))
-    {
-        return m->getNestedColumn();
-    }
+#include <Functions/FunctionHelpers.h>
+#include <Interpreters/castColumn.h>
 
-    return column;
-}
+#include <Dictionaries/DictionaryFactory.h>
+#include <Dictionaries/DictionarySource.h>
 
-}
 
 namespace DB
 {
@@ -60,22 +25,53 @@ namespace ErrorCodes
     extern const int BAD_ARGUMENTS;
     extern const int DICTIONARY_IS_EMPTY;
     extern const int UNSUPPORTED_METHOD;
+    extern const int TYPE_MISMATCH;
 }
 
+namespace
+{
+    template <typename F>
+    void callOnRangeType(const DataTypePtr & range_type, F && func)
+    {
+        auto call = [&](const auto & types)
+        {
+            using Types = std::decay_t<decltype(types)>;
+            using DataType = typename Types::LeftType;
+
+            if constexpr (IsDataTypeDecimalOrNumber<DataType> || IsDataTypeDateOrDateTime<DataType> || IsDataTypeEnum<DataType>)
+            {
+                using ColumnType = typename DataType::ColumnType;
+                func(TypePair<ColumnType, void>());
+                return true;
+            }
+
+            return false;
+        };
+
+        auto type_index = range_type->getTypeId();
+        if (!callOnIndexAndDataType<void>(type_index, call))
+        {
+            throw Exception(ErrorCodes::BAD_ARGUMENTS,
+                "Dictionary structure type of 'range_min' and 'range_max' should be an Integer, Float, Decimal, Date, Date32, DateTime DateTime64, or Enum."
+                " Actual 'range_min' and 'range_max' type is {}",
+                range_type->getName());
+        }
+    }
+}
 
 template <DictionaryKeyType dictionary_key_type>
 RangeHashedDictionary<dictionary_key_type>::RangeHashedDictionary(
     const StorageID & dict_id_,
     const DictionaryStructure & dict_struct_,
     DictionarySourcePtr source_ptr_,
-    const DictionaryLifetime dict_lifetime_,
-    bool require_nonempty_,
+    DictionaryLifetime dict_lifetime_,
+    RangeHashedDictionaryConfiguration configuration_,
     BlockPtr update_field_loaded_block_)
     : IDictionary(dict_id_)
     , dict_struct(dict_struct_)
-    , source_ptr{std::move(source_ptr_)}
+    , source_ptr(std::move(source_ptr_))
     , dict_lifetime(dict_lifetime_)
-    , require_nonempty(require_nonempty_)
+    , configuration(configuration_)
     , update_field_loaded_block(std::move(update_field_loaded_block_))
 {
     createAttributes();
@@ -104,15 +100,14 @@ ColumnPtr RangeHashedDictionary<dictionary_key_type>::getColumn(
     const size_t attribute_index = dict_struct.attribute_name_to_index.find(attribute_name)->second;
     const auto & attribute = attributes[attribute_index];
 
-    /// Cast second column to storage type
+    /// Cast range column to storage type
     Columns modified_key_columns = key_columns;
     auto range_storage_column = key_columns.back();
     ColumnWithTypeAndName column_to_cast = {range_storage_column->convertToFullColumnIfConst(), key_types.back(), ""};
-    auto range_column_storage_type = std::make_shared<DataTypeInt64>();
-    modified_key_columns.back() = castColumnAccurate(column_to_cast, range_column_storage_type);
+    modified_key_columns.back() = castColumnAccurate(column_to_cast, dict_struct.range_min->type);
 
     size_t keys_size = key_columns.front()->size();
-    bool is_attribute_nullable = attribute.is_nullable;
+    bool is_attribute_nullable = attribute.is_value_nullable.has_value();
 
     ColumnUInt8::MutablePtr col_null_map_to;
     ColumnUInt8::Container * vec_null_map_to = nullptr;
@@ -122,7 +117,7 @@ ColumnPtr RangeHashedDictionary<dictionary_key_type>::getColumn(
         vec_null_map_to = &col_null_map_to->getData();
     }
 
-    auto type_call = [&](const auto &dictionary_attribute_type)
+    auto type_call = [&](const auto & dictionary_attribute_type)
     {
         using Type = std::decay_t<decltype(dictionary_attribute_type)>;
         using AttributeType = typename Type::AttributeType;
@@ -206,6 +201,106 @@ ColumnPtr RangeHashedDictionary<dictionary_key_type>::getColumn(
     return result;
 }
 
+template <DictionaryKeyType dictionary_key_type>
+ColumnPtr RangeHashedDictionary<dictionary_key_type>::getColumnInternal(
+    const std::string & attribute_name,
+    const DataTypePtr & result_type,
+    const PaddedPODArray<UInt64> & key_to_index) const
+{
+    ColumnPtr result;
+
+    const auto & dictionary_attribute = dict_struct.getAttribute(attribute_name, result_type);
+    const size_t attribute_index = dict_struct.attribute_name_to_index.find(attribute_name)->second;
+    const auto & attribute = attributes[attribute_index];
+
+    size_t keys_size = key_to_index.size();
+    bool is_attribute_nullable = attribute.is_value_nullable.has_value();
+
+    ColumnUInt8::MutablePtr col_null_map_to;
+    ColumnUInt8::Container * vec_null_map_to = nullptr;
+    if (is_attribute_nullable)
+    {
+        col_null_map_to = ColumnUInt8::create(keys_size, false);
+        vec_null_map_to = &col_null_map_to->getData();
+    }
+
+    auto type_call = [&](const auto & dictionary_attribute_type)
+    {
+        using Type = std::decay_t<decltype(dictionary_attribute_type)>;
+        using AttributeType = typename Type::AttributeType;
+        using ValueType = DictionaryValueType<AttributeType>;
+        using ColumnProvider = DictionaryAttributeColumnProvider<AttributeType>;
+
+        auto column = ColumnProvider::getColumn(dictionary_attribute, keys_size);
+
+        if constexpr (std::is_same_v<ValueType, Array>)
+        {
+            auto * out = column.get();
+
+            getItemsInternalImpl<ValueType, false>(
+                attribute,
+                key_to_index,
+                [&](size_t, const Array & value, bool)
+                {
+                    out->insert(value);
+                });
+        }
+        else if constexpr (std::is_same_v<ValueType, StringRef>)
+        {
+            auto * out = column.get();
+
+            if (is_attribute_nullable)
+                getItemsInternalImpl<ValueType, true>(
+                    attribute,
+                    key_to_index,
+                    [&](size_t row, const StringRef value, bool is_null)
+                    {
+                        (*vec_null_map_to)[row] = is_null;
+                        out->insertData(value.data, value.size);
+                    });
+            else
+                getItemsInternalImpl<ValueType, false>(
+                    attribute,
+                    key_to_index,
+                    [&](size_t, const StringRef value, bool)
+                    {
+                        out->insertData(value.data, value.size);
+                    });
+        }
+        else
+        {
+            auto & out = column->getData();
+
+            if (is_attribute_nullable)
+                getItemsInternalImpl<ValueType, true>(
+                    attribute,
+                    key_to_index,
+                    [&](size_t row, const auto value, bool is_null)
+                    {
+                        (*vec_null_map_to)[row] = is_null;
+                        out[row] = value;
+                    });
+            else
+                getItemsInternalImpl<ValueType, false>(
+                    attribute,
+                    key_to_index,
+                    [&](size_t row, const auto value, bool)
+                    {
+                        out[row] = value;
+                    });
+        }
+
+        result = std::move(column);
+    };
+
+    callOnDictionaryAttributeType(attribute.type, type_call);
+
+    if (is_attribute_nullable)
+        result = ColumnNullable::create(std::move(result), std::move(col_null_map_to));
+
+    return result;
+}
+
 template <DictionaryKeyType dictionary_key_type>
 ColumnUInt8::Ptr RangeHashedDictionary<dictionary_key_type>::hasKeys(const Columns & key_columns, const DataTypes & key_types) const
 {
@@ -216,41 +311,45 @@ ColumnUInt8::Ptr RangeHashedDictionary<dictionary_key_type>::hasKeys(const Colum
         dict_struct.validateKeyTypes(key_types_copy);
     }
 
-    auto range_column_storage_type = std::make_shared<DataTypeInt64>();
+    /// Cast range column to storage type
     auto range_storage_column = key_columns.back();
     ColumnWithTypeAndName column_to_cast = {range_storage_column->convertToFullColumnIfConst(), key_types.back(), ""};
-    auto range_column_updated = castColumnAccurate(column_to_cast, range_column_storage_type);
-    PaddedPODArray<RangeStorageType> range_backup_storage;
-    const PaddedPODArray<RangeStorageType> & dates = getColumnVectorData(this, range_column_updated, range_backup_storage);
-
+    auto range_column_updated = castColumnAccurate(column_to_cast, dict_struct.range_min->type);
     auto key_columns_copy = key_columns;
     key_columns_copy.pop_back();
+
     DictionaryKeysArenaHolder<dictionary_key_type> arena_holder;
     DictionaryKeysExtractor<dictionary_key_type> keys_extractor(key_columns_copy, arena_holder.getComplexKeyArena());
     const size_t keys_size = keys_extractor.getKeysSize();
 
-    const auto & attribute = attributes.front();
-
     auto result = ColumnUInt8::create(keys_size);
     auto & out = result->getData();
     size_t keys_found = 0;
 
-    auto type_call = [&](const auto & dictionary_attribute_type)
+    callOnRangeType(dict_struct.range_min->type, [&](const auto & types)
     {
-        using Type = std::decay_t<decltype(dictionary_attribute_type)>;
-        using AttributeType = typename Type::AttributeType;
-        using ValueType = DictionaryValueType<AttributeType>;
+        using Types = std::decay_t<decltype(types)>;
+        using RangeColumnType = typename Types::LeftType;
+        using RangeStorageType = typename RangeColumnType::ValueType;
+
+        const auto * range_column_typed = typeid_cast<const RangeColumnType *>(range_column_updated.get());
+        if (!range_column_typed)
+            throw Exception(ErrorCodes::TYPE_MISMATCH,
+                "Dictionary {} range column type should be equal to {}",
+                getFullName(),
+                dict_struct.range_min->type->getName());
+        const auto & range_column_data = range_column_typed->getData();
 
-        const auto & collection = std::get<CollectionType<ValueType>>(attribute.maps);
+        const auto & key_attribute_container = std::get<KeyAttributeContainerType<RangeStorageType>>(key_attribute.container);
 
         for (size_t key_index = 0; key_index < keys_size; ++key_index)
         {
             const auto key = keys_extractor.extractCurrentKey();
-            const auto it = collection.find(key);
+            const auto it = key_attribute_container.find(key);
 
             if (it)
             {
-                const auto date = dates[key_index];
+                const auto date = range_column_data[key_index];
                 const auto & interval_tree = it->getMapped();
                 out[key_index] = interval_tree.has(date);
                 keys_found += out[key_index];
@@ -262,9 +361,7 @@ ColumnUInt8::Ptr RangeHashedDictionary<dictionary_key_type>::hasKeys(const Colum
 
             keys_extractor.rollbackCurrentKey();
         }
-    };
-
-    callOnDictionaryAttributeType(attribute.type, type_call);
+    });
 
     query_count.fetch_add(keys_size, std::memory_order_relaxed);
     found_count.fetch_add(keys_found, std::memory_order_relaxed);
@@ -286,6 +383,16 @@ void RangeHashedDictionary<dictionary_key_type>::createAttributes()
             throw Exception(ErrorCodes::BAD_ARGUMENTS, "Hierarchical attributes not supported by {} dictionary.",
                             getDictionaryID().getNameForLogs());
     }
+
+    callOnRangeType(dict_struct.range_min->type, [&](const auto & types)
+    {
+        using Types = std::decay_t<decltype(types)>;
+        using RangeColumnType = typename Types::LeftType;
+        using RangeStorageType = typename RangeColumnType::ValueType;
+
+        key_attribute.container = KeyAttributeContainerType<RangeStorageType>();
+        key_attribute.invalid_intervals_container = InvalidIntervalsContainerType<RangeStorageType>();
+    });
 }
 
 template <DictionaryKeyType dictionary_key_type>
@@ -294,9 +401,9 @@ void RangeHashedDictionary<dictionary_key_type>::loadData()
     if (!source_ptr->hasUpdateField())
     {
         QueryPipeline pipeline(source_ptr->loadAll());
-
         PullingPipelineExecutor executor(pipeline);
         Block block;
+
         while (executor.pull(block))
         {
             blockToAttributes(block);
@@ -307,9 +414,19 @@ void RangeHashedDictionary<dictionary_key_type>::loadData()
         updateData();
     }
 
-    buildAttributeIntervalTrees();
+    callOnRangeType(dict_struct.range_min->type, [&](const auto & types)
+    {
+        using Types = std::decay_t<decltype(types)>;
+        using RangeColumnType = typename Types::LeftType;
+        using RangeStorageType = typename RangeColumnType::ValueType;
+
+        auto & key_attribute_container = std::get<KeyAttributeContainerType<RangeStorageType>>(key_attribute.container);
+
+        for (auto & [_, intervals] : key_attribute_container)
+            intervals.build();
+    });
 
-    if (require_nonempty && 0 == element_count)
+    if (configuration.require_nonempty && 0 == element_count)
         throw Exception(ErrorCodes::DICTIONARY_IS_EMPTY,
             "{}: dictionary source is empty and 'require_nonempty' property is set.");
 }
@@ -317,8 +434,22 @@ void RangeHashedDictionary<dictionary_key_type>::loadData()
 template <DictionaryKeyType dictionary_key_type>
 void RangeHashedDictionary<dictionary_key_type>::calculateBytesAllocated()
 {
-    bytes_allocated += attributes.size() * sizeof(attributes.front());
+    callOnRangeType(dict_struct.range_min->type, [&](const auto & types)
+    {
+        using Types = std::decay_t<decltype(types)>;
+        using RangeColumnType = typename Types::LeftType;
+        using RangeStorageType = typename RangeColumnType::ValueType;
+
+        auto & key_attribute_container = std::get<KeyAttributeContainerType<RangeStorageType>>(key_attribute.container);
+
+        bucket_count = key_attribute_container.getBufferSizeInCells();
+        bytes_allocated += key_attribute_container.getBufferSizeInBytes();
+
+        for (auto & [_, intervals] : key_attribute_container)
+            bytes_allocated += intervals.getSizeInBytes();
+    });
 
+    bytes_allocated += attributes.size() * sizeof(attributes.front());
     for (const auto & attribute : attributes)
     {
         auto type_call = [&](const auto & dictionary_attribute_type)
@@ -327,17 +458,17 @@ void RangeHashedDictionary<dictionary_key_type>::calculateBytesAllocated()
             using AttributeType = typename Type::AttributeType;
             using ValueType = DictionaryValueType<AttributeType>;
 
-            const auto & collection = std::get<CollectionType<ValueType>>(attribute.maps);
-            bytes_allocated += sizeof(CollectionType<ValueType>) + collection.getBufferSizeInBytes();
-            bucket_count = collection.getBufferSizeInCells();
+            const auto & container = std::get<AttributeContainerType<ValueType>>(attribute.container);
+
+            bytes_allocated += container.size() * sizeof(ValueType);
+
+            if (attribute.is_value_nullable)
+                bytes_allocated += (*attribute.is_value_nullable).size() * sizeof(bool);
         };
 
         callOnDictionaryAttributeType(attribute.type, type_call);
     }
 
-    if constexpr (dictionary_key_type == DictionaryKeyType::Complex)
-        bytes_allocated += complex_key_arena.size();
-
     if (update_field_loaded_block)
         bytes_allocated += update_field_loaded_block->allocatedBytes();
 
@@ -347,15 +478,20 @@ void RangeHashedDictionary<dictionary_key_type>::calculateBytesAllocated()
 template <DictionaryKeyType dictionary_key_type>
 typename RangeHashedDictionary<dictionary_key_type>::Attribute RangeHashedDictionary<dictionary_key_type>::createAttribute(const DictionaryAttribute & dictionary_attribute)
 {
-    Attribute attribute{dictionary_attribute.underlying_type, dictionary_attribute.is_nullable, {}};
+    std::optional<std::vector<bool>> is_value_nullable;
+
+    if (dictionary_attribute.is_nullable)
+        is_value_nullable.emplace(std::vector<bool>());
+
+    Attribute attribute{dictionary_attribute.underlying_type, {}, std::move(is_value_nullable)};
 
-    auto type_call = [&](const auto &dictionary_attribute_type)
+    auto type_call = [&](const auto & dictionary_attribute_type)
     {
         using Type = std::decay_t<decltype(dictionary_attribute_type)>;
         using AttributeType = typename Type::AttributeType;
         using ValueType = DictionaryValueType<AttributeType>;
 
-        attribute.maps = CollectionType<ValueType>();
+        attribute.container = AttributeContainerType<ValueType>();
     };
 
     callOnDictionaryAttributeType(dictionary_attribute.underlying_type, type_call);
@@ -371,78 +507,156 @@ void RangeHashedDictionary<dictionary_key_type>::getItemsImpl(
     ValueSetter && set_value,
     DefaultValueExtractor & default_value_extractor) const
 {
-    const auto & collection = std::get<CollectionType<AttributeType>>(attribute.maps);
+    const auto & attribute_container = std::get<AttributeContainerType<AttributeType>>(attribute.container);
 
     size_t keys_found = 0;
 
-    PaddedPODArray<RangeStorageType> range_backup_storage;
-    const auto & dates = getColumnVectorData(this, key_columns.back(), range_backup_storage);
-
+    auto range_column = key_columns.back();
     auto key_columns_copy = key_columns;
     key_columns_copy.pop_back();
+
     DictionaryKeysArenaHolder<dictionary_key_type> arena_holder;
     DictionaryKeysExtractor<dictionary_key_type> keys_extractor(key_columns_copy, arena_holder.getComplexKeyArena());
     const size_t keys_size = keys_extractor.getKeysSize();
 
-    for (size_t key_index = 0; key_index < keys_size; ++key_index)
+    callOnRangeType(dict_struct.range_min->type, [&](const auto & types)
     {
-        auto key = keys_extractor.extractCurrentKey();
-        const auto it = collection.find(key);
-
-        if (it)
-        {
-            const auto date = dates[key_index];
-            const auto & interval_tree = it->getMapped();
-
-            std::optional<AttributeType> min_value;
-            std::optional<RangeInterval> min_range;
-            bool has_interval = false;
+        using Types = std::decay_t<decltype(types)>;
+        using RangeColumnType = typename Types::LeftType;
+        using RangeStorageType = typename RangeColumnType::ValueType;
+        using RangeInterval = Interval<RangeStorageType>;
 
-            interval_tree.find(date, [&](auto & interval, auto & value)
-            {
-                has_interval = true;
+        const auto * range_column_typed = typeid_cast<const RangeColumnType *>(range_column.get());
+        if (!range_column_typed)
+            throw Exception(ErrorCodes::TYPE_MISMATCH,
+                "Dictionary {} range column type should be equal to {}",
+                getFullName(),
+                dict_struct.range_min->type->getName());
 
-                if (min_range && interval < *min_range)
-                    min_range = interval;
-                else
-                    min_range = interval;
+        const auto & range_column_data = range_column_typed->getData();
 
-                min_value = value;
+        const auto & key_attribute_container = std::get<KeyAttributeContainerType<RangeStorageType>>(key_attribute.container);
 
-                return true;
-            });
+        for (size_t key_index = 0; key_index < keys_size; ++key_index)
+        {
+            auto key = keys_extractor.extractCurrentKey();
+            const auto it = key_attribute_container.find(key);
 
-            if (has_interval)
+            if (it)
             {
-                ++keys_found;
+                const auto date = range_column_data[key_index];
+                const auto & interval_tree = it->getMapped();
 
-                if constexpr (is_nullable)
+                size_t value_index = 0;
+                std::optional<RangeInterval> range;
+
+                interval_tree.find(date, [&](auto & interval, auto & interval_value_index)
                 {
-                    if (min_value.has_value())
-                        set_value(key_index, *min_value, false);
+                    if (range)
+                    {
+                        if (likely(configuration.lookup_strategy == RangeHashedDictionaryLookupStrategy::min) && interval < *range)
+                        {
+                            range = interval;
+                            value_index = interval_value_index;
+                        }
+                        else if (configuration.lookup_strategy == RangeHashedDictionaryLookupStrategy::max && interval > * range)
+                        {
+                            range = interval;
+                            value_index = interval_value_index;
+                        }
+                    }
                     else
-                        set_value(key_index, default_value_extractor[key_index], true);
-                }
-                else
+                    {
+                        range = interval;
+                        value_index = interval_value_index;
+                    }
+
+                    return true;
+                });
+
+                if (range.has_value())
                 {
-                    set_value(key_index, *min_value, false);
-                }
+                    ++keys_found;
 
-                keys_extractor.rollbackCurrentKey();
-                continue;
+                    AttributeType value = attribute_container[value_index];
+
+                    if constexpr (is_nullable)
+                    {
+                        bool is_null = (*attribute.is_value_nullable)[value_index];
+
+                        if (!is_null)
+                            set_value(key_index, value, false);
+                        else
+                            set_value(key_index, default_value_extractor[key_index], true);
+                    }
+                    else
+                    {
+                        set_value(key_index, value, false);
+                    }
+
+                    keys_extractor.rollbackCurrentKey();
+                    continue;
+                }
             }
+
+            if constexpr (is_nullable)
+                set_value(key_index, default_value_extractor[key_index], default_value_extractor.isNullAt(key_index));
+            else
+                set_value(key_index, default_value_extractor[key_index], false);
+
+            keys_extractor.rollbackCurrentKey();
+        }
+    });
+
+    query_count.fetch_add(keys_size, std::memory_order_relaxed);
+    found_count.fetch_add(keys_found, std::memory_order_relaxed);
+}
+
+template <DictionaryKeyType dictionary_key_type>
+template <typename AttributeType, bool is_nullable, typename ValueSetter>
+void RangeHashedDictionary<dictionary_key_type>::getItemsInternalImpl(
+        const Attribute & attribute,
+        const PaddedPODArray<UInt64> & key_to_index,
+        ValueSetter && set_value) const
+{
+    size_t keys_size = key_to_index.size();
+
+    const auto & container = std::get<AttributeContainerType<AttributeType>>(attribute.container);
+    size_t container_size = container.size();
+
+    for (size_t key_index = 0; key_index < keys_size; ++key_index)
+    {
+        UInt64 container_index = key_to_index[key_index];
+
+        if (unlikely(container_index >= container_size))
+        {
+            throw Exception(ErrorCodes::LOGICAL_ERROR,
+                "Dictionary {} expected attribute container index {} must be less than attribute container size {}",
+                getFullName(),
+                container_index,
+                container_size
+            );
         }
 
+        AttributeType value = container[container_index];
+
         if constexpr (is_nullable)
-            set_value(key_index, default_value_extractor[key_index], default_value_extractor.isNullAt(key_index));
-        else
-            set_value(key_index, default_value_extractor[key_index], false);
+        {
+            bool is_null = (*attribute.is_value_nullable)[container_index];
 
-        keys_extractor.rollbackCurrentKey();
+            if (!is_null)
+                set_value(key_index, value, false);
+            else
+                set_value(key_index, value, true);
+        }
+        else
+        {
+            set_value(key_index, value, false);
+        }
     }
 
     query_count.fetch_add(keys_size, std::memory_order_relaxed);
-    found_count.fetch_add(keys_found, std::memory_order_relaxed);
+    found_count.fetch_add(keys_size, std::memory_order_relaxed);
 }
 
 template <DictionaryKeyType dictionary_key_type>
@@ -486,282 +700,379 @@ void RangeHashedDictionary<dictionary_key_type>::updateData()
 }
 
 template <DictionaryKeyType dictionary_key_type>
-void RangeHashedDictionary<dictionary_key_type>::blockToAttributes(const Block & block [[maybe_unused]])
+void RangeHashedDictionary<dictionary_key_type>::blockToAttributes(const Block & block)
 {
-    size_t skip_keys_size_offset = dict_struct.getKeysSize();
+    size_t attributes_size = attributes.size();
+    size_t dictionary_keys_size = dict_struct.getKeysSize();
+
+    static constexpr size_t ranges_size = 2;
+
+    size_t block_columns = block.columns();
+    size_t range_dictionary_attributes_size = attributes_size + dictionary_keys_size + ranges_size;
+
+    if (range_dictionary_attributes_size != block.columns())
+    {
+        throw Exception(ErrorCodes::UNSUPPORTED_METHOD,
+            "Block size mismatch. Actual {}. Expected {}",
+            block_columns,
+            range_dictionary_attributes_size);
+    }
 
     Columns key_columns;
-    key_columns.reserve(skip_keys_size_offset);
+    key_columns.reserve(dictionary_keys_size);
 
     /// Split into keys columns and attribute columns
-    for (size_t i = 0; i < skip_keys_size_offset; ++i)
-        key_columns.emplace_back(block.safeGetByPosition(i).column);
+    for (size_t i = 0; i < dictionary_keys_size; ++i)
+        key_columns.emplace_back(block.getByPosition(i).column);
 
     DictionaryKeysArenaHolder<dictionary_key_type> arena_holder;
     DictionaryKeysExtractor<dictionary_key_type> keys_extractor(key_columns, arena_holder.getComplexKeyArena());
     const size_t keys_size = keys_extractor.getKeysSize();
 
-    element_count += keys_size;
+    size_t block_attributes_skip_offset = dictionary_keys_size;
+
+    const auto * min_range_column = block.getByPosition(block_attributes_skip_offset).column.get();
+    const auto * max_range_column = block.getByPosition(block_attributes_skip_offset + 1).column.get();
 
-    // Support old behaviour, where invalid date means 'open range'.
-    const bool is_date = isDate(dict_struct.range_min->type);
+    const NullMap * min_range_null_map = nullptr;
+    const NullMap * max_range_null_map = nullptr;
 
-    const auto & min_range_column = unwrapNullableColumn(*block.safeGetByPosition(skip_keys_size_offset).column);
-    const auto & max_range_column = unwrapNullableColumn(*block.safeGetByPosition(skip_keys_size_offset + 1).column);
+    if (const auto * min_range_column_nullable = checkAndGetColumn<ColumnNullable>(min_range_column))
+    {
+        min_range_column = &min_range_column_nullable->getNestedColumn();
+        min_range_null_map = &min_range_column_nullable->getNullMapColumn().getData();
+    }
 
-    skip_keys_size_offset += 2;
+    if (const auto * max_range_column_nullable = checkAndGetColumn<ColumnNullable>(max_range_column))
+    {
+        max_range_column = &max_range_column_nullable->getNestedColumn();
+        max_range_null_map = &max_range_column_nullable->getNullMapColumn().getData();
+    }
 
-    for (size_t attribute_index = 0; attribute_index < attributes.size(); ++attribute_index)
+    callOnRangeType(dict_struct.range_min->type, [&](const auto & types)
     {
-        const auto & attribute_column = *block.safeGetByPosition(attribute_index + skip_keys_size_offset).column;
-        auto & attribute = attributes[attribute_index];
+        using Types = std::decay_t<decltype(types)>;
+        using RangeColumnType = typename Types::LeftType;
+        using RangeStorageType = typename RangeColumnType::ValueType;
+
+        const auto * min_range_column_typed = typeid_cast<const RangeColumnType *>(min_range_column);
+        if (!min_range_column_typed)
+            throw Exception(ErrorCodes::TYPE_MISMATCH,
+                "Dictionary {} range min column type should be equal to {}",
+                getFullName(),
+                dict_struct.range_min->type->getName());
+
+        const auto * max_range_column_typed = typeid_cast<const RangeColumnType *>(max_range_column);
+        if (!max_range_column_typed)
+            throw Exception(ErrorCodes::TYPE_MISMATCH,
+                "Dictionary {} range max column type should be equal to {}",
+                getFullName(),
+                dict_struct.range_max->type->getName());
+
+        const auto & min_range_column_data = min_range_column_typed->getData();
+        const auto & max_range_column_data = max_range_column_typed->getData();
+
+        auto & key_attribute_container = std::get<KeyAttributeContainerType<RangeStorageType>>(key_attribute.container);
+        auto & invalid_intervals_container = std::get<InvalidIntervalsContainerType<RangeStorageType>>(key_attribute.invalid_intervals_container);
+
+        block_attributes_skip_offset += 2;
+
+        Field column_value;
 
         for (size_t key_index = 0; key_index < keys_size; ++key_index)
         {
             auto key = keys_extractor.extractCurrentKey();
 
-            RangeStorageType lower_bound;
-            RangeStorageType upper_bound;
+            RangeStorageType lower_bound = min_range_column_data[key_index];
+            RangeStorageType upper_bound = max_range_column_data[key_index];
+
+            bool invalid_range = false;
 
-            if (is_date)
+            if (unlikely(min_range_null_map && (*min_range_null_map)[key_index]))
             {
-                lower_bound = getColumnIntValueOrDefault(min_range_column, key_index, is_date, 0);
-                upper_bound = getColumnIntValueOrDefault(max_range_column, key_index, is_date, DATE_LUT_MAX_DAY_NUM + 1);
+                lower_bound = std::numeric_limits<RangeStorageType>::min();
+                invalid_range = true;
             }
-            else
+
+            if (unlikely(max_range_null_map && (*max_range_null_map)[key_index]))
+            {
+                upper_bound = std::numeric_limits<RangeStorageType>::max();
+                invalid_range = true;
+            }
+
+            if (unlikely(!configuration.convert_null_range_bound_to_open && invalid_range))
             {
-                lower_bound = getColumnIntValueOrDefault(min_range_column, key_index, is_date, RANGE_MIN_NULL_VALUE);
-                upper_bound = getColumnIntValueOrDefault(max_range_column, key_index, is_date, RANGE_MAX_NULL_VALUE);
+                keys_extractor.rollbackCurrentKey();
+                continue;
             }
 
             if constexpr (std::is_same_v<KeyType, StringRef>)
                 key = copyStringInArena(string_arena, key);
 
-            if (likely(lower_bound <= upper_bound))
-                setAttributeValue(attribute, key, RangeInterval{lower_bound, upper_bound}, attribute_column[key_index]);
+            for (size_t attribute_index = 0; attribute_index < attributes.size(); ++attribute_index)
+            {
+                const auto & attribute_column = *block.getByPosition(attribute_index + block_attributes_skip_offset).column;
+                auto & attribute = attributes[attribute_index];
+                attribute_column.get(key_index, column_value);
+
+                setAttributeValue(attribute, column_value);
+            }
+
+            auto interval = Interval<RangeStorageType>(lower_bound, upper_bound);
+            auto it = key_attribute_container.find(key);
+
+            bool emplaced_in_interval_tree = false;
+
+            if (it)
+            {
+                auto & intervals = it->getMapped();
+                emplaced_in_interval_tree = intervals.emplace(interval, element_count);
+            }
+            else
+            {
+                IntervalMap<RangeStorageType> intervals;
+                emplaced_in_interval_tree = intervals.emplace(interval, element_count);
+                key_attribute_container.insert({key, std::move(intervals)});
+            }
 
+            if (unlikely(!emplaced_in_interval_tree))
+            {
+                InvalidIntervalWithKey<RangeStorageType> invalid_interval{key, interval, element_count};
+                invalid_intervals_container.emplace_back(invalid_interval);
+            }
+
+            ++element_count;
             keys_extractor.rollbackCurrentKey();
         }
-
-        keys_extractor.reset();
-    }
+    });
 }
 
 template <DictionaryKeyType dictionary_key_type>
-void RangeHashedDictionary<dictionary_key_type>::buildAttributeIntervalTrees()
+void RangeHashedDictionary<dictionary_key_type>::setAttributeValue(Attribute & attribute, const Field & value)
 {
-    for (auto & attribute : attributes)
+    auto type_call = [&](const auto & dictionary_attribute_type)
     {
-        auto type_call = [&](const auto & dictionary_attribute_type)
+        using Type = std::decay_t<decltype(dictionary_attribute_type)>;
+        using AttributeType = typename Type::AttributeType;
+        using ValueType = DictionaryValueType<AttributeType>;
+
+        auto & container = std::get<AttributeContainerType<ValueType>>(attribute.container);
+        container.emplace_back();
+
+        if (unlikely(attribute.is_value_nullable.has_value()))
         {
-            using Type = std::decay_t<decltype(dictionary_attribute_type)>;
-            using AttributeType = typename Type::AttributeType;
-            using ValueType = DictionaryValueType<AttributeType>;
+            bool value_is_null = value.isNull();
+            attribute.is_value_nullable->emplace_back(value_is_null);
 
-            auto & collection = std::get<CollectionType<ValueType>>(attribute.maps);
-            for (auto & [_, ranges] : collection)
-                ranges.build();
-        };
+            if (unlikely(value_is_null))
+                return;
+        }
 
-        callOnDictionaryAttributeType(attribute.type, type_call);
-    }
+        ValueType value_to_insert;
+
+        if constexpr (std::is_same_v<AttributeType, String>)
+        {
+            const auto & string = value.get<String>();
+            StringRef string_ref = copyStringInArena(string_arena, string);
+            value_to_insert = string_ref;
+        }
+        else
+        {
+            value_to_insert = value.get<ValueType>();
+        }
+
+        container.back() = value_to_insert;
+    };
+
+    callOnDictionaryAttributeType(attribute.type, type_call);
 }
 
 template <DictionaryKeyType dictionary_key_type>
-template <typename T>
-void RangeHashedDictionary<dictionary_key_type>::setAttributeValueImpl(Attribute & attribute, KeyType key, const RangeInterval & interval, const Field & value)
+Pipe RangeHashedDictionary<dictionary_key_type>::read(const Names & column_names, size_t max_block_size, size_t num_streams) const
 {
-    using ValueType = std::conditional_t<std::is_same_v<T, String>, StringRef, T>;
-    auto & collection = std::get<CollectionType<ValueType>>(attribute.maps);
+    auto key_to_index_column = ColumnUInt64::create();
+    auto range_min_column = dict_struct.range_min->type->createColumn();
+    auto range_max_column = dict_struct.range_max->type->createColumn();
 
-    std::optional<ValueType> value_to_insert;
+    PaddedPODArray<KeyType> keys;
 
-    if (attribute.is_nullable && value.isNull())
-    {
-        value_to_insert = std::nullopt;
-    }
-    else
+    callOnRangeType(dict_struct.range_min->type, [&](const auto & types)
     {
-        if constexpr (std::is_same_v<T, String>)
+        using Types = std::decay_t<decltype(types)>;
+        using RangeColumnType = typename Types::LeftType;
+        using RangeStorageType = typename RangeColumnType::ValueType;
+
+        auto * range_min_column_typed = typeid_cast<RangeColumnType *>(range_min_column.get());
+        if (!range_min_column_typed)
+            throw Exception(ErrorCodes::TYPE_MISMATCH,
+                "Dictionary {} range min column type should be equal to {}",
+                getFullName(),
+                dict_struct.range_min->type->getName());
+
+        auto * range_max_column_typed = typeid_cast<RangeColumnType *>(range_max_column.get());
+        if (!range_max_column_typed)
+            throw Exception(ErrorCodes::TYPE_MISMATCH,
+                "Dictionary {} range max column type should be equal to {}",
+                getFullName(),
+                dict_struct.range_max->type->getName());
+
+        auto & key_to_index_column_data = key_to_index_column->getData();
+        auto & range_min_column_data = range_min_column_typed->getData();
+        auto & range_max_column_data = range_max_column_typed->getData();
+
+        const auto & container = std::get<KeyAttributeContainerType<RangeStorageType>>(key_attribute.container);
+        const auto & invalid_intervals_container = std::get<InvalidIntervalsContainerType<RangeStorageType>>(key_attribute.invalid_intervals_container);
+
+        keys.reserve(element_count);
+        key_to_index_column_data.reserve(element_count);
+        range_min_column_data.reserve(element_count);
+        range_max_column_data.reserve(element_count);
+
+        for (const auto & key : container)
         {
-            const auto & string = value.get<String>();
-            StringRef string_ref = copyStringInArena(string_arena, string);
-            value_to_insert = { string_ref };
+            for (const auto & [interval, index] : key.getMapped())
+            {
+                keys.emplace_back(key.getKey());
+                key_to_index_column_data.emplace_back(index);
+                range_min_column_data.push_back(interval.left);
+                range_max_column_data.push_back(interval.right);
+            }
         }
-        else
+
+        for (const auto & invalid_interval_with_key : invalid_intervals_container)
         {
-            value_to_insert = { value.get<ValueType>() };
+            keys.emplace_back(invalid_interval_with_key.key);
+            key_to_index_column_data.emplace_back(invalid_interval_with_key.attribute_value_index);
+            range_min_column_data.push_back(invalid_interval_with_key.interval.left);
+            range_max_column_data.push_back(invalid_interval_with_key.interval.right);
         }
-    }
+    });
 
-    const auto it = collection.find(key);
+    auto range_min_column_with_type = ColumnWithTypeAndName{std::move(range_min_column), dict_struct.range_min->type, dict_struct.range_min->name};
+    auto range_max_column_with_type = ColumnWithTypeAndName{std::move(range_max_column), dict_struct.range_max->type, dict_struct.range_max->name};
 
-    if (it)
+    ColumnsWithTypeAndName key_columns;
+    if constexpr (dictionary_key_type == DictionaryKeyType::Simple)
     {
-        auto & values = it->getMapped();
-        values.emplace(interval, std::move(value_to_insert));
+        auto keys_column = getColumnFromPODArray(std::move(keys));
+        key_columns = {ColumnWithTypeAndName(std::move(keys_column), std::make_shared<DataTypeUInt64>(), dict_struct.id->name)};
     }
     else
     {
-        Values<ValueType> values;
-        values.emplace(interval, value_to_insert);
-        collection.insert({key, std::move(values)});
+        key_columns = deserializeColumnsWithTypeAndNameFromKeys(dict_struct, keys, 0, keys.size());
     }
-}
-
-template <DictionaryKeyType dictionary_key_type>
-void RangeHashedDictionary<dictionary_key_type>::setAttributeValue(Attribute & attribute, KeyType key, const RangeInterval & interval, const Field & value)
-{
-    auto type_call = [&](const auto &dictionary_attribute_type)
-    {
-        using Type = std::decay_t<decltype(dictionary_attribute_type)>;
-        using AttributeType = typename Type::AttributeType;
 
-        setAttributeValueImpl<AttributeType>(attribute, key, interval, value);
-    };
+    key_columns.emplace_back(ColumnWithTypeAndName{std::move(key_to_index_column), std::make_shared<DataTypeUInt64>(), ""});
 
-    callOnDictionaryAttributeType(attribute.type, type_call);
-}
+    ColumnsWithTypeAndName data_columns = {std::move(range_min_column_with_type), std::move(range_max_column_with_type)};
 
-template <DictionaryKeyType dictionary_key_type>
-template <typename RangeType>
-void RangeHashedDictionary<dictionary_key_type>::getKeysAndDates(
-    PaddedPODArray<KeyType> & keys,
-    PaddedPODArray<RangeType> & start_dates,
-    PaddedPODArray<RangeType> & end_dates) const
-{
-    const auto & attribute = attributes.front();
+    std::shared_ptr<const IDictionary> dictionary = shared_from_this();
 
-    auto type_call = [&](const auto & dictionary_attribute_type)
+    DictionarySourceCoordinator::ReadColumnsFunc read_keys_func = [dictionary_copy = dictionary](
+        const Strings & attribute_names,
+        const DataTypes & result_types,
+        const Columns & key_columns,
+        const DataTypes,
+        const Columns &)
     {
-        using Type = std::decay_t<decltype(dictionary_attribute_type)>;
-        using AttributeType = typename Type::AttributeType;
-        using ValueType = DictionaryValueType<AttributeType>;
+        auto range_dictionary_ptr = std::static_pointer_cast<const RangeHashedDictionary<dictionary_key_type>>(dictionary_copy);
 
-        getKeysAndDates<ValueType>(attribute, keys, start_dates, end_dates);
-    };
+        size_t attribute_names_size = attribute_names.size();
 
-    callOnDictionaryAttributeType(attribute.type, type_call);
-}
+        Columns result;
+        result.reserve(attribute_names_size);
 
-template <DictionaryKeyType dictionary_key_type>
-template <typename T, typename RangeType>
-void RangeHashedDictionary<dictionary_key_type>::getKeysAndDates(
-    const Attribute & attribute,
-    PaddedPODArray<KeyType> & keys,
-    PaddedPODArray<RangeType> & start_dates,
-    PaddedPODArray<RangeType> & end_dates) const
-{
-    const auto & collection = std::get<CollectionType<T>>(attribute.maps);
+        auto key_column = key_columns.back();
 
-    keys.reserve(collection.size());
-    start_dates.reserve(collection.size());
-    end_dates.reserve(collection.size());
+        const auto * key_to_index_column = typeid_cast<const ColumnUInt64 *>(key_column.get());
+        if (!key_to_index_column)
+            throw Exception(ErrorCodes::LOGICAL_ERROR,
+                "Dictionary {} read expect indexes column with type UInt64",
+                range_dictionary_ptr->getFullName());
 
-    const bool is_date = isDate(dict_struct.range_min->type);
-    (void)(is_date);
+        const auto & data = key_to_index_column->getData();
 
-    for (const auto & key : collection)
-    {
-        for (const auto & [interval, _] : key.getMapped())
+        for (size_t i = 0; i < attribute_names_size; ++i)
         {
-            keys.push_back(key.getKey());
-            start_dates.push_back(interval.left);
-            end_dates.push_back(interval.right);
+            const auto & attribute_name = attribute_names[i];
+            const auto & result_type = result_types[i];
 
-            if constexpr (std::numeric_limits<RangeType>::max() > DATE_LUT_MAX_DAY_NUM) /// Avoid warning about tautological comparison in next line.
-                if (is_date && static_cast<UInt64>(end_dates.back()) > DATE_LUT_MAX_DAY_NUM)
-                    end_dates.back() = 0;
+            result.emplace_back(range_dictionary_ptr->getColumnInternal(attribute_name, result_type, data));
         }
-    }
-}
 
-template <DictionaryKeyType dictionary_key_type>
-template <typename RangeType>
-PaddedPODArray<Int64> RangeHashedDictionary<dictionary_key_type>::makeDateKeys(
-    const PaddedPODArray<RangeType> & block_start_dates,
-    const PaddedPODArray<RangeType> & block_end_dates) const
-{
-    PaddedPODArray<Int64> keys(block_start_dates.size());
+        return result;
+    };
 
-    for (size_t i = 0; i < keys.size(); ++i)
-    {
-        if (isCorrectDate(block_start_dates[i]))
-            keys[i] = block_start_dates[i]; // NOLINT
-        else
-            keys[i] = block_end_dates[i]; // NOLINT
-    }
+    auto coordinator = DictionarySourceCoordinator::create(
+        dictionary,
+        column_names,
+        std::move(key_columns),
+        std::move(data_columns),
+        max_block_size,
+        std::move(read_keys_func));
+    auto result = coordinator->read(num_streams);
 
-    return keys;
+    return result;
 }
 
 template <DictionaryKeyType dictionary_key_type>
-Pipe RangeHashedDictionary<dictionary_key_type>::read(const Names & column_names, size_t max_block_size, size_t num_streams) const
+static DictionaryPtr createRangeHashedDictionary(const std::string & full_name,
+                            const DictionaryStructure & dict_struct,
+                            const Poco::Util::AbstractConfiguration & config,
+                            const std::string & config_prefix,
+                            DictionarySourcePtr source_ptr)
 {
-    auto type = dict_struct.range_min->type;
-
-    ColumnsWithTypeAndName key_columns;
-    ColumnWithTypeAndName range_min_column;
-    ColumnWithTypeAndName range_max_column;
+    static constexpr auto layout_name = dictionary_key_type == DictionaryKeyType::Simple ? "range_hashed" : "complex_key_range_hashed";
 
-    auto type_call = [&](const auto & types) mutable -> bool
+    if constexpr (dictionary_key_type == DictionaryKeyType::Simple)
     {
-        using Types = std::decay_t<decltype(types)>;
-        using LeftDataType = typename Types::LeftType;
-
-        if constexpr (IsDataTypeNumber<LeftDataType> ||
-            std::is_same_v<LeftDataType, DataTypeDate> ||
-            std::is_same_v<LeftDataType, DataTypeDate32> ||
-            std::is_same_v<LeftDataType, DataTypeDateTime>)
-        {
-            using RangeType = typename LeftDataType::FieldType;
-
-            PaddedPODArray<KeyType> keys;
-            PaddedPODArray<RangeType> range_start;
-            PaddedPODArray<RangeType> range_end;
-            getKeysAndDates(keys, range_start, range_end);
-
-            auto date_column = getColumnFromPODArray(makeDateKeys(range_start, range_end));
+        if (dict_struct.key)
+            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, "'key' is not supported for dictionary of layout 'range_hashed'");
+    }
+    else
+    {
+        if (dict_struct.id)
+            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, "'id' is not supported for dictionary of layout 'complex_key_range_hashed'");
+    }
 
-            auto range_start_column = getColumnFromPODArray(std::move(range_start));
-            range_min_column = ColumnWithTypeAndName{std::move(range_start_column), dict_struct.range_min->type, dict_struct.range_min->name};
+    if (!dict_struct.range_min || !dict_struct.range_max)
+        throw Exception(
+            ErrorCodes::BAD_ARGUMENTS,
+            "{}: dictionary of layout '{}' requires .structure.range_min and .structure.range_max",
+            full_name,
+            layout_name);
 
-            auto range_end_column = getColumnFromPODArray(std::move(range_end));
-            range_max_column = ColumnWithTypeAndName{std::move(range_end_column), dict_struct.range_max->type, dict_struct.range_max->name};
+    const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);
+    const DictionaryLifetime dict_lifetime{config, config_prefix + ".lifetime"};
+    const bool require_nonempty = config.getBool(config_prefix + ".require_nonempty", false);
 
-            if constexpr (dictionary_key_type == DictionaryKeyType::Simple)
-            {
-                auto keys_column = getColumnFromPODArray(std::move(keys));
-                key_columns = {ColumnWithTypeAndName(std::move(keys_column), std::make_shared<DataTypeUInt64>(), dict_struct.id->name)};
-            }
-            else
-            {
-                key_columns = deserializeColumnsWithTypeAndNameFromKeys(dict_struct, keys, 0, keys.size());
-            }
+    String dictionary_layout_prefix = config_prefix + ".layout." + layout_name;
+    const bool convert_null_range_bound_to_open = config.getBool(dictionary_layout_prefix + ".convert_null_range_bound_to_open", true);
+    String range_lookup_strategy = config.getString(dictionary_layout_prefix + ".range_lookup_strategy", "min");
+    RangeHashedDictionaryLookupStrategy lookup_strategy = RangeHashedDictionaryLookupStrategy::min;
 
-            key_columns.emplace_back(ColumnWithTypeAndName{std::move(date_column), std::make_shared<DataTypeInt64>(), ""});
+    if (range_lookup_strategy == "min")
+        lookup_strategy = RangeHashedDictionaryLookupStrategy::min;
+    else if (range_lookup_strategy == "max")
+        lookup_strategy = RangeHashedDictionaryLookupStrategy::max;
 
-            return true;
-        }
-        else
-        {
-            return false;
-        }
+    RangeHashedDictionaryConfiguration configuration
+    {
+        .convert_null_range_bound_to_open = convert_null_range_bound_to_open,
+        .lookup_strategy = lookup_strategy,
+        .require_nonempty = require_nonempty
     };
 
-    if (!callOnIndexAndDataType<void>(type->getTypeId(), type_call))
-        throw Exception(ErrorCodes::LOGICAL_ERROR, "RangeHashedDictionary min max range type should be numeric");
-
-    ColumnsWithTypeAndName data_columns = {std::move(range_min_column), std::move(range_max_column)};
-
-    std::shared_ptr<const IDictionary> dictionary = shared_from_this();
-    auto coordinator = DictionarySourceCoordinator::create(dictionary, column_names, std::move(key_columns), std::move(data_columns), max_block_size);
-    auto result = coordinator->read(num_streams);
+    DictionaryPtr result = std::make_unique<RangeHashedDictionary<dictionary_key_type>>(
+        dict_id,
+        dict_struct,
+        std::move(source_ptr),
+        dict_lifetime,
+        configuration);
 
     return result;
 }
 
-
 void registerDictionaryRangeHashed(DictionaryFactory & factory)
 {
     auto create_layout_simple = [=](const std::string & full_name,
@@ -772,22 +1083,9 @@ void registerDictionaryRangeHashed(DictionaryFactory & factory)
                              ContextPtr /* global_context */,
                              bool /*created_from_ddl*/) -> DictionaryPtr
     {
-        if (dict_struct.key)
-            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, "'key' is not supported for dictionary of layout 'range_hashed'");
-
-        if (!dict_struct.range_min || !dict_struct.range_max)
-            throw Exception(ErrorCodes::BAD_ARGUMENTS,
-                "{}: dictionary of layout 'range_hashed' requires .structure.range_min and .structure.range_max",
-                full_name);
-
-        if (dict_struct.attributes.empty())
-            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, "Empty attributes are not supported for dictionary of layout 'range_hashed'");
-
-        const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);
-        const DictionaryLifetime dict_lifetime{config, config_prefix + ".lifetime"};
-        const bool require_nonempty = config.getBool(config_prefix + ".require_nonempty", false);
-        return std::make_unique<RangeHashedDictionary<DictionaryKeyType::Simple>>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty);
+        return createRangeHashedDictionary<DictionaryKeyType::Simple>(full_name, dict_struct, config, config_prefix, std::move(source_ptr));
     };
+
     factory.registerLayout("range_hashed", create_layout_simple, false);
 
     auto create_layout_complex = [=](const std::string & full_name,
@@ -798,22 +1096,9 @@ void registerDictionaryRangeHashed(DictionaryFactory & factory)
                              ContextPtr /* context */,
                              bool /*created_from_ddl*/) -> DictionaryPtr
     {
-        if (dict_struct.id)
-            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, "'id' is not supported for dictionary of layout 'complex_key_range_hashed'");
-
-        if (!dict_struct.range_min || !dict_struct.range_max)
-            throw Exception(ErrorCodes::BAD_ARGUMENTS,
-                "{}: dictionary of layout 'complex_key_range_hashed' requires .structure.range_min and .structure.range_max",
-                full_name);
-
-        if (dict_struct.attributes.empty())
-            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, "Empty attributes are not supported for dictionary of layout 'complex_key_range_hashed'");
-
-        const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);
-        const DictionaryLifetime dict_lifetime{config, config_prefix + ".lifetime"};
-        const bool require_nonempty = config.getBool(config_prefix + ".require_nonempty", false);
-        return std::make_unique<RangeHashedDictionary<DictionaryKeyType::Complex>>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty);
+        return createRangeHashedDictionary<DictionaryKeyType::Complex>(full_name, dict_struct, config, config_prefix, std::move(source_ptr));
     };
+
     factory.registerLayout("complex_key_range_hashed", create_layout_complex, true);
 }
 
diff --git a/src/Dictionaries/RangeHashedDictionary.h b/src/Dictionaries/RangeHashedDictionary.h
index 91c714d27e68..78d62e9d7de3 100644
--- a/src/Dictionaries/RangeHashedDictionary.h
+++ b/src/Dictionaries/RangeHashedDictionary.h
@@ -19,7 +19,18 @@
 namespace DB
 {
 
-using RangeStorageType = Int64;
+enum class RangeHashedDictionaryLookupStrategy : uint8_t
+{
+    min,
+    max
+};
+
+struct RangeHashedDictionaryConfiguration
+{
+    bool convert_null_range_bound_to_open;
+    RangeHashedDictionaryLookupStrategy lookup_strategy;
+    bool require_nonempty;
+};
 
 template <DictionaryKeyType dictionary_key_type>
 class RangeHashedDictionary final : public IDictionary
@@ -31,11 +42,17 @@ class RangeHashedDictionary final : public IDictionary
         const StorageID & dict_id_,
         const DictionaryStructure & dict_struct_,
         DictionarySourcePtr source_ptr_,
-        const DictionaryLifetime dict_lifetime_,
-        bool require_nonempty_,
+        DictionaryLifetime dict_lifetime_,
+        RangeHashedDictionaryConfiguration configuration_,
         BlockPtr update_field_loaded_block_ = nullptr);
 
-    std::string getTypeName() const override { return "RangeHashed"; }
+    std::string getTypeName() const override
+    {
+        if constexpr (dictionary_key_type == DictionaryKeyType::Simple)
+            return "RangeHashed";
+        else
+            return "ComplexKeyRangeHashed";
+    }
 
     size_t getBytesAllocated() const override { return bytes_allocated; }
 
@@ -57,7 +74,15 @@ class RangeHashedDictionary final : public IDictionary
 
     std::shared_ptr<const IExternalLoadable> clone() const override
     {
-        return std::make_shared<RangeHashedDictionary>(getDictionaryID(), dict_struct, source_ptr->clone(), dict_lifetime, require_nonempty, update_field_loaded_block);
+        auto result = std::make_shared<RangeHashedDictionary>(
+            getDictionaryID(),
+            dict_struct,
+            source_ptr->clone(),
+            dict_lifetime,
+            configuration,
+            update_field_loaded_block);
+
+        return result;
     }
 
     DictionarySourcePtr getSource() const override { return source_ptr; }
@@ -76,7 +101,7 @@ class RangeHashedDictionary final : public IDictionary
     DictionarySpecialKeyType getSpecialKeyType() const override { return DictionarySpecialKeyType::Range;}
 
     ColumnPtr getColumn(
-        const std::string& attribute_name,
+        const std::string & attribute_name,
         const DataTypePtr & result_type,
         const Columns & key_columns,
         const DataTypes & key_types,
@@ -88,52 +113,90 @@ class RangeHashedDictionary final : public IDictionary
 
 private:
 
-    using RangeInterval = Interval<RangeStorageType>;
-
-    template <typename T>
-    using Values = IntervalMap<RangeInterval, std::optional<T>>;
+    template <typename RangeStorageType>
+    using IntervalMap = IntervalMap<Interval<RangeStorageType>, size_t>;
 
-    template <typename Value>
-    using CollectionType = std::conditional_t<
+    template <typename RangeStorageType>
+    using KeyAttributeContainerType = std::conditional_t<
         dictionary_key_type == DictionaryKeyType::Simple,
-        HashMap<UInt64, Values<Value>, DefaultHash<UInt64>>,
-        HashMapWithSavedHash<StringRef, Values<Value>, DefaultHash<StringRef>>>;
+        HashMap<UInt64, IntervalMap<RangeStorageType>, DefaultHash<UInt64>>,
+        HashMapWithSavedHash<StringRef, IntervalMap<RangeStorageType>, DefaultHash<StringRef>>>;
 
-    using NoAttributesCollectionType = std::conditional_t<
-        dictionary_key_type == DictionaryKeyType::Simple,
-        HashMap<UInt64, IntervalSet<RangeInterval>>,
-        HashMapWithSavedHash<StringRef, IntervalSet<RangeInterval>>>;
+    template <typename Value>
+    using AttributeContainerType = std::conditional_t<std::is_same_v<Value, Array>, std::vector<Value>, PaddedPODArray<Value>>;
 
     struct Attribute final
     {
-    public:
         AttributeUnderlyingType type;
-        bool is_nullable;
 
         std::variant<
-            CollectionType<UInt8>,
-            CollectionType<UInt16>,
-            CollectionType<UInt32>,
-            CollectionType<UInt64>,
-            CollectionType<UInt128>,
-            CollectionType<UInt256>,
-            CollectionType<Int8>,
-            CollectionType<Int16>,
-            CollectionType<Int32>,
-            CollectionType<Int64>,
-            CollectionType<Int128>,
-            CollectionType<Int256>,
-            CollectionType<Decimal32>,
-            CollectionType<Decimal64>,
-            CollectionType<Decimal128>,
-            CollectionType<Decimal256>,
-            CollectionType<DateTime64>,
-            CollectionType<Float32>,
-            CollectionType<Float64>,
-            CollectionType<UUID>,
-            CollectionType<StringRef>,
-            CollectionType<Array>>
-            maps;
+            AttributeContainerType<UInt8>,
+            AttributeContainerType<UInt16>,
+            AttributeContainerType<UInt32>,
+            AttributeContainerType<UInt64>,
+            AttributeContainerType<UInt128>,
+            AttributeContainerType<UInt256>,
+            AttributeContainerType<Int8>,
+            AttributeContainerType<Int16>,
+            AttributeContainerType<Int32>,
+            AttributeContainerType<Int64>,
+            AttributeContainerType<Int128>,
+            AttributeContainerType<Int256>,
+            AttributeContainerType<Decimal32>,
+            AttributeContainerType<Decimal64>,
+            AttributeContainerType<Decimal128>,
+            AttributeContainerType<Decimal256>,
+            AttributeContainerType<DateTime64>,
+            AttributeContainerType<Float32>,
+            AttributeContainerType<Float64>,
+            AttributeContainerType<UUID>,
+            AttributeContainerType<StringRef>,
+            AttributeContainerType<Array>>
+            container;
+
+        std::optional<std::vector<bool>> is_value_nullable;
+    };
+
+    template <typename RangeStorageType>
+    struct InvalidIntervalWithKey
+    {
+        KeyType key;
+        Interval<RangeStorageType> interval;
+        size_t attribute_value_index;
+    };
+
+    template <typename RangeStorageType>
+    using InvalidIntervalsContainerType = PaddedPODArray<InvalidIntervalWithKey<RangeStorageType>>;
+
+    template <template<typename> typename ContainerType>
+    using RangeStorageTypeContainer = std::variant<
+        ContainerType<UInt8>,
+        ContainerType<UInt16>,
+        ContainerType<UInt32>,
+        ContainerType<UInt64>,
+        ContainerType<UInt128>,
+        ContainerType<UInt256>,
+        ContainerType<Int8>,
+        ContainerType<Int16>,
+        ContainerType<Int32>,
+        ContainerType<Int64>,
+        ContainerType<Int128>,
+        ContainerType<Int256>,
+        ContainerType<Decimal32>,
+        ContainerType<Decimal64>,
+        ContainerType<Decimal128>,
+        ContainerType<Decimal256>,
+        ContainerType<DateTime64>,
+        ContainerType<Float32>,
+        ContainerType<Float64>,
+        ContainerType<UUID>>;
+
+    struct KeyAttribute final
+    {
+        RangeStorageTypeContainer<KeyAttributeContainerType> container;
+
+        RangeStorageTypeContainer<InvalidIntervalsContainerType> invalid_intervals_container;
+
     };
 
     void createAttributes();
@@ -151,43 +214,31 @@ class RangeHashedDictionary final : public IDictionary
         ValueSetter && set_value,
         DefaultValueExtractor & default_value_extractor) const;
 
-    void updateData();
-
-    void blockToAttributes(const Block & block);
-
-    void buildAttributeIntervalTrees();
-
-    template <typename T>
-    void setAttributeValueImpl(Attribute & attribute, KeyType key, const RangeInterval & interval, const Field & value);
+    ColumnPtr getColumnInternal(
+        const std::string & attribute_name,
+        const DataTypePtr & result_type,
+        const PaddedPODArray<UInt64> & key_to_index) const;
 
-    void setAttributeValue(Attribute & attribute, KeyType key, const RangeInterval & interval, const Field & value);
+    template <typename AttributeType, bool is_nullable, typename ValueSetter>
+    void getItemsInternalImpl(
+        const Attribute & attribute,
+        const PaddedPODArray<UInt64> & key_to_index,
+        ValueSetter && set_value) const;
 
-    template <typename RangeType>
-    void getKeysAndDates(
-        PaddedPODArray<KeyType> & keys,
-        PaddedPODArray<RangeType> & start_dates,
-        PaddedPODArray<RangeType> & end_dates) const;
+    void updateData();
 
-    template <typename T, typename RangeType>
-    void getKeysAndDates(
-        const Attribute & attribute,
-        PaddedPODArray<KeyType> & keys,
-        PaddedPODArray<RangeType> & start_dates,
-        PaddedPODArray<RangeType> & end_dates) const;
+    void blockToAttributes(const Block & block);
 
-    template <typename RangeType>
-    PaddedPODArray<Int64> makeDateKeys(
-        const PaddedPODArray<RangeType> & block_start_dates,
-        const PaddedPODArray<RangeType> & block_end_dates) const;
+    void setAttributeValue(Attribute & attribute, const Field & value);
 
     const DictionaryStructure dict_struct;
     const DictionarySourcePtr source_ptr;
     const DictionaryLifetime dict_lifetime;
-    const bool require_nonempty;
+    const RangeHashedDictionaryConfiguration configuration;
     BlockPtr update_field_loaded_block;
 
     std::vector<Attribute> attributes;
-    Arena complex_key_arena;
+    KeyAttribute key_attribute;
 
     size_t bytes_allocated = 0;
     size_t element_count = 0;
@@ -195,7 +246,6 @@ class RangeHashedDictionary final : public IDictionary
     mutable std::atomic<size_t> query_count{0};
     mutable std::atomic<size_t> found_count{0};
     Arena string_arena;
-    NoAttributesCollectionType no_attributes_container;
 };
 
 }
