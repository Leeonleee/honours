{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 23310,
  "instance_id": "ClickHouse__ClickHouse-23310",
  "issue_numbers": [
    "23305"
  ],
  "base_commit": "b61a24634f0fea9443996db61e2552c1b3f7c845",
  "patch": "diff --git a/src/Storages/MergeTree/KeyCondition.cpp b/src/Storages/MergeTree/KeyCondition.cpp\nindex e4c9f0ae0cca..5cc095799029 100644\n--- a/src/Storages/MergeTree/KeyCondition.cpp\n+++ b/src/Storages/MergeTree/KeyCondition.cpp\n@@ -596,18 +596,6 @@ bool KeyCondition::canConstantBeWrappedByMonotonicFunctions(\n     Field & out_value,\n     DataTypePtr & out_type)\n {\n-    /// We don't look for inversed key transformations when strict is true, which is required for trivial count().\n-    /// Consider the following test case:\n-    ///\n-    /// create table test1(p DateTime, k int) engine MergeTree partition by toDate(p) order by k;\n-    /// insert into test1 values ('2020-09-01 00:01:02', 1), ('2020-09-01 20:01:03', 2), ('2020-09-02 00:01:03', 3);\n-    /// select count() from test1 where p > toDateTime('2020-09-01 10:00:00');\n-    ///\n-    /// toDate(DateTime) is always monotonic, but we cannot relaxing the predicates to be\n-    /// >= toDate(toDateTime('2020-09-01 10:00:00')), which returns 3 instead of the right count: 2.\n-    if (strict)\n-        return false;\n-\n     // Constant expr should use alias names if any\n     String expr_name = node->getColumnName();\n     const auto & sample_block = key_expr->getSampleBlock();\n@@ -621,8 +609,8 @@ bool KeyCondition::canConstantBeWrappedByMonotonicFunctions(\n     bool found_transformation = false;\n     auto input_column = sample_block.getByName(expr_name);\n     auto const_column = out_type->createColumnConst(1, out_value);\n-    out_value = (*castColumn({const_column, out_type, \"c\"}, input_column.type))[0];\n-    out_type = input_column.type;\n+    auto const_value = (*castColumn({const_column, out_type, \"c\"}, input_column.type))[0];\n+    auto const_type = input_column.type;\n     for (const auto & action : key_expr->getActions())\n     {\n         /** The key functional expression constraint may be inferred from a plain column in the expression.\n@@ -644,14 +632,14 @@ bool KeyCondition::canConstantBeWrappedByMonotonicFunctions(\n                 return false;\n \n             /// Range is irrelevant in this case.\n-            IFunction::Monotonicity monotonicity = action.node->function_base->getMonotonicityForRange(*out_type, Field(), Field());\n+            IFunction::Monotonicity monotonicity = action.node->function_base->getMonotonicityForRange(*const_type, Field(), Field());\n             if (!monotonicity.is_always_monotonic)\n                 return false;\n \n             /// Apply the next transformation step.\n-            std::tie(out_value, out_type) = applyFunctionForFieldOfUnknownType(\n+            std::tie(const_value, const_type) = applyFunctionForFieldOfUnknownType(\n                 action.node->function_builder,\n-                out_type, out_value);\n+                const_type, const_value);\n \n             expr_name = action.node->result_name;\n \n@@ -661,6 +649,8 @@ bool KeyCondition::canConstantBeWrappedByMonotonicFunctions(\n             {\n                 out_key_column_num = it->second;\n                 out_key_column_type = sample_block.getByName(it->first).type;\n+                out_value = const_value;\n+                out_type = const_type;\n                 found_transformation = true;\n                 break;\n             }\n@@ -674,9 +664,6 @@ bool KeyCondition::canConstantBeWrappedByMonotonicFunctions(\n bool KeyCondition::canConstantBeWrappedByFunctions(\n     const ASTPtr & ast, size_t & out_key_column_num, DataTypePtr & out_key_column_type, Field & out_value, DataTypePtr & out_type)\n {\n-    if (strict)\n-        return false;\n-\n     // Constant expr should use alias names if any\n     String expr_name = ast->getColumnName();\n     const auto & sample_block = key_expr->getSampleBlock();\n@@ -734,12 +721,10 @@ bool KeyCondition::canConstantBeWrappedByFunctions(\n \n             if (is_valid_chain)\n             {\n-                {\n-                    auto input_column = sample_block.getByName(expr_name);\n-                    auto const_column = out_type->createColumnConst(1, out_value);\n-                    out_value = (*castColumn({const_column, out_type, \"c\"}, input_column.type))[0];\n-                    out_type = input_column.type;\n-                }\n+                auto input_column = sample_block.getByName(expr_name);\n+                auto const_column = out_type->createColumnConst(1, out_value);\n+                auto const_value = (*castColumn({const_column, out_type, \"c\"}, input_column.type))[0];\n+                auto const_type = input_column.type;\n \n                 while (!chain.empty())\n                 {\n@@ -751,7 +736,7 @@ bool KeyCondition::canConstantBeWrappedByFunctions(\n \n                     if (func->children.size() == 1)\n                     {\n-                        std::tie(out_value, out_type) = applyFunctionForFieldOfUnknownType(func->function_builder, out_type, out_value);\n+                        std::tie(const_value, const_type) = applyFunctionForFieldOfUnknownType(func->function_builder, const_type, const_value);\n                     }\n                     else if (func->children.size() == 2)\n                     {\n@@ -761,21 +746,23 @@ bool KeyCondition::canConstantBeWrappedByFunctions(\n                         {\n                             auto left_arg_type = left->result_type;\n                             auto left_arg_value = (*left->column)[0];\n-                            std::tie(out_value, out_type) = applyBinaryFunctionForFieldOfUnknownType(\n-                                    func->function_builder, left_arg_type, left_arg_value, out_type, out_value);\n+                            std::tie(const_value, const_type) = applyBinaryFunctionForFieldOfUnknownType(\n+                                    func->function_builder, left_arg_type, left_arg_value, const_type, const_value);\n                         }\n                         else\n                         {\n                             auto right_arg_type = right->result_type;\n                             auto right_arg_value = (*right->column)[0];\n-                            std::tie(out_value, out_type) = applyBinaryFunctionForFieldOfUnknownType(\n-                                    func->function_builder, out_type, out_value, right_arg_type, right_arg_value);\n+                            std::tie(const_value, const_type) = applyBinaryFunctionForFieldOfUnknownType(\n+                                    func->function_builder, const_type, const_value, right_arg_type, right_arg_value);\n                         }\n                     }\n                 }\n \n                 out_key_column_num = it->second;\n                 out_key_column_type = sample_block.getByName(it->first).type;\n+                out_value = const_value;\n+                out_type = const_type;\n                 return true;\n             }\n         }\n@@ -1109,6 +1096,23 @@ bool KeyCondition::tryParseAtomFromAST(const ASTPtr & node, ContextPtr context,\n             bool is_set_const = false;\n             bool is_constant_transformed = false;\n \n+            /// We don't look for inversed key transformations when strict is true, which is required for trivial count().\n+            /// Consider the following test case:\n+            ///\n+            /// create table test1(p DateTime, k int) engine MergeTree partition by toDate(p) order by k;\n+            /// insert into test1 values ('2020-09-01 00:01:02', 1), ('2020-09-01 20:01:03', 2), ('2020-09-02 00:01:03', 3);\n+            /// select count() from test1 where p > toDateTime('2020-09-01 10:00:00');\n+            ///\n+            /// toDate(DateTime) is always monotonic, but we cannot relax the predicates to be\n+            /// >= toDate(toDateTime('2020-09-01 10:00:00')), which returns 3 instead of the right count: 2.\n+            bool strict_condition = strict;\n+\n+            /// If we use this key condition to prune partitions by single value, we cannot relax conditions for NOT.\n+            if (single_point\n+                && (func_name == \"notLike\" || func_name == \"notIn\" || func_name == \"globalNotIn\" || func_name == \"notEquals\"\n+                    || func_name == \"notEmpty\"))\n+                strict_condition = true;\n+\n             if (functionIsInOrGlobalInOperator(func_name))\n             {\n                 if (tryPrepareSetIndex(args, context, out, key_column_num))\n@@ -1125,13 +1129,15 @@ bool KeyCondition::tryParseAtomFromAST(const ASTPtr & node, ContextPtr context,\n                 {\n                     key_arg_pos = 0;\n                 }\n-                else if (canConstantBeWrappedByMonotonicFunctions(args[0], key_column_num, key_expr_type, const_value, const_type))\n+                else if (\n+                    !strict_condition\n+                    && canConstantBeWrappedByMonotonicFunctions(args[0], key_column_num, key_expr_type, const_value, const_type))\n                 {\n                     key_arg_pos = 0;\n                     is_constant_transformed = true;\n                 }\n                 else if (\n-                    single_point && func_name == \"equals\"\n+                    single_point && func_name == \"equals\" && !strict_condition\n                     && canConstantBeWrappedByFunctions(args[0], key_column_num, key_expr_type, const_value, const_type))\n                 {\n                     key_arg_pos = 0;\n@@ -1146,13 +1152,15 @@ bool KeyCondition::tryParseAtomFromAST(const ASTPtr & node, ContextPtr context,\n                 {\n                     key_arg_pos = 1;\n                 }\n-                else if (canConstantBeWrappedByMonotonicFunctions(args[1], key_column_num, key_expr_type, const_value, const_type))\n+                else if (\n+                    !strict_condition\n+                    && canConstantBeWrappedByMonotonicFunctions(args[1], key_column_num, key_expr_type, const_value, const_type))\n                 {\n                     key_arg_pos = 1;\n                     is_constant_transformed = true;\n                 }\n                 else if (\n-                    single_point && func_name == \"equals\"\n+                    single_point && func_name == \"equals\" && !strict_condition\n                     && canConstantBeWrappedByFunctions(args[1], key_column_num, key_expr_type, const_value, const_type))\n                 {\n                     key_arg_pos = 0;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01540_verbatim_partition_pruning.reference b/tests/queries/0_stateless/01540_verbatim_partition_pruning.reference\nindex b9338e6a9c41..3310ffe7de47 100644\n--- a/tests/queries/0_stateless/01540_verbatim_partition_pruning.reference\n+++ b/tests/queries/0_stateless/01540_verbatim_partition_pruning.reference\n@@ -2,3 +2,5 @@\n 9\t5\n 8\t4\n 1\t2\t3\n+2020-01-02\t1\t\n+2021-01-02\t2\t\ndiff --git a/tests/queries/0_stateless/01540_verbatim_partition_pruning.sql b/tests/queries/0_stateless/01540_verbatim_partition_pruning.sql\nindex 16ab51d11607..2d227856be42 100644\n--- a/tests/queries/0_stateless/01540_verbatim_partition_pruning.sql\n+++ b/tests/queries/0_stateless/01540_verbatim_partition_pruning.sql\n@@ -28,3 +28,22 @@ create table xyz(x int, y int, z int) engine MergeTree partition by if(toUInt8(x\n insert into xyz values (1, 2, 3);\n select * from xyz where y = 2;\n drop table if exists xyz;\n+\n+-- Test if we obey strict rules when facing NOT contitions\n+drop table if exists test;\n+create table test(d Date, k Int64, s String) Engine=MergeTree partition by (toYYYYMM(d),k) order by (d, k);\n+\n+insert into test values ('2020-01-01', 1, '');\n+insert into test values ('2020-01-02', 1, '');\n+\n+select * from test where d != '2020-01-01';\n+drop table test;\n+\n+-- Test if single value partition pruning works correctly for Date = String\n+drop table if exists myTable;\n+CREATE TABLE myTable (myDay Date, myOrder Int32, someData String) ENGINE = ReplacingMergeTree PARTITION BY floor(toYYYYMMDD(myDay), -1) ORDER BY (myOrder);\n+INSERT INTO myTable (myDay, myOrder) VALUES ('2021-01-01', 1);\n+INSERT INTO myTable (myDay, myOrder) VALUES ('2021-01-02', 2); // This row should be returned\n+INSERT INTO myTable (myDay, myOrder) VALUES ('2021-01-03', 3);\n+SELECT * FROM myTable mt WHERE myDay = '2021-01-02';\n+drop table myTable;\n",
  "problem_statement": "Partition pruning toYYYYMM partition key. Wrong query result with !=\n21.5.1\r\n```sql\r\n\r\ncreate table test(d Date, k Int64, s String) \r\nEngine=MergeTree partition by (toYYYYMM(d),k) order by (d, k)\r\n\r\ninsert into test values ('2020-01-01', 1, '');\r\ninsert into test values ('2020-01-02', 1, '');\r\n\r\nSELECT * FROM test WHERE d != '2020-01-01'\r\n0 rows in set. Elapsed: 0.003 sec.\r\n\r\n\r\nSELECT * FROM test WHERE identity(d) !=  '2020-01-01';\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500d\u2500\u252c\u2500k\u2500\u252c\u2500s\u2500\u2510\r\n\u2502 2020-01-02 \u2502 1 \u2502   \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\r\n\r\nSELECT * FROM test WHERE toDate(d) != '2020-01-01';\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500d\u2500\u252c\u2500k\u2500\u252c\u2500s\u2500\u2510\r\n\u2502 2020-01-02 \u2502 1 \u2502   \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\r\n```\r\n\n",
  "hints_text": "@amosbird \nthe same with \r\n\r\n```\r\ncreate table test(d Date, k Int64, s String) \r\nEngine=MergeTree partition by toYYYYMM(d) order by tuple()\r\n```\n```\r\nSELECT * FROM test WHERE d != materialize(toDate('2020-01-01'))\u3000;\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500d\u2500\u252c\u2500k\u2500\u252c\u2500s\u2500\u2510\r\n\u2502 2020-01-02 \u2502 1 \u2502   \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\r\n```",
  "created_at": "2021-04-19T14:17:51Z"
}