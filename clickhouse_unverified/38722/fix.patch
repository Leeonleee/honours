diff --git a/src/AggregateFunctions/AggregateFunctionRankCorrelation.h b/src/AggregateFunctions/AggregateFunctionRankCorrelation.h
index a9bf8254f35d..670dd5948f7e 100644
--- a/src/AggregateFunctions/AggregateFunctionRankCorrelation.h
+++ b/src/AggregateFunctions/AggregateFunctionRankCorrelation.h
@@ -31,8 +31,8 @@ struct RankCorrelationData : public StatisticalSample<Float64, Float64>
         RanksArray ranks_y;
         std::tie(ranks_y, std::ignore) = computeRanksAndTieCorrection(this->y);
 
-        /// In our case sizes of both samples are equal.
-        const auto size = this->size_x;
+        /// Sizes can be non-equal due to skipped NaNs.
+        const auto size = std::min(this->size_x, this->size_y);
 
         /// Count d^2 sum
         Float64 answer = 0;
diff --git a/src/AggregateFunctions/StatCommon.h b/src/AggregateFunctions/StatCommon.h
index 29163b63f778..ff824ca11b89 100644
--- a/src/AggregateFunctions/StatCommon.h
+++ b/src/AggregateFunctions/StatCommon.h
@@ -31,8 +31,8 @@ std::pair<RanksArray, Float64> computeRanksAndTieCorrection(const Values & value
     /// Save initial positions, than sort indices according to the values.
     std::vector<size_t> indexes(size);
     std::iota(indexes.begin(), indexes.end(), 0);
-    ::sort(indexes.begin(), indexes.end(),
-                [&] (size_t lhs, size_t rhs) { return values[lhs] < values[rhs]; });
+    std::sort(indexes.begin(), indexes.end(),
+        [&] (size_t lhs, size_t rhs) { return values[lhs] < values[rhs]; });
 
     size_t left = 0;
     Float64 tie_numenator = 0;
@@ -74,12 +74,18 @@ struct StatisticalSample
 
     void addX(X value, Arena * arena)
     {
+        if (isNaN(value))
+            return;
+
         ++size_x;
         x.push_back(value, arena);
     }
 
     void addY(Y value, Arena * arena)
     {
+        if (isNaN(value))
+            return;
+
         ++size_y;
         y.push_back(value, arena);
     }
