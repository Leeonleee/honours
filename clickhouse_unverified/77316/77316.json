{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 77316,
  "instance_id": "ClickHouse__ClickHouse-77316",
  "issue_numbers": [
    "79672",
    "75647"
  ],
  "base_commit": "37b9a26669823154be1e92cdd92e68b3bd43756f",
  "patch": "diff --git a/src/Analyzer/IQueryTreeNode.h b/src/Analyzer/IQueryTreeNode.h\nindex 175879879257..f24cec87d999 100644\n--- a/src/Analyzer/IQueryTreeNode.h\n+++ b/src/Analyzer/IQueryTreeNode.h\n@@ -71,6 +71,21 @@ using QueryTreeNodesDeque = std::deque<QueryTreeNodePtr>;\n using QueryTreeNodeWeakPtr = std::weak_ptr<IQueryTreeNode>;\n using QueryTreeWeakNodes = std::vector<QueryTreeNodeWeakPtr>;\n \n+struct ConvertToASTOptions\n+{\n+    /// Add _CAST if constant literal type is different from column type\n+    bool add_cast_for_constants = true;\n+\n+    /// Identifiers are fully qualified (`database.table.column`), otherwise names are just column names (`column`)\n+    bool fully_qualified_identifiers = true;\n+\n+    /// Identifiers are qualified but database name is not added (`table.column`) if set to false.\n+    bool qualify_indentifiers_with_database = true;\n+\n+    /// Set CTE name in ASTSubquery field.\n+    bool set_subquery_cte_name = true;\n+};\n+\n class IQueryTreeNode : public TypePromotion<IQueryTreeNode>\n {\n public:\n@@ -197,20 +212,8 @@ class IQueryTreeNode : public TypePromotion<IQueryTreeNode>\n       */\n     String formatOriginalASTForErrorMessage() const;\n \n-    struct ConvertToASTOptions\n-    {\n-        /// Add _CAST if constant literal type is different from column type\n-        bool add_cast_for_constants = true;\n-\n-        /// Identifiers are fully qualified (`database.table.column`), otherwise names are just column names (`column`)\n-        bool fully_qualified_identifiers = true;\n-\n-        /// Identifiers are qualified but database name is not added (`table.column`) if set to false.\n-        bool qualify_indentifiers_with_database = true;\n-    };\n-\n     /// Convert query tree to AST\n-    ASTPtr toAST(const ConvertToASTOptions & options = { .add_cast_for_constants = true, .fully_qualified_identifiers = true, .qualify_indentifiers_with_database = true }) const;\n+    ASTPtr toAST(const ConvertToASTOptions & options = {}) const;\n \n     /// Convert query tree to AST and then format it for error message.\n     String formatConvertedASTForErrorMessage() const;\ndiff --git a/src/Analyzer/QueryNode.cpp b/src/Analyzer/QueryNode.cpp\nindex a5984e71140f..59bc60f73c0a 100644\n--- a/src/Analyzer/QueryNode.cpp\n+++ b/src/Analyzer/QueryNode.cpp\n@@ -552,7 +552,8 @@ ASTPtr QueryNode::toASTImpl(const ConvertToASTOptions & options) const\n     if (is_subquery)\n     {\n         auto subquery = std::make_shared<ASTSubquery>(std::move(result_select_query));\n-        subquery->cte_name = cte_name;\n+        if (options.set_subquery_cte_name)\n+            subquery->cte_name = cte_name;\n         return subquery;\n     }\n \ndiff --git a/src/Analyzer/UnionNode.cpp b/src/Analyzer/UnionNode.cpp\nindex 7f8662f2608d..34a4b2b69749 100644\n--- a/src/Analyzer/UnionNode.cpp\n+++ b/src/Analyzer/UnionNode.cpp\n@@ -232,7 +232,7 @@ ASTPtr UnionNode::toASTImpl(const ConvertToASTOptions & options) const\n     select_with_union_query->list_of_selects = select_with_union_query->children.back();\n \n     ASTPtr result_query = std::move(select_with_union_query);\n-    bool set_subquery_cte_name = true;\n+    bool set_subquery_cte_name = options.set_subquery_cte_name;\n \n     if (recursive_cte_table)\n     {\ndiff --git a/src/Analyzer/Utils.cpp b/src/Analyzer/Utils.cpp\nindex d2626e08653e..9e419d4a5cf0 100644\n--- a/src/Analyzer/Utils.cpp\n+++ b/src/Analyzer/Utils.cpp\n@@ -366,7 +366,10 @@ std::optional<bool> tryExtractConstantFromConditionNode(const QueryTreeNodePtr &\n     return predicate_value > 0;\n }\n \n-static ASTPtr convertIntoTableExpressionAST(const QueryTreeNodePtr & table_expression_node)\n+static ASTPtr convertIntoTableExpressionAST(\n+    const QueryTreeNodePtr & table_expression_node,\n+    const ConvertToASTOptions & convert_to_ast_options\n+)\n {\n     ASTPtr table_expression_node_ast;\n     auto node_type = table_expression_node->getNodeType();\n@@ -389,7 +392,7 @@ static ASTPtr convertIntoTableExpressionAST(const QueryTreeNodePtr & table_expre\n     }\n     else\n     {\n-        table_expression_node_ast = table_expression_node->toAST();\n+        table_expression_node_ast = table_expression_node->toAST(convert_to_ast_options);\n     }\n \n     auto result_table_expression = std::make_shared<ASTTableExpression>();\n@@ -440,7 +443,11 @@ static ASTPtr convertIntoTableExpressionAST(const QueryTreeNodePtr & table_expre\n     return result_table_expression;\n }\n \n-void addTableExpressionOrJoinIntoTablesInSelectQuery(ASTPtr & tables_in_select_query_ast, const QueryTreeNodePtr & table_expression, const IQueryTreeNode::ConvertToASTOptions & convert_to_ast_options)\n+void addTableExpressionOrJoinIntoTablesInSelectQuery(\n+    ASTPtr & tables_in_select_query_ast,\n+    const QueryTreeNodePtr & table_expression,\n+    const ConvertToASTOptions & convert_to_ast_options\n+)\n {\n     auto table_expression_node_type = table_expression->getNodeType();\n \n@@ -456,7 +463,7 @@ void addTableExpressionOrJoinIntoTablesInSelectQuery(ASTPtr & tables_in_select_q\n             [[fallthrough]];\n         case QueryTreeNodeType::TABLE_FUNCTION:\n         {\n-            auto table_expression_ast = convertIntoTableExpressionAST(table_expression);\n+            auto table_expression_ast = convertIntoTableExpressionAST(table_expression, convert_to_ast_options);\n \n             auto tables_in_select_query_element_ast = std::make_shared<ASTTablesInSelectQueryElement>();\n             tables_in_select_query_element_ast->children.push_back(std::move(table_expression_ast));\ndiff --git a/src/Analyzer/Utils.h b/src/Analyzer/Utils.h\nindex e0063d51bd94..bd34c54bac01 100644\n--- a/src/Analyzer/Utils.h\n+++ b/src/Analyzer/Utils.h\n@@ -92,7 +92,7 @@ std::optional<bool> tryExtractConstantFromConditionNode(const QueryTreeNodePtr &\n /** Add table expression in tables in select query children.\n   * If table expression node is not of identifier node, table node, query node, table function node, join node or array join node type throws logical error exception.\n   */\n-void addTableExpressionOrJoinIntoTablesInSelectQuery(ASTPtr & tables_in_select_query_ast, const QueryTreeNodePtr & table_expression, const IQueryTreeNode::ConvertToASTOptions & convert_to_ast_options);\n+void addTableExpressionOrJoinIntoTablesInSelectQuery(ASTPtr & tables_in_select_query_ast, const QueryTreeNodePtr & table_expression, const ConvertToASTOptions & convert_to_ast_options);\n \n /// Extract all TableNodes from the query tree.\n QueryTreeNodes extractAllTableReferences(const QueryTreeNodePtr & tree);\ndiff --git a/src/Planner/CollectSets.cpp b/src/Planner/CollectSets.cpp\nindex aaa33b7a86f5..ec3b88bdcfe1 100644\n--- a/src/Planner/CollectSets.cpp\n+++ b/src/Planner/CollectSets.cpp\n@@ -105,7 +105,7 @@ class CollectSetsVisitor : public ConstInDepthQueryTreeVisitor<CollectSetsVisito\n             if (in_second_argument->as<TableNode>())\n                 subquery_to_execute = buildSubqueryToReadColumnsFromTableExpression(subquery_to_execute, planner_context.getQueryContext());\n \n-            auto ast = in_second_argument->toAST();\n+            auto ast = in_second_argument->toAST({ .set_subquery_cte_name = false });\n             sets.addFromSubquery(set_key, std::move(ast), std::move(subquery_to_execute), settings);\n         }\n         else\ndiff --git a/src/Planner/Utils.cpp b/src/Planner/Utils.cpp\nindex c4ec9fecbd72..7b3c1ccd0c69 100644\n--- a/src/Planner/Utils.cpp\n+++ b/src/Planner/Utils.cpp\n@@ -162,13 +162,16 @@ void addConvertingToCommonHeaderActionsIfNeeded(\n     }\n }\n \n-ASTPtr queryNodeToSelectQuery(const QueryTreeNodePtr & query_node)\n+ASTPtr queryNodeToSelectQuery(const QueryTreeNodePtr & query_node, bool set_subquery_cte_name)\n {\n     auto & query_node_typed = query_node->as<QueryNode &>();\n \n     // In case of cross-replication we don't know what database is used for the table.\n     // Each shard will use the default database (in the case of cross-replication shards may have different defaults).\n-    auto result_ast = query_node_typed.toAST({ .qualify_indentifiers_with_database = false });\n+    auto result_ast = query_node_typed.toAST({\n+        .qualify_indentifiers_with_database = false,\n+        .set_subquery_cte_name = set_subquery_cte_name\n+    });\n \n     while (true)\n     {\n@@ -188,31 +191,13 @@ ASTPtr queryNodeToSelectQuery(const QueryTreeNodePtr & query_node)\n     return result_ast;\n }\n \n-static void removeCTEs(ASTPtr & ast)\n-{\n-    std::stack<IAST *> stack;\n-    stack.push(ast.get());\n-    while (!stack.empty())\n-    {\n-        auto * node = stack.top();\n-        stack.pop();\n-\n-        if (auto * subquery = typeid_cast<ASTSubquery *>(node))\n-            subquery->cte_name = {};\n-\n-        for (const auto & child : node->children)\n-            stack.push(child.get());\n-    }\n-}\n-\n ASTPtr queryNodeToDistributedSelectQuery(const QueryTreeNodePtr & query_node)\n {\n-    auto ast = queryNodeToSelectQuery(query_node);\n     /// Remove CTEs information from distributed queries.\n     /// Now, if cte_name is set for subquery node, AST -> String serialization will only print cte name.\n     /// But CTE is defined only for top-level query part, so may not be sent.\n     /// Removing cte_name forces subquery to be always printed.\n-    removeCTEs(ast);\n+    auto ast = queryNodeToSelectQuery(query_node, /*set_subquery_cte_name=*/false);\n     return ast;\n }\n \ndiff --git a/src/Planner/Utils.h b/src/Planner/Utils.h\nindex bd7be4b1bd86..1aedcd417986 100644\n--- a/src/Planner/Utils.h\n+++ b/src/Planner/Utils.h\n@@ -42,7 +42,7 @@ void addConvertingToCommonHeaderActionsIfNeeded(\n     Blocks & query_plans_headers);\n \n /// Convert query node to ASTSelectQuery\n-ASTPtr queryNodeToSelectQuery(const QueryTreeNodePtr & query_node);\n+ASTPtr queryNodeToSelectQuery(const QueryTreeNodePtr & query_node, bool set_subquery_cte_name = true);\n \n /// Convert query node to ASTSelectQuery for distributed processing\n ASTPtr queryNodeToDistributedSelectQuery(const QueryTreeNodePtr & query_node);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03371_analyzer_filter_pushdown_distributed.reference b/tests/queries/0_stateless/03371_analyzer_filter_pushdown_distributed.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/03371_analyzer_filter_pushdown_distributed.sql b/tests/queries/0_stateless/03371_analyzer_filter_pushdown_distributed.sql\nnew file mode 100644\nindex 000000000000..6dd0a16574a1\n--- /dev/null\n+++ b/tests/queries/0_stateless/03371_analyzer_filter_pushdown_distributed.sql\n@@ -0,0 +1,42 @@\n+set enable_analyzer=1;\n+\n+CREATE TABLE bug_table\n+(\n+    `date_column` Date,\n+    `c1` String,\n+    `c2` String\n+)\n+ENGINE =  MergeTree\n+PARTITION BY toYYYYMM(date_column)\n+ORDER BY (c1, c2);\n+\n+INSERT INTO bug_table values\n+    (toDate(now()),hex(rand()),hex(now())),\n+    (toDate(now()),hex(rand()),hex(now())),\n+    (toDate(now()),hex(rand()),hex(now())),\n+    (toDate(now()),hex(rand()),hex(now())),\n+    (toDate(now()),hex(rand()),hex(now()));\n+\n+CREATE TABLE distributed_bug_table\n+(\n+date_column Date,\n+c1 String,\n+c2 String\n+)\n+ENGINE = Distributed('test_cluster_two_shards', currentDatabase(), 'bug_table', cityHash64(c1));\n+\n+set distributed_product_mode = 'allow';\n+\n+set prefer_localhost_replica=1;\n+\n+WITH alias_1 AS\n+   (SELECT c1,c2 FROM distributed_bug_table)\n+SELECT c1 from alias_1 where c2 IN (SELECT DISTINCT c2 from alias_1)\n+FORMAT Null;\n+\n+set prefer_localhost_replica=0;\n+\n+WITH alias_1 AS\n+   (SELECT c1,c2 FROM distributed_bug_table)\n+SELECT c1 from alias_1 where c2 IN (SELECT DISTINCT c2 from alias_1)\n+FORMAT Null;\ndiff --git a/tests/queries/0_stateless/03519_cte_allow_push_predicate_ast_for_distributed_subqueries_bug.reference b/tests/queries/0_stateless/03519_cte_allow_push_predicate_ast_for_distributed_subqueries_bug.reference\nnew file mode 100644\nindex 000000000000..b00d02e650c6\n--- /dev/null\n+++ b/tests/queries/0_stateless/03519_cte_allow_push_predicate_ast_for_distributed_subqueries_bug.reference\n@@ -0,0 +1,5 @@\n+0\n+0\n+-\n+0\n+0\ndiff --git a/tests/queries/0_stateless/03519_cte_allow_push_predicate_ast_for_distributed_subqueries_bug.sql b/tests/queries/0_stateless/03519_cte_allow_push_predicate_ast_for_distributed_subqueries_bug.sql\nnew file mode 100644\nindex 000000000000..79f74823a338\n--- /dev/null\n+++ b/tests/queries/0_stateless/03519_cte_allow_push_predicate_ast_for_distributed_subqueries_bug.sql\n@@ -0,0 +1,4 @@\n+-- Tags: no-parallel-replicas\n+with sub as (select number from numbers(1)) select x from (select number as x from remote('127.0.0.{1,2}', numbers(2))) where x in sub settings allow_push_predicate_ast_for_distributed_subqueries = 1, enable_analyzer=1;\n+select '-';\n+with sub as (select number from numbers(1)) select x from (select number as x from remote('127.0.0.{1,2}', numbers(2))) where x global in sub settings allow_push_predicate_ast_for_distributed_subqueries = 1, enable_analyzer=1;\n",
  "problem_statement": "Query from a view derived from a distributed table does not work when CTE is used in subquery\n### Company or project name\n\n_No response_\n\n### Describe what's wrong\n\nLooks like since 25.1, if I use a CTE in a sub query it returns Unknown table expression identifier. \n\n### Does it reproduce on the most recent release?\n\nYes\n\n### How to reproduce\n\n\n- Create a local table:\n\n```\n    CREATE TABLE default.t1\n    (\n        `a` String\n    )\n    ENGINE = MergeTree\n    ORDER BY a;\n```\n\n- Create a distributed table\n```\n  CREATE TABLE default.t1_all\n  (\n      `a` String\n  )\n  ENGINE = Distributed('my_cluster', 'default', 't1', rand());\n\n```\n- Create a view based on the distributed table\n\n```\n  CREATE VIEW t1_view\n  (\n      `a` String\n  )\n  AS SELECT *\n  FROM t1_all;\n```\n\n- Run a query with CTE\n\n```\n  WITH subquery AS\n      (\n          SELECT a\n          FROM default.t1_view\n      )\n  SELECT *\n  FROM default.t1_view\n  WHERE a GLOBAL IN (\n      SELECT a\n      FROM subquery\n  );\n```\n\n\n### Expected behavior\n\nThe query should run without error.\n\n### Error message and/or stacktrace\n\nYou will see below error:\nCode: 60. DB::Exception: Received from localhost:9000. DB::Exception: Received from 172.30.58.214:9000. DB::Exception: Unknown table expression identifier 'subquery' in scope (SELECT __table1.a AS a FROM subquery AS __table1). (UNKNOWN_TABLE)\n\n### Additional context\n\nIt worked before and include 24.12 and stops working since version 25.1.\n\nWITH Clause queries (CTEs) failing on 25.1.1.4165\n### Company or project name\n\n_No response_\n\n### Describe what's wrong\n\nWhen running queries using WITH CLAUSE in Clickhouse v25.1.1.4165 we are seeing errors.\n\nWhen the same queries were run on lower versions, they were working fine.\n\nWhen we point another node running v24.9 to cluster defined in v25.1 (remote servers section in config) and run the same query it works.\n\nBelow are steps to reproduce the errors. Some more complex queries return \n\n> DB::Exception: Table bug_test.bug_table does not exist. (UNKNOWN_TABLE)\n\n### Does it reproduce on the most recent release?\n\nYes\n\n### How to reproduce\n\n```\nCREATE DATABASE bug_test ON CLUSTER client_and_data_nodes;\n```\n\n\n\n```\nCREATE TABLE bug_test.bug_table ON CLUSTER only_data_nodes\n(\n    `date_column` Date,\n    `c1` String,\n    `c2` String\n)\nENGINE = ReplicatedAggregatingMergeTree('/{cluster}/bug_test/{uuid}/{replicated_shard}', '{replica}')\nPARTITION BY toYYYYMM(date_column)\nORDER BY (c1, c2);\n```\n\n\n\n```\nCREATE TABLE bug_test.distributed_bug_table on cluster client_and_data_nodes\n(\ndate_column Date,\nc1 String,\nc2 String\n)\nENGINE = Distributed('only_data_nodes','bug_test','bug_table',cityHash64(c1));\n```\n\n\n\n```\nINSERT INTO bug_test.distributed_bug_table values (toDate(now()),hex(rand()),hex(now())),(toDate(now()),hex(rand()),hex(now())),(toDate(now()),hex(rand()),hex(now())),(toDate(now()),hex(rand()),hex(now())),(toDate(now()),hex(rand()),hex(now()));\n```\n\n\n\n```\nWITH alias_1 AS (SELECT c1,c2 FROM bug_test.distributed_bug_table) SELECT c1 from alias_1 where c2 IN (SELECT DISTINCT c2 from alias_1);\n```\n\n\n> Code: 60. DB::Exception: Received from localhost:9000. DB::Exception: Received from datanode.example.com:9440. DB::Exception: Unknown table expression identifier 'alias_1' in scope (SELECT DISTINCT __table1.c2 AS c2 FROM alias_1 AS __table1). (UNKNOWN_TABLE)\n\n\n\n\n```\nWITH alias_1 AS (SELECT c1,c2 FROM bug_test.distributed_bug_table) SELECT c1 from alias_1 where c2 IN (SELECT DISTINCT c2 from alias_1) SETTINGS allow_experimental_analyzer = 0, enable_analyzer = 0;\n```\n\n\n> Code: 60. DB::Exception: Received from localhost:9000. DB::Exception: Received from datanode.example.com:9440. DB::Exception: Table default.alias_1 does not exist: While processing c2 IN ((SELECT DISTINCT c2 FROM alias_1) AS _subquery4). (UNKNOWN_TABLE)`\n\n### Expected behavior\n\nOn lower version we can see an output.\n\n\n```\nQuery id: 27f7b7b9-552c-4630-a37b-e99af16d12be\n\n   \u250c\u2500c1\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n1. \u2502 8D0298F6 \u2502\n2. \u2502 AC6703AF \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   \u250c\u2500c1\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n3. \u2502 C7FEDA1C \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \u250c\u2500c1\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n 4. \u2502 2F7F32CB \u2502\n 5. \u2502 486F2EEC \u2502\n 6. \u2502 4A2D1F30 \u2502\n 7. \u2502 621DB402 \u2502\n 8. \u2502 74D11472 \u2502\n 9. \u2502 E0A7B38A \u2502\n10. \u2502 E4F4D788 \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n### Error message and/or stacktrace\n\n```\n2025.02.05 17:04:00.797685 [ 3769666 ] {} <Error> TCPHandler: Code: 60. DB::Exception: Received from datanode.example.com:9440. DB::Exception: Unknown table expression identifier 'alias_2' in scope (SELECT DISTINCT __table1.c2 AS c2 FROM alias_2 AS __table1). Stack trace:\n\n0. DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0x000000000dd0ddfb\n1. DB::Exception::Exception(PreformattedMessage&&, int) @ 0x0000000008bab62c\n2. DB::Exception::Exception<String const&, String>(int, FormatStringHelperImpl<std::type_identity<String const&>::type, std::type_identity<String>::type>, String const&, String&&) @ 0x000000000921c86b\n3. DB::QueryAnalyzer::resolveQuery(std::shared_ptr<DB::IQueryTreeNode> const&, DB::IdentifierResolveScope&) @ 0x0000000011ee76b5\n4. DB::QueryAnalyzer::resolveExpressionNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, bool, bool, bool) @ 0x0000000011eee9f4\n5. DB::QueryAnalyzer::resolveExpressionNodeList(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, bool, bool) @ 0x0000000011eed6db\n6. DB::QueryAnalyzer::resolveFunction(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&) @ 0x0000000011f064e4\n7. DB::QueryAnalyzer::resolveExpressionNode(std::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, bool, bool, bool) @ 0x0000000011eeeaaa\n8. DB::QueryAnalyzer::resolveQuery(std::shared_ptr<DB::IQueryTreeNode> const&, DB::IdentifierResolveScope&) @ 0x0000000011ee4cb4\n9. DB::QueryAnalyzer::resolve(std::shared_ptr<DB::IQueryTreeNode>&, std::shared_ptr<DB::IQueryTreeNode> const&, std::shared_ptr<DB::Context const>) @ 0x0000000011ee250c\n10. DB::QueryAnalysisPass::run(std::shared_ptr<DB::IQueryTreeNode>&, std::shared_ptr<DB::Context const>) @ 0x0000000011ee1de0\n11. DB::QueryTreePassManager::run(std::shared_ptr<DB::IQueryTreeNode>, unsigned long) @ 0x000000001259ec1e\n12. DB::(anonymous namespace)::buildQueryTreeAndRunPasses(std::shared_ptr<DB::IAST> const&, DB::SelectQueryOptions const&, std::shared_ptr<DB::Context const> const&, std::shared_ptr<DB::IStorage> const&) (.llvm.1246331599746980635) @ 0x00000000127fe898\n13. DB::InterpreterSelectQueryAnalyzer::InterpreterSelectQueryAnalyzer(std::shared_ptr<DB::IAST> const&, std::shared_ptr<DB::Context const> const&, DB::SelectQueryOptions const&, std::vector<String, std::allocator<String>> const&) @ 0x00000000127fcadc\n14. std::unique_ptr<DB::IInterpreter, std::default_delete<DB::IInterpreter>> std::__function::__policy_invoker<std::unique_ptr<DB::IInterpreter, std::default_delete<DB::IInterpreter>> (DB::InterpreterFactory::Arguments const&)>::__call_impl[abi:ne180100]<std::__function::__default_alloc_func<DB::registerInterpreterSelectQueryAnalyzer(DB::InterpreterFactory&)::$_0, std::unique_ptr<DB::IInterpreter, std::default_delete<DB::IInterpreter>> (DB::InterpreterFactory::Arguments const&)>>(std::__function::__policy_storage const*, DB::InterpreterFactory::Arguments const&) (.llvm.1246331599746980635) @ 0x0000000012800882\n15. DB::InterpreterFactory::get(std::shared_ptr<DB::IAST>&, std::shared_ptr<DB::Context>, DB::SelectQueryOptions const&) @ 0x000000001279a596\n16. DB::executeQueryImpl(char const*, char const*, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum, DB::ReadBuffer*) @ 0x0000000012b8cbea\n17. DB::executeQuery(String const&, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum) @ 0x0000000012b8819c\n18. DB::TCPHandler::runImpl() @ 0x0000000013e7b66c\n19. DB::TCPHandler::run() @ 0x0000000013e98f59\n20. Poco::Net::TCPServerConnection::start() @ 0x000000001743e507\n21. Poco::Net::TCPServerDispatcher::run() @ 0x000000001743e959\n22. Poco::PooledThread::run() @ 0x000000001740aebb\n23. Poco::ThreadImpl::runnableEntry(void*) @ 0x000000001740939d\n24. ? @ 0x00007f1e37c62ac3\n25. ? @ 0x00007f1e37cf4850\n: While executing Remote. (UNKNOWN_TABLE), Stack trace (when copying this message, always include the lines below):\n\n```\n\n### Additional context\n\n_No response_\n",
  "hints_text": "\nProbably fixed by #66143.\nAnother scenario without the CTE syntax with the same issue:\n\n```\nSELECT ip_col\nFROM\n(\n    SELECT DISTINCT ip_col\n    FROM db_name_1.Distributed_Table\n    UNION DISTINCT\n    SELECT DISTINCT ip_col_2\n    FROM db_name_1.Distributed_Table\n)\nWHERE ip_col GLOBAL NOT IN (\n    SELECT ip_col\n    FROM db_name_2.another_table)\n```\n@novikd the query in that bug runs fine without changing any settings. However, the ones referenced here do not work.\nSimilar https://github.com/ClickHouse/ClickHouse/issues/75956 \n> Probably fixed by [#66143](https://github.com/ClickHouse/ClickHouse/pull/66143).\n\nI don't think it is. I hit this same problem with docker image `clickhouse/clickhouse-server:25.1.5.31-alpine` as of February 24th ~and according to the github releases [#66143](https://github.com/ClickHouse/ClickHouse/pull/66143) made it into [releases/tag/v25.1.5.31-stable](https://github.com/ClickHouse/ClickHouse/releases/tag/v25.1.5.31-stable).~\n\n> I don't think it is. I hit this same problem with docker image clickhouse/clickhouse-server:25.1.5.31-alpine as of February 24th and according to the github releases https://github.com/ClickHouse/ClickHouse/pull/66143 made it into [releases/tag/v25.1.5.31-stable](https://github.com/ClickHouse/ClickHouse/releases/tag/v25.1.5.31-stable).\n\n@voran, this fix was not backported to `25.1`: https://github.com/ClickHouse/ClickHouse/pull/75904\nCould you please show where you see that it made into `25.1.5.31`?\n> > I don't think it is. I hit this same problem with docker image clickhouse/clickhouse-server:25.1.5.31-alpine as of February 24th and according to the github releases [#66143](https://github.com/ClickHouse/ClickHouse/pull/66143) made it into [releases/tag/v25.1.5.31-stable](https://github.com/ClickHouse/ClickHouse/releases/tag/v25.1.5.31-stable).\n> \n> [@voran](https://github.com/voran), this fix was not backported to `25.1`: [#75904](https://github.com/ClickHouse/ClickHouse/pull/75904) Could you please show where you see that it made into `25.1.5.31`?\n\nSorry, I thought I saw it there but now I don't see it. I probably looked at the wrong merge commit.\nprefer_localhost_replica=0\n\nhttps://fiddle.clickhouse.com/5a2e5422-fbee-4616-9dc9-15dc0d93a706\n\nworked in 24.12 fails in 25.1 and in the master https://fiddle.clickhouse.com/c05b210f-e0ba-4eea-9e6e-e1bcf38fb50d\nIt is most likely broken by https://github.com/ClickHouse/ClickHouse/pull/74085.\nHere, we pass incorrect AST to the `FutureSet`:\nhttps://github.com/ClickHouse/ClickHouse/blob/be91c6e7ce99d56b64e35fbbb91144b3258d8c13/src/Planner/CollectSets.cpp#L112-L113\nConfirmed: this issue is related to https://github.com/ClickHouse/ClickHouse/pull/74085, but it seems the bug is the code where predicate is rewritten for shard.\n\n### Workaround\n\n`set allow_push_predicate_ast_for_distributed_subqueries = 0`",
  "created_at": "2025-03-07T16:23:03Z",
  "modified_files": [
    "src/Analyzer/IQueryTreeNode.h",
    "src/Analyzer/QueryNode.cpp",
    "src/Analyzer/UnionNode.cpp",
    "src/Analyzer/Utils.cpp",
    "src/Analyzer/Utils.h",
    "src/Planner/CollectSets.cpp",
    "src/Planner/Utils.cpp",
    "src/Planner/Utils.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03371_analyzer_filter_pushdown_distributed.sql",
    "b/tests/queries/0_stateless/03519_cte_allow_push_predicate_ast_for_distributed_subqueries_bug.reference",
    "b/tests/queries/0_stateless/03519_cte_allow_push_predicate_ast_for_distributed_subqueries_bug.sql"
  ]
}