{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 61823,
  "instance_id": "ClickHouse__ClickHouse-61823",
  "issue_numbers": [
    "58183"
  ],
  "base_commit": "65a47801f195eb7371ea8e80958c87a1e16a1a64",
  "patch": "diff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex efc37fd76afd..ffe45d556438 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -2499,10 +2499,13 @@ void InterpreterSelectQuery::executeFetchColumns(QueryProcessingStage::Enum proc\n             max_block_size = std::max<UInt64>(1, max_block_limited);\n             max_threads_execute_query = max_streams = 1;\n         }\n+\n         if (local_limits.local_limits.size_limits.max_rows != 0)\n         {\n             if (max_block_limited < local_limits.local_limits.size_limits.max_rows)\n                 query_info.limit = max_block_limited;\n+            else if (local_limits.local_limits.size_limits.max_rows < std::numeric_limits<UInt64>::max()) /// Ask to read just enough rows to make the max_rows limit effective (so it has a chance to be triggered).\n+                query_info.limit = 1 + local_limits.local_limits.size_limits.max_rows;\n         }\n         else\n         {\ndiff --git a/src/Planner/PlannerJoinTree.cpp b/src/Planner/PlannerJoinTree.cpp\nindex 514c19b0f89c..bf1ebe6740b7 100644\n--- a/src/Planner/PlannerJoinTree.cpp\n+++ b/src/Planner/PlannerJoinTree.cpp\n@@ -691,6 +691,9 @@ JoinTreeQueryPlan buildQueryPlanForTableExpression(QueryTreeNodePtr table_expres\n                 {\n                     if (max_block_size_limited < select_query_info.local_storage_limits.local_limits.size_limits.max_rows)\n                         table_expression_query_info.limit = max_block_size_limited;\n+                    /// Ask to read just enough rows to make the max_rows limit effective (so it has a chance to be triggered).\n+                    else if (select_query_info.local_storage_limits.local_limits.size_limits.max_rows < std::numeric_limits<UInt64>::max())\n+                        table_expression_query_info.limit = 1 + select_query_info.local_storage_limits.local_limits.size_limits.max_rows;\n                 }\n                 else\n                 {\ndiff --git a/src/Processors/QueryPlan/ReadFromSystemNumbersStep.cpp b/src/Processors/QueryPlan/ReadFromSystemNumbersStep.cpp\nindex 7a61d09bdd2d..11371578c79c 100644\n--- a/src/Processors/QueryPlan/ReadFromSystemNumbersStep.cpp\n+++ b/src/Processors/QueryPlan/ReadFromSystemNumbersStep.cpp\n@@ -12,8 +12,8 @@\n #include <fmt/format.h>\n #include <Common/iota.h>\n #include <Common/typeid_cast.h>\n-#include \"Core/Types.h\"\n-#include \"base/types.h\"\n+#include <Core/Types.h>\n+\n \n namespace DB\n {\n@@ -443,7 +443,6 @@ Pipe ReadFromSystemNumbersStep::makePipe()\n     /// Build rpn of query filters\n     KeyCondition condition(filter_actions_dag, context, column_names, key_expression);\n \n-\n     if (condition.extractPlainRanges(ranges))\n     {\n         /// Intersect ranges with table range\n@@ -505,7 +504,6 @@ Pipe ReadFromSystemNumbersStep::makePipe()\n             }\n         }\n \n-\n         /// ranges is blank, return a source who has no data\n         if (intersected_ranges.empty())\n         {\ndiff --git a/src/Processors/QueryPlan/ReadFromSystemNumbersStep.h b/src/Processors/QueryPlan/ReadFromSystemNumbersStep.h\nindex cab0686474ba..bc84e31be626 100644\n--- a/src/Processors/QueryPlan/ReadFromSystemNumbersStep.h\n+++ b/src/Processors/QueryPlan/ReadFromSystemNumbersStep.h\n@@ -8,6 +8,7 @@\n #include <Storages/SelectQueryInfo.h>\n #include <Storages/StorageSnapshot.h>\n \n+\n namespace DB\n {\n \n@@ -43,4 +44,5 @@ class ReadFromSystemNumbersStep final : public SourceStepWithFilter\n     UInt64 limit;\n     std::shared_ptr<const StorageLimitsList> storage_limits;\n };\n+\n }\ndiff --git a/src/Storages/StorageGenerateRandom.cpp b/src/Storages/StorageGenerateRandom.cpp\nindex fbce6c2bb7d1..cdbade51695b 100644\n--- a/src/Storages/StorageGenerateRandom.cpp\n+++ b/src/Storages/StorageGenerateRandom.cpp\n@@ -3,6 +3,7 @@\n #include <Storages/StorageGenerateRandom.h>\n #include <Storages/StorageFactory.h>\n #include <Storages/checkAndGetLiteralArgument.h>\n+#include <Storages/SelectQueryInfo.h>\n #include <Processors/Sources/SourceFromSingleChunk.h>\n #include <QueryPipeline/Pipe.h>\n #include <Parsers/ASTLiteral.h>\n@@ -30,12 +31,9 @@\n #include <Common/SipHash.h>\n #include <Common/randomSeed.h>\n #include <Interpreters/Context.h>\n-#include <base/unaligned.h>\n \n #include <Functions/FunctionFactory.h>\n \n-#include <pcg_random.hpp>\n-\n \n namespace DB\n {\n@@ -639,7 +637,7 @@ void registerStorageGenerateRandom(StorageFactory & factory)\n Pipe StorageGenerateRandom::read(\n     const Names & column_names,\n     const StorageSnapshotPtr & storage_snapshot,\n-    SelectQueryInfo & /*query_info*/,\n+    SelectQueryInfo & query_info,\n     ContextPtr context,\n     QueryProcessingStage::Enum /*processed_stage*/,\n     size_t max_block_size,\n@@ -682,7 +680,14 @@ Pipe StorageGenerateRandom::read(\n     pcg64 generate(random_seed);\n \n     for (UInt64 i = 0; i < num_streams; ++i)\n-        pipes.emplace_back(std::make_shared<GenerateSource>(max_block_size, max_array_length, max_string_length, generate(), block_header, context));\n+    {\n+        auto source = std::make_shared<GenerateSource>(max_block_size, max_array_length, max_string_length, generate(), block_header, context);\n+\n+        if (i == 0 && query_info.limit)\n+            source->addTotalRowsApprox(query_info.limit);\n+\n+        pipes.emplace_back(std::move(source));\n+    }\n \n     return Pipe::unitePipes(std::move(pipes));\n }\ndiff --git a/src/Storages/System/StorageSystemNumbers.cpp b/src/Storages/System/StorageSystemNumbers.cpp\nindex 629b11ee7f1f..da700a7a4e9d 100644\n--- a/src/Storages/System/StorageSystemNumbers.cpp\n+++ b/src/Storages/System/StorageSystemNumbers.cpp\n@@ -1,17 +1,14 @@\n #include <Storages/System/StorageSystemNumbers.h>\n \n #include <mutex>\n-#include <Columns/ColumnsNumber.h>\n #include <DataTypes/DataTypesNumber.h>\n #include <Interpreters/InterpreterSelectQuery.h>\n-#include <Processors/ISource.h>\n #include <Processors/LimitTransform.h>\n #include <Processors/QueryPlan/QueryPlan.h>\n #include <Processors/QueryPlan/ReadFromSystemNumbersStep.h>\n-#include <Processors/Sources/NullSource.h>\n-#include <QueryPipeline/Pipe.h>\n #include <Storages/SelectQueryInfo.h>\n \n+\n namespace DB\n {\n \ndiff --git a/src/Storages/System/StorageSystemZeros.cpp b/src/Storages/System/StorageSystemZeros.cpp\nindex ce2e153ea666..a48b109fbbe5 100644\n--- a/src/Storages/System/StorageSystemZeros.cpp\n+++ b/src/Storages/System/StorageSystemZeros.cpp\n@@ -1,4 +1,5 @@\n #include <Storages/System/StorageSystemZeros.h>\n+#include <Storages/SelectQueryInfo.h>\n \n #include <Processors/ISource.h>\n #include <QueryPipeline/Pipe.h>\n@@ -6,6 +7,7 @@\n #include <DataTypes/DataTypesNumber.h>\n #include <Columns/ColumnsNumber.h>\n \n+\n namespace DB\n {\n \n@@ -93,7 +95,7 @@ StorageSystemZeros::StorageSystemZeros(const StorageID & table_id_, bool multith\n Pipe StorageSystemZeros::read(\n     const Names & column_names,\n     const StorageSnapshotPtr & storage_snapshot,\n-    SelectQueryInfo &,\n+    SelectQueryInfo & query_info,\n     ContextPtr /*context*/,\n     QueryProcessingStage::Enum /*processed_stage*/,\n     size_t max_block_size,\n@@ -123,8 +125,13 @@ Pipe StorageSystemZeros::read(\n     {\n         auto source = std::make_shared<ZerosSource>(max_block_size, limit ? *limit : 0, state);\n \n-        if (limit && i == 0)\n-            source->addTotalRowsApprox(*limit);\n+        if (i == 0)\n+        {\n+            if (limit)\n+                source->addTotalRowsApprox(*limit);\n+            else if (query_info.limit)\n+                source->addTotalRowsApprox(query_info.limit);\n+        }\n \n         res.addSource(std::move(source));\n     }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03023_zeros_generate_random_with_limit_progress_bar.expect b/tests/queries/0_stateless/03023_zeros_generate_random_with_limit_progress_bar.expect\nnew file mode 100755\nindex 000000000000..de15a1991328\n--- /dev/null\n+++ b/tests/queries/0_stateless/03023_zeros_generate_random_with_limit_progress_bar.expect\n@@ -0,0 +1,49 @@\n+#!/usr/bin/expect -f\n+\n+set basedir [file dirname $argv0]\n+set basename [file tail $argv0]\n+if {[info exists env(CLICKHOUSE_TMP)]} {\n+    set CLICKHOUSE_TMP $env(CLICKHOUSE_TMP)\n+} else {\n+    set CLICKHOUSE_TMP \".\"\n+}\n+exp_internal -f $CLICKHOUSE_TMP/$basename.debuglog 0\n+\n+log_user 0\n+set timeout 60\n+match_max 100000\n+set stty_init \"rows 25 cols 120\"\n+\n+expect_after {\n+    -i $any_spawn_id eof { exp_continue }\n+    -i $any_spawn_id timeout { exit 1 }\n+}\n+\n+spawn clickhouse-local\n+expect \":) \"\n+\n+# Trivial SELECT with LIMIT from system.zeros shows progress bar.\n+send \"SELECT * FROM system.zeros LIMIT 10000000 FORMAT Null SETTINGS max_execution_speed = 1000000, timeout_before_checking_execution_speed = 0, max_block_size = 128\\r\"\n+expect \"Progress: \"\n+expect \"\u2588\"\n+send \"\\3\"\n+expect \"Query was cancelled.\"\n+expect \":) \"\n+\n+send \"SELECT * FROM system.zeros_mt LIMIT 10000000 FORMAT Null SETTINGS max_execution_speed = 1000000, timeout_before_checking_execution_speed = 0, max_block_size = 128\\r\"\n+expect \"Progress: \"\n+expect \"\u2588\"\n+send \"\\3\"\n+expect \"Query was cancelled.\"\n+expect \":) \"\n+\n+# As well as from generateRandom\n+send \"SELECT * FROM generateRandom() LIMIT 10000000 FORMAT Null SETTINGS max_execution_speed = 1000000, timeout_before_checking_execution_speed = 0, max_block_size = 128\\r\"\n+expect \"Progress: \"\n+expect \"\u2588\"\n+send \"\\3\"\n+expect \"Query was cancelled.\"\n+expect \":) \"\n+\n+send \"exit\\r\"\n+expect eof\ndiff --git a/tests/queries/0_stateless/03023_zeros_generate_random_with_limit_progress_bar.reference b/tests/queries/0_stateless/03023_zeros_generate_random_with_limit_progress_bar.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/03024_total_rows_approx_is_set_for_system_zeros_and_generate_random.reference b/tests/queries/0_stateless/03024_total_rows_approx_is_set_for_system_zeros_and_generate_random.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/03024_total_rows_approx_is_set_for_system_zeros_and_generate_random.sql b/tests/queries/0_stateless/03024_total_rows_approx_is_set_for_system_zeros_and_generate_random.sql\nnew file mode 100644\nindex 000000000000..0db09ead2cda\n--- /dev/null\n+++ b/tests/queries/0_stateless/03024_total_rows_approx_is_set_for_system_zeros_and_generate_random.sql\n@@ -0,0 +1,9 @@\n+SET max_rows_to_read = 1e11;\n+\n+SELECT * FROM system.numbers LIMIT 1e12 FORMAT Null; -- { serverError TOO_MANY_ROWS }\n+SELECT * FROM system.numbers_mt LIMIT 1e12 FORMAT Null; -- { serverError TOO_MANY_ROWS }\n+\n+SELECT * FROM system.zeros LIMIT 1e12 FORMAT Null; -- { serverError TOO_MANY_ROWS }\n+SELECT * FROM system.zeros_mt LIMIT 1e12 FORMAT Null; -- { serverError TOO_MANY_ROWS }\n+\n+SELECT * FROM generateRandom() LIMIT 1e12 FORMAT Null; -- { serverError TOO_MANY_ROWS }\n",
  "problem_statement": "If the storage does not provide `total_rows_approx` for the progress bar, but it is a trivial query with LIMIT, provide `total_rows_approx` from the LIMIT.\n**Use case**\r\n\r\nThis query should show progress bar:\r\n```\r\nINSERT INTO test SELECT * FROM generateRandom() LIMIT 100000000000;\r\n```\n",
  "hints_text": "@alexey-milovidov I'd like to have a try.  \n@lingtaolf, thank you! This will be very helpful!",
  "created_at": "2024-03-23T23:45:34Z"
}