{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 39227,
  "instance_id": "ClickHouse__ClickHouse-39227",
  "issue_numbers": [
    "38018"
  ],
  "base_commit": "06a1874c176cff9eefd61fa3ed1d639830204d15",
  "patch": "diff --git a/src/Common/logger_useful.h b/src/Common/logger_useful.h\nindex ad7d6583f5e9..1e84efd80850 100644\n--- a/src/Common/logger_useful.h\n+++ b/src/Common/logger_useful.h\n@@ -14,8 +14,10 @@ namespace\n     template <typename T, typename... Ts> constexpr auto firstArg(T && x, Ts &&...) { return std::forward<T>(x); }\n     /// For implicit conversion of fmt::basic_runtime<> to char* for std::string ctor\n     template <typename T, typename... Ts> constexpr auto firstArg(fmt::basic_runtime<T> && data, Ts &&...) { return data.str.data(); }\n-}\n \n+    [[maybe_unused]] const ::Poco::Logger * getLogger(const ::Poco::Logger * logger) { return logger; };\n+    [[maybe_unused]] const ::Poco::Logger * getLogger(const std::atomic<::Poco::Logger *> & logger) { return logger.load(); };\n+}\n \n /// Logs a message to a specified logger with that level.\n /// If more than one argument is provided,\n@@ -25,20 +27,21 @@ namespace\n \n #define LOG_IMPL(logger, priority, PRIORITY, ...) do                              \\\n {                                                                                 \\\n-    const bool is_clients_log = (DB::CurrentThread::getGroup() != nullptr) &&     \\\n+    auto _logger = ::getLogger(logger);                                           \\\n+    const bool _is_clients_log = (DB::CurrentThread::getGroup() != nullptr) &&    \\\n         (DB::CurrentThread::getGroup()->client_logs_level >= (priority));         \\\n-    if ((logger)->is((PRIORITY)) || is_clients_log)                               \\\n+    if (_logger->is((PRIORITY)) || _is_clients_log)                               \\\n     {                                                                             \\\n         std::string formatted_message = numArgs(__VA_ARGS__) > 1 ? fmt::format(__VA_ARGS__) : firstArg(__VA_ARGS__); \\\n-        if (auto channel = (logger)->getChannel())                                \\\n+        if (auto _channel = _logger->getChannel())                                \\\n         {                                                                         \\\n             std::string file_function;                                            \\\n             file_function += __FILE__;                                            \\\n             file_function += \"; \";                                                \\\n             file_function += __PRETTY_FUNCTION__;                                 \\\n-            Poco::Message poco_message((logger)->name(), formatted_message,       \\\n+            Poco::Message poco_message(_logger->name(), formatted_message,        \\\n                                  (PRIORITY), file_function.c_str(), __LINE__);    \\\n-            channel->log(poco_message);                                           \\\n+            _channel->log(poco_message);                                          \\\n         }                                                                         \\\n     }                                                                             \\\n } while (false)\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex 5900ea0fdb72..ef315e865ec6 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -216,8 +216,8 @@ MergeTreeData::MergeTreeData(\n     , require_part_metadata(require_part_metadata_)\n     , relative_data_path(relative_data_path_)\n     , broken_part_callback(broken_part_callback_)\n-    , log_name(table_id_.getNameForLogs())\n-    , log(&Poco::Logger::get(log_name))\n+    , log_name(std::make_shared<String>(table_id_.getNameForLogs()))\n+    , log(&Poco::Logger::get(*log_name))\n     , storage_settings(std::move(storage_settings_))\n     , pinned_part_uuids(std::make_shared<PinnedPartUUIDs>())\n     , data_parts_by_info(data_parts_indexes.get<TagByInfo>())\n@@ -2033,8 +2033,13 @@ void MergeTreeData::rename(const String & new_table_path, const StorageID & new_\n     relative_data_path = new_table_path;\n \n     renameInMemory(new_table_id);\n+}\n \n-\n+void MergeTreeData::renameInMemory(const StorageID & new_table_id)\n+{\n+    IStorage::renameInMemory(new_table_id);\n+    std::atomic_store(&log_name, std::make_shared<String>(new_table_id.getNameForLogs()));\n+    log = &Poco::Logger::get(*log_name);\n }\n \n void MergeTreeData::dropAllData()\n@@ -4734,11 +4739,19 @@ ReservationPtr MergeTreeData::tryReserveSpacePreferringTTLRules(\n         if (!destination_ptr)\n         {\n             if (move_ttl_entry->destination_type == DataDestinationType::VOLUME && !move_ttl_entry->if_exists)\n-                LOG_WARNING(log, \"Would like to reserve space on volume '{}' by TTL rule of table '{}' but volume was not found or rule is not applicable at the moment\",\n-                    move_ttl_entry->destination_name, log_name);\n+                LOG_WARNING(\n+                    log,\n+                    \"Would like to reserve space on volume '{}' by TTL rule of table '{}' but volume was not found or rule is not \"\n+                    \"applicable at the moment\",\n+                    move_ttl_entry->destination_name,\n+                    *std::atomic_load(&log_name));\n             else if (move_ttl_entry->destination_type == DataDestinationType::DISK && !move_ttl_entry->if_exists)\n-                LOG_WARNING(log, \"Would like to reserve space on disk '{}' by TTL rule of table '{}' but disk was not found or rule is not applicable at the moment\",\n-                    move_ttl_entry->destination_name, log_name);\n+                LOG_WARNING(\n+                    log,\n+                    \"Would like to reserve space on disk '{}' by TTL rule of table '{}' but disk was not found or rule is not applicable \"\n+                    \"at the moment\",\n+                    move_ttl_entry->destination_name,\n+                    *std::atomic_load(&log_name));\n         }\n         else\n         {\n@@ -4747,11 +4760,17 @@ ReservationPtr MergeTreeData::tryReserveSpacePreferringTTLRules(\n                 return reservation;\n             else\n                 if (move_ttl_entry->destination_type == DataDestinationType::VOLUME)\n-                    LOG_WARNING(log, \"Would like to reserve space on volume '{}' by TTL rule of table '{}' but there is not enough space\",\n-                    move_ttl_entry->destination_name, log_name);\n+                    LOG_WARNING(\n+                        log,\n+                        \"Would like to reserve space on volume '{}' by TTL rule of table '{}' but there is not enough space\",\n+                        move_ttl_entry->destination_name,\n+                        *std::atomic_load(&log_name));\n                 else if (move_ttl_entry->destination_type == DataDestinationType::DISK)\n-                    LOG_WARNING(log, \"Would like to reserve space on disk '{}' by TTL rule of table '{}' but there is not enough space\",\n-                        move_ttl_entry->destination_name, log_name);\n+                    LOG_WARNING(\n+                        log,\n+                        \"Would like to reserve space on disk '{}' by TTL rule of table '{}' but there is not enough space\",\n+                        move_ttl_entry->destination_name,\n+                        *std::atomic_load(&log_name));\n         }\n     }\n \n@@ -6590,7 +6609,10 @@ bool MergeTreeData::insertQueryIdOrThrowNoLock(const String & query_id, size_t m\n         return false;\n     if (query_id_set.size() >= max_queries)\n         throw Exception(\n-            ErrorCodes::TOO_MANY_SIMULTANEOUS_QUERIES, \"Too many simultaneous queries for table {}. Maximum is: {}\", log_name, max_queries);\n+            ErrorCodes::TOO_MANY_SIMULTANEOUS_QUERIES,\n+            \"Too many simultaneous queries for table {}. Maximum is: {}\",\n+            *std::atomic_load(&log_name),\n+            max_queries);\n     query_id_set.insert(query_id);\n     return true;\n }\ndiff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h\nindex 0b6e757ab496..be338d529780 100644\n--- a/src/Storages/MergeTree/MergeTreeData.h\n+++ b/src/Storages/MergeTree/MergeTreeData.h\n@@ -456,7 +456,7 @@ class MergeTreeData : public IStorage, public WithMutableContext\n     /// Load the set of data parts from disk. Call once - immediately after the object is created.\n     void loadDataParts(bool skip_sanity_checks);\n \n-    String getLogName() const { return log_name; }\n+    String getLogName() const { return *std::atomic_load(&log_name); }\n \n     Int64 getMaxBlockNumber() const;\n \n@@ -649,6 +649,9 @@ class MergeTreeData : public IStorage, public WithMutableContext\n     /// because changes relative_data_path.\n     void rename(const String & new_table_path, const StorageID & new_table_id) override;\n \n+    /// Also rename log names.\n+    void renameInMemory(const StorageID & new_table_id) override;\n+\n     /// Check if the ALTER can be performed:\n     /// - all needed columns are present.\n     /// - all type conversions can be done.\n@@ -1021,8 +1024,10 @@ class MergeTreeData : public IStorage, public WithMutableContext\n     /// Engine-specific methods\n     BrokenPartCallback broken_part_callback;\n \n-    String log_name;\n-    Poco::Logger * log;\n+    /// log_name will change during table RENAME. Use atomic_shared_ptr to allow concurrent RW.\n+    /// NOTE clang-14 doesn't have atomic_shared_ptr yet. Use std::atomic* operations for now.\n+    std::shared_ptr<String> log_name;\n+    std::atomic<Poco::Logger *> log;\n \n     /// Storage settings.\n     /// Use get and set to receive readonly versions.\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02360_rename_table_along_with_log_name.reference b/tests/queries/0_stateless/02360_rename_table_along_with_log_name.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/02360_rename_table_along_with_log_name.sh b/tests/queries/0_stateless/02360_rename_table_along_with_log_name.sh\nnew file mode 100755\nindex 000000000000..e8c7f844b5cc\n--- /dev/null\n+++ b/tests/queries/0_stateless/02360_rename_table_along_with_log_name.sh\n@@ -0,0 +1,18 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+[ ! -z \"$CLICKHOUSE_CLIENT_REDEFINED\" ] && CLICKHOUSE_CLIENT=$CLICKHOUSE_CLIENT_REDEFINED\n+\n+$CLICKHOUSE_CLIENT -q \"DROP TABLE IF EXISTS x;\"\n+$CLICKHOUSE_CLIENT -q \"DROP TABLE IF EXISTS y;\"\n+$CLICKHOUSE_CLIENT -q \"CREATE TABLE x(i int) ENGINE MergeTree ORDER BY i;\"\n+$CLICKHOUSE_CLIENT -q \"RENAME TABLE x TO y;\"\n+\n+CLICKHOUSE_CLIENT_WITH_LOG=$(echo ${CLICKHOUSE_CLIENT} | sed 's/'\"--send_logs_level=${CLICKHOUSE_CLIENT_SERVER_LOGS_LEVEL}\"'/--send_logs_level=trace/g')\n+regexp=\"${CLICKHOUSE_DATABASE}\\\\.x\" # Check if there are still log entries with old table name\n+$CLICKHOUSE_CLIENT_WITH_LOG --send_logs_source_regexp \"$regexp\" -q \"INSERT INTO y VALUES(1);\"\n+\n+$CLICKHOUSE_CLIENT -q \"DROP TABLE y;\"\n",
  "problem_statement": "Wrong table name in logs after RENAME TABLE \n**Describe what's wrong**\r\n\r\nWrong table name in logs after table `RENAME`\r\n\r\n\r\n**Does it reproduce on recent release?**\r\n\r\nYes.\r\n**How to reproduce**\r\n22.6\r\n\r\n```\r\nCREATE TABLE table_test_a\r\n(\r\n    `key` UInt32\r\n)\r\nENGINE = MergeTree\r\nORDER BY key;\r\n\r\nINSERT INTO table_test_a SELECT *\r\nFROM numbers(1000);\r\n\r\nRENAME TABLE table_test_a TO table_test_b;\r\n\r\nSELECT *\r\nFROM table_test_b\r\nFORMAT `Null`;\r\n\r\n\r\n[LAPTOP-] 2022.06.13 10:58:18.370192 [ 27745 ] {43b0dc5d-69e6-4e42-b96c-a13871b6a791} <Debug> executeQuery: (from 127.0.0.1:58484) SELECT * FROM table_test_b FORMAT Null; (stage: Complete)\r\n[LAPTOP-] 2022.06.13 10:58:18.370599 [ 27745 ] {43b0dc5d-69e6-4e42-b96c-a13871b6a791} <Trace> ContextAccess (default): Access granted: SELECT(key) ON test.table_test_b\r\n[LAPTOP-] 2022.06.13 10:58:18.370665 [ 27745 ] {43b0dc5d-69e6-4e42-b96c-a13871b6a791} <Trace> ContextAccess (default): Access granted: SELECT(key) ON test.table_test_b\r\n[LAPTOP-] 2022.06.13 10:58:18.370714 [ 27745 ] {43b0dc5d-69e6-4e42-b96c-a13871b6a791} <Trace> InterpreterSelectQuery: FetchColumns -> Complete\r\n[LAPTOP-] 2022.06.13 10:58:18.370783 [ 27745 ] {43b0dc5d-69e6-4e42-b96c-a13871b6a791} <Debug> test.table_test_a (SelectExecutor): Key condition: unknown\r\n[LAPTOP-] 2022.06.13 10:58:18.370817 [ 27745 ] {43b0dc5d-69e6-4e42-b96c-a13871b6a791} <Debug> test.table_test_a (SelectExecutor): Selected 1/1 parts by partition key, 1 parts by primary key, 1/1 marks by primary key, 1 marks to read from 1 ranges\r\n[LAPTOP-] 2022.06.13 10:58:18.370847 [ 27745 ] {43b0dc5d-69e6-4e42-b96c-a13871b6a791} <Trace> MergeTreeInOrderSelectProcessor: Reading 1 ranges in order from part all_1_1_0, approx. 1000 rows starting from 0\r\n[LAPTOP-] 2022.06.13 10:58:18.371812 [ 27745 ] {43b0dc5d-69e6-4e42-b96c-a13871b6a791} <Information> executeQuery: Read 1000 rows, 3.91 KiB in 0.0015354 sec., 651296 rows/sec., 2.48 MiB/sec.\r\n[LAPTOP-] 2022.06.13 10:58:18.371956 [ 27745 ] {43b0dc5d-69e6-4e42-b96c-a13871b6a791} <Debug> MemoryTracker: Peak memory usage (for query): 45.10 KiB.\r\n```\r\n**Expected behavior**\r\n\r\nCorrect table name in logs\r\n\r\n\r\n**Additional context**\r\n\r\nInteresting, does it affect grants and etc (looks like no, in ContextAccess log it's using correct table name )\r\n\n",
  "hints_text": "> Interesting, does it affect grants and etc\r\n\r\nNo, the only thing it affects is logger name.",
  "created_at": "2022-07-14T13:24:06Z"
}