{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 57836,
  "instance_id": "ClickHouse__ClickHouse-57836",
  "issue_numbers": [
    "57458",
    "57816"
  ],
  "base_commit": "1c6eefd7db8c5282a5f1c2609cd7d0837ffb2a79",
  "patch": "diff --git a/docs/en/sql-reference/functions/array-functions.md b/docs/en/sql-reference/functions/array-functions.md\nindex 00efa63c9605..a058e1db6b43 100644\n--- a/docs/en/sql-reference/functions/array-functions.md\n+++ b/docs/en/sql-reference/functions/array-functions.md\n@@ -1081,10 +1081,6 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n-**See also**\n-\n-- [arrayFold](#arrayfold)\n-\n ## arrayReduceInRanges\n \n Applies an aggregate function to array elements in given ranges and returns an array containing the result corresponding to each range. The function will return the same result as multiple `arrayReduce(agg_func, arraySlice(arr1, index, length), ...)`.\n@@ -1127,56 +1123,6 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n-## arrayFold\n-\n-Applies a lambda function to one or more equally-sized arrays and collects the result in an accumulator.\n-\n-**Syntax**\n-\n-``` sql\n-arrayFold(lambda_function, arr1, arr2, ..., accumulator)\n-```\n-\n-**Example**\n-\n-Query:\n-\n-``` sql\n-SELECT arrayFold( acc,x -> acc + x*2,  [1, 2, 3, 4], toInt64(3)) AS res;\n-```\n-\n-Result:\n-\n-``` text\n-\u250c\u2500res\u2500\u2510\n-\u2502  23 \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n-```\n-\n-**Example with the Fibonacci sequence**\n-\n-```sql\n-SELECT arrayFold( acc,x -> (acc.2, acc.2 + acc.1), range(number), (1::Int64, 0::Int64)).1 AS fibonacci\n-FROM numbers(1,10);\n-\n-\u250c\u2500fibonacci\u2500\u2510\n-\u2502         0 \u2502\n-\u2502         1 \u2502\n-\u2502         1 \u2502\n-\u2502         2 \u2502\n-\u2502         3 \u2502\n-\u2502         5 \u2502\n-\u2502         8 \u2502\n-\u2502        13 \u2502\n-\u2502        21 \u2502\n-\u2502        34 \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n-```\n-\n-**See also**\n-\n-- [arrayReduce](#arrayreduce)\n-\n ## arrayReverse(arr)\n \n Returns an array of the same size as the original array containing the elements in reverse order.\ndiff --git a/src/Functions/array/arrayFold.cpp b/src/Functions/array/arrayFold.cpp\ndeleted file mode 100644\nindex b5b650e72897..000000000000\n--- a/src/Functions/array/arrayFold.cpp\n+++ /dev/null\n@@ -1,236 +0,0 @@\n-#include \"FunctionArrayMapped.h\"\n-#include <Functions/FunctionFactory.h>\n-#include <Common/Exception.h>\n-\n-namespace DB\n-{\n-\n-namespace ErrorCodes\n-{\n-    extern const int ILLEGAL_COLUMN;\n-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n-    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n-    extern const int SIZES_OF_ARRAYS_DONT_MATCH;\n-    extern const int TYPE_MISMATCH;\n-}\n-\n-/**\n- * arrayFold(x1,...,xn,accum -> expression, array1,...,arrayn, accum_initial) - apply the expression to each element of the array (or set of arrays).\n- */\n-class ArrayFold : public IFunction\n-{\n-public:\n-    static constexpr auto name = \"arrayFold\";\n-    static FunctionPtr create(ContextPtr) { return std::make_shared<ArrayFold>(); }\n-\n-    bool isVariadic() const override { return true; }\n-    size_t getNumberOfArguments() const override { return 0; }\n-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n-\n-    void getLambdaArgumentTypes(DataTypes & arguments) const override\n-    {\n-        if (arguments.size() < 3)\n-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Function {} requires as arguments a lambda function, at least one array and an accumulator\", getName());\n-\n-        DataTypes accumulator_and_array_types(arguments.size() - 1);\n-        accumulator_and_array_types[0] = arguments.back();\n-        for (size_t i = 1; i < accumulator_and_array_types.size(); ++i)\n-        {\n-            const auto * array_type = checkAndGetDataType<DataTypeArray>(&*arguments[i]);\n-            if (!array_type)\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Argument {} of function {} must be of type Array, found {} instead\", i + 1, getName(), arguments[i]->getName());\n-            accumulator_and_array_types[i] = recursiveRemoveLowCardinality(array_type->getNestedType());\n-        }\n-\n-        const auto * lambda_function_type = checkAndGetDataType<DataTypeFunction>(arguments[0].get());\n-        if (!lambda_function_type || lambda_function_type->getArgumentTypes().size() != accumulator_and_array_types.size())\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"First argument of function {} must be a lambda function with {} arguments, found {} instead.\",\n-                            getName(), accumulator_and_array_types.size(), arguments[0]->getName());\n-\n-        arguments[0] = std::make_shared<DataTypeFunction>(accumulator_and_array_types);\n-    }\n-\n-    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n-    {\n-        if (arguments.size() < 3)\n-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Function {} requires as arguments a lambda function, at least one array and an accumulator\", getName());\n-\n-        const auto * lambda_function_type = checkAndGetDataType<DataTypeFunction>(arguments[0].type.get());\n-        if (!lambda_function_type)\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"First argument for function {} must be a function\", getName());\n-\n-        auto accumulator_type = arguments.back().type;\n-        auto lambda_type = lambda_function_type->getReturnType();\n-        if (!accumulator_type->equals(*lambda_type))\n-            throw Exception(ErrorCodes::TYPE_MISMATCH,\n-                    \"Return type of lambda function must be the same as the accumulator type, inferred return type of lambda: {}, inferred type of accumulator: {}\",\n-                    lambda_type->getName(), accumulator_type->getName());\n-\n-        return accumulator_type;\n-    }\n-\n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n-    {\n-        const auto & lambda_function_with_type_and_name = arguments[0];\n-\n-        if (!lambda_function_with_type_and_name.column)\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"First argument for function {} must be a function\", getName());\n-\n-        const auto * lambda_function = typeid_cast<const ColumnFunction *>(lambda_function_with_type_and_name.column.get());\n-        if (!lambda_function)\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"First argument for function {} must be a function\", getName());\n-\n-        ColumnPtr offsets_column;\n-        ColumnPtr column_first_array_ptr;\n-        const ColumnArray * column_first_array = nullptr;\n-        ColumnsWithTypeAndName arrays;\n-        arrays.reserve(arguments.size() - 1);\n-\n-        /// Validate input types and get input array columns in convenient form\n-        for (size_t i = 1; i < arguments.size() - 1; ++i)\n-        {\n-            const auto & array_with_type_and_name = arguments[i];\n-            ColumnPtr column_array_ptr = array_with_type_and_name.column;\n-            const auto * column_array = checkAndGetColumn<ColumnArray>(column_array_ptr.get());\n-            if (!column_array)\n-            {\n-                const ColumnConst * column_const_array = checkAndGetColumnConst<ColumnArray>(column_array_ptr.get());\n-                if (!column_const_array)\n-                    throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Expected array column, found {}\", column_array_ptr->getName());\n-                column_array_ptr = recursiveRemoveLowCardinality(column_const_array->convertToFullColumn());\n-                column_array = checkAndGetColumn<ColumnArray>(column_array_ptr.get());\n-            }\n-\n-            const DataTypePtr & array_type_ptr = array_with_type_and_name.type;\n-            const auto * array_type = checkAndGetDataType<DataTypeArray>(array_type_ptr.get());\n-            if (!array_type)\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Expected array type, found {}\", array_type_ptr->getName());\n-\n-            if (!offsets_column)\n-                offsets_column = column_array->getOffsetsPtr();\n-            else\n-            {\n-                /// The first condition is optimization: do not compare data if the pointers are equal.\n-                if (column_array->getOffsetsPtr() != offsets_column\n-                    && column_array->getOffsets() != typeid_cast<const ColumnArray::ColumnOffsets &>(*offsets_column).getData())\n-                    throw Exception(ErrorCodes::SIZES_OF_ARRAYS_DONT_MATCH, \"Arrays passed to {} must have equal size\", getName());\n-            }\n-            if (i == 1)\n-            {\n-                column_first_array_ptr = column_array_ptr;\n-                column_first_array = column_array;\n-            }\n-            arrays.emplace_back(ColumnWithTypeAndName(column_array->getDataPtr(),\n-                                                      recursiveRemoveLowCardinality(array_type->getNestedType()),\n-                                                      array_with_type_and_name.name));\n-        }\n-\n-        ssize_t rows_count = input_rows_count;\n-        ssize_t data_row_count = arrays[0].column->size();\n-        size_t array_count = arrays.size();\n-\n-        if (rows_count == 0)\n-            return arguments.back().column->convertToFullColumnIfConst()->cloneEmpty();\n-\n-        ColumnPtr current_column = arguments.back().column->convertToFullColumnIfConst();\n-        MutableColumnPtr result_data = arguments.back().column->convertToFullColumnIfConst()->cloneEmpty();\n-\n-        size_t max_array_size = 0;\n-        const auto & offsets = column_first_array->getOffsets();\n-\n-        IColumn::Selector selector(data_row_count);\n-        size_t cur_ind = 0;\n-        ssize_t cur_arr = 0;\n-\n-        /// skip to the first non empty array\n-        if (data_row_count)\n-            while (offsets[cur_arr] == 0)\n-                ++cur_arr;\n-\n-        /// selector[i] is an index that i_th data element has in an array it corresponds to\n-        for (ssize_t i = 0; i < data_row_count; ++i)\n-        {\n-            selector[i] = cur_ind;\n-            cur_ind++;\n-            if (cur_ind > max_array_size)\n-                max_array_size = cur_ind;\n-            while (cur_arr < rows_count && cur_ind >= offsets[cur_arr] - offsets[cur_arr - 1])\n-            {\n-                ++cur_arr;\n-                cur_ind = 0;\n-            }\n-        }\n-\n-        std::vector<MutableColumns> data_arrays;\n-        data_arrays.resize(array_count);\n-\n-        /// Split each data column to columns containing elements of only Nth index in array\n-        if (max_array_size > 0)\n-            for (size_t i = 0; i < array_count; ++i)\n-                data_arrays[i] = arrays[i].column->scatter(max_array_size, selector);\n-\n-        size_t prev_size = rows_count;\n-\n-        IColumn::Permutation inverse_permutation(rows_count);\n-        size_t inverse_permutation_count = 0;\n-\n-        /// current_column after each iteration contains value of accumulator after applying values under indexes of arrays.\n-        /// At each iteration only rows of current_column with arrays that still has unapplied elements are kept.\n-        /// Discarded rows which contain finished calculations are added to result_data column and as we insert them we save their original row_number in inverse_permutation vector\n-        for (size_t ind = 0; ind < max_array_size; ++ind)\n-        {\n-            IColumn::Selector prev_selector(prev_size);\n-            size_t prev_ind = 0;\n-            for (ssize_t irow = 0; irow < rows_count; ++irow)\n-            {\n-                if (offsets[irow] - offsets[irow - 1] > ind)\n-                    prev_selector[prev_ind++] = 1;\n-                else if (offsets[irow] - offsets[irow - 1] == ind)\n-                {\n-                    inverse_permutation[inverse_permutation_count++] = irow;\n-                    prev_selector[prev_ind++] = 0;\n-                }\n-            }\n-            auto prev = current_column->scatter(2, prev_selector);\n-\n-            result_data->insertRangeFrom(*(prev[0]), 0, prev[0]->size());\n-\n-            auto res_lambda = lambda_function->cloneResized(prev[1]->size());\n-            auto * res_lambda_ptr = typeid_cast<ColumnFunction *>(res_lambda.get());\n-\n-            res_lambda_ptr->appendArguments(std::vector({ColumnWithTypeAndName(std::move(prev[1]), arguments.back().type, arguments.back().name)}));\n-            for (size_t i = 0; i < array_count; i++)\n-                res_lambda_ptr->appendArguments(std::vector({ColumnWithTypeAndName(std::move(data_arrays[i][ind]), arrays[i].type, arrays[i].name)}));\n-\n-            current_column = IColumn::mutate(res_lambda_ptr->reduce().column);\n-            prev_size = current_column->size();\n-        }\n-\n-        result_data->insertRangeFrom(*current_column, 0, current_column->size());\n-        for (ssize_t irow = 0; irow < rows_count; ++irow)\n-            if (offsets[irow] - offsets[irow - 1] == max_array_size)\n-                inverse_permutation[inverse_permutation_count++] = irow;\n-\n-        /// We have result_data containing result for every row and inverse_permutation which contains indexes of rows in input it corresponds to.\n-        /// Now we need to invert inverse_permuation and apply it to result_data to get rows in right order.\n-        IColumn::Permutation perm(rows_count);\n-        for (ssize_t i = 0; i < rows_count; i++)\n-            perm[inverse_permutation[i]] = i;\n-        return result_data->permute(perm, 0);\n-    }\n-\n-private:\n-    String getName() const override\n-    {\n-        return name;\n-    }\n-};\n-\n-REGISTER_FUNCTION(ArrayFold)\n-{\n-    factory.registerFunction<ArrayFold>(FunctionDocumentation{.description=R\"(\n-        Function arrayFold(x1,...,xn,accum -> expression, array1,...,arrayn, accum_initial) applies lambda function to a number of equally-sized arrays\n-        and collects the result in an accumulator.\n-        )\", .examples{{\"sum\", \"SELECT arrayFold(x,acc -> acc+x, [1,2,3,4], toInt64(1));\", \"11\"}}, .categories{\"Array\"}});\n-}\n-}\n",
  "test_patch": "diff --git a/tests/performance/array_fold.xml b/tests/performance/array_fold.xml\ndeleted file mode 100644\nindex 32bd45beb1ec..000000000000\n--- a/tests/performance/array_fold.xml\n+++ /dev/null\n@@ -1,5 +0,0 @@\n-<test>\n-    <query>SELECT arrayFold((acc, x) -> acc + x, range(number % 100), toUInt64(0)) from numbers(100000) Format Null</query>\n-    <query>SELECT arrayFold((acc, x) -> acc + 1, range(number % 100), toUInt64(0)) from numbers(100000) Format Null</query>\n-    <query>SELECT arrayFold((acc, x) -> acc + x, range(number), toUInt64(0)) from numbers(10000) Format Null</query>\n-</test>\ndiff --git a/tests/queries/0_stateless/02718_array_fold.reference b/tests/queries/0_stateless/02718_array_fold.reference\ndeleted file mode 100644\nindex 4139232d145e..000000000000\n--- a/tests/queries/0_stateless/02718_array_fold.reference\n+++ /dev/null\n@@ -1,25 +0,0 @@\n-Negative tests\n-Const arrays\n-23\n-3\n-101\n-[1,2,3,4]\n-[4,3,2,1]\n-([4,3,2,1],[1,2,3,4])\n-([1,3,5],[2,4,6])\n-Non-const arrays\n-0\n-1\n-3\n-6\n-10\n-[]\n-[0]\n-[1,0]\n-[2,1,0]\n-[3,2,1,0]\n-[]\n-[0]\n-[1,0]\n-[1,0,2]\n-[3,1,0,2]\ndiff --git a/tests/queries/0_stateless/02718_array_fold.sql b/tests/queries/0_stateless/02718_array_fold.sql\ndeleted file mode 100644\nindex 0486a5ce2e36..000000000000\n--- a/tests/queries/0_stateless/02718_array_fold.sql\n+++ /dev/null\n@@ -1,24 +0,0 @@\n-SELECT 'Negative tests';\n-SELECT arrayFold(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n-SELECT arrayFold(1); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n-SELECT arrayFold(1, toUInt64(0)); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n-SELECT arrayFold(1, emptyArrayUInt64(), toUInt64(0)); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n-SELECT arrayFold( acc,x -> x,  emptyArrayString(), toInt8(0)); -- { serverError TYPE_MISMATCH }\n-SELECT arrayFold( acc,x -> x,  'not an array', toUInt8(0)); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n-SELECT arrayFold( acc,x,y -> x,  [0, 1], 'not an array', toUInt8(0)); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n-SELECT arrayFold( acc,x -> x,  [0, 1], [2, 3], toUInt8(0)); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n-SELECT arrayFold( acc,x,y -> x,  [0, 1], [2, 3, 4], toUInt8(0)); -- { serverError SIZES_OF_ARRAYS_DONT_MATCH }\n-\n-SELECT 'Const arrays';\n-SELECT arrayFold( acc,x -> acc+x*2,  [1, 2, 3, 4], toInt64(3));\n-SELECT arrayFold( acc,x -> acc+x*2,  emptyArrayInt64(), toInt64(3));\n-SELECT arrayFold( acc,x,y -> acc+x*2+y*3,  [1, 2, 3, 4], [5, 6, 7, 8], toInt64(3));\n-SELECT arrayFold( acc,x -> arrayPushBack(acc, x),  [1, 2, 3, 4], emptyArrayInt64());\n-SELECT arrayFold( acc,x -> arrayPushFront(acc, x),  [1, 2, 3, 4], emptyArrayInt64());\n-SELECT arrayFold( acc,x -> (arrayPushFront(acc.1, x),arrayPushBack(acc.2, x)),  [1, 2, 3, 4], (emptyArrayInt64(), emptyArrayInt64()));\n-SELECT arrayFold( acc,x -> x%2 ? (arrayPushBack(acc.1, x), acc.2): (acc.1, arrayPushBack(acc.2, x)),  [1, 2, 3, 4, 5, 6], (emptyArrayInt64(), emptyArrayInt64()));\n-\n-SELECT 'Non-const arrays';\n-SELECT arrayFold( acc,x -> acc+x,  range(number), number) FROM system.numbers LIMIT 5;\n-SELECT arrayFold( acc,x -> arrayPushFront(acc,x),  range(number), emptyArrayUInt64()) FROM system.numbers LIMIT 5;\n-SELECT arrayFold( acc,x -> x%2 ? arrayPushFront(acc,x) : arrayPushBack(acc,x),  range(number), emptyArrayUInt64()) FROM system.numbers LIMIT 5;\n",
  "problem_statement": "position function behaves incorrectly when used with arrayFold\n**Describe what's wrong**\r\n\r\n`position` function behaves incorrectly when used with `arrayFold` - fails to search string. I've verified all other intermediate states of `arrayFold` and other functions used are correct.\r\n\r\nhttps://fiddle.clickhouse.com/80adfdb5-f671-4d8a-bb27-49d6fdfdada7\r\n\r\n`position` function seems to fail string search and return 0 (substring not found).\r\n\r\n**Does it reproduce on recent release?**\r\n\r\nConfirmed on 23.10.3.1 on server as well as clickhouse-local\r\n\r\n**How to reproduce**\r\n\r\nrefer to clickhouse fiddle - has a minimal reproducible setup\r\n\r\n**Expected behavior**\r\n\r\nIt should return the correct position of the substring.\r\n\r\n**Additional context**\r\n\r\nI am using the nix version of clickhouse but seeing it's also reproducible on fiddle, I don't think that's relevant to the issue.\r\n\r\n---\r\n*offtopic: I spent multiple hours figuring out why it isn't working. If you're wondering how I found this bug, I was trying to solve this years' advent of code with clickhouse - helps to learn a lot of the cool functions ClickHouse offers! (also I'm slightly deranged).*\r\n\narrayFold of arrayIntersect segfault\nThis little query breaks clickhouse. It works on arm64 macos local, it works on amd64 linux server, it works on fresh installed version.\r\n\r\n```\r\n$ clickhouse local\r\nClickHouse local version 23.12.1.457 (official build).\r\n\r\nair.local :) SELECT arrayFold(acc, x -> arrayIntersect(acc, x), [['qwe', 'asd'], ['qwe','asde']], [])\r\n\r\nSELECT arrayFold((acc, x) -> arrayIntersect(acc, x), [['qwe', 'asd'], ['qwe', 'asde']], [])\r\n\r\nQuery id: 660a9bd1-2975-49b8-ba29-35bcfce5901c\r\n\r\nAbort trap: 6\r\n```\n",
  "hints_text": "Simpler repro: https://fiddle.clickhouse.com/1b5a7741-b441-4a8f-819d-1ea62e79ce38\r\n\r\n@Lirikl There is a problem with `arrayFold()`, added with #49794, maybe you like to have a look?\nVia gdb:\r\n\r\n```\r\n#0  DB::ColumnArray::insertRangeFrom (this=0x70200002f840, src=..., start=0, length=1) at ./build_msan/./src/Columns/ColumnArray.cpp:521\r\n#1  0x000055557469539b in DB::ArrayFold::executeImpl(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long) const ()\r\n#2  0x000055555d23e598 in DB::FunctionToExecutableFunctionAdaptor::executeImpl(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long) const\r\n    ()\r\n#3  0x000055558790b598 in DB::IExecutableFunction::executeWithoutLowCardinalityColumns (this=this@entry=0x70200006d800, args=..., result_type=..., input_rows_count=input_rows_count@entry=1, dry_run=false)\r\n    at ./build_msan/./src/Functions/IFunction.cpp:248\r\n#4  0x000055558790d6b1 in DB::IExecutableFunction::executeWithoutSparseColumns (this=this@entry=0x70200006d800, arguments=..., result_type=..., input_rows_count=input_rows_count@entry=1, dry_run=false) at ./build_msan/./src/Functions/IFunction.cpp:303\r\n#5  0x0000555587913d17 in DB::IExecutableFunction::execute (this=0x70200006d800, arguments=..., result_type=..., input_rows_count=1, dry_run=false) at ./build_msan/./src/Functions/IFunction.cpp:378\r\n#6  0x000055558b8c67d8 in DB::executeAction (action=..., execution_context=..., dry_run=false) at ./build_msan/./src/Interpreters/ExpressionActions.cpp:613\r\n#7  DB::ExpressionActions::execute (this=0x7110000ea398, block=..., num_rows=@0x7ffee8772100: 1, dry_run=false) at ./build_msan/./src/Interpreters/ExpressionActions.cpp:730\r\n#8  0x0000555592af616e in DB::ExpressionTransform::transform (this=0x71200021e898, chunk=...) at ./build_msan/./src/Processors/Transforms/ExpressionTransform.cpp:23\r\n#9  0x000055557d4813e1 in DB::ISimpleTransform::transform (this=0x0, input_chunk=..., output_chunk=...) at ./src/Processors/ISimpleTransform.h:32\r\n#10 0x0000555592038f26 in DB::ISimpleTransform::work (this=0x71200021e898) at ./build_msan/./src/Processors/ISimpleTransform.cpp:89\r\n#11 0x00005555920a156e in DB::executeJob (node=0x710000017500, read_progress_callback=0x70a0000370a0) at ./build_msan/./src/Processors/Executors/ExecutionThreadContext.cpp:47\r\n#12 DB::ExecutionThreadContext::executeTask (this=<optimized out>) at ./build_msan/./src/Processors/Executors/ExecutionThreadContext.cpp:95\r\n```\r\n\r\n```\r\n(gdb) p typeid(src)\r\n$9 = {_vptr$type_info = 0x55559d7f3a50 <vtable for __cxxabiv1::__si_class_type_info+16>, __type_name = 0x55555825e064 <typeinfo name for DB::ColumnConst> \"N2DB11ColumnConstE\"}\r\n```\r\n\r\nThe column is `const` not `array`, so the assert fails. If asserts are disabled, it will crash if you are lucky (or corrupt things if not)\r\n\r\ncc @rschu1ze @Lirikl \nThe longer version also works. I mean, I've encountered the bug on real tables with real data.\r\n```\r\n$ clickhouse local\r\nClickHouse local version 23.12.1.116 (official build).\r\n\r\nair.local :) CREATE TABLE q (id UInt32, arr Array(String)) ENGINE GenerateRandom(0, 10, 20)\r\n\r\nCREATE TABLE q\r\n(\r\n    `id` UInt32,\r\n    `arr` Array(String)\r\n)\r\nENGINE = GenerateRandom(0, 10, 20)\r\n\r\nQuery id: 0bbc04b0-9d87-48f3-9264-7d8926db5dc4\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.000 sec.\r\n\r\nair.local :) SELECT id, arrayFold(acc, x -> arrayIntersect(acc, x), groupArray(arr), []) AS u FROM (SELECT * FROM q LIMIT 5) GROUP BY id\r\n\r\nSELECT\r\n    id,\r\n    arrayFold((acc, x) -> arrayIntersect(acc, x), groupArray(arr), []) AS u\r\nFROM\r\n(\r\n    SELECT *\r\n    FROM q\r\n    LIMIT 5\r\n)\r\nGROUP BY id\r\n\r\nQuery id: 84246678-9c81-4078-991d-fc785dac5f07\r\n\r\nAbort trap: 6\r\n```",
  "created_at": "2023-12-14T03:35:13Z",
  "modified_files": [
    "docs/en/sql-reference/functions/array-functions.md",
    "src/Functions/array/arrayFold.cpp"
  ],
  "modified_test_files": [
    "tests/performance/array_fold.xml",
    "tests/queries/0_stateless/02718_array_fold.reference",
    "tests/queries/0_stateless/02718_array_fold.sql"
  ]
}