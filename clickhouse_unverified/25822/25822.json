{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25822,
  "instance_id": "ClickHouse__ClickHouse-25822",
  "issue_numbers": [
    "23708"
  ],
  "base_commit": "bf1af34e5d03ccb4a0f8a85ec1359b803240e49a",
  "patch": "diff --git a/src/Databases/DatabaseLazy.cpp b/src/Databases/DatabaseLazy.cpp\nindex 28f9372a61eb..abcb8dbb9745 100644\n--- a/src/Databases/DatabaseLazy.cpp\n+++ b/src/Databases/DatabaseLazy.cpp\n@@ -305,12 +305,12 @@ void DatabaseLazy::clearExpiredTables() const\n \n \n DatabaseLazyIterator::DatabaseLazyIterator(DatabaseLazy & database_, Strings && table_names_)\n-    : database(database_)\n+    : IDatabaseTablesIterator(database_.database_name)\n+    , database(database_)\n     , table_names(std::move(table_names_))\n     , iterator(table_names.begin())\n     , current_storage(nullptr)\n {\n-    database_name = database.database_name;\n }\n \n void DatabaseLazyIterator::next()\ndiff --git a/src/Databases/IDatabase.h b/src/Databases/IDatabase.h\nindex ba5fa974d5c4..0c8382465f79 100644\n--- a/src/Databases/IDatabase.h\n+++ b/src/Databases/IDatabase.h\n@@ -45,6 +45,9 @@ class IDatabaseTablesIterator\n     /// - it maintains a list of tables but tables are loaded lazily).\n     virtual const StoragePtr & table() const = 0;\n \n+    IDatabaseTablesIterator(const String & database_name_) : database_name(database_name_) { }\n+    IDatabaseTablesIterator(String && database_name_) : database_name(std::move(database_name_)) { }\n+\n     virtual ~IDatabaseTablesIterator() = default;\n \n     virtual UUID uuid() const { return UUIDHelpers::Nil; }\n@@ -52,7 +55,7 @@ class IDatabaseTablesIterator\n     const String & databaseName() const { assert(!database_name.empty()); return database_name; }\n \n protected:\n-    String database_name;\n+    const String database_name;\n };\n \n /// Copies list of tables and iterates through such snapshot.\n@@ -64,26 +67,24 @@ class DatabaseTablesSnapshotIterator : public IDatabaseTablesIterator\n \n protected:\n     DatabaseTablesSnapshotIterator(DatabaseTablesSnapshotIterator && other)\n+    : IDatabaseTablesIterator(std::move(other.database_name))\n     {\n         size_t idx = std::distance(other.tables.begin(), other.it);\n         std::swap(tables, other.tables);\n         other.it = other.tables.end();\n         it = tables.begin();\n         std::advance(it, idx);\n-        database_name = std::move(other.database_name);\n     }\n \n public:\n     DatabaseTablesSnapshotIterator(const Tables & tables_, const String & database_name_)\n-    : tables(tables_), it(tables.begin())\n+    : IDatabaseTablesIterator(database_name_), tables(tables_), it(tables.begin())\n     {\n-        database_name = database_name_;\n     }\n \n     DatabaseTablesSnapshotIterator(Tables && tables_, String && database_name_)\n-    : tables(std::move(tables_)), it(tables.begin())\n+    : IDatabaseTablesIterator(std::move(database_name_)), tables(std::move(tables_)), it(tables.begin())\n     {\n-        database_name = std::move(database_name_);\n     }\n \n     void next() override { ++it; }\ndiff --git a/src/Databases/MySQL/DatabaseMaterializeMySQL.h b/src/Databases/MySQL/DatabaseMaterializeMySQL.h\nindex 74a3c06e6f04..d07810e6416b 100644\n--- a/src/Databases/MySQL/DatabaseMaterializeMySQL.h\n+++ b/src/Databases/MySQL/DatabaseMaterializeMySQL.h\n@@ -66,6 +66,8 @@ class DatabaseMaterializeMySQL : public Base\n     void assertCalledFromSyncThreadOrDrop(const char * method) const;\n \n     void shutdownSynchronizationThread();\n+\n+    friend class DatabaseMaterializeTablesIterator;\n };\n \n \ndiff --git a/src/Databases/MySQL/DatabaseMaterializeTablesIterator.h b/src/Databases/MySQL/DatabaseMaterializeTablesIterator.h\nindex 54031de40a25..a3d49077baa2 100644\n--- a/src/Databases/MySQL/DatabaseMaterializeTablesIterator.h\n+++ b/src/Databases/MySQL/DatabaseMaterializeTablesIterator.h\n@@ -30,7 +30,7 @@ class DatabaseMaterializeTablesIterator final : public IDatabaseTablesIterator\n     UUID uuid() const override { return nested_iterator->uuid(); }\n \n     DatabaseMaterializeTablesIterator(DatabaseTablesIteratorPtr nested_iterator_, const IDatabase * database_)\n-        : nested_iterator(std::move(nested_iterator_)), database(database_)\n+        : IDatabaseTablesIterator(database_->getDatabaseName()), nested_iterator(std::move(nested_iterator_)), database(database_)\n     {\n     }\n \ndiff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex 55888cd1afd7..79e60a9a02cc 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -388,6 +388,9 @@ InterpreterSelectQuery::InterpreterSelectQuery(\n \n         query_info.syntax_analyzer_result = syntax_analyzer_result;\n \n+        if (storage && !query.final() && storage->needRewriteQueryWithFinal(syntax_analyzer_result->requiredSourceColumns()))\n+            query.setFinal();\n+\n         /// Save scalar sub queries's results in the query context\n         if (!options.only_analyze && context->hasQueryContext())\n             for (const auto & it : syntax_analyzer_result->getScalars())\ndiff --git a/src/Parsers/ASTSelectQuery.cpp b/src/Parsers/ASTSelectQuery.cpp\nindex 84a2e1070d6c..7699d3806239 100644\n--- a/src/Parsers/ASTSelectQuery.cpp\n+++ b/src/Parsers/ASTSelectQuery.cpp\n@@ -438,4 +438,19 @@ ASTPtr & ASTSelectQuery::getExpression(Expression expr)\n     return children[positions[expr]];\n }\n \n+void ASTSelectQuery::setFinal() // NOLINT method can be made const\n+{\n+    auto & tables_in_select_query = tables()->as<ASTTablesInSelectQuery &>();\n+\n+    if (tables_in_select_query.children.empty())\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Tables list is empty, it's a bug\");\n+\n+    auto & tables_element = tables_in_select_query.children[0]->as<ASTTablesInSelectQueryElement &>();\n+\n+    if (!tables_element.table_expression)\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"There is no table expression, it's a bug\");\n+\n+    tables_element.table_expression->as<ASTTableExpression &>().final = true;\n+}\n+\n }\ndiff --git a/src/Parsers/ASTSelectQuery.h b/src/Parsers/ASTSelectQuery.h\nindex 3fc8efb53114..db4d7e763209 100644\n--- a/src/Parsers/ASTSelectQuery.h\n+++ b/src/Parsers/ASTSelectQuery.h\n@@ -93,6 +93,8 @@ class ASTSelectQuery : public IAST\n     void addTableFunction(ASTPtr & table_function_ptr);\n     void updateTreeHashImpl(SipHash & hash_state) const override;\n \n+    void setFinal();\n+\n protected:\n     void formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const override;\n \ndiff --git a/src/Storages/IStorage.h b/src/Storages/IStorage.h\nindex 2d6109bd7aff..5d1771f48b79 100644\n--- a/src/Storages/IStorage.h\n+++ b/src/Storages/IStorage.h\n@@ -272,6 +272,10 @@ class IStorage : public std::enable_shared_from_this<IStorage>, public TypePromo\n         throw Exception(\"Method watch is not supported by storage \" + getName(), ErrorCodes::NOT_IMPLEMENTED);\n     }\n \n+    /// Returns true if FINAL modifier must be added to SELECT query depending on required columns.\n+    /// It's needed for ReplacingMergeTree wrappers such as MaterializedMySQL and MaterializedPostrgeSQL\n+    virtual bool needRewriteQueryWithFinal(const Names & /*column_names*/) const { return false; }\n+\n     /** Read a set of columns from the table.\n       * Accepts a list of columns to read, as well as a description of the query,\n       *  from which information can be extracted about how to retrieve data\ndiff --git a/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp b/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp\nindex 2fa96ac5cf21..e24e252bf016 100644\n--- a/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp\n+++ b/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp\n@@ -256,6 +256,12 @@ NamesAndTypesList StorageMaterializedPostgreSQL::getVirtuals() const\n }\n \n \n+bool StorageMaterializedPostgreSQL::needRewriteQueryWithFinal(const Names & column_names) const\n+{\n+    return needRewriteQueryWithFinalForStorage(column_names, getNested());\n+}\n+\n+\n Pipe StorageMaterializedPostgreSQL::read(\n         const Names & column_names,\n         const StorageMetadataPtr & metadata_snapshot,\ndiff --git a/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.h b/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.h\nindex 5d18a0b16b7b..becb4f6ba10f 100644\n--- a/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.h\n+++ b/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.h\n@@ -82,6 +82,8 @@ class StorageMaterializedPostgreSQL final : public shared_ptr_helper<StorageMate\n \n     NamesAndTypesList getVirtuals() const override;\n \n+    bool needRewriteQueryWithFinal(const Names & column_names) const override;\n+\n     Pipe read(\n         const Names & column_names,\n         const StorageMetadataPtr & metadata_snapshot,\n@@ -119,6 +121,8 @@ class StorageMaterializedPostgreSQL final : public shared_ptr_helper<StorageMate\n     /// for current table, set has_nested = true.\n     StoragePtr prepare();\n \n+    bool supportsFinal() const override { return true; }\n+\n protected:\n     StorageMaterializedPostgreSQL(\n         const StorageID & table_id_,\ndiff --git a/src/Storages/ReadFinalForExternalReplicaStorage.cpp b/src/Storages/ReadFinalForExternalReplicaStorage.cpp\nindex fb96bb019368..36a40beca36f 100644\n--- a/src/Storages/ReadFinalForExternalReplicaStorage.cpp\n+++ b/src/Storages/ReadFinalForExternalReplicaStorage.cpp\n@@ -16,6 +16,14 @@\n namespace DB\n {\n \n+bool needRewriteQueryWithFinalForStorage(const Names & column_names, const StoragePtr & storage)\n+{\n+    const StorageMetadataPtr & metadata = storage->getInMemoryMetadataPtr();\n+    Block header = metadata->getSampleBlock();\n+    ColumnWithTypeAndName & version_column = header.getByPosition(header.columns() - 1);\n+    return std::find(column_names.begin(), column_names.end(), version_column.name) == column_names.end();\n+}\n+\n Pipe readFinalFromNestedStorage(\n     StoragePtr nested_storage,\n     const Names & column_names,\n@@ -32,20 +40,6 @@ Pipe readFinalFromNestedStorage(\n \n     Block nested_header = nested_metadata->getSampleBlock();\n     ColumnWithTypeAndName & sign_column = nested_header.getByPosition(nested_header.columns() - 2);\n-    ColumnWithTypeAndName & version_column = nested_header.getByPosition(nested_header.columns() - 1);\n-\n-    if (ASTSelectQuery * select_query = query_info.query->as<ASTSelectQuery>(); select_query && !column_names_set.count(version_column.name))\n-    {\n-        auto & tables_in_select_query = select_query->tables()->as<ASTTablesInSelectQuery &>();\n-\n-        if (!tables_in_select_query.children.empty())\n-        {\n-            auto & tables_element = tables_in_select_query.children[0]->as<ASTTablesInSelectQueryElement &>();\n-\n-            if (tables_element.table_expression)\n-                tables_element.table_expression->as<ASTTableExpression &>().final = true;\n-        }\n-    }\n \n     String filter_column_name;\n     Names require_columns_name = column_names;\n@@ -59,9 +53,6 @@ Pipe readFinalFromNestedStorage(\n \n         expressions->children.emplace_back(makeASTFunction(\"equals\", sign_column_name, fetch_sign_value));\n         filter_column_name = expressions->children.back()->getColumnName();\n-\n-        for (const auto & column_name : column_names)\n-            expressions->children.emplace_back(std::make_shared<ASTIdentifier>(column_name));\n     }\n \n     Pipe pipe = nested_storage->read(require_columns_name, nested_metadata, query_info, context, processed_stage, max_block_size, num_streams);\ndiff --git a/src/Storages/ReadFinalForExternalReplicaStorage.h b/src/Storages/ReadFinalForExternalReplicaStorage.h\nindex b54592159ef2..f09a115919dc 100644\n--- a/src/Storages/ReadFinalForExternalReplicaStorage.h\n+++ b/src/Storages/ReadFinalForExternalReplicaStorage.h\n@@ -13,6 +13,8 @@\n namespace DB\n {\n \n+bool needRewriteQueryWithFinalForStorage(const Names & column_names, const StoragePtr & storage);\n+\n Pipe readFinalFromNestedStorage(\n     StoragePtr nested_storage,\n     const Names & column_names,\ndiff --git a/src/Storages/StorageMaterializeMySQL.cpp b/src/Storages/StorageMaterializeMySQL.cpp\nindex 5b371fe3fb81..220d77b104aa 100644\n--- a/src/Storages/StorageMaterializeMySQL.cpp\n+++ b/src/Storages/StorageMaterializeMySQL.cpp\n@@ -36,6 +36,11 @@ StorageMaterializeMySQL::StorageMaterializeMySQL(const StoragePtr & nested_stora\n     setInMemoryMetadata(in_memory_metadata);\n }\n \n+bool StorageMaterializeMySQL::needRewriteQueryWithFinal(const Names & column_names) const\n+{\n+    return needRewriteQueryWithFinalForStorage(column_names, nested_storage);\n+}\n+\n Pipe StorageMaterializeMySQL::read(\n     const Names & column_names,\n     const StorageMetadataPtr & metadata_snapshot,\n@@ -47,6 +52,7 @@ Pipe StorageMaterializeMySQL::read(\n {\n     /// If the background synchronization thread has exception.\n     rethrowSyncExceptionIfNeed(database);\n+\n     return readFinalFromNestedStorage(nested_storage, column_names, metadata_snapshot,\n             query_info, context, processed_stage, max_block_size, num_streams);\n }\ndiff --git a/src/Storages/StorageMaterializeMySQL.h b/src/Storages/StorageMaterializeMySQL.h\nindex 45221ed5b76e..b0b7a877630e 100644\n--- a/src/Storages/StorageMaterializeMySQL.h\n+++ b/src/Storages/StorageMaterializeMySQL.h\n@@ -24,6 +24,8 @@ class StorageMaterializeMySQL final : public shared_ptr_helper<StorageMaterializ\n \n     StorageMaterializeMySQL(const StoragePtr & nested_storage_, const IDatabase * database_);\n \n+    bool needRewriteQueryWithFinal(const Names & column_names) const override;\n+\n     Pipe read(\n         const Names & column_names, const StorageMetadataPtr & metadata_snapshot, SelectQueryInfo & query_info,\n         ContextPtr context, QueryProcessingStage::Enum processed_stage, size_t max_block_size, unsigned num_streams) override;\ndiff --git a/src/Storages/StorageMerge.cpp b/src/Storages/StorageMerge.cpp\nindex 355b9335d9f2..43838b1d8c5d 100644\n--- a/src/Storages/StorageMerge.cpp\n+++ b/src/Storages/StorageMerge.cpp\n@@ -388,6 +388,13 @@ Pipe StorageMerge::createSources(\n         return pipe;\n     }\n \n+    if (!modified_select.final() && storage->needRewriteQueryWithFinal(real_column_names))\n+    {\n+        /// NOTE: It may not work correctly in some cases, because query was analyzed without final.\n+        /// However, it's needed for MaterializeMySQL and it's unlikely that someone will use it with Merge tables.\n+        modified_select.setFinal();\n+    }\n+\n     auto storage_stage\n         = storage->getQueryProcessingStage(modified_context, QueryProcessingStage::Complete, metadata_snapshot, modified_query_info);\n     if (processed_stage <= storage_stage)\n",
  "test_patch": "diff --git a/tests/integration/test_materialize_mysql_database/materialize_with_ddl.py b/tests/integration/test_materialize_mysql_database/materialize_with_ddl.py\nindex 3fd1cb0ecae5..71693148a17d 100644\n--- a/tests/integration/test_materialize_mysql_database/materialize_with_ddl.py\n+++ b/tests/integration/test_materialize_mysql_database/materialize_with_ddl.py\n@@ -944,7 +944,22 @@ def move_to_prewhere_and_column_filtering(clickhouse_node, mysql_node, service_n\n     clickhouse_node.query(\"CREATE DATABASE cond_on_key_col ENGINE = MaterializeMySQL('{}:3306', 'cond_on_key_col', 'root', 'clickhouse')\".format(service_name))\n     mysql_node.query(\"create table cond_on_key_col.products (id int primary key, product_id int not null, catalog_id int not null, brand_id int not null, name text)\")\n     mysql_node.query(\"insert into cond_on_key_col.products (id, name, catalog_id, brand_id, product_id) values (915, 'ertyui', 5287, 15837, 0), (990, 'wer', 1053, 24390, 1), (781, 'qwerty', 1041, 1176, 2);\")\n+    mysql_node.query(\"create table cond_on_key_col.test (id int(11) NOT NULL AUTO_INCREMENT, a int(11) DEFAULT NULL, b int(11) DEFAULT NULL, PRIMARY KEY (id)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4;\")\n+    mysql_node.query(\"insert into cond_on_key_col.test values (42, 123, 1);\")\n+    mysql_node.query(\"CREATE TABLE cond_on_key_col.balance_change_record (id bigint(20) NOT NULL AUTO_INCREMENT, type tinyint(4) DEFAULT NULL, value decimal(10,4) DEFAULT NULL, time timestamp NULL DEFAULT NULL, \"\n+                     \"initiative_id varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL, passivity_id varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL, \"\n+                     \"person_id varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL, tenant_code varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL, \"\n+                     \"created_time timestamp NULL DEFAULT CURRENT_TIMESTAMP COMMENT '\u521b\u5efa\u65f6\u95f4', updated_time timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, \"\n+                     \"value_snapshot decimal(10,4) DEFAULT NULL, PRIMARY KEY (id), KEY balance_change_record_initiative_id (person_id) USING BTREE, \"\n+                     \"KEY type (type) USING BTREE, KEY balance_change_record_type (time) USING BTREE, KEY initiative_id (initiative_id) USING BTREE, \"\n+                     \"KEY balance_change_record_tenant_code (passivity_id) USING BTREE, KEY tenant_code (tenant_code) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1691049 DEFAULT CHARSET=utf8\")\n+    mysql_node.query(\"insert into cond_on_key_col.balance_change_record values (123, 1, 3.14, null, 'qwe', 'asd', 'zxc', 'rty', null, null, 2.7);\")\n+    mysql_node.query(\"CREATE TABLE cond_on_key_col.test1 (id int(11) NOT NULL AUTO_INCREMENT, c1 varchar(32) NOT NULL, c2 varchar(32), PRIMARY KEY (id)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4\")\n+    mysql_node.query(\"insert into cond_on_key_col.test1(c1,c2) values ('a','b'), ('c', null);\")\n     check_query(clickhouse_node, \"SELECT DISTINCT P.id, P.name, P.catalog_id FROM cond_on_key_col.products P WHERE P.name ILIKE '%e%' and P.catalog_id=5287\", '915\\tertyui\\t5287\\n')\n+    check_query(clickhouse_node, \"select count(a) from cond_on_key_col.test where b = 1;\", \"1\\n\")\n+    check_query(clickhouse_node, \"select id from cond_on_key_col.balance_change_record where type=1;\", \"123\\n\")\n+    check_query(clickhouse_node, \"select count(c1) from cond_on_key_col.test1 where c2='b';\", \"1\\n\")\n     clickhouse_node.query(\"DROP DATABASE cond_on_key_col\")\n     mysql_node.query(\"DROP DATABASE cond_on_key_col\")\n \n",
  "problem_statement": "Another case encountered \"DB::Exception: Not found column xxx in block...\"  (MaterializeMySQL) \nI reported the issue #23470 a few days ago, now it is fine after upgrade to the latest stable version (version 21.4.5.46).\r\nBut encountered same error message \"`Code: 10. DB::Exception: Received from localhost:9000. DB::Exception: Not found column type in block: while executing 'INPUT : 1 -> type Nullable(Int8) : 1'`\" for another case...\r\n\r\nRefer to below two screenshots, it's fine if the column **type** exits in both 'select' and 'where' clause.\r\n![image](https://user-images.githubusercontent.com/44794448/116338305-1af1e100-a80e-11eb-83b4-ecf5e6201e33.png)\r\n![image](https://user-images.githubusercontent.com/44794448/116338498-660bf400-a80e-11eb-95c9-eed301352a1b.png)\r\n\r\nbut encountered the exception if the column **type** only exists in 'where' clause:\r\n![image](https://user-images.githubusercontent.com/44794448/116338467-5c828c00-a80e-11eb-9f81-20a551020f65.png)\r\n\n",
  "hints_text": "Could you please provide `CREATE TABLE` statement of this table?\n> Could you please provide `CREATE TABLE` statement of this table?\r\n\r\n### MySQL statement:\r\nCREATE TABLE `balance_change_record` (\r\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\r\n  `type` tinyint(4) DEFAULT NULL,\r\n  `value` decimal(10,4) DEFAULT NULL,\r\n  `time` timestamp NULL DEFAULT NULL,\r\n  `initiative_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL,\r\n  `passivity_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL,\r\n  `person_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL,\r\n  `tenant_code` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL,\r\n  `created_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP COMMENT '\u521b\u5efa\u65f6\u95f4',\r\n  `updated_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\r\n  `value_snapshot` decimal(10,4) DEFAULT NULL,\r\n  PRIMARY KEY (`id`),\r\n  KEY `balance_change_record_initiative_id` (`person_id`) USING BTREE,\r\n  KEY `type` (`type`) USING BTREE,\r\n  KEY `balance_change_record_type` (`time`) USING BTREE,\r\n  KEY `initiative_id` (`initiative_id`) USING BTREE,\r\n  KEY `balance_change_record_tenant_code` (`passivity_id`) USING BTREE,\r\n  KEY `tenant_code` (`tenant_code`) USING BTREE\r\n) ENGINE=InnoDB AUTO_INCREMENT=1691049 DEFAULT CHARSET=utf8\r\n\r\n### Clickhouse statement:\r\nCREATE TABLE gaia_acc_ajidou.balance_change_record\r\n(\r\n    `id` Int64,\r\n    `type` Nullable(Int8),\r\n    `value` Nullable(Decimal(10, 4)),\r\n    `time` Nullable(DateTime),\r\n    `initiative_id` Nullable(String),\r\n    `passivity_id` Nullable(String),\r\n    `person_id` Nullable(String),\r\n    `tenant_code` Nullable(String),\r\n    `created_time` Nullable(DateTime),\r\n    `updated_time` Nullable(DateTime),\r\n    `value_snapshot` Nullable(Decimal(10, 4)),\r\n    `_sign` Int8 MATERIALIZED 1,\r\n    `_version` UInt64 MATERIALIZED 1,\r\n    INDEX _version _version TYPE minmax GRANULARITY 1\r\n)\r\nENGINE = ReplacingMergeTree(_version)\r\nPARTITION BY intDiv(id, 18446744073709551)\r\nORDER BY (assumeNotNull(type), assumeNotNull(time), assumeNotNull(initiative_id), assumeNotNull(passivity_id), assumeNotNull(person_id), assumeNotNull(tenant_code), id)\r\nSETTINGS index_granularity = 8192\nI copied the table to another database, no issue was found.\r\nSeems the exception only for MaterializeMySQL database",
  "created_at": "2021-06-29T17:49:45Z"
}