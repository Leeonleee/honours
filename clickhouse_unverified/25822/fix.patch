diff --git a/src/Databases/DatabaseLazy.cpp b/src/Databases/DatabaseLazy.cpp
index 28f9372a61eb..abcb8dbb9745 100644
--- a/src/Databases/DatabaseLazy.cpp
+++ b/src/Databases/DatabaseLazy.cpp
@@ -305,12 +305,12 @@ void DatabaseLazy::clearExpiredTables() const
 
 
 DatabaseLazyIterator::DatabaseLazyIterator(DatabaseLazy & database_, Strings && table_names_)
-    : database(database_)
+    : IDatabaseTablesIterator(database_.database_name)
+    , database(database_)
     , table_names(std::move(table_names_))
     , iterator(table_names.begin())
     , current_storage(nullptr)
 {
-    database_name = database.database_name;
 }
 
 void DatabaseLazyIterator::next()
diff --git a/src/Databases/IDatabase.h b/src/Databases/IDatabase.h
index ba5fa974d5c4..0c8382465f79 100644
--- a/src/Databases/IDatabase.h
+++ b/src/Databases/IDatabase.h
@@ -45,6 +45,9 @@ class IDatabaseTablesIterator
     /// - it maintains a list of tables but tables are loaded lazily).
     virtual const StoragePtr & table() const = 0;
 
+    IDatabaseTablesIterator(const String & database_name_) : database_name(database_name_) { }
+    IDatabaseTablesIterator(String && database_name_) : database_name(std::move(database_name_)) { }
+
     virtual ~IDatabaseTablesIterator() = default;
 
     virtual UUID uuid() const { return UUIDHelpers::Nil; }
@@ -52,7 +55,7 @@ class IDatabaseTablesIterator
     const String & databaseName() const { assert(!database_name.empty()); return database_name; }
 
 protected:
-    String database_name;
+    const String database_name;
 };
 
 /// Copies list of tables and iterates through such snapshot.
@@ -64,26 +67,24 @@ class DatabaseTablesSnapshotIterator : public IDatabaseTablesIterator
 
 protected:
     DatabaseTablesSnapshotIterator(DatabaseTablesSnapshotIterator && other)
+    : IDatabaseTablesIterator(std::move(other.database_name))
     {
         size_t idx = std::distance(other.tables.begin(), other.it);
         std::swap(tables, other.tables);
         other.it = other.tables.end();
         it = tables.begin();
         std::advance(it, idx);
-        database_name = std::move(other.database_name);
     }
 
 public:
     DatabaseTablesSnapshotIterator(const Tables & tables_, const String & database_name_)
-    : tables(tables_), it(tables.begin())
+    : IDatabaseTablesIterator(database_name_), tables(tables_), it(tables.begin())
     {
-        database_name = database_name_;
     }
 
     DatabaseTablesSnapshotIterator(Tables && tables_, String && database_name_)
-    : tables(std::move(tables_)), it(tables.begin())
+    : IDatabaseTablesIterator(std::move(database_name_)), tables(std::move(tables_)), it(tables.begin())
     {
-        database_name = std::move(database_name_);
     }
 
     void next() override { ++it; }
diff --git a/src/Databases/MySQL/DatabaseMaterializeMySQL.h b/src/Databases/MySQL/DatabaseMaterializeMySQL.h
index 74a3c06e6f04..d07810e6416b 100644
--- a/src/Databases/MySQL/DatabaseMaterializeMySQL.h
+++ b/src/Databases/MySQL/DatabaseMaterializeMySQL.h
@@ -66,6 +66,8 @@ class DatabaseMaterializeMySQL : public Base
     void assertCalledFromSyncThreadOrDrop(const char * method) const;
 
     void shutdownSynchronizationThread();
+
+    friend class DatabaseMaterializeTablesIterator;
 };
 
 
diff --git a/src/Databases/MySQL/DatabaseMaterializeTablesIterator.h b/src/Databases/MySQL/DatabaseMaterializeTablesIterator.h
index 54031de40a25..a3d49077baa2 100644
--- a/src/Databases/MySQL/DatabaseMaterializeTablesIterator.h
+++ b/src/Databases/MySQL/DatabaseMaterializeTablesIterator.h
@@ -30,7 +30,7 @@ class DatabaseMaterializeTablesIterator final : public IDatabaseTablesIterator
     UUID uuid() const override { return nested_iterator->uuid(); }
 
     DatabaseMaterializeTablesIterator(DatabaseTablesIteratorPtr nested_iterator_, const IDatabase * database_)
-        : nested_iterator(std::move(nested_iterator_)), database(database_)
+        : IDatabaseTablesIterator(database_->getDatabaseName()), nested_iterator(std::move(nested_iterator_)), database(database_)
     {
     }
 
diff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp
index 55888cd1afd7..79e60a9a02cc 100644
--- a/src/Interpreters/InterpreterSelectQuery.cpp
+++ b/src/Interpreters/InterpreterSelectQuery.cpp
@@ -388,6 +388,9 @@ InterpreterSelectQuery::InterpreterSelectQuery(
 
         query_info.syntax_analyzer_result = syntax_analyzer_result;
 
+        if (storage && !query.final() && storage->needRewriteQueryWithFinal(syntax_analyzer_result->requiredSourceColumns()))
+            query.setFinal();
+
         /// Save scalar sub queries's results in the query context
         if (!options.only_analyze && context->hasQueryContext())
             for (const auto & it : syntax_analyzer_result->getScalars())
diff --git a/src/Parsers/ASTSelectQuery.cpp b/src/Parsers/ASTSelectQuery.cpp
index 84a2e1070d6c..7699d3806239 100644
--- a/src/Parsers/ASTSelectQuery.cpp
+++ b/src/Parsers/ASTSelectQuery.cpp
@@ -438,4 +438,19 @@ ASTPtr & ASTSelectQuery::getExpression(Expression expr)
     return children[positions[expr]];
 }
 
+void ASTSelectQuery::setFinal() // NOLINT method can be made const
+{
+    auto & tables_in_select_query = tables()->as<ASTTablesInSelectQuery &>();
+
+    if (tables_in_select_query.children.empty())
+        throw Exception(ErrorCodes::LOGICAL_ERROR, "Tables list is empty, it's a bug");
+
+    auto & tables_element = tables_in_select_query.children[0]->as<ASTTablesInSelectQueryElement &>();
+
+    if (!tables_element.table_expression)
+        throw Exception(ErrorCodes::LOGICAL_ERROR, "There is no table expression, it's a bug");
+
+    tables_element.table_expression->as<ASTTableExpression &>().final = true;
+}
+
 }
diff --git a/src/Parsers/ASTSelectQuery.h b/src/Parsers/ASTSelectQuery.h
index 3fc8efb53114..db4d7e763209 100644
--- a/src/Parsers/ASTSelectQuery.h
+++ b/src/Parsers/ASTSelectQuery.h
@@ -93,6 +93,8 @@ class ASTSelectQuery : public IAST
     void addTableFunction(ASTPtr & table_function_ptr);
     void updateTreeHashImpl(SipHash & hash_state) const override;
 
+    void setFinal();
+
 protected:
     void formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const override;
 
diff --git a/src/Storages/IStorage.h b/src/Storages/IStorage.h
index 2d6109bd7aff..5d1771f48b79 100644
--- a/src/Storages/IStorage.h
+++ b/src/Storages/IStorage.h
@@ -272,6 +272,10 @@ class IStorage : public std::enable_shared_from_this<IStorage>, public TypePromo
         throw Exception("Method watch is not supported by storage " + getName(), ErrorCodes::NOT_IMPLEMENTED);
     }
 
+    /// Returns true if FINAL modifier must be added to SELECT query depending on required columns.
+    /// It's needed for ReplacingMergeTree wrappers such as MaterializedMySQL and MaterializedPostrgeSQL
+    virtual bool needRewriteQueryWithFinal(const Names & /*column_names*/) const { return false; }
+
     /** Read a set of columns from the table.
       * Accepts a list of columns to read, as well as a description of the query,
       *  from which information can be extracted about how to retrieve data
diff --git a/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp b/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp
index 2fa96ac5cf21..e24e252bf016 100644
--- a/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp
+++ b/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp
@@ -256,6 +256,12 @@ NamesAndTypesList StorageMaterializedPostgreSQL::getVirtuals() const
 }
 
 
+bool StorageMaterializedPostgreSQL::needRewriteQueryWithFinal(const Names & column_names) const
+{
+    return needRewriteQueryWithFinalForStorage(column_names, getNested());
+}
+
+
 Pipe StorageMaterializedPostgreSQL::read(
         const Names & column_names,
         const StorageMetadataPtr & metadata_snapshot,
diff --git a/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.h b/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.h
index 5d18a0b16b7b..becb4f6ba10f 100644
--- a/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.h
+++ b/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.h
@@ -82,6 +82,8 @@ class StorageMaterializedPostgreSQL final : public shared_ptr_helper<StorageMate
 
     NamesAndTypesList getVirtuals() const override;
 
+    bool needRewriteQueryWithFinal(const Names & column_names) const override;
+
     Pipe read(
         const Names & column_names,
         const StorageMetadataPtr & metadata_snapshot,
@@ -119,6 +121,8 @@ class StorageMaterializedPostgreSQL final : public shared_ptr_helper<StorageMate
     /// for current table, set has_nested = true.
     StoragePtr prepare();
 
+    bool supportsFinal() const override { return true; }
+
 protected:
     StorageMaterializedPostgreSQL(
         const StorageID & table_id_,
diff --git a/src/Storages/ReadFinalForExternalReplicaStorage.cpp b/src/Storages/ReadFinalForExternalReplicaStorage.cpp
index fb96bb019368..36a40beca36f 100644
--- a/src/Storages/ReadFinalForExternalReplicaStorage.cpp
+++ b/src/Storages/ReadFinalForExternalReplicaStorage.cpp
@@ -16,6 +16,14 @@
 namespace DB
 {
 
+bool needRewriteQueryWithFinalForStorage(const Names & column_names, const StoragePtr & storage)
+{
+    const StorageMetadataPtr & metadata = storage->getInMemoryMetadataPtr();
+    Block header = metadata->getSampleBlock();
+    ColumnWithTypeAndName & version_column = header.getByPosition(header.columns() - 1);
+    return std::find(column_names.begin(), column_names.end(), version_column.name) == column_names.end();
+}
+
 Pipe readFinalFromNestedStorage(
     StoragePtr nested_storage,
     const Names & column_names,
@@ -32,20 +40,6 @@ Pipe readFinalFromNestedStorage(
 
     Block nested_header = nested_metadata->getSampleBlock();
     ColumnWithTypeAndName & sign_column = nested_header.getByPosition(nested_header.columns() - 2);
-    ColumnWithTypeAndName & version_column = nested_header.getByPosition(nested_header.columns() - 1);
-
-    if (ASTSelectQuery * select_query = query_info.query->as<ASTSelectQuery>(); select_query && !column_names_set.count(version_column.name))
-    {
-        auto & tables_in_select_query = select_query->tables()->as<ASTTablesInSelectQuery &>();
-
-        if (!tables_in_select_query.children.empty())
-        {
-            auto & tables_element = tables_in_select_query.children[0]->as<ASTTablesInSelectQueryElement &>();
-
-            if (tables_element.table_expression)
-                tables_element.table_expression->as<ASTTableExpression &>().final = true;
-        }
-    }
 
     String filter_column_name;
     Names require_columns_name = column_names;
@@ -59,9 +53,6 @@ Pipe readFinalFromNestedStorage(
 
         expressions->children.emplace_back(makeASTFunction("equals", sign_column_name, fetch_sign_value));
         filter_column_name = expressions->children.back()->getColumnName();
-
-        for (const auto & column_name : column_names)
-            expressions->children.emplace_back(std::make_shared<ASTIdentifier>(column_name));
     }
 
     Pipe pipe = nested_storage->read(require_columns_name, nested_metadata, query_info, context, processed_stage, max_block_size, num_streams);
diff --git a/src/Storages/ReadFinalForExternalReplicaStorage.h b/src/Storages/ReadFinalForExternalReplicaStorage.h
index b54592159ef2..f09a115919dc 100644
--- a/src/Storages/ReadFinalForExternalReplicaStorage.h
+++ b/src/Storages/ReadFinalForExternalReplicaStorage.h
@@ -13,6 +13,8 @@
 namespace DB
 {
 
+bool needRewriteQueryWithFinalForStorage(const Names & column_names, const StoragePtr & storage);
+
 Pipe readFinalFromNestedStorage(
     StoragePtr nested_storage,
     const Names & column_names,
diff --git a/src/Storages/StorageMaterializeMySQL.cpp b/src/Storages/StorageMaterializeMySQL.cpp
index 5b371fe3fb81..220d77b104aa 100644
--- a/src/Storages/StorageMaterializeMySQL.cpp
+++ b/src/Storages/StorageMaterializeMySQL.cpp
@@ -36,6 +36,11 @@ StorageMaterializeMySQL::StorageMaterializeMySQL(const StoragePtr & nested_stora
     setInMemoryMetadata(in_memory_metadata);
 }
 
+bool StorageMaterializeMySQL::needRewriteQueryWithFinal(const Names & column_names) const
+{
+    return needRewriteQueryWithFinalForStorage(column_names, nested_storage);
+}
+
 Pipe StorageMaterializeMySQL::read(
     const Names & column_names,
     const StorageMetadataPtr & metadata_snapshot,
@@ -47,6 +52,7 @@ Pipe StorageMaterializeMySQL::read(
 {
     /// If the background synchronization thread has exception.
     rethrowSyncExceptionIfNeed(database);
+
     return readFinalFromNestedStorage(nested_storage, column_names, metadata_snapshot,
             query_info, context, processed_stage, max_block_size, num_streams);
 }
diff --git a/src/Storages/StorageMaterializeMySQL.h b/src/Storages/StorageMaterializeMySQL.h
index 45221ed5b76e..b0b7a877630e 100644
--- a/src/Storages/StorageMaterializeMySQL.h
+++ b/src/Storages/StorageMaterializeMySQL.h
@@ -24,6 +24,8 @@ class StorageMaterializeMySQL final : public shared_ptr_helper<StorageMaterializ
 
     StorageMaterializeMySQL(const StoragePtr & nested_storage_, const IDatabase * database_);
 
+    bool needRewriteQueryWithFinal(const Names & column_names) const override;
+
     Pipe read(
         const Names & column_names, const StorageMetadataPtr & metadata_snapshot, SelectQueryInfo & query_info,
         ContextPtr context, QueryProcessingStage::Enum processed_stage, size_t max_block_size, unsigned num_streams) override;
diff --git a/src/Storages/StorageMerge.cpp b/src/Storages/StorageMerge.cpp
index 355b9335d9f2..43838b1d8c5d 100644
--- a/src/Storages/StorageMerge.cpp
+++ b/src/Storages/StorageMerge.cpp
@@ -388,6 +388,13 @@ Pipe StorageMerge::createSources(
         return pipe;
     }
 
+    if (!modified_select.final() && storage->needRewriteQueryWithFinal(real_column_names))
+    {
+        /// NOTE: It may not work correctly in some cases, because query was analyzed without final.
+        /// However, it's needed for MaterializeMySQL and it's unlikely that someone will use it with Merge tables.
+        modified_select.setFinal();
+    }
+
     auto storage_stage
         = storage->getQueryProcessingStage(modified_context, QueryProcessingStage::Complete, metadata_snapshot, modified_query_info);
     if (processed_stage <= storage_stage)
