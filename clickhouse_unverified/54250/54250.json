{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 54250,
  "instance_id": "ClickHouse__ClickHouse-54250",
  "issue_numbers": [
    "53156"
  ],
  "base_commit": "ff66d2937617f2c66e57b9539f34b6e4ea8ed183",
  "patch": "diff --git a/docs/en/sql-reference/functions/other-functions.md b/docs/en/sql-reference/functions/other-functions.md\nindex 566eff76584e..378fc821df9a 100644\n--- a/docs/en/sql-reference/functions/other-functions.md\n+++ b/docs/en/sql-reference/functions/other-functions.md\n@@ -660,21 +660,26 @@ SELECT\n \n ## formatReadableTimeDelta\n \n-Given a time interval (delta) in seconds, this function returns a time delta with year/month/day/hour/minute/second as string.\n+Given a time interval (delta) in seconds, this function returns a time delta with year/month/day/hour/minute/second/millisecond/microsecond/nanosecond as string.\n \n **Syntax**\n \n ``` sql\n-formatReadableTimeDelta(column[, maximum_unit])\n+formatReadableTimeDelta(column[, maximum_unit, minimum_unit])\n ```\n \n **Arguments**\n \n - `column` \u2014 A column with a numeric time delta.\n-- `maximum_unit` \u2014 Optional. Maximum unit to show. Acceptable values `seconds`, `minutes`, `hours`, `days`, `months`, `years`.\n-\n-Example:\n+- `maximum_unit` \u2014 Optional. Maximum unit to show.\n+  * Acceptable values: `nanoseconds`, `microseconds`, `milliseconds`, `seconds`, `minutes`, `hours`, `days`, `months`, `years`.\n+  * Default value: `years`.\n+- `minimum_unit` \u2014 Optional. Minimum unit to show. All smaller units are truncated.\n+  * Acceptable values: `nanoseconds`, `microseconds`, `milliseconds`, `seconds`, `minutes`, `hours`, `days`, `months`, `years`.\n+  * If explicitly specified value is bigger than `maximum_unit`, an exception will be thrown.\n+  * Default value: `seconds` if `maximum_unit` is `seconds` or bigger, `nanoseconds` otherwise.\n \n+**Example**\n ``` sql\n SELECT\n     arrayJoin([100, 12345, 432546534]) AS elapsed,\n@@ -703,6 +708,20 @@ SELECT\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+```sql\n+SELECT\n+    arrayJoin([100, 12345, 432546534.00000006]) AS elapsed,\n+    formatReadableTimeDelta(elapsed, 'minutes', 'nanoseconds') AS time_delta\n+```\n+\n+```text\n+\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500elapsed\u2500\u252c\u2500time_delta\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+\u2502                100 \u2502 1 minute and 40 seconds                        \u2502\n+\u2502              12345 \u2502 205 minutes and 45 seconds                     \u2502\n+\u2502 432546534.00000006 \u2502 7209108 minutes, 54 seconds and 60 nanoseconds \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## parseTimeDelta\n \n Parse a sequence of numbers followed by something resembling a time unit.\ndiff --git a/docs/ru/sql-reference/functions/other-functions.md b/docs/ru/sql-reference/functions/other-functions.md\nindex 78608aaf8176..835aed934d5f 100644\n--- a/docs/ru/sql-reference/functions/other-functions.md\n+++ b/docs/ru/sql-reference/functions/other-functions.md\n@@ -659,9 +659,11 @@ SELECT\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+\n ## formatReadableTimeDelta {#formatreadabletimedelta}\n \n-\u041f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u0434\u0435\u043b\u044c\u0442\u0443 \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u0432 \u0441\u0435\u043a\u0443\u043d\u0434\u0430\u0445. \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0434\u0435\u043b\u044c\u0442\u0443 \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u0441 (\u0433\u043e\u0434, \u043c\u0435\u0441\u044f\u0446, \u0434\u0435\u043d\u044c, \u0447\u0430\u0441, \u043c\u0438\u043d\u0443\u0442\u0430, \u0441\u0435\u043a\u0443\u043d\u0434\u0430) \u0432 \u0432\u0438\u0434\u0435 \u0441\u0442\u0440\u043e\u043a\u0438.\n+\u041f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u0434\u0435\u043b\u044c\u0442\u0443 \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u0432 \u0441\u0435\u043a\u0443\u043d\u0434\u0430\u0445. \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0434\u0435\u043b\u044c\u0442\u0443 \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u0432 \u0432\u0438\u0434\u0435 \u0441\u0442\u0440\u043e\u043a\u0438.\n+\u0415\u0441\u0442\u044c \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0443\u043a\u0430\u0437\u0430\u0442\u044c \u043d\u0430\u0438\u0431\u043e\u043b\u0435\u0435 \u043a\u0440\u0443\u043f\u043d\u0443\u044e \u0435\u0434\u0438\u043d\u0438\u0446\u0443 \u0438\u0437\u043c\u0435\u0440\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u0432\u044b\u0432\u043e\u0434\u0430 (\u0433\u043e\u0434, \u043c\u0435\u0441\u044f\u0446, \u0434\u0435\u043d\u044c, \u0447\u0430\u0441, \u043c\u0438\u043d\u0443\u0442\u0430, \u0441\u0435\u043a\u0443\u043d\u0434\u0430, \u043c\u0438\u043b\u043b\u0438/\u043c\u0438\u043a\u0440\u043e/\u043d\u0430\u043d\u043e\u0441\u0435\u043a\u0443\u043d\u0434\u0430).\n \n **\u0421\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441**\n \n@@ -671,10 +673,16 @@ formatReadableTimeDelta(column[, maximum_unit])\n \n **\u0410\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b**\n \n--   `column` \u2014 \u0421\u0442\u043e\u043b\u0431\u0435\u0446 \u0441 \u0447\u0438\u0441\u043b\u043e\u0432\u043e\u0439 \u0434\u0435\u043b\u044c\u0442\u043e\u0439 \u0432\u0440\u0435\u043c\u0435\u043d\u0438.\n--   `maximum_unit` \u2014 \u041e\u043f\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440. \u041c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u0430\u044f \u0435\u0434\u0438\u043d\u0438\u0446\u0430 \u0438\u0437\u043c\u0435\u0440\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f. \u0414\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f: \u0441\u0435\u043a\u0443\u043d\u0434\u044b, \u043c\u0438\u043d\u0443\u0442\u044b, \u0447\u0430\u0441\u044b, \u0434\u043d\u0438, \u043c\u0435\u0441\u044f\u0446\u044b, \u0433\u043e\u0434\u044b.\n+- `column` \u2014 \u0421\u0442\u043e\u043b\u0431\u0435\u0446 \u0441 \u0447\u0438\u0441\u043b\u043e\u0432\u043e\u0439 \u0434\u0435\u043b\u044c\u0442\u043e\u0439 \u0432\u0440\u0435\u043c\u0435\u043d\u0438.\n+- `maximum_unit` \u2014 \u041e\u043f\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440. \u041c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u0430\u044f \u0435\u0434\u0438\u043d\u0438\u0446\u0430 \u0438\u0437\u043c\u0435\u0440\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f.\n+  * \u0414\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f: `nanoseconds`, `microseconds`, `milliseconds`, `seconds`, `minutes`, `hours`, `days`, `months`, `years`.\n+  * \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e: `years`.\n+- `minimum_unit` \u2014 \u041e\u043f\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440. \u041c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u0430\u044f \u0435\u0434\u0438\u043d\u0438\u0446\u0430 \u0438\u0437\u043c\u0435\u0440\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f. \u0411\u043e\u043b\u0435\u0435 \u043c\u0435\u043b\u043a\u0438\u0435 \u0435\u0434\u0438\u043d\u0438\u0446\u044b \u0431\u0443\u0434\u0443\u0442 \u043e\u0442\u0431\u0440\u043e\u0448\u0435\u043d\u044b.\n+  * \u0414\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f: `nanoseconds`, `microseconds`, `milliseconds`, `seconds`, `minutes`, `hours`, `days`, `months`, `years`.\n+  * \u0415\u0441\u043b\u0438 \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u0430\u044f \u0435\u0434\u0438\u043d\u0438\u0446\u0430 \u0437\u0430\u0434\u0430\u043d\u0430 \u044f\u0432\u043d\u043e \u0438 \u043f\u0440\u0435\u0432\u044b\u0448\u0430\u0435\u0442 \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u0443\u044e \u0435\u0434\u0438\u043d\u0438\u0446\u0443, \u0431\u0443\u0434\u0435\u0442 \u0432\u044b\u043a\u0438\u043d\u0443\u0442\u043e \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435.\n+  * \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e: `seconds` \u0435\u0441\u043b\u0438 \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u0430\u044f \u0435\u0434\u0438\u043d\u0438\u0446\u0430 -- \u0441\u0435\u043a\u0443\u043d\u0434\u0430 \u0438\u043b\u0438 \u0431\u043e\u043b\u0435\u0435 \u043a\u0440\u0443\u043f\u043d\u044b\u0439 \u0438\u043d\u0442\u0435\u0440\u0432\u0430\u043b, \u0432 \u043f\u0440\u043e\u0442\u0438\u0432\u043d\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435 -- `nanoseconds`.\n \n-\u041f\u0440\u0438\u043c\u0435\u0440:\n+**\u041f\u0440\u0438\u043c\u0435\u0440**\n \n ``` sql\n SELECT\ndiff --git a/src/Functions/formatReadableTimeDelta.cpp b/src/Functions/formatReadableTimeDelta.cpp\nindex 5fd48c01e8f0..96d3a6fd966b 100644\n--- a/src/Functions/formatReadableTimeDelta.cpp\n+++ b/src/Functions/formatReadableTimeDelta.cpp\n@@ -2,11 +2,11 @@\n #include <Functions/IFunction.h>\n #include <Functions/FunctionHelpers.h>\n #include <Columns/ColumnString.h>\n-#include <Columns/ColumnVector.h>\n #include <Common/NaNUtils.h>\n #include <DataTypes/DataTypeString.h>\n #include <IO/WriteBufferFromVector.h>\n #include <IO/WriteHelpers.h>\n+#include <IO/DoubleConverter.h>\n \n \n namespace DB\n@@ -14,9 +14,10 @@ namespace DB\n \n namespace ErrorCodes\n {\n-    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n-    extern const int BAD_ARGUMENTS;\n+extern const int CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER;\n+extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+extern const int BAD_ARGUMENTS;\n }\n \n namespace\n@@ -52,75 +53,88 @@ class FunctionFormatReadableTimeDelta : public IFunction\n     {\n         if (arguments.empty())\n             throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n-                \"Number of arguments for function {} doesn't match: passed {}, should be at least 1.\",\n-                getName(), arguments.size());\n+                            \"Number of arguments for function {} doesn't match: passed {}, should be at least 1.\",\n+                            getName(), arguments.size());\n \n-        if (arguments.size() > 2)\n+        if (arguments.size() > 3)\n             throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n-                \"Number of arguments for function {} doesn't match: passed {}, should be at most 2.\",\n-                getName(), arguments.size());\n+                            \"Number of arguments for function {} doesn't match: passed {}, should be 1, 2 or 3.\",\n+                            getName(), arguments.size());\n \n         const IDataType & type = *arguments[0];\n \n         if (!isNativeNumber(type))\n             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cannot format {} as time delta\", type.getName());\n \n-        if (arguments.size() == 2)\n+        if (arguments.size() >= 2)\n         {\n             const auto * maximum_unit_arg = arguments[1].get();\n             if (!isStringOrFixedString(maximum_unit_arg))\n                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of argument maximum_unit of function {}\",\n                                 maximum_unit_arg->getName(), getName());\n+\n+            if (arguments.size() == 3)\n+            {\n+                const auto * minimum_unit_arg = arguments[2].get();\n+                if (!isStringOrFixedString(minimum_unit_arg))\n+                    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of argument minimum_unit of function {}\",\n+                                    minimum_unit_arg->getName(), getName());\n+            }\n         }\n \n         return std::make_shared<DataTypeString>();\n     }\n \n-    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1, 2}; }\n \n     bool useDefaultImplementationForConstants() const override { return true; }\n \n     enum Unit\n     {\n-        Seconds,\n-        Minutes,\n-        Hours,\n-        Days,\n-        Months,\n-        Years\n+        Nanoseconds = 1,\n+        Microseconds = 2,\n+        Milliseconds = 3,\n+        Seconds = 4,\n+        Minutes = 5,\n+        Hours = 6,\n+        Days = 7,\n+        Months = 8,\n+        Years = 9\n     };\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n     {\n-        std::string_view maximum_unit_str;\n-        if (arguments.size() == 2)\n+        std::string_view maximum_unit_str, minimum_unit_str;\n+        if (arguments.size() >= 2)\n         {\n             const ColumnPtr & maximum_unit_column = arguments[1].column;\n             const ColumnConst * maximum_unit_const_col = checkAndGetColumnConstStringOrFixedString(maximum_unit_column.get());\n             if (maximum_unit_const_col)\n                 maximum_unit_str = maximum_unit_const_col->getDataColumn().getDataAt(0).toView();\n+\n+            if (arguments.size() == 3)\n+            {\n+                const ColumnPtr & minimum_unit_column = arguments[2].column;\n+                const ColumnConst * minimum_unit_const_col = checkAndGetColumnConstStringOrFixedString(minimum_unit_column.get());\n+                if (minimum_unit_const_col)\n+                    minimum_unit_str = minimum_unit_const_col->getDataColumn().getDataAt(0).toView();\n+            }\n         }\n+        /// Default means \"use all available whole units\".\n+        Unit max_unit = dispatchUnit(maximum_unit_str, Years, \"maximum\");\n+        /// Set seconds as min_unit by default not to ruin old use cases\n+        Unit min_unit = dispatchUnit(minimum_unit_str, Seconds, \"minimum\");\n \n-        Unit max_unit;\n-\n-        /// Default means \"use all available units\".\n-        if (maximum_unit_str.empty() || maximum_unit_str == \"years\")\n-            max_unit = Years;\n-        else if (maximum_unit_str == \"months\")\n-            max_unit = Months;\n-        else if (maximum_unit_str == \"days\")\n-            max_unit = Days;\n-        else if (maximum_unit_str == \"hours\")\n-            max_unit = Hours;\n-        else if (maximum_unit_str == \"minutes\")\n-            max_unit = Minutes;\n-        else if (maximum_unit_str == \"seconds\")\n-            max_unit = Seconds;\n-        else\n-            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                \"Unexpected value of maximum unit argument ({}) for function {}, the only allowed values are:\"\n-                \" 'seconds', 'minutes', 'hours', 'days', 'months', 'years'.\",\n-                maximum_unit_str, getName());\n+        if (min_unit > max_unit)\n+        {\n+            if (minimum_unit_str.empty())\n+                min_unit = Nanoseconds;   /// User wants sub-second max_unit. Show him all sub-second units unless other specified.\n+            else\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                                \"Explicitly specified value of minimum unit argument ({}) for function {} \"\n+                                \"must not be greater than maximum unit value ({}).\",\n+                                minimum_unit_str, getName(), maximum_unit_str);\n+        }\n \n         auto col_to = ColumnString::create();\n \n@@ -152,14 +166,61 @@ class FunctionFormatReadableTimeDelta : public IFunction\n                 /// To output separators between parts: \", \" and \" and \".\n                 bool has_output = false;\n \n+                Float64 whole_part;\n+                std::string fractional_str = getFractionalString(std::modf(value, &whole_part));\n+\n                 switch (max_unit) /// A kind of Duff Device.\n                 {\n-                    case Years:     processUnit(365 * 24 * 3600, \" year\", 5, value, buf_to, has_output); [[fallthrough]];\n-                    case Months:    processUnit(static_cast<UInt64>(30.5 * 24 * 3600), \" month\", 6, value, buf_to, has_output); [[fallthrough]];\n-                    case Days:      processUnit(24 * 3600, \" day\", 4, value, buf_to, has_output); [[fallthrough]];\n-                    case Hours:     processUnit(3600, \" hour\", 5, value, buf_to, has_output); [[fallthrough]];\n-                    case Minutes:   processUnit(60, \" minute\", 7, value, buf_to, has_output); [[fallthrough]];\n-                    case Seconds:   processUnit(1, \" second\", 7, value, buf_to, has_output);\n+                    case Years:\n+                        processUnit(365 * 24 * 3600, 0, \" year\", 5, whole_part, fractional_str, buf_to, has_output, min_unit, min_unit == Years);\n+                        if (min_unit == Years)\n+                            break;\n+                        [[fallthrough]];\n+\n+                    case Months:\n+                        processUnit(static_cast<UInt64>(30.5 * 24 * 3600), 0, \" month\", 6, whole_part, fractional_str, buf_to, has_output, min_unit, min_unit == Months);\n+                        if (min_unit == Months)\n+                            break;\n+                        [[fallthrough]];\n+\n+                    case Days:\n+                        processUnit(24 * 3600, 0, \" day\", 4, whole_part, fractional_str, buf_to, has_output, min_unit, min_unit == Days);\n+                        if (min_unit == Days)\n+                            break;\n+                        [[fallthrough]];\n+\n+                    case Hours:\n+                        processUnit(3600, 0, \" hour\", 5, whole_part, fractional_str, buf_to, has_output, min_unit, min_unit == Hours);\n+                        if (min_unit == Hours)\n+                            break;\n+                        [[fallthrough]];\n+\n+                    case Minutes:\n+                        processUnit(60, 0, \" minute\", 7, whole_part, fractional_str, buf_to, has_output, min_unit, min_unit == Minutes);\n+                        if (min_unit == Minutes)\n+                            break;\n+                        [[fallthrough]];\n+\n+                    case Seconds:\n+                        processUnit(1, 0, \" second\", 7, whole_part, fractional_str, buf_to, has_output, min_unit, min_unit == Seconds);\n+                        if (min_unit == Seconds)\n+                            break;\n+                        [[fallthrough]];\n+\n+                    case Milliseconds:\n+                        processUnit(1, 3, \" millisecond\", 12, whole_part, fractional_str, buf_to, has_output, min_unit, min_unit == Milliseconds);\n+                        if (min_unit == Milliseconds)\n+                            break;\n+                        [[fallthrough]];\n+\n+                    case Microseconds:\n+                        processUnit(1, 6, \" microsecond\", 12, whole_part, fractional_str, buf_to, has_output, min_unit, min_unit == Microseconds);\n+                        if (min_unit == Microseconds)\n+                            break;\n+                        [[fallthrough]];\n+\n+                    case Nanoseconds:\n+                        processUnit(1, 9, \" nanosecond\", 11, whole_part, fractional_str, buf_to, has_output, min_unit, true);\n                 }\n             }\n \n@@ -172,42 +233,68 @@ class FunctionFormatReadableTimeDelta : public IFunction\n     }\n \n     static void processUnit(\n-        UInt64 unit_size, const char * unit_name, size_t unit_name_size,\n-        Float64 & value, WriteBuffer & buf_to, bool & has_output)\n+        UInt64 unit_multiplier, UInt32 unit_scale, const char * unit_name, size_t unit_name_size, Float64 & whole_part,\n+        String & fractional_str, WriteBuffer & buf_to, bool & has_output,  Unit min_unit, bool is_minimum_unit)\n     {\n-        if (unlikely(value + 1.0 == value))\n+        if (unlikely(whole_part + 1.0 == whole_part))\n         {\n             /// The case when value is too large so exact representation for subsequent smaller units is not possible.\n-            writeText(std::floor(value / unit_size), buf_to);\n+            writeText(std::floor(whole_part * DecimalUtils::scaleMultiplier<Int64>(unit_scale) / unit_multiplier), buf_to);\n             buf_to.write(unit_name, unit_name_size);\n             writeChar('s', buf_to);\n             has_output = true;\n-            value = 0;\n+            whole_part = 0;\n             return;\n         }\n+        UInt64 num_units = 0;\n+        if (unit_scale == 0)  /// dealing with whole number of seconds\n+        {\n+            num_units = static_cast<UInt64>(std::floor(whole_part / unit_multiplier));\n \n-        UInt64 num_units = static_cast<UInt64>(value / unit_size);\n+            if (!num_units)\n+            {\n+                /// Zero units, no need to print. But if it's the last (seconds) and the only unit, print \"0 seconds\" nevertheless.\n+                if (unit_multiplier != 1 || has_output)\n+                    return;\n+            }\n \n-        if (!num_units)\n-        {\n-            /// Zero units, no need to print. But if it's the last (seconds) and the only unit, print \"0 seconds\" nevertheless.\n-            if (unit_size > 1 || has_output)\n-                return;\n+            /// Remaining value to print on next iteration.\n+            whole_part -= num_units * unit_multiplier;\n         }\n+        else   /// dealing with sub-seconds, a bit more peculiar to avoid more precision issues\n+        {\n+            if (whole_part >= 1)  /// There were no whole units printed\n+            {\n+                num_units += static_cast<UInt64>(whole_part) * DecimalUtils::scaleMultiplier<Int64>(unit_scale);\n+                whole_part = 0;\n+            }\n \n-        /// Remaining value to print on next iteration.\n-        value -= num_units * unit_size;\n+            for (UInt32 i = 0; i < unit_scale; ++i)\n+            {\n+                num_units += (fractional_str[i] - '0') * DecimalUtils::scaleMultiplier<Int64>(unit_scale - i - 1);\n+                fractional_str[i] = '0';\n+            }\n \n+            if (!num_units)\n+            {\n+                /// Zero units, no need to print. But if it's the last (nanoseconds) and the only unit, print \"0 nanoseconds\" nevertheless.\n+                if (!is_minimum_unit || has_output)\n+                    return;\n+            }\n+        }\n+\n+        /// Write number of units\n         if (has_output)\n         {\n             /// Need delimiter between values. The last delimiter is \" and \", all previous are comma.\n-            if (value < 1)\n+            if (is_minimum_unit || (whole_part < 1 && fractional_str.substr(0, (4 - min_unit) * 3) == std::string((4 - min_unit) * 3, '0')))\n                 writeCString(\" and \", buf_to);\n             else\n                 writeCString(\", \", buf_to);\n         }\n \n         writeText(num_units, buf_to);\n+\n         buf_to.write(unit_name, unit_name_size); /// If we just leave strlen(unit_name) here, clang-11 fails to make it compile-time.\n \n         /// How to pronounce: unit vs. units.\n@@ -216,6 +303,47 @@ class FunctionFormatReadableTimeDelta : public IFunction\n \n         has_output = true;\n     }\n+\n+private:\n+    static std::string getFractionalString(const Float64 & fractional_part)\n+    {\n+        DB::DoubleConverter<true>::BufferType buffer;\n+        double_conversion::StringBuilder builder{buffer, sizeof(buffer)};\n+\n+        if (!DB::DoubleConverter<false>::instance().ToFixed(fractional_part, 9, &builder))\n+            throw DB::Exception(DB::ErrorCodes::CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER, \"Cannot print double number: {}\", fractional_part);\n+\n+        return std::string(buffer, builder.position()).substr(2);   /// do not return `0.` -- we don't need it\n+    }\n+\n+    Unit dispatchUnit(const std::string_view & unit_str, const Unit default_unit, const std::string & bound_name) const\n+    {\n+        if (unit_str.empty())\n+            return default_unit;\n+        else if (unit_str == \"years\")\n+            return Years;\n+        else if (unit_str == \"months\")\n+            return Months;\n+        else if (unit_str == \"days\")\n+            return Days;\n+        else if (unit_str == \"hours\")\n+            return Hours;\n+        else if (unit_str == \"minutes\")\n+            return Minutes;\n+        else if (unit_str == \"seconds\")\n+            return Seconds;\n+        else if (unit_str == \"milliseconds\")\n+            return Milliseconds;\n+        else if (unit_str == \"microseconds\")\n+            return Microseconds;\n+        else if (unit_str == \"nanoseconds\")\n+            return Nanoseconds;\n+        else\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                            \"Unexpected value of {} unit argument ({}) for function {}, the only allowed values are:\"\n+                            \" 'nanoseconds', 'microseconds', 'nanoseconds', 'seconds', 'minutes', 'hours', 'days', 'months', 'years'.\",\n+                            bound_name, unit_str, getName());\n+    }\n };\n \n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02887_format_readable_timedelta_subseconds.reference b/tests/queries/0_stateless/02887_format_readable_timedelta_subseconds.reference\nnew file mode 100644\nindex 000000000000..389479eb5290\n--- /dev/null\n+++ b/tests/queries/0_stateless/02887_format_readable_timedelta_subseconds.reference\n@@ -0,0 +1,24 @@\n+1 second\n+1 minute\n+2 minutes and 3 seconds\n+24 seconds\n+35 seconds\n+1 minute and 6 seconds\n+1 minute and 7 seconds\n+48 seconds\n+1 minute and 39 seconds\n+1 hour\n+1120 milliseconds\n+60200 milliseconds\n+123330 milliseconds\n+24450 milliseconds\n+35570 milliseconds\n+66640 milliseconds\n+67797 milliseconds, 979 microseconds and 790 nanoseconds\n+48888 milliseconds and 888 microseconds\n+99960 milliseconds\n+3600000 milliseconds\n+0 seconds\n+1 hour and 1 second\n+0 nanoseconds\n+1000 milliseconds and 500 microseconds\ndiff --git a/tests/queries/0_stateless/02887_format_readable_timedelta_subseconds.sql b/tests/queries/0_stateless/02887_format_readable_timedelta_subseconds.sql\nnew file mode 100644\nindex 000000000000..0a8a76d54fd4\n--- /dev/null\n+++ b/tests/queries/0_stateless/02887_format_readable_timedelta_subseconds.sql\n@@ -0,0 +1,30 @@\n+-- max_unit bigger than second, min_unit omitted (and considered 'seconds')\n+WITH\n+    'hours' AS maximum_unit,\n+    arrayJoin([1.12, 60.2, 123.33, 24.45, 35.57, 66.64, 67.79, 48.88, 99.96, 3600]) AS elapsed\n+SELECT\n+    formatReadableTimeDelta(elapsed, maximum_unit) AS time_delta;\n+\n+-- max_unit smaller than second, min_unit omitted (and considered 'nanoseconds')\n+WITH\n+    'milliseconds' AS maximum_unit,\n+    arrayJoin([1.12, 60.2, 123.33, 24.45, 35.57, 66.64, 67.79797979, 48.888888, 99.96, 3600]) AS elapsed\n+SELECT\n+    formatReadableTimeDelta(elapsed, maximum_unit) AS time_delta;\n+\n+-- Check exception is thrown\n+SELECT formatReadableTimeDelta(1.1, 'seconds', 'hours'); -- { serverError BAD_ARGUMENTS }\n+\n+-- Check empty units are omitted unless they are the only one\n+WITH\n+    'hours' AS maximum_unit,\n+    'microseconds' as minimum_unit,\n+    arrayJoin([0, 3601.000000003]) AS elapsed\n+SELECT\n+    formatReadableTimeDelta(elapsed, maximum_unit, minimum_unit);\n+\n+WITH\n+    'milliseconds' AS maximum_unit,\n+    arrayJoin([0, 1.0005]) AS elapsed\n+SELECT\n+    formatReadableTimeDelta(elapsed, maximum_unit);\n",
  "problem_statement": "formatReadableTimeDelta support for milli-micro-nano seconds in output\n\r\n\r\n**Use case**\r\n\r\n```\r\nSELECT formatReadableTimeDelta(0.1)\r\n\r\n\r\n\r\n\u250c\u2500formatReadableTimeDelta(0.1)\u2500\u2510\r\n\u2502 0 seconds                    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\r\nSELECT formatReadableTimeDelta(0.1, 'millisecond')\r\n\u250c\u2500formatReadableTimeDelta(0.1)\u2500\u2510\r\n\u2502 100 milliseconds             \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n**Describe the solution you'd like**\r\n\r\nAbility to use subseconds intervals in formatReadableTimeDelta  function\r\n\n",
  "hints_text": "@KochetovNicolai (as you are assigneee) could you please take a look at https://github.com/ClickHouse/ClickHouse/pull/54250 ?",
  "created_at": "2023-09-04T12:03:47Z"
}