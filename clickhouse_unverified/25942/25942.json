{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25942,
  "instance_id": "ClickHouse__ClickHouse-25942",
  "issue_numbers": [
    "25855"
  ],
  "base_commit": "313117c7d8505b44b2e60f606ee7881667da1657",
  "patch": "diff --git a/.gitmodules b/.gitmodules\nindex 0a7a6b4a3f9b..1d9d4d25baf1 100644\n--- a/.gitmodules\n+++ b/.gitmodules\n@@ -168,9 +168,6 @@\n [submodule \"contrib/fmtlib\"]\n \tpath = contrib/fmtlib\n \turl = https://github.com/fmtlib/fmt.git\n-[submodule \"contrib/antlr4-runtime\"]\n-\tpath = contrib/antlr4-runtime\n-\turl = https://github.com/ClickHouse-Extras/antlr4-runtime.git\n [submodule \"contrib/sentry-native\"]\n \tpath = contrib/sentry-native\n \turl = https://github.com/ClickHouse-Extras/sentry-native.git\ndiff --git a/contrib/CMakeLists.txt b/contrib/CMakeLists.txt\nindex 710c8c7fca50..164692fb893c 100644\n--- a/contrib/CMakeLists.txt\n+++ b/contrib/CMakeLists.txt\n@@ -34,7 +34,6 @@ endif()\n set_property(DIRECTORY PROPERTY EXCLUDE_FROM_ALL 1)\n \n add_subdirectory (abseil-cpp-cmake)\n-add_subdirectory (antlr4-runtime-cmake)\n add_subdirectory (boost-cmake)\n add_subdirectory (cctz-cmake)\n add_subdirectory (consistent-hashing)\ndiff --git a/contrib/antlr4-runtime b/contrib/antlr4-runtime\ndeleted file mode 160000\nindex 672643e9a427..000000000000\n--- a/contrib/antlr4-runtime\n+++ /dev/null\n@@ -1,1 +0,0 @@\n-Subproject commit 672643e9a427ef803abf13bc8cb4989606553d64\ndiff --git a/contrib/antlr4-runtime-cmake/CMakeLists.txt b/contrib/antlr4-runtime-cmake/CMakeLists.txt\ndeleted file mode 100644\nindex 4f639a33ebfe..000000000000\n--- a/contrib/antlr4-runtime-cmake/CMakeLists.txt\n+++ /dev/null\n@@ -1,156 +0,0 @@\n-set (LIBRARY_DIR \"${ClickHouse_SOURCE_DIR}/contrib/antlr4-runtime\")\n-\n-set (SRCS\n-    \"${LIBRARY_DIR}/ANTLRErrorListener.cpp\"\n-    \"${LIBRARY_DIR}/ANTLRErrorStrategy.cpp\"\n-    \"${LIBRARY_DIR}/ANTLRFileStream.cpp\"\n-    \"${LIBRARY_DIR}/ANTLRInputStream.cpp\"\n-    \"${LIBRARY_DIR}/atn/AbstractPredicateTransition.cpp\"\n-    \"${LIBRARY_DIR}/atn/ActionTransition.cpp\"\n-    \"${LIBRARY_DIR}/atn/AmbiguityInfo.cpp\"\n-    \"${LIBRARY_DIR}/atn/ArrayPredictionContext.cpp\"\n-    \"${LIBRARY_DIR}/atn/ATN.cpp\"\n-    \"${LIBRARY_DIR}/atn/ATNConfig.cpp\"\n-    \"${LIBRARY_DIR}/atn/ATNConfigSet.cpp\"\n-    \"${LIBRARY_DIR}/atn/ATNDeserializationOptions.cpp\"\n-    \"${LIBRARY_DIR}/atn/ATNDeserializer.cpp\"\n-    \"${LIBRARY_DIR}/atn/ATNSerializer.cpp\"\n-    \"${LIBRARY_DIR}/atn/ATNSimulator.cpp\"\n-    \"${LIBRARY_DIR}/atn/ATNState.cpp\"\n-    \"${LIBRARY_DIR}/atn/AtomTransition.cpp\"\n-    \"${LIBRARY_DIR}/atn/BasicBlockStartState.cpp\"\n-    \"${LIBRARY_DIR}/atn/BasicState.cpp\"\n-    \"${LIBRARY_DIR}/atn/BlockEndState.cpp\"\n-    \"${LIBRARY_DIR}/atn/BlockStartState.cpp\"\n-    \"${LIBRARY_DIR}/atn/ContextSensitivityInfo.cpp\"\n-    \"${LIBRARY_DIR}/atn/DecisionEventInfo.cpp\"\n-    \"${LIBRARY_DIR}/atn/DecisionInfo.cpp\"\n-    \"${LIBRARY_DIR}/atn/DecisionState.cpp\"\n-    \"${LIBRARY_DIR}/atn/EmptyPredictionContext.cpp\"\n-    \"${LIBRARY_DIR}/atn/EpsilonTransition.cpp\"\n-    \"${LIBRARY_DIR}/atn/ErrorInfo.cpp\"\n-    \"${LIBRARY_DIR}/atn/LexerAction.cpp\"\n-    \"${LIBRARY_DIR}/atn/LexerActionExecutor.cpp\"\n-    \"${LIBRARY_DIR}/atn/LexerATNConfig.cpp\"\n-    \"${LIBRARY_DIR}/atn/LexerATNSimulator.cpp\"\n-    \"${LIBRARY_DIR}/atn/LexerChannelAction.cpp\"\n-    \"${LIBRARY_DIR}/atn/LexerCustomAction.cpp\"\n-    \"${LIBRARY_DIR}/atn/LexerIndexedCustomAction.cpp\"\n-    \"${LIBRARY_DIR}/atn/LexerModeAction.cpp\"\n-    \"${LIBRARY_DIR}/atn/LexerMoreAction.cpp\"\n-    \"${LIBRARY_DIR}/atn/LexerPopModeAction.cpp\"\n-    \"${LIBRARY_DIR}/atn/LexerPushModeAction.cpp\"\n-    \"${LIBRARY_DIR}/atn/LexerSkipAction.cpp\"\n-    \"${LIBRARY_DIR}/atn/LexerTypeAction.cpp\"\n-    \"${LIBRARY_DIR}/atn/LL1Analyzer.cpp\"\n-    \"${LIBRARY_DIR}/atn/LookaheadEventInfo.cpp\"\n-    \"${LIBRARY_DIR}/atn/LoopEndState.cpp\"\n-    \"${LIBRARY_DIR}/atn/NotSetTransition.cpp\"\n-    \"${LIBRARY_DIR}/atn/OrderedATNConfigSet.cpp\"\n-    \"${LIBRARY_DIR}/atn/ParseInfo.cpp\"\n-    \"${LIBRARY_DIR}/atn/ParserATNSimulator.cpp\"\n-    \"${LIBRARY_DIR}/atn/PlusBlockStartState.cpp\"\n-    \"${LIBRARY_DIR}/atn/PlusLoopbackState.cpp\"\n-    \"${LIBRARY_DIR}/atn/PrecedencePredicateTransition.cpp\"\n-    \"${LIBRARY_DIR}/atn/PredicateEvalInfo.cpp\"\n-    \"${LIBRARY_DIR}/atn/PredicateTransition.cpp\"\n-    \"${LIBRARY_DIR}/atn/PredictionContext.cpp\"\n-    \"${LIBRARY_DIR}/atn/PredictionMode.cpp\"\n-    \"${LIBRARY_DIR}/atn/ProfilingATNSimulator.cpp\"\n-    \"${LIBRARY_DIR}/atn/RangeTransition.cpp\"\n-    \"${LIBRARY_DIR}/atn/RuleStartState.cpp\"\n-    \"${LIBRARY_DIR}/atn/RuleStopState.cpp\"\n-    \"${LIBRARY_DIR}/atn/RuleTransition.cpp\"\n-    \"${LIBRARY_DIR}/atn/SemanticContext.cpp\"\n-    \"${LIBRARY_DIR}/atn/SetTransition.cpp\"\n-    \"${LIBRARY_DIR}/atn/SingletonPredictionContext.cpp\"\n-    \"${LIBRARY_DIR}/atn/StarBlockStartState.cpp\"\n-    \"${LIBRARY_DIR}/atn/StarLoopbackState.cpp\"\n-    \"${LIBRARY_DIR}/atn/StarLoopEntryState.cpp\"\n-    \"${LIBRARY_DIR}/atn/TokensStartState.cpp\"\n-    \"${LIBRARY_DIR}/atn/Transition.cpp\"\n-    \"${LIBRARY_DIR}/atn/WildcardTransition.cpp\"\n-    \"${LIBRARY_DIR}/BailErrorStrategy.cpp\"\n-    \"${LIBRARY_DIR}/BaseErrorListener.cpp\"\n-    \"${LIBRARY_DIR}/BufferedTokenStream.cpp\"\n-    \"${LIBRARY_DIR}/CharStream.cpp\"\n-    \"${LIBRARY_DIR}/CommonToken.cpp\"\n-    \"${LIBRARY_DIR}/CommonTokenFactory.cpp\"\n-    \"${LIBRARY_DIR}/CommonTokenStream.cpp\"\n-    \"${LIBRARY_DIR}/ConsoleErrorListener.cpp\"\n-    \"${LIBRARY_DIR}/DefaultErrorStrategy.cpp\"\n-    \"${LIBRARY_DIR}/dfa/DFA.cpp\"\n-    \"${LIBRARY_DIR}/dfa/DFASerializer.cpp\"\n-    \"${LIBRARY_DIR}/dfa/DFAState.cpp\"\n-    \"${LIBRARY_DIR}/dfa/LexerDFASerializer.cpp\"\n-    \"${LIBRARY_DIR}/DiagnosticErrorListener.cpp\"\n-    \"${LIBRARY_DIR}/Exceptions.cpp\"\n-    \"${LIBRARY_DIR}/FailedPredicateException.cpp\"\n-    \"${LIBRARY_DIR}/InputMismatchException.cpp\"\n-    \"${LIBRARY_DIR}/InterpreterRuleContext.cpp\"\n-    \"${LIBRARY_DIR}/IntStream.cpp\"\n-    \"${LIBRARY_DIR}/Lexer.cpp\"\n-    \"${LIBRARY_DIR}/LexerInterpreter.cpp\"\n-    \"${LIBRARY_DIR}/LexerNoViableAltException.cpp\"\n-    \"${LIBRARY_DIR}/ListTokenSource.cpp\"\n-    \"${LIBRARY_DIR}/misc/InterpreterDataReader.cpp\"\n-    \"${LIBRARY_DIR}/misc/Interval.cpp\"\n-    \"${LIBRARY_DIR}/misc/IntervalSet.cpp\"\n-    \"${LIBRARY_DIR}/misc/MurmurHash.cpp\"\n-    \"${LIBRARY_DIR}/misc/Predicate.cpp\"\n-    \"${LIBRARY_DIR}/NoViableAltException.cpp\"\n-    \"${LIBRARY_DIR}/Parser.cpp\"\n-    \"${LIBRARY_DIR}/ParserInterpreter.cpp\"\n-    \"${LIBRARY_DIR}/ParserRuleContext.cpp\"\n-    \"${LIBRARY_DIR}/ProxyErrorListener.cpp\"\n-    \"${LIBRARY_DIR}/RecognitionException.cpp\"\n-    \"${LIBRARY_DIR}/Recognizer.cpp\"\n-    \"${LIBRARY_DIR}/RuleContext.cpp\"\n-    \"${LIBRARY_DIR}/RuleContextWithAltNum.cpp\"\n-    \"${LIBRARY_DIR}/RuntimeMetaData.cpp\"\n-    \"${LIBRARY_DIR}/support/Any.cpp\"\n-    \"${LIBRARY_DIR}/support/Arrays.cpp\"\n-    \"${LIBRARY_DIR}/support/CPPUtils.cpp\"\n-    \"${LIBRARY_DIR}/support/guid.cpp\"\n-    \"${LIBRARY_DIR}/support/StringUtils.cpp\"\n-    \"${LIBRARY_DIR}/Token.cpp\"\n-    \"${LIBRARY_DIR}/TokenSource.cpp\"\n-    \"${LIBRARY_DIR}/TokenStream.cpp\"\n-    \"${LIBRARY_DIR}/TokenStreamRewriter.cpp\"\n-    \"${LIBRARY_DIR}/tree/ErrorNode.cpp\"\n-    \"${LIBRARY_DIR}/tree/ErrorNodeImpl.cpp\"\n-    \"${LIBRARY_DIR}/tree/IterativeParseTreeWalker.cpp\"\n-    \"${LIBRARY_DIR}/tree/ParseTree.cpp\"\n-    \"${LIBRARY_DIR}/tree/ParseTreeListener.cpp\"\n-    \"${LIBRARY_DIR}/tree/ParseTreeVisitor.cpp\"\n-    \"${LIBRARY_DIR}/tree/ParseTreeWalker.cpp\"\n-    \"${LIBRARY_DIR}/tree/pattern/Chunk.cpp\"\n-    \"${LIBRARY_DIR}/tree/pattern/ParseTreeMatch.cpp\"\n-    \"${LIBRARY_DIR}/tree/pattern/ParseTreePattern.cpp\"\n-    \"${LIBRARY_DIR}/tree/pattern/ParseTreePatternMatcher.cpp\"\n-    \"${LIBRARY_DIR}/tree/pattern/RuleTagToken.cpp\"\n-    \"${LIBRARY_DIR}/tree/pattern/TagChunk.cpp\"\n-    \"${LIBRARY_DIR}/tree/pattern/TextChunk.cpp\"\n-    \"${LIBRARY_DIR}/tree/pattern/TokenTagToken.cpp\"\n-    \"${LIBRARY_DIR}/tree/TerminalNode.cpp\"\n-    \"${LIBRARY_DIR}/tree/TerminalNodeImpl.cpp\"\n-    \"${LIBRARY_DIR}/tree/Trees.cpp\"\n-    \"${LIBRARY_DIR}/tree/xpath/XPath.cpp\"\n-    \"${LIBRARY_DIR}/tree/xpath/XPathElement.cpp\"\n-    \"${LIBRARY_DIR}/tree/xpath/XPathLexer.cpp\"\n-    \"${LIBRARY_DIR}/tree/xpath/XPathLexerErrorListener.cpp\"\n-    \"${LIBRARY_DIR}/tree/xpath/XPathRuleAnywhereElement.cpp\"\n-    \"${LIBRARY_DIR}/tree/xpath/XPathRuleElement.cpp\"\n-    \"${LIBRARY_DIR}/tree/xpath/XPathTokenAnywhereElement.cpp\"\n-    \"${LIBRARY_DIR}/tree/xpath/XPathTokenElement.cpp\"\n-    \"${LIBRARY_DIR}/tree/xpath/XPathWildcardAnywhereElement.cpp\"\n-    \"${LIBRARY_DIR}/tree/xpath/XPathWildcardElement.cpp\"\n-    \"${LIBRARY_DIR}/UnbufferedCharStream.cpp\"\n-    \"${LIBRARY_DIR}/UnbufferedTokenStream.cpp\"\n-    \"${LIBRARY_DIR}/Vocabulary.cpp\"\n-    \"${LIBRARY_DIR}/WritableToken.cpp\"\n-)\n-\n-add_library (antlr4-runtime ${SRCS})\n-\n-target_include_directories (antlr4-runtime SYSTEM PUBLIC ${LIBRARY_DIR})\ndiff --git a/src/CMakeLists.txt b/src/CMakeLists.txt\nindex 88a6113b8fa8..fc1064ffcc74 100644\n--- a/src/CMakeLists.txt\n+++ b/src/CMakeLists.txt\n@@ -54,7 +54,6 @@ add_subdirectory (Dictionaries)\n add_subdirectory (Disks)\n add_subdirectory (Storages)\n add_subdirectory (Parsers)\n-add_subdirectory (Parsers/New)\n add_subdirectory (IO)\n add_subdirectory (Functions)\n add_subdirectory (Interpreters)\n@@ -222,12 +221,12 @@ endif()\n \n if (MAKE_STATIC_LIBRARIES OR NOT SPLIT_SHARED_LIBRARIES)\n     add_library (dbms STATIC ${dbms_headers} ${dbms_sources})\n-    target_link_libraries (dbms PRIVATE clickhouse_parsers_new jemalloc libdivide ${DBMS_COMMON_LIBRARIES})\n+    target_link_libraries (dbms PRIVATE jemalloc libdivide ${DBMS_COMMON_LIBRARIES})\n     set (all_modules dbms)\n else()\n     add_library (dbms SHARED ${dbms_headers} ${dbms_sources})\n     target_link_libraries (dbms PUBLIC ${all_modules} ${DBMS_COMMON_LIBRARIES})\n-    target_link_libraries (clickhouse_interpreters PRIVATE clickhouse_parsers_new jemalloc libdivide)\n+    target_link_libraries (clickhouse_interpreters PRIVATE jemalloc libdivide)\n     list (APPEND all_modules dbms)\n     # force all split libs to be linked\n     if (OS_DARWIN)\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 0197bfac7e48..9eec38f97883 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -445,7 +445,6 @@ class IColumn;\n     M(Bool, allow_experimental_window_functions, false, \"Allow experimental window functions\", 0) \\\n     M(Bool, allow_experimental_projection_optimization, false, \"Enable projection optimization when processing SELECT queries\", 0) \\\n     M(Bool, force_optimize_projection, false, \"If projection optimization is enabled, SELECT queries need to use projection\", 0) \\\n-    M(Bool, use_antlr_parser, false, \"Parse incoming queries using ANTLR-generated experimental parser\", 0) \\\n     M(Bool, async_socket_for_remote, true, \"Asynchronously read from socket executing remote query\", 0) \\\n     M(Bool, insert_null_as_default, true, \"Insert DEFAULT values instead of NULL in INSERT SELECT (UNION ALL)\", 0) \\\n     \\\ndiff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp\nindex c69a5bcd3e12..5b55754f00ad 100644\n--- a/src/Interpreters/executeQuery.cpp\n+++ b/src/Interpreters/executeQuery.cpp\n@@ -26,11 +26,6 @@\n #include <Parsers/ASTShowProcesslistQuery.h>\n #include <Parsers/ASTWatchQuery.h>\n #include <Parsers/Lexer.h>\n-\n-#if !defined(ARCADIA_BUILD)\n-#    include <Parsers/New/parseQuery.h>  // Y_IGNORE\n-#endif\n-\n #include <Parsers/parseQuery.h>\n #include <Parsers/ParserQuery.h>\n #include <Parsers/queryNormalization.h>\n@@ -166,11 +161,10 @@ static void logQuery(const String & query, ContextPtr context, bool internal)\n         if (!comment.empty())\n             comment = fmt::format(\" (comment: {})\", comment);\n \n-        LOG_DEBUG(&Poco::Logger::get(\"executeQuery\"), \"(from {}{}{}, using {} parser){} {}\",\n+        LOG_DEBUG(&Poco::Logger::get(\"executeQuery\"), \"(from {}{}{}){} {}\",\n             client_info.current_address.toString(),\n             (current_user != \"default\" ? \", user: \" + current_user : \"\"),\n             (!initial_query_id.empty() && current_query_id != initial_query_id ? \", initial_query_id: \" + initial_query_id : std::string()),\n-            (context->getSettingsRef().use_antlr_parser ? \"experimental\" : \"production\"),\n             comment,\n             joinLines(query));\n \n@@ -386,24 +380,10 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n     String query_table;\n     try\n     {\n-#if !defined(ARCADIA_BUILD)\n-        if (settings.use_antlr_parser)\n-        {\n-            ast = parseQuery(begin, end, max_query_size, settings.max_parser_depth, context->getCurrentDatabase());\n-        }\n-        else\n-        {\n-            ParserQuery parser(end);\n-\n-            /// TODO: parser should fail early when max_query_size limit is reached.\n-            ast = parseQuery(parser, begin, end, \"\", max_query_size, settings.max_parser_depth);\n-        }\n-#else\n         ParserQuery parser(end);\n \n         /// TODO: parser should fail early when max_query_size limit is reached.\n         ast = parseQuery(parser, begin, end, \"\", max_query_size, settings.max_parser_depth);\n-#endif\n \n         /// Interpret SETTINGS clauses as early as possible (before invoking the corresponding interpreter),\n         /// to allow settings to take effect.\ndiff --git a/src/Parsers/New/AST/AlterTableQuery.cpp b/src/Parsers/New/AST/AlterTableQuery.cpp\ndeleted file mode 100644\nindex e1ea54b61e5e..000000000000\n--- a/src/Parsers/New/AST/AlterTableQuery.cpp\n+++ /dev/null\n@@ -1,814 +0,0 @@\n-#include <Parsers/New/AST/AlterTableQuery.h>\n-\n-#include <Interpreters/StorageID.h>\n-#include <Parsers/ASTAlterQuery.h>\n-#include <Parsers/ASTAssignment.h>\n-#include <Parsers/ASTColumnDeclaration.h>\n-#include <Parsers/ASTFunction.h>\n-#include <Parsers/ASTIdentifier.h>\n-#include <Parsers/ASTPartition.h>\n-#include <Parsers/New/AST/ColumnExpr.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/AST/Literal.h>\n-#include <Parsers/New/AST/TableElementExpr.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-AssignmentExpr::AssignmentExpr(PtrTo<Identifier> identifier, PtrTo<ColumnExpr> expr) : INode{identifier, expr}\n-{\n-}\n-\n-ASTPtr AssignmentExpr::convertToOld() const\n-{\n-    auto expr = std::make_shared<ASTAssignment>();\n-\n-    expr->column_name = get(IDENTIFIER)->convertToOld()->getColumnName();\n-    expr->children.push_back(get(EXPR)->convertToOld());\n-\n-    return expr;\n-}\n-\n-PartitionClause::PartitionClause(PtrTo<Literal> id) : PartitionClause(ClauseType::ID, {id})\n-{\n-}\n-\n-PartitionClause::PartitionClause(PtrTo<List<Literal>> list) : PartitionClause(ClauseType::LIST, {list})\n-{\n-}\n-\n-PartitionClause::PartitionClause(ClauseType type, PtrList exprs) : INode(exprs), clause_type(type)\n-{\n-}\n-\n-ASTPtr PartitionClause::convertToOld() const\n-{\n-    auto partition = std::make_shared<ASTPartition>();\n-\n-    switch(clause_type)\n-    {\n-        case ClauseType::ID:\n-            partition->id = get<StringLiteral>(ID)->as<String>();\n-            break;\n-        case ClauseType::LIST:\n-            {\n-                auto tuple = std::make_shared<ASTFunction>();\n-\n-                tuple->name = \"tuple\";\n-                tuple->arguments = std::make_shared<ASTExpressionList>();\n-                for (const auto & child : get(LIST)->as<List<Literal> &>())\n-                    tuple->arguments->children.push_back(child->convertToOld());\n-                tuple->children.push_back(tuple->arguments);\n-\n-                partition->value = tuple;\n-                partition->children.push_back(partition->value);\n-                partition->fields_count = get<List<Literal>>(LIST)->size();\n-                partition->fields_str = get(LIST)->toString();\n-            }\n-            break;\n-    }\n-\n-    return partition;\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createAddColumn(bool if_not_exists, PtrTo<TableElementExpr> element, PtrTo<Identifier> after)\n-{\n-    assert(element->getType() == TableElementExpr::ExprType::COLUMN);\n-    PtrTo<AlterTableClause> query(new AlterTableClause(ClauseType::ADD_COLUMN, {element, after}));\n-    query->if_not_exists = if_not_exists;\n-    return query;\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createAddIndex(bool if_not_exists, PtrTo<TableElementExpr> element, PtrTo<Identifier> after)\n-{\n-    assert(element->getType() == TableElementExpr::ExprType::INDEX);\n-    PtrTo<AlterTableClause> query(new AlterTableClause(ClauseType::ADD_INDEX, {element, after}));\n-    query->if_not_exists = if_not_exists;\n-    return query;\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createAddProjection(bool if_not_exists, PtrTo<TableElementExpr> element, PtrTo<Identifier> after)\n-{\n-    assert(element->getType() == TableElementExpr::ExprType::PROJECTION);\n-    PtrTo<AlterTableClause> query(new AlterTableClause(ClauseType::ADD_PROJECTION, {element, after}));\n-    query->if_not_exists = if_not_exists;\n-    return query;\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createAttach(PtrTo<PartitionClause> clause, PtrTo<TableIdentifier> from)\n-{\n-    return PtrTo<AlterTableClause>(new AlterTableClause(ClauseType::ATTACH, {clause, from}));\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createClearColumn(bool if_exists, PtrTo<Identifier> identifier, PtrTo<PartitionClause> in)\n-{\n-    PtrTo<AlterTableClause> query(new AlterTableClause(ClauseType::CLEAR_COLUMN, {identifier, in}));\n-    query->if_exists = if_exists;\n-    return query;\n-}\n-\n-PtrTo<AlterTableClause> AlterTableClause::createClearIndex(bool if_exists, PtrTo<Identifier> identifier, PtrTo<PartitionClause> in)\n-{\n-    PtrTo<AlterTableClause> query(new AlterTableClause(ClauseType::CLEAR_INDEX, {identifier, in}));\n-    query->if_exists = if_exists;\n-    return query;\n-}\n-\n-PtrTo<AlterTableClause> AlterTableClause::createClearProjection(bool if_exists, PtrTo<Identifier> identifier, PtrTo<PartitionClause> in)\n-{\n-    PtrTo<AlterTableClause> query(new AlterTableClause(ClauseType::CLEAR_PROJECTION, {identifier, in}));\n-    query->if_exists = if_exists;\n-    return query;\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createCodec(bool if_exists, PtrTo<Identifier> identifier, PtrTo<CodecExpr> codec)\n-{\n-    PtrTo<AlterTableClause> query(new AlterTableClause(ClauseType::CODEC, {identifier, codec}));\n-    query->if_exists = if_exists;\n-    return query;\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createComment(bool if_exists, PtrTo<Identifier> identifier, PtrTo<StringLiteral> comment)\n-{\n-    PtrTo<AlterTableClause> query(new AlterTableClause(ClauseType::COMMENT, {identifier, comment}));\n-    query->if_exists = if_exists;\n-    return query;\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createDelete(PtrTo<ColumnExpr> expr)\n-{\n-    return PtrTo<AlterTableClause>(new AlterTableClause(ClauseType::DELETE, {expr}));\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createDetach(PtrTo<PartitionClause> clause)\n-{\n-    return PtrTo<AlterTableClause>(new AlterTableClause(ClauseType::DETACH, {clause}));\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createDropColumn(bool if_exists, PtrTo<Identifier> identifier)\n-{\n-    PtrTo<AlterTableClause> query(new AlterTableClause(ClauseType::DROP_COLUMN, {identifier}));\n-    query->if_exists = if_exists;\n-    return query;\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createDropIndex(bool if_exists, PtrTo<Identifier> identifier)\n-{\n-    PtrTo<AlterTableClause> query(new AlterTableClause(ClauseType::DROP_INDEX, {identifier}));\n-    query->if_exists = if_exists;\n-    return query;\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createDropProjection(bool if_exists, PtrTo<Identifier> identifier)\n-{\n-    PtrTo<AlterTableClause> query(new AlterTableClause(ClauseType::DROP_PROJECTION, {identifier}));\n-    query->if_exists = if_exists;\n-    return query;\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createDropPartition(PtrTo<PartitionClause> clause)\n-{\n-    return PtrTo<AlterTableClause>(new AlterTableClause(ClauseType::DROP_PARTITION, {clause}));\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createFreezePartition(PtrTo<PartitionClause> clause)\n-{\n-    return PtrTo<AlterTableClause>(new AlterTableClause(ClauseType::FREEZE_PARTITION, {clause}));\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createMaterializeIndex(bool if_exists, PtrTo<Identifier> identifier, PtrTo<PartitionClause> in)\n-{\n-    PtrTo<AlterTableClause> query(new AlterTableClause(ClauseType::MATERIALIZE_INDEX, {identifier, in}));\n-    query->if_exists = if_exists;\n-    return query;\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createMaterializeProjection(bool if_exists, PtrTo<Identifier> identifier, PtrTo<PartitionClause> in)\n-{\n-    PtrTo<AlterTableClause> query(new AlterTableClause(ClauseType::MATERIALIZE_PROJECTION, {identifier, in}));\n-    query->if_exists = if_exists;\n-    return query;\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createModify(bool if_exists, PtrTo<TableElementExpr> element)\n-{\n-    // TODO: assert(element->getType() == TableElementExpr::ExprType::COLUMN);\n-    PtrTo<AlterTableClause> query(new AlterTableClause(ClauseType::MODIFY, {element}));\n-    query->if_exists = if_exists;\n-    return query;\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createMovePartitionToDisk(PtrTo<PartitionClause> clause, PtrTo<StringLiteral> literal)\n-{\n-    return PtrTo<AlterTableClause>(new AlterTableClause(ClauseType::MOVE_PARTITION_TO_DISK, {clause, literal}));\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createMovePartitionToTable(PtrTo<PartitionClause> clause, PtrTo<TableIdentifier> identifier)\n-{\n-    return PtrTo<AlterTableClause>(new AlterTableClause(ClauseType::MOVE_PARTITION_TO_TABLE, {clause, identifier}));\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createMovePartitionToVolume(PtrTo<PartitionClause> clause, PtrTo<StringLiteral> literal)\n-{\n-    return PtrTo<AlterTableClause>(new AlterTableClause(ClauseType::MOVE_PARTITION_TO_VOLUME, {clause, literal}));\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createOrderBy(PtrTo<ColumnExpr> expr)\n-{\n-    return PtrTo<AlterTableClause>(new AlterTableClause(ClauseType::ORDER_BY, {expr}));\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createRemove(bool if_exists, PtrTo<Identifier> identifier, TableColumnPropertyType type)\n-{\n-    PtrTo<AlterTableClause> query(new AlterTableClause(ClauseType::REMOVE, {identifier}));\n-    query->if_exists = if_exists;\n-    query->property_type = type;\n-    return query;\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createRemoveTTL()\n-{\n-    return PtrTo<AlterTableClause>(new AlterTableClause(ClauseType::REMOVE_TTL, {}));\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createRename(bool if_exists, PtrTo<Identifier> identifier, PtrTo<Identifier> to)\n-{\n-    PtrTo<AlterTableClause> query(new AlterTableClause(ClauseType::RENAME, {identifier, to}));\n-    query->if_exists = if_exists;\n-    return query;\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createReplace(PtrTo<PartitionClause> clause, PtrTo<TableIdentifier> from)\n-{\n-    return PtrTo<AlterTableClause>(new AlterTableClause(ClauseType::REPLACE, {clause, from}));\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createTTL(PtrTo<TTLClause> clause)\n-{\n-    return PtrTo<AlterTableClause>(new AlterTableClause(ClauseType::TTL, {clause}));\n-}\n-\n-// static\n-PtrTo<AlterTableClause> AlterTableClause::createUpdate(PtrTo<AssignmentExprList> list, PtrTo<WhereClause> where)\n-{\n-    return PtrTo<AlterTableClause>(new AlterTableClause(ClauseType::UPDATE, {list, where}));\n-}\n-\n-ASTPtr AlterTableClause::convertToOld() const\n-{\n-    auto command = std::make_shared<ASTAlterCommand>();\n-\n-    switch(clause_type)\n-    {\n-        case ClauseType::ADD_COLUMN:\n-            command->type = ASTAlterCommand::ADD_COLUMN;\n-            command->if_not_exists = if_not_exists;\n-            // TODO: command->first\n-            command->col_decl = get(ELEMENT)->convertToOld();\n-            if (has(AFTER)) command->column = get(AFTER)->convertToOld();\n-            break;\n-\n-        case ClauseType::ADD_INDEX:\n-            command->type = ASTAlterCommand::ADD_INDEX;\n-            command->if_not_exists = if_not_exists;\n-            command->index_decl = get(ELEMENT)->convertToOld();\n-            if (has(AFTER)) command->index = get(AFTER)->convertToOld();\n-            break;\n-\n-        case ClauseType::ADD_PROJECTION:\n-            command->type = ASTAlterCommand::ADD_PROJECTION;\n-            command->if_not_exists = if_not_exists;\n-            command->projection_decl = get(ELEMENT)->convertToOld();\n-            if (has(AFTER)) command->projection = get(AFTER)->convertToOld();\n-            break;\n-\n-        case ClauseType::ATTACH:\n-            command->type = ASTAlterCommand::ATTACH_PARTITION;\n-            command->partition = get(PARTITION)->convertToOld();\n-\n-            if (has(FROM))\n-            {\n-                auto table = get(FROM)->convertToOld();\n-                command->from_database = table->as<ASTTableIdentifier>()->getDatabaseName();\n-                command->from_table = table->as<ASTTableIdentifier>()->shortName();\n-                command->replace = false;\n-                command->type = ASTAlterCommand::REPLACE_PARTITION;\n-            }\n-            break;\n-\n-        case ClauseType::CLEAR_COLUMN:\n-            command->type = ASTAlterCommand::DROP_COLUMN;\n-            command->if_exists = if_exists;\n-            command->clear_column = true;\n-            command->detach = false;\n-            command->column = get(ELEMENT)->convertToOld();\n-            if (has(IN)) command->partition = get(IN)->convertToOld();\n-            break;\n-\n-        case ClauseType::CLEAR_INDEX:\n-            command->type = ASTAlterCommand::DROP_INDEX;\n-            command->if_exists = if_exists;\n-            command->clear_index = true;\n-            command->detach = false;\n-            command->index = get(ELEMENT)->convertToOld();\n-            if (has(IN)) command->partition = get(IN)->convertToOld();\n-            break;\n-\n-        case ClauseType::CLEAR_PROJECTION:\n-            command->type = ASTAlterCommand::DROP_PROJECTION;\n-            command->if_exists = if_exists;\n-            command->clear_projection = true;\n-            command->detach = false;\n-            command->projection = get(ELEMENT)->convertToOld();\n-            if (has(IN)) command->partition = get(IN)->convertToOld();\n-            break;\n-\n-        case ClauseType::CODEC:\n-            command->type = ASTAlterCommand::MODIFY_COLUMN;\n-            command->if_exists = if_exists;\n-\n-            {\n-                auto column = std::make_shared<ASTColumnDeclaration>();\n-                column->name = get(COLUMN)->toString();\n-                column->codec = get(CODEC)->convertToOld();\n-\n-                command->col_decl = column;\n-            }\n-            break;\n-\n-        case ClauseType::COMMENT:\n-            command->type = ASTAlterCommand::COMMENT_COLUMN;\n-            command->if_exists = if_exists;\n-            command->column = get(COLUMN)->convertToOld();\n-            command->comment = get(COMMENT)->convertToOld();\n-            break;\n-\n-        case ClauseType::DELETE:\n-            command->type = ASTAlterCommand::DELETE;\n-            command->predicate = get(EXPR)->convertToOld();\n-            break;\n-\n-        case ClauseType::DETACH:\n-            command->type = ASTAlterCommand::DROP_PARTITION;\n-            command->detach = true;\n-            command->partition = get(PARTITION)->convertToOld();\n-            break;\n-\n-        case ClauseType::DROP_COLUMN:\n-            command->type = ASTAlterCommand::DROP_COLUMN;\n-            command->if_exists = if_exists;\n-            command->detach = false;\n-            command->column = get(ELEMENT)->convertToOld();\n-            break;\n-\n-        case ClauseType::DROP_INDEX:\n-            command->type = ASTAlterCommand::DROP_INDEX;\n-            command->if_exists = if_exists;\n-            command->detach = false;\n-            command->index = get(ELEMENT)->convertToOld();\n-            break;\n-\n-        case ClauseType::DROP_PROJECTION:\n-            command->type = ASTAlterCommand::DROP_PROJECTION;\n-            command->if_exists = if_exists;\n-            command->detach = false;\n-            command->projection = get(ELEMENT)->convertToOld();\n-            break;\n-\n-        case ClauseType::DROP_PARTITION:\n-            command->type = ASTAlterCommand::DROP_PARTITION;\n-            command->partition = get(PARTITION)->convertToOld();\n-            break;\n-\n-        case ClauseType::FREEZE_PARTITION:\n-            if (has(PARTITION))\n-            {\n-                command->type = ASTAlterCommand::FREEZE_PARTITION;\n-                command->partition = get(PARTITION)->convertToOld();\n-            }\n-            else\n-                command->type = ASTAlterCommand::FREEZE_ALL;\n-            break;\n-\n-        case ClauseType::MATERIALIZE_INDEX:\n-            command->type = ASTAlterCommand::MATERIALIZE_INDEX;\n-            command->if_exists = if_exists;\n-            command->index = get(ELEMENT)->convertToOld();\n-            if (has(IN)) command->partition = get(IN)->convertToOld();\n-            break;\n-\n-        case ClauseType::MATERIALIZE_PROJECTION:\n-            command->type = ASTAlterCommand::MATERIALIZE_PROJECTION;\n-            command->if_exists = if_exists;\n-            command->projection = get(ELEMENT)->convertToOld();\n-            if (has(IN)) command->partition = get(IN)->convertToOld();\n-            break;\n-\n-        case ClauseType::MODIFY:\n-            command->type = ASTAlterCommand::MODIFY_COLUMN;\n-            command->if_exists = if_exists;\n-            command->col_decl = get(ELEMENT)->convertToOld();\n-            break;\n-\n-        case ClauseType::MOVE_PARTITION_TO_DISK:\n-            command->type = ASTAlterCommand::MOVE_PARTITION;\n-            command->partition = get(PARTITION)->convertToOld();\n-            command->move_destination_type = DataDestinationType::DISK;\n-            command->move_destination_name = get(TO)->convertToOld()->as<ASTLiteral>()->value.get<String>();\n-            break;\n-\n-        case ClauseType::MOVE_PARTITION_TO_TABLE:\n-            command->type = ASTAlterCommand::MOVE_PARTITION;\n-            command->partition = get(PARTITION)->convertToOld();\n-            command->move_destination_type = DataDestinationType::TABLE;\n-            {\n-                auto table = get(TO)->convertToOld();\n-                command->to_database = table->as<ASTTableIdentifier>()->getDatabaseName();\n-                command->to_table = table->as<ASTTableIdentifier>()->shortName();\n-            }\n-            break;\n-\n-        case ClauseType::MOVE_PARTITION_TO_VOLUME:\n-            command->type = ASTAlterCommand::MOVE_PARTITION;\n-            command->partition = get(PARTITION)->convertToOld();\n-            command->move_destination_type = DataDestinationType::VOLUME;\n-            command->move_destination_name = get(TO)->convertToOld()->as<ASTLiteral>()->value.get<String>();\n-            break;\n-\n-        case ClauseType::REMOVE:\n-            command->type = ASTAlterCommand::MODIFY_COLUMN;\n-            command->if_exists = if_exists;\n-            {\n-                auto col_decl = std::make_shared<ASTColumnDeclaration>();\n-                col_decl->name = get(ELEMENT)->convertToOld()->getColumnName();\n-                command->col_decl = col_decl;\n-            }\n-            switch(property_type)\n-            {\n-                case TableColumnPropertyType::ALIAS:\n-                    command->remove_property = \"ALIAS\";\n-                    break;\n-                case TableColumnPropertyType::CODEC:\n-                    command->remove_property = \"CODEC\";\n-                    break;\n-                case TableColumnPropertyType::COMMENT:\n-                    command->remove_property = \"COMMENT\";\n-                    break;\n-                case TableColumnPropertyType::DEFAULT:\n-                    command->remove_property = \"DEFAULT\";\n-                    break;\n-                case TableColumnPropertyType::MATERIALIZED:\n-                    command->remove_property = \"MATERIALIZED\";\n-                    break;\n-                case TableColumnPropertyType::TTL:\n-                    command->remove_property = \"TTL\";\n-                    break;\n-            }\n-            break;\n-\n-        case ClauseType::REMOVE_TTL:\n-            command->type = ASTAlterCommand::REMOVE_TTL;\n-            break;\n-\n-        case ClauseType::RENAME:\n-            command->type = ASTAlterCommand::RENAME_COLUMN;\n-            command->column = get(COLUMN)->convertToOld();\n-            command->rename_to = get(TO)->convertToOld();\n-            break;\n-\n-        case ClauseType::ORDER_BY:\n-            command->type = ASTAlterCommand::MODIFY_ORDER_BY;\n-            command->order_by = get(EXPR)->convertToOld();\n-            break;\n-\n-        case ClauseType::REPLACE:\n-            command->type = ASTAlterCommand::REPLACE_PARTITION;\n-            command->replace = true;\n-            command->partition = get(PARTITION)->convertToOld();\n-            {\n-                auto table = get(FROM)->convertToOld();\n-                command->from_database = table->as<ASTTableIdentifier>()->getDatabaseName();\n-                command->from_table = table->as<ASTTableIdentifier>()->shortName();\n-            }\n-            break;\n-\n-        case ClauseType::TTL:\n-            command->type = ASTAlterCommand::MODIFY_TTL;\n-            command->ttl = get(CLAUSE)->convertToOld();\n-            break;\n-\n-        case ClauseType::UPDATE:\n-            command->type = ASTAlterCommand::UPDATE;\n-            command->update_assignments = get(ASSIGNMENTS)->convertToOld();\n-            command->predicate = get(WHERE)->convertToOld();\n-            break;\n-    }\n-\n-    if (command->col_decl)\n-        command->children.push_back(command->col_decl);\n-    if (command->column)\n-        command->children.push_back(command->column);\n-    if (command->partition)\n-        command->children.push_back(command->partition);\n-    if (command->order_by)\n-        command->children.push_back(command->order_by);\n-    if (command->sample_by)\n-        command->children.push_back(command->sample_by);\n-    if (command->predicate)\n-        command->children.push_back(command->predicate);\n-    if (command->update_assignments)\n-        command->children.push_back(command->update_assignments);\n-    if (command->values)\n-        command->children.push_back(command->values);\n-    if (command->comment)\n-        command->children.push_back(command->comment);\n-    if (command->ttl)\n-        command->children.push_back(command->ttl);\n-    if (command->settings_changes)\n-        command->children.push_back(command->settings_changes);\n-\n-    return command;\n-}\n-\n-AlterTableClause::AlterTableClause(ClauseType type, PtrList exprs) : INode(exprs), clause_type(type)\n-{\n-}\n-\n-AlterTableQuery::AlterTableQuery(PtrTo<ClusterClause> cluster, PtrTo<TableIdentifier> identifier, PtrTo<List<AlterTableClause>> clauses)\n-    : DDLQuery(cluster, {identifier, clauses})\n-{\n-}\n-\n-ASTPtr AlterTableQuery::convertToOld() const\n-{\n-    auto query = std::make_shared<ASTAlterQuery>();\n-\n-    {\n-        auto table = get(TABLE)->convertToOld();\n-        query->database = table->as<ASTTableIdentifier>()->getDatabaseName();\n-        query->table = table->as<ASTTableIdentifier>()->shortName();\n-    }\n-\n-    query->cluster = cluster_name;\n-\n-    query->set(query->command_list, get(CLAUSES)->convertToOld());\n-\n-    return query;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseAddColumn(ClickHouseParser::AlterTableClauseAddColumnContext * ctx)\n-{\n-    auto after = ctx->AFTER() ? visit(ctx->nestedIdentifier()).as<PtrTo<Identifier>>() : nullptr;\n-    return AlterTableClause::createAddColumn(!!ctx->IF(), visit(ctx->tableColumnDfnt()), after);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseAddIndex(ClickHouseParser::AlterTableClauseAddIndexContext * ctx)\n-{\n-    auto after = ctx->AFTER() ? visit(ctx->nestedIdentifier()).as<PtrTo<Identifier>>() : nullptr;\n-    return AlterTableClause::createAddIndex(!!ctx->IF(), visit(ctx->tableIndexDfnt()), after);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseAddProjection(ClickHouseParser::AlterTableClauseAddProjectionContext * ctx)\n-{\n-    auto after = ctx->AFTER() ? visit(ctx->nestedIdentifier()).as<PtrTo<Identifier>>() : nullptr;\n-    return AlterTableClause::createAddProjection(!!ctx->IF(), visit(ctx->tableProjectionDfnt()), after);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseAttach(ClickHouseParser::AlterTableClauseAttachContext *ctx)\n-{\n-    auto from = ctx->tableIdentifier() ? visit(ctx->tableIdentifier()).as<PtrTo<TableIdentifier>>() : nullptr;\n-    return AlterTableClause::createAttach(visit(ctx->partitionClause()), from);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseClearColumn(ClickHouseParser::AlterTableClauseClearColumnContext * ctx)\n-{\n-    auto partition = ctx->partitionClause() ? visit(ctx->partitionClause()).as<PtrTo<PartitionClause>>() : nullptr;\n-    return AlterTableClause::createClearColumn(!!ctx->IF(), visit(ctx->nestedIdentifier()), partition);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseClearIndex(ClickHouseParser::AlterTableClauseClearIndexContext * ctx)\n-{\n-    auto partition = ctx->partitionClause() ? visit(ctx->partitionClause()).as<PtrTo<PartitionClause>>() : nullptr;\n-    return AlterTableClause::createClearIndex(!!ctx->IF(), visit(ctx->nestedIdentifier()), partition);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseClearProjection(ClickHouseParser::AlterTableClauseClearProjectionContext * ctx)\n-{\n-    auto partition = ctx->partitionClause() ? visit(ctx->partitionClause()).as<PtrTo<PartitionClause>>() : nullptr;\n-    return AlterTableClause::createClearProjection(!!ctx->IF(), visit(ctx->nestedIdentifier()), partition);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseComment(ClickHouseParser::AlterTableClauseCommentContext * ctx)\n-{\n-    return AlterTableClause::createComment(!!ctx->IF(), visit(ctx->nestedIdentifier()), Literal::createString(ctx->STRING_LITERAL()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseDelete(ClickHouseParser::AlterTableClauseDeleteContext *ctx)\n-{\n-    return AlterTableClause::createDelete(visit(ctx->columnExpr()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseDetach(ClickHouseParser::AlterTableClauseDetachContext *ctx)\n-{\n-    return AlterTableClause::createDetach(visit(ctx->partitionClause()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseDropColumn(ClickHouseParser::AlterTableClauseDropColumnContext * ctx)\n-{\n-    return AlterTableClause::createDropColumn(!!ctx->IF(), visit(ctx->nestedIdentifier()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseDropIndex(ClickHouseParser::AlterTableClauseDropIndexContext * ctx)\n-{\n-    return AlterTableClause::createDropIndex(!!ctx->IF(), visit(ctx->nestedIdentifier()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseDropProjection(ClickHouseParser::AlterTableClauseDropProjectionContext * ctx)\n-{\n-    return AlterTableClause::createDropProjection(!!ctx->IF(), visit(ctx->nestedIdentifier()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseDropPartition(ClickHouseParser::AlterTableClauseDropPartitionContext *ctx)\n-{\n-    return AlterTableClause::createDropPartition(visit(ctx->partitionClause()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseFreezePartition(ClickHouseParser::AlterTableClauseFreezePartitionContext *ctx)\n-{\n-    auto clause = ctx->partitionClause() ? visit(ctx->partitionClause()).as<PtrTo<PartitionClause>>() : nullptr;\n-    return AlterTableClause::createFreezePartition(clause);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseMaterializeIndex(ClickHouseParser::AlterTableClauseMaterializeIndexContext * ctx)\n-{\n-    auto partition = ctx->partitionClause() ? visit(ctx->partitionClause()).as<PtrTo<PartitionClause>>() : nullptr;\n-    return AlterTableClause::createMaterializeIndex(!!ctx->IF(), visit(ctx->nestedIdentifier()), partition);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseMaterializeProjection(ClickHouseParser::AlterTableClauseMaterializeProjectionContext * ctx)\n-{\n-    auto partition = ctx->partitionClause() ? visit(ctx->partitionClause()).as<PtrTo<PartitionClause>>() : nullptr;\n-    return AlterTableClause::createMaterializeProjection(!!ctx->IF(), visit(ctx->nestedIdentifier()), partition);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseModify(ClickHouseParser::AlterTableClauseModifyContext * ctx)\n-{\n-    return AlterTableClause::createModify(!!ctx->IF(), visit(ctx->tableColumnDfnt()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseModifyCodec(ClickHouseParser::AlterTableClauseModifyCodecContext * ctx)\n-{\n-    return AlterTableClause::createCodec(!!ctx->IF(), visit(ctx->nestedIdentifier()), visit(ctx->codecExpr()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseModifyComment(ClickHouseParser::AlterTableClauseModifyCommentContext *ctx)\n-{\n-    return AlterTableClause::createComment(!!ctx->IF(), visit(ctx->nestedIdentifier()), Literal::createString(ctx->STRING_LITERAL()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseModifyOrderBy(ClickHouseParser::AlterTableClauseModifyOrderByContext * ctx)\n-{\n-    return AlterTableClause::createOrderBy(visit(ctx->columnExpr()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseModifyRemove(ClickHouseParser::AlterTableClauseModifyRemoveContext *ctx)\n-{\n-    return AlterTableClause::createRemove(!!ctx->IF(), visit(ctx->nestedIdentifier()), visit(ctx->tableColumnPropertyType()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseModifyTTL(ClickHouseParser::AlterTableClauseModifyTTLContext *ctx)\n-{\n-    return AlterTableClause::createTTL(visit(ctx->ttlClause()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseMovePartition(ClickHouseParser::AlterTableClauseMovePartitionContext *ctx)\n-{\n-    if (ctx->DISK())\n-        return AlterTableClause::createMovePartitionToDisk(visit(ctx->partitionClause()), Literal::createString(ctx->STRING_LITERAL()));\n-    if (ctx->TABLE())\n-        return AlterTableClause::createMovePartitionToTable(visit(ctx->partitionClause()), visit(ctx->tableIdentifier()));\n-    if (ctx->VOLUME())\n-        return AlterTableClause::createMovePartitionToVolume(visit(ctx->partitionClause()), Literal::createString(ctx->STRING_LITERAL()));\n-    __builtin_unreachable();\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseRemoveTTL(ClickHouseParser::AlterTableClauseRemoveTTLContext *)\n-{\n-    return AlterTableClause::createRemoveTTL();\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseRename(ClickHouseParser::AlterTableClauseRenameContext *ctx)\n-{\n-    return AlterTableClause::createRename(!!ctx->IF(), visit(ctx->nestedIdentifier(0)), visit(ctx->nestedIdentifier(1)));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseReplace(ClickHouseParser::AlterTableClauseReplaceContext *ctx)\n-{\n-    return AlterTableClause::createReplace(visit(ctx->partitionClause()), visit(ctx->tableIdentifier()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableClauseUpdate(ClickHouseParser::AlterTableClauseUpdateContext *ctx)\n-{\n-    return AlterTableClause::createUpdate(visit(ctx->assignmentExprList()), visit(ctx->whereClause()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlterTableStmt(ClickHouseParser::AlterTableStmtContext * ctx)\n-{\n-    auto cluster = ctx->clusterClause() ? visit(ctx->clusterClause()).as<PtrTo<ClusterClause>>() : nullptr;\n-    auto list = std::make_shared<List<AlterTableClause>>();\n-    for (auto * clause : ctx->alterTableClause()) list->push(visit(clause));\n-    return std::make_shared<AlterTableQuery>(cluster, visit(ctx->tableIdentifier()), list);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAssignmentExpr(ClickHouseParser::AssignmentExprContext *ctx)\n-{\n-    return std::make_shared<AssignmentExpr>(visit(ctx->nestedIdentifier()), visit(ctx->columnExpr()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitAssignmentExprList(ClickHouseParser::AssignmentExprListContext *ctx)\n-{\n-    auto list = std::make_shared<AssignmentExprList>();\n-    for (auto * expr : ctx->assignmentExpr()) list->push(visit(expr));\n-    return list;\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitTableColumnPropertyType(ClickHouseParser::TableColumnPropertyTypeContext *ctx)\n-{\n-    if (ctx->ALIAS()) return TableColumnPropertyType::ALIAS;\n-    if (ctx->CODEC()) return TableColumnPropertyType::CODEC;\n-    if (ctx->COMMENT()) return TableColumnPropertyType::COMMENT;\n-    if (ctx->DEFAULT()) return TableColumnPropertyType::DEFAULT;\n-    if (ctx->MATERIALIZED()) return TableColumnPropertyType::MATERIALIZED;\n-    if (ctx->TTL()) return TableColumnPropertyType::TTL;\n-    __builtin_unreachable();\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitPartitionClause(ClickHouseParser::PartitionClauseContext *ctx)\n-{\n-    if (ctx->STRING_LITERAL())\n-        return std::make_shared<PartitionClause>(Literal::createString(ctx->STRING_LITERAL()));\n-\n-    auto expr = visit(ctx->columnExpr()).as<PtrTo<ColumnExpr>>();\n-\n-    if (expr->getType() == ColumnExpr::ExprType::LITERAL)\n-        return std::make_shared<PartitionClause>(PtrTo<List<Literal>>(new List<Literal>{expr->getLiteral()}));\n-\n-    if (expr->getType() == ColumnExpr::ExprType::FUNCTION && expr->getFunctionName() == \"tuple\")\n-    {\n-        auto list = std::make_shared<List<Literal>>();\n-\n-        for (auto it = expr->argumentsBegin(); it != expr->argumentsEnd(); ++it)\n-        {\n-            auto * literal = (*it)->as<ColumnExpr>();\n-\n-            if (literal->getType() == ColumnExpr::ExprType::LITERAL)\n-                list->push(literal->getLiteral());\n-            else\n-            {\n-                // TODO: 'Expected tuple of literals as Partition Expression'.\n-            }\n-        }\n-\n-        return std::make_shared<PartitionClause>(list);\n-    }\n-\n-    // TODO: 'Expected tuple of literals as Partition Expression'.\n-    __builtin_unreachable();\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/AlterTableQuery.h b/src/Parsers/New/AST/AlterTableQuery.h\ndeleted file mode 100644\nindex 7e7783c49ad4..000000000000\n--- a/src/Parsers/New/AST/AlterTableQuery.h\n+++ /dev/null\n@@ -1,191 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/DDLQuery.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class AssignmentExpr : public INode\n-{\n-    public:\n-        AssignmentExpr(PtrTo<Identifier> identifier, PtrTo<ColumnExpr> expr);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            IDENTIFIER = 0,  // Identifier\n-            EXPR = 1,        // ColumnExpr\n-        };\n-};\n-\n-enum class TableColumnPropertyType\n-{\n-    ALIAS,\n-    CODEC,\n-    COMMENT,\n-    DEFAULT,\n-    MATERIALIZED,\n-    TTL,\n-};\n-\n-class PartitionClause : public INode\n-{\n-    public:\n-        explicit PartitionClause(PtrTo<Literal> id);\n-        explicit PartitionClause(PtrTo<List<Literal>> list);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            ID = 0,    // Literal\n-            LIST = 0,  // List<Literal>\n-        };\n-        enum class ClauseType\n-        {\n-            ID,\n-            LIST,\n-        };\n-\n-        const ClauseType clause_type;\n-\n-        PartitionClause(ClauseType type, PtrList exprs);\n-};\n-\n-class AlterTableClause : public INode\n-{\n-    public:\n-        static PtrTo<AlterTableClause> createAddColumn(bool if_not_exists, PtrTo<TableElementExpr> element, PtrTo<Identifier> after);\n-        static PtrTo<AlterTableClause> createAddIndex(bool if_not_exists, PtrTo<TableElementExpr> element, PtrTo<Identifier> after);\n-        static PtrTo<AlterTableClause> createAddProjection(bool if_not_exists, PtrTo<TableElementExpr> element, PtrTo<Identifier> after);\n-        static PtrTo<AlterTableClause> createAttach(PtrTo<PartitionClause> clause, PtrTo<TableIdentifier> from);\n-        static PtrTo<AlterTableClause> createClearColumn(bool if_exists, PtrTo<Identifier> identifier, PtrTo<PartitionClause> in);\n-        static PtrTo<AlterTableClause> createClearIndex(bool if_exists, PtrTo<Identifier> identifier, PtrTo<PartitionClause> in);\n-        static PtrTo<AlterTableClause> createClearProjection(bool if_exists, PtrTo<Identifier> identifier, PtrTo<PartitionClause> in);\n-        static PtrTo<AlterTableClause> createCodec(bool if_exists, PtrTo<Identifier> identifier, PtrTo<CodecExpr> codec);\n-        static PtrTo<AlterTableClause> createComment(bool if_exists, PtrTo<Identifier> identifier, PtrTo<StringLiteral> comment);\n-        static PtrTo<AlterTableClause> createDelete(PtrTo<ColumnExpr> expr);\n-        static PtrTo<AlterTableClause> createDetach(PtrTo<PartitionClause> clause);\n-        static PtrTo<AlterTableClause> createDropColumn(bool if_exists, PtrTo<Identifier> identifier);\n-        static PtrTo<AlterTableClause> createDropIndex(bool if_exists, PtrTo<Identifier> identifier);\n-        static PtrTo<AlterTableClause> createDropProjection(bool if_exists, PtrTo<Identifier> identifier);\n-        static PtrTo<AlterTableClause> createDropPartition(PtrTo<PartitionClause> clause);\n-        static PtrTo<AlterTableClause> createFreezePartition(PtrTo<PartitionClause> clause);\n-        static PtrTo<AlterTableClause> createMaterializeIndex(bool if_exists, PtrTo<Identifier> identifier, PtrTo<PartitionClause> in);\n-        static PtrTo<AlterTableClause> createMaterializeProjection(bool if_exists, PtrTo<Identifier> identifier, PtrTo<PartitionClause> in);\n-        static PtrTo<AlterTableClause> createModify(bool if_exists, PtrTo<TableElementExpr> element);\n-        static PtrTo<AlterTableClause> createMovePartitionToDisk(PtrTo<PartitionClause> clause, PtrTo<StringLiteral> literal);\n-        static PtrTo<AlterTableClause> createMovePartitionToTable(PtrTo<PartitionClause> clause, PtrTo<TableIdentifier> identifier);\n-        static PtrTo<AlterTableClause> createMovePartitionToVolume(PtrTo<PartitionClause> clause, PtrTo<StringLiteral> literal);\n-        static PtrTo<AlterTableClause> createRemove(bool if_exists, PtrTo<Identifier> identifier, TableColumnPropertyType type);\n-        static PtrTo<AlterTableClause> createRemoveTTL();\n-        static PtrTo<AlterTableClause> createRename(bool if_exists, PtrTo<Identifier> identifier, PtrTo<Identifier> to);\n-        static PtrTo<AlterTableClause> createOrderBy(PtrTo<ColumnExpr> expr);\n-        static PtrTo<AlterTableClause> createReplace(PtrTo<PartitionClause> clause, PtrTo<TableIdentifier> from);\n-        static PtrTo<AlterTableClause> createTTL(PtrTo<TTLClause> clause);\n-        static PtrTo<AlterTableClause> createUpdate(PtrTo<AssignmentExprList> list, PtrTo<WhereClause> where);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            // ADD COLUMN, INDEX or PROJECTION\n-            ELEMENT = 0,  // TableElementExpr (COLUMN, CONSTRAINT, INDEX, PROJECTION)\n-            AFTER = 1,    // Identifier (optional)\n-\n-            // ATTACH/REPLACE\n-            PARTITION = 0,  // PartitionClause\n-            FROM = 1,       // TableIdentifier (optional)\n-\n-            // CLEAR COLUMN, INDEX or PROJECTION\n-            IN = 1,      // PartitionClause\n-\n-            // CODEC, COMMENT and RENAME\n-            COLUMN = 0, // Identifier\n-            CODEC = 1,  // CodecExpr\n-\n-            // COMMENT\n-            COMMENT = 1,  // StringLiteral\n-\n-            // DELETE\n-            EXPR = 0,  // ColumnExpr\n-\n-            // MOVE\n-            // TO = 1,  // TableIdentifier or StringLiteral\n-\n-            // RENAME\n-            TO = 1,      // Identifier\n-\n-            // TTL\n-            CLAUSE = 0,  // TTLClause\n-\n-            // UPDATE\n-            ASSIGNMENTS = 0,  // AssignmentExprList\n-            WHERE = 1,        // WhereClause\n-        };\n-\n-        enum class ClauseType\n-        {\n-            ADD_COLUMN,\n-            ADD_INDEX,\n-            ADD_PROJECTION,\n-            ATTACH,\n-            CLEAR_COLUMN,\n-            CLEAR_INDEX,\n-            CLEAR_PROJECTION,\n-            CODEC,\n-            COMMENT,\n-            DELETE,\n-            DETACH,\n-            DROP_COLUMN,\n-            DROP_INDEX,\n-            DROP_PROJECTION,\n-            DROP_PARTITION,\n-            FREEZE_PARTITION,\n-            MATERIALIZE_INDEX,\n-            MATERIALIZE_PROJECTION,\n-            MODIFY,\n-            MOVE_PARTITION_TO_DISK,\n-            MOVE_PARTITION_TO_TABLE,\n-            MOVE_PARTITION_TO_VOLUME,\n-            ORDER_BY,\n-            REMOVE,\n-            REMOVE_TTL,\n-            RENAME,\n-            REPLACE,\n-            TTL,\n-            UPDATE,\n-        };\n-\n-        const ClauseType clause_type;\n-        TableColumnPropertyType property_type = TableColumnPropertyType::ALIAS;  // default value to silence PVS-Studio\n-        union\n-        {\n-            bool if_exists;\n-            bool if_not_exists;\n-        };\n-\n-        AlterTableClause(ClauseType type, PtrList exprs);\n-};\n-\n-class AlterTableQuery : public DDLQuery\n-{\n-    public:\n-        AlterTableQuery(PtrTo<ClusterClause> cluster, PtrTo<TableIdentifier> identifier, PtrTo<List<AlterTableClause>> clauses);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            TABLE = 0,    // TableIdentifier\n-            CLAUSES = 1,  // List<AlterTableClause>\n-        };\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/AttachQuery.cpp b/src/Parsers/New/AST/AttachQuery.cpp\ndeleted file mode 100644\nindex 5fba573972bb..000000000000\n--- a/src/Parsers/New/AST/AttachQuery.cpp\n+++ /dev/null\n@@ -1,57 +0,0 @@\n-#include <Parsers/New/AST/AttachQuery.h>\n-\n-#include <Parsers/ASTCreateQuery.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-// static\n-PtrTo<AttachQuery> AttachQuery::createDictionary(PtrTo<ClusterClause> clause, PtrTo<TableIdentifier> identifier)\n-{\n-    return PtrTo<AttachQuery>(new AttachQuery(clause, QueryType::DICTIONARY, {identifier}));\n-}\n-\n-AttachQuery::AttachQuery(PtrTo<ClusterClause> clause, QueryType type, PtrList exprs) : DDLQuery(clause, exprs), query_type(type)\n-{\n-}\n-\n-ASTPtr AttachQuery::convertToOld() const\n-{\n-    auto query = std::make_shared<ASTCreateQuery>();\n-\n-    query->attach = true;\n-\n-    switch(query_type)\n-    {\n-        case QueryType::DICTIONARY:\n-            query->is_dictionary = true;\n-            {\n-                auto table = get(NAME)->convertToOld();\n-                query->database = table->as<ASTTableIdentifier>()->getDatabaseName();\n-                query->table = table->as<ASTTableIdentifier>()->shortName();\n-            }\n-            break;\n-    }\n-\n-    query->cluster = cluster_name;\n-\n-    return query;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitAttachDictionaryStmt(ClickHouseParser::AttachDictionaryStmtContext *ctx)\n-{\n-    auto cluster = ctx->clusterClause() ? visit(ctx->clusterClause()).as<PtrTo<ClusterClause>>() : nullptr;\n-    return AttachQuery::createDictionary(cluster, visit(ctx->tableIdentifier()));\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/AttachQuery.h b/src/Parsers/New/AST/AttachQuery.h\ndeleted file mode 100644\nindex f9b495b5b46f..000000000000\n--- a/src/Parsers/New/AST/AttachQuery.h\n+++ /dev/null\n@@ -1,32 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/DDLQuery.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class AttachQuery : public DDLQuery\n-{\n-    public:\n-        static PtrTo<AttachQuery> createDictionary(PtrTo<ClusterClause> clause, PtrTo<TableIdentifier> identifier);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            NAME = 0,  // TableIdentifier\n-        };\n-\n-        enum class QueryType\n-        {\n-            DICTIONARY,\n-        };\n-\n-        const QueryType query_type;\n-\n-        AttachQuery(PtrTo<ClusterClause> clause, QueryType type, PtrList exprs);\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/CheckQuery.cpp b/src/Parsers/New/AST/CheckQuery.cpp\ndeleted file mode 100644\nindex 87a7544ec34c..000000000000\n--- a/src/Parsers/New/AST/CheckQuery.cpp\n+++ /dev/null\n@@ -1,44 +0,0 @@\n-#include <Parsers/New/AST/CheckQuery.h>\n-\n-#include <Interpreters/StorageID.h>\n-#include <Parsers/ASTCheckQuery.h>\n-#include <Parsers/ASTIdentifier.h>\n-#include <Parsers/New/AST/AlterTableQuery.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-CheckQuery::CheckQuery(PtrTo<TableIdentifier> identifier, PtrTo<PartitionClause> clause) : Query{identifier, clause}\n-{\n-}\n-\n-ASTPtr CheckQuery::convertToOld() const\n-{\n-    auto query = std::make_shared<ASTCheckQuery>();\n-\n-    auto table = std::static_pointer_cast<ASTTableIdentifier>(get(NAME)->convertToOld());\n-    query->database = table->getDatabaseName();\n-    query->table = table->shortName();\n-\n-    if (has(PARTITION)) query->partition = get(PARTITION)->convertToOld();\n-\n-    return query;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitCheckStmt(ClickHouseParser::CheckStmtContext *ctx)\n-{\n-    auto partition = ctx->partitionClause() ? visit(ctx->partitionClause()).as<PtrTo<PartitionClause>>() : nullptr;\n-    return std::make_shared<CheckQuery>(visit(ctx->tableIdentifier()), partition);\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/CheckQuery.h b/src/Parsers/New/AST/CheckQuery.h\ndeleted file mode 100644\nindex d29d2c42acd2..000000000000\n--- a/src/Parsers/New/AST/CheckQuery.h\n+++ /dev/null\n@@ -1,24 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/Query.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class CheckQuery : public Query\n-{\n-    public:\n-        CheckQuery(PtrTo<TableIdentifier> identifier, PtrTo<PartitionClause> clause);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            NAME = 0,       // TableIdentifier\n-            PARTITION = 1,  // PartitionClause (optional)\n-        };\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/ColumnExpr.cpp b/src/Parsers/New/AST/ColumnExpr.cpp\ndeleted file mode 100644\nindex 0bfcee594cd8..000000000000\n--- a/src/Parsers/New/AST/ColumnExpr.cpp\n+++ /dev/null\n@@ -1,588 +0,0 @@\n-#include <Parsers/New/AST/ColumnExpr.h>\n-\n-#include <Parsers/ASTAsterisk.h>\n-#include <Parsers/ASTFunction.h>\n-#include <Parsers/ASTQualifiedAsterisk.h>\n-#include <Parsers/ASTSubquery.h>\n-#include <Parsers/New/AST/ColumnTypeExpr.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/AST/Literal.h>\n-#include <Parsers/New/AST/SelectUnionQuery.h>\n-#include <Parsers/New/ClickHouseLexer.h>\n-#include <Parsers/New/ClickHouseParser.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::ErrorCodes\n-{\n-    extern int SYNTAX_ERROR;\n-}\n-\n-namespace DB::AST\n-{\n-\n-// static\n-PtrTo<ColumnExpr> ColumnExpr::createAlias(PtrTo<ColumnExpr> expr, PtrTo<Identifier> alias)\n-{\n-    return PtrTo<ColumnExpr>(new ColumnExpr(ExprType::ALIAS, {expr, alias}));\n-}\n-\n-// static\n-PtrTo<ColumnExpr> ColumnExpr::createAsterisk(PtrTo<TableIdentifier> identifier, bool single_column)\n-{\n-    auto expr = PtrTo<ColumnExpr>(new ColumnExpr(ExprType::ASTERISK, {identifier}));\n-    expr->expect_single_column = single_column;\n-    return expr;\n-}\n-\n-// static\n-PtrTo<ColumnExpr> ColumnExpr::createFunction(PtrTo<Identifier> name, PtrTo<ColumnParamList> params, PtrTo<ColumnExprList> args)\n-{\n-    // FIXME: make sure that all function names are camel-case.\n-\n-    // Flatten some consequent binary operators to a single multi-operator, because they are left-associative.\n-    if ((name->getName() == \"or\" || name->getName() == \"and\") && args && args->size() == 2)\n-    {\n-        const auto * left = (*args->begin())->as<ColumnExpr>();\n-        const auto * right = (*++args->begin())->as<ColumnExpr>();\n-\n-        if (left && left->getType() == ExprType::FUNCTION && left->getFunctionName() == name->getName())\n-        {\n-            auto new_args = std::make_shared<ColumnExprList>();\n-            for (const auto & arg : left->get(ARGS)->as<ColumnExprList &>())\n-                new_args->push(std::static_pointer_cast<ColumnExpr>(arg));\n-            new_args->push(std::static_pointer_cast<ColumnExpr>(*++args->begin()));\n-            args = new_args;\n-        }\n-        else if (right && right->getType() == ExprType::FUNCTION && right->getFunctionName() == name->getName())\n-        {\n-            auto new_args = std::make_shared<ColumnExprList>();\n-            new_args->push(std::static_pointer_cast<ColumnExpr>(*args->begin()));\n-            for (const auto & arg : right->get(ARGS)->as<ColumnExprList &>())\n-                new_args->push(std::static_pointer_cast<ColumnExpr>(arg));\n-            args = new_args;\n-        }\n-    }\n-\n-    return PtrTo<ColumnExpr>(new ColumnExpr(ExprType::FUNCTION, {name, params, args}));\n-}\n-\n-// static\n-PtrTo<ColumnExpr> ColumnExpr::createIdentifier(PtrTo<ColumnIdentifier> identifier)\n-{\n-    return PtrTo<ColumnExpr>(new ColumnExpr(ExprType::IDENTIFIER, {identifier}));\n-}\n-\n-// static\n-PtrTo<ColumnExpr> ColumnExpr::createLambda(PtrTo<List<Identifier>> params, PtrTo<ColumnExpr> expr)\n-{\n-    return PtrTo<ColumnExpr>(new ColumnExpr(ExprType::LAMBDA, {params, expr}));\n-}\n-\n-// static\n-PtrTo<ColumnExpr> ColumnExpr::createLiteral(PtrTo<Literal> literal)\n-{\n-    return PtrTo<ColumnExpr>(new ColumnExpr(ExprType::LITERAL, {literal}));\n-}\n-\n-// static\n-PtrTo<ColumnExpr> ColumnExpr::createSubquery(PtrTo<SelectUnionQuery> query, bool scalar)\n-{\n-    if (scalar) query->shouldBeScalar();\n-    return PtrTo<ColumnExpr>(new ColumnExpr(ExprType::SUBQUERY, {query}));\n-}\n-\n-ColumnExpr::ColumnExpr(ColumnExpr::ExprType type, PtrList exprs) : INode(exprs), expr_type(type)\n-{\n-}\n-\n-ASTPtr ColumnExpr::convertToOld() const\n-{\n-    switch (expr_type)\n-    {\n-        case ExprType::ALIAS:\n-        {\n-            ASTPtr expr = get(EXPR)->convertToOld();\n-\n-            if (auto * expr_with_alias = dynamic_cast<ASTWithAlias*>(expr.get()))\n-                expr_with_alias->setAlias(get<Identifier>(ALIAS)->getName());\n-            else\n-                throw std::runtime_error(\"Trying to convert new expression with alias to old one without alias support: \" + expr->getID());\n-\n-            return expr;\n-        }\n-        case ExprType::ASTERISK:\n-            if (has(TABLE))\n-            {\n-                auto expr = std::make_shared<ASTQualifiedAsterisk>();\n-                expr->children.push_back(get(TABLE)->convertToOld());\n-                return expr;\n-            }\n-            return std::make_shared<ASTAsterisk>();\n-        case ExprType::FUNCTION:\n-        {\n-            auto func = std::make_shared<ASTFunction>();\n-\n-            func->name = get<Identifier>(NAME)->getName();\n-            if (has(ARGS))\n-            {\n-                func->arguments = get(ARGS)->convertToOld();\n-                func->children.push_back(func->arguments);\n-            }\n-            if (has(PARAMS))\n-            {\n-                func->parameters = get(PARAMS)->convertToOld();\n-                func->children.push_back(func->parameters);\n-            }\n-\n-            return func;\n-        }\n-        case ExprType::IDENTIFIER:\n-            return get(IDENTIFIER)->convertToOld();\n-        case ExprType::LAMBDA:\n-        {\n-            auto func = std::make_shared<ASTFunction>();\n-            auto tuple = std::make_shared<ASTFunction>();\n-\n-            func->name = \"lambda\";\n-            func->arguments = std::make_shared<ASTExpressionList>();\n-            func->arguments->children.push_back(tuple);\n-            func->arguments->children.push_back(get(LAMBDA_EXPR)->convertToOld());\n-            func->children.push_back(func->arguments);\n-\n-            tuple->name = \"tuple\";\n-            tuple->arguments = get(LAMBDA_ARGS)->convertToOld();\n-            tuple->children.push_back(tuple->arguments);\n-\n-            return func;\n-        }\n-        case ExprType::LITERAL:\n-            return get(LITERAL)->convertToOld();\n-        case ExprType::SUBQUERY:\n-        {\n-            auto subquery = std::make_shared<ASTSubquery>();\n-            subquery->children.push_back(get(SUBQUERY)->convertToOld());\n-            return subquery;\n-        }\n-    }\n-    __builtin_unreachable();\n-}\n-\n-String ColumnExpr::toString() const\n-{\n-    switch(expr_type)\n-    {\n-        case ExprType::LITERAL: return get(LITERAL)->toString();\n-        default: return {};\n-    }\n-    __builtin_unreachable();\n-}\n-\n-String ColumnExpr::dumpInfo() const\n-{\n-    switch(expr_type)\n-    {\n-        case ExprType::ALIAS: return \"ALIAS\";\n-        case ExprType::ASTERISK: return \"ASTERISK\";\n-        case ExprType::FUNCTION: return \"FUNCTION\";\n-        case ExprType::IDENTIFIER: return \"IDENTIFIER\";\n-        case ExprType::LAMBDA: return \"LAMBDA\";\n-        case ExprType::LITERAL: return \"LITERAL\";\n-        case ExprType::SUBQUERY: return \"SUBQUERY\";\n-    }\n-    __builtin_unreachable();\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnArgExpr(ClickHouseParser::ColumnArgExprContext *ctx)\n-{\n-    if (ctx->columnExpr()) return visit(ctx->columnExpr());\n-    if (ctx->columnLambdaExpr()) return visit(ctx->columnLambdaExpr());\n-    __builtin_unreachable();\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnArgList(ClickHouseParser::ColumnArgListContext *ctx)\n-{\n-    auto list = std::make_shared<ColumnExprList>();\n-    for (auto * arg : ctx->columnArgExpr()) list->push(visit(arg));\n-    return list;\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprAlias(ClickHouseParser::ColumnExprAliasContext *ctx)\n-{\n-    if (ctx->AS()) return ColumnExpr::createAlias(visit(ctx->columnExpr()), visit(ctx->identifier()));\n-    else return ColumnExpr::createAlias(visit(ctx->columnExpr()), visit(ctx->alias()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprAnd(ClickHouseParser::ColumnExprAndContext *ctx)\n-{\n-    auto name = std::make_shared<Identifier>(\"and\");\n-    auto args = std::make_shared<ColumnExprList>();\n-\n-    for (auto * expr : ctx->columnExpr()) args->push(visit(expr));\n-\n-    return ColumnExpr::createFunction(name, nullptr, args);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprArray(ClickHouseParser::ColumnExprArrayContext *ctx)\n-{\n-    auto name = std::make_shared<Identifier>(\"array\");\n-    auto args = ctx->columnExprList() ? visit(ctx->columnExprList()).as<PtrTo<ColumnExprList>>() : nullptr;\n-    return ColumnExpr::createFunction(name, nullptr, args);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprArrayAccess(ClickHouseParser::ColumnExprArrayAccessContext *ctx)\n-{\n-    auto name = std::make_shared<Identifier>(\"arrayElement\");\n-    auto args = std::make_shared<ColumnExprList>();\n-\n-    for (auto * expr : ctx->columnExpr()) args->push(visit(expr));\n-\n-    return ColumnExpr::createFunction(name, nullptr, args);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprAsterisk(ClickHouseParser::ColumnExprAsteriskContext *ctx)\n-{\n-    auto table = ctx->tableIdentifier() ? visit(ctx->tableIdentifier()).as<PtrTo<TableIdentifier>>() : nullptr;\n-    return ColumnExpr::createAsterisk(table, true);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprBetween(ClickHouseParser::ColumnExprBetweenContext *ctx)\n-{\n-    PtrTo<ColumnExpr> expr1, expr2;\n-\n-    {\n-        auto name = std::make_shared<Identifier>(ctx->NOT() ? \"lessOrEquals\" : \"greaterOrEquals\");\n-        auto args = std::make_shared<ColumnExprList>();\n-        args->push(visit(ctx->columnExpr(0)));\n-        args->push(visit(ctx->columnExpr(1)));\n-        expr1 = ColumnExpr::createFunction(name, nullptr, args);\n-    }\n-\n-    {\n-        auto name = std::make_shared<Identifier>(ctx->NOT() ? \"greaterOrEquals\" : \"lessOrEquals\");\n-        auto args = std::make_shared<ColumnExprList>();\n-        args->push(visit(ctx->columnExpr(0)));\n-        args->push(visit(ctx->columnExpr(2)));\n-        expr2 = ColumnExpr::createFunction(name, nullptr, args);\n-    }\n-\n-    auto name = std::make_shared<Identifier>(\"and\");\n-    auto args = std::make_shared<ColumnExprList>();\n-\n-    args->push(expr1);\n-    args->push(expr2);\n-\n-    return ColumnExpr::createFunction(name, nullptr, args);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprCase(ClickHouseParser::ColumnExprCaseContext *ctx)\n-{\n-    auto has_case_expr = (ctx->ELSE() && ctx->columnExpr().size() % 2 == 0) || (!ctx->ELSE() && ctx->columnExpr().size() % 2 == 1);\n-    auto name = std::make_shared<Identifier>(has_case_expr ? \"caseWithExpression\" : \"multiIf\");\n-    auto args = std::make_shared<ColumnExprList>();\n-\n-    for (auto * expr : ctx->columnExpr()) args->push(visit(expr));\n-    if (!ctx->ELSE()) args->push(ColumnExpr::createLiteral(Literal::createNull()));\n-\n-    return ColumnExpr::createFunction(name, nullptr, args);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprCast(ClickHouseParser::ColumnExprCastContext *ctx)\n-{\n-    auto args = std::make_shared<ColumnExprList>();\n-\n-    args->push(visit(ctx->columnExpr()));\n-    args->push(ColumnExpr::createLiteral(Literal::createString(visit(ctx->columnTypeExpr()).as<PtrTo<ColumnTypeExpr>>()->toString())));\n-\n-    return ColumnExpr::createFunction(std::make_shared<Identifier>(\"cast\"), nullptr, args);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprDate(ClickHouseParser::ColumnExprDateContext *ctx)\n-{\n-    auto name = std::make_shared<Identifier>(\"toDate\");\n-    auto args = std::make_shared<ColumnExprList>();\n-\n-    args->push(ColumnExpr::createLiteral(Literal::createString(ctx->STRING_LITERAL())));\n-\n-    return ColumnExpr::createFunction(name, nullptr, args);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprExtract(ClickHouseParser::ColumnExprExtractContext *ctx)\n-{\n-    String name;\n-    auto args = std::make_shared<ColumnExprList>();\n-\n-    if (ctx->interval()->SECOND()) name = \"toSecond\";\n-    else if (ctx->interval()->MINUTE()) name = \"toMinute\";\n-    else if (ctx->interval()->HOUR()) name = \"toHour\";\n-    else if (ctx->interval()->DAY()) name = \"toDayOfMonth\";\n-    else if (ctx->interval()->WEEK())\n-        throw Exception(\n-            \"The syntax 'EXTRACT(WEEK FROM date)' is not supported, cannot extract the number of a week\", ErrorCodes::SYNTAX_ERROR);\n-    else if (ctx->interval()->MONTH()) name = \"toMonth\";\n-    else if (ctx->interval()->QUARTER()) name = \"toQuarter\";\n-    else if (ctx->interval()->YEAR()) name = \"toYear\";\n-    else __builtin_unreachable();\n-\n-    args->push(visit(ctx->columnExpr()));\n-\n-    return ColumnExpr::createFunction(std::make_shared<Identifier>(name), nullptr, args);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprFunction(ClickHouseParser::ColumnExprFunctionContext *ctx)\n-{\n-    auto name = visit(ctx->identifier()).as<PtrTo<Identifier>>();\n-    auto params = ctx->columnExprList() ? visit(ctx->columnExprList()).as<PtrTo<ColumnExprList>>() : nullptr;\n-    auto args = ctx->columnArgList() ? visit(ctx->columnArgList()).as<PtrTo<ColumnExprList>>() : nullptr;\n-\n-    if (ctx->DISTINCT()) name = std::make_shared<Identifier>(name->getName() + \"Distinct\");\n-\n-    return ColumnExpr::createFunction(name, params, args);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprIdentifier(ClickHouseParser::ColumnExprIdentifierContext *ctx)\n-{\n-    return ColumnExpr::createIdentifier(visit(ctx->columnIdentifier()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprInterval(ClickHouseParser::ColumnExprIntervalContext *ctx)\n-{\n-    PtrTo<Identifier> name;\n-    auto args = std::make_shared<ColumnExprList>();\n-\n-    if (ctx->interval()->SECOND()) name = std::make_shared<Identifier>(\"toIntervalSecond\");\n-    else if (ctx->interval()->MINUTE()) name = std::make_shared<Identifier>(\"toIntervalMinute\");\n-    else if (ctx->interval()->HOUR()) name = std::make_shared<Identifier>(\"toIntervalHour\");\n-    else if (ctx->interval()->DAY()) name = std::make_shared<Identifier>(\"toIntervalDay\");\n-    else if (ctx->interval()->WEEK()) name = std::make_shared<Identifier>(\"toIntervalWeek\");\n-    else if (ctx->interval()->MONTH()) name = std::make_shared<Identifier>(\"toIntervalMonth\");\n-    else if (ctx->interval()->QUARTER()) name = std::make_shared<Identifier>(\"toIntervalQuarter\");\n-    else if (ctx->interval()->YEAR()) name = std::make_shared<Identifier>(\"toIntervalYear\");\n-    else __builtin_unreachable();\n-\n-    args->push(visit(ctx->columnExpr()));\n-\n-    return ColumnExpr::createFunction(name, nullptr, args);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprIsNull(ClickHouseParser::ColumnExprIsNullContext *ctx)\n-{\n-    auto name = std::make_shared<Identifier>(ctx->NOT() ? \"isNotNull\" : \"isNull\");\n-    auto args = std::make_shared<ColumnExprList>();\n-\n-    args->push(visit(ctx->columnExpr()));\n-\n-    return ColumnExpr::createFunction(name, nullptr, args);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprList(ClickHouseParser::ColumnExprListContext *ctx)\n-{\n-    auto list = std::make_shared<ColumnExprList>();\n-    for (auto * expr : ctx->columnsExpr()) list->push(visit(expr));\n-    return list;\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprLiteral(ClickHouseParser::ColumnExprLiteralContext *ctx)\n-{\n-    return ColumnExpr::createLiteral(visit(ctx->literal()).as<PtrTo<Literal>>());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprNegate(ClickHouseParser::ColumnExprNegateContext *ctx)\n-{\n-    auto name = std::make_shared<Identifier>(\"negate\");\n-    auto args = std::make_shared<ColumnExprList>();\n-\n-    args->push(visit(ctx->columnExpr()));\n-\n-    return ColumnExpr::createFunction(name, nullptr, args);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprNot(ClickHouseParser::ColumnExprNotContext *ctx)\n-{\n-    auto name = std::make_shared<Identifier>(\"not\");\n-    auto args = std::make_shared<ColumnExprList>();\n-\n-    args->push(visit(ctx->columnExpr()));\n-\n-    return ColumnExpr::createFunction(name, nullptr, args);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprOr(ClickHouseParser::ColumnExprOrContext *ctx)\n-{\n-    auto name = std::make_shared<Identifier>(\"or\");\n-\n-    auto args = std::make_shared<ColumnExprList>();\n-    for (auto * expr : ctx->columnExpr()) args->push(visit(expr));\n-\n-    return ColumnExpr::createFunction(name, nullptr, args);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprParens(ClickHouseParser::ColumnExprParensContext *ctx)\n-{\n-    return visit(ctx->columnExpr());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprPrecedence1(ClickHouseParser::ColumnExprPrecedence1Context *ctx)\n-{\n-    PtrTo<Identifier> name;\n-    if (ctx->ASTERISK()) name = std::make_shared<Identifier>(\"multiply\");\n-    else if (ctx->SLASH()) name = std::make_shared<Identifier>(\"divide\");\n-    else if (ctx->PERCENT()) name = std::make_shared<Identifier>(\"modulo\");\n-\n-    auto args = std::make_shared<ColumnExprList>();\n-    for (auto * expr : ctx->columnExpr()) args->push(visit(expr));\n-\n-    return ColumnExpr::createFunction(name, nullptr, args);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprPrecedence2(ClickHouseParser::ColumnExprPrecedence2Context *ctx)\n-{\n-    PtrTo<Identifier> name;\n-    if (ctx->PLUS()) name = std::make_shared<Identifier>(\"plus\");\n-    else if (ctx->DASH()) name = std::make_shared<Identifier>(\"minus\");\n-    else if (ctx->CONCAT()) name = std::make_shared<Identifier>(\"concat\");\n-\n-    auto args = std::make_shared<ColumnExprList>();\n-    for (auto * expr : ctx->columnExpr()) args->push(visit(expr));\n-\n-    return ColumnExpr::createFunction(name, nullptr, args);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprPrecedence3(ClickHouseParser::ColumnExprPrecedence3Context *ctx)\n-{\n-    PtrTo<Identifier> name;\n-    if (ctx->EQ_DOUBLE() || ctx->EQ_SINGLE()) name = std::make_shared<Identifier>(\"equals\");\n-    else if (ctx->NOT_EQ()) name = std::make_shared<Identifier>(\"notEquals\");\n-    else if (ctx->LE()) name = std::make_shared<Identifier>(\"lessOrEquals\");\n-    else if (ctx->GE()) name = std::make_shared<Identifier>(\"greaterOrEquals\");\n-    else if (ctx->LT()) name = std::make_shared<Identifier>(\"less\");\n-    else if (ctx->GT()) name = std::make_shared<Identifier>(\"greater\");\n-    else if (ctx->LIKE())\n-    {\n-        if (ctx->NOT()) name = std::make_shared<Identifier>(\"notLike\");\n-        else name = std::make_shared<Identifier>(\"like\");\n-    }\n-    else if (ctx->ILIKE())\n-    {\n-        if (ctx->NOT()) name = std::make_shared<Identifier>(\"notILike\");\n-        else name = std::make_shared<Identifier>(\"ilike\");\n-    }\n-    else if (ctx->IN())\n-    {\n-        if (ctx->GLOBAL())\n-        {\n-            if (ctx->NOT()) name = std::make_shared<Identifier>(\"globalNotIn\");\n-            else name = std::make_shared<Identifier>(\"globalIn\");\n-        }\n-        else\n-        {\n-            if (ctx->NOT()) name = std::make_shared<Identifier>(\"notIn\");\n-            else name = std::make_shared<Identifier>(\"in\");\n-        }\n-    }\n-\n-    auto args = std::make_shared<ColumnExprList>();\n-    for (auto * expr : ctx->columnExpr()) args->push(visit(expr));\n-\n-    return ColumnExpr::createFunction(name, nullptr, args);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprSubquery(ClickHouseParser::ColumnExprSubqueryContext *ctx)\n-{\n-    // IN-operator is special since it accepts non-scalar subqueries on the right side.\n-    auto * parent = dynamic_cast<ClickHouseParser::ColumnExprPrecedence3Context*>(ctx->parent);\n-    return ColumnExpr::createSubquery(visit(ctx->selectUnionStmt()), !(parent && parent->IN()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprSubstring(ClickHouseParser::ColumnExprSubstringContext *ctx)\n-{\n-    auto name = std::make_shared<Identifier>(\"substring\");\n-    auto args = std::make_shared<ColumnExprList>();\n-\n-    for (auto * expr : ctx->columnExpr()) args->push(visit(expr));\n-\n-    return ColumnExpr::createFunction(name, nullptr, args);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprTernaryOp(ClickHouseParser::ColumnExprTernaryOpContext *ctx)\n-{\n-    auto name = std::make_shared<Identifier>(\"if\");\n-    auto args = std::make_shared<ColumnExprList>();\n-\n-    for (auto * expr : ctx->columnExpr()) args->push(visit(expr));\n-\n-    return ColumnExpr::createFunction(name, nullptr, args);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprTimestamp(ClickHouseParser::ColumnExprTimestampContext *ctx)\n-{\n-    auto name = std::make_shared<Identifier>(\"toDateTime\");\n-    auto args = std::make_shared<ColumnExprList>();\n-\n-    args->push(ColumnExpr::createLiteral(Literal::createString(ctx->STRING_LITERAL())));\n-\n-    return ColumnExpr::createFunction(name, nullptr, args);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprTrim(ClickHouseParser::ColumnExprTrimContext *ctx)\n-{\n-    auto name = std::make_shared<Identifier>(\"trim\");\n-    auto args = std::make_shared<ColumnExprList>();\n-    auto params = std::make_shared<ColumnParamList>();\n-\n-    args->push(visit(ctx->columnExpr()));\n-    // TODO: params->append(Literal::createString(???));\n-    params->push(ColumnExpr::createLiteral(Literal::createString(ctx->STRING_LITERAL())));\n-\n-    return ColumnExpr::createFunction(name, params, args);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprTuple(ClickHouseParser::ColumnExprTupleContext *ctx)\n-{\n-    auto name = std::make_shared<Identifier>(\"tuple\");\n-    auto args = visit(ctx->columnExprList()).as<PtrTo<ColumnExprList>>();\n-    return ColumnExpr::createFunction(name, nullptr, args);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnExprTupleAccess(ClickHouseParser::ColumnExprTupleAccessContext *ctx)\n-{\n-    auto name = std::make_shared<Identifier>(\"tupleElement\");\n-    auto args = std::make_shared<ColumnExprList>();\n-\n-    args->push(visit(ctx->columnExpr()));\n-    args->push(ColumnExpr::createLiteral(Literal::createNumber(ctx->DECIMAL_LITERAL())));\n-\n-    return ColumnExpr::createFunction(name, nullptr, args);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnLambdaExpr(ClickHouseParser::ColumnLambdaExprContext *ctx)\n-{\n-    auto params = std::make_shared<List<Identifier>>();\n-    for (auto * id : ctx->identifier()) params->push(visit(id));\n-    return ColumnExpr::createLambda(params, visit(ctx->columnExpr()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnsExprAsterisk(ClickHouseParser::ColumnsExprAsteriskContext *ctx)\n-{\n-    auto table = ctx->tableIdentifier() ? visit(ctx->tableIdentifier()).as<PtrTo<TableIdentifier>>() : nullptr;\n-    return ColumnExpr::createAsterisk(table, false);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnsExprSubquery(ClickHouseParser::ColumnsExprSubqueryContext *ctx)\n-{\n-    return ColumnExpr::createSubquery(visit(ctx->selectUnionStmt()), false);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnsExprColumn(ClickHouseParser::ColumnsExprColumnContext *ctx)\n-{\n-    return visit(ctx->columnExpr());\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/ColumnExpr.h b/src/Parsers/New/AST/ColumnExpr.h\ndeleted file mode 100644\nindex 6de707d6b2d7..000000000000\n--- a/src/Parsers/New/AST/ColumnExpr.h\n+++ /dev/null\n@@ -1,82 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/AST/Literal.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class ColumnExpr : public INode\n-{\n-    public:\n-        static PtrTo<ColumnExpr> createAlias(PtrTo<ColumnExpr> expr, PtrTo<Identifier> alias);\n-        static PtrTo<ColumnExpr> createAsterisk(PtrTo<TableIdentifier> identifier, bool single_column);\n-        static PtrTo<ColumnExpr> createFunction(PtrTo<Identifier> name, PtrTo<ColumnParamList> params, PtrTo<ColumnExprList> args);\n-        static PtrTo<ColumnExpr> createIdentifier(PtrTo<ColumnIdentifier> identifier);\n-        static PtrTo<ColumnExpr> createLambda(PtrTo<List<Identifier>> params, PtrTo<ColumnExpr> expr);\n-        static PtrTo<ColumnExpr> createLiteral(PtrTo<Literal> literal);\n-        static PtrTo<ColumnExpr> createSubquery(PtrTo<SelectUnionQuery> query, bool scalar);\n-\n-        enum class ExprType\n-        {\n-            ALIAS,\n-            ASTERISK,\n-            FUNCTION,\n-            IDENTIFIER,\n-            LAMBDA,\n-            LITERAL,\n-            SUBQUERY,\n-        };\n-\n-        auto getType() const { return expr_type; };\n-\n-        // FUNCTION\n-        auto getFunctionName() const { return get<Identifier>(NAME)->getName(); }\n-        auto argumentsBegin() const { return has(ARGS) ? get<ColumnExprList>(ARGS)->begin() : end(); }\n-        auto argumentsEnd() const { return has(ARGS) ? get<ColumnExprList>(ARGS)->end() : end(); }\n-\n-        // LITERAL\n-        auto getLiteral() const { return std::static_pointer_cast<Literal>(get(LITERAL)); }\n-\n-        ASTPtr convertToOld() const override;\n-        String toString() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            // ALIAS\n-            EXPR = 0,   // ColumnExpr\n-            ALIAS = 1,  // Identifier\n-\n-            // ASTERISK\n-            TABLE = 0,  // TableIdentifier (optional)\n-\n-            // IDENTIFIER\n-            IDENTIFIER = 0,  // ColumnIdentifier\n-\n-            // FUNCTION\n-            NAME = 0,    // Identifier\n-            PARAMS = 1,  // ColumnParamList (optional)\n-            ARGS = 2,    // ColumnExprList (optional)\n-\n-            // LAMBDA\n-            LAMBDA_ARGS = 0,\n-            LAMBDA_EXPR = 1,\n-\n-            // LITERAL\n-            LITERAL = 0,\n-\n-            // SUBQUERY\n-            SUBQUERY = 0,\n-        };\n-\n-        const ExprType expr_type;\n-        bool expect_single_column = false;\n-\n-        ColumnExpr(ExprType type, PtrList exprs);\n-\n-        String dumpInfo() const override;\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/ColumnTypeExpr.cpp b/src/Parsers/New/AST/ColumnTypeExpr.cpp\ndeleted file mode 100644\nindex a2947cf0f63b..000000000000\n--- a/src/Parsers/New/AST/ColumnTypeExpr.cpp\n+++ /dev/null\n@@ -1,166 +0,0 @@\n-#include <Parsers/New/AST/ColumnTypeExpr.h>\n-\n-#include <Parsers/ASTFunction.h>\n-#include <Parsers/ASTNameTypePair.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/AST/Literal.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-EnumValue::EnumValue(PtrTo<StringLiteral> name, PtrTo<NumberLiteral> value) : INode{name, value}\n-{\n-}\n-\n-ASTPtr EnumValue::convertToOld() const\n-{\n-    auto func = std::make_shared<ASTFunction>();\n-\n-    func->name = \"equals\";\n-    func->arguments = std::make_shared<ASTExpressionList>();\n-    func->arguments->children.push_back(get(NAME)->convertToOld());\n-    func->arguments->children.push_back(get(VALUE)->convertToOld());\n-    func->children.push_back(func->arguments);\n-\n-    return func;\n-}\n-\n-String EnumValue::toString() const\n-{\n-    return fmt::format(\"{} = {}\", get(NAME)->toString(), get(VALUE)->toString());\n-}\n-\n-// static\n-PtrTo<ColumnTypeExpr> ColumnTypeExpr::createSimple(PtrTo<Identifier> identifier)\n-{\n-    return PtrTo<ColumnTypeExpr>(new ColumnTypeExpr(ExprType::SIMPLE, {identifier}));\n-}\n-\n-// static\n-PtrTo<ColumnTypeExpr> ColumnTypeExpr::createNamed(PtrTo<Identifier> identifier, PtrTo<ColumnTypeExpr> type)\n-{\n-    return PtrTo<ColumnTypeExpr>(new ColumnTypeExpr(ExprType::NAMED, {identifier, type}));\n-}\n-\n-// static\n-PtrTo<ColumnTypeExpr> ColumnTypeExpr::createComplex(PtrTo<Identifier> identifier, PtrTo<ColumnTypeExprList> list)\n-{\n-    return PtrTo<ColumnTypeExpr>(new ColumnTypeExpr(ExprType::COMPLEX, {identifier, list}));\n-}\n-\n-// static\n-PtrTo<ColumnTypeExpr> ColumnTypeExpr::createEnum(PtrTo<Identifier> identifier, PtrTo<EnumValueList> list)\n-{\n-    return PtrTo<ColumnTypeExpr>(new ColumnTypeExpr(ExprType::ENUM, {identifier, list}));\n-}\n-\n-// static\n-PtrTo<ColumnTypeExpr> ColumnTypeExpr::createParam(PtrTo<Identifier> identifier, PtrTo<ColumnParamList> list)\n-{\n-    return PtrTo<ColumnTypeExpr>(new ColumnTypeExpr(ExprType::PARAM, {identifier, list}));\n-}\n-\n-// static\n-PtrTo<ColumnTypeExpr> ColumnTypeExpr::createNested(PtrTo<Identifier> identifier, PtrTo<ColumnTypeExprList> list)\n-{\n-    // TODO: assert that |list| must contain only expressions of NAMED type\n-    return PtrTo<ColumnTypeExpr>(new ColumnTypeExpr(ExprType::NESTED, {identifier, list}));\n-}\n-\n-ColumnTypeExpr::ColumnTypeExpr(ExprType type, PtrList exprs) : INode(exprs), expr_type(type)\n-{\n-}\n-\n-ASTPtr ColumnTypeExpr::convertToOld() const\n-{\n-    if (expr_type == ExprType::NAMED)\n-    {\n-        auto pair = std::make_shared<ASTNameTypePair>();\n-\n-        pair->name = get<Identifier>(NAME)->getName();\n-        pair->type = get(TYPE)->convertToOld();\n-        pair->children.push_back(pair->type);\n-\n-        return pair;\n-    }\n-\n-    auto func = std::make_shared<ASTFunction>();\n-\n-    func->name = get<Identifier>(NAME)->getName();\n-    func->no_empty_args = true;\n-    if (expr_type != ExprType::SIMPLE && has(LIST))\n-    {\n-        func->arguments = get(LIST)->convertToOld();\n-        func->children.push_back(func->arguments);\n-    }\n-\n-    return func;\n-}\n-\n-String ColumnTypeExpr::toString() const\n-{\n-    switch(expr_type)\n-    {\n-        case ExprType::SIMPLE:\n-            return get(NAME)->toString();\n-        case ExprType::NAMED:\n-            return get(NAME)->toString() + \" \" + get(TYPE)->toString();\n-        case ExprType::COMPLEX:\n-        case ExprType::ENUM:\n-        case ExprType::PARAM:\n-        case ExprType::NESTED:\n-            return get(NAME)->toString() + \"(\" + (has(LIST) ? get(LIST)->toString() : \"\") + \")\";\n-    }\n-    __builtin_unreachable();\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnTypeExprSimple(ClickHouseParser::ColumnTypeExprSimpleContext *ctx)\n-{\n-    return ColumnTypeExpr::createSimple(visit(ctx->identifier()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnTypeExprParam(ClickHouseParser::ColumnTypeExprParamContext *ctx)\n-{\n-    auto list = ctx->columnExprList() ? visit(ctx->columnExprList()).as<PtrTo<ColumnExprList>>() : nullptr;\n-    return ColumnTypeExpr::createParam(visit(ctx->identifier()), list);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnTypeExprEnum(ClickHouseParser::ColumnTypeExprEnumContext *ctx)\n-{\n-    auto list = std::make_shared<EnumValueList>();\n-    for (auto * value : ctx->enumValue()) list->push(visit(value));\n-    return ColumnTypeExpr::createEnum(visit(ctx->identifier()), list);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnTypeExprComplex(ClickHouseParser::ColumnTypeExprComplexContext *ctx)\n-{\n-    auto list = std::make_shared<ColumnTypeExprList>();\n-    for (auto * expr : ctx->columnTypeExpr()) list->push(visit(expr));\n-    return ColumnTypeExpr::createComplex(visit(ctx->identifier()), list);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnTypeExprNested(ClickHouseParser::ColumnTypeExprNestedContext *ctx)\n-{\n-    auto list = std::make_shared<ColumnTypeExprList>();\n-\n-    for (size_t i = 0; i < ctx->columnTypeExpr().size(); ++i)\n-        list->push(ColumnTypeExpr::createNamed(visit(ctx->identifier(i + 1)), visit(ctx->columnTypeExpr(i))));\n-\n-    return ColumnTypeExpr::createNested(visit(ctx->identifier(0)), list);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitEnumValue(ClickHouseParser::EnumValueContext *ctx)\n-{\n-    return std::make_shared<EnumValue>(Literal::createString(ctx->STRING_LITERAL()), visit(ctx->numberLiteral()));\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/ColumnTypeExpr.h b/src/Parsers/New/AST/ColumnTypeExpr.h\ndeleted file mode 100644\nindex 8c4f3c697e7e..000000000000\n--- a/src/Parsers/New/AST/ColumnTypeExpr.h\n+++ /dev/null\n@@ -1,62 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/INode.h>\n-\n-#include <list>\n-\n-\n-namespace DB::AST\n-{\n-\n-class EnumValue : public INode\n-{\n-    public:\n-        EnumValue(PtrTo<StringLiteral> name, PtrTo<NumberLiteral> value);\n-\n-        ASTPtr convertToOld() const override;\n-        String toString() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            NAME = 0,   // StringLiteral\n-            VALUE = 1,  // NumberLiteral\n-        };\n-};\n-\n-class ColumnTypeExpr : public INode\n-{\n-    public:\n-        static PtrTo<ColumnTypeExpr> createSimple(PtrTo<Identifier> identifier);\n-        static PtrTo<ColumnTypeExpr> createNamed(PtrTo<Identifier> identifier, PtrTo<ColumnTypeExpr> type);\n-        static PtrTo<ColumnTypeExpr> createComplex(PtrTo<Identifier> identifier, PtrTo<ColumnTypeExprList> list);\n-        static PtrTo<ColumnTypeExpr> createEnum(PtrTo<Identifier> identifier, PtrTo<EnumValueList> list);\n-        static PtrTo<ColumnTypeExpr> createParam(PtrTo<Identifier> identifier, PtrTo<ColumnParamList> list);\n-        static PtrTo<ColumnTypeExpr> createNested(PtrTo<Identifier> identifier, PtrTo<ColumnTypeExprList> list);\n-\n-        ASTPtr convertToOld() const override;\n-        String toString() const override;\n-\n-    private:\n-        enum class ExprType\n-        {\n-            SIMPLE,\n-            NAMED,\n-            COMPLEX,\n-            ENUM,\n-            PARAM,\n-            NESTED,\n-        };\n-        enum ChildIndex : UInt8\n-        {\n-            NAME = 0,  // Identifier\n-            TYPE = 1,  // ColumnTypeExpr\n-            LIST = 1,  // depends on |expr_type|\n-        };\n-\n-        ExprType expr_type;\n-\n-        ColumnTypeExpr(ExprType type, PtrList exprs);\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/CreateDatabaseQuery.cpp b/src/Parsers/New/AST/CreateDatabaseQuery.cpp\ndeleted file mode 100644\nindex 9f6c79d592f4..000000000000\n--- a/src/Parsers/New/AST/CreateDatabaseQuery.cpp\n+++ /dev/null\n@@ -1,51 +0,0 @@\n-#include <Parsers/New/AST/CreateDatabaseQuery.h>\n-\n-#include <Parsers/ASTCreateQuery.h>\n-#include <Parsers/ASTFunction.h>\n-#include <Parsers/New/AST/EngineExpr.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-CreateDatabaseQuery::CreateDatabaseQuery(\n-    PtrTo<ClusterClause> cluster, bool if_not_exists_, PtrTo<DatabaseIdentifier> identifier, PtrTo<EngineExpr> expr)\n-    : DDLQuery(cluster, {identifier, expr}), if_not_exists(if_not_exists_)\n-{\n-}\n-\n-ASTPtr CreateDatabaseQuery::convertToOld() const\n-{\n-    auto query = std::make_shared<ASTCreateQuery>();\n-\n-    query->if_not_exists = if_not_exists;\n-    query->database = get<DatabaseIdentifier>(NAME)->getName();\n-    query->cluster = cluster_name;\n-    if (has(ENGINE))\n-    {\n-        auto engine = std::make_shared<ASTStorage>();\n-        engine->set(engine->engine, get(ENGINE)->convertToOld());\n-        query->set(query->storage, engine);\n-    }\n-    // TODO: query->uuid\n-\n-    return query;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitCreateDatabaseStmt(ClickHouseParser::CreateDatabaseStmtContext *ctx)\n-{\n-    auto engine = ctx->engineExpr() ? visit(ctx->engineExpr()).as<PtrTo<EngineExpr>>() : nullptr;\n-    auto cluster = ctx->clusterClause() ? visit(ctx->clusterClause()).as<PtrTo<ClusterClause>>() : nullptr;\n-    return std::make_shared<CreateDatabaseQuery>(cluster, !!ctx->IF(), visit(ctx->databaseIdentifier()), engine);\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/CreateDatabaseQuery.h b/src/Parsers/New/AST/CreateDatabaseQuery.h\ndeleted file mode 100644\nindex 3de16c3dc831..000000000000\n--- a/src/Parsers/New/AST/CreateDatabaseQuery.h\n+++ /dev/null\n@@ -1,26 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/DDLQuery.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class CreateDatabaseQuery: public DDLQuery\n-{\n-    public:\n-        CreateDatabaseQuery(PtrTo<ClusterClause> cluster, bool if_not_exists, PtrTo<DatabaseIdentifier> identifier, PtrTo<EngineExpr> expr);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            NAME = 0,    // DatabaseIdentifier\n-            ENGINE = 1,  // EngineExpr (optional)\n-        };\n-\n-        const bool if_not_exists;\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/CreateDictionaryQuery.cpp b/src/Parsers/New/AST/CreateDictionaryQuery.cpp\ndeleted file mode 100644\nindex 75413df495bd..000000000000\n--- a/src/Parsers/New/AST/CreateDictionaryQuery.cpp\n+++ /dev/null\n@@ -1,361 +0,0 @@\n-#include <Parsers/New/AST/CreateDictionaryQuery.h>\n-\n-#include <Parsers/ASTCreateQuery.h>\n-#include <Parsers/New/AST/ColumnExpr.h>\n-#include <Parsers/New/AST/ColumnTypeExpr.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/AST/Literal.h>\n-#include <Parsers/New/AST/SelectUnionQuery.h>\n-#include <Parsers/New/AST/SettingExpr.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-#include <Poco/String.h>\n-\n-\n-namespace DB::ErrorCodes\n-{\n-    extern const int SYNTAX_ERROR;\n-}\n-\n-namespace DB::AST\n-{\n-\n-// DictionaryAttributeExpr\n-\n-DictionaryAttributeExpr::DictionaryAttributeExpr(PtrTo<Identifier> identifier, PtrTo<ColumnTypeExpr> type) : INode(MAX_INDEX)\n-{\n-    set(NAME, identifier);\n-    set(TYPE, type);\n-}\n-\n-void DictionaryAttributeExpr::setDefaultClause(PtrTo<Literal> literal)\n-{\n-    set(DEFAULT, literal);\n-}\n-\n-void DictionaryAttributeExpr::setExpressionClause(PtrTo<ColumnExpr> expr)\n-{\n-    set(EXPRESSION, expr);\n-}\n-\n-ASTPtr DictionaryAttributeExpr::convertToOld() const\n-{\n-    auto expr = std::make_shared<ASTDictionaryAttributeDeclaration>();\n-\n-    expr->name = get<Identifier>(NAME)->getName();\n-    if (has(TYPE))\n-    {\n-        expr->type = get(TYPE)->convertToOld();\n-        expr->children.push_back(expr->type);\n-    }\n-    if (has(DEFAULT))\n-    {\n-        expr->default_value = get(DEFAULT)->convertToOld();\n-        expr->children.push_back(expr->default_value);\n-    }\n-    if (has(EXPRESSION))\n-    {\n-        expr->expression = get(EXPRESSION)->convertToOld();\n-        expr->children.push_back(expr->expression);\n-    }\n-    expr->hierarchical = hierarchical;\n-    expr->injective = injective;\n-    expr->is_object_id = is_object_id;\n-\n-    return expr;\n-}\n-\n-// DictionaryArgExpr\n-\n-DictionaryArgExpr::DictionaryArgExpr(PtrTo<Identifier> identifier, PtrTo<ColumnExpr> expr) : INode{identifier, expr}\n-{\n-    if (expr->getType() != ColumnExpr::ExprType::LITERAL && expr->getType() != ColumnExpr::ExprType::IDENTIFIER\n-        && expr->getType() != ColumnExpr::ExprType::FUNCTION)\n-        throw DB::Exception(ErrorCodes::SYNTAX_ERROR, \"Expected literal, identifier or function\");\n-}\n-\n-ASTPtr DictionaryArgExpr::convertToOld() const\n-{\n-    auto expr = std::make_shared<ASTPair>(false);  // FIXME: always true?\n-\n-    // TODO: probably there are more variants to parse.\n-\n-    expr->first = Poco::toLower(get<Identifier>(KEY)->getName());\n-    expr->set(expr->second, get(VALUE)->convertToOld());\n-\n-    return expr;\n-}\n-\n-// SourceClause\n-\n-SourceClause::SourceClause(PtrTo<Identifier> identifier, PtrTo<DictionaryArgList> list) : INode{identifier, list}\n-{\n-}\n-\n-ASTPtr SourceClause::convertToOld() const\n-{\n-    auto clause = std::make_shared<ASTFunctionWithKeyValueArguments>(true);  // FIXME: always true?\n-\n-    clause->name = Poco::toLower(get<Identifier>(NAME)->getName());\n-    if (has(ARGS))\n-    {\n-        clause->elements = get(ARGS)->convertToOld();\n-        clause->children.push_back(clause->elements);\n-    }\n-\n-    return clause;\n-}\n-\n-// LifetimeClause\n-\n-LifetimeClause::LifetimeClause(PtrTo<NumberLiteral> max, PtrTo<NumberLiteral> min) : INode{max, min}\n-{\n-}\n-\n-ASTPtr LifetimeClause::convertToOld() const\n-{\n-    auto clause = std::make_shared<ASTDictionaryLifetime>();\n-\n-    clause->max_sec = get(MAX)->convertToOld()->as<ASTLiteral>()->value.get<UInt64>();\n-    if (has(MIN)) clause->min_sec = get(MIN)->convertToOld()->as<ASTLiteral>()->value.get<UInt64>();\n-\n-    return clause;\n-}\n-\n-// LayoutClause\n-\n-LayoutClause::LayoutClause(PtrTo<Identifier> identifier, PtrTo<DictionaryArgList> list) : INode{identifier, list}\n-{\n-}\n-\n-ASTPtr LayoutClause::convertToOld() const\n-{\n-    auto clause = std::make_shared<ASTDictionaryLayout>();\n-\n-    clause->layout_type = Poco::toLower(get<Identifier>(NAME)->getName());\n-    clause->has_brackets = true;  // FIXME: maybe not?\n-    if (has(ARGS)) clause->set(clause->parameters, get(ARGS)->convertToOld());\n-\n-    return clause;\n-}\n-\n-// RangeClause\n-\n-RangeClause::RangeClause(PtrTo<Identifier> max, PtrTo<Identifier> min) : INode{max, min}\n-{\n-}\n-\n-ASTPtr RangeClause::convertToOld() const\n-{\n-    auto clause = std::make_shared<ASTDictionaryRange>();\n-\n-    clause->max_attr_name = get<Identifier>(MAX)->getName();\n-    clause->min_attr_name = get<Identifier>(MIN)->getName();\n-\n-    return clause;\n-}\n-\n-// DictionarySettingsClause\n-\n-DictionarySettingsClause::DictionarySettingsClause(PtrTo<SettingExprList> list) : INode{list}\n-{\n-}\n-\n-ASTPtr DictionarySettingsClause::convertToOld() const\n-{\n-    auto clause = std::make_shared<ASTDictionarySettings>();\n-\n-    for (const auto & child : get(LIST)->as<SettingExprList &>())\n-    {\n-        const auto * setting = child->as<SettingExpr>();\n-        clause->changes.emplace_back(setting->getName()->getName(), setting->getValue()->convertToOld()->as<ASTLiteral>()->value);\n-    }\n-\n-    return clause;\n-}\n-\n-// DictionaryEngineClause\n-\n-DictionaryEngineClause::DictionaryEngineClause(PtrTo<DictionaryPrimaryKeyClause> clause) : INode(MAX_INDEX)\n-{\n-    set(PRIMARY_KEY, clause);\n-}\n-\n-void DictionaryEngineClause::setSourceClause(PtrTo<SourceClause> clause)\n-{\n-    set(SOURCE, clause);\n-}\n-\n-void DictionaryEngineClause::setLifetimeClause(PtrTo<LifetimeClause> clause)\n-{\n-    set(LIFETIME, clause);\n-}\n-\n-void DictionaryEngineClause::setLayoutClause(PtrTo<LayoutClause> clause)\n-{\n-    set(LAYOUT, clause);\n-}\n-\n-void DictionaryEngineClause::setRangeClause(PtrTo<RangeClause> clause)\n-{\n-    set(RANGE, clause);\n-}\n-\n-void DictionaryEngineClause::setSettingsClause(PtrTo<DictionarySettingsClause> clause)\n-{\n-    set(SETTINGS, clause);\n-}\n-\n-ASTPtr DictionaryEngineClause::convertToOld() const\n-{\n-    auto clause = std::make_shared<ASTDictionary>();\n-\n-    if (has(PRIMARY_KEY)) clause->set(clause->primary_key, get(PRIMARY_KEY)->convertToOld());\n-    if (has(SOURCE)) clause->set(clause->source, get(SOURCE)->convertToOld());\n-    if (has(LIFETIME)) clause->set(clause->lifetime, get(LIFETIME)->convertToOld());\n-    if (has(LAYOUT)) clause->set(clause->layout, get(LAYOUT)->convertToOld());\n-    if (has(RANGE)) clause->set(clause->range, get(RANGE)->convertToOld());\n-    if (has(SETTINGS)) clause->set(clause->dict_settings, get(SETTINGS)->convertToOld());\n-\n-    return clause;\n-}\n-\n-// CreateDictionaryQuery\n-\n-CreateDictionaryQuery::CreateDictionaryQuery(\n-    PtrTo<ClusterClause> cluster,\n-    bool attach_,\n-    bool if_not_exists_,\n-    PtrTo<TableIdentifier> identifier,\n-    PtrTo<UUIDClause> uuid,\n-    PtrTo<DictionarySchemaClause> schema,\n-    PtrTo<DictionaryEngineClause> engine)\n-    : DDLQuery(cluster, {identifier, uuid, schema, engine}), attach(attach_), if_not_exists(if_not_exists_)\n-{\n-}\n-\n-ASTPtr CreateDictionaryQuery::convertToOld() const\n-{\n-    auto query = std::make_shared<ASTCreateQuery>();\n-\n-    {\n-        auto table = get(NAME)->convertToOld();\n-        query->database = table->as<ASTTableIdentifier>()->getDatabaseName();\n-        query->table = table->as<ASTTableIdentifier>()->shortName();\n-        query->uuid = has(UUID) ? parseFromString<DB::UUID>(get(UUID)->convertToOld()->as<ASTLiteral>()->value.get<String>())\n-                                : table->as<ASTTableIdentifier>()->uuid;\n-    }\n-\n-    query->cluster = cluster_name;\n-\n-    query->is_dictionary = true;\n-    query->attach = attach;\n-    query->if_not_exists = if_not_exists;\n-\n-    query->set(query->dictionary_attributes_list, get(SCHEMA)->convertToOld());\n-    query->set(query->dictionary, get(ENGINE)->convertToOld());\n-\n-    return query;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitCreateDictionaryStmt(ClickHouseParser::CreateDictionaryStmtContext *ctx)\n-{\n-    auto uuid = ctx->uuidClause() ? visit(ctx->uuidClause()).as<PtrTo<UUIDClause>>() : nullptr;\n-    auto cluster = ctx->clusterClause() ? visit(ctx->clusterClause()).as<PtrTo<ClusterClause>>() : nullptr;\n-    auto schema = ctx->dictionarySchemaClause() ? visit(ctx->dictionarySchemaClause()).as<PtrTo<DictionarySchemaClause>>() : nullptr;\n-    auto engine = ctx->dictionaryEngineClause() ? visit(ctx->dictionaryEngineClause()).as<PtrTo<DictionaryEngineClause>>() : nullptr;\n-    return std::make_shared<CreateDictionaryQuery>(\n-        cluster, !!ctx->ATTACH(), !!ctx->IF(), visit(ctx->tableIdentifier()), uuid, schema, engine);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitDictionaryArgExpr(ClickHouseParser::DictionaryArgExprContext *ctx)\n-{\n-    PtrTo<ColumnExpr> expr;\n-    if (ctx->literal()) expr = ColumnExpr::createLiteral(visit(ctx->literal()));\n-    else if (ctx->LPAREN()) expr = ColumnExpr::createFunction(visit(ctx->identifier(1)), nullptr, nullptr);\n-    else expr = ColumnExpr::createIdentifier(visit(ctx->identifier(1)));\n-    return std::make_shared<DictionaryArgExpr>(visit(ctx->identifier(0)), expr);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitDictionaryAttrDfnt(ClickHouseParser::DictionaryAttrDfntContext *ctx)\n-{\n-    auto expr = std::make_shared<DictionaryAttributeExpr>(visit(ctx->identifier()), visit(ctx->columnTypeExpr()));\n-    if (!ctx->DEFAULT().empty()) expr->setDefaultClause(visit(ctx->literal(0)));\n-    if (!ctx->EXPRESSION().empty()) expr->setExpressionClause(visit(ctx->columnExpr(0)));\n-    if (!ctx->HIERARCHICAL().empty()) expr->setHierarchicalFlag();\n-    if (!ctx->INJECTIVE().empty()) expr->setInjectiveFlag();\n-    if (!ctx->IS_OBJECT_ID().empty()) expr->setIsObjectIdFlag();\n-    return expr;\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitDictionaryEngineClause(ClickHouseParser::DictionaryEngineClauseContext *ctx)\n-{\n-    auto primary_key\n-        = ctx->dictionaryPrimaryKeyClause() ? visit(ctx->dictionaryPrimaryKeyClause()).as<PtrTo<DictionaryPrimaryKeyClause>>() : nullptr;\n-    auto clause = std::make_shared<DictionaryEngineClause>(primary_key);\n-    if (!ctx->sourceClause().empty()) clause->setSourceClause(visit(ctx->sourceClause(0)));\n-    if (!ctx->lifetimeClause().empty()) clause->setLifetimeClause(visit(ctx->lifetimeClause(0)));\n-    if (!ctx->layoutClause().empty()) clause->setLayoutClause(visit(ctx->layoutClause(0)));\n-    if (!ctx->rangeClause().empty()) clause->setRangeClause(visit(ctx->rangeClause(0)));\n-    if (!ctx->dictionarySettingsClause().empty()) clause->setSettingsClause(visit(ctx->dictionarySettingsClause(0)));\n-    return clause;\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitDictionaryPrimaryKeyClause(ClickHouseParser::DictionaryPrimaryKeyClauseContext *ctx)\n-{\n-    return std::make_shared<DictionaryPrimaryKeyClause>(visit(ctx->columnExprList()).as<PtrTo<ColumnExprList>>());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitDictionarySchemaClause(ClickHouseParser::DictionarySchemaClauseContext *ctx)\n-{\n-    auto list = std::make_shared<DictionaryAttributeList>();\n-    for (auto * attr : ctx->dictionaryAttrDfnt()) list->push(visit(attr));\n-    return std::make_shared<DictionarySchemaClause>(list);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitDictionarySettingsClause(ClickHouseParser::DictionarySettingsClauseContext *ctx)\n-{\n-    return std::make_shared<DictionarySettingsClause>(visit(ctx->settingExprList()).as<PtrTo<SettingExprList>>());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitLayoutClause(ClickHouseParser::LayoutClauseContext *ctx)\n-{\n-    auto list = ctx->dictionaryArgExpr().empty() ? nullptr : std::make_shared<DictionaryArgList>();\n-    for (auto * arg : ctx->dictionaryArgExpr()) list->push(visit(arg));\n-    return std::make_shared<LayoutClause>(visit(ctx->identifier()), list);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitLifetimeClause(ClickHouseParser::LifetimeClauseContext *ctx)\n-{\n-    if (ctx->DECIMAL_LITERAL().size() == 1) return std::make_shared<LifetimeClause>(Literal::createNumber(ctx->DECIMAL_LITERAL(0)));\n-    if (ctx->MAX()->getSymbol()->getTokenIndex() < ctx->MIN()->getSymbol()->getTokenIndex())\n-        return std::make_shared<LifetimeClause>(\n-            Literal::createNumber(ctx->DECIMAL_LITERAL(0)), Literal::createNumber(ctx->DECIMAL_LITERAL(1)));\n-    else\n-        return std::make_shared<LifetimeClause>(\n-            Literal::createNumber(ctx->DECIMAL_LITERAL(1)), Literal::createNumber(ctx->DECIMAL_LITERAL(0)));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitRangeClause(ClickHouseParser::RangeClauseContext *ctx)\n-{\n-    if (ctx->MAX()->getSymbol()->getTokenIndex() < ctx->MIN()->getSymbol()->getTokenIndex())\n-        return std::make_shared<RangeClause>(visit(ctx->identifier(0)), visit(ctx->identifier(1)));\n-    else\n-        return std::make_shared<RangeClause>(visit(ctx->identifier(1)), visit(ctx->identifier(0)));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitSourceClause(ClickHouseParser::SourceClauseContext *ctx)\n-{\n-    auto list = ctx->dictionaryArgExpr().empty() ? nullptr : std::make_shared<DictionaryArgList>();\n-    for (auto * arg : ctx->dictionaryArgExpr()) list->push(visit(arg));\n-    return std::make_shared<SourceClause>(visit(ctx->identifier()), list);\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/CreateDictionaryQuery.h b/src/Parsers/New/AST/CreateDictionaryQuery.h\ndeleted file mode 100644\nindex 3c5be3f391ce..000000000000\n--- a/src/Parsers/New/AST/CreateDictionaryQuery.h\n+++ /dev/null\n@@ -1,183 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/DDLQuery.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class DictionaryAttributeExpr : public INode\n-{\n-    public:\n-        DictionaryAttributeExpr(PtrTo<Identifier> identifier, PtrTo<ColumnTypeExpr> type);\n-\n-        void setDefaultClause(PtrTo<Literal> literal);\n-        void setExpressionClause(PtrTo<ColumnExpr> expr);\n-\n-        void setHierarchicalFlag() { hierarchical = true; }\n-        void setInjectiveFlag() { injective = true; }\n-        void setIsObjectIdFlag() { is_object_id = true; }\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            NAME = 0,    // Identifier\n-            TYPE,        // ColumnTypeExpr\n-            DEFAULT,     // Literal (optional)\n-            EXPRESSION,  // ColumnExpr (optional)\n-\n-            MAX_INDEX,\n-        };\n-\n-        bool hierarchical = false, injective = false, is_object_id = false;\n-};\n-\n-using DictionaryPrimaryKeyClause = SimpleClause<ColumnExprList>;\n-\n-using DictionarySchemaClause = SimpleClause<DictionaryAttributeList>;\n-\n-class DictionaryArgExpr : public INode\n-{\n-    public:\n-        explicit DictionaryArgExpr(PtrTo<Identifier> identifier, PtrTo<ColumnExpr> expr);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            KEY = 0,  // Identifier\n-            VALUE,    // ColumnExpr: literal, identifier or function\n-        };\n-};\n-\n-class SourceClause : public INode\n-{\n-    public:\n-        SourceClause(PtrTo<Identifier> identifier, PtrTo<DictionaryArgList> list);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            NAME = 0,  // Identifier\n-            ARGS = 1,  // DictionaryArgList (optional)\n-        };\n-};\n-\n-class LifetimeClause : public INode\n-{\n-    public:\n-        explicit LifetimeClause(PtrTo<NumberLiteral> max, PtrTo<NumberLiteral> min = nullptr);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            MAX = 0,  // NumberLiteral\n-            MIN,      // NumberLiteral (optional)\n-        };\n-};\n-\n-class LayoutClause : public INode\n-{\n-    public:\n-        LayoutClause(PtrTo<Identifier> identifier, PtrTo<DictionaryArgList> list);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            NAME = 0,  // Identifier\n-            ARGS = 1,  // DictionaryArgList (optional)\n-        };\n-};\n-\n-class RangeClause : public INode\n-{\n-    public:\n-        RangeClause(PtrTo<Identifier> max, PtrTo<Identifier> min);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            MAX = 0,  // Identifier\n-            MIN,      // Identifier\n-        };\n-};\n-\n-class DictionarySettingsClause : public INode\n-{\n-    public:\n-        explicit DictionarySettingsClause(PtrTo<SettingExprList> list);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            LIST = 0,  // SettingExprList\n-        };\n-};\n-\n-class DictionaryEngineClause : public INode\n-{\n-    public:\n-        explicit DictionaryEngineClause(PtrTo<DictionaryPrimaryKeyClause> clause);\n-\n-        void setSourceClause(PtrTo<SourceClause> clause);\n-        void setLifetimeClause(PtrTo<LifetimeClause> clause);\n-        void setLayoutClause(PtrTo<LayoutClause> clause);\n-        void setRangeClause(PtrTo<RangeClause> clause);\n-        void setSettingsClause(PtrTo<DictionarySettingsClause> clause);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            PRIMARY_KEY = 0,  // DictionaryPrimaryKeyClause\n-            SOURCE,           // SourceClause (optional)\n-            LIFETIME,         // LifetimeClause (optional)\n-            LAYOUT,           // LayoutClause (optional)\n-            RANGE,            // RangeClause (optional)\n-            SETTINGS,         // DictionarySettingsClause (optional)\n-\n-            MAX_INDEX,\n-        };\n-};\n-\n-class CreateDictionaryQuery : public DDLQuery\n-{\n-    public:\n-        CreateDictionaryQuery(\n-            PtrTo<ClusterClause> cluster,\n-            bool attach,\n-            bool if_not_exists,\n-            PtrTo<TableIdentifier> identifier,\n-            PtrTo<UUIDClause> uuid,\n-            PtrTo<DictionarySchemaClause> schema,\n-            PtrTo<DictionaryEngineClause> engine);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            NAME = 0,  // TableIdentifier\n-            UUID,      // UUIDClause (optional)\n-            SCHEMA,    // DictionarySchemaClause\n-            ENGINE,    // DictionaryEngineClause\n-        };\n-\n-        const bool attach, if_not_exists;\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/CreateLiveViewQuery.cpp b/src/Parsers/New/AST/CreateLiveViewQuery.cpp\ndeleted file mode 100644\nindex 18501884f025..000000000000\n--- a/src/Parsers/New/AST/CreateLiveViewQuery.cpp\n+++ /dev/null\n@@ -1,86 +0,0 @@\n-#include <Parsers/New/AST/CreateLiveViewQuery.h>\n-\n-#include <Parsers/ASTCreateQuery.h>\n-#include <Parsers/New/AST/CreateTableQuery.h>\n-#include <Parsers/New/AST/Literal.h>\n-#include <Parsers/New/AST/SelectUnionQuery.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-CreateLiveViewQuery::CreateLiveViewQuery(\n-    PtrTo<ClusterClause> cluster,\n-    bool attach_,\n-    bool if_not_exists_,\n-    PtrTo<TableIdentifier> identifier,\n-    PtrTo<UUIDClause> uuid,\n-    PtrTo<NumberLiteral> timeout,\n-    PtrTo<DestinationClause> destination,\n-    PtrTo<TableSchemaClause> schema,\n-    PtrTo<SelectUnionQuery> query)\n-    : DDLQuery(cluster, {identifier, uuid, timeout, destination, schema, query}), attach(attach_), if_not_exists(if_not_exists_)\n-{\n-}\n-\n-ASTPtr CreateLiveViewQuery::convertToOld() const\n-{\n-    auto query = std::make_shared<ASTCreateQuery>();\n-\n-    {\n-        auto table = std::static_pointer_cast<ASTTableIdentifier>(get(NAME)->convertToOld());\n-        query->database = table->getDatabaseName();\n-        query->table = table->shortName();\n-        query->uuid = has(UUID) ? parseFromString<DB::UUID>(get(UUID)->convertToOld()->as<ASTLiteral>()->value.get<String>()) : table->uuid;\n-    }\n-\n-    if (has(TIMEOUT))\n-        query->live_view_timeout.emplace(get(TIMEOUT)->convertToOld()->as<ASTLiteral>()->value.get<UInt64>());\n-\n-    if (has(DESTINATION))\n-        query->to_table_id = get(DESTINATION)->convertToOld()->as<ASTTableIdentifier>()->getTableId();\n-\n-    if (has(SCHEMA))\n-    {\n-        assert(get<TableSchemaClause>(SCHEMA)->getType() == TableSchemaClause::ClauseType::DESCRIPTION);\n-        query->set(query->columns_list, get(SCHEMA)->convertToOld());\n-    }\n-\n-    query->attach = attach;\n-    query->if_not_exists = if_not_exists;\n-    query->is_live_view = true;\n-    query->set(query->select, get(SUBQUERY)->convertToOld());\n-    query->cluster = cluster_name;\n-\n-    return query;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitCreateLiveViewStmt(ClickHouseParser::CreateLiveViewStmtContext *ctx)\n-{\n-    auto uuid = ctx->uuidClause() ? visit(ctx->uuidClause()).as<PtrTo<UUIDClause>>() : nullptr;\n-    auto cluster = ctx->clusterClause() ? visit(ctx->clusterClause()).as<PtrTo<ClusterClause>>() : nullptr;\n-    auto timeout = ctx->DECIMAL_LITERAL() ? Literal::createNumber(ctx->DECIMAL_LITERAL()) : nullptr;\n-    auto destination = ctx->destinationClause() ? visit(ctx->destinationClause()).as<PtrTo<DestinationClause>>() : nullptr;\n-    auto schema = ctx->tableSchemaClause() ? visit(ctx->tableSchemaClause()).as<PtrTo<TableSchemaClause>>() : nullptr;\n-    if (ctx->TIMEOUT() && !timeout) timeout = Literal::createNumber(std::to_string(DEFAULT_TEMPORARY_LIVE_VIEW_TIMEOUT_SEC));\n-    return std::make_shared<CreateLiveViewQuery>(\n-        cluster,\n-        !!ctx->ATTACH(),\n-        !!ctx->IF(),\n-        visit(ctx->tableIdentifier()),\n-        uuid,\n-        timeout,\n-        destination,\n-        schema,\n-        visit(ctx->subqueryClause()));\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/CreateLiveViewQuery.h b/src/Parsers/New/AST/CreateLiveViewQuery.h\ndeleted file mode 100644\nindex dd6fe8a25284..000000000000\n--- a/src/Parsers/New/AST/CreateLiveViewQuery.h\n+++ /dev/null\n@@ -1,39 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/DDLQuery.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class CreateLiveViewQuery : public DDLQuery\n-{\n-    public:\n-        CreateLiveViewQuery(\n-            PtrTo<ClusterClause> cluster,\n-            bool attach,\n-            bool if_not_exists,\n-            PtrTo<TableIdentifier> identifier,\n-            PtrTo<UUIDClause> uuid,\n-            PtrTo<NumberLiteral> timeout,\n-            PtrTo<DestinationClause> destination,\n-            PtrTo<TableSchemaClause> schema,\n-            PtrTo<SelectUnionQuery> query);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            NAME = 0,     // TableIdentifier\n-            UUID,         // UUIDClause (optional)\n-            TIMEOUT,      // NumberLiteral (optional)\n-            DESTINATION,  // DestinationClause (optional)\n-            SCHEMA,       // TableSchemaClause (optional)\n-            SUBQUERY,     // SelectUnionQuery\n-        };\n-\n-        const bool attach, if_not_exists;\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/CreateMaterializedViewQuery.cpp b/src/Parsers/New/AST/CreateMaterializedViewQuery.cpp\ndeleted file mode 100644\nindex 2b8a1b18b5ff..000000000000\n--- a/src/Parsers/New/AST/CreateMaterializedViewQuery.cpp\n+++ /dev/null\n@@ -1,99 +0,0 @@\n-#include <Parsers/New/AST/CreateMaterializedViewQuery.h>\n-\n-#include <IO/ReadHelpers.h>\n-#include <Parsers/ASTCreateQuery.h>\n-#include <Parsers/New/AST/CreateTableQuery.h>\n-#include <Parsers/New/AST/EngineExpr.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/AST/SelectUnionQuery.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-CreateMaterializedViewQuery::CreateMaterializedViewQuery(\n-    PtrTo<ClusterClause> cluster,\n-    bool attach_,\n-    bool if_not_exists_,\n-    bool populate_,\n-    PtrTo<TableIdentifier> identifier,\n-    PtrTo<UUIDClause> uuid,\n-    PtrTo<TableSchemaClause> schema,\n-    PtrTo<DestinationClause> destination,\n-    PtrTo<EngineClause> engine,\n-    PtrTo<SelectUnionQuery> query)\n-    : DDLQuery(cluster, {identifier, uuid, schema, destination, engine, query})\n-    , attach(attach_)\n-    , if_not_exists(if_not_exists_)\n-    , populate(populate_)\n-{\n-    assert(!destination != !engine);\n-}\n-\n-ASTPtr CreateMaterializedViewQuery::convertToOld() const\n-{\n-    auto query = std::make_shared<ASTCreateQuery>();\n-\n-    {\n-        auto table = std::static_pointer_cast<ASTTableIdentifier>(get(NAME)->convertToOld());\n-        query->database = table->getDatabaseName();\n-        query->table = table->shortName();\n-        query->uuid = has(UUID) ? parseFromString<DB::UUID>(get(UUID)->convertToOld()->as<ASTLiteral>()->value.get<String>()) : table->uuid;\n-    }\n-\n-    if (has(DESTINATION))\n-        query->to_table_id = get(DESTINATION)->convertToOld()->as<ASTTableIdentifier>()->getTableId();\n-    else if (has(ENGINE))\n-    {\n-        query->set(query->storage, get(ENGINE)->convertToOld());\n-        query->is_populate = populate;\n-    }\n-\n-    if (has(SCHEMA))\n-    {\n-        assert(get<TableSchemaClause>(SCHEMA)->getType() == TableSchemaClause::ClauseType::DESCRIPTION);\n-        query->set(query->columns_list, get(SCHEMA)->convertToOld());\n-    }\n-\n-    query->attach = attach;\n-    query->if_not_exists = if_not_exists;\n-    query->is_materialized_view = true;\n-    query->set(query->select, get(SUBQUERY)->convertToOld());\n-    query->cluster = cluster_name;\n-\n-    return query;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitCreateMaterializedViewStmt(ClickHouseParser::CreateMaterializedViewStmtContext *ctx)\n-{\n-    auto uuid = ctx->uuidClause() ? visit(ctx->uuidClause()).as<PtrTo<UUIDClause>>() : nullptr;\n-    auto cluster = ctx->clusterClause() ? visit(ctx->clusterClause()).as<PtrTo<ClusterClause>>() : nullptr;\n-    auto schema = ctx->tableSchemaClause() ? visit(ctx->tableSchemaClause()).as<PtrTo<TableSchemaClause>>() : nullptr;\n-    auto engine = ctx->engineClause() ? visit(ctx->engineClause()).as<PtrTo<EngineClause>>() : nullptr;\n-    auto destination = ctx->destinationClause() ? visit(ctx->destinationClause()).as<PtrTo<DestinationClause>>() : nullptr;\n-    return std::make_shared<CreateMaterializedViewQuery>(\n-        cluster,\n-        !!ctx->ATTACH(),\n-        !!ctx->IF(),\n-        !!ctx->POPULATE(),\n-        visit(ctx->tableIdentifier()),\n-        uuid,\n-        schema,\n-        destination,\n-        engine,\n-        visit(ctx->subqueryClause()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitDestinationClause(ClickHouseParser::DestinationClauseContext *ctx)\n-{\n-    return std::make_shared<DestinationClause>(visit(ctx->tableIdentifier()).as<PtrTo<TableIdentifier>>());\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/CreateMaterializedViewQuery.h b/src/Parsers/New/AST/CreateMaterializedViewQuery.h\ndeleted file mode 100644\nindex 6cd45132371c..000000000000\n--- a/src/Parsers/New/AST/CreateMaterializedViewQuery.h\n+++ /dev/null\n@@ -1,40 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/DDLQuery.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class CreateMaterializedViewQuery : public DDLQuery\n-{\n-    public:\n-        CreateMaterializedViewQuery(\n-            PtrTo<ClusterClause> cluster,\n-            bool attach,\n-            bool if_not_exists,\n-            bool populate,\n-            PtrTo<TableIdentifier> identifier,\n-            PtrTo<UUIDClause> uuid,\n-            PtrTo<TableSchemaClause> schema,\n-            PtrTo<DestinationClause> destination,\n-            PtrTo<EngineClause> engine,\n-            PtrTo<SelectUnionQuery> query);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            NAME = 0,     // TableIdentifier\n-            UUID,         // UUIDClause (optional)\n-            SCHEMA,       // TableSchemaClause (optional)\n-            DESTINATION,  // DestinationClause (optional)\n-            ENGINE,       // EngineClause (optional)\n-            SUBQUERY,     // SelectUnionQuery\n-        };\n-\n-        const bool attach, if_not_exists, populate;\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/CreateTableQuery.cpp b/src/Parsers/New/AST/CreateTableQuery.cpp\ndeleted file mode 100644\nindex 1767c08451a5..000000000000\n--- a/src/Parsers/New/AST/CreateTableQuery.cpp\n+++ /dev/null\n@@ -1,224 +0,0 @@\n-#include <Parsers/New/AST/CreateTableQuery.h>\n-\n-#include <IO/ReadHelpers.h>\n-#include <Parsers/ASTCreateQuery.h>\n-#include <Parsers/ASTIdentifier.h>\n-#include <Parsers/New/AST/EngineExpr.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/AST/Literal.h>\n-#include <Parsers/New/AST/SelectUnionQuery.h>\n-#include <Parsers/New/AST/TableElementExpr.h>\n-#include <Parsers/New/AST/TableExpr.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-// static\n-PtrTo<TableSchemaClause> TableSchemaClause::createDescription(PtrTo<TableElementList> list)\n-{\n-    return PtrTo<TableSchemaClause>(new TableSchemaClause(ClauseType::DESCRIPTION, {list}));\n-}\n-\n-// static\n-PtrTo<TableSchemaClause> TableSchemaClause::createAsTable(PtrTo<TableIdentifier> identifier)\n-{\n-    return PtrTo<TableSchemaClause>(new TableSchemaClause(ClauseType::TABLE, {identifier}));\n-}\n-\n-// static\n-PtrTo<TableSchemaClause> TableSchemaClause::createAsFunction(PtrTo<TableFunctionExpr> expr)\n-{\n-    return PtrTo<TableSchemaClause>(new TableSchemaClause(ClauseType::FUNCTION, {expr}));\n-}\n-\n-TableSchemaClause::TableSchemaClause(ClauseType type, PtrList exprs) : INode(exprs), clause_type(type)\n-{\n-}\n-\n-ASTPtr TableSchemaClause::convertToOld() const\n-{\n-    switch(clause_type)\n-    {\n-        case ClauseType::DESCRIPTION:\n-        {\n-            auto columns = std::make_shared<ASTColumns>();\n-\n-            auto column_list = std::make_shared<ASTExpressionList>();\n-            auto constraint_list = std::make_shared<ASTExpressionList>();\n-            auto index_list = std::make_shared<ASTExpressionList>();\n-            auto projection_list = std::make_shared<ASTExpressionList>();\n-\n-            for (const auto & element : get(ELEMENTS)->as<TableElementList &>())\n-            {\n-                switch(element->as<TableElementExpr>()->getType())\n-                {\n-                    case TableElementExpr::ExprType::COLUMN:\n-                        column_list->children.push_back(element->convertToOld());\n-                        break;\n-                    case TableElementExpr::ExprType::CONSTRAINT:\n-                        constraint_list->children.push_back(element->convertToOld());\n-                        break;\n-                    case TableElementExpr::ExprType::INDEX:\n-                        index_list->children.push_back(element->convertToOld());\n-                        break;\n-                    case TableElementExpr::ExprType::PROJECTION:\n-                        projection_list->children.push_back(element->convertToOld());\n-                        break;\n-                }\n-            }\n-\n-            if (!column_list->children.empty()) columns->set(columns->columns, column_list);\n-            if (!constraint_list->children.empty()) columns->set(columns->constraints, constraint_list);\n-            if (!index_list->children.empty()) columns->set(columns->indices, index_list);\n-            if (!projection_list->children.empty()) columns->set(columns->projections, projection_list);\n-\n-            return columns;\n-        }\n-        case ClauseType::FUNCTION:\n-        case ClauseType::TABLE:\n-            return get(EXPR)->convertToOld();\n-    }\n-    __builtin_unreachable();  // FIXME: old gcc compilers complain about reaching end of non-void function\n-}\n-\n-String TableSchemaClause::dumpInfo() const\n-{\n-    switch(clause_type)\n-    {\n-        case ClauseType::DESCRIPTION: return \"Description\";\n-        case ClauseType::FUNCTION: return \"Function\";\n-        case ClauseType::TABLE: return \"Table\";\n-    }\n-    __builtin_unreachable();  // FIXME: old gcc compilers complain about reaching end of non-void function\n-}\n-\n-CreateTableQuery::CreateTableQuery(\n-    PtrTo<ClusterClause> cluster,\n-    bool attach_,\n-    bool temporary_,\n-    bool if_not_exists_,\n-    PtrTo<TableIdentifier> identifier,\n-    PtrTo<UUIDClause> uuid,\n-    PtrTo<TableSchemaClause> schema,\n-    PtrTo<EngineClause> engine,\n-    PtrTo<SelectUnionQuery> query)\n-    : DDLQuery(cluster, {identifier, uuid, schema, engine, query}), attach(attach_), temporary(temporary_), if_not_exists(if_not_exists_)\n-{\n-}\n-\n-ASTPtr CreateTableQuery::convertToOld() const\n-{\n-    auto query = std::make_shared<ASTCreateQuery>();\n-\n-    {\n-        auto table = get(NAME)->convertToOld();\n-        query->database = table->as<ASTTableIdentifier>()->getDatabaseName();\n-        query->table = table->as<ASTTableIdentifier>()->shortName();\n-        query->uuid = has(UUID) ? parseFromString<DB::UUID>(get(UUID)->convertToOld()->as<ASTLiteral>()->value.get<String>())\n-                                : table->as<ASTTableIdentifier>()->uuid;\n-    }\n-\n-    query->cluster = cluster_name;\n-\n-    query->attach = attach;\n-    query->if_not_exists = if_not_exists;\n-    query->temporary = temporary;\n-\n-    if (has(SCHEMA))\n-    {\n-        switch(get<TableSchemaClause>(SCHEMA)->getType())\n-        {\n-            case TableSchemaClause::ClauseType::DESCRIPTION:\n-            {\n-                query->set(query->columns_list, get(SCHEMA)->convertToOld());\n-                break;\n-            }\n-            case TableSchemaClause::ClauseType::TABLE:\n-            {\n-                auto table = std::static_pointer_cast<ASTTableIdentifier>(get(SCHEMA)->convertToOld());\n-                query->as_database = table->getDatabaseName();\n-                query->as_table = table->shortName();\n-                break;\n-            }\n-            case TableSchemaClause::ClauseType::FUNCTION:\n-            {\n-                query->as_table_function = get(SCHEMA)->convertToOld();\n-                break;\n-            }\n-        }\n-    }\n-    if (has(ENGINE)) query->set(query->storage, get(ENGINE)->convertToOld());\n-    if (has(SUBQUERY)) query->set(query->select, get(SUBQUERY)->convertToOld());\n-\n-    return query;\n-}\n-\n-String CreateTableQuery::dumpInfo() const\n-{\n-    String info;\n-    if (attach) info += \"attach=true, \";\n-    else info += \"attach=false, \";\n-    if (temporary) info += \"temporary=true, \";\n-    else info += \"temporary=false, \";\n-    if (if_not_exists) info += \"if_not_exists=true\";\n-    else info += \"if_not_exists=false\";\n-    return info;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-// TODO: assert(!(ctx->parent->TEMPORARY() ^ ctx->engineClause()))\n-\n-antlrcpp::Any ParseTreeVisitor::visitClusterClause(ClickHouseParser::ClusterClauseContext *ctx)\n-{\n-    auto literal = ctx->STRING_LITERAL() ? Literal::createString(ctx->STRING_LITERAL())\n-                                         : Literal::createString(ctx->identifier()->getText());\n-    return std::make_shared<ClusterClause>(literal);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitCreateTableStmt(ClickHouseParser::CreateTableStmtContext *ctx)\n-{\n-    auto uuid = ctx->uuidClause() ? visit(ctx->uuidClause()).as<PtrTo<UUIDClause>>() : nullptr;\n-    auto cluster = ctx->clusterClause() ? visit(ctx->clusterClause()).as<PtrTo<ClusterClause>>() : nullptr;\n-    auto schema = ctx->tableSchemaClause() ? visit(ctx->tableSchemaClause()).as<PtrTo<TableSchemaClause>>() : nullptr;\n-    auto engine = ctx->engineClause() ? visit(ctx->engineClause()).as<PtrTo<EngineClause>>() : nullptr;\n-    auto query = ctx->subqueryClause() ? visit(ctx->subqueryClause()).as<PtrTo<SelectUnionQuery>>() : nullptr;\n-    return std::make_shared<CreateTableQuery>(\n-        cluster, !!ctx->ATTACH(), !!ctx->TEMPORARY(), !!ctx->IF(), visit(ctx->tableIdentifier()), uuid, schema, engine, query);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitSchemaDescriptionClause(ClickHouseParser::SchemaDescriptionClauseContext *ctx)\n-{\n-    auto elems = std::make_shared<TableElementList>();\n-    for (auto * elem : ctx->tableElementExpr()) elems->push(visit(elem));\n-    return TableSchemaClause::createDescription(elems);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitSchemaAsTableClause(ClickHouseParser::SchemaAsTableClauseContext *ctx)\n-{\n-    return TableSchemaClause::createAsTable(visit(ctx->tableIdentifier()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitSchemaAsFunctionClause(ClickHouseParser::SchemaAsFunctionClauseContext *ctx)\n-{\n-    return TableSchemaClause::createAsFunction(visit(ctx->tableFunctionExpr()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitSubqueryClause(ClickHouseParser::SubqueryClauseContext *ctx)\n-{\n-    return visit(ctx->selectUnionStmt());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitUuidClause(ClickHouseParser::UuidClauseContext *ctx)\n-{\n-    return std::make_shared<UUIDClause>(Literal::createString(ctx->STRING_LITERAL()));\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/CreateTableQuery.h b/src/Parsers/New/AST/CreateTableQuery.h\ndeleted file mode 100644\nindex 4fe19832b1d5..000000000000\n--- a/src/Parsers/New/AST/CreateTableQuery.h\n+++ /dev/null\n@@ -1,76 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/DDLQuery.h>\n-#include \"Parsers/New/AST/SelectUnionQuery.h\"\n-\n-\n-namespace DB::AST\n-{\n-\n-class TableSchemaClause : public INode\n-{\n-    public:\n-        static PtrTo<TableSchemaClause> createDescription(PtrTo<TableElementList> list);\n-        static PtrTo<TableSchemaClause> createAsTable(PtrTo<TableIdentifier> identifier);\n-        static PtrTo<TableSchemaClause> createAsFunction(PtrTo<TableFunctionExpr> expr);\n-\n-        enum class ClauseType\n-        {\n-            DESCRIPTION,\n-            TABLE,\n-            FUNCTION,\n-        };\n-\n-        auto getType() const { return clause_type; }\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            // DESCRIPTION\n-            ELEMENTS = 0,  // TableElementList\n-\n-            // TABLE and FUNCTION\n-            EXPR = 0,      // TableIdentifier or TableFunctionExpr\n-        };\n-\n-        ClauseType clause_type;\n-\n-        TableSchemaClause(ClauseType type, PtrList exprs);\n-\n-        String dumpInfo() const override;\n-};\n-\n-class CreateTableQuery : public DDLQuery\n-{\n-    public:\n-        CreateTableQuery(\n-            PtrTo<ClusterClause> cluster,\n-            bool attach,\n-            bool temporary,\n-            bool if_not_exists,\n-            PtrTo<TableIdentifier> identifier,\n-            PtrTo<UUIDClause> uuid,\n-            PtrTo<TableSchemaClause> schema,\n-            PtrTo<EngineClause> engine,\n-            PtrTo<SelectUnionQuery> query);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            NAME = 0,  // TableIdentifier\n-            UUID,      // UUIDClause (optional)\n-            SCHEMA,    // TableSchemaClause\n-            ENGINE,    // EngineClause\n-            SUBQUERY,  // SelectUnionQuery\n-        };\n-\n-        const bool attach, temporary, if_not_exists;\n-\n-        String dumpInfo() const override;\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/CreateViewQuery.cpp b/src/Parsers/New/AST/CreateViewQuery.cpp\ndeleted file mode 100644\nindex 97244e82d528..000000000000\n--- a/src/Parsers/New/AST/CreateViewQuery.cpp\n+++ /dev/null\n@@ -1,62 +0,0 @@\n-#include <Parsers/New/AST/CreateViewQuery.h>\n-\n-#include <Parsers/ASTCreateQuery.h>\n-#include <Parsers/New/AST/CreateTableQuery.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/AST/SelectUnionQuery.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-CreateViewQuery::CreateViewQuery(\n-    PtrTo<ClusterClause> cluster,\n-    bool attach_,\n-    bool replace_,\n-    bool if_not_exists_,\n-    PtrTo<TableIdentifier> identifier,\n-    PtrTo<TableSchemaClause> clause,\n-    PtrTo<SelectUnionQuery> query)\n-    : DDLQuery(cluster, {identifier, clause, query}), attach(attach_), replace(replace_), if_not_exists(if_not_exists_)\n-{\n-}\n-\n-ASTPtr CreateViewQuery::convertToOld() const\n-{\n-    auto query = std::make_shared<ASTCreateQuery>();\n-\n-    {\n-        auto table = std::static_pointer_cast<ASTTableIdentifier>(get(NAME)->convertToOld());\n-        query->database = table->getDatabaseName();\n-        query->table = table->shortName();\n-        query->uuid = table->uuid;\n-    }\n-\n-    query->attach = attach;\n-    query->replace_view = replace;\n-    query->if_not_exists = if_not_exists;\n-    query->is_ordinary_view = true;\n-    query->cluster = cluster_name;\n-\n-    if (has(SCHEMA)) query->set(query->columns_list, get(SCHEMA)->convertToOld());\n-    query->set(query->select, get(SUBQUERY)->convertToOld());\n-\n-    return query;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitCreateViewStmt(ClickHouseParser::CreateViewStmtContext *ctx)\n-{\n-    auto cluster = ctx->clusterClause() ? visit(ctx->clusterClause()).as<PtrTo<ClusterClause>>() : nullptr;\n-    auto schema = ctx->tableSchemaClause() ? visit(ctx->tableSchemaClause()).as<PtrTo<TableSchemaClause>>() : nullptr;\n-    return std::make_shared<CreateViewQuery>(\n-        cluster, !!ctx->ATTACH(), !!ctx->REPLACE(), !!ctx->IF(), visit(ctx->tableIdentifier()), schema, visit(ctx->subqueryClause()));\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/CreateViewQuery.h b/src/Parsers/New/AST/CreateViewQuery.h\ndeleted file mode 100644\nindex 41567c30cdc2..000000000000\n--- a/src/Parsers/New/AST/CreateViewQuery.h\n+++ /dev/null\n@@ -1,34 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/DDLQuery.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class CreateViewQuery : public DDLQuery\n-{\n-    public:\n-        CreateViewQuery(\n-            PtrTo<ClusterClause> cluster,\n-            bool attach,\n-            bool replace,\n-            bool if_not_exists,\n-            PtrTo<TableIdentifier> identifier,\n-            PtrTo<TableSchemaClause> clause,\n-            PtrTo<SelectUnionQuery> query);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            NAME = 0,      // TableIdentifier\n-            SCHEMA = 1,    // TableSchemaClause (optional)\n-            SUBQUERY = 2,  // SelectUnionQuery\n-        };\n-\n-        const bool attach, replace, if_not_exists;\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/DDLQuery.cpp b/src/Parsers/New/AST/DDLQuery.cpp\ndeleted file mode 100644\nindex 0cd06e27abe9..000000000000\n--- a/src/Parsers/New/AST/DDLQuery.cpp\n+++ /dev/null\n@@ -1,6 +0,0 @@\n-#include <Parsers/New/AST/DDLQuery.h>\n-\n-\n-namespace DB::AST\n-{\n-}\ndiff --git a/src/Parsers/New/AST/DDLQuery.h b/src/Parsers/New/AST/DDLQuery.h\ndeleted file mode 100644\nindex 6aba46d29e31..000000000000\n--- a/src/Parsers/New/AST/DDLQuery.h\n+++ /dev/null\n@@ -1,29 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/Query.h>\n-\n-#include <Parsers/ASTLiteral.h>\n-#include <Parsers/ASTQueryWithOnCluster.h>\n-#include <Parsers/New/AST/Identifier.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class DDLQuery : public Query\n-{\n-    protected:\n-        DDLQuery(PtrTo<ClusterClause> cluster, std::initializer_list<Ptr> list)\n-            : Query(list), cluster_name(cluster ? cluster->convertToOld()->as<ASTLiteral>()->value.get<String>() : String{})\n-        {\n-        }\n-\n-        DDLQuery(PtrTo<ClusterClause> cluster, PtrList list)\n-            : Query(list), cluster_name(cluster ? cluster->convertToOld()->as<ASTLiteral>()->value.get<String>() : String{})\n-        {\n-        }\n-\n-        const String cluster_name;\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/DescribeQuery.cpp b/src/Parsers/New/AST/DescribeQuery.cpp\ndeleted file mode 100644\nindex b924b1b270bd..000000000000\n--- a/src/Parsers/New/AST/DescribeQuery.cpp\n+++ /dev/null\n@@ -1,36 +0,0 @@\n-#include <Parsers/New/AST/DescribeQuery.h>\n-\n-#include <Parsers/TablePropertiesQueriesASTs.h>\n-#include <Parsers/New/AST/TableExpr.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-DescribeQuery::DescribeQuery(PtrTo<TableExpr> expr) : Query{expr}\n-{\n-}\n-\n-ASTPtr DescribeQuery::convertToOld() const\n-{\n-    auto query = std::make_shared<ASTDescribeQuery>();\n-\n-    query->table_expression = get(EXPR)->convertToOld();\n-\n-    return query;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitDescribeStmt(ClickHouseParser::DescribeStmtContext *ctx)\n-{\n-    return std::make_shared<DescribeQuery>(visit(ctx->tableExpr()).as<PtrTo<TableExpr>>());\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/DescribeQuery.h b/src/Parsers/New/AST/DescribeQuery.h\ndeleted file mode 100644\nindex e7323476a439..000000000000\n--- a/src/Parsers/New/AST/DescribeQuery.h\n+++ /dev/null\n@@ -1,27 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/Query.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-// TODO: rewrite to\n-//       `SELECT name, type, default_type, default_expression, comment, codec_expression, ttl_expression FROM system.columns\n-//        WHERE database=db AND table=table`\n-\n-class DescribeQuery : public Query\n-{\n-    public:\n-        explicit DescribeQuery(PtrTo<TableExpr> expr);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            EXPR = 0,\n-        };\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/DropQuery.cpp b/src/Parsers/New/AST/DropQuery.cpp\ndeleted file mode 100644\nindex 59a417a6fa94..000000000000\n--- a/src/Parsers/New/AST/DropQuery.cpp\n+++ /dev/null\n@@ -1,126 +0,0 @@\n-#include <Parsers/New/AST/DropQuery.h>\n-\n-#include <Parsers/New/AST/Identifier.h>\n-\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-#include <Parsers/ASTDropQuery.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-// static\n-PtrTo<DropQuery>\n-DropQuery::createDropDatabase(bool detach, bool if_exists, PtrTo<DatabaseIdentifier> identifier, PtrTo<ClusterClause> cluster)\n-{\n-    auto query = PtrTo<DropQuery>(new DropQuery(cluster, QueryType::DATABASE, {identifier}));\n-    query->detach = detach;\n-    query->if_exists = if_exists;\n-    return query;\n-}\n-\n-// static\n-PtrTo<DropQuery>\n-DropQuery::createDropDictionary(bool detach, bool if_exists, PtrTo<TableIdentifier> identifier, PtrTo<ClusterClause> cluster)\n-{\n-    auto query = PtrTo<DropQuery>(new DropQuery(cluster, QueryType::DICTIONARY, {identifier}));\n-    query->detach = detach;\n-    query->if_exists = if_exists;\n-    return query;\n-}\n-\n-// static\n-PtrTo<DropQuery>\n-DropQuery::createDropTable(bool detach, bool if_exists, bool temporary, PtrTo<TableIdentifier> identifier, PtrTo<ClusterClause> cluster)\n-{\n-    auto query = PtrTo<DropQuery>(new DropQuery(cluster, QueryType::TABLE, {identifier}));\n-    query->detach = detach;\n-    query->if_exists = if_exists;\n-    query->temporary = temporary;\n-    return query;\n-}\n-\n-// static\n-PtrTo<DropQuery>\n-DropQuery::createDropView(bool detach, bool if_exists, PtrTo<TableIdentifier> identifier, PtrTo<ClusterClause> cluster)\n-{\n-    auto query = PtrTo<DropQuery>(new DropQuery(cluster, QueryType::VIEW, {identifier}));\n-    query->detach = detach;\n-    query->if_exists = if_exists;\n-    return query;\n-}\n-\n-DropQuery::DropQuery(PtrTo<ClusterClause> cluster, QueryType type, PtrList exprs) : DDLQuery(cluster, exprs), query_type(type)\n-{\n-}\n-\n-ASTPtr DropQuery::convertToOld() const\n-{\n-    auto query = std::make_shared<ASTDropQuery>();\n-\n-    query->kind = detach ? ASTDropQuery::Detach : ASTDropQuery::Drop;\n-    query->if_exists = if_exists;\n-    query->temporary = temporary;\n-    query->cluster = cluster_name;\n-\n-    // TODO: refactor |ASTQueryWithTableAndOutput| to accept |ASTIdentifier|\n-    switch(query_type)\n-    {\n-        case QueryType::DATABASE:\n-            query->database = get<DatabaseIdentifier>(NAME)->getName();\n-            break;\n-        case QueryType::DICTIONARY:\n-            query->is_dictionary = true;\n-            query->table = get<TableIdentifier>(NAME)->getName();\n-            if (auto database = get<TableIdentifier>(NAME)->getDatabase())\n-                query->database = database->getName();\n-            break;\n-        case QueryType::TABLE:\n-        {\n-            query->table = get<TableIdentifier>(NAME)->getName();\n-            if (auto database = get<TableIdentifier>(NAME)->getDatabase())\n-                query->database = database->getName();\n-            break;\n-        }\n-        case QueryType::VIEW:\n-        {\n-            query->is_view = true;\n-            query->table = get<TableIdentifier>(NAME)->getName();\n-            if (auto database = get<TableIdentifier>(NAME)->getDatabase())\n-                query->database = database->getName();\n-            break;\n-        }\n-    }\n-\n-    convertToOldPartially(query);\n-\n-    return query;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitDropDatabaseStmt(ClickHouseParser::DropDatabaseStmtContext *ctx)\n-{\n-    auto cluster = ctx->clusterClause() ? visit(ctx->clusterClause()).as<PtrTo<ClusterClause>>() : nullptr;\n-    return DropQuery::createDropDatabase(!!ctx->DETACH(), !!ctx->EXISTS(), visit(ctx->databaseIdentifier()), cluster);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitDropTableStmt(ClickHouseParser::DropTableStmtContext *ctx)\n-{\n-    auto cluster = ctx->clusterClause() ? visit(ctx->clusterClause()).as<PtrTo<ClusterClause>>() : nullptr;\n-    if (ctx->TABLE())\n-        return DropQuery::createDropTable(!!ctx->DETACH(), !!ctx->EXISTS(), !!ctx->TEMPORARY(), visit(ctx->tableIdentifier()), cluster);\n-    if (ctx->DICTIONARY())\n-        return DropQuery::createDropDictionary(!!ctx->DETACH(), !!ctx->EXISTS(), visit(ctx->tableIdentifier()), cluster);\n-    if (ctx->VIEW())\n-        return DropQuery::createDropView(!!ctx->DETACH(), !!ctx->EXISTS(), visit(ctx->tableIdentifier()), cluster);\n-    __builtin_unreachable();\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/DropQuery.h b/src/Parsers/New/AST/DropQuery.h\ndeleted file mode 100644\nindex cc70561e90f4..000000000000\n--- a/src/Parsers/New/AST/DropQuery.h\n+++ /dev/null\n@@ -1,46 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/DDLQuery.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class DropQuery : public DDLQuery\n-{\n-    public:\n-        static PtrTo<DropQuery>\n-        createDropDatabase(bool detach, bool if_exists, PtrTo<DatabaseIdentifier> identifier, PtrTo<ClusterClause> cluster);\n-        static PtrTo<DropQuery>\n-        createDropTable(bool detach, bool if_exists, bool temporary, PtrTo<TableIdentifier> identifier, PtrTo<ClusterClause> cluster);\n-        static PtrTo<DropQuery>\n-        createDropDictionary(bool detach, bool if_exists, PtrTo<TableIdentifier> identifier, PtrTo<ClusterClause> cluster);\n-        static PtrTo<DropQuery>\n-        createDropView(bool detach, bool if_exists, PtrTo<TableIdentifier> identifier, PtrTo<ClusterClause> cluster);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            NAME = 0,\n-        };\n-\n-        enum class QueryType\n-        {\n-            DATABASE,\n-            DICTIONARY,\n-            TABLE,\n-            VIEW,\n-        };\n-\n-        const QueryType query_type;\n-\n-        bool detach = false;\n-        bool if_exists = false;\n-        bool temporary = false;\n-\n-        DropQuery(PtrTo<ClusterClause> cluster, QueryType type, PtrList exprs);\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/EngineExpr.cpp b/src/Parsers/New/AST/EngineExpr.cpp\ndeleted file mode 100644\nindex 7127882c49dc..000000000000\n--- a/src/Parsers/New/AST/EngineExpr.cpp\n+++ /dev/null\n@@ -1,199 +0,0 @@\n-#include <Parsers/New/AST/EngineExpr.h>\n-\n-#include <Parsers/ASTCreateQuery.h>\n-#include <Parsers/ASTFunction.h>\n-#include <Parsers/ASTTTLElement.h>\n-#include <Parsers/New/AST/ColumnExpr.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/AST/Literal.h>\n-#include <Parsers/New/AST/SelectUnionQuery.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-#include <Storages/DataDestinationType.h>\n-#include <Storages/TTLMode.h>\n-\n-\n-namespace DB::ErrorCodes\n-{\n-    extern const int UNEXPECTED_AST_STRUCTURE;\n-}\n-\n-namespace DB::AST\n-{\n-\n-EngineClause::EngineClause(PtrTo<EngineExpr> expr) : INode(MAX_INDEX)\n-{\n-    set(ENGINE, expr);\n-}\n-\n-void EngineClause::setOrderByClause(PtrTo<OrderByClause> clause)\n-{\n-    set(ORDER_BY, clause);\n-}\n-\n-void EngineClause::setPartitionByClause(PtrTo<PartitionByClause> clause)\n-{\n-    set(PARTITION_BY, clause);\n-}\n-\n-void EngineClause::setPrimaryKeyClause(PtrTo<PrimaryKeyClause> clause)\n-{\n-    set(PRIMARY_KEY, clause);\n-}\n-\n-void EngineClause::setSampleByClause(PtrTo<SampleByClause> clause)\n-{\n-    set(SAMPLE_BY, clause);\n-}\n-\n-void EngineClause::setTTLClause(PtrTo<TTLClause> clause)\n-{\n-    set(TTL, clause);\n-}\n-\n-void EngineClause::setSettingsClause(PtrTo<SettingsClause> clause)\n-{\n-    set(SETTINGS, clause);\n-}\n-\n-ASTPtr EngineClause::convertToOld() const\n-{\n-    auto storage = std::make_shared<ASTStorage>();\n-\n-    storage->set(storage->engine, get(ENGINE)->convertToOld());\n-    if (has(PARTITION_BY)) storage->set(storage->partition_by, get(PARTITION_BY)->convertToOld());\n-    if (has(PRIMARY_KEY)) storage->set(storage->primary_key, get(PRIMARY_KEY)->convertToOld());\n-    if (has(ORDER_BY))\n-    {\n-        /// XXX: old parser used very strange grammar for this case, instead of using OrderByElement's.\n-        auto expr_list = get(ORDER_BY)->convertToOld();\n-        if (expr_list->children.size() > 1)\n-            throw DB::Exception(ErrorCodes::UNEXPECTED_AST_STRUCTURE, \"Cannot convert multiple ORDER expression to old AST\");\n-        storage->set(storage->order_by, expr_list->children[0]->children[0]);\n-    }\n-    if (has(SAMPLE_BY)) storage->set(storage->sample_by, get(SAMPLE_BY)->convertToOld());\n-    if (has(TTL)) storage->set(storage->ttl_table, get(TTL)->convertToOld());\n-    if (has(SETTINGS))\n-    {\n-        storage->set(storage->settings, get(SETTINGS)->convertToOld());\n-        storage->settings->is_standalone = false;\n-    }\n-\n-    return storage;\n-}\n-\n-EngineExpr::EngineExpr(PtrTo<Identifier> identifier, PtrTo<ColumnExprList> args) : INode{identifier, args}\n-{\n-}\n-\n-ASTPtr EngineExpr::convertToOld() const\n-{\n-    auto expr = std::make_shared<ASTFunction>();\n-\n-    expr->name = get<Identifier>(NAME)->getName();\n-    expr->no_empty_args = true;\n-    if (has(ARGS))\n-    {\n-        expr->arguments = get(ARGS)->convertToOld();\n-        expr->children.push_back(expr->arguments);\n-    }\n-\n-    return expr;\n-}\n-\n-TTLExpr::TTLExpr(PtrTo<ColumnExpr> expr, TTLType type, PtrTo<StringLiteral> literal) : INode{expr, literal}, ttl_type(type)\n-{\n-}\n-\n-ASTPtr TTLExpr::convertToOld() const\n-{\n-    TTLMode mode = TTLMode::DELETE;\n-    DataDestinationType destination_type = DataDestinationType::DELETE;\n-    String destination_name;\n-\n-    switch(ttl_type)\n-    {\n-        case TTLType::DELETE:\n-            mode = TTLMode::DELETE;\n-            destination_type = DataDestinationType::DELETE;\n-            break;\n-        case TTLType::TO_DISK:\n-            mode = TTLMode::MOVE;\n-            destination_type = DataDestinationType::DISK;\n-            destination_name = get(TYPE)->convertToOld()->as<ASTLiteral>()->value.get<String>();\n-            break;\n-        case TTLType::TO_VOLUME:\n-            mode = TTLMode::MOVE;\n-            destination_type = DataDestinationType::VOLUME;\n-            destination_name = get(TYPE)->convertToOld()->as<ASTLiteral>()->value.get<String>();\n-            break;\n-    }\n-\n-    auto expr = std::make_shared<ASTTTLElement>(mode, destination_type, destination_name);\n-    expr->setTTL(get(EXPR)->convertToOld());\n-    return expr;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitEngineClause(ClickHouseParser::EngineClauseContext *ctx)\n-{\n-    auto clause = std::make_shared<EngineClause>(visit(ctx->engineExpr()).as<PtrTo<EngineExpr>>());\n-\n-    if (!ctx->orderByClause().empty()) clause->setOrderByClause(visit(ctx->orderByClause(0)));\n-    if (!ctx->partitionByClause().empty()) clause->setPartitionByClause(visit(ctx->partitionByClause(0)));\n-    if (!ctx->primaryKeyClause().empty()) clause->setPrimaryKeyClause(visit(ctx->primaryKeyClause(0)));\n-    if (!ctx->sampleByClause().empty()) clause->setSampleByClause(visit(ctx->sampleByClause(0)));\n-    if (!ctx->ttlClause().empty()) clause->setTTLClause(visit(ctx->ttlClause(0)));\n-    if (!ctx->settingsClause().empty()) clause->setSettingsClause(visit(ctx->settingsClause(0)));\n-\n-    return clause;\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitEngineExpr(ClickHouseParser::EngineExprContext *ctx)\n-{\n-    auto list = ctx->columnExprList() ? visit(ctx->columnExprList()).as<PtrTo<ColumnExprList>>() : nullptr;\n-    return std::make_shared<EngineExpr>(visit(ctx->identifierOrNull()), list);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitPartitionByClause(ClickHouseParser::PartitionByClauseContext *ctx)\n-{\n-    return std::make_shared<PartitionByClause>(visit(ctx->columnExpr()).as<PtrTo<ColumnExpr>>());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitPrimaryKeyClause(ClickHouseParser::PrimaryKeyClauseContext *ctx)\n-{\n-    return std::make_shared<PrimaryKeyClause>(visit(ctx->columnExpr()).as<PtrTo<ColumnExpr>>());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitSampleByClause(ClickHouseParser::SampleByClauseContext *ctx)\n-{\n-    return std::make_shared<SampleByClause>(visit(ctx->columnExpr()).as<PtrTo<ColumnExpr>>());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitTtlClause(ClickHouseParser::TtlClauseContext *ctx)\n-{\n-    auto list = std::make_shared<TTLExprList>();\n-    for (auto * expr : ctx->ttlExpr()) list->push(visit(expr));\n-    return std::make_shared<TTLClause>(list);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitTtlExpr(ClickHouseParser::TtlExprContext *ctx)\n-{\n-    TTLExpr::TTLType type;\n-    PtrTo<StringLiteral> literal;\n-\n-    if (ctx->DISK()) type = TTLExpr::TTLType::TO_DISK;\n-    else if (ctx->VOLUME()) type = TTLExpr::TTLType::TO_VOLUME;\n-    else type = TTLExpr::TTLType::DELETE;\n-\n-    if (ctx->STRING_LITERAL()) literal = Literal::createString(ctx->STRING_LITERAL());\n-\n-    return std::make_shared<TTLExpr>(visit(ctx->columnExpr()), type, literal);\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/EngineExpr.h b/src/Parsers/New/AST/EngineExpr.h\ndeleted file mode 100644\nindex 809b398d834d..000000000000\n--- a/src/Parsers/New/AST/EngineExpr.h\n+++ /dev/null\n@@ -1,85 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/INode.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-// Clauses\n-\n-using PartitionByClause = SimpleClause<ColumnExpr>;\n-\n-using SampleByClause = SimpleClause<ColumnExpr>;\n-\n-class EngineClause : public INode\n-{\n-    public:\n-        explicit EngineClause(PtrTo<EngineExpr> expr);\n-\n-        void setOrderByClause(PtrTo<OrderByClause> clause);\n-        void setPartitionByClause(PtrTo<PartitionByClause> clause);\n-        void setPrimaryKeyClause(PtrTo<PrimaryKeyClause> clause);\n-        void setSampleByClause(PtrTo<SampleByClause> clause);\n-        void setTTLClause(PtrTo<TTLClause> clause);\n-        void setSettingsClause(PtrTo<SettingsClause> clause);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            ENGINE = 0,    // EngineExpr\n-            ORDER_BY,      // OrderByClause (optional)\n-            PARTITION_BY,  // PartitionByClause (optional)\n-            PRIMARY_KEY,   // PrimaryKeyClause (optional)\n-            SAMPLE_BY,     // SampleByClause (optional)\n-            TTL,           // TTLClause (optional)\n-            SETTINGS,      // SettingsClause (optional)\n-\n-            MAX_INDEX,\n-        };\n-};\n-\n-// Expressions\n-\n-class EngineExpr : public INode\n-{\n-    public:\n-        EngineExpr(PtrTo<Identifier> identifier, PtrTo<ColumnExprList> args);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            NAME = 0,  // Identifier\n-            ARGS,      // ColumnExprList (optional)\n-        };\n-};\n-\n-class TTLExpr : public INode\n-{\n-    public:\n-        enum class TTLType\n-        {\n-            DELETE,\n-            TO_DISK,\n-            TO_VOLUME,\n-        };\n-\n-        TTLExpr(PtrTo<ColumnExpr> expr, TTLType type, PtrTo<StringLiteral> literal);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            EXPR = 0,  // ColumnExpr\n-            TYPE = 1,  // StringLiteral (optional)\n-        };\n-\n-        TTLType ttl_type;\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/ExistsQuery.cpp b/src/Parsers/New/AST/ExistsQuery.cpp\ndeleted file mode 100644\nindex d2b77319dcc3..000000000000\n--- a/src/Parsers/New/AST/ExistsQuery.cpp\n+++ /dev/null\n@@ -1,87 +0,0 @@\n-#include <Parsers/New/AST/ExistsQuery.h>\n-\n-#include <Interpreters/StorageID.h>\n-#include <Parsers/ASTIdentifier.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-#include <Parsers/TablePropertiesQueriesASTs.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-ExistsQuery::ExistsQuery(QueryType type, bool temporary_, PtrList exprs)\n-    : Query(exprs), query_type(type), temporary(temporary_)\n-{\n-}\n-\n-// static\n-PtrTo<ExistsQuery> ExistsQuery::createTable(QueryType type, bool temporary, PtrTo<TableIdentifier> identifier)\n-{\n-    return PtrTo<ExistsQuery>(new ExistsQuery(type, temporary, {identifier}));\n-}\n-\n-// static\n-PtrTo<ExistsQuery> ExistsQuery::createDatabase(PtrTo<DatabaseIdentifier> identifier)\n-{\n-    return PtrTo<ExistsQuery>(new ExistsQuery(QueryType::DATABASE, false, {identifier}));\n-}\n-\n-ASTPtr ExistsQuery::convertToOld() const\n-{\n-    std::shared_ptr<ASTQueryWithTableAndOutput> query;\n-\n-    switch(query_type)\n-    {\n-        case QueryType::DATABASE:\n-            query = std::make_shared<ASTExistsDatabaseQuery>();\n-            tryGetIdentifierNameInto(get<DatabaseIdentifier>(IDENTIFIER)->convertToOld(), query->database);\n-            return query;\n-\n-        case QueryType::DICTIONARY:\n-            query = std::make_shared<ASTExistsDictionaryQuery>();\n-            break;\n-        case QueryType::TABLE:\n-            query = std::make_shared<ASTExistsTableQuery>();\n-            break;\n-        case QueryType::VIEW:\n-            query = std::make_shared<ASTExistsViewQuery>();\n-            break;\n-    }\n-\n-    // FIXME: this won't work if table doesn't exist\n-    auto table_id = std::static_pointer_cast<ASTTableIdentifier>(get<TableIdentifier>(IDENTIFIER)->convertToOld());\n-    query->database = table_id->getDatabaseName();\n-    query->table = table_id->shortName();\n-    query->uuid = table_id->uuid;\n-    query->temporary = temporary;\n-\n-    return query;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitExistsTableStmt(ClickHouseParser::ExistsTableStmtContext *ctx)\n-{\n-    ExistsQuery::QueryType type;\n-    if (ctx->DICTIONARY())\n-        type = ExistsQuery::QueryType::DICTIONARY;\n-    else if (ctx->VIEW())\n-        type = ExistsQuery::QueryType::VIEW;\n-    else // Query 'EXISTS <table_name>' is interptered as 'EXISTS TABLE <table_name>'\n-        type = ExistsQuery::QueryType::TABLE;\n-\n-    return ExistsQuery::createTable(type, !!ctx->TEMPORARY(), visit(ctx->tableIdentifier()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitExistsDatabaseStmt(ClickHouseParser::ExistsDatabaseStmtContext *ctx)\n-{\n-    return ExistsQuery::createDatabase(visit(ctx->databaseIdentifier()));\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/ExistsQuery.h b/src/Parsers/New/AST/ExistsQuery.h\ndeleted file mode 100644\nindex 5afe076b580a..000000000000\n--- a/src/Parsers/New/AST/ExistsQuery.h\n+++ /dev/null\n@@ -1,37 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/Query.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class ExistsQuery : public Query\n-{\n-    public:\n-        enum class QueryType\n-        {\n-            DICTIONARY,\n-            TABLE,\n-            VIEW,\n-            DATABASE,\n-        };\n-\n-        static PtrTo<ExistsQuery> createTable(QueryType type, bool temporary, PtrTo<TableIdentifier> identifier);\n-        static PtrTo<ExistsQuery> createDatabase(PtrTo<DatabaseIdentifier> identifier);\n-\n-        ExistsQuery(QueryType type, bool temporary, PtrList exprs);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            IDENTIFIER = 0,  // DatabaseIdentifier or TableIdentifier\n-        };\n-\n-        const QueryType query_type;\n-        const bool temporary;\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/ExplainQuery.cpp b/src/Parsers/New/AST/ExplainQuery.cpp\ndeleted file mode 100644\nindex e6afd480f85a..000000000000\n--- a/src/Parsers/New/AST/ExplainQuery.cpp\n+++ /dev/null\n@@ -1,62 +0,0 @@\n-#include <Parsers/New/AST/ExplainQuery.h>\n-\n-#include <Parsers/ASTExplainQuery.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-// static\n-PtrTo<ExplainQuery> ExplainQuery::createExplainAST(PtrTo<Query> query)\n-{\n-    return PtrTo<ExplainQuery>(new ExplainQuery(QueryType::AST, {query}));\n-}\n-\n-// static\n-PtrTo<ExplainQuery> ExplainQuery::createExplainSyntax(PtrTo<Query> query)\n-{\n-    return PtrTo<ExplainQuery>(new ExplainQuery(QueryType::SYNTAX, {query}));\n-}\n-\n-ExplainQuery::ExplainQuery(QueryType type, PtrList exprs) : Query{exprs}, query_type(type)\n-{\n-}\n-\n-ASTPtr ExplainQuery::convertToOld() const\n-{\n-    ASTPtr query;\n-\n-    switch (query_type)\n-    {\n-        case QueryType::AST:\n-            query = std::make_shared<ASTExplainQuery>(ASTExplainQuery::ParsedAST);\n-            break;\n-        case QueryType::SYNTAX:\n-            query = std::make_shared<ASTExplainQuery>(ASTExplainQuery::AnalyzedSyntax);\n-            break;\n-    }\n-\n-    query->as<ASTExplainQuery>()->setExplainedQuery(get(QUERY)->convertToOld());\n-\n-    return query;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace DB::AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitExplainASTStmt(ClickHouseParser::ExplainASTStmtContext *ctx)\n-{\n-    return ExplainQuery::createExplainAST(visit(ctx->query()).as<PtrTo<Query>>());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitExplainSyntaxStmt(ClickHouseParser::ExplainSyntaxStmtContext *ctx)\n-{\n-    return ExplainQuery::createExplainSyntax(visit(ctx->query()).as<PtrTo<Query>>());\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/ExplainQuery.h b/src/Parsers/New/AST/ExplainQuery.h\ndeleted file mode 100644\nindex 53bc63e7fd5c..000000000000\n--- a/src/Parsers/New/AST/ExplainQuery.h\n+++ /dev/null\n@@ -1,34 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/Query.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class ExplainQuery : public Query\n-{\n-    public:\n-        static PtrTo<ExplainQuery> createExplainAST(PtrTo<Query> query);\n-        static PtrTo<ExplainQuery> createExplainSyntax(PtrTo<Query> query);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            QUERY = 0,  // Query\n-        };\n-\n-        enum class QueryType\n-        {\n-            AST,\n-            SYNTAX,\n-        };\n-\n-        const QueryType query_type;\n-\n-        ExplainQuery(QueryType type, PtrList exprs);\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/INode.h b/src/Parsers/New/AST/INode.h\ndeleted file mode 100644\nindex 68ad774e2183..000000000000\n--- a/src/Parsers/New/AST/INode.h\n+++ /dev/null\n@@ -1,103 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/fwd_decl.h>\n-\n-#include <common/demangle.h>\n-#include <Common/TypePromotion.h>\n-#include <Parsers/ASTExpressionList.h>\n-\n-#include <initializer_list>\n-#include <iostream>\n-\n-\n-namespace DB::AST\n-{\n-\n-class INode : public TypePromotion<INode>\n-{\n-    public:\n-        virtual ~INode() = default;\n-\n-        virtual ASTPtr convertToOld() const { return ASTPtr(); }\n-        virtual String toString() const { return {}; }\n-\n-        void dump() const { dump(0); }\n-\n-    protected:\n-        INode() = default;\n-        INode(std::initializer_list<Ptr> list) { children = list; }\n-        explicit INode(PtrList list) { children = list; }\n-        explicit INode(size_t size) { children.resize(size); }\n-\n-        void push(const Ptr& child) { children.push_back(child); }\n-        void set(size_t i, const Ptr& child) { children[i] = child; }\n-        bool has(size_t i) const { return i < children.size() && children[i]; }\n-        const Ptr & get(size_t i) const { return children[i]; }\n-\n-        template <class ChildType>\n-        bool has(size_t i) const { return has(i) && children[i]->as<ChildType>(); }\n-\n-        template <class ChildType>\n-        ChildType * get(size_t i) const { return children[i]->template as<ChildType>(); }\n-\n-        auto begin() const { return children.cbegin(); }\n-        auto end() const { return children.cend(); }\n-        auto size() const { return children.size(); }\n-\n-    private:\n-        PtrList children;  // any child potentially may point to |nullptr|\n-\n-        void dump(int indentation) const\n-        {\n-            for (auto i = 0; i < indentation; ++i) std::cout << \" \";\n-            std::cout << \"\u2b78 \" << demangle(typeid(*this).name()) << \" (\" << dumpInfo() << \")\" << std::endl;\n-            for (const auto & child : children) if (child) child->dump(indentation + 1);\n-        }\n-\n-        virtual String dumpInfo() const { return \"\"; }\n-};\n-\n-template <class T, char Separator>\n-class List : public INode {\n-    public:\n-        List() = default;\n-        List(std::initializer_list<PtrTo<T>> list)\n-        {\n-            for (const auto & i : list) push(i);\n-        }\n-\n-        using INode::begin;\n-        using INode::end;\n-        using INode::size;\n-\n-        void push(const PtrTo<T> & node) { INode::push(node); }\n-\n-        ASTPtr convertToOld() const override\n-        {\n-            auto list = std::make_shared<ASTExpressionList>(Separator);\n-            for (const auto & child : *this) list->children.emplace_back(child->convertToOld());\n-            return list;\n-        }\n-\n-        String toString() const override\n-        {\n-            if (!size()) return {};\n-\n-            auto string = (*begin())->toString();\n-\n-            for (auto next = ++begin(); next != end(); ++next)\n-                string += String(1, Separator) + \" \" + (*next)->toString();\n-\n-            return string;\n-        }\n-};\n-\n-template <class T>\n-class SimpleClause : public INode\n-{\n-    public:\n-        explicit SimpleClause(PtrTo<T> expr) : INode{expr} {}\n-        ASTPtr convertToOld() const override { return get(0)->convertToOld(); }\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/Identifier.cpp b/src/Parsers/New/AST/Identifier.cpp\ndeleted file mode 100644\nindex 17d4cfe2b2f1..000000000000\n--- a/src/Parsers/New/AST/Identifier.cpp\n+++ /dev/null\n@@ -1,174 +0,0 @@\n-#include <Parsers/New/AST/Identifier.h>\n-\n-#include <IO/ReadHelpers.h>\n-#include <Parsers/ASTIdentifier.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-Identifier::Identifier(const String & name_) : name(name_)\n-{\n-    if (name.front() == '`' || name.front() == '\"')\n-    {\n-        String s;\n-        ReadBufferFromMemory in(name.data(), name.size());\n-\n-        if (name.front() == '`')\n-            readBackQuotedStringWithSQLStyle(s, in);\n-        else\n-            readDoubleQuotedStringWithSQLStyle(s, in);\n-\n-        assert(in.count() == name.size());\n-        name = s;\n-    }\n-}\n-\n-Identifier::Identifier(const String & name_, const String & nested_name) : name(name_ + \".\" + nested_name)\n-{\n-}\n-\n-ASTPtr Identifier::convertToOld() const\n-{\n-    return std::make_shared<ASTIdentifier>(getQualifiedName());\n-}\n-\n-String Identifier::toString() const\n-{\n-    return getQualifiedName();\n-}\n-\n-DatabaseIdentifier::DatabaseIdentifier(PtrTo<Identifier> name) : Identifier(*name)\n-{\n-}\n-\n-TableIdentifier::TableIdentifier(PtrTo<DatabaseIdentifier> database, PtrTo<Identifier> name) : Identifier(*name), db(database)\n-{\n-}\n-\n-void TableIdentifier::makeCompound() const\n-{\n-    if (db)\n-    {\n-        name = db->getName();\n-        db.reset();\n-    }\n-}\n-\n-ASTPtr TableIdentifier::convertToOld() const\n-{\n-    if (db) return std::make_shared<ASTTableIdentifier>(db->getName(), getName());\n-    else    return std::make_shared<ASTTableIdentifier>(getName());\n-}\n-\n-ColumnIdentifier::ColumnIdentifier(PtrTo<TableIdentifier> table_, PtrTo<Identifier> name) : Identifier(name->getName()), table(table_)\n-{\n-}\n-\n-void ColumnIdentifier::makeCompound() const\n-{\n-    if (table)\n-    {\n-        name = table->getName() + \".\" + getName();\n-        if (table->getDatabase()) table->makeCompound();\n-        else table.reset();\n-    }\n-}\n-\n-ASTPtr ColumnIdentifier::convertToOld() const\n-{\n-    std::vector<String> parts;\n-\n-    if (table)\n-    {\n-        if (table->getDatabase()) parts.push_back(table->getDatabase()->getName());\n-        parts.push_back(table->getName());\n-    }\n-    parts.push_back(getName());\n-\n-    return std::make_shared<ASTIdentifier>(std::move(parts));\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitAlias(ClickHouseParser::AliasContext *ctx)\n-{\n-    if (ctx->IDENTIFIER()) return std::make_shared<Identifier>(ctx->IDENTIFIER()->getText());\n-    if (ctx->keywordForAlias()) return std::make_shared<Identifier>(ctx->keywordForAlias()->getText());\n-    __builtin_unreachable();\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnIdentifier(ClickHouseParser::ColumnIdentifierContext *ctx)\n-{\n-    auto table = ctx->tableIdentifier() ? visit(ctx->tableIdentifier()).as<PtrTo<TableIdentifier>>() : nullptr;\n-    return std::make_shared<ColumnIdentifier>(table, visit(ctx->nestedIdentifier()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitDatabaseIdentifier(ClickHouseParser::DatabaseIdentifierContext *ctx)\n-{\n-    return std::make_shared<DatabaseIdentifier>(visit(ctx->identifier()).as<PtrTo<Identifier>>());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitIdentifier(ClickHouseParser::IdentifierContext *ctx)\n-{\n-    if (ctx->IDENTIFIER()) return std::make_shared<Identifier>(ctx->IDENTIFIER()->getText());\n-    if (ctx->interval()) return std::make_shared<Identifier>(ctx->interval()->getText());\n-    if (ctx->keyword()) return std::make_shared<Identifier>(ctx->keyword()->getText());\n-    __builtin_unreachable();\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitIdentifierOrNull(ClickHouseParser::IdentifierOrNullContext *ctx)\n-{\n-    if (ctx->identifier()) return visit(ctx->identifier());\n-    if (ctx->NULL_SQL())\n-    {\n-        if (ctx->NULL_SQL()->getSymbol()->getText() == \"Null\") return std::make_shared<Identifier>(\"Null\");\n-        else {\n-            // TODO: raise error\n-        }\n-    }\n-    __builtin_unreachable();\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitInterval(ClickHouseParser::IntervalContext *)\n-{\n-    asm (\"\"); // prevent symbol removal\n-    __builtin_unreachable();\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitKeyword(ClickHouseParser::KeywordContext *)\n-{\n-    asm (\"\"); // prevent symbol removal\n-    __builtin_unreachable();\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitKeywordForAlias(ClickHouseParser::KeywordForAliasContext *)\n-{\n-    asm (\"\"); // prevent symbol removal\n-    __builtin_unreachable();\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitNestedIdentifier(ClickHouseParser::NestedIdentifierContext *ctx)\n-{\n-    if (ctx->identifier().size() == 2)\n-    {\n-        auto name1 = visit(ctx->identifier(0)).as<PtrTo<Identifier>>()->getName();\n-        auto name2 = visit(ctx->identifier(1)).as<PtrTo<Identifier>>()->getName();\n-        return std::make_shared<Identifier>(name1, name2);\n-    }\n-    else return visit(ctx->identifier(0));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitTableIdentifier(ClickHouseParser::TableIdentifierContext *ctx)\n-{\n-    auto database = ctx->databaseIdentifier() ? visit(ctx->databaseIdentifier()).as<PtrTo<DatabaseIdentifier>>() : nullptr;\n-    return std::make_shared<TableIdentifier>(database, visit(ctx->identifier()));\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/Identifier.h b/src/Parsers/New/AST/Identifier.h\ndeleted file mode 100644\nindex 3d3688c30ef8..000000000000\n--- a/src/Parsers/New/AST/Identifier.h\n+++ /dev/null\n@@ -1,66 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/INode.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class Identifier : public INode\n-{\n-    public:\n-        explicit Identifier(const String & name_);\n-        Identifier(const String & name_, const String & nested_name);\n-\n-        const auto & getName() const { return name; }\n-\n-        ASTPtr convertToOld() const override;\n-        String toString() const override;\n-\n-        virtual String getQualifiedName() const { return name; };\n-\n-    protected:\n-        mutable String name; // protected and non-const because identifiers may become `column.nested` from `table.column`\n-\n-        String dumpInfo() const override { return getQualifiedName(); }\n-};\n-\n-class DatabaseIdentifier : public Identifier\n-{\n-    public:\n-        explicit DatabaseIdentifier(PtrTo<Identifier> name);\n-};\n-\n-class TableIdentifier : public Identifier\n-{\n-    public:\n-        TableIdentifier(PtrTo<DatabaseIdentifier> database, PtrTo<Identifier> name);\n-\n-        auto getDatabase() const { return db; }\n-        void makeCompound() const;\n-\n-        String getQualifiedName() const override { return (db ? db->getQualifiedName() + \".\" : String()) + getName(); }\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        mutable PtrTo<DatabaseIdentifier> db;\n-};\n-\n-class ColumnIdentifier : public Identifier\n-{\n-    public:\n-        ColumnIdentifier(PtrTo<TableIdentifier> table, PtrTo<Identifier> name);\n-\n-        auto getTable() const { return table; }\n-        void makeCompound() const;\n-\n-        String getQualifiedName() const override { return (table ? table->getQualifiedName() + \".\" : String()) + getName(); }\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        mutable PtrTo<TableIdentifier> table;\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/InsertQuery.cpp b/src/Parsers/New/AST/InsertQuery.cpp\ndeleted file mode 100644\nindex 905748ba4414..000000000000\n--- a/src/Parsers/New/AST/InsertQuery.cpp\n+++ /dev/null\n@@ -1,125 +0,0 @@\n-#include <Parsers/New/AST/InsertQuery.h>\n-\n-#include <Parsers/ASTIdentifier.h>\n-#include <Parsers/ASTInsertQuery.h>\n-#include <Parsers/New/AST/ColumnExpr.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/AST/SelectUnionQuery.h>\n-#include <Parsers/New/AST/TableExpr.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-// static\n-PtrTo<DataClause> DataClause::createFormat(PtrTo<Identifier> identifier, size_t data_offset)\n-{\n-    PtrTo<DataClause> clause(new DataClause(ClauseType::FORMAT, {identifier}));\n-    clause->offset = data_offset;\n-    return clause;\n-}\n-\n-// static\n-PtrTo<DataClause> DataClause::createSelect(PtrTo<SelectUnionQuery> query)\n-{\n-    return PtrTo<DataClause>(new DataClause(ClauseType::SELECT, {query}));\n-}\n-\n-// static\n-PtrTo<DataClause> DataClause::createValues(size_t data_offset)\n-{\n-    PtrTo<DataClause> clause(new DataClause(ClauseType::VALUES, {}));\n-    clause->offset = data_offset;\n-    return clause;\n-}\n-\n-DataClause::DataClause(ClauseType type, PtrList exprs) : INode(exprs), clause_type(type)\n-{\n-}\n-\n-ASTPtr DataClause::convertToOld() const\n-{\n-    if (clause_type != ClauseType::SELECT) return {};\n-    return get(SUBQUERY)->convertToOld();\n-}\n-\n-// static\n-PtrTo<InsertQuery> InsertQuery::createTable(PtrTo<TableIdentifier> identifier, PtrTo<ColumnNameList> list, PtrTo<DataClause> clause)\n-{\n-    return PtrTo<InsertQuery>(new InsertQuery(QueryType::TABLE, {identifier, list, clause}));\n-}\n-\n-// static\n-PtrTo<InsertQuery> InsertQuery::createFunction(PtrTo<TableFunctionExpr> function, PtrTo<ColumnNameList> list, PtrTo<DataClause> clause)\n-{\n-    return PtrTo<InsertQuery>(new InsertQuery(QueryType::FUNCTION, {function, list, clause}));\n-}\n-\n-InsertQuery::InsertQuery(QueryType type, PtrList exprs) : Query(exprs), query_type(type)\n-{\n-}\n-\n-ASTPtr InsertQuery::convertToOld() const\n-{\n-    auto query = std::make_shared<ASTInsertQuery>();\n-\n-    switch(query_type)\n-    {\n-        case QueryType::FUNCTION:\n-            query->table_function = get(FUNCTION)->convertToOld();\n-            break;\n-        case QueryType::TABLE:\n-            query->table_id = get(IDENTIFIER)->convertToOld()->as<ASTTableIdentifier>()->getTableId();\n-            break;\n-    }\n-\n-    if (has(COLUMNS)) query->columns = get(COLUMNS)->convertToOld();\n-    if (get<DataClause>(DATA)->getType() == DataClause::ClauseType::SELECT)\n-    {\n-        query->select = get(DATA)->convertToOld();\n-        query->children.push_back(query->select);\n-    }\n-\n-    return query;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitColumnsClause(ClickHouseParser::ColumnsClauseContext *ctx)\n-{\n-    auto list = std::make_shared<ColumnNameList>();\n-    for (auto * name : ctx->nestedIdentifier()) list->push(visit(name));\n-    return list;\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitDataClauseFormat(ClickHouseParser::DataClauseFormatContext *ctx)\n-{\n-    return DataClause::createFormat(visit(ctx->identifier()), ctx->getStop()->getStopIndex() + 1);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitDataClauseSelect(ClickHouseParser::DataClauseSelectContext *ctx)\n-{\n-    return DataClause::createSelect(visit(ctx->selectUnionStmt()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitDataClauseValues(ClickHouseParser::DataClauseValuesContext *ctx)\n-{\n-    return DataClause::createValues(ctx->getStop()->getStopIndex() + 1);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitInsertStmt(ClickHouseParser::InsertStmtContext *ctx)\n-{\n-    auto columns = ctx->columnsClause() ? visit(ctx->columnsClause()).as<PtrTo<ColumnNameList>>() : nullptr;\n-\n-    if (ctx->FUNCTION()) return InsertQuery::createFunction(visit(ctx->tableFunctionExpr()), columns, visit(ctx->dataClause()));\n-    if (ctx->tableIdentifier()) return InsertQuery::createTable(visit(ctx->tableIdentifier()), columns, visit(ctx->dataClause()));\n-    __builtin_unreachable();\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/InsertQuery.h b/src/Parsers/New/AST/InsertQuery.h\ndeleted file mode 100644\nindex e7543d6e8750..000000000000\n--- a/src/Parsers/New/AST/InsertQuery.h\n+++ /dev/null\n@@ -1,73 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/Query.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class DataClause : public INode\n-{\n-    public:\n-        enum class ClauseType\n-        {\n-            FORMAT,\n-            SELECT,\n-            VALUES,\n-        };\n-\n-        static PtrTo<DataClause> createFormat(PtrTo<Identifier> identifier, size_t data_offset);\n-        static PtrTo<DataClause> createSelect(PtrTo<SelectUnionQuery> query);\n-        static PtrTo<DataClause> createValues(size_t data_offset);\n-\n-        auto getType() const { return clause_type; }\n-        auto getOffset() const { return offset; }\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            FORMAT = 0,    // Identifier\n-            SUBQUERY = 0,  // SelectUnionQuery\n-        };\n-\n-        ClauseType clause_type;\n-        size_t offset = 0;\n-\n-        DataClause(ClauseType type, PtrList exprs);\n-};\n-\n-class InsertQuery : public Query\n-{\n-    public:\n-        static PtrTo<InsertQuery> createFunction(PtrTo<TableFunctionExpr> function, PtrTo<ColumnNameList> list, PtrTo<DataClause> clause);\n-        static PtrTo<InsertQuery> createTable(PtrTo<TableIdentifier> identifier, PtrTo<ColumnNameList> list, PtrTo<DataClause> clause);\n-\n-        bool hasData() const { return get<DataClause>(DATA)->getType() != DataClause::ClauseType::SELECT; }\n-        size_t getDataOffset() const { return get<DataClause>(DATA)->getOffset(); }\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            IDENTIFIER = 0,  // TableIdentifier\n-            FUNCTION = 0,    // TableFunctionExpr\n-            COLUMNS = 1,     // ColumnNameList\n-            DATA = 2,        // DataClause\n-        };\n-        enum class QueryType\n-        {\n-            FUNCTION,\n-            TABLE,\n-        };\n-\n-        QueryType query_type;\n-\n-        InsertQuery(QueryType type, PtrList exprs);\n-\n-        String dumpInfo() const override { return String(\"has_data=\") + (hasData() ? \"true\" : \"false\"); }\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/JoinExpr.cpp b/src/Parsers/New/AST/JoinExpr.cpp\ndeleted file mode 100644\nindex acbeae86897c..000000000000\n--- a/src/Parsers/New/AST/JoinExpr.cpp\n+++ /dev/null\n@@ -1,326 +0,0 @@\n-#include <Parsers/New/AST/JoinExpr.h>\n-\n-#include <Parsers/ASTExpressionList.h>\n-#include <Parsers/ASTTablesInSelectQuery.h>\n-#include <Parsers/New/AST/RatioExpr.h>\n-#include <Parsers/New/AST/TableExpr.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::ErrorCodes\n-{\n-    extern const int UNEXPECTED_AST_STRUCTURE;\n-}\n-\n-namespace DB::AST\n-{\n-\n-JoinConstraintClause::JoinConstraintClause(ConstraintType type_, PtrTo<ColumnExprList> list) : SimpleClause{list}, type(type_)\n-{\n-}\n-\n-SampleClause::SampleClause(PtrTo<RatioExpr> ratio, PtrTo<RatioExpr> offset) : INode{ratio, offset}\n-{\n-}\n-\n-ASTPtr SampleClause::convertToOld() const\n-{\n-    auto list = std::make_shared<ASTExpressionList>();\n-\n-    list->children.push_back(get(RATIO)->convertToOld());\n-    if (has(OFFSET)) list->children.push_back(get(OFFSET)->convertToOld());\n-\n-    return list;\n-}\n-\n-// static\n-PtrTo<JoinExpr> JoinExpr::createTableExpr(PtrTo<TableExpr> expr, PtrTo<SampleClause> clause, bool final)\n-{\n-    return PtrTo<JoinExpr>(new JoinExpr(JoinExpr::ExprType::TABLE, final, {expr, clause}));\n-}\n-\n-// static\n-PtrTo<JoinExpr> JoinExpr::createJoinOp(\n-    PtrTo<JoinExpr> left_expr, PtrTo<JoinExpr> right_expr, JoinOpType op, JoinOpMode mode, PtrTo<JoinConstraintClause> clause)\n-{\n-    return PtrTo<JoinExpr>(new JoinExpr(ExprType::JOIN_OP, op, mode, {left_expr, right_expr, clause}));\n-}\n-\n-JoinExpr::JoinExpr(JoinExpr::ExprType type, bool final_, PtrList exprs) : INode(exprs), expr_type(type), final(final_)\n-{\n-}\n-\n-JoinExpr::JoinExpr(JoinExpr::ExprType type, JoinExpr::JoinOpType op, JoinExpr::JoinOpMode mode, PtrList exprs)\n-    : INode(exprs), expr_type(type), op_type(op), op_mode(mode)\n-{\n-}\n-\n-ASTPtr JoinExpr::convertToOld() const\n-{\n-    /** The sole convertible chain of Join's may look like:\n-     *\n-     *      \u2026 FROM table1 JOIN table2 ON SMTH JOIN table3 ON SMTH JOIN \u2026\n-     *\n-     *  Since Join is a left-associative operation then the tree will look like:\n-     *\n-     *                JoinExpr\n-     *               /       \\\n-     *           JoinExpr     \u2026\n-     *          /       \\\n-     *      JoinExpr   table3\n-     *     /       \\\n-     *  table1    table2\n-     *\n-     *  To linearize this tree we have to start from the top-most expression.\n-     */\n-\n-    auto list = std::make_shared<ASTExpressionList>();\n-\n-    if (expr_type == ExprType::TABLE)\n-    {\n-        auto element = std::make_shared<ASTTablesInSelectQueryElement>();\n-        element->children.emplace_back(get(TABLE)->convertToOld());\n-        element->table_expression = element->children.back();\n-        element->table_expression->as<ASTTableExpression>()->final = final;\n-        if (has(SAMPLE))\n-        {\n-            auto old_list = get(SAMPLE)->convertToOld();\n-\n-            element->table_expression->as<ASTTableExpression>()->sample_size = old_list->children[0];\n-            element->table_expression->children.push_back(element->table_expression->as<ASTTableExpression>()->sample_size);\n-\n-            if (old_list->children.size() > 1)\n-            {\n-                element->table_expression->as<ASTTableExpression>()->sample_offset = old_list->children[1];\n-                element->table_expression->children.push_back(element->table_expression->as<ASTTableExpression>()->sample_offset);\n-            }\n-        }\n-\n-        list->children.emplace_back(element);\n-    }\n-    else if (expr_type == ExprType::JOIN_OP)\n-    {\n-        if (get<JoinExpr>(RIGHT_EXPR)->expr_type != ExprType::TABLE)\n-            throw Exception(ErrorCodes::UNEXPECTED_AST_STRUCTURE, \"Cannot convert new tree-like JoinExpr to old AST\");\n-\n-        auto left = get(LEFT_EXPR)->convertToOld(), right = get(RIGHT_EXPR)->convertToOld();  // ASTExpressionList's\n-        list->children.insert(list->children.end(), left->children.begin(), left->children.end());  // Insert all the previously parsed left subtree\n-        list->children.emplace_back(right->children[0]);  // Insert only first (single) ASTTablesInSelectQueryElement which should contain only ASTTableExpression\n-\n-        auto element = std::make_shared<ASTTableJoin>();\n-        switch (op_mode)\n-        {\n-            case JoinOpMode::DEFAULT:\n-                element->locality = ASTTableJoin::Locality::Unspecified;\n-                break;\n-            case JoinOpMode::GLOBAL:\n-                element->locality = ASTTableJoin::Locality::Global;\n-                break;\n-            case JoinOpMode::LOCAL:\n-                element->locality = ASTTableJoin::Locality::Local;\n-                break;\n-        }\n-        switch (op_type)\n-        {\n-            case JoinOpType::CROSS:\n-                element->kind = ASTTableJoin::Kind::Cross;\n-                break;\n-            case JoinOpType::FULL:\n-                element->kind = ASTTableJoin::Kind::Full;\n-                break;\n-            case JoinOpType::FULL_ALL:\n-                element->kind = ASTTableJoin::Kind::Full;\n-                element->strictness = ASTTableJoin::Strictness::All;\n-                break;\n-            case JoinOpType::FULL_ANY:\n-                element->kind = ASTTableJoin::Kind::Full;\n-                element->strictness = ASTTableJoin::Strictness::Any;\n-                break;\n-            case JoinOpType::INNER:\n-                element->kind = ASTTableJoin::Kind::Inner;\n-                break;\n-            case JoinOpType::INNER_ALL:\n-                element->kind = ASTTableJoin::Kind::Inner;\n-                element->strictness = ASTTableJoin::Strictness::All;\n-                break;\n-            case JoinOpType::INNER_ANY:\n-                element->kind = ASTTableJoin::Kind::Inner;\n-                element->strictness = ASTTableJoin::Strictness::Any;\n-                break;\n-            case JoinOpType::INNER_ASOF:\n-                element->kind = ASTTableJoin::Kind::Inner;\n-                element->strictness = ASTTableJoin::Strictness::Asof;\n-                break;\n-            case JoinOpType::LEFT:\n-                element->kind = ASTTableJoin::Kind::Left;\n-                break;\n-            case JoinOpType::LEFT_ALL:\n-                element->kind = ASTTableJoin::Kind::Left;\n-                element->strictness = ASTTableJoin::Strictness::All;\n-                break;\n-            case JoinOpType::LEFT_ANTI:\n-                element->kind = ASTTableJoin::Kind::Left;\n-                element->strictness = ASTTableJoin::Strictness::Anti;\n-                break;\n-            case JoinOpType::LEFT_ANY:\n-                element->kind = ASTTableJoin::Kind::Left;\n-                element->strictness = ASTTableJoin::Strictness::Any;\n-                break;\n-            case JoinOpType::LEFT_ASOF:\n-                element->kind = ASTTableJoin::Kind::Left;\n-                element->strictness = ASTTableJoin::Strictness::Asof;\n-                break;\n-            case JoinOpType::LEFT_SEMI:\n-                element->kind = ASTTableJoin::Kind::Left;\n-                element->strictness = ASTTableJoin::Strictness::Semi;\n-                break;\n-            case JoinOpType::RIGHT:\n-                element->kind = ASTTableJoin::Kind::Right;\n-                break;\n-            case JoinOpType::RIGHT_ANTI:\n-                element->kind = ASTTableJoin::Kind::Right;\n-                element->strictness = ASTTableJoin::Strictness::Anti;\n-                break;\n-            case JoinOpType::RIGHT_ALL:\n-                element->kind = ASTTableJoin::Kind::Right;\n-                element->strictness = ASTTableJoin::Strictness::All;\n-                break;\n-            case JoinOpType::RIGHT_ANY:\n-                element->kind = ASTTableJoin::Kind::Right;\n-                element->strictness = ASTTableJoin::Strictness::Any;\n-                break;\n-            case JoinOpType::RIGHT_ASOF:\n-                element->kind = ASTTableJoin::Kind::Right;\n-                element->strictness = ASTTableJoin::Strictness::Asof;\n-                break;\n-            case JoinOpType::RIGHT_SEMI:\n-                element->kind = ASTTableJoin::Kind::Right;\n-                element->strictness = ASTTableJoin::Strictness::Semi;\n-                break;\n-        }\n-\n-        if (has(CONSTRAINT))\n-        {\n-            const auto * constraint = get<JoinConstraintClause>(CONSTRAINT);\n-            switch(constraint->getType())\n-            {\n-                case JoinConstraintClause::ConstraintType::ON:\n-                    element->on_expression = constraint->convertToOld();\n-                    if (element->on_expression->children.size() > 1)\n-                        throw Exception(ErrorCodes::UNEXPECTED_AST_STRUCTURE, \"Cannot convert JoinExpr with more than one ON expression\");\n-                    element->on_expression = element->on_expression->children[0];\n-                    element->children.push_back(element->on_expression);\n-                    break;\n-                case JoinConstraintClause::ConstraintType::USING:\n-                    element->using_expression_list = constraint->convertToOld();\n-                    element->children.push_back(element->using_expression_list);\n-                    break;\n-            }\n-        }\n-\n-        list->children.back()->children.emplace_back(element);\n-        list->children.back()->as<ASTTablesInSelectQueryElement>()->table_join = element;\n-    }\n-\n-    return list;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitJoinConstraintClause(ClickHouseParser::JoinConstraintClauseContext *ctx)\n-{\n-    return std::make_shared<JoinConstraintClause>(\n-        ctx->ON() ? JoinConstraintClause::ConstraintType::ON : JoinConstraintClause::ConstraintType::USING,\n-        visit(ctx->columnExprList()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitJoinExprCrossOp(ClickHouseParser::JoinExprCrossOpContext *ctx)\n-{\n-    auto [op, mode] = std::pair<JoinExpr::JoinOpType, JoinExpr::JoinOpMode>(visit(ctx->joinOpCross()));\n-\n-    return JoinExpr::createJoinOp(visit(ctx->joinExpr(0)), visit(ctx->joinExpr(1)), op, mode, nullptr);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitJoinExprOp(ClickHouseParser::JoinExprOpContext *ctx)\n-{\n-    auto mode = JoinExpr::JoinOpMode::DEFAULT;\n-    auto op = ctx->joinOp() ? visit(ctx->joinOp()).as<JoinExpr::JoinOpType>() : JoinExpr::JoinOpType::INNER;\n-\n-    if (ctx->GLOBAL()) mode = JoinExpr::JoinOpMode::GLOBAL;\n-    else if (ctx->LOCAL()) mode = JoinExpr::JoinOpMode::LOCAL;\n-\n-    return JoinExpr::createJoinOp(visit(ctx->joinExpr(0)), visit(ctx->joinExpr(1)), op, mode, visit(ctx->joinConstraintClause()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitJoinExprParens(ClickHouseParser::JoinExprParensContext *ctx)\n-{\n-    return visit(ctx->joinExpr());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitJoinExprTable(ClickHouseParser::JoinExprTableContext *ctx)\n-{\n-    auto sample = ctx->sampleClause() ? visit(ctx->sampleClause()).as<PtrTo<SampleClause>>() : nullptr;\n-    return JoinExpr::createTableExpr(visit(ctx->tableExpr()), sample, !!ctx->FINAL());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitJoinOpCross(ClickHouseParser::JoinOpCrossContext *ctx)\n-{\n-    std::pair<JoinExpr::JoinOpType, JoinExpr::JoinOpMode> op{\n-        JoinExpr::JoinOpType::CROSS, JoinExpr::JoinOpMode::DEFAULT};\n-\n-    if (ctx->GLOBAL()) op.second = JoinExpr::JoinOpMode::GLOBAL;\n-    else if (ctx->LOCAL()) op.second = JoinExpr::JoinOpMode::LOCAL;\n-\n-    return op;\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitJoinOpFull(ClickHouseParser::JoinOpFullContext *ctx)\n-{\n-    if (ctx->ALL()) return JoinExpr::JoinOpType::FULL_ALL;\n-    if (ctx->ANY()) return JoinExpr::JoinOpType::FULL_ANY;\n-    return JoinExpr::JoinOpType::FULL;\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitJoinOpInner(ClickHouseParser::JoinOpInnerContext *ctx)\n-{\n-    if (ctx->ALL()) return JoinExpr::JoinOpType::INNER_ALL;\n-    if (ctx->ANY()) return JoinExpr::JoinOpType::INNER_ANY;\n-    if (ctx->ASOF()) return JoinExpr::JoinOpType::INNER_ASOF;\n-    return JoinExpr::JoinOpType::INNER;\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitJoinOpLeftRight(ClickHouseParser::JoinOpLeftRightContext *ctx)\n-{\n-    if (ctx->LEFT())\n-    {\n-        if (ctx->SEMI()) return JoinExpr::JoinOpType::LEFT_SEMI;\n-        if (ctx->ALL()) return JoinExpr::JoinOpType::LEFT_ALL;\n-        if (ctx->ANTI()) return JoinExpr::JoinOpType::LEFT_ANTI;\n-        if (ctx->ANY()) return JoinExpr::JoinOpType::LEFT_ANY;\n-        if (ctx->ASOF()) return JoinExpr::JoinOpType::LEFT_ASOF;\n-        return JoinExpr::JoinOpType::LEFT;\n-    }\n-    else if (ctx->RIGHT())\n-    {\n-        if (ctx->SEMI()) return JoinExpr::JoinOpType::RIGHT_SEMI;\n-        if (ctx->ALL()) return JoinExpr::JoinOpType::RIGHT_ALL;\n-        if (ctx->ANTI()) return JoinExpr::JoinOpType::RIGHT_ANTI;\n-        if (ctx->ANY()) return JoinExpr::JoinOpType::RIGHT_ANY;\n-        if (ctx->ASOF()) return JoinExpr::JoinOpType::RIGHT_ASOF;\n-        return JoinExpr::JoinOpType::RIGHT;\n-    }\n-    __builtin_unreachable();\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitSampleClause(ClickHouseParser::SampleClauseContext *ctx)\n-{\n-    auto offset = ctx->ratioExpr().size() == 2 ? visit(ctx->ratioExpr(1)).as<PtrTo<RatioExpr>>() : nullptr;\n-    return std::make_shared<SampleClause>(visit(ctx->ratioExpr(0)), offset);\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/JoinExpr.h b/src/Parsers/New/AST/JoinExpr.h\ndeleted file mode 100644\nindex 08117d6b6e80..000000000000\n--- a/src/Parsers/New/AST/JoinExpr.h\n+++ /dev/null\n@@ -1,103 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/INode.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class JoinConstraintClause : public SimpleClause<ColumnExprList>\n-{\n-    public:\n-        enum class ConstraintType\n-        {\n-            ON,\n-            USING,\n-        };\n-\n-        JoinConstraintClause(ConstraintType type, PtrTo<ColumnExprList> list);\n-\n-        auto getType() const { return type; }\n-\n-    private:\n-        const ConstraintType type;\n-};\n-\n-class SampleClause : public INode\n-{\n-    public:\n-        SampleClause(PtrTo<RatioExpr> ratio_, PtrTo<RatioExpr> offset_);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            RATIO = 0,   // RatioExpr\n-            OFFSET = 1,  // RatioExpr (optional)\n-        };\n-};\n-\n-class JoinExpr : public INode\n-{\n-    public:\n-        enum class JoinOpType\n-        {\n-            INNER,\n-            INNER_ALL,\n-            INNER_ANY,\n-            INNER_ASOF,\n-            LEFT,\n-            LEFT_SEMI,\n-            LEFT_ALL,\n-            LEFT_ANTI,\n-            LEFT_ANY,\n-            LEFT_ASOF,\n-            RIGHT,\n-            RIGHT_SEMI,\n-            RIGHT_ALL,\n-            RIGHT_ANTI,\n-            RIGHT_ANY,\n-            RIGHT_ASOF,\n-            FULL,\n-            FULL_ALL,\n-            FULL_ANY,\n-            CROSS,\n-        };\n-        enum class JoinOpMode\n-        {\n-            DEFAULT,  // actual mode depends on setting's 'distributed_product_mode' value\n-            GLOBAL,\n-            LOCAL,\n-        };\n-\n-        static PtrTo<JoinExpr> createTableExpr(PtrTo<TableExpr> expr, PtrTo<SampleClause> clause, bool final);\n-        static PtrTo<JoinExpr> createJoinOp(PtrTo<JoinExpr> left_expr, PtrTo<JoinExpr> right_expr, JoinOpType op, JoinOpMode mode, PtrTo<JoinConstraintClause> clause);\n-\n-        ASTPtr convertToOld() const override;  // returns topologically sorted elements as ASTExpressionList\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            TABLE = 0,       // TableExpr\n-            SAMPLE = 1,      // SampleClause (optional)\n-            LEFT_EXPR = 0,   // JoinExpr\n-            RIGHT_EXPR = 1,  // JoinExpr\n-            CONSTRAINT = 2,  // JoinConstraintClause\n-        };\n-        enum class ExprType\n-        {\n-            TABLE,\n-            JOIN_OP,\n-        };\n-\n-        const ExprType expr_type;\n-        const JoinOpType op_type = JoinOpType::INNER;\n-        const JoinOpMode op_mode = JoinOpMode::DEFAULT;\n-        const bool final = false;\n-\n-        JoinExpr(ExprType type, bool final, PtrList exprs);\n-        JoinExpr(ExprType type, JoinOpType op, JoinOpMode mode, PtrList exprs);\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/KillQuery.cpp b/src/Parsers/New/AST/KillQuery.cpp\ndeleted file mode 100644\nindex 615b5ec3fe32..000000000000\n--- a/src/Parsers/New/AST/KillQuery.cpp\n+++ /dev/null\n@@ -1,56 +0,0 @@\n-#include <Parsers/New/AST/KillQuery.h>\n-\n-#include <Parsers/ASTKillQueryQuery.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-// static\n-PtrTo<KillQuery> KillQuery::createMutation(PtrTo<ClusterClause> cluster, bool sync, bool test, PtrTo<WhereClause> where)\n-{\n-    PtrTo<KillQuery> query(new KillQuery(cluster, QueryType::MUTATION, {where}));\n-    query->sync = sync;\n-    query->test = test;\n-    return query;\n-}\n-\n-KillQuery::KillQuery(PtrTo<ClusterClause> cluster, QueryType type, PtrList exprs) : DDLQuery(cluster, exprs), query_type(type)\n-{\n-}\n-\n-ASTPtr KillQuery::convertToOld() const\n-{\n-    auto query = std::make_shared<ASTKillQueryQuery>();\n-\n-    query->cluster = cluster_name;\n-\n-    switch(query_type)\n-    {\n-        case QueryType::MUTATION:\n-            query->type = ASTKillQueryQuery::Type::Mutation;\n-            query->sync = sync;\n-            query->test = test;\n-            query->where_expression = get(WHERE)->convertToOld();\n-            query->children.push_back(query->where_expression);\n-            break;\n-    }\n-\n-    return query;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitKillMutationStmt(ClickHouseParser::KillMutationStmtContext * ctx)\n-{\n-    auto cluster = ctx->clusterClause() ? visit(ctx->clusterClause()).as<PtrTo<ClusterClause>>() : nullptr;\n-    return KillQuery::createMutation(cluster, !!ctx->SYNC(), !!ctx->TEST(), visit(ctx->whereClause()));\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/KillQuery.h b/src/Parsers/New/AST/KillQuery.h\ndeleted file mode 100644\nindex 61a73599cec3..000000000000\n--- a/src/Parsers/New/AST/KillQuery.h\n+++ /dev/null\n@@ -1,33 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/DDLQuery.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class KillQuery : public DDLQuery\n-{\n-    public:\n-        static PtrTo<KillQuery> createMutation(PtrTo<ClusterClause> cluster, bool sync, bool test, PtrTo<WhereClause> where);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            WHERE = 0,  // WhereClause\n-        };\n-\n-        enum class QueryType\n-        {\n-            MUTATION,\n-        };\n-\n-        const QueryType query_type;\n-        bool sync = false, test = false;\n-\n-        KillQuery(PtrTo<ClusterClause> cluster, QueryType type, PtrList exprs);\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/LimitExpr.cpp b/src/Parsers/New/AST/LimitExpr.cpp\ndeleted file mode 100644\nindex b41c56d21f9f..000000000000\n--- a/src/Parsers/New/AST/LimitExpr.cpp\n+++ /dev/null\n@@ -1,39 +0,0 @@\n-#include <Parsers/New/AST/LimitExpr.h>\n-\n-#include <Parsers/New/AST/ColumnExpr.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-LimitExpr::LimitExpr(PtrTo<ColumnExpr> limit, PtrTo<ColumnExpr> offset) : INode{limit, offset}\n-{\n-}\n-\n-ASTPtr LimitExpr::convertToOld() const\n-{\n-    auto list = std::make_shared<ASTExpressionList>();\n-\n-    if (has(OFFSET)) list->children.push_back(get(OFFSET)->convertToOld());\n-    list->children.push_back(get(LIMIT)->convertToOld());\n-\n-    return list;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitLimitExpr(ClickHouseParser::LimitExprContext *ctx)\n-{\n-    if (ctx->columnExpr().size() == 2)\n-        return std::make_shared<LimitExpr>(visit(ctx->columnExpr(0)), visit(ctx->columnExpr(1)));\n-    else\n-        return std::make_shared<LimitExpr>(visit(ctx->columnExpr(0)).as<PtrTo<ColumnExpr>>());\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/LimitExpr.h b/src/Parsers/New/AST/LimitExpr.h\ndeleted file mode 100644\nindex 986806c2bd98..000000000000\n--- a/src/Parsers/New/AST/LimitExpr.h\n+++ /dev/null\n@@ -1,24 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/INode.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class LimitExpr : public INode\n-{\n-    public:\n-        explicit LimitExpr(PtrTo<ColumnExpr> limit, PtrTo<ColumnExpr> offset = nullptr);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            LIMIT = 0,   // ColumnExpr\n-            OFFSET = 1,  // ColumnExpr (optional)\n-        };\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/Literal.cpp b/src/Parsers/New/AST/Literal.cpp\ndeleted file mode 100644\nindex 30aacd3d590a..000000000000\n--- a/src/Parsers/New/AST/Literal.cpp\n+++ /dev/null\n@@ -1,222 +0,0 @@\n-#include <Parsers/New/AST/Literal.h>\n-\n-#include <IO/ReadHelpers.h>\n-#include <IO/WriteBufferFromString.h>\n-#include <IO/WriteHelpers.h>\n-#include <Parsers/ASTLiteral.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-// static\n-PtrTo<Literal> Literal::createNull()\n-{\n-    return PtrTo<Literal>(new Literal(LiteralType::NULL_LITERAL, String()));\n-}\n-\n-// static\n-PtrTo<NumberLiteral> Literal::createNumber(antlr4::tree::TerminalNode * literal, bool negative)\n-{\n-    auto number = std::make_shared<NumberLiteral>(literal);\n-    if (negative) number->makeNegative();\n-    return number;\n-}\n-\n-// static\n-PtrTo<NumberLiteral> Literal::createNumber(const String & literal)\n-{\n-    bool has_minus = literal[0] == '-';\n-    auto number = std::make_shared<NumberLiteral>(has_minus ? literal.substr(1) : literal);\n-    if (has_minus) number->makeNegative();\n-    return number;\n-}\n-\n-// static\n-PtrTo<StringLiteral> Literal::createString(antlr4::tree::TerminalNode * literal)\n-{\n-    return std::make_shared<StringLiteral>(literal);\n-}\n-\n-// static\n-PtrTo<StringLiteral> Literal::createString(const String & literal)\n-{\n-    return std::make_shared<StringLiteral>(literal);\n-}\n-\n-Literal::Literal(LiteralType type_, const String & token_) : token(token_), type(type_)\n-{\n-}\n-\n-ASTPtr Literal::convertToOld() const\n-{\n-    auto as_field = [this] () -> Field\n-    {\n-        switch(type)\n-        {\n-            case LiteralType::NULL_LITERAL:\n-                return Field(Null());\n-            case LiteralType::NUMBER:\n-            {\n-                const auto * number = this->as<NumberLiteral>();\n-\n-                if (!number->isNegative())\n-                    if (auto value = number->as<UInt64>()) return Field(*value);\n-                if (auto value = number->as<Int64>()) return Field(*value);\n-                if (auto value = number->as<Float64>()) return Field(*value);\n-\n-                return Field();\n-            }\n-            case LiteralType::STRING:\n-                return asString();\n-        }\n-        __builtin_unreachable();\n-    };\n-\n-    return std::make_shared<ASTLiteral>(as_field());\n-}\n-\n-String Literal::toString() const\n-{\n-    WriteBufferFromOwnString wb;\n-    writeEscapedString(token, wb);\n-    return type == LiteralType::STRING ? \"'\" + wb.str() + \"'\" : wb.str();\n-}\n-\n-NumberLiteral::NumberLiteral(antlr4::tree::TerminalNode * literal) : Literal(LiteralType::NUMBER, literal->getSymbol()->getText())\n-{\n-}\n-\n-NumberLiteral::NumberLiteral(const String & literal) : Literal(LiteralType::NUMBER, literal)\n-{\n-}\n-\n-String NumberLiteral::toString() const\n-{\n-    return (minus ? String(\"-\") : String()) + Literal::toString();\n-}\n-\n-ASTSampleRatio::Rational NumberLiteral::convertToOldRational() const\n-{\n-    UInt64 num_before = 0;\n-    UInt64 num_after = 0;\n-    Int64 exponent = 0;\n-\n-    const char * pos = token.data(), * end = token.data() + token.size();\n-    const char * pos_after_first_num = tryReadIntText(num_before, pos, end);\n-\n-    bool has_num_before_point [[maybe_unused]] = pos_after_first_num > pos;\n-    pos = pos_after_first_num;\n-    bool has_point = pos < end && *pos == '.';\n-\n-    if (has_point)\n-        ++pos;\n-\n-    assert (has_num_before_point || has_point);\n-\n-    size_t number_of_digits_after_point = 0;\n-\n-    if (has_point)\n-    {\n-        const char * pos_after_second_num = tryReadIntText(num_after, pos, end);\n-        number_of_digits_after_point = pos_after_second_num - pos;\n-        pos = pos_after_second_num;\n-    }\n-\n-    bool has_exponent = pos < end && (*pos == 'e' || *pos == 'E');\n-\n-    if (has_exponent)\n-    {\n-        ++pos;\n-        const char * pos_after_exponent [[maybe_unused]] = tryReadIntText(exponent, pos, end);\n-        assert (pos_after_exponent != pos);\n-    }\n-\n-    ASTSampleRatio::Rational res;\n-    res.numerator = num_before * intExp10(number_of_digits_after_point) + num_after;\n-    res.denominator = intExp10(number_of_digits_after_point);\n-\n-    if (exponent > 0)\n-        res.numerator *= intExp10(exponent);\n-    if (exponent < 0)\n-        res.denominator *= intExp10(-exponent);\n-\n-    return res;\n-}\n-\n-StringLiteral::StringLiteral(antlr4::tree::TerminalNode * literal) : Literal(LiteralType::STRING, literal->getSymbol()->getText())\n-{\n-    String s;\n-    ReadBufferFromMemory in(token.data(), token.size());\n-\n-    readQuotedStringWithSQLStyle(s, in);\n-\n-    assert(in.count() == token.size());\n-    token = s;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitFloatingLiteral(ClickHouseParser::FloatingLiteralContext * ctx)\n-{\n-    if (ctx->FLOATING_LITERAL()) return Literal::createNumber(ctx->FLOATING_LITERAL());\n-\n-    const auto * dot = ctx->DOT()->getSymbol();\n-\n-    if (!ctx->DECIMAL_LITERAL().empty())\n-    {\n-        // .1234\n-        if (dot->getTokenIndex() < ctx->DECIMAL_LITERAL(0)->getSymbol()->getTokenIndex())\n-            return Literal::createNumber(dot->getText() + ctx->DECIMAL_LITERAL(0)->getSymbol()->getText());\n-        // 1234.\n-        else if (ctx->DECIMAL_LITERAL().size() == 1 && !ctx->OCTAL_LITERAL())\n-            return Literal::createNumber(ctx->DECIMAL_LITERAL(0)->getSymbol()->getText() + dot->getText());\n-        // 1234.1234\n-        else if (ctx->DECIMAL_LITERAL().size() == 2)\n-            return Literal::createNumber(\n-                ctx->DECIMAL_LITERAL(0)->getSymbol()->getText() + dot->getText() + ctx->DECIMAL_LITERAL(1)->getSymbol()->getText());\n-        // 1234.0123\n-        else\n-            return Literal::createNumber(\n-                ctx->DECIMAL_LITERAL(0)->getSymbol()->getText() + dot->getText() + ctx->OCTAL_LITERAL()->getSymbol()->getText());\n-    }\n-    else\n-        // .0123\n-        return Literal::createNumber(dot->getText() + ctx->OCTAL_LITERAL()->getSymbol()->getText());\n-    __builtin_unreachable();\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitLiteral(ClickHouseParser::LiteralContext * ctx)\n-{\n-    if (ctx->NULL_SQL())\n-        return Literal::createNull();\n-    if (ctx->STRING_LITERAL())\n-        return std::static_pointer_cast<Literal>(Literal::createString(ctx->STRING_LITERAL()));\n-    if (ctx->numberLiteral())\n-        return std::static_pointer_cast<Literal>(visit(ctx->numberLiteral()).as<PtrTo<NumberLiteral>>());\n-    __builtin_unreachable();\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitNumberLiteral(ClickHouseParser::NumberLiteralContext *ctx)\n-{\n-    if (ctx->floatingLiteral())\n-    {\n-        auto number = visit(ctx->floatingLiteral()).as<PtrTo<NumberLiteral>>();\n-        if (ctx->DASH()) number->makeNegative();\n-        return number;\n-    }\n-    if (ctx->OCTAL_LITERAL()) return Literal::createNumber(ctx->OCTAL_LITERAL(), !!ctx->DASH());\n-    if (ctx->DECIMAL_LITERAL()) return Literal::createNumber(ctx->DECIMAL_LITERAL(), !!ctx->DASH());\n-    if (ctx->HEXADECIMAL_LITERAL()) return Literal::createNumber(ctx->HEXADECIMAL_LITERAL(), !!ctx->DASH());\n-    if (ctx->INF()) return Literal::createNumber(ctx->INF(), !!ctx->DASH());\n-    if (ctx->NAN_SQL()) return Literal::createNumber(ctx->NAN_SQL());\n-    __builtin_unreachable();\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/Literal.h b/src/Parsers/New/AST/Literal.h\ndeleted file mode 100644\nindex 75790daed201..000000000000\n--- a/src/Parsers/New/AST/Literal.h\n+++ /dev/null\n@@ -1,96 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/INode.h>\n-\n-#include <Core/Field.h>\n-#include <Parsers/ASTSampleRatio.h>\n-\n-#include <Token.h>\n-#include <tree/TerminalNode.h>\n-\n-#include <sstream>\n-\n-\n-namespace DB::AST\n-{\n-\n-class Literal : public INode\n-{\n-    public:\n-        enum class LiteralType\n-        {\n-            NULL_LITERAL,\n-            NUMBER,\n-            STRING,\n-        };\n-\n-        static PtrTo<Literal> createNull();\n-        static PtrTo<NumberLiteral> createNumber(antlr4::tree::TerminalNode * literal, bool negative = false);\n-        static PtrTo<NumberLiteral> createNumber(const String& literal); // checks first symbol for '-' character\n-        static PtrTo<StringLiteral> createString(antlr4::tree::TerminalNode * literal);\n-        static PtrTo<StringLiteral> createString(const String& literal); // without quotes\n-\n-        ASTPtr convertToOld() const override;\n-        String toString() const override;\n-\n-        bool is(LiteralType what) const { return type == what; }\n-\n-    protected:\n-        String token; // STRING is stored without quotes and interpolated with escape-sequences.\n-\n-        Literal(LiteralType type, const String & token);\n-\n-        template <typename T>\n-        std::optional<T> asNumber(bool minus) const\n-        {\n-            T number;\n-            std::stringstream ss(String(minus ? \"-\" : \"+\") + token);\n-            if (token.size() > 2 && (token[1] == 'x' || token[1] == 'X')) ss >> std::hex >> number;\n-            else if (token.size() > 1 && (token[0] == '0')) ss >> std::oct >> number;\n-            else ss >> number;\n-            if (ss.fail() || !ss.eof())\n-                return {};\n-            return number;\n-        }\n-\n-        auto asString() const { return token; }\n-\n-    private:\n-        LiteralType type;\n-\n-        String dumpInfo() const override { return token; }\n-};\n-\n-class NumberLiteral : public Literal\n-{\n-    public:\n-        explicit NumberLiteral(antlr4::tree::TerminalNode * literal);\n-        explicit NumberLiteral(const String & literal);\n-\n-        String toString() const override;\n-\n-        void makeNegative() { minus = true; }\n-        bool isNegative() const { return minus; }\n-\n-        template <typename T> std::optional<T> as() const { return asNumber<T>(minus); }\n-\n-        ASTSampleRatio::Rational convertToOldRational() const;\n-\n-    private:\n-        bool minus = false;\n-};\n-\n-class StringLiteral : public Literal\n-{\n-    public:\n-        explicit StringLiteral(antlr4::tree::TerminalNode * literal);\n-        explicit StringLiteral(const String & literal) : Literal(LiteralType::STRING, literal) {}\n-\n-        template <typename T>\n-        T as() const\n-        {\n-            return asString();\n-        }\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/OptimizeQuery.cpp b/src/Parsers/New/AST/OptimizeQuery.cpp\ndeleted file mode 100644\nindex 5977a2221b93..000000000000\n--- a/src/Parsers/New/AST/OptimizeQuery.cpp\n+++ /dev/null\n@@ -1,59 +0,0 @@\n-#include <Parsers/New/AST/OptimizeQuery.h>\n-\n-#include <Interpreters/StorageID.h>\n-#include <Parsers/ASTIdentifier.h>\n-#include <Parsers/ASTOptimizeQuery.h>\n-#include <Parsers/New/AST/AlterTableQuery.h>\n-#include <Parsers/New/AST/ColumnExpr.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/AST/Literal.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-OptimizeQuery::OptimizeQuery(PtrTo<ClusterClause> cluster, PtrTo<TableIdentifier> identifier, PtrTo<PartitionClause> clause, bool final_, bool deduplicate_)\n-    : DDLQuery(cluster, {identifier, clause}), final(final_), deduplicate(deduplicate_)\n-{\n-}\n-\n-ASTPtr OptimizeQuery::convertToOld() const\n-{\n-    auto query = std::make_shared<ASTOptimizeQuery>();\n-\n-    {\n-        auto table = std::static_pointer_cast<ASTTableIdentifier>(get(TABLE)->convertToOld());\n-        query->database = table->getDatabaseName();\n-        query->table = table->shortName();\n-        query->uuid = table->uuid;\n-    }\n-\n-    if (has(PARTITION))\n-    {\n-        query->partition = get(PARTITION)->convertToOld();\n-        query->children.push_back(query->partition);\n-    }\n-\n-    query->final = final;\n-    query->deduplicate = deduplicate;\n-    query->cluster = cluster_name;\n-\n-    return query;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitOptimizeStmt(ClickHouseParser::OptimizeStmtContext *ctx)\n-{\n-    auto cluster = ctx->clusterClause() ? visit(ctx->clusterClause()).as<PtrTo<ClusterClause>>() : nullptr;\n-    auto clause = ctx->partitionClause() ? visit(ctx->partitionClause()).as<PtrTo<PartitionClause>>() : nullptr;\n-    return std::make_shared<OptimizeQuery>(cluster, visit(ctx->tableIdentifier()), clause, !!ctx->FINAL(), !!ctx->DEDUPLICATE());\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/OptimizeQuery.h b/src/Parsers/New/AST/OptimizeQuery.h\ndeleted file mode 100644\nindex b94351518a7c..000000000000\n--- a/src/Parsers/New/AST/OptimizeQuery.h\n+++ /dev/null\n@@ -1,27 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/DDLQuery.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class OptimizeQuery : public DDLQuery\n-{\n-    public:\n-        OptimizeQuery(\n-            PtrTo<ClusterClause> cluster, PtrTo<TableIdentifier> identifier, PtrTo<PartitionClause> clause, bool final, bool deduplicate);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            TABLE = 0,  // TableIdentifier\n-            PARTITION,  // PartitionClause\n-        };\n-\n-        const bool final, deduplicate;\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/OrderExpr.cpp b/src/Parsers/New/AST/OrderExpr.cpp\ndeleted file mode 100644\nindex 8511bc23276d..000000000000\n--- a/src/Parsers/New/AST/OrderExpr.cpp\n+++ /dev/null\n@@ -1,62 +0,0 @@\n-#include <Parsers/New/AST/OrderExpr.h>\n-\n-#include <Parsers/ASTOrderByElement.h>\n-#include <Parsers/New/AST/ColumnExpr.h>\n-#include <Parsers/New/AST/Literal.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-OrderExpr::OrderExpr(PtrTo<ColumnExpr> expr, NullsOrder nulls_, PtrTo<StringLiteral> collate, bool ascending)\n-    : INode{expr, collate}, nulls(nulls_), asc(ascending)\n-{\n-}\n-\n-ASTPtr OrderExpr::convertToOld() const\n-{\n-    auto expr = std::make_shared<ASTOrderByElement>();\n-\n-    expr->children.push_back(get(EXPR)->convertToOld());\n-    expr->direction = asc ? 1 : -1;\n-    expr->nulls_direction_was_explicitly_specified = (nulls != NATURAL);\n-    if (nulls == NATURAL) expr->nulls_direction = expr->direction;\n-    else expr->nulls_direction = (nulls == NULLS_LAST) ? expr->direction : -expr->direction;\n-\n-    if (has(COLLATE))\n-    {\n-        expr->collation = get(COLLATE)->convertToOld();\n-        expr->children.push_back(expr->collation);\n-    }\n-\n-    // TODO: WITH FILL?\n-\n-    return expr;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-antlrcpp::Any ParseTreeVisitor::visitOrderExprList(ClickHouseParser::OrderExprListContext *ctx)\n-{\n-    auto expr_list = std::make_shared<AST::OrderExprList>();\n-    for (auto* expr : ctx->orderExpr()) expr_list->push(visit(expr));\n-    return expr_list;\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitOrderExpr(ClickHouseParser::OrderExprContext *ctx)\n-{\n-    AST::OrderExpr::NullsOrder nulls = AST::OrderExpr::NATURAL;\n-    if (ctx->FIRST()) nulls = AST::OrderExpr::NULLS_FIRST;\n-    else if (ctx->LAST()) nulls = AST::OrderExpr::NULLS_LAST;\n-\n-    AST::PtrTo<AST::StringLiteral> collate;\n-    if (ctx->COLLATE()) collate = AST::Literal::createString(ctx->STRING_LITERAL());\n-\n-    return std::make_shared<AST::OrderExpr>(visit(ctx->columnExpr()), nulls, collate, !ctx->DESCENDING() && !ctx->DESC());\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/OrderExpr.h b/src/Parsers/New/AST/OrderExpr.h\ndeleted file mode 100644\nindex 2c13e7f5298c..000000000000\n--- a/src/Parsers/New/AST/OrderExpr.h\n+++ /dev/null\n@@ -1,33 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/INode.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class OrderExpr : public INode\n-{\n-    public:\n-        enum NullsOrder {\n-            NATURAL,\n-            NULLS_FIRST,\n-            NULLS_LAST,\n-        };\n-\n-        OrderExpr(PtrTo<ColumnExpr> expr, NullsOrder nulls_, PtrTo<StringLiteral> collate, bool ascending = true);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            EXPR = 0,  // ColumnExpr\n-            COLLATE,   // StringLiteral (optional)\n-        };\n-\n-        NullsOrder nulls;\n-        bool asc;\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/Query.cpp b/src/Parsers/New/AST/Query.cpp\ndeleted file mode 100644\nindex 1ef2ee935b62..000000000000\n--- a/src/Parsers/New/AST/Query.cpp\n+++ /dev/null\n@@ -1,34 +0,0 @@\n-#include <Parsers/New/AST/Query.h>\n-\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/AST/Literal.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-void Query::setOutFile(PtrTo<StringLiteral> literal)\n-{\n-    out_file = literal;\n-}\n-\n-void Query::setFormat(PtrTo<Identifier> id)\n-{\n-    format = id;\n-}\n-\n-void Query::convertToOldPartially(const std::shared_ptr<ASTQueryWithOutput> & query) const\n-{\n-    if (out_file)\n-    {\n-        query->out_file = out_file->convertToOld();\n-        query->children.push_back(query->out_file);\n-    }\n-    if (format)\n-    {\n-        query->format = format->convertToOld();\n-        query->children.push_back(query->format);\n-    }\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/Query.h b/src/Parsers/New/AST/Query.h\ndeleted file mode 100644\nindex 2998d1f01466..000000000000\n--- a/src/Parsers/New/AST/Query.h\n+++ /dev/null\n@@ -1,29 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/INode.h>\n-\n-#include <Parsers/ASTQueryWithOutput.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class Query : public INode {\n-    public:\n-        void setOutFile(PtrTo<StringLiteral> literal);\n-        void setFormat(PtrTo<Identifier> id);\n-\n-    protected:\n-        Query() = default;\n-        Query(std::initializer_list<Ptr> list) : INode(list) {}\n-        explicit Query(PtrList list) : INode(list) {}\n-\n-        void convertToOldPartially(const std::shared_ptr<ASTQueryWithOutput> & query) const;\n-\n-    private:\n-        // TODO: put them to |children|\n-        PtrTo<StringLiteral> out_file;\n-        PtrTo<Identifier> format;\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/README.md b/src/Parsers/New/AST/README.md\ndeleted file mode 100644\nindex 4216a8dcfdc1..000000000000\n--- a/src/Parsers/New/AST/README.md\n+++ /dev/null\n@@ -1,32 +0,0 @@\n-What is AST?\n-===\n-AST stands for Abstract Syntax Tree, which is opposed to Concrete Syntax Tree (or Parse Tree). Read [this](https://eli.thegreenplace.net/2009/02/16/abstract-vs-concrete-syntax-trees/) post to get a sketchy overview of the difference between two concepts.\n-\n-AST **must not** repeat the grammar constructions or follow them. It's convenient to have similar structure but nothing more.\n-The main purpose of AST is to be easily handled by interpreter - the formatting of the original query is not the purpose of AST.\n-\n-Basic principles in code\n-===\n-\n-- The base class for all AST elements is `INode` (INode.h).\n-- **All** sub-elements must be stored inside `INode::children` vector in a\n-**predetermined order** and with **predetermined type**: some elements may be `nullptr` to preserve positions of other elements.\n-- The order may be defined as a position in vector from the start, the last element, and some pattern of variable number of elements\n-in between. It's convenient to define `enum ChildIndex : Uint8 {\u2026}` with index numbers for each class.\n-- If there is more than one variable pack of elements or the order can't be deterministic, then wrap elements into the lists and store the\n-multi-level structure (see `ColumnExpr::ExprType::FUNCTION` for example).\n-- Don't do multi-level structure just for nothing or to mimic the parse tree: the less is depth the better.\n-- The whole grammar separates expressions for databases, tables and columns. That way we already assess the semantics on the parser level.\n-E.g. don't use `identifier` where you know you should use `tableIdentifier`, etc.\n-\n-Name conventions\n-===\n-\n-**Query**. The top-level element that allows to distinguish different types of SQL queries. The base class is `Query` (Query.h).\n-\n-**Statement**. An essential part of a query that describes its structure and possible alternatives.\n-\n-**Clause**. A part of the statement designed to differ logical parts for more convenient parsing. I.e. there are many clauses in SELECT statement that are optional and contain `columnExpr` elements. Without clauses it will be hard for visitor to distinguish which `columnExpr` refers to what.\n-\n-**Expression**. An element that should be somehow calculated or interpreted and result in some value.\n-**\ndiff --git a/src/Parsers/New/AST/RatioExpr.cpp b/src/Parsers/New/AST/RatioExpr.cpp\ndeleted file mode 100644\nindex b9f569282272..000000000000\n--- a/src/Parsers/New/AST/RatioExpr.cpp\n+++ /dev/null\n@@ -1,43 +0,0 @@\n-#include <Parsers/New/AST/RatioExpr.h>\n-\n-#include <Parsers/ASTSampleRatio.h>\n-#include <Parsers/New/AST/Literal.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-RatioExpr::RatioExpr(PtrTo<NumberLiteral> num1, PtrTo<NumberLiteral> num2) : INode{num1, num2}\n-{\n-}\n-\n-ASTPtr RatioExpr::convertToOld() const\n-{\n-    auto numerator = get<NumberLiteral>(NUMERATOR)->convertToOldRational();\n-\n-    if (has(DENOMINATOR))\n-    {\n-        auto denominator = get<NumberLiteral>(DENOMINATOR)->convertToOldRational();\n-\n-        numerator.numerator = numerator.numerator * denominator.denominator;\n-        numerator.denominator = numerator.denominator * denominator.numerator;\n-    }\n-\n-    return std::make_shared<ASTSampleRatio>(numerator);\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitRatioExpr(ClickHouseParser::RatioExprContext *ctx)\n-{\n-    auto denominator = ctx->numberLiteral().size() == 2 ? visit(ctx->numberLiteral(1)).as<PtrTo<NumberLiteral>>() : nullptr;\n-    return std::make_shared<RatioExpr>(visit(ctx->numberLiteral(0)), denominator);\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/RatioExpr.h b/src/Parsers/New/AST/RatioExpr.h\ndeleted file mode 100644\nindex 8e48edbf6eaf..000000000000\n--- a/src/Parsers/New/AST/RatioExpr.h\n+++ /dev/null\n@@ -1,24 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/INode.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class RatioExpr : public INode\n-{\n-    public:\n-        RatioExpr(PtrTo<NumberLiteral> num1, PtrTo<NumberLiteral> num2);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            NUMERATOR = 0,    // NumberLiteral\n-            DENOMINATOR = 1,  // NumberLiteral (optional)\n-        };\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/RenameQuery.cpp b/src/Parsers/New/AST/RenameQuery.cpp\ndeleted file mode 100644\nindex 78a4530a20f1..000000000000\n--- a/src/Parsers/New/AST/RenameQuery.cpp\n+++ /dev/null\n@@ -1,58 +0,0 @@\n-#include <Parsers/New/AST/RenameQuery.h>\n-\n-#include <Interpreters/StorageID.h>\n-#include <Parsers/ASTIdentifier.h>\n-#include <Parsers/ASTRenameQuery.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-RenameQuery::RenameQuery(PtrTo<ClusterClause> cluster, PtrTo<List<TableIdentifier>> list) : DDLQuery(cluster, {list})\n-{\n-}\n-\n-ASTPtr RenameQuery::convertToOld() const\n-{\n-    auto query = std::make_shared<ASTRenameQuery>();\n-\n-    for (auto table = get<List<TableIdentifier>>(EXPRS)->begin(), end = get<List<TableIdentifier>>(EXPRS)->end(); table != end; ++table)\n-    {\n-        ASTRenameQuery::Element element;\n-\n-        if (auto database = (*table)->as<TableIdentifier>()->getDatabase())\n-            element.from.database = database->getName();\n-        element.from.table = (*table)->as<TableIdentifier>()->getName();\n-\n-        ++table;\n-\n-        if (auto database = (*table)->as<TableIdentifier>()->getDatabase())\n-            element.to.database = database->getName();\n-        element.to.table = (*table)->as<TableIdentifier>()->getName();\n-\n-        query->elements.push_back(element);\n-    }\n-\n-    query->cluster = cluster_name;\n-\n-    return query;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitRenameStmt(ClickHouseParser::RenameStmtContext *ctx)\n-{\n-    auto list = std::make_shared<List<TableIdentifier>>();\n-    auto cluster = ctx->clusterClause() ? visit(ctx->clusterClause()).as<PtrTo<ClusterClause>>() : nullptr;\n-    for (auto * identifier : ctx->tableIdentifier()) list->push(visit(identifier));\n-    return std::make_shared<RenameQuery>(cluster, list);\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/RenameQuery.h b/src/Parsers/New/AST/RenameQuery.h\ndeleted file mode 100644\nindex 74909043d4dd..000000000000\n--- a/src/Parsers/New/AST/RenameQuery.h\n+++ /dev/null\n@@ -1,23 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/DDLQuery.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class RenameQuery : public DDLQuery\n-{\n-    public:\n-        explicit RenameQuery(PtrTo<ClusterClause> cluster, PtrTo<List<TableIdentifier>> list);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            EXPRS = 0,  // List<TableIdentifier>\n-        };\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/SelectUnionQuery.cpp b/src/Parsers/New/AST/SelectUnionQuery.cpp\ndeleted file mode 100644\nindex 35eda09b473b..000000000000\n--- a/src/Parsers/New/AST/SelectUnionQuery.cpp\n+++ /dev/null\n@@ -1,444 +0,0 @@\n-#include <Parsers/New/AST/SelectUnionQuery.h>\n-\n-#include <Parsers/ASTExpressionList.h>\n-#include <Parsers/ASTFunction.h>\n-#include <Parsers/ASTLiteral.h>\n-#include <Parsers/ASTProjectionSelectQuery.h>\n-#include <Parsers/ASTSelectQuery.h>\n-#include <Parsers/ASTSelectWithUnionQuery.h>\n-#include <Parsers/ASTSetQuery.h>\n-#include <Parsers/ASTTablesInSelectQuery.h>\n-#include <Parsers/New/AST/ColumnExpr.h>\n-#include <Parsers/New/AST/JoinExpr.h>\n-#include <Parsers/New/AST/LimitExpr.h>\n-#include <Parsers/New/AST/SettingExpr.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-namespace DB::ErrorCodes\n-{\n-    extern const int TOP_AND_LIMIT_TOGETHER;\n-}\n-\n-namespace DB::AST\n-{\n-\n-// FROM Clause\n-\n-FromClause::FromClause(PtrTo<JoinExpr> expr) : INode{expr}\n-{\n-}\n-\n-ASTPtr FromClause::convertToOld() const\n-{\n-    auto old_tables = std::make_shared<ASTTablesInSelectQuery>();\n-    old_tables->children = get(EXPR)->convertToOld()->children;\n-    return old_tables;\n-}\n-\n-// ARRAY JOIN Clause\n-\n-ArrayJoinClause::ArrayJoinClause(PtrTo<ColumnExprList> expr_list, bool left_) : INode{expr_list}, left(left_)\n-{\n-}\n-\n-ASTPtr ArrayJoinClause::convertToOld() const\n-{\n-    auto element = std::make_shared<ASTTablesInSelectQueryElement>();\n-    auto array_join = std::make_shared<ASTArrayJoin>();\n-\n-    if (left) array_join->kind = ASTArrayJoin::Kind::Left;\n-    else array_join->kind = ASTArrayJoin::Kind::Inner;\n-\n-    array_join->expression_list = get(EXPRS)->convertToOld();\n-    array_join->children.push_back(array_join->expression_list);\n-\n-    element->array_join = array_join;\n-    element->children.push_back(element->array_join);\n-\n-    return element;\n-}\n-\n-// LIMIT By Clause\n-\n-LimitByClause::LimitByClause(PtrTo<LimitExpr> expr, PtrTo<ColumnExprList> expr_list) : INode{expr, expr_list}\n-{\n-}\n-\n-ASTPtr LimitByClause::convertToOld() const\n-{\n-    auto list = std::make_shared<ASTExpressionList>();\n-\n-    list->children.push_back(get(LIMIT)->convertToOld());\n-    list->children.push_back(get(EXPRS)->convertToOld());\n-\n-    return list;\n-}\n-\n-// LIMIT Clause\n-\n-LimitClause::LimitClause(bool with_ties_, PtrTo<LimitExpr> expr) : INode{expr}, with_ties(with_ties_)\n-{\n-}\n-\n-ASTPtr LimitClause::convertToOld() const\n-{\n-    return get(EXPR)->convertToOld();\n-}\n-\n-// SETTINGS Clause\n-\n-SettingsClause::SettingsClause(PtrTo<SettingExprList> expr_list) : INode{expr_list}\n-{\n-}\n-\n-ASTPtr SettingsClause::convertToOld() const\n-{\n-    auto expr = std::make_shared<ASTSetQuery>();\n-\n-    for (const auto & child : get(EXPRS)->as<SettingExprList &>())\n-    {\n-        const auto * setting = child->as<SettingExpr>();\n-        expr->changes.emplace_back(setting->getName()->getName(), setting->getValue()->convertToOld()->as<ASTLiteral>()->value);\n-    }\n-\n-    return expr;\n-}\n-\n-// PROJECTION SELECT Caluse\n-\n-ProjectionSelectStmt::ProjectionSelectStmt(PtrTo<ColumnExprList> expr_list)\n-    : INode(MAX_INDEX)\n-{\n-    set(COLUMNS, expr_list);\n-}\n-\n-void ProjectionSelectStmt::setWithClause(PtrTo<WithClause> clause)\n-{\n-    set(WITH, clause);\n-}\n-\n-void ProjectionSelectStmt::setGroupByClause(PtrTo<GroupByClause> clause)\n-{\n-    set(GROUP_BY, clause);\n-}\n-\n-void ProjectionSelectStmt::setOrderByClause(PtrTo<ProjectionOrderByClause> clause)\n-{\n-    set(ORDER_BY, clause);\n-}\n-\n-ASTPtr ProjectionSelectStmt::convertToOld() const\n-{\n-    auto old_select = std::make_shared<ASTProjectionSelectQuery>();\n-\n-    old_select->setExpression(ASTProjectionSelectQuery::Expression::SELECT, get(COLUMNS)->convertToOld());\n-\n-    if (has(WITH)) old_select->setExpression(ASTProjectionSelectQuery::Expression::WITH, get(WITH)->convertToOld());\n-    if (has(GROUP_BY)) old_select->setExpression(ASTProjectionSelectQuery::Expression::GROUP_BY, get(GROUP_BY)->convertToOld());\n-    if (has(ORDER_BY))\n-    {\n-        ASTPtr order_expression;\n-        auto expr_list = get(ORDER_BY)->convertToOld();\n-        if (expr_list->children.size() == 1)\n-        {\n-            order_expression = expr_list->children.front();\n-        }\n-        else\n-        {\n-            auto function_node = std::make_shared<ASTFunction>();\n-            function_node->name = \"tuple\";\n-            function_node->arguments = expr_list;\n-            function_node->children.push_back(expr_list);\n-            order_expression = function_node;\n-        }\n-        old_select->setExpression(ASTProjectionSelectQuery::Expression::ORDER_BY, std::move(order_expression));\n-    }\n-\n-    return old_select;\n-}\n-\n-// SELECT Statement\n-\n-SelectStmt::SelectStmt(bool distinct_, ModifierType type, bool totals, PtrTo<ColumnExprList> expr_list)\n-    : INode(MAX_INDEX), modifier_type(type), distinct(distinct_), with_totals(totals)\n-{\n-    set(COLUMNS, expr_list);\n-}\n-\n-void SelectStmt::setWithClause(PtrTo<WithClause> clause)\n-{\n-    set(WITH, clause);\n-}\n-\n-void SelectStmt::setFromClause(PtrTo<FromClause> clause)\n-{\n-    set(FROM, clause);\n-}\n-\n-void SelectStmt::setArrayJoinClause(PtrTo<ArrayJoinClause> clause)\n-{\n-    set(ARRAY_JOIN, clause);\n-}\n-\n-void SelectStmt::setPrewhereClause(PtrTo<PrewhereClause> clause)\n-{\n-    set(PREWHERE, clause);\n-}\n-\n-void SelectStmt::setWhereClause(PtrTo<WhereClause> clause)\n-{\n-    set(WHERE, clause);\n-}\n-\n-void SelectStmt::setGroupByClause(PtrTo<GroupByClause> clause)\n-{\n-    set(GROUP_BY, clause);\n-}\n-\n-void SelectStmt::setHavingClause(PtrTo<HavingClause> clause)\n-{\n-    set(HAVING, clause);\n-}\n-\n-void SelectStmt::setOrderByClause(PtrTo<OrderByClause> clause)\n-{\n-    set(ORDER_BY, clause);\n-}\n-\n-void SelectStmt::setLimitByClause(PtrTo<LimitByClause> clause)\n-{\n-    set(LIMIT_BY, clause);\n-}\n-\n-void SelectStmt::setLimitClause(PtrTo<LimitClause> clause)\n-{\n-    set(LIMIT, clause);\n-}\n-\n-void SelectStmt::setSettingsClause(PtrTo<SettingsClause> clause)\n-{\n-    set(SETTINGS, clause);\n-}\n-\n-ASTPtr SelectStmt::convertToOld() const\n-{\n-    auto old_select = std::make_shared<ASTSelectQuery>();\n-\n-    old_select->setExpression(ASTSelectQuery::Expression::SELECT, get(COLUMNS)->convertToOld());\n-    old_select->distinct = distinct;\n-    old_select->group_by_with_totals = with_totals;\n-\n-    switch(modifier_type)\n-    {\n-        case ModifierType::NONE:\n-            break;\n-        case ModifierType::CUBE:\n-            old_select->group_by_with_cube = true;\n-            break;\n-        case ModifierType::ROLLUP:\n-            old_select->group_by_with_rollup = true;\n-            break;\n-    }\n-\n-    if (has(WITH)) old_select->setExpression(ASTSelectQuery::Expression::WITH, get(WITH)->convertToOld());\n-    if (has(FROM)) old_select->setExpression(ASTSelectQuery::Expression::TABLES, get(FROM)->convertToOld());\n-    if (has(ARRAY_JOIN)) old_select->tables()->children.push_back(get(ARRAY_JOIN)->convertToOld());\n-    if (has(PREWHERE)) old_select->setExpression(ASTSelectQuery::Expression::PREWHERE, get(PREWHERE)->convertToOld());\n-    if (has(WHERE)) old_select->setExpression(ASTSelectQuery::Expression::WHERE, get(WHERE)->convertToOld());\n-    if (has(GROUP_BY)) old_select->setExpression(ASTSelectQuery::Expression::GROUP_BY, get(GROUP_BY)->convertToOld());\n-    if (has(HAVING)) old_select->setExpression(ASTSelectQuery::Expression::HAVING, get(HAVING)->convertToOld());\n-    if (has(ORDER_BY)) old_select->setExpression(ASTSelectQuery::Expression::ORDER_BY, get(ORDER_BY)->convertToOld());\n-    if (has(LIMIT_BY))\n-    {\n-        auto old_list = get(LIMIT_BY)->convertToOld();\n-        old_select->setExpression(ASTSelectQuery::Expression::LIMIT_BY, std::move(old_list->children[1]));\n-        old_select->setExpression(ASTSelectQuery::Expression::LIMIT_BY_LENGTH, std::move(old_list->children[0]->children[0]));\n-        if (old_list->children[0]->children.size() > 1)\n-            old_select->setExpression(ASTSelectQuery::Expression::LIMIT_BY_OFFSET, std::move(old_list->children[0]->children[1]));\n-    }\n-    if (has(LIMIT))\n-    {\n-        auto old_list = get(LIMIT)->convertToOld();\n-        old_select->limit_with_ties = get<LimitClause>(LIMIT)->with_ties;\n-        old_select->setExpression(ASTSelectQuery::Expression::LIMIT_LENGTH, std::move(old_list->children[0]));\n-        if (old_list->children.size() > 1)\n-            old_select->setExpression(ASTSelectQuery::Expression::LIMIT_OFFSET, std::move(old_list->children[1]));\n-    }\n-    if (has(SETTINGS)) old_select->setExpression(ASTSelectQuery::Expression::SETTINGS, get(SETTINGS)->convertToOld());\n-\n-    return old_select;\n-}\n-\n-SelectUnionQuery::SelectUnionQuery(PtrTo<List<SelectStmt>> stmts) : Query{stmts}\n-{\n-}\n-\n-void SelectUnionQuery::appendSelect(PtrTo<SelectStmt> stmt)\n-{\n-    if (!has(STMTS)) push(std::make_shared<List<SelectStmt>>());\n-    get<List<SelectStmt>>(STMTS)->push(stmt);\n-}\n-\n-void SelectUnionQuery::appendSelect(PtrTo<SelectUnionQuery> query)\n-{\n-    for (const auto & stmt : query->get(STMTS)->as<List<SelectStmt> &>())\n-        appendSelect(std::static_pointer_cast<SelectStmt>(stmt));\n-}\n-\n-ASTPtr SelectUnionQuery::convertToOld() const\n-{\n-    auto query = std::make_shared<ASTSelectWithUnionQuery>();\n-\n-    query->list_of_selects = std::make_shared<ASTExpressionList>();\n-    query->children.push_back(query->list_of_selects);\n-\n-    for (const auto & select : get(STMTS)->as<List<SelectStmt> &>())\n-        query->list_of_selects->children.push_back(select->convertToOld());\n-\n-    // TODO(ilezhankin): need to parse new UNION DISTINCT\n-    query->list_of_modes\n-        = ASTSelectWithUnionQuery::UnionModes(query->list_of_selects->children.size() - 1, ASTSelectWithUnionQuery::Mode::ALL);\n-\n-    convertToOldPartially(query);\n-\n-    return query;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitWithClause(ClickHouseParser::WithClauseContext *ctx)\n-{\n-    return std::make_shared<WithClause>(visit(ctx->columnExprList()).as<PtrTo<ColumnExprList>>());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitTopClause(ClickHouseParser::TopClauseContext *ctx)\n-{\n-    auto limit = std::make_shared<LimitExpr>(ColumnExpr::createLiteral(Literal::createNumber(ctx->DECIMAL_LITERAL())));\n-    return std::make_shared<LimitClause>(!!ctx->WITH(), limit);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitFromClause(ClickHouseParser::FromClauseContext *ctx)\n-{\n-    return std::make_shared<FromClause>(visit(ctx->joinExpr()).as<PtrTo<JoinExpr>>());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitArrayJoinClause(ClickHouseParser::ArrayJoinClauseContext *ctx)\n-{\n-    return std::make_shared<ArrayJoinClause>(visit(ctx->columnExprList()), !!ctx->LEFT());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitPrewhereClause(ClickHouseParser::PrewhereClauseContext *ctx)\n-{\n-    return std::make_shared<PrewhereClause>(visit(ctx->columnExpr()).as<PtrTo<ColumnExpr>>());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitWhereClause(ClickHouseParser::WhereClauseContext *ctx)\n-{\n-    return std::make_shared<WhereClause>(visit(ctx->columnExpr()).as<PtrTo<ColumnExpr>>());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitGroupByClause(ClickHouseParser::GroupByClauseContext *ctx)\n-{\n-    return std::make_shared<GroupByClause>(visit(ctx->columnExprList()).as<PtrTo<ColumnExprList>>());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitHavingClause(ClickHouseParser::HavingClauseContext *ctx)\n-{\n-    return std::make_shared<HavingClause>(visit(ctx->columnExpr()).as<PtrTo<ColumnExpr>>());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitOrderByClause(ClickHouseParser::OrderByClauseContext *ctx)\n-{\n-    return std::make_shared<OrderByClause>(visit(ctx->orderExprList()).as<PtrTo<OrderExprList>>());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitProjectionOrderByClause(ClickHouseParser::ProjectionOrderByClauseContext *ctx)\n-{\n-    return std::make_shared<ProjectionOrderByClause>(visit(ctx->columnExprList()).as<PtrTo<ColumnExprList>>());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitLimitByClause(ClickHouseParser::LimitByClauseContext *ctx)\n-{\n-    return std::make_shared<LimitByClause>(visit(ctx->limitExpr()), visit(ctx->columnExprList()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitLimitClause(ClickHouseParser::LimitClauseContext *ctx)\n-{\n-    return std::make_shared<LimitClause>(!!ctx->WITH(), visit(ctx->limitExpr()).as<PtrTo<LimitExpr>>());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitSettingsClause(ClickHouseParser::SettingsClauseContext *ctx)\n-{\n-    return std::make_shared<SettingsClause>(visit(ctx->settingExprList()).as<PtrTo<SettingExprList>>());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitProjectionSelectStmt(ClickHouseParser::ProjectionSelectStmtContext *ctx)\n-{\n-    PtrTo<ColumnExprList> column_list = visit(ctx->columnExprList());\n-    auto select_stmt = std::make_shared<ProjectionSelectStmt>(column_list);\n-\n-    if (ctx->withClause()) select_stmt->setWithClause(visit(ctx->withClause()));\n-    if (ctx->groupByClause()) select_stmt->setGroupByClause(visit(ctx->groupByClause()));\n-    if (ctx->projectionOrderByClause()) select_stmt->setOrderByClause(visit(ctx->projectionOrderByClause()));\n-\n-    return select_stmt;\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitSelectStmt(ClickHouseParser::SelectStmtContext *ctx)\n-{\n-    SelectStmt::ModifierType type = SelectStmt::ModifierType::NONE;\n-\n-    if (ctx->CUBE() || (ctx->groupByClause() && ctx->groupByClause()->CUBE())) type = SelectStmt::ModifierType::CUBE;\n-    else if (ctx->ROLLUP() || (ctx->groupByClause() && ctx->groupByClause()->ROLLUP())) type = SelectStmt::ModifierType::ROLLUP;\n-\n-    auto select_stmt = std::make_shared<SelectStmt>(!!ctx->DISTINCT(), type, !!ctx->TOTALS(), visit(ctx->columnExprList()));\n-\n-    if (ctx->topClause() && ctx->limitClause())\n-        throw Exception(\"Can not use TOP and LIMIT together\", ErrorCodes::TOP_AND_LIMIT_TOGETHER);\n-\n-    if (ctx->withClause()) select_stmt->setWithClause(visit(ctx->withClause()));\n-    if (ctx->topClause()) select_stmt->setLimitClause(visit(ctx->topClause()));\n-    if (ctx->fromClause()) select_stmt->setFromClause(visit(ctx->fromClause()));\n-    if (ctx->arrayJoinClause()) select_stmt->setArrayJoinClause(visit(ctx->arrayJoinClause()));\n-    if (ctx->prewhereClause()) select_stmt->setPrewhereClause(visit(ctx->prewhereClause()));\n-    if (ctx->whereClause()) select_stmt->setWhereClause(visit(ctx->whereClause()));\n-    if (ctx->groupByClause()) select_stmt->setGroupByClause(visit(ctx->groupByClause()));\n-    if (ctx->havingClause()) select_stmt->setHavingClause(visit(ctx->havingClause()));\n-    if (ctx->orderByClause()) select_stmt->setOrderByClause(visit(ctx->orderByClause()));\n-    if (ctx->limitByClause()) select_stmt->setLimitByClause(visit(ctx->limitByClause()));\n-    if (ctx->limitClause()) select_stmt->setLimitClause(visit(ctx->limitClause()));\n-    if (ctx->settingsClause()) select_stmt->setSettingsClause(visit(ctx->settingsClause()));\n-\n-    return select_stmt;\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitSelectStmtWithParens(ClickHouseParser::SelectStmtWithParensContext *ctx)\n-{\n-    PtrTo<SelectUnionQuery> query;\n-\n-    if (ctx->selectStmt())\n-    {\n-        query = std::make_shared<SelectUnionQuery>();\n-        query->appendSelect(visit(ctx->selectStmt()).as<PtrTo<SelectStmt>>());\n-    }\n-    else if (ctx->selectUnionStmt())\n-    {\n-         query = visit(ctx->selectUnionStmt());\n-    }\n-\n-    return query;\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitSelectUnionStmt(ClickHouseParser::SelectUnionStmtContext *ctx)\n-{\n-    auto select_union_query = std::make_shared<SelectUnionQuery>();\n-    for (auto * stmt : ctx->selectStmtWithParens()) select_union_query->appendSelect(visit(stmt).as<PtrTo<SelectUnionQuery>>());\n-    return select_union_query;\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/SelectUnionQuery.h b/src/Parsers/New/AST/SelectUnionQuery.h\ndeleted file mode 100644\nindex 587da271a785..000000000000\n--- a/src/Parsers/New/AST/SelectUnionQuery.h\n+++ /dev/null\n@@ -1,193 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/Query.h>\n-\n-#include <Core/Types.h>\n-\n-#include <list>\n-\n-\n-namespace DB::AST\n-{\n-\n-// Clauses\n-\n-using WithClause = SimpleClause<ColumnExprList>;\n-\n-class FromClause : public INode\n-{\n-    public:\n-        explicit FromClause(PtrTo<JoinExpr> join_expr);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            EXPR = 0,  // JoinExpr\n-        };\n-};\n-\n-class ArrayJoinClause : public INode\n-{\n-    public:\n-        ArrayJoinClause(PtrTo<ColumnExprList> expr_list, bool left);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            EXPRS = 0,  // ColumnExprList\n-        };\n-\n-        const bool left;\n-};\n-\n-using PrewhereClause = SimpleClause<ColumnExpr>;\n-\n-using GroupByClause = SimpleClause<ColumnExprList>;\n-\n-using HavingClause = SimpleClause<ColumnExpr>;\n-\n-class LimitByClause : public INode\n-{\n-    public:\n-        LimitByClause(PtrTo<LimitExpr> expr, PtrTo<ColumnExprList> expr_list);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            LIMIT = 0,  // LimitExpr\n-            EXPRS = 1,   // ColumnExprList\n-        };\n-};\n-\n-class LimitClause : public INode\n-{\n-    public:\n-        LimitClause(bool with_ties, PtrTo<LimitExpr> expr);\n-\n-        ASTPtr convertToOld() const override;\n-\n-        const bool with_ties;  // FIXME: bad interface, because old AST stores this inside ASTSelectQuery.\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            EXPR = 0,  // LimitExpr\n-        };\n-};\n-\n-class SettingsClause : public INode\n-{\n-    public:\n-        explicit SettingsClause(PtrTo<SettingExprList> expr_list);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            EXPRS = 0,  // SettingExprList\n-        };\n-};\n-\n-// Statement\n-\n-class ProjectionSelectStmt : public INode\n-{\n-    public:\n-        ProjectionSelectStmt(PtrTo<ColumnExprList> expr_list);\n-\n-        void setWithClause(PtrTo<WithClause> clause);\n-        void setGroupByClause(PtrTo<GroupByClause> clause);\n-        void setOrderByClause(PtrTo<ProjectionOrderByClause> clause);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            COLUMNS = 0,  // ColumnExprList\n-            WITH,         // WithClause (optional)\n-            GROUP_BY,     // GroupByClause (optional)\n-            ORDER_BY,     // OrderByClause (optional)\n-\n-            MAX_INDEX,\n-        };\n-};\n-\n-class SelectStmt : public INode\n-{\n-    public:\n-        enum class ModifierType\n-        {\n-            NONE,\n-            CUBE,\n-            ROLLUP,\n-        };\n-\n-        SelectStmt(bool distinct_, ModifierType type, bool totals, PtrTo<ColumnExprList> expr_list);\n-\n-        void setWithClause(PtrTo<WithClause> clause);\n-        void setFromClause(PtrTo<FromClause> clause);\n-        void setArrayJoinClause(PtrTo<ArrayJoinClause> clause);\n-        void setPrewhereClause(PtrTo<PrewhereClause> clause);\n-        void setWhereClause(PtrTo<WhereClause> clause);\n-        void setGroupByClause(PtrTo<GroupByClause> clause);\n-        void setHavingClause(PtrTo<HavingClause> clause);\n-        void setOrderByClause(PtrTo<OrderByClause> clause);\n-        void setLimitByClause(PtrTo<LimitByClause> clause);\n-        void setLimitClause(PtrTo<LimitClause> clause);\n-        void setSettingsClause(PtrTo<SettingsClause> clause);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            COLUMNS = 0,  // ColumnExprList\n-            WITH,         // WithClause (optional)\n-            FROM,         // FromClause (optional)\n-            ARRAY_JOIN,   // ArrayJoinClause (optional)\n-            PREWHERE,     // PrewhereClause (optional)\n-            WHERE,        // WhereClause (optional)\n-            GROUP_BY,     // GroupByClause (optional)\n-            HAVING,       // HavingClause (optional)\n-            ORDER_BY,     // OrderByClause (optional)\n-            LIMIT_BY,     // LimitByClause (optional)\n-            LIMIT,        // LimitClause (optional)\n-            SETTINGS,     // SettingsClause (optional)\n-\n-            MAX_INDEX,\n-        };\n-\n-        const ModifierType modifier_type;\n-        const bool distinct, with_totals;\n-};\n-\n-class SelectUnionQuery : public Query\n-{\n-    public:\n-        SelectUnionQuery() = default;\n-        explicit SelectUnionQuery(PtrTo<List<SelectStmt>> stmts);\n-\n-        void appendSelect(PtrTo<SelectStmt> stmt);\n-        void appendSelect(PtrTo<SelectUnionQuery> query);\n-        void shouldBeScalar() { is_scalar = true; }\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            STMTS = 0,  // List<SelectStmt>\n-        };\n-\n-        bool is_scalar = false;\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/SetQuery.cpp b/src/Parsers/New/AST/SetQuery.cpp\ndeleted file mode 100644\nindex 1f7087e21e39..000000000000\n--- a/src/Parsers/New/AST/SetQuery.cpp\n+++ /dev/null\n@@ -1,43 +0,0 @@\n-#include <Parsers/New/AST/SetQuery.h>\n-\n-#include <Parsers/ASTLiteral.h>\n-#include <Parsers/ASTSetQuery.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/AST/Literal.h>\n-#include <Parsers/New/AST/SettingExpr.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-SetQuery::SetQuery(PtrTo<SettingExprList> list) : Query{list}\n-{\n-}\n-\n-ASTPtr SetQuery::convertToOld() const\n-{\n-    auto expr = std::make_shared<ASTSetQuery>();\n-\n-    for (const auto & child : get(EXPRS)->as<SettingExprList &>())\n-    {\n-        const auto * setting = child->as<SettingExpr>();\n-        expr->changes.emplace_back(setting->getName()->getName(), setting->getValue()->convertToOld()->as<ASTLiteral>()->value);\n-    }\n-\n-    return expr;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitSetStmt(ClickHouseParser::SetStmtContext *ctx)\n-{\n-    return std::make_shared<SetQuery>(visit(ctx->settingExprList()).as<PtrTo<SettingExprList>>());\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/SetQuery.h b/src/Parsers/New/AST/SetQuery.h\ndeleted file mode 100644\nindex 451371f6896f..000000000000\n--- a/src/Parsers/New/AST/SetQuery.h\n+++ /dev/null\n@@ -1,23 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/Query.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class SetQuery : public Query\n-{\n-    public:\n-        explicit SetQuery(PtrTo<SettingExprList> list);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            EXPRS = 0,  // SettingExprList\n-        };\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/SettingExpr.cpp b/src/Parsers/New/AST/SettingExpr.cpp\ndeleted file mode 100644\nindex e38b9d57ff84..000000000000\n--- a/src/Parsers/New/AST/SettingExpr.cpp\n+++ /dev/null\n@@ -1,33 +0,0 @@\n-#include <Parsers/New/AST/SettingExpr.h>\n-\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/AST/Literal.h>\n-\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-SettingExpr::SettingExpr(PtrTo<Identifier> name, PtrTo<Literal> value) : INode{name, value}\n-{\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-antlrcpp::Any ParseTreeVisitor::visitSettingExprList(ClickHouseParser::SettingExprListContext *ctx)\n-{\n-    auto expr_list = std::make_shared<AST::SettingExprList>();\n-    for (auto* expr : ctx->settingExpr()) expr_list->push(visit(expr));\n-    return expr_list;\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitSettingExpr(ClickHouseParser::SettingExprContext *ctx)\n-{\n-    return std::make_shared<AST::SettingExpr>(visit(ctx->identifier()), visit(ctx->literal()));\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/SettingExpr.h b/src/Parsers/New/AST/SettingExpr.h\ndeleted file mode 100644\nindex 8dad61661897..000000000000\n--- a/src/Parsers/New/AST/SettingExpr.h\n+++ /dev/null\n@@ -1,25 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/INode.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class SettingExpr : public INode\n-{\n-    public:\n-        SettingExpr(PtrTo<Identifier> name, PtrTo<Literal> value);\n-\n-        auto getName() const { return std::static_pointer_cast<Identifier>(get(NAME)); }\n-        auto getValue() const { return std::static_pointer_cast<Literal>(get(VALUE)); }\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            NAME = 0,\n-            VALUE = 1,\n-        };\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/ShowCreateQuery.cpp b/src/Parsers/New/AST/ShowCreateQuery.cpp\ndeleted file mode 100644\nindex 613b5178e621..000000000000\n--- a/src/Parsers/New/AST/ShowCreateQuery.cpp\n+++ /dev/null\n@@ -1,96 +0,0 @@\n-#include <Parsers/New/AST/ShowCreateQuery.h>\n-\n-#include <Interpreters/StorageID.h>\n-#include <Parsers/ASTIdentifier.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-#include <Parsers/TablePropertiesQueriesASTs.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-// static\n-PtrTo<ShowCreateQuery> ShowCreateQuery::createDatabase(PtrTo<DatabaseIdentifier> identifier)\n-{\n-    return PtrTo<ShowCreateQuery>(new ShowCreateQuery(QueryType::DATABASE, {identifier}));\n-}\n-\n-// static\n-PtrTo<ShowCreateQuery> ShowCreateQuery::createDictionary(PtrTo<TableIdentifier> identifier)\n-{\n-    return PtrTo<ShowCreateQuery>(new ShowCreateQuery(QueryType::DICTIONARY, {identifier}));\n-}\n-\n-// static\n-PtrTo<ShowCreateQuery> ShowCreateQuery::createTable(bool temporary, PtrTo<TableIdentifier> identifier)\n-{\n-    PtrTo<ShowCreateQuery> query(new ShowCreateQuery(QueryType::TABLE, {identifier}));\n-    query->temporary = temporary;\n-    return query;\n-}\n-\n-ShowCreateQuery::ShowCreateQuery(QueryType type, PtrList exprs) : Query(exprs), query_type(type)\n-{\n-}\n-\n-ASTPtr ShowCreateQuery::convertToOld() const\n-{\n-    switch(query_type)\n-    {\n-        case QueryType::DATABASE:\n-        {\n-            auto query = std::make_shared<ASTShowCreateDatabaseQuery>();\n-            query->database = get<DatabaseIdentifier>(IDENTIFIER)->getName();\n-            return query;\n-        }\n-        case QueryType::DICTIONARY:\n-        {\n-            auto query = std::make_shared<ASTShowCreateDictionaryQuery>();\n-\n-            auto table = std::static_pointer_cast<ASTTableIdentifier>(get(IDENTIFIER)->convertToOld());\n-            query->database = table->getDatabaseName();\n-            query->table = table->shortName();\n-            query->uuid = table->uuid;\n-\n-            return query;\n-        }\n-        case QueryType::TABLE:\n-        {\n-            auto query = std::make_shared<ASTShowCreateTableQuery>();\n-\n-            auto table = std::static_pointer_cast<ASTTableIdentifier>(get(IDENTIFIER)->convertToOld());\n-            query->database = table->getDatabaseName();\n-            query->table = table->shortName();\n-            query->uuid = table->uuid;\n-            query->temporary = temporary;\n-\n-            return query;\n-        }\n-    }\n-    __builtin_unreachable();\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitShowCreateDatabaseStmt(ClickHouseParser::ShowCreateDatabaseStmtContext *ctx)\n-{\n-    return ShowCreateQuery::createDatabase(visit(ctx->databaseIdentifier()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitShowCreateDictionaryStmt(ClickHouseParser::ShowCreateDictionaryStmtContext * ctx)\n-{\n-    return ShowCreateQuery::createDictionary(visit(ctx->tableIdentifier()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitShowCreateTableStmt(ClickHouseParser::ShowCreateTableStmtContext *ctx)\n-{\n-    return ShowCreateQuery::createTable(!!ctx->TEMPORARY(), visit(ctx->tableIdentifier()));\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/ShowCreateQuery.h b/src/Parsers/New/AST/ShowCreateQuery.h\ndeleted file mode 100644\nindex 5f4d31bce60a..000000000000\n--- a/src/Parsers/New/AST/ShowCreateQuery.h\n+++ /dev/null\n@@ -1,36 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/Query.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class ShowCreateQuery : public Query\n-{\n-    public:\n-        static PtrTo<ShowCreateQuery> createDatabase(PtrTo<DatabaseIdentifier> identifier);\n-        static PtrTo<ShowCreateQuery> createDictionary(PtrTo<TableIdentifier> identifier);\n-        static PtrTo<ShowCreateQuery> createTable(bool temporary, PtrTo<TableIdentifier> identifier);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            IDENTIFIER = 0,  // DatabaseIdentifier or TableIdentifier\n-        };\n-        enum class QueryType\n-        {\n-            DATABASE,\n-            DICTIONARY,\n-            TABLE,\n-        };\n-\n-        QueryType query_type;\n-        bool temporary = false;\n-\n-        ShowCreateQuery(QueryType type, PtrList exprs);\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/ShowQuery.cpp b/src/Parsers/New/AST/ShowQuery.cpp\ndeleted file mode 100644\nindex e6ea357dd703..000000000000\n--- a/src/Parsers/New/AST/ShowQuery.cpp\n+++ /dev/null\n@@ -1,49 +0,0 @@\n-#include <Parsers/New/AST/ShowQuery.h>\n-\n-#include <Parsers/ASTShowTablesQuery.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-// static\n-PtrTo<ShowQuery> ShowQuery::createDictionaries(PtrTo<DatabaseIdentifier> from)\n-{\n-    return PtrTo<ShowQuery>(new ShowQuery(QueryType::DICTIONARIES, {from}));\n-}\n-\n-ShowQuery::ShowQuery(QueryType type, PtrList exprs) : Query(exprs), query_type(type)\n-{\n-}\n-\n-ASTPtr ShowQuery::convertToOld() const\n-{\n-    auto query = std::make_shared<ASTShowTablesQuery>();\n-\n-    switch(query_type)\n-    {\n-        case QueryType::DICTIONARIES:\n-            query->dictionaries = true;\n-            if (has(FROM)) query->from = get<DatabaseIdentifier>(FROM)->getQualifiedName();\n-            break;\n-    }\n-\n-    return query;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitShowDictionariesStmt(ClickHouseParser::ShowDictionariesStmtContext *ctx)\n-{\n-    auto from = ctx->databaseIdentifier() ? visit(ctx->databaseIdentifier()).as<PtrTo<DatabaseIdentifier>>() : nullptr;\n-    return ShowQuery::createDictionaries(from);\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/ShowQuery.h b/src/Parsers/New/AST/ShowQuery.h\ndeleted file mode 100644\nindex 93951676bbbf..000000000000\n--- a/src/Parsers/New/AST/ShowQuery.h\n+++ /dev/null\n@@ -1,32 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/Query.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class ShowQuery : public Query\n-{\n-    public:\n-        static PtrTo<ShowQuery> createDictionaries(PtrTo<DatabaseIdentifier> from);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            FROM = 0,  // DatabaseIdentifier (optional)\n-        };\n-\n-        enum class QueryType\n-        {\n-            DICTIONARIES,\n-        };\n-\n-        const QueryType query_type;\n-\n-        ShowQuery(QueryType type, PtrList exprs);\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/SystemQuery.cpp b/src/Parsers/New/AST/SystemQuery.cpp\ndeleted file mode 100644\nindex d2fda6a3fbc2..000000000000\n--- a/src/Parsers/New/AST/SystemQuery.cpp\n+++ /dev/null\n@@ -1,191 +0,0 @@\n-#include <Parsers/New/AST/SystemQuery.h>\n-\n-#include <Parsers/ASTIdentifier.h>\n-#include <Parsers/ASTSystemQuery.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-#include <Interpreters/StorageID.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-// static\n-PtrTo<SystemQuery> SystemQuery::createDistributedSends(bool stop, PtrTo<TableIdentifier> identifier)\n-{\n-    PtrTo<SystemQuery> query(new SystemQuery(QueryType::DISTRIBUTED_SENDS, {identifier}));\n-    query->stop = stop;\n-    return query;\n-}\n-\n-// static\n-PtrTo<SystemQuery> SystemQuery::createFetches(bool stop, PtrTo<TableIdentifier> identifier)\n-{\n-    PtrTo<SystemQuery> query(new SystemQuery(QueryType::FETCHES, {identifier}));\n-    query->stop = stop;\n-    return query;\n-}\n-\n-// static\n-PtrTo<SystemQuery> SystemQuery::createFlushDistributed(PtrTo<TableIdentifier> identifier)\n-{\n-    return PtrTo<SystemQuery>(new SystemQuery(QueryType::FLUSH_DISTRIBUTED, {identifier}));\n-}\n-\n-// static\n-PtrTo<SystemQuery> SystemQuery::createFlushLogs()\n-{\n-    return PtrTo<SystemQuery>(new SystemQuery(QueryType::FLUSH_LOGS, {}));\n-}\n-\n-// static\n-PtrTo<SystemQuery> SystemQuery::createMerges(bool stop, PtrTo<TableIdentifier> identifier)\n-{\n-    PtrTo<SystemQuery> query(new SystemQuery(QueryType::MERGES, {identifier}));\n-    query->stop = stop;\n-    return query;\n-}\n-\n-// static\n-PtrTo<SystemQuery> SystemQuery::createReloadDictionaries()\n-{\n-    return PtrTo<SystemQuery>(new SystemQuery(QueryType::RELOAD_DICTIONARIES, {}));\n-}\n-\n-// static\n-PtrTo<SystemQuery> SystemQuery::createReloadDictionary(PtrTo<TableIdentifier> identifier)\n-{\n-    return PtrTo<SystemQuery>(new SystemQuery(QueryType::RELOAD_DICTIONARY, {identifier}));\n-}\n-\n-// static\n-PtrTo<SystemQuery> SystemQuery::createReplicatedSends(bool stop)\n-{\n-    PtrTo<SystemQuery> query(new SystemQuery(QueryType::REPLICATED_SENDS, {}));\n-    query->stop = stop;\n-    return query;\n-}\n-\n-// static\n-PtrTo<SystemQuery> SystemQuery::createSyncReplica(PtrTo<TableIdentifier> identifier)\n-{\n-    return PtrTo<SystemQuery>(new SystemQuery(QueryType::SYNC_REPLICA, {identifier}));\n-}\n-\n-// static\n-PtrTo<SystemQuery> SystemQuery::createTTLMerges(bool stop, PtrTo<TableIdentifier> identifier)\n-{\n-    PtrTo<SystemQuery> query(new SystemQuery(QueryType::TTL_MERGES, {identifier}));\n-    query->stop = stop;\n-    return query;\n-}\n-\n-SystemQuery::SystemQuery(QueryType type, PtrList exprs) : Query(exprs), query_type(type)\n-{\n-}\n-\n-ASTPtr SystemQuery::convertToOld() const\n-{\n-    auto query = std::make_shared<ASTSystemQuery>();\n-\n-    switch(query_type)\n-    {\n-        case QueryType::DISTRIBUTED_SENDS:\n-            query->type = stop ? ASTSystemQuery::Type::STOP_DISTRIBUTED_SENDS : ASTSystemQuery::Type::START_DISTRIBUTED_SENDS;\n-            {\n-                auto table = std::static_pointer_cast<ASTTableIdentifier>(get(TABLE)->convertToOld());\n-                query->database = table->getDatabaseName();\n-                query->table = table->shortName();\n-            }\n-            break;\n-        case QueryType::FETCHES:\n-            query->type = stop ? ASTSystemQuery::Type::STOP_FETCHES : ASTSystemQuery::Type::START_FETCHES;\n-            {\n-                auto table = std::static_pointer_cast<ASTTableIdentifier>(get(TABLE)->convertToOld());\n-                query->database = table->getDatabaseName();\n-                query->table = table->shortName();\n-            }\n-            break;\n-        case QueryType::FLUSH_DISTRIBUTED:\n-            query->type = ASTSystemQuery::Type::FLUSH_DISTRIBUTED;\n-            {\n-                auto table = std::static_pointer_cast<ASTTableIdentifier>(get(TABLE)->convertToOld());\n-                query->database = table->getDatabaseName();\n-                query->table = table->shortName();\n-            }\n-            break;\n-        case QueryType::FLUSH_LOGS:\n-            query->type = ASTSystemQuery::Type::FLUSH_LOGS;\n-            break;\n-        case QueryType::MERGES:\n-            query->type = stop ? ASTSystemQuery::Type::STOP_MERGES : ASTSystemQuery::Type::START_MERGES;\n-            {\n-                auto table = std::static_pointer_cast<ASTTableIdentifier>(get(TABLE)->convertToOld());\n-                query->database = table->getDatabaseName();\n-                query->table = table->shortName();\n-            }\n-            break;\n-        case QueryType::RELOAD_DICTIONARIES:\n-            query->type = ASTSystemQuery::Type::RELOAD_DICTIONARIES;\n-            break;\n-        case QueryType::RELOAD_DICTIONARY:\n-            query->type = ASTSystemQuery::Type::RELOAD_DICTIONARY;\n-            {\n-                auto table = std::static_pointer_cast<ASTTableIdentifier>(get(TABLE)->convertToOld());\n-                query->database = table->getDatabaseName();\n-                query->table = table->getTableId().table_name;\n-            }\n-            break;\n-        case QueryType::REPLICATED_SENDS:\n-            query->type = stop ? ASTSystemQuery::Type::STOP_REPLICATED_SENDS : ASTSystemQuery::Type::START_REPLICATED_SENDS;\n-            break;\n-        case QueryType::SYNC_REPLICA:\n-            query->type = ASTSystemQuery::Type::SYNC_REPLICA;\n-            {\n-                auto table = std::static_pointer_cast<ASTTableIdentifier>(get(TABLE)->convertToOld());\n-                query->database = table->getDatabaseName();\n-                query->table = table->shortName();\n-            }\n-            break;\n-        case QueryType::TTL_MERGES:\n-            query->type = stop ? ASTSystemQuery::Type::STOP_TTL_MERGES : ASTSystemQuery::Type::START_TTL_MERGES;\n-            {\n-                auto table = std::static_pointer_cast<ASTTableIdentifier>(get(TABLE)->convertToOld());\n-                query->database = table->getDatabaseName();\n-                query->table = table->shortName();\n-            }\n-            break;\n-    }\n-\n-    return query;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitSystemStmt(ClickHouseParser::SystemStmtContext *ctx)\n-{\n-    if (ctx->FLUSH() && ctx->DISTRIBUTED()) return SystemQuery::createFlushDistributed(visit(ctx->tableIdentifier()));\n-    if (ctx->FLUSH() && ctx->LOGS()) return SystemQuery::createFlushLogs();\n-    if (ctx->DISTRIBUTED() && ctx->SENDS()) return SystemQuery::createDistributedSends(!!ctx->STOP(), visit(ctx->tableIdentifier()));\n-    if (ctx->FETCHES()) return SystemQuery::createFetches(!!ctx->STOP(), visit(ctx->tableIdentifier()));\n-    if (ctx->MERGES())\n-    {\n-        if (ctx->TTL()) return SystemQuery::createTTLMerges(!!ctx->STOP(), visit(ctx->tableIdentifier()));\n-        else return SystemQuery::createMerges(!!ctx->STOP(), visit(ctx->tableIdentifier()));\n-    }\n-    if (ctx->RELOAD())\n-    {\n-        if (ctx->DICTIONARIES()) return SystemQuery::createReloadDictionaries();\n-        if (ctx->DICTIONARY()) return SystemQuery::createReloadDictionary(visit(ctx->tableIdentifier()));\n-    }\n-    if (ctx->REPLICATED() && ctx->SENDS()) return SystemQuery::createReplicatedSends(!!ctx->STOP());\n-    if (ctx->SYNC() && ctx->REPLICA()) return SystemQuery::createSyncReplica(visit(ctx->tableIdentifier()));\n-    __builtin_unreachable();\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/SystemQuery.h b/src/Parsers/New/AST/SystemQuery.h\ndeleted file mode 100644\nindex 98a5cfd09324..000000000000\n--- a/src/Parsers/New/AST/SystemQuery.h\n+++ /dev/null\n@@ -1,50 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/Query.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class SystemQuery : public Query\n-{\n-    public:\n-        static PtrTo<SystemQuery> createDistributedSends(bool stop, PtrTo<TableIdentifier> identifier);\n-        static PtrTo<SystemQuery> createFetches(bool stop, PtrTo<TableIdentifier> identifier);\n-        static PtrTo<SystemQuery> createFlushDistributed(PtrTo<TableIdentifier> identifier);\n-        static PtrTo<SystemQuery> createFlushLogs();\n-        static PtrTo<SystemQuery> createMerges(bool stop, PtrTo<TableIdentifier> identifier);\n-        static PtrTo<SystemQuery> createReloadDictionaries();\n-        static PtrTo<SystemQuery> createReloadDictionary(PtrTo<TableIdentifier> identifier);\n-        static PtrTo<SystemQuery> createReplicatedSends(bool stop);\n-        static PtrTo<SystemQuery> createSyncReplica(PtrTo<TableIdentifier> identifier);\n-        static PtrTo<SystemQuery> createTTLMerges(bool stop, PtrTo<TableIdentifier> identifier);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            TABLE = 0,\n-        };\n-        enum class QueryType\n-        {\n-            DISTRIBUTED_SENDS,\n-            FETCHES,\n-            FLUSH_DISTRIBUTED,\n-            FLUSH_LOGS,\n-            MERGES,\n-            RELOAD_DICTIONARIES,\n-            RELOAD_DICTIONARY,\n-            REPLICATED_SENDS,\n-            SYNC_REPLICA,\n-            TTL_MERGES,\n-        };\n-\n-        QueryType query_type;\n-        bool stop = false;\n-\n-        SystemQuery(QueryType type, PtrList exprs);\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/TableElementExpr.cpp b/src/Parsers/New/AST/TableElementExpr.cpp\ndeleted file mode 100644\nindex 70855fee6972..000000000000\n--- a/src/Parsers/New/AST/TableElementExpr.cpp\n+++ /dev/null\n@@ -1,264 +0,0 @@\n-#include <Parsers/New/AST/TableElementExpr.h>\n-\n-#include <Parsers/ASTColumnDeclaration.h>\n-#include <Parsers/ASTConstraintDeclaration.h>\n-#include <Parsers/ASTFunction.h>\n-#include <Parsers/ASTIndexDeclaration.h>\n-#include <Parsers/ASTProjectionDeclaration.h>\n-#include <Parsers/New/AST/ColumnExpr.h>\n-#include <Parsers/New/AST/ColumnTypeExpr.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/AST/Literal.h>\n-#include <Parsers/New/AST/SelectUnionQuery.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-CodecArgExpr::CodecArgExpr(PtrTo<Identifier> identifier, PtrTo<ColumnExprList> list) : INode{identifier, list}\n-{\n-}\n-\n-ASTPtr CodecArgExpr::convertToOld() const\n-{\n-    auto func = std::make_shared<ASTFunction>();\n-\n-    func->name = get<Identifier>(NAME)->getName();\n-    if (has(ARGS))\n-    {\n-        func->arguments = get(ARGS)->convertToOld();\n-        func->children.push_back(func->arguments);\n-    }\n-\n-    return func;\n-}\n-\n-CodecExpr::CodecExpr(PtrTo<CodecArgList> list) : INode{list}\n-{\n-}\n-\n-ASTPtr CodecExpr::convertToOld() const\n-{\n-    auto func = std::make_shared<ASTFunction>();\n-\n-    func->name = \"codec\";\n-    func->arguments = get(ARGS)->convertToOld();\n-    func->children.push_back(func->arguments);\n-\n-    return func;\n-}\n-\n-TableColumnPropertyExpr::TableColumnPropertyExpr(PropertyType type, PtrTo<ColumnExpr> expr) : INode{expr}, property_type(type)\n-{\n-}\n-\n-ASTPtr TableColumnPropertyExpr::convertToOld() const\n-{\n-    return get(EXPR)->convertToOld();\n-}\n-\n-// static\n-PtrTo<TableElementExpr> TableElementExpr::createColumn(\n-    PtrTo<Identifier> name,\n-    PtrTo<ColumnTypeExpr> type,\n-    PtrTo<TableColumnPropertyExpr> property,\n-    PtrTo<StringLiteral> comment,\n-    PtrTo<CodecExpr> codec,\n-    PtrTo<ColumnExpr> ttl)\n-{\n-    return PtrTo<TableElementExpr>(new TableElementExpr(ExprType::COLUMN, {name, type, property, comment, codec, ttl}));\n-}\n-\n-// static\n-PtrTo<TableElementExpr> TableElementExpr::createConstraint(PtrTo<Identifier> identifier, PtrTo<ColumnExpr> expr)\n-{\n-    return PtrTo<TableElementExpr>(new TableElementExpr(ExprType::CONSTRAINT, {identifier, expr}));\n-}\n-\n-// static\n-PtrTo<TableElementExpr>\n-TableElementExpr::createIndex(PtrTo<Identifier> name, PtrTo<ColumnExpr> expr, PtrTo<ColumnTypeExpr> type, PtrTo<NumberLiteral> granularity)\n-{\n-    return PtrTo<TableElementExpr>(new TableElementExpr(ExprType::INDEX, {name, expr, type, granularity}));\n-}\n-\n-// static\n-PtrTo<TableElementExpr>\n-TableElementExpr::createProjection(PtrTo<Identifier> name, PtrTo<ProjectionSelectStmt> query)\n-{\n-    return PtrTo<TableElementExpr>(new TableElementExpr(ExprType::PROJECTION, {name, query}));\n-}\n-\n-TableElementExpr::TableElementExpr(ExprType type, PtrList exprs) : INode(exprs), expr_type(type)\n-{\n-}\n-\n-ASTPtr TableElementExpr::convertToOld() const\n-{\n-    switch(expr_type)\n-    {\n-        case ExprType::COLUMN:\n-        {\n-            auto expr = std::make_shared<ASTColumnDeclaration>();\n-\n-            expr->name = get<Identifier>(NAME)->getName(); // FIXME: do we have correct nested identifier here already?\n-            if (has(TYPE))\n-            {\n-                expr->type = get(TYPE)->convertToOld();\n-                expr->children.push_back(expr->type);\n-            }\n-            if (has(PROPERTY))\n-            {\n-                switch(get<TableColumnPropertyExpr>(PROPERTY)->getType())\n-                {\n-                    case TableColumnPropertyExpr::PropertyType::ALIAS:\n-                        expr->default_specifier = \"ALIAS\";\n-                        break;\n-                    case TableColumnPropertyExpr::PropertyType::DEFAULT:\n-                        expr->default_specifier = \"DEFAULT\";\n-                        break;\n-                    case TableColumnPropertyExpr::PropertyType::MATERIALIZED:\n-                        expr->default_specifier = \"MATERIALIZED\";\n-                        break;\n-                }\n-                expr->default_expression = get(PROPERTY)->convertToOld();\n-                expr->children.push_back(expr->default_expression);\n-            }\n-            if (has(COMMENT))\n-            {\n-                expr->comment = get(COMMENT)->convertToOld();\n-                expr->children.push_back(expr->comment);\n-            }\n-            if (has(CODEC))\n-            {\n-                expr->codec = get(CODEC)->convertToOld();\n-                expr->children.push_back(expr->codec);\n-            }\n-            if (has(TTL))\n-            {\n-                expr->ttl = get(TTL)->convertToOld();\n-                expr->children.push_back(expr->ttl);\n-            }\n-\n-            return expr;\n-        }\n-        case ExprType::CONSTRAINT:\n-        {\n-            auto expr = std::make_shared<ASTConstraintDeclaration>();\n-\n-            expr->name = get<Identifier>(NAME)->getName();\n-            expr->set(expr->expr, get(EXPR)->convertToOld());\n-\n-            return expr;\n-        }\n-        case ExprType::INDEX:\n-        {\n-            auto expr = std::make_shared<ASTIndexDeclaration>();\n-\n-            expr->name = get<Identifier>(NAME)->getName();\n-            expr->set(expr->expr, get(EXPR)->convertToOld());\n-            expr->set(expr->type, get(INDEX_TYPE)->convertToOld());\n-            expr->granularity = get<NumberLiteral>(GRANULARITY)->as<UInt64>().value_or(0); // FIXME: throw exception instead of default.\n-\n-            return expr;\n-        }\n-        case ExprType::PROJECTION:\n-        {\n-            auto expr = std::make_shared<ASTProjectionDeclaration>();\n-\n-            expr->name = get<Identifier>(NAME)->getName();\n-            expr->set(expr->query, get(QUERY)->convertToOld());\n-\n-            return expr;\n-        }\n-    }\n-    __builtin_unreachable();\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitCodecArgExpr(ClickHouseParser::CodecArgExprContext *ctx)\n-{\n-    auto list = ctx->columnExprList() ? visit(ctx->columnExprList()).as<PtrTo<ColumnExprList>>() : nullptr;\n-    return std::make_shared<CodecArgExpr>(visit(ctx->identifier()), list);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitCodecExpr(ClickHouseParser::CodecExprContext *ctx)\n-{\n-    auto list = std::make_shared<CodecArgList>();\n-    for (auto * arg : ctx->codecArgExpr()) list->push(visit(arg));\n-    return std::make_shared<CodecExpr>(list);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitTableColumnDfnt(ClickHouseParser::TableColumnDfntContext *ctx)\n-{\n-    PtrTo<TableColumnPropertyExpr> property;\n-    PtrTo<ColumnTypeExpr> type;\n-    PtrTo<StringLiteral> comment;\n-    PtrTo<CodecExpr> codec;\n-    PtrTo<ColumnExpr> ttl;\n-\n-    if (ctx->tableColumnPropertyExpr()) property = visit(ctx->tableColumnPropertyExpr());\n-    if (ctx->columnTypeExpr()) type = visit(ctx->columnTypeExpr());\n-    if (ctx->STRING_LITERAL()) comment = Literal::createString(ctx->STRING_LITERAL());\n-    if (ctx->codecExpr()) codec = visit(ctx->codecExpr());\n-    if (ctx->TTL()) ttl = visit(ctx->columnExpr());\n-\n-    return TableElementExpr::createColumn(visit(ctx->nestedIdentifier()), type, property, comment, codec, ttl);\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitTableColumnPropertyExpr(ClickHouseParser::TableColumnPropertyExprContext *ctx)\n-{\n-    TableColumnPropertyExpr::PropertyType type;\n-\n-    if (ctx->DEFAULT()) type = TableColumnPropertyExpr::PropertyType::DEFAULT;\n-    else if (ctx->MATERIALIZED()) type = TableColumnPropertyExpr::PropertyType::MATERIALIZED;\n-    else if (ctx->ALIAS()) type = TableColumnPropertyExpr::PropertyType::ALIAS;\n-    else __builtin_unreachable();\n-\n-    return std::make_shared<TableColumnPropertyExpr>(type, visit(ctx->columnExpr()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitTableElementExprColumn(ClickHouseParser::TableElementExprColumnContext *ctx)\n-{\n-    return visit(ctx->tableColumnDfnt());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitTableElementExprConstraint(ClickHouseParser::TableElementExprConstraintContext *ctx)\n-{\n-    return TableElementExpr::createConstraint(visit(ctx->identifier()), visit(ctx->columnExpr()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitTableElementExprIndex(ClickHouseParser::TableElementExprIndexContext *ctx)\n-{\n-    return visit(ctx->tableIndexDfnt());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitTableElementExprProjection(ClickHouseParser::TableElementExprProjectionContext *ctx)\n-{\n-    return visit(ctx->tableProjectionDfnt());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitTableIndexDfnt(ClickHouseParser::TableIndexDfntContext *ctx)\n-{\n-    return TableElementExpr::createIndex(\n-        visit(ctx->nestedIdentifier()),\n-        visit(ctx->columnExpr()),\n-        visit(ctx->columnTypeExpr()),\n-        Literal::createNumber(ctx->DECIMAL_LITERAL()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitTableProjectionDfnt(ClickHouseParser::TableProjectionDfntContext *ctx)\n-{\n-    return TableElementExpr::createProjection(\n-        visit(ctx->nestedIdentifier()),\n-        visit(ctx->projectionSelectStmt()));\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/TableElementExpr.h b/src/Parsers/New/AST/TableElementExpr.h\ndeleted file mode 100644\nindex 18d1aa9c456e..000000000000\n--- a/src/Parsers/New/AST/TableElementExpr.h\n+++ /dev/null\n@@ -1,123 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/INode.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class CodecArgExpr : public INode\n-{\n-    public:\n-        CodecArgExpr(PtrTo<Identifier> identifier, PtrTo<ColumnExprList> list);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            NAME = 0,  // Identifier\n-            ARGS = 1,  // ColumnExprList (optional)\n-        };\n-};\n-\n-class CodecExpr : public INode\n-{\n-    public:\n-        explicit CodecExpr(PtrTo<CodecArgList> list);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            ARGS = 0,  // CodecArgList\n-        };\n-};\n-\n-class TableColumnPropertyExpr : public INode\n-{\n-    public:\n-        enum class PropertyType\n-        {\n-            DEFAULT,\n-            MATERIALIZED,\n-            ALIAS,\n-        };\n-\n-        TableColumnPropertyExpr(PropertyType type, PtrTo<ColumnExpr> expr);\n-\n-        auto getType() const { return property_type; }\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            EXPR = 0,  // ColumnExpr\n-        };\n-\n-        PropertyType property_type;\n-};\n-\n-class TableElementExpr : public INode\n-{\n-    public:\n-        enum class ExprType\n-        {\n-            COLUMN,\n-            CONSTRAINT,\n-            INDEX,\n-            PROJECTION,\n-        };\n-\n-        static PtrTo<TableElementExpr> createColumn(\n-            PtrTo<Identifier> name,\n-            PtrTo<ColumnTypeExpr> type,\n-            PtrTo<TableColumnPropertyExpr> property,\n-            PtrTo<StringLiteral> comment,\n-            PtrTo<CodecExpr> codec,\n-            PtrTo<ColumnExpr> ttl);\n-\n-        static PtrTo<TableElementExpr> createConstraint(PtrTo<Identifier> identifier, PtrTo<ColumnExpr> expr);\n-\n-        static PtrTo<TableElementExpr>\n-        createIndex(PtrTo<Identifier> name, PtrTo<ColumnExpr> expr, PtrTo<ColumnTypeExpr> type, PtrTo<NumberLiteral> granularity);\n-\n-        static PtrTo<TableElementExpr>\n-        createProjection(PtrTo<Identifier> name, PtrTo<ProjectionSelectStmt> query);\n-\n-        auto getType() const { return expr_type; }\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex: UInt8\n-        {\n-            // COLUMN\n-            NAME = 0,      // Identifier\n-            TYPE = 1,      // ColumnExprType (optional)\n-            PROPERTY = 2,  // TableColumnPropertyExpr\n-            COMMENT = 3,   // StringLiteral (optional)\n-            CODEC = 4,     // CodecExpr (optional)\n-            TTL = 5,       // ColumnExpr (optional)\n-\n-            // CONSTRAINT\n-            // NAME = 0,\n-            // EXPR = 1,\n-\n-            // INDEX\n-            EXPR = 1,         // ColumnExpr\n-            INDEX_TYPE = 2,   // ColumnTypeExpr\n-            GRANULARITY = 3,  // NumberLiteral\n-\n-            // PROJECTION\n-            QUERY = 1,         // ColumnExpr\n-        };\n-\n-        const ExprType expr_type;\n-\n-        TableElementExpr(ExprType type, PtrList exprs);\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/TableExpr.cpp b/src/Parsers/New/AST/TableExpr.cpp\ndeleted file mode 100644\nindex e14493c6bd62..000000000000\n--- a/src/Parsers/New/AST/TableExpr.cpp\n+++ /dev/null\n@@ -1,190 +0,0 @@\n-#include <Parsers/New/AST/TableExpr.h>\n-\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/AST/Literal.h>\n-#include <Parsers/New/AST/SelectUnionQuery.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-#include <Parsers/ASTFunction.h>\n-#include <Parsers/ASTSubquery.h>\n-#include <Parsers/ASTTablesInSelectQuery.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-TableArgExpr::TableArgExpr(PtrTo<Literal> literal) : INode{literal}\n-{\n-}\n-\n-TableArgExpr::TableArgExpr(PtrTo<TableFunctionExpr> function) : INode{function}\n-{\n-}\n-\n-TableArgExpr::TableArgExpr(PtrTo<Identifier> identifier) : INode{identifier}\n-{\n-}\n-\n-ASTPtr TableArgExpr::convertToOld() const\n-{\n-    return get(EXPR)->convertToOld();\n-}\n-\n-// static\n-PtrTo<TableExpr> TableExpr::createAlias(PtrTo<TableExpr> expr, PtrTo<Identifier> alias)\n-{\n-    return PtrTo<TableExpr>(new TableExpr(ExprType::ALIAS, {expr, alias}));\n-}\n-\n-// static\n-PtrTo<TableExpr> TableExpr::createFunction(PtrTo<TableFunctionExpr> function)\n-{\n-    return PtrTo<TableExpr>(new TableExpr(ExprType::FUNCTION, {function}));\n-}\n-\n-// static\n-PtrTo<TableExpr> TableExpr::createIdentifier(PtrTo<TableIdentifier> identifier)\n-{\n-    return PtrTo<TableExpr>(new TableExpr(ExprType::IDENTIFIER, {identifier}));\n-}\n-\n-// static\n-PtrTo<TableExpr> TableExpr::createSubquery(PtrTo<SelectUnionQuery> subquery)\n-{\n-    return PtrTo<TableExpr>(new TableExpr(ExprType::SUBQUERY, {subquery}));\n-}\n-\n-ASTPtr TableExpr::convertToOld() const\n-{\n-    // TODO: SAMPLE and RATIO also goes here somehow\n-\n-    switch (expr_type)\n-    {\n-        case ExprType::ALIAS:\n-        {\n-            auto expr = get(EXPR)->convertToOld();\n-            auto * table_expr = expr->as<ASTTableExpression>();\n-\n-            if (table_expr->database_and_table_name)\n-                table_expr->database_and_table_name->setAlias(get<Identifier>(ALIAS)->getName());\n-            else if (table_expr->table_function)\n-                table_expr->table_function->setAlias(get<Identifier>(ALIAS)->getName());\n-            else if (table_expr->subquery)\n-                table_expr->subquery->setAlias(get<Identifier>(ALIAS)->getName());\n-\n-            return expr;\n-        }\n-        case ExprType::FUNCTION:\n-        {\n-            auto expr = std::make_shared<ASTTableExpression>();\n-            auto func = get(FUNCTION)->convertToOld();\n-\n-            expr->table_function = func;\n-            expr->children.push_back(func);\n-\n-            return expr;\n-        }\n-        case ExprType::IDENTIFIER:\n-        {\n-            auto expr = std::make_shared<ASTTableExpression>();\n-\n-            expr->database_and_table_name = get(IDENTIFIER)->convertToOld();\n-            expr->children.emplace_back(expr->database_and_table_name);\n-\n-            return expr;\n-        }\n-        case ExprType::SUBQUERY:\n-        {\n-            auto expr = std::make_shared<ASTTableExpression>();\n-\n-            expr->subquery = std::make_shared<ASTSubquery>();\n-            expr->subquery->children.push_back(get(SUBQUERY)->convertToOld());\n-            expr->children.push_back(expr->subquery);\n-\n-            return expr;\n-        }\n-    }\n-    __builtin_unreachable();\n-}\n-\n-TableExpr::TableExpr(TableExpr::ExprType type, PtrList exprs) : INode(exprs), expr_type(type)\n-{\n-}\n-\n-String TableExpr::dumpInfo() const\n-{\n-    switch(expr_type)\n-    {\n-        case ExprType::ALIAS: return \"ALIAS\";\n-        case ExprType::FUNCTION: return \"FUNCTION\";\n-        case ExprType::IDENTIFIER: return \"IDENTIFIER\";\n-        case ExprType::SUBQUERY: return \"SUBQUERY\";\n-    }\n-    __builtin_unreachable();\n-}\n-\n-TableFunctionExpr::TableFunctionExpr(PtrTo<Identifier> name, PtrTo<TableArgList> args) : INode{name, args}\n-{\n-}\n-\n-ASTPtr TableFunctionExpr::convertToOld() const\n-{\n-    auto func = std::make_shared<ASTFunction>();\n-\n-    func->name = get<Identifier>(NAME)->getName();\n-    func->arguments = has(ARGS) ? get(ARGS)->convertToOld() : std::make_shared<TableArgList>()->convertToOld();\n-    func->children.push_back(func->arguments);\n-\n-    return func;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitTableArgExpr(ClickHouseParser::TableArgExprContext *ctx)\n-{\n-    if (ctx->literal()) return std::make_shared<TableArgExpr>(visit(ctx->literal()).as<PtrTo<Literal>>());\n-    if (ctx->tableFunctionExpr()) return std::make_shared<TableArgExpr>(visit(ctx->tableFunctionExpr()).as<PtrTo<TableFunctionExpr>>());\n-    if (ctx->nestedIdentifier()) return std::make_shared<TableArgExpr>(visit(ctx->nestedIdentifier()).as<PtrTo<Identifier>>());\n-    __builtin_unreachable();\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitTableArgList(ClickHouseParser::TableArgListContext * ctx)\n-{\n-    auto list = std::make_shared<TableArgList>();\n-    for (auto * arg : ctx->tableArgExpr()) list->push(visit(arg));\n-    return list;\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitTableExprAlias(ClickHouseParser::TableExprAliasContext *ctx)\n-{\n-    if (ctx->AS()) return TableExpr::createAlias(visit(ctx->tableExpr()), visit(ctx->identifier()));\n-    else return TableExpr::createAlias(visit(ctx->tableExpr()), visit(ctx->alias()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitTableExprFunction(ClickHouseParser::TableExprFunctionContext *ctx)\n-{\n-    return TableExpr::createFunction(visit(ctx->tableFunctionExpr()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitTableExprIdentifier(ClickHouseParser::TableExprIdentifierContext *ctx)\n-{\n-    return TableExpr::createIdentifier(visit(ctx->tableIdentifier()).as<PtrTo<TableIdentifier>>());\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitTableExprSubquery(ClickHouseParser::TableExprSubqueryContext *ctx)\n-{\n-    return TableExpr::createSubquery(visit(ctx->selectUnionStmt()));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitTableFunctionExpr(ClickHouseParser::TableFunctionExprContext *ctx)\n-{\n-    auto list = ctx->tableArgList() ? visit(ctx->tableArgList()).as<PtrTo<TableArgList>>() : nullptr;\n-    return std::make_shared<TableFunctionExpr>(visit(ctx->identifier()), list);\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/TableExpr.h b/src/Parsers/New/AST/TableExpr.h\ndeleted file mode 100644\nindex 1d8937530234..000000000000\n--- a/src/Parsers/New/AST/TableExpr.h\n+++ /dev/null\n@@ -1,81 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/INode.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class TableArgExpr : public INode\n-{\n-    public:\n-        explicit TableArgExpr(PtrTo<Literal> literal);\n-        explicit TableArgExpr(PtrTo<TableFunctionExpr> function);\n-        explicit TableArgExpr(PtrTo<Identifier> identifier);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            EXPR = 0,  // Literal or TableFunctionExpr or Identifier\n-        };\n-};\n-\n-class TableExpr : public INode\n-{\n-    public:\n-        static PtrTo<TableExpr> createAlias(PtrTo<TableExpr> expr, PtrTo<Identifier> alias);\n-        static PtrTo<TableExpr> createFunction(PtrTo<TableFunctionExpr> function);\n-        static PtrTo<TableExpr> createIdentifier(PtrTo<TableIdentifier> identifier);\n-        static PtrTo<TableExpr> createSubquery(PtrTo<SelectUnionQuery> subquery);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            // ALIAS\n-            EXPR = 0,   // TableExpr\n-            ALIAS = 1,  // Identifier\n-\n-            // FUNCTION\n-            FUNCTION = 0,  // TableFunctionExpr\n-\n-            // IDENTIFIER\n-            IDENTIFIER = 0,  // TableIdentifier\n-\n-            // SUBQUERY\n-            SUBQUERY = 0,  // SelectUnionSubquery\n-        };\n-        enum class ExprType\n-        {\n-            ALIAS,\n-            FUNCTION,\n-            IDENTIFIER,\n-            SUBQUERY,\n-        };\n-\n-        ExprType expr_type;\n-\n-        TableExpr(ExprType type, PtrList exprs);\n-\n-        String dumpInfo() const override;\n-};\n-\n-class TableFunctionExpr : public INode\n-{\n-    public:\n-        TableFunctionExpr(PtrTo<Identifier> name, PtrTo<TableArgList> args);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            NAME = 0,\n-            ARGS = 1,\n-        };\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/TruncateQuery.cpp b/src/Parsers/New/AST/TruncateQuery.cpp\ndeleted file mode 100644\nindex 43d7f7ed042a..000000000000\n--- a/src/Parsers/New/AST/TruncateQuery.cpp\n+++ /dev/null\n@@ -1,47 +0,0 @@\n-#include <Parsers/New/AST/TruncateQuery.h>\n-\n-#include <Parsers/ASTDropQuery.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-TruncateQuery::TruncateQuery(PtrTo<ClusterClause> cluster, bool temporary_, bool if_exists_, PtrTo<TableIdentifier> identifier)\n-    : DDLQuery(cluster, {identifier}), temporary(temporary_), if_exists(if_exists_)\n-{\n-}\n-\n-ASTPtr TruncateQuery::convertToOld() const\n-{\n-    auto query = std::make_shared<ASTDropQuery>();\n-\n-    query->kind = ASTDropQuery::Truncate;\n-    query->if_exists = if_exists;\n-    query->temporary = temporary;\n-    query->cluster = cluster_name;\n-\n-    query->table = get<TableIdentifier>(NAME)->getName();\n-    if (auto database = get<TableIdentifier>(NAME)->getDatabase())\n-        query->database = database->getName();\n-\n-    convertToOldPartially(query);\n-\n-    return query;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitTruncateStmt(ClickHouseParser::TruncateStmtContext *ctx)\n-{\n-    auto cluster = ctx->clusterClause() ? visit(ctx->clusterClause()).as<PtrTo<ClusterClause>>() : nullptr;\n-    return std::make_shared<TruncateQuery>(cluster, !!ctx->TEMPORARY(), !!ctx->IF(), visit(ctx->tableIdentifier()));\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/TruncateQuery.h b/src/Parsers/New/AST/TruncateQuery.h\ndeleted file mode 100644\nindex 463e561890f4..000000000000\n--- a/src/Parsers/New/AST/TruncateQuery.h\n+++ /dev/null\n@@ -1,25 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/DDLQuery.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class TruncateQuery : public DDLQuery\n-{\n-    public:\n-        TruncateQuery(PtrTo<ClusterClause> cluster, bool temporary, bool if_exists, PtrTo<TableIdentifier> identifier);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            NAME = 0,  // TableIdentifier\n-        };\n-\n-        const bool temporary, if_exists;\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/UseQuery.cpp b/src/Parsers/New/AST/UseQuery.cpp\ndeleted file mode 100644\nindex 4dd4d564c278..000000000000\n--- a/src/Parsers/New/AST/UseQuery.cpp\n+++ /dev/null\n@@ -1,37 +0,0 @@\n-#include <Parsers/New/AST/UseQuery.h>\n-\n-#include <Parsers/ASTUseQuery.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-UseQuery::UseQuery(PtrTo<DatabaseIdentifier> identifier)\n-{\n-    push(identifier);\n-}\n-\n-ASTPtr UseQuery::convertToOld() const\n-{\n-    auto query = std::make_shared<ASTUseQuery>();\n-\n-    query->database = get<DatabaseIdentifier>(DATABASE)->getName();\n-\n-    return query;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitUseStmt(ClickHouseParser::UseStmtContext *ctx)\n-{\n-    return std::make_shared<UseQuery>(visit(ctx->databaseIdentifier()).as<PtrTo<DatabaseIdentifier>>());\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/UseQuery.h b/src/Parsers/New/AST/UseQuery.h\ndeleted file mode 100644\nindex c71f271edb57..000000000000\n--- a/src/Parsers/New/AST/UseQuery.h\n+++ /dev/null\n@@ -1,23 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/Query.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class UseQuery : public Query\n-{\n-    public:\n-        explicit UseQuery(PtrTo<DatabaseIdentifier> identifier);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            DATABASE = 0,\n-        };\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/WatchQuery.cpp b/src/Parsers/New/AST/WatchQuery.cpp\ndeleted file mode 100644\nindex 14d71007232f..000000000000\n--- a/src/Parsers/New/AST/WatchQuery.cpp\n+++ /dev/null\n@@ -1,51 +0,0 @@\n-#include <Parsers/New/AST/WatchQuery.h>\n-\n-#include <Interpreters/StorageID.h>\n-#include <Parsers/ASTIdentifier.h>\n-#include <Parsers/ASTWatchQuery.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/AST/Literal.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-WatchQuery::WatchQuery(bool events_, PtrTo<TableIdentifier> identifier, PtrTo<NumberLiteral> literal)\n-    : Query{identifier, literal}, events(events_)\n-{\n-}\n-\n-ASTPtr WatchQuery::convertToOld() const\n-{\n-    auto query = std::make_shared<ASTWatchQuery>();\n-\n-    auto table = std::static_pointer_cast<ASTTableIdentifier>(get(TABLE)->convertToOld());\n-    query->database = table->getDatabaseName();\n-    query->table = table->shortName();\n-    query->uuid = table->uuid;\n-\n-    query->is_watch_events = events;\n-\n-    if (has(LIMIT))\n-        query->limit_length = get(LIMIT)->convertToOld();\n-\n-    convertToOldPartially(query);\n-\n-    return query;\n-}\n-\n-}\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitWatchStmt(ClickHouseParser::WatchStmtContext *ctx)\n-{\n-    auto limit = ctx->DECIMAL_LITERAL() ? Literal::createNumber(ctx->DECIMAL_LITERAL()) : nullptr;\n-    return std::make_shared<WatchQuery>(!!ctx->EVENTS(), visit(ctx->tableIdentifier()), limit);\n-}\n-\n-}\ndiff --git a/src/Parsers/New/AST/WatchQuery.h b/src/Parsers/New/AST/WatchQuery.h\ndeleted file mode 100644\nindex 041f71b75ffe..000000000000\n--- a/src/Parsers/New/AST/WatchQuery.h\n+++ /dev/null\n@@ -1,26 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/AST/Query.h>\n-\n-\n-namespace DB::AST\n-{\n-\n-class WatchQuery : public Query\n-{\n-    public:\n-        WatchQuery(bool events, PtrTo<TableIdentifier> identifier, PtrTo<NumberLiteral> literal);\n-\n-        ASTPtr convertToOld() const override;\n-\n-    private:\n-        enum ChildIndex : UInt8\n-        {\n-            TABLE = 0,  // TableIdentifier\n-            LIMIT = 1,  // NumberLiteral (optional)\n-        };\n-\n-        const bool events;\n-};\n-\n-}\ndiff --git a/src/Parsers/New/AST/fwd_decl.h b/src/Parsers/New/AST/fwd_decl.h\ndeleted file mode 100644\nindex 4f9bde4bbbbe..000000000000\n--- a/src/Parsers/New/AST/fwd_decl.h\n+++ /dev/null\n@@ -1,91 +0,0 @@\n-#pragma once\n-\n-#include <memory>\n-#include <vector>\n-\n-\n-namespace DB::AST\n-{\n-\n-class INode;\n-\n-template <class T, char Separator = ','>\n-class List;\n-\n-template <class T>\n-class SimpleClause;\n-\n-template <class T = INode>\n-using PtrTo = std::shared_ptr<T>;\n-\n-using Ptr = PtrTo<>;\n-using PtrList = std::vector<Ptr>;\n-\n-class AssignmentExpr;\n-class CodecArgExpr;\n-class CodecExpr;\n-class ColumnExpr;\n-class ColumnFunctionExpr;\n-class ColumnIdentifier;\n-class ColumnLambdaExpr;\n-class ColumnTypeExpr;\n-class DatabaseIdentifier;\n-class DictionaryArgExpr;\n-class DictionaryAttributeExpr;\n-class EngineClause;\n-class EngineExpr;\n-class EnumValue;\n-class Identifier;\n-class JoinExpr;\n-class JsonExpr;\n-class JsonValue;\n-class LimitExpr;\n-class Literal;\n-class NumberLiteral;\n-class OrderExpr;\n-class PartitionClause;\n-class Query;\n-class RatioExpr;\n-class TableSchemaClause;\n-class ProjectionSelectStmt;\n-class SelectStmt;\n-class SelectUnionQuery;\n-class SettingExpr;\n-class SettingsClause;\n-class StringLiteral;\n-class TableArgExpr;\n-class TableColumnPropertyExpr;\n-class TableElementExpr;\n-class TableExpr;\n-class TableFunctionExpr;\n-class TableIdentifier;\n-class TTLExpr;\n-\n-using AssignmentExprList = List<AssignmentExpr>;\n-using CodecArgList = List<CodecArgExpr>;\n-using ColumnExprList = List<ColumnExpr>;\n-using ColumnNameList = List<Identifier>;\n-using ColumnParamList = ColumnExprList;\n-using ColumnTypeExprList = List<ColumnTypeExpr>;\n-using DictionaryArgList = List<DictionaryArgExpr, 0>;\n-using DictionaryAttributeList = List<DictionaryAttributeExpr>;\n-using EnumValueList = List<EnumValue>;\n-using JsonExprList = List<JsonExpr>;\n-using JsonValueList = List<JsonValue>;\n-using OrderExprList = List<OrderExpr>;\n-using QueryList = List<Query, ';'>;\n-using SettingExprList = List<SettingExpr>;\n-using TableArgList = List<TableArgExpr>;\n-using TableElementList = List<TableElementExpr>;\n-using TTLExprList = List<TTLExpr>;\n-\n-using ClusterClause = SimpleClause<StringLiteral>;\n-using DestinationClause = SimpleClause<TableIdentifier>;\n-using OrderByClause = SimpleClause<OrderExprList>;\n-using ProjectionOrderByClause = SimpleClause<ColumnExprList>;\n-using PrimaryKeyClause = SimpleClause<ColumnExpr>;\n-using TTLClause = SimpleClause<TTLExprList>;\n-using UUIDClause = SimpleClause<StringLiteral>;\n-using WhereClause = SimpleClause<ColumnExpr>;\n-\n-}\ndiff --git a/src/Parsers/New/CMakeLists.txt b/src/Parsers/New/CMakeLists.txt\ndeleted file mode 100644\nindex b045b0cc1235..000000000000\n--- a/src/Parsers/New/CMakeLists.txt\n+++ /dev/null\n@@ -1,93 +0,0 @@\n-set (SRCS\n-    AST/AlterTableQuery.cpp\n-    AST/AttachQuery.cpp\n-    AST/CheckQuery.cpp\n-    AST/ColumnExpr.cpp\n-    AST/ColumnTypeExpr.cpp\n-    AST/CreateDatabaseQuery.cpp\n-    AST/CreateDictionaryQuery.cpp\n-    AST/CreateLiveViewQuery.cpp\n-    AST/CreateMaterializedViewQuery.cpp\n-    AST/CreateTableQuery.cpp\n-    AST/CreateViewQuery.cpp\n-    AST/DDLQuery.cpp\n-    AST/DescribeQuery.cpp\n-    AST/DropQuery.cpp\n-    AST/EngineExpr.cpp\n-    AST/ExistsQuery.cpp\n-    AST/ExplainQuery.cpp\n-    AST/Identifier.cpp\n-    AST/InsertQuery.cpp\n-    AST/JoinExpr.cpp\n-    AST/KillQuery.cpp\n-    AST/LimitExpr.cpp\n-    AST/Literal.cpp\n-    AST/OptimizeQuery.cpp\n-    AST/OrderExpr.cpp\n-    AST/Query.cpp\n-    AST/RatioExpr.cpp\n-    AST/RenameQuery.cpp\n-    AST/SelectUnionQuery.cpp\n-    AST/SetQuery.cpp\n-    AST/SettingExpr.cpp\n-    AST/ShowCreateQuery.cpp\n-    AST/ShowQuery.cpp\n-    AST/SystemQuery.cpp\n-    AST/TableElementExpr.cpp\n-    AST/TableExpr.cpp\n-    AST/TruncateQuery.cpp\n-    AST/UseQuery.cpp\n-    AST/WatchQuery.cpp\n-    CharInputStream.cpp\n-    ClickHouseLexer.cpp\n-    ClickHouseParser.cpp\n-    ClickHouseParserVisitor.cpp\n-    LexerErrorListener.cpp\n-    parseQuery.cpp\n-    ParserErrorListener.cpp\n-    ParseTreeVisitor.cpp\n-)\n-\n-add_library (clickhouse_parsers_new ${SRCS})\n-\n-target_compile_options (clickhouse_parsers_new\n-    PRIVATE\n-        -Wno-c++2a-compat\n-        -Wno-deprecated-this-capture\n-        -Wno-documentation-html\n-        -Wno-documentation\n-        -Wno-documentation-deprecated-sync\n-        -Wno-shadow-field\n-        -Wno-unused-parameter\n-        -Wno-extra-semi\n-        -Wno-inconsistent-missing-destructor-override\n-)\n-\n-# XXX: hack for old clang-10!\n-if (HAS_SUGGEST_DESTRUCTOR_OVERRIDE)\n-    target_compile_options (clickhouse_parsers_new\n-        PRIVATE\n-            -Wno-suggest-destructor-override\n-    )\n-endif ()\n-\n-# XXX: hack for old gcc-10!\n-if (HAS_SHADOW)\n-    target_compile_options (clickhouse_parsers_new\n-        PRIVATE\n-            -Wno-shadow\n-    )\n-endif ()\n-\n-target_link_libraries (clickhouse_parsers_new PUBLIC antlr4-runtime clickhouse_common_io clickhouse_parsers)\n-\n-# ANTLR generates u8 string literals, which are incompatible with |std::string| in C++20.\n-# See https://github.com/antlr/antlr4/issues/2683\n-set_source_files_properties(\n-        ClickHouseLexer.cpp\n-        ClickHouseParser.cpp\n-    PROPERTIES COMPILE_FLAGS -std=c++17\n-)\n-\n-# Disable clang-tidy for whole target.\n-set_target_properties(clickhouse_parsers_new PROPERTIES CXX_CLANG_TIDY \"\")\ndiff --git a/src/Parsers/New/CharInputStream.cpp b/src/Parsers/New/CharInputStream.cpp\ndeleted file mode 100644\nindex 71cccafae50f..000000000000\n--- a/src/Parsers/New/CharInputStream.cpp\n+++ /dev/null\n@@ -1,79 +0,0 @@\n-#include <Parsers/New/CharInputStream.h>\n-\n-#include <Exceptions.h>\n-\n-\n-namespace DB\n-{\n-\n-using namespace antlr4;\n-\n-CharInputStream::CharInputStream(const char * begin, const char * end)\n-{\n-    d = begin;\n-    s = end - begin;\n-}\n-\n-size_t CharInputStream::LA(ssize_t i)\n-{\n-    if (i == 0) return 0;  // undefined\n-\n-    ssize_t position = static_cast<ssize_t>(p);\n-    if (i < 0)\n-    {\n-        i++; // e.g., translate LA(-1) to use offset i=0; then data[p+0-1]\n-        if ((position + i - 1) < 0)\n-            return IntStream::EOF; // invalid; no char before first char\n-    }\n-\n-    if ((position + i - 1) >= static_cast<ssize_t>(s))\n-        return IntStream::EOF;\n-\n-    return d[static_cast<size_t>((position + i - 1))];\n-}\n-\n-void CharInputStream::consume()\n-{\n-    if (p >= s)\n-    {\n-        assert(LA(1) == IntStream::EOF);\n-        throw IllegalStateException(\"cannot consume EOF\");\n-    }\n-\n-    ++p;\n-}\n-\n-void CharInputStream::seek(size_t i)\n-{\n-    if (i <= p)\n-    {\n-        p = i; // just jump; don't update stream state (line, ...)\n-        return;\n-    }\n-\n-    // seek forward, consume until p hits index or s (whichever comes first)\n-    i = std::min(i, s);\n-    while (p < i)\n-        consume();\n-}\n-\n-std::string CharInputStream::getText(const antlr4::misc::Interval &interval)\n-{\n-    if (interval.a < 0 || interval.b < 0)\n-        return {};\n-\n-    size_t start = static_cast<size_t>(interval.a);\n-    size_t stop = static_cast<size_t>(interval.b);\n-\n-\n-    if (stop >= s)\n-        stop = s - 1;\n-\n-    size_t count = stop - start + 1;\n-    if (start >= s)\n-        return \"\";\n-\n-    return {d + start, count};\n-}\n-\n-}\ndiff --git a/src/Parsers/New/CharInputStream.h b/src/Parsers/New/CharInputStream.h\ndeleted file mode 100644\nindex 735f5c2bc38c..000000000000\n--- a/src/Parsers/New/CharInputStream.h\n+++ /dev/null\n@@ -1,34 +0,0 @@\n-#pragma once\n-\n-#include <CharStream.h>\n-\n-\n-namespace DB\n-{\n-\n-class CharInputStream : public antlr4::CharStream\n-{\n-    public:\n-        CharInputStream(const char * begin, const char * end);\n-\n-    private:\n-        const char * d;\n-        size_t s = 0;\n-        size_t p = 0;\n-\n-        size_t index() override { return p; }\n-        size_t size() override { return s; }\n-\n-        size_t LA(ssize_t i) override;\n-        void consume() override;\n-        void seek(size_t i) override;\n-\n-        ssize_t mark() override { return -1; }\n-        void release(ssize_t marker) override {};\n-\n-        std::string getSourceName() const override { return \"CharInputStream\"; };\n-        std::string getText(const antlr4::misc::Interval &interval) override;\n-        std::string toString() const override { return {d, s}; }\n-};\n-\n-}\ndiff --git a/src/Parsers/New/ClickHouseLexer.cpp b/src/Parsers/New/ClickHouseLexer.cpp\ndeleted file mode 100644\nindex 7fb2a0effaa9..000000000000\n--- a/src/Parsers/New/ClickHouseLexer.cpp\n+++ /dev/null\n@@ -1,1603 +0,0 @@\n-\n-// Generated from ClickHouseLexer.g4 by ANTLR 4.7.2\n-\n-\n-#include \"ClickHouseLexer.h\"\n-\n-\n-using namespace antlr4;\n-\n-using namespace DB;\n-\n-ClickHouseLexer::ClickHouseLexer(CharStream *input) : Lexer(input) {\n-  _interpreter = new atn::LexerATNSimulator(this, _atn, _decisionToDFA, _sharedContextCache);\n-}\n-\n-ClickHouseLexer::~ClickHouseLexer() {\n-  delete _interpreter;\n-}\n-\n-std::string ClickHouseLexer::getGrammarFileName() const {\n-  return \"ClickHouseLexer.g4\";\n-}\n-\n-const std::vector<std::string>& ClickHouseLexer::getRuleNames() const {\n-  return _ruleNames;\n-}\n-\n-const std::vector<std::string>& ClickHouseLexer::getChannelNames() const {\n-  return _channelNames;\n-}\n-\n-const std::vector<std::string>& ClickHouseLexer::getModeNames() const {\n-  return _modeNames;\n-}\n-\n-const std::vector<std::string>& ClickHouseLexer::getTokenNames() const {\n-  return _tokenNames;\n-}\n-\n-dfa::Vocabulary& ClickHouseLexer::getVocabulary() const {\n-  return _vocabulary;\n-}\n-\n-const std::vector<uint16_t> ClickHouseLexer::getSerializedATN() const {\n-  return _serializedATN;\n-}\n-\n-const atn::ATN& ClickHouseLexer::getATN() const {\n-  return _atn;\n-}\n-\n-\n-\n-\n-// Static vars and initialization.\n-std::vector<dfa::DFA> ClickHouseLexer::_decisionToDFA;\n-atn::PredictionContextCache ClickHouseLexer::_sharedContextCache;\n-\n-// We own the ATN which in turn owns the ATN states.\n-atn::ATN ClickHouseLexer::_atn;\n-std::vector<uint16_t> ClickHouseLexer::_serializedATN;\n-\n-std::vector<std::string> ClickHouseLexer::_ruleNames = {\n-  u8\"ADD\", u8\"AFTER\", u8\"ALIAS\", u8\"ALL\", u8\"ALTER\", u8\"AND\", u8\"ANTI\", \n-  u8\"ANY\", u8\"ARRAY\", u8\"AS\", u8\"ASCENDING\", u8\"ASOF\", u8\"AST\", u8\"ASYNC\", \n-  u8\"ATTACH\", u8\"BETWEEN\", u8\"BOTH\", u8\"BY\", u8\"CASE\", u8\"CAST\", u8\"CHECK\", \n-  u8\"CLEAR\", u8\"CLUSTER\", u8\"CODEC\", u8\"COLLATE\", u8\"COLUMN\", u8\"COMMENT\", \n-  u8\"CONSTRAINT\", u8\"CREATE\", u8\"CROSS\", u8\"CUBE\", u8\"DATABASE\", u8\"DATABASES\", \n-  u8\"DATE\", u8\"DAY\", u8\"DEDUPLICATE\", u8\"DEFAULT\", u8\"DELAY\", u8\"DELETE\", \n-  u8\"DESC\", u8\"DESCENDING\", u8\"DESCRIBE\", u8\"DETACH\", u8\"DICTIONARIES\", \n-  u8\"DICTIONARY\", u8\"DISK\", u8\"DISTINCT\", u8\"DISTRIBUTED\", u8\"DROP\", u8\"ELSE\", \n-  u8\"END\", u8\"ENGINE\", u8\"EVENTS\", u8\"EXISTS\", u8\"EXPLAIN\", u8\"EXPRESSION\", \n-  u8\"EXTRACT\", u8\"FETCHES\", u8\"FINAL\", u8\"FIRST\", u8\"FLUSH\", u8\"FOR\", u8\"FORMAT\", \n-  u8\"FREEZE\", u8\"FROM\", u8\"FULL\", u8\"FUNCTION\", u8\"GLOBAL\", u8\"GRANULARITY\", \n-  u8\"GROUP\", u8\"HAVING\", u8\"HIERARCHICAL\", u8\"HOUR\", u8\"ID\", u8\"IF\", u8\"ILIKE\", \n-  u8\"IN\", u8\"INDEX\", u8\"INF\", u8\"INJECTIVE\", u8\"INNER\", u8\"INSERT\", u8\"INTERVAL\", \n-  u8\"INTO\", u8\"IS\", u8\"IS_OBJECT_ID\", u8\"JOIN\", u8\"KEY\", u8\"KILL\", u8\"LAST\", \n-  u8\"LAYOUT\", u8\"LEADING\", u8\"LEFT\", u8\"LIFETIME\", u8\"LIKE\", u8\"LIMIT\", \n-  u8\"LIVE\", u8\"LOCAL\", u8\"LOGS\", u8\"MATERIALIZE\", u8\"MATERIALIZED\", u8\"MAX\", \n-  u8\"MERGES\", u8\"MIN\", u8\"MINUTE\", u8\"MODIFY\", u8\"MONTH\", u8\"MOVE\", u8\"MUTATION\", \n-  u8\"NAN_SQL\", u8\"NO\", u8\"NOT\", u8\"NULL_SQL\", u8\"NULLS\", u8\"OFFSET\", u8\"ON\", \n-  u8\"OPTIMIZE\", u8\"OR\", u8\"ORDER\", u8\"OUTER\", u8\"OUTFILE\", u8\"PARTITION\", \n-  u8\"POPULATE\", u8\"PREWHERE\", u8\"PRIMARY\", u8\"PROJECTION\", u8\"QUARTER\", \n-  u8\"RANGE\", u8\"RELOAD\", u8\"REMOVE\", u8\"RENAME\", u8\"REPLACE\", u8\"REPLICA\", \n-  u8\"REPLICATED\", u8\"RIGHT\", u8\"ROLLUP\", u8\"SAMPLE\", u8\"SECOND\", u8\"SELECT\", \n-  u8\"SEMI\", u8\"SENDS\", u8\"SET\", u8\"SETTINGS\", u8\"SHOW\", u8\"SOURCE\", u8\"START\", \n-  u8\"STOP\", u8\"SUBSTRING\", u8\"SYNC\", u8\"SYNTAX\", u8\"SYSTEM\", u8\"TABLE\", \n-  u8\"TABLES\", u8\"TEMPORARY\", u8\"TEST\", u8\"THEN\", u8\"TIES\", u8\"TIMEOUT\", \n-  u8\"TIMESTAMP\", u8\"TO\", u8\"TOP\", u8\"TOTALS\", u8\"TRAILING\", u8\"TRIM\", u8\"TRUNCATE\", \n-  u8\"TTL\", u8\"TYPE\", u8\"UNION\", u8\"UPDATE\", u8\"USE\", u8\"USING\", u8\"UUID\", \n-  u8\"VALUES\", u8\"VIEW\", u8\"VOLUME\", u8\"WATCH\", u8\"WEEK\", u8\"WHEN\", u8\"WHERE\", \n-  u8\"WITH\", u8\"YEAR\", u8\"JSON_FALSE\", u8\"JSON_TRUE\", u8\"IDENTIFIER\", u8\"FLOATING_LITERAL\", \n-  u8\"OCTAL_LITERAL\", u8\"DECIMAL_LITERAL\", u8\"HEXADECIMAL_LITERAL\", u8\"STRING_LITERAL\", \n-  u8\"A\", u8\"B\", u8\"C\", u8\"D\", u8\"E\", u8\"F\", u8\"G\", u8\"H\", u8\"I\", u8\"J\", \n-  u8\"K\", u8\"L\", u8\"M\", u8\"N\", u8\"O\", u8\"P\", u8\"Q\", u8\"R\", u8\"S\", u8\"T\", \n-  u8\"U\", u8\"V\", u8\"W\", u8\"X\", u8\"Y\", u8\"Z\", u8\"LETTER\", u8\"OCT_DIGIT\", u8\"DEC_DIGIT\", \n-  u8\"HEX_DIGIT\", u8\"ARROW\", u8\"ASTERISK\", u8\"BACKQUOTE\", u8\"BACKSLASH\", \n-  u8\"COLON\", u8\"COMMA\", u8\"CONCAT\", u8\"DASH\", u8\"DOT\", u8\"EQ_DOUBLE\", u8\"EQ_SINGLE\", \n-  u8\"GE\", u8\"GT\", u8\"LBRACE\", u8\"LBRACKET\", u8\"LE\", u8\"LPAREN\", u8\"LT\", \n-  u8\"NOT_EQ\", u8\"PERCENT\", u8\"PLUS\", u8\"QUERY\", u8\"QUOTE_DOUBLE\", u8\"QUOTE_SINGLE\", \n-  u8\"RBRACE\", u8\"RBRACKET\", u8\"RPAREN\", u8\"SEMICOLON\", u8\"SLASH\", u8\"UNDERSCORE\", \n-  u8\"MULTI_LINE_COMMENT\", u8\"SINGLE_LINE_COMMENT\", u8\"WHITESPACE\"\n-};\n-\n-std::vector<std::string> ClickHouseLexer::_channelNames = {\n-  \"DEFAULT_TOKEN_CHANNEL\", \"HIDDEN\"\n-};\n-\n-std::vector<std::string> ClickHouseLexer::_modeNames = {\n-  u8\"DEFAULT_MODE\"\n-};\n-\n-std::vector<std::string> ClickHouseLexer::_literalNames = {\n-  \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \n-  \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \n-  \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \n-  \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \n-  \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \n-  \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \n-  \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \n-  \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \n-  \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \n-  \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \n-  \"\", \"\", u8\"'false'\", u8\"'true'\", \"\", \"\", \"\", \"\", \"\", \"\", u8\"'->'\", u8\"'*'\", \n-  u8\"'`'\", u8\"'\\\\'\", u8\"':'\", u8\"','\", u8\"'||'\", u8\"'-'\", u8\"'.'\", u8\"'=='\", \n-  u8\"'='\", u8\"'>='\", u8\"'>'\", u8\"'{'\", u8\"'['\", u8\"'<='\", u8\"'('\", u8\"'<'\", \n-  \"\", u8\"'%'\", u8\"'+'\", u8\"'?'\", u8\"'\\\"'\", u8\"'''\", u8\"'}'\", u8\"']'\", u8\"')'\", \n-  u8\"';'\", u8\"'/'\", u8\"'_'\"\n-};\n-\n-std::vector<std::string> ClickHouseLexer::_symbolicNames = {\n-  \"\", u8\"ADD\", u8\"AFTER\", u8\"ALIAS\", u8\"ALL\", u8\"ALTER\", u8\"AND\", u8\"ANTI\", \n-  u8\"ANY\", u8\"ARRAY\", u8\"AS\", u8\"ASCENDING\", u8\"ASOF\", u8\"AST\", u8\"ASYNC\", \n-  u8\"ATTACH\", u8\"BETWEEN\", u8\"BOTH\", u8\"BY\", u8\"CASE\", u8\"CAST\", u8\"CHECK\", \n-  u8\"CLEAR\", u8\"CLUSTER\", u8\"CODEC\", u8\"COLLATE\", u8\"COLUMN\", u8\"COMMENT\", \n-  u8\"CONSTRAINT\", u8\"CREATE\", u8\"CROSS\", u8\"CUBE\", u8\"DATABASE\", u8\"DATABASES\", \n-  u8\"DATE\", u8\"DAY\", u8\"DEDUPLICATE\", u8\"DEFAULT\", u8\"DELAY\", u8\"DELETE\", \n-  u8\"DESC\", u8\"DESCENDING\", u8\"DESCRIBE\", u8\"DETACH\", u8\"DICTIONARIES\", \n-  u8\"DICTIONARY\", u8\"DISK\", u8\"DISTINCT\", u8\"DISTRIBUTED\", u8\"DROP\", u8\"ELSE\", \n-  u8\"END\", u8\"ENGINE\", u8\"EVENTS\", u8\"EXISTS\", u8\"EXPLAIN\", u8\"EXPRESSION\", \n-  u8\"EXTRACT\", u8\"FETCHES\", u8\"FINAL\", u8\"FIRST\", u8\"FLUSH\", u8\"FOR\", u8\"FORMAT\", \n-  u8\"FREEZE\", u8\"FROM\", u8\"FULL\", u8\"FUNCTION\", u8\"GLOBAL\", u8\"GRANULARITY\", \n-  u8\"GROUP\", u8\"HAVING\", u8\"HIERARCHICAL\", u8\"HOUR\", u8\"ID\", u8\"IF\", u8\"ILIKE\", \n-  u8\"IN\", u8\"INDEX\", u8\"INF\", u8\"INJECTIVE\", u8\"INNER\", u8\"INSERT\", u8\"INTERVAL\", \n-  u8\"INTO\", u8\"IS\", u8\"IS_OBJECT_ID\", u8\"JOIN\", u8\"KEY\", u8\"KILL\", u8\"LAST\", \n-  u8\"LAYOUT\", u8\"LEADING\", u8\"LEFT\", u8\"LIFETIME\", u8\"LIKE\", u8\"LIMIT\", \n-  u8\"LIVE\", u8\"LOCAL\", u8\"LOGS\", u8\"MATERIALIZE\", u8\"MATERIALIZED\", u8\"MAX\", \n-  u8\"MERGES\", u8\"MIN\", u8\"MINUTE\", u8\"MODIFY\", u8\"MONTH\", u8\"MOVE\", u8\"MUTATION\", \n-  u8\"NAN_SQL\", u8\"NO\", u8\"NOT\", u8\"NULL_SQL\", u8\"NULLS\", u8\"OFFSET\", u8\"ON\", \n-  u8\"OPTIMIZE\", u8\"OR\", u8\"ORDER\", u8\"OUTER\", u8\"OUTFILE\", u8\"PARTITION\", \n-  u8\"POPULATE\", u8\"PREWHERE\", u8\"PRIMARY\", u8\"PROJECTION\", u8\"QUARTER\", \n-  u8\"RANGE\", u8\"RELOAD\", u8\"REMOVE\", u8\"RENAME\", u8\"REPLACE\", u8\"REPLICA\", \n-  u8\"REPLICATED\", u8\"RIGHT\", u8\"ROLLUP\", u8\"SAMPLE\", u8\"SECOND\", u8\"SELECT\", \n-  u8\"SEMI\", u8\"SENDS\", u8\"SET\", u8\"SETTINGS\", u8\"SHOW\", u8\"SOURCE\", u8\"START\", \n-  u8\"STOP\", u8\"SUBSTRING\", u8\"SYNC\", u8\"SYNTAX\", u8\"SYSTEM\", u8\"TABLE\", \n-  u8\"TABLES\", u8\"TEMPORARY\", u8\"TEST\", u8\"THEN\", u8\"TIES\", u8\"TIMEOUT\", \n-  u8\"TIMESTAMP\", u8\"TO\", u8\"TOP\", u8\"TOTALS\", u8\"TRAILING\", u8\"TRIM\", u8\"TRUNCATE\", \n-  u8\"TTL\", u8\"TYPE\", u8\"UNION\", u8\"UPDATE\", u8\"USE\", u8\"USING\", u8\"UUID\", \n-  u8\"VALUES\", u8\"VIEW\", u8\"VOLUME\", u8\"WATCH\", u8\"WEEK\", u8\"WHEN\", u8\"WHERE\", \n-  u8\"WITH\", u8\"YEAR\", u8\"JSON_FALSE\", u8\"JSON_TRUE\", u8\"IDENTIFIER\", u8\"FLOATING_LITERAL\", \n-  u8\"OCTAL_LITERAL\", u8\"DECIMAL_LITERAL\", u8\"HEXADECIMAL_LITERAL\", u8\"STRING_LITERAL\", \n-  u8\"ARROW\", u8\"ASTERISK\", u8\"BACKQUOTE\", u8\"BACKSLASH\", u8\"COLON\", u8\"COMMA\", \n-  u8\"CONCAT\", u8\"DASH\", u8\"DOT\", u8\"EQ_DOUBLE\", u8\"EQ_SINGLE\", u8\"GE\", u8\"GT\", \n-  u8\"LBRACE\", u8\"LBRACKET\", u8\"LE\", u8\"LPAREN\", u8\"LT\", u8\"NOT_EQ\", u8\"PERCENT\", \n-  u8\"PLUS\", u8\"QUERY\", u8\"QUOTE_DOUBLE\", u8\"QUOTE_SINGLE\", u8\"RBRACE\", u8\"RBRACKET\", \n-  u8\"RPAREN\", u8\"SEMICOLON\", u8\"SLASH\", u8\"UNDERSCORE\", u8\"MULTI_LINE_COMMENT\", \n-  u8\"SINGLE_LINE_COMMENT\", u8\"WHITESPACE\"\n-};\n-\n-dfa::Vocabulary ClickHouseLexer::_vocabulary(_literalNames, _symbolicNames);\n-\n-std::vector<std::string> ClickHouseLexer::_tokenNames;\n-\n-ClickHouseLexer::Initializer::Initializer() {\n-  // This code could be in a static initializer lambda, but VS doesn't allow access to private class members from there.\n-\tfor (size_t i = 0; i < _symbolicNames.size(); ++i) {\n-\t\tstd::string name = _vocabulary.getLiteralName(i);\n-\t\tif (name.empty()) {\n-\t\t\tname = _vocabulary.getSymbolicName(i);\n-\t\t}\n-\n-\t\tif (name.empty()) {\n-\t\t\t_tokenNames.push_back(\"<INVALID>\");\n-\t\t} else {\n-      _tokenNames.push_back(name);\n-    }\n-\t}\n-\n-  _serializedATN = {\n-    0x3, 0x608b, 0xa72a, 0x8133, 0xb9ed, 0x417c, 0x3be7, 0x7786, 0x5964, \n-    0x2, 0xe0, 0x803, 0x8, 0x1, 0x4, 0x2, 0x9, 0x2, 0x4, 0x3, 0x9, 0x3, \n-    0x4, 0x4, 0x9, 0x4, 0x4, 0x5, 0x9, 0x5, 0x4, 0x6, 0x9, 0x6, 0x4, 0x7, \n-    0x9, 0x7, 0x4, 0x8, 0x9, 0x8, 0x4, 0x9, 0x9, 0x9, 0x4, 0xa, 0x9, 0xa, \n-    0x4, 0xb, 0x9, 0xb, 0x4, 0xc, 0x9, 0xc, 0x4, 0xd, 0x9, 0xd, 0x4, 0xe, \n-    0x9, 0xe, 0x4, 0xf, 0x9, 0xf, 0x4, 0x10, 0x9, 0x10, 0x4, 0x11, 0x9, \n-    0x11, 0x4, 0x12, 0x9, 0x12, 0x4, 0x13, 0x9, 0x13, 0x4, 0x14, 0x9, 0x14, \n-    0x4, 0x15, 0x9, 0x15, 0x4, 0x16, 0x9, 0x16, 0x4, 0x17, 0x9, 0x17, 0x4, \n-    0x18, 0x9, 0x18, 0x4, 0x19, 0x9, 0x19, 0x4, 0x1a, 0x9, 0x1a, 0x4, 0x1b, \n-    0x9, 0x1b, 0x4, 0x1c, 0x9, 0x1c, 0x4, 0x1d, 0x9, 0x1d, 0x4, 0x1e, 0x9, \n-    0x1e, 0x4, 0x1f, 0x9, 0x1f, 0x4, 0x20, 0x9, 0x20, 0x4, 0x21, 0x9, 0x21, \n-    0x4, 0x22, 0x9, 0x22, 0x4, 0x23, 0x9, 0x23, 0x4, 0x24, 0x9, 0x24, 0x4, \n-    0x25, 0x9, 0x25, 0x4, 0x26, 0x9, 0x26, 0x4, 0x27, 0x9, 0x27, 0x4, 0x28, \n-    0x9, 0x28, 0x4, 0x29, 0x9, 0x29, 0x4, 0x2a, 0x9, 0x2a, 0x4, 0x2b, 0x9, \n-    0x2b, 0x4, 0x2c, 0x9, 0x2c, 0x4, 0x2d, 0x9, 0x2d, 0x4, 0x2e, 0x9, 0x2e, \n-    0x4, 0x2f, 0x9, 0x2f, 0x4, 0x30, 0x9, 0x30, 0x4, 0x31, 0x9, 0x31, 0x4, \n-    0x32, 0x9, 0x32, 0x4, 0x33, 0x9, 0x33, 0x4, 0x34, 0x9, 0x34, 0x4, 0x35, \n-    0x9, 0x35, 0x4, 0x36, 0x9, 0x36, 0x4, 0x37, 0x9, 0x37, 0x4, 0x38, 0x9, \n-    0x38, 0x4, 0x39, 0x9, 0x39, 0x4, 0x3a, 0x9, 0x3a, 0x4, 0x3b, 0x9, 0x3b, \n-    0x4, 0x3c, 0x9, 0x3c, 0x4, 0x3d, 0x9, 0x3d, 0x4, 0x3e, 0x9, 0x3e, 0x4, \n-    0x3f, 0x9, 0x3f, 0x4, 0x40, 0x9, 0x40, 0x4, 0x41, 0x9, 0x41, 0x4, 0x42, \n-    0x9, 0x42, 0x4, 0x43, 0x9, 0x43, 0x4, 0x44, 0x9, 0x44, 0x4, 0x45, 0x9, \n-    0x45, 0x4, 0x46, 0x9, 0x46, 0x4, 0x47, 0x9, 0x47, 0x4, 0x48, 0x9, 0x48, \n-    0x4, 0x49, 0x9, 0x49, 0x4, 0x4a, 0x9, 0x4a, 0x4, 0x4b, 0x9, 0x4b, 0x4, \n-    0x4c, 0x9, 0x4c, 0x4, 0x4d, 0x9, 0x4d, 0x4, 0x4e, 0x9, 0x4e, 0x4, 0x4f, \n-    0x9, 0x4f, 0x4, 0x50, 0x9, 0x50, 0x4, 0x51, 0x9, 0x51, 0x4, 0x52, 0x9, \n-    0x52, 0x4, 0x53, 0x9, 0x53, 0x4, 0x54, 0x9, 0x54, 0x4, 0x55, 0x9, 0x55, \n-    0x4, 0x56, 0x9, 0x56, 0x4, 0x57, 0x9, 0x57, 0x4, 0x58, 0x9, 0x58, 0x4, \n-    0x59, 0x9, 0x59, 0x4, 0x5a, 0x9, 0x5a, 0x4, 0x5b, 0x9, 0x5b, 0x4, 0x5c, \n-    0x9, 0x5c, 0x4, 0x5d, 0x9, 0x5d, 0x4, 0x5e, 0x9, 0x5e, 0x4, 0x5f, 0x9, \n-    0x5f, 0x4, 0x60, 0x9, 0x60, 0x4, 0x61, 0x9, 0x61, 0x4, 0x62, 0x9, 0x62, \n-    0x4, 0x63, 0x9, 0x63, 0x4, 0x64, 0x9, 0x64, 0x4, 0x65, 0x9, 0x65, 0x4, \n-    0x66, 0x9, 0x66, 0x4, 0x67, 0x9, 0x67, 0x4, 0x68, 0x9, 0x68, 0x4, 0x69, \n-    0x9, 0x69, 0x4, 0x6a, 0x9, 0x6a, 0x4, 0x6b, 0x9, 0x6b, 0x4, 0x6c, 0x9, \n-    0x6c, 0x4, 0x6d, 0x9, 0x6d, 0x4, 0x6e, 0x9, 0x6e, 0x4, 0x6f, 0x9, 0x6f, \n-    0x4, 0x70, 0x9, 0x70, 0x4, 0x71, 0x9, 0x71, 0x4, 0x72, 0x9, 0x72, 0x4, \n-    0x73, 0x9, 0x73, 0x4, 0x74, 0x9, 0x74, 0x4, 0x75, 0x9, 0x75, 0x4, 0x76, \n-    0x9, 0x76, 0x4, 0x77, 0x9, 0x77, 0x4, 0x78, 0x9, 0x78, 0x4, 0x79, 0x9, \n-    0x79, 0x4, 0x7a, 0x9, 0x7a, 0x4, 0x7b, 0x9, 0x7b, 0x4, 0x7c, 0x9, 0x7c, \n-    0x4, 0x7d, 0x9, 0x7d, 0x4, 0x7e, 0x9, 0x7e, 0x4, 0x7f, 0x9, 0x7f, 0x4, \n-    0x80, 0x9, 0x80, 0x4, 0x81, 0x9, 0x81, 0x4, 0x82, 0x9, 0x82, 0x4, 0x83, \n-    0x9, 0x83, 0x4, 0x84, 0x9, 0x84, 0x4, 0x85, 0x9, 0x85, 0x4, 0x86, 0x9, \n-    0x86, 0x4, 0x87, 0x9, 0x87, 0x4, 0x88, 0x9, 0x88, 0x4, 0x89, 0x9, 0x89, \n-    0x4, 0x8a, 0x9, 0x8a, 0x4, 0x8b, 0x9, 0x8b, 0x4, 0x8c, 0x9, 0x8c, 0x4, \n-    0x8d, 0x9, 0x8d, 0x4, 0x8e, 0x9, 0x8e, 0x4, 0x8f, 0x9, 0x8f, 0x4, 0x90, \n-    0x9, 0x90, 0x4, 0x91, 0x9, 0x91, 0x4, 0x92, 0x9, 0x92, 0x4, 0x93, 0x9, \n-    0x93, 0x4, 0x94, 0x9, 0x94, 0x4, 0x95, 0x9, 0x95, 0x4, 0x96, 0x9, 0x96, \n-    0x4, 0x97, 0x9, 0x97, 0x4, 0x98, 0x9, 0x98, 0x4, 0x99, 0x9, 0x99, 0x4, \n-    0x9a, 0x9, 0x9a, 0x4, 0x9b, 0x9, 0x9b, 0x4, 0x9c, 0x9, 0x9c, 0x4, 0x9d, \n-    0x9, 0x9d, 0x4, 0x9e, 0x9, 0x9e, 0x4, 0x9f, 0x9, 0x9f, 0x4, 0xa0, 0x9, \n-    0xa0, 0x4, 0xa1, 0x9, 0xa1, 0x4, 0xa2, 0x9, 0xa2, 0x4, 0xa3, 0x9, 0xa3, \n-    0x4, 0xa4, 0x9, 0xa4, 0x4, 0xa5, 0x9, 0xa5, 0x4, 0xa6, 0x9, 0xa6, 0x4, \n-    0xa7, 0x9, 0xa7, 0x4, 0xa8, 0x9, 0xa8, 0x4, 0xa9, 0x9, 0xa9, 0x4, 0xaa, \n-    0x9, 0xaa, 0x4, 0xab, 0x9, 0xab, 0x4, 0xac, 0x9, 0xac, 0x4, 0xad, 0x9, \n-    0xad, 0x4, 0xae, 0x9, 0xae, 0x4, 0xaf, 0x9, 0xaf, 0x4, 0xb0, 0x9, 0xb0, \n-    0x4, 0xb1, 0x9, 0xb1, 0x4, 0xb2, 0x9, 0xb2, 0x4, 0xb3, 0x9, 0xb3, 0x4, \n-    0xb4, 0x9, 0xb4, 0x4, 0xb5, 0x9, 0xb5, 0x4, 0xb6, 0x9, 0xb6, 0x4, 0xb7, \n-    0x9, 0xb7, 0x4, 0xb8, 0x9, 0xb8, 0x4, 0xb9, 0x9, 0xb9, 0x4, 0xba, 0x9, \n-    0xba, 0x4, 0xbb, 0x9, 0xbb, 0x4, 0xbc, 0x9, 0xbc, 0x4, 0xbd, 0x9, 0xbd, \n-    0x4, 0xbe, 0x9, 0xbe, 0x4, 0xbf, 0x9, 0xbf, 0x4, 0xc0, 0x9, 0xc0, 0x4, \n-    0xc1, 0x9, 0xc1, 0x4, 0xc2, 0x9, 0xc2, 0x4, 0xc3, 0x9, 0xc3, 0x4, 0xc4, \n-    0x9, 0xc4, 0x4, 0xc5, 0x9, 0xc5, 0x4, 0xc6, 0x9, 0xc6, 0x4, 0xc7, 0x9, \n-    0xc7, 0x4, 0xc8, 0x9, 0xc8, 0x4, 0xc9, 0x9, 0xc9, 0x4, 0xca, 0x9, 0xca, \n-    0x4, 0xcb, 0x9, 0xcb, 0x4, 0xcc, 0x9, 0xcc, 0x4, 0xcd, 0x9, 0xcd, 0x4, \n-    0xce, 0x9, 0xce, 0x4, 0xcf, 0x9, 0xcf, 0x4, 0xd0, 0x9, 0xd0, 0x4, 0xd1, \n-    0x9, 0xd1, 0x4, 0xd2, 0x9, 0xd2, 0x4, 0xd3, 0x9, 0xd3, 0x4, 0xd4, 0x9, \n-    0xd4, 0x4, 0xd5, 0x9, 0xd5, 0x4, 0xd6, 0x9, 0xd6, 0x4, 0xd7, 0x9, 0xd7, \n-    0x4, 0xd8, 0x9, 0xd8, 0x4, 0xd9, 0x9, 0xd9, 0x4, 0xda, 0x9, 0xda, 0x4, \n-    0xdb, 0x9, 0xdb, 0x4, 0xdc, 0x9, 0xdc, 0x4, 0xdd, 0x9, 0xdd, 0x4, 0xde, \n-    0x9, 0xde, 0x4, 0xdf, 0x9, 0xdf, 0x4, 0xe0, 0x9, 0xe0, 0x4, 0xe1, 0x9, \n-    0xe1, 0x4, 0xe2, 0x9, 0xe2, 0x4, 0xe3, 0x9, 0xe3, 0x4, 0xe4, 0x9, 0xe4, \n-    0x4, 0xe5, 0x9, 0xe5, 0x4, 0xe6, 0x9, 0xe6, 0x4, 0xe7, 0x9, 0xe7, 0x4, \n-    0xe8, 0x9, 0xe8, 0x4, 0xe9, 0x9, 0xe9, 0x4, 0xea, 0x9, 0xea, 0x4, 0xeb, \n-    0x9, 0xeb, 0x4, 0xec, 0x9, 0xec, 0x4, 0xed, 0x9, 0xed, 0x4, 0xee, 0x9, \n-    0xee, 0x4, 0xef, 0x9, 0xef, 0x4, 0xf0, 0x9, 0xf0, 0x4, 0xf1, 0x9, 0xf1, \n-    0x4, 0xf2, 0x9, 0xf2, 0x4, 0xf3, 0x9, 0xf3, 0x4, 0xf4, 0x9, 0xf4, 0x4, \n-    0xf5, 0x9, 0xf5, 0x4, 0xf6, 0x9, 0xf6, 0x4, 0xf7, 0x9, 0xf7, 0x4, 0xf8, \n-    0x9, 0xf8, 0x4, 0xf9, 0x9, 0xf9, 0x4, 0xfa, 0x9, 0xfa, 0x4, 0xfb, 0x9, \n-    0xfb, 0x4, 0xfc, 0x9, 0xfc, 0x4, 0xfd, 0x9, 0xfd, 0x3, 0x2, 0x3, 0x2, \n-    0x3, 0x2, 0x3, 0x2, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, \n-    0x3, 0x3, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, \n-    0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, \n-    0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, \n-    0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x9, 0x3, 0x9, \n-    0x3, 0x9, 0x3, 0x9, 0x3, 0xa, 0x3, 0xa, 0x3, 0xa, 0x3, 0xa, 0x3, 0xa, \n-    0x3, 0xa, 0x3, 0xb, 0x3, 0xb, 0x3, 0xb, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, \n-    0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, \n-    0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x5, 0xc, 0x23a, 0xa, 0xc, 0x3, \n-    0xd, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 0x3, 0xe, 0x3, 0xe, 0x3, \n-    0xe, 0x3, 0xe, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, \n-    0xf, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, \n-    0x3, 0x10, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, \n-    0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, \n-    0x3, 0x12, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x14, 0x3, 0x14, 0x3, \n-    0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, \n-    0x3, 0x15, 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, \n-    0x16, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, \n-    0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 0x3, \n-    0x18, 0x3, 0x18, 0x3, 0x19, 0x3, 0x19, 0x3, 0x19, 0x3, 0x19, 0x3, 0x19, \n-    0x3, 0x19, 0x3, 0x1a, 0x3, 0x1a, 0x3, 0x1a, 0x3, 0x1a, 0x3, 0x1a, 0x3, \n-    0x1a, 0x3, 0x1a, 0x3, 0x1a, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1b, \n-    0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x3, \n-    0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1d, 0x3, 0x1d, \n-    0x3, 0x1d, 0x3, 0x1d, 0x3, 0x1d, 0x3, 0x1d, 0x3, 0x1d, 0x3, 0x1d, 0x3, \n-    0x1d, 0x3, 0x1d, 0x3, 0x1d, 0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1e, \n-    0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x3, \n-    0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x3, 0x20, 0x3, 0x20, 0x3, 0x20, 0x3, 0x20, \n-    0x3, 0x20, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, \n-    0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, \n-    0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, \n-    0x22, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x24, \n-    0x3, 0x24, 0x3, 0x24, 0x3, 0x24, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, \n-    0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, \n-    0x3, 0x25, 0x3, 0x25, 0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 0x3, \n-    0x26, 0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, \n-    0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 0x3, \n-    0x28, 0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, \n-    0x3, 0x29, 0x3, 0x29, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, \n-    0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, \n-    0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, \n-    0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, \n-    0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, \n-    0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, \n-    0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x3, \n-    0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2e, \n-    0x3, 0x2e, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, \n-    0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, \n-    0x3, 0x30, 0x3, 0x30, 0x3, 0x31, 0x3, 0x31, 0x3, 0x31, 0x3, 0x31, 0x3, \n-    0x31, 0x3, 0x31, 0x3, 0x31, 0x3, 0x31, 0x3, 0x31, 0x3, 0x31, 0x3, 0x31, \n-    0x3, 0x31, 0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 0x3, \n-    0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x34, 0x3, 0x34, \n-    0x3, 0x34, 0x3, 0x34, 0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, \n-    0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 0x36, \n-    0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, \n-    0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x38, 0x3, 0x38, 0x3, 0x38, \n-    0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x39, 0x3, \n-    0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, \n-    0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x3, \n-    0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3b, 0x3, 0x3b, \n-    0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x3, \n-    0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3d, \n-    0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3e, 0x3, \n-    0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3f, 0x3, 0x3f, \n-    0x3, 0x3f, 0x3, 0x3f, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, \n-    0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, \n-    0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x3, \n-    0x42, 0x3, 0x42, 0x3, 0x43, 0x3, 0x43, 0x3, 0x43, 0x3, 0x43, 0x3, 0x43, \n-    0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, \n-    0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, \n-    0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x3, \n-    0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, \n-    0x3, 0x46, 0x3, 0x46, 0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 0x3, \n-    0x47, 0x3, 0x47, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, \n-    0x3, 0x48, 0x3, 0x48, 0x3, 0x49, 0x3, 0x49, 0x3, 0x49, 0x3, 0x49, 0x3, \n-    0x49, 0x3, 0x49, 0x3, 0x49, 0x3, 0x49, 0x3, 0x49, 0x3, 0x49, 0x3, 0x49, \n-    0x3, 0x49, 0x3, 0x49, 0x3, 0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x3, \n-    0x4a, 0x3, 0x4b, 0x3, 0x4b, 0x3, 0x4b, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, \n-    0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 0x3, \n-    0x4e, 0x3, 0x4e, 0x3, 0x4e, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, \n-    0x3, 0x4f, 0x3, 0x4f, 0x3, 0x50, 0x3, 0x50, 0x3, 0x50, 0x3, 0x50, 0x3, \n-    0x50, 0x3, 0x50, 0x3, 0x50, 0x3, 0x50, 0x3, 0x50, 0x3, 0x50, 0x3, 0x50, \n-    0x3, 0x50, 0x3, 0x50, 0x5, 0x50, 0x41a, 0xa, 0x50, 0x3, 0x51, 0x3, 0x51, \n-    0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, \n-    0x51, 0x3, 0x51, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, \n-    0x3, 0x52, 0x3, 0x53, 0x3, 0x53, 0x3, 0x53, 0x3, 0x53, 0x3, 0x53, 0x3, \n-    0x53, 0x3, 0x53, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, \n-    0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x55, 0x3, 0x55, 0x3, \n-    0x55, 0x3, 0x55, 0x3, 0x55, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x57, \n-    0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, \n-    0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x58, \n-    0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 0x3, 0x59, 0x3, 0x59, 0x3, \n-    0x59, 0x3, 0x59, 0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5a, \n-    0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5c, 0x3, \n-    0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5d, \n-    0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, \n-    0x5d, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5f, \n-    0x3, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x3, \n-    0x5f, 0x3, 0x5f, 0x3, 0x60, 0x3, 0x60, 0x3, 0x60, 0x3, 0x60, 0x3, 0x60, \n-    0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, \n-    0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x63, 0x3, 0x63, \n-    0x3, 0x63, 0x3, 0x63, 0x3, 0x63, 0x3, 0x63, 0x3, 0x64, 0x3, 0x64, 0x3, \n-    0x64, 0x3, 0x64, 0x3, 0x64, 0x3, 0x65, 0x3, 0x65, 0x3, 0x65, 0x3, 0x65, \n-    0x3, 0x65, 0x3, 0x65, 0x3, 0x65, 0x3, 0x65, 0x3, 0x65, 0x3, 0x65, 0x3, \n-    0x65, 0x3, 0x65, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, \n-    0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, \n-    0x66, 0x3, 0x66, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x68, \n-    0x3, 0x68, 0x3, 0x68, 0x3, 0x68, 0x3, 0x68, 0x3, 0x68, 0x3, 0x68, 0x3, \n-    0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, \n-    0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6b, 0x3, 0x6b, 0x3, \n-    0x6b, 0x3, 0x6b, 0x3, 0x6b, 0x3, 0x6b, 0x3, 0x6b, 0x3, 0x6c, 0x3, 0x6c, \n-    0x3, 0x6c, 0x3, 0x6c, 0x3, 0x6c, 0x3, 0x6c, 0x3, 0x6d, 0x3, 0x6d, 0x3, \n-    0x6d, 0x3, 0x6d, 0x3, 0x6d, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, \n-    0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6f, 0x3, \n-    0x6f, 0x3, 0x6f, 0x3, 0x6f, 0x3, 0x70, 0x3, 0x70, 0x3, 0x70, 0x3, 0x71, \n-    0x3, 0x71, 0x3, 0x71, 0x3, 0x71, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x3, \n-    0x72, 0x3, 0x72, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, \n-    0x3, 0x73, 0x3, 0x74, 0x3, 0x74, 0x3, 0x74, 0x3, 0x74, 0x3, 0x74, 0x3, \n-    0x74, 0x3, 0x74, 0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 0x3, 0x76, 0x3, 0x76, \n-    0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, \n-    0x76, 0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, \n-    0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, \n-    0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, \n-    0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7b, 0x3, 0x7b, 0x3, \n-    0x7b, 0x3, 0x7b, 0x3, 0x7b, 0x3, 0x7b, 0x3, 0x7b, 0x3, 0x7b, 0x3, 0x7b, \n-    0x3, 0x7b, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x3, \n-    0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, \n-    0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x3, \n-    0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, \n-    0x3, 0x7e, 0x3, 0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x3, \n-    0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x3, 0x80, \n-    0x3, 0x80, 0x3, 0x80, 0x3, 0x80, 0x3, 0x80, 0x3, 0x80, 0x3, 0x80, 0x3, \n-    0x80, 0x3, 0x81, 0x3, 0x81, 0x3, 0x81, 0x3, 0x81, 0x3, 0x81, 0x3, 0x81, \n-    0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, \n-    0x82, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, \n-    0x3, 0x83, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, \n-    0x84, 0x3, 0x84, 0x3, 0x85, 0x3, 0x85, 0x3, 0x85, 0x3, 0x85, 0x3, 0x85, \n-    0x3, 0x85, 0x3, 0x85, 0x3, 0x85, 0x3, 0x86, 0x3, 0x86, 0x3, 0x86, 0x3, \n-    0x86, 0x3, 0x86, 0x3, 0x86, 0x3, 0x86, 0x3, 0x86, 0x3, 0x87, 0x3, 0x87, \n-    0x3, 0x87, 0x3, 0x87, 0x3, 0x87, 0x3, 0x87, 0x3, 0x87, 0x3, 0x87, 0x3, \n-    0x87, 0x3, 0x87, 0x3, 0x87, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, \n-    0x3, 0x88, 0x3, 0x88, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, \n-    0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, \n-    0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, \n-    0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8c, \n-    0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8d, 0x3, 0x8d, 0x3, \n-    0x8d, 0x3, 0x8d, 0x3, 0x8d, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, \n-    0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x3, \n-    0x90, 0x3, 0x90, 0x3, 0x90, 0x3, 0x90, 0x3, 0x90, 0x3, 0x90, 0x3, 0x90, \n-    0x3, 0x90, 0x3, 0x90, 0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 0x3, \n-    0x91, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, \n-    0x3, 0x92, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x3, \n-    0x93, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x95, \n-    0x3, 0x95, 0x3, 0x95, 0x3, 0x95, 0x3, 0x95, 0x3, 0x95, 0x3, 0x95, 0x3, \n-    0x95, 0x3, 0x95, 0x3, 0x95, 0x3, 0x96, 0x3, 0x96, 0x3, 0x96, 0x3, 0x96, \n-    0x3, 0x96, 0x3, 0x97, 0x3, 0x97, 0x3, 0x97, 0x3, 0x97, 0x3, 0x97, 0x3, \n-    0x97, 0x3, 0x97, 0x3, 0x98, 0x3, 0x98, 0x3, 0x98, 0x3, 0x98, 0x3, 0x98, \n-    0x3, 0x98, 0x3, 0x98, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, \n-    0x99, 0x3, 0x99, 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, \n-    0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, \n-    0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9c, \n-    0x3, 0x9c, 0x3, 0x9c, 0x3, 0x9c, 0x3, 0x9c, 0x3, 0x9d, 0x3, 0x9d, 0x3, \n-    0x9d, 0x3, 0x9d, 0x3, 0x9d, 0x3, 0x9e, 0x3, 0x9e, 0x3, 0x9e, 0x3, 0x9e, \n-    0x3, 0x9e, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, \n-    0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, \n-    0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x3, \n-    0xa1, 0x3, 0xa1, 0x3, 0xa1, 0x3, 0xa2, 0x3, 0xa2, 0x3, 0xa2, 0x3, 0xa2, \n-    0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, \n-    0xa3, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, \n-    0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, \n-    0xa5, 0x3, 0xa5, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa6, \n-    0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa7, 0x3, 0xa7, 0x3, \n-    0xa7, 0x3, 0xa7, 0x3, 0xa8, 0x3, 0xa8, 0x3, 0xa8, 0x3, 0xa8, 0x3, 0xa8, \n-    0x3, 0xa9, 0x3, 0xa9, 0x3, 0xa9, 0x3, 0xa9, 0x3, 0xa9, 0x3, 0xa9, 0x3, \n-    0xaa, 0x3, 0xaa, 0x3, 0xaa, 0x3, 0xaa, 0x3, 0xaa, 0x3, 0xaa, 0x3, 0xaa, \n-    0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 0x3, 0xac, 0x3, 0xac, 0x3, \n-    0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xad, 0x3, 0xad, 0x3, 0xad, \n-    0x3, 0xad, 0x3, 0xad, 0x3, 0xae, 0x3, 0xae, 0x3, 0xae, 0x3, 0xae, 0x3, \n-    0xae, 0x3, 0xae, 0x3, 0xae, 0x3, 0xaf, 0x3, 0xaf, 0x3, 0xaf, 0x3, 0xaf, \n-    0x3, 0xaf, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, \n-    0xb0, 0x3, 0xb0, 0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, \n-    0x3, 0xb1, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x3, \n-    0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb4, 0x3, 0xb4, \n-    0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb5, 0x3, 0xb5, 0x3, \n-    0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, \n-    0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 0x5, \n-    0xb6, 0x6bb, 0xa, 0xb6, 0x3, 0xb7, 0x3, 0xb7, 0x3, 0xb7, 0x3, 0xb7, \n-    0x3, 0xb7, 0x3, 0xb7, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, \n-    0xb8, 0x3, 0xb9, 0x3, 0xb9, 0x5, 0xb9, 0x6ca, 0xa, 0xb9, 0x3, 0xb9, \n-    0x3, 0xb9, 0x3, 0xb9, 0x7, 0xb9, 0x6cf, 0xa, 0xb9, 0xc, 0xb9, 0xe, 0xb9, \n-    0x6d2, 0xb, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, \n-    0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x7, 0xb9, 0x6dc, 0xa, 0xb9, 0xc, 0xb9, \n-    0xe, 0xb9, 0x6df, 0xb, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, \n-    0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x7, \n-    0xb9, 0x6eb, 0xa, 0xb9, 0xc, 0xb9, 0xe, 0xb9, 0x6ee, 0xb, 0xb9, 0x3, \n-    0xb9, 0x3, 0xb9, 0x5, 0xb9, 0x6f2, 0xa, 0xb9, 0x3, 0xba, 0x3, 0xba, \n-    0x3, 0xba, 0x7, 0xba, 0x6f7, 0xa, 0xba, 0xc, 0xba, 0xe, 0xba, 0x6fa, \n-    0xb, 0xba, 0x3, 0xba, 0x3, 0xba, 0x5, 0xba, 0x6fe, 0xa, 0xba, 0x3, 0xba, \n-    0x3, 0xba, 0x5, 0xba, 0x702, 0xa, 0xba, 0x3, 0xba, 0x6, 0xba, 0x705, \n-    0xa, 0xba, 0xd, 0xba, 0xe, 0xba, 0x706, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, \n-    0x5, 0xba, 0x70c, 0xa, 0xba, 0x3, 0xba, 0x3, 0xba, 0x5, 0xba, 0x710, \n-    0xa, 0xba, 0x3, 0xba, 0x6, 0xba, 0x713, 0xa, 0xba, 0xd, 0xba, 0xe, 0xba, \n-    0x714, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x7, 0xba, 0x71a, 0xa, 0xba, \n-    0xc, 0xba, 0xe, 0xba, 0x71d, 0xb, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, \n-    0x5, 0xba, 0x722, 0xa, 0xba, 0x3, 0xba, 0x6, 0xba, 0x725, 0xa, 0xba, \n-    0xd, 0xba, 0xe, 0xba, 0x726, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, \n-    0x3, 0xba, 0x5, 0xba, 0x72e, 0xa, 0xba, 0x3, 0xba, 0x6, 0xba, 0x731, \n-    0xa, 0xba, 0xd, 0xba, 0xe, 0xba, 0x732, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, \n-    0x3, 0xba, 0x5, 0xba, 0x739, 0xa, 0xba, 0x3, 0xba, 0x6, 0xba, 0x73c, \n-    0xa, 0xba, 0xd, 0xba, 0xe, 0xba, 0x73d, 0x5, 0xba, 0x740, 0xa, 0xba, \n-    0x3, 0xbb, 0x3, 0xbb, 0x6, 0xbb, 0x744, 0xa, 0xbb, 0xd, 0xbb, 0xe, 0xbb, \n-    0x745, 0x3, 0xbc, 0x6, 0xbc, 0x749, 0xa, 0xbc, 0xd, 0xbc, 0xe, 0xbc, \n-    0x74a, 0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbd, 0x6, 0xbd, 0x750, 0xa, 0xbd, \n-    0xd, 0xbd, 0xe, 0xbd, 0x751, 0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbe, \n-    0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x7, 0xbe, 0x75c, 0xa, 0xbe, \n-    0xc, 0xbe, 0xe, 0xbe, 0x75f, 0xb, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbf, \n-    0x3, 0xbf, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc1, 0x3, 0xc1, 0x3, 0xc2, 0x3, \n-    0xc2, 0x3, 0xc3, 0x3, 0xc3, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc5, 0x3, 0xc5, \n-    0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc8, 0x3, 0xc8, 0x3, \n-    0xc9, 0x3, 0xc9, 0x3, 0xca, 0x3, 0xca, 0x3, 0xcb, 0x3, 0xcb, 0x3, 0xcc, \n-    0x3, 0xcc, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xce, 0x3, 0xce, 0x3, 0xcf, 0x3, \n-    0xcf, 0x3, 0xd0, 0x3, 0xd0, 0x3, 0xd1, 0x3, 0xd1, 0x3, 0xd2, 0x3, 0xd2, \n-    0x3, 0xd3, 0x3, 0xd3, 0x3, 0xd4, 0x3, 0xd4, 0x3, 0xd5, 0x3, 0xd5, 0x3, \n-    0xd6, 0x3, 0xd6, 0x3, 0xd7, 0x3, 0xd7, 0x3, 0xd8, 0x3, 0xd8, 0x3, 0xd9, \n-    0x3, 0xd9, 0x3, 0xda, 0x3, 0xda, 0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdc, 0x3, \n-    0xdc, 0x3, 0xdd, 0x3, 0xdd, 0x3, 0xdd, 0x3, 0xde, 0x3, 0xde, 0x3, 0xdf, \n-    0x3, 0xdf, 0x3, 0xe0, 0x3, 0xe0, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe2, 0x3, \n-    0xe2, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe4, 0x3, 0xe4, 0x3, 0xe5, \n-    0x3, 0xe5, 0x3, 0xe6, 0x3, 0xe6, 0x3, 0xe6, 0x3, 0xe7, 0x3, 0xe7, 0x3, \n-    0xe8, 0x3, 0xe8, 0x3, 0xe8, 0x3, 0xe9, 0x3, 0xe9, 0x3, 0xea, 0x3, 0xea, \n-    0x3, 0xeb, 0x3, 0xeb, 0x3, 0xec, 0x3, 0xec, 0x3, 0xec, 0x3, 0xed, 0x3, \n-    0xed, 0x3, 0xee, 0x3, 0xee, 0x3, 0xef, 0x3, 0xef, 0x3, 0xef, 0x3, 0xef, \n-    0x5, 0xef, 0x7cc, 0xa, 0xef, 0x3, 0xf0, 0x3, 0xf0, 0x3, 0xf1, 0x3, 0xf1, \n-    0x3, 0xf2, 0x3, 0xf2, 0x3, 0xf3, 0x3, 0xf3, 0x3, 0xf4, 0x3, 0xf4, 0x3, \n-    0xf5, 0x3, 0xf5, 0x3, 0xf6, 0x3, 0xf6, 0x3, 0xf7, 0x3, 0xf7, 0x3, 0xf8, \n-    0x3, 0xf8, 0x3, 0xf9, 0x3, 0xf9, 0x3, 0xfa, 0x3, 0xfa, 0x3, 0xfb, 0x3, \n-    0xfb, 0x3, 0xfb, 0x3, 0xfb, 0x7, 0xfb, 0x7e8, 0xa, 0xfb, 0xc, 0xfb, \n-    0xe, 0xfb, 0x7eb, 0xb, 0xfb, 0x3, 0xfb, 0x3, 0xfb, 0x3, 0xfb, 0x3, 0xfb, \n-    0x3, 0xfb, 0x3, 0xfc, 0x3, 0xfc, 0x3, 0xfc, 0x3, 0xfc, 0x7, 0xfc, 0x7f6, \n-    0xa, 0xfc, 0xc, 0xfc, 0xe, 0xfc, 0x7f9, 0xb, 0xfc, 0x3, 0xfc, 0x5, 0xfc, \n-    0x7fc, 0xa, 0xfc, 0x3, 0xfc, 0x3, 0xfc, 0x3, 0xfd, 0x3, 0xfd, 0x3, 0xfd, \n-    0x3, 0xfd, 0x3, 0x7e9, 0x2, 0xfe, 0x3, 0x3, 0x5, 0x4, 0x7, 0x5, 0x9, \n-    0x6, 0xb, 0x7, 0xd, 0x8, 0xf, 0x9, 0x11, 0xa, 0x13, 0xb, 0x15, 0xc, \n-    0x17, 0xd, 0x19, 0xe, 0x1b, 0xf, 0x1d, 0x10, 0x1f, 0x11, 0x21, 0x12, \n-    0x23, 0x13, 0x25, 0x14, 0x27, 0x15, 0x29, 0x16, 0x2b, 0x17, 0x2d, 0x18, \n-    0x2f, 0x19, 0x31, 0x1a, 0x33, 0x1b, 0x35, 0x1c, 0x37, 0x1d, 0x39, 0x1e, \n-    0x3b, 0x1f, 0x3d, 0x20, 0x3f, 0x21, 0x41, 0x22, 0x43, 0x23, 0x45, 0x24, \n-    0x47, 0x25, 0x49, 0x26, 0x4b, 0x27, 0x4d, 0x28, 0x4f, 0x29, 0x51, 0x2a, \n-    0x53, 0x2b, 0x55, 0x2c, 0x57, 0x2d, 0x59, 0x2e, 0x5b, 0x2f, 0x5d, 0x30, \n-    0x5f, 0x31, 0x61, 0x32, 0x63, 0x33, 0x65, 0x34, 0x67, 0x35, 0x69, 0x36, \n-    0x6b, 0x37, 0x6d, 0x38, 0x6f, 0x39, 0x71, 0x3a, 0x73, 0x3b, 0x75, 0x3c, \n-    0x77, 0x3d, 0x79, 0x3e, 0x7b, 0x3f, 0x7d, 0x40, 0x7f, 0x41, 0x81, 0x42, \n-    0x83, 0x43, 0x85, 0x44, 0x87, 0x45, 0x89, 0x46, 0x8b, 0x47, 0x8d, 0x48, \n-    0x8f, 0x49, 0x91, 0x4a, 0x93, 0x4b, 0x95, 0x4c, 0x97, 0x4d, 0x99, 0x4e, \n-    0x9b, 0x4f, 0x9d, 0x50, 0x9f, 0x51, 0xa1, 0x52, 0xa3, 0x53, 0xa5, 0x54, \n-    0xa7, 0x55, 0xa9, 0x56, 0xab, 0x57, 0xad, 0x58, 0xaf, 0x59, 0xb1, 0x5a, \n-    0xb3, 0x5b, 0xb5, 0x5c, 0xb7, 0x5d, 0xb9, 0x5e, 0xbb, 0x5f, 0xbd, 0x60, \n-    0xbf, 0x61, 0xc1, 0x62, 0xc3, 0x63, 0xc5, 0x64, 0xc7, 0x65, 0xc9, 0x66, \n-    0xcb, 0x67, 0xcd, 0x68, 0xcf, 0x69, 0xd1, 0x6a, 0xd3, 0x6b, 0xd5, 0x6c, \n-    0xd7, 0x6d, 0xd9, 0x6e, 0xdb, 0x6f, 0xdd, 0x70, 0xdf, 0x71, 0xe1, 0x72, \n-    0xe3, 0x73, 0xe5, 0x74, 0xe7, 0x75, 0xe9, 0x76, 0xeb, 0x77, 0xed, 0x78, \n-    0xef, 0x79, 0xf1, 0x7a, 0xf3, 0x7b, 0xf5, 0x7c, 0xf7, 0x7d, 0xf9, 0x7e, \n-    0xfb, 0x7f, 0xfd, 0x80, 0xff, 0x81, 0x101, 0x82, 0x103, 0x83, 0x105, \n-    0x84, 0x107, 0x85, 0x109, 0x86, 0x10b, 0x87, 0x10d, 0x88, 0x10f, 0x89, \n-    0x111, 0x8a, 0x113, 0x8b, 0x115, 0x8c, 0x117, 0x8d, 0x119, 0x8e, 0x11b, \n-    0x8f, 0x11d, 0x90, 0x11f, 0x91, 0x121, 0x92, 0x123, 0x93, 0x125, 0x94, \n-    0x127, 0x95, 0x129, 0x96, 0x12b, 0x97, 0x12d, 0x98, 0x12f, 0x99, 0x131, \n-    0x9a, 0x133, 0x9b, 0x135, 0x9c, 0x137, 0x9d, 0x139, 0x9e, 0x13b, 0x9f, \n-    0x13d, 0xa0, 0x13f, 0xa1, 0x141, 0xa2, 0x143, 0xa3, 0x145, 0xa4, 0x147, \n-    0xa5, 0x149, 0xa6, 0x14b, 0xa7, 0x14d, 0xa8, 0x14f, 0xa9, 0x151, 0xaa, \n-    0x153, 0xab, 0x155, 0xac, 0x157, 0xad, 0x159, 0xae, 0x15b, 0xaf, 0x15d, \n-    0xb0, 0x15f, 0xb1, 0x161, 0xb2, 0x163, 0xb3, 0x165, 0xb4, 0x167, 0xb5, \n-    0x169, 0xb6, 0x16b, 0xb7, 0x16d, 0xb8, 0x16f, 0xb9, 0x171, 0xba, 0x173, \n-    0xbb, 0x175, 0xbc, 0x177, 0xbd, 0x179, 0xbe, 0x17b, 0xbf, 0x17d, 0x2, \n-    0x17f, 0x2, 0x181, 0x2, 0x183, 0x2, 0x185, 0x2, 0x187, 0x2, 0x189, 0x2, \n-    0x18b, 0x2, 0x18d, 0x2, 0x18f, 0x2, 0x191, 0x2, 0x193, 0x2, 0x195, 0x2, \n-    0x197, 0x2, 0x199, 0x2, 0x19b, 0x2, 0x19d, 0x2, 0x19f, 0x2, 0x1a1, 0x2, \n-    0x1a3, 0x2, 0x1a5, 0x2, 0x1a7, 0x2, 0x1a9, 0x2, 0x1ab, 0x2, 0x1ad, 0x2, \n-    0x1af, 0x2, 0x1b1, 0x2, 0x1b3, 0x2, 0x1b5, 0x2, 0x1b7, 0x2, 0x1b9, 0xc0, \n-    0x1bb, 0xc1, 0x1bd, 0xc2, 0x1bf, 0xc3, 0x1c1, 0xc4, 0x1c3, 0xc5, 0x1c5, \n-    0xc6, 0x1c7, 0xc7, 0x1c9, 0xc8, 0x1cb, 0xc9, 0x1cd, 0xca, 0x1cf, 0xcb, \n-    0x1d1, 0xcc, 0x1d3, 0xcd, 0x1d5, 0xce, 0x1d7, 0xcf, 0x1d9, 0xd0, 0x1db, \n-    0xd1, 0x1dd, 0xd2, 0x1df, 0xd3, 0x1e1, 0xd4, 0x1e3, 0xd5, 0x1e5, 0xd6, \n-    0x1e7, 0xd7, 0x1e9, 0xd8, 0x1eb, 0xd9, 0x1ed, 0xda, 0x1ef, 0xdb, 0x1f1, \n-    0xdc, 0x1f3, 0xdd, 0x1f5, 0xde, 0x1f7, 0xdf, 0x1f9, 0xe0, 0x3, 0x2, \n-    0x26, 0x4, 0x2, 0x5e, 0x5e, 0x62, 0x62, 0x4, 0x2, 0x24, 0x24, 0x5e, \n-    0x5e, 0x4, 0x2, 0x29, 0x29, 0x5e, 0x5e, 0x4, 0x2, 0x43, 0x43, 0x63, \n-    0x63, 0x4, 0x2, 0x44, 0x44, 0x64, 0x64, 0x4, 0x2, 0x45, 0x45, 0x65, \n-    0x65, 0x4, 0x2, 0x46, 0x46, 0x66, 0x66, 0x4, 0x2, 0x47, 0x47, 0x67, \n-    0x67, 0x4, 0x2, 0x48, 0x48, 0x68, 0x68, 0x4, 0x2, 0x49, 0x49, 0x69, \n-    0x69, 0x4, 0x2, 0x4a, 0x4a, 0x6a, 0x6a, 0x4, 0x2, 0x4b, 0x4b, 0x6b, \n-    0x6b, 0x4, 0x2, 0x4c, 0x4c, 0x6c, 0x6c, 0x4, 0x2, 0x4d, 0x4d, 0x6d, \n-    0x6d, 0x4, 0x2, 0x4e, 0x4e, 0x6e, 0x6e, 0x4, 0x2, 0x4f, 0x4f, 0x6f, \n-    0x6f, 0x4, 0x2, 0x50, 0x50, 0x70, 0x70, 0x4, 0x2, 0x51, 0x51, 0x71, \n-    0x71, 0x4, 0x2, 0x52, 0x52, 0x72, 0x72, 0x4, 0x2, 0x53, 0x53, 0x73, \n-    0x73, 0x4, 0x2, 0x54, 0x54, 0x74, 0x74, 0x4, 0x2, 0x55, 0x55, 0x75, \n-    0x75, 0x4, 0x2, 0x56, 0x56, 0x76, 0x76, 0x4, 0x2, 0x57, 0x57, 0x77, \n-    0x77, 0x4, 0x2, 0x58, 0x58, 0x78, 0x78, 0x4, 0x2, 0x59, 0x59, 0x79, \n-    0x79, 0x4, 0x2, 0x5a, 0x5a, 0x7a, 0x7a, 0x4, 0x2, 0x5b, 0x5b, 0x7b, \n-    0x7b, 0x4, 0x2, 0x5c, 0x5c, 0x7c, 0x7c, 0x4, 0x2, 0x43, 0x5c, 0x63, \n-    0x7c, 0x3, 0x2, 0x32, 0x39, 0x3, 0x2, 0x32, 0x3b, 0x5, 0x2, 0x32, 0x3b, \n-    0x43, 0x48, 0x63, 0x68, 0x4, 0x2, 0xc, 0xc, 0xf, 0xf, 0x4, 0x3, 0xc, \n-    0xc, 0xf, 0xf, 0x4, 0x2, 0xb, 0xf, 0x22, 0x22, 0x2, 0x813, 0x2, 0x3, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0x5, 0x3, 0x2, 0x2, 0x2, 0x2, 0x7, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0x9, 0x3, 0x2, 0x2, 0x2, 0x2, 0xb, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0xd, 0x3, 0x2, 0x2, 0x2, 0x2, 0xf, 0x3, 0x2, 0x2, 0x2, 0x2, 0x11, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0x13, 0x3, 0x2, 0x2, 0x2, 0x2, 0x15, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0x17, 0x3, 0x2, 0x2, 0x2, 0x2, 0x19, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0x1b, 0x3, 0x2, 0x2, 0x2, 0x2, 0x1d, 0x3, 0x2, 0x2, 0x2, 0x2, 0x1f, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0x21, 0x3, 0x2, 0x2, 0x2, 0x2, 0x23, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0x25, 0x3, 0x2, 0x2, 0x2, 0x2, 0x27, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0x29, 0x3, 0x2, 0x2, 0x2, 0x2, 0x2b, 0x3, 0x2, 0x2, 0x2, 0x2, 0x2d, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0x2f, 0x3, 0x2, 0x2, 0x2, 0x2, 0x31, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0x33, 0x3, 0x2, 0x2, 0x2, 0x2, 0x35, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0x37, 0x3, 0x2, 0x2, 0x2, 0x2, 0x39, 0x3, 0x2, 0x2, 0x2, 0x2, 0x3b, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0x3d, 0x3, 0x2, 0x2, 0x2, 0x2, 0x3f, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0x41, 0x3, 0x2, 0x2, 0x2, 0x2, 0x43, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0x45, 0x3, 0x2, 0x2, 0x2, 0x2, 0x47, 0x3, 0x2, 0x2, 0x2, 0x2, 0x49, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0x4b, 0x3, 0x2, 0x2, 0x2, 0x2, 0x4d, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0x4f, 0x3, 0x2, 0x2, 0x2, 0x2, 0x51, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0x53, 0x3, 0x2, 0x2, 0x2, 0x2, 0x55, 0x3, 0x2, 0x2, 0x2, 0x2, 0x57, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0x59, 0x3, 0x2, 0x2, 0x2, 0x2, 0x5b, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0x5d, 0x3, 0x2, 0x2, 0x2, 0x2, 0x5f, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0x61, 0x3, 0x2, 0x2, 0x2, 0x2, 0x63, 0x3, 0x2, 0x2, 0x2, 0x2, 0x65, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0x67, 0x3, 0x2, 0x2, 0x2, 0x2, 0x69, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0x6b, 0x3, 0x2, 0x2, 0x2, 0x2, 0x6d, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0x6f, 0x3, 0x2, 0x2, 0x2, 0x2, 0x71, 0x3, 0x2, 0x2, 0x2, 0x2, 0x73, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0x75, 0x3, 0x2, 0x2, 0x2, 0x2, 0x77, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0x79, 0x3, 0x2, 0x2, 0x2, 0x2, 0x7b, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0x7d, 0x3, 0x2, 0x2, 0x2, 0x2, 0x7f, 0x3, 0x2, 0x2, 0x2, 0x2, 0x81, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0x83, 0x3, 0x2, 0x2, 0x2, 0x2, 0x85, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0x87, 0x3, 0x2, 0x2, 0x2, 0x2, 0x89, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0x8b, 0x3, 0x2, 0x2, 0x2, 0x2, 0x8d, 0x3, 0x2, 0x2, 0x2, 0x2, 0x8f, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0x91, 0x3, 0x2, 0x2, 0x2, 0x2, 0x93, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0x95, 0x3, 0x2, 0x2, 0x2, 0x2, 0x97, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0x99, 0x3, 0x2, 0x2, 0x2, 0x2, 0x9b, 0x3, 0x2, 0x2, 0x2, 0x2, 0x9d, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0x9f, 0x3, 0x2, 0x2, 0x2, 0x2, 0xa1, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0xa3, 0x3, 0x2, 0x2, 0x2, 0x2, 0xa5, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0xa7, 0x3, 0x2, 0x2, 0x2, 0x2, 0xa9, 0x3, 0x2, 0x2, 0x2, 0x2, 0xab, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0xad, 0x3, 0x2, 0x2, 0x2, 0x2, 0xaf, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0xb1, 0x3, 0x2, 0x2, 0x2, 0x2, 0xb3, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0xb5, 0x3, 0x2, 0x2, 0x2, 0x2, 0xb7, 0x3, 0x2, 0x2, 0x2, 0x2, 0xb9, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0xbb, 0x3, 0x2, 0x2, 0x2, 0x2, 0xbd, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0xbf, 0x3, 0x2, 0x2, 0x2, 0x2, 0xc1, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0xc3, 0x3, 0x2, 0x2, 0x2, 0x2, 0xc5, 0x3, 0x2, 0x2, 0x2, 0x2, 0xc7, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0xc9, 0x3, 0x2, 0x2, 0x2, 0x2, 0xcb, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0xcd, 0x3, 0x2, 0x2, 0x2, 0x2, 0xcf, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0xd1, 0x3, 0x2, 0x2, 0x2, 0x2, 0xd3, 0x3, 0x2, 0x2, 0x2, 0x2, 0xd5, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0xd7, 0x3, 0x2, 0x2, 0x2, 0x2, 0xd9, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0xdb, 0x3, 0x2, 0x2, 0x2, 0x2, 0xdd, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0xdf, 0x3, 0x2, 0x2, 0x2, 0x2, 0xe1, 0x3, 0x2, 0x2, 0x2, 0x2, 0xe3, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0xe5, 0x3, 0x2, 0x2, 0x2, 0x2, 0xe7, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0xe9, 0x3, 0x2, 0x2, 0x2, 0x2, 0xeb, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0xed, 0x3, 0x2, 0x2, 0x2, 0x2, 0xef, 0x3, 0x2, 0x2, 0x2, 0x2, 0xf1, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0xf3, 0x3, 0x2, 0x2, 0x2, 0x2, 0xf5, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0xf7, 0x3, 0x2, 0x2, 0x2, 0x2, 0xf9, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0xfb, 0x3, 0x2, 0x2, 0x2, 0x2, 0xfd, 0x3, 0x2, 0x2, 0x2, 0x2, 0xff, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0x101, 0x3, 0x2, 0x2, 0x2, 0x2, 0x103, 0x3, \n-    0x2, 0x2, 0x2, 0x2, 0x105, 0x3, 0x2, 0x2, 0x2, 0x2, 0x107, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0x109, 0x3, 0x2, 0x2, 0x2, 0x2, 0x10b, 0x3, 0x2, 0x2, \n-    0x2, 0x2, 0x10d, 0x3, 0x2, 0x2, 0x2, 0x2, 0x10f, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0x111, 0x3, 0x2, 0x2, 0x2, 0x2, 0x113, 0x3, 0x2, 0x2, 0x2, 0x2, \n-    0x115, 0x3, 0x2, 0x2, 0x2, 0x2, 0x117, 0x3, 0x2, 0x2, 0x2, 0x2, 0x119, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0x11b, 0x3, 0x2, 0x2, 0x2, 0x2, 0x11d, 0x3, \n-    0x2, 0x2, 0x2, 0x2, 0x11f, 0x3, 0x2, 0x2, 0x2, 0x2, 0x121, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0x123, 0x3, 0x2, 0x2, 0x2, 0x2, 0x125, 0x3, 0x2, 0x2, \n-    0x2, 0x2, 0x127, 0x3, 0x2, 0x2, 0x2, 0x2, 0x129, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0x12b, 0x3, 0x2, 0x2, 0x2, 0x2, 0x12d, 0x3, 0x2, 0x2, 0x2, 0x2, \n-    0x12f, 0x3, 0x2, 0x2, 0x2, 0x2, 0x131, 0x3, 0x2, 0x2, 0x2, 0x2, 0x133, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0x135, 0x3, 0x2, 0x2, 0x2, 0x2, 0x137, 0x3, \n-    0x2, 0x2, 0x2, 0x2, 0x139, 0x3, 0x2, 0x2, 0x2, 0x2, 0x13b, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0x13d, 0x3, 0x2, 0x2, 0x2, 0x2, 0x13f, 0x3, 0x2, 0x2, \n-    0x2, 0x2, 0x141, 0x3, 0x2, 0x2, 0x2, 0x2, 0x143, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0x145, 0x3, 0x2, 0x2, 0x2, 0x2, 0x147, 0x3, 0x2, 0x2, 0x2, 0x2, \n-    0x149, 0x3, 0x2, 0x2, 0x2, 0x2, 0x14b, 0x3, 0x2, 0x2, 0x2, 0x2, 0x14d, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0x14f, 0x3, 0x2, 0x2, 0x2, 0x2, 0x151, 0x3, \n-    0x2, 0x2, 0x2, 0x2, 0x153, 0x3, 0x2, 0x2, 0x2, 0x2, 0x155, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0x157, 0x3, 0x2, 0x2, 0x2, 0x2, 0x159, 0x3, 0x2, 0x2, \n-    0x2, 0x2, 0x15b, 0x3, 0x2, 0x2, 0x2, 0x2, 0x15d, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0x15f, 0x3, 0x2, 0x2, 0x2, 0x2, 0x161, 0x3, 0x2, 0x2, 0x2, 0x2, \n-    0x163, 0x3, 0x2, 0x2, 0x2, 0x2, 0x165, 0x3, 0x2, 0x2, 0x2, 0x2, 0x167, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0x169, 0x3, 0x2, 0x2, 0x2, 0x2, 0x16b, 0x3, \n-    0x2, 0x2, 0x2, 0x2, 0x16d, 0x3, 0x2, 0x2, 0x2, 0x2, 0x16f, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0x171, 0x3, 0x2, 0x2, 0x2, 0x2, 0x173, 0x3, 0x2, 0x2, \n-    0x2, 0x2, 0x175, 0x3, 0x2, 0x2, 0x2, 0x2, 0x177, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0x179, 0x3, 0x2, 0x2, 0x2, 0x2, 0x17b, 0x3, 0x2, 0x2, 0x2, 0x2, \n-    0x1b9, 0x3, 0x2, 0x2, 0x2, 0x2, 0x1bb, 0x3, 0x2, 0x2, 0x2, 0x2, 0x1bd, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0x1bf, 0x3, 0x2, 0x2, 0x2, 0x2, 0x1c1, 0x3, \n-    0x2, 0x2, 0x2, 0x2, 0x1c3, 0x3, 0x2, 0x2, 0x2, 0x2, 0x1c5, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0x1c7, 0x3, 0x2, 0x2, 0x2, 0x2, 0x1c9, 0x3, 0x2, 0x2, \n-    0x2, 0x2, 0x1cb, 0x3, 0x2, 0x2, 0x2, 0x2, 0x1cd, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0x1cf, 0x3, 0x2, 0x2, 0x2, 0x2, 0x1d1, 0x3, 0x2, 0x2, 0x2, 0x2, \n-    0x1d3, 0x3, 0x2, 0x2, 0x2, 0x2, 0x1d5, 0x3, 0x2, 0x2, 0x2, 0x2, 0x1d7, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0x1d9, 0x3, 0x2, 0x2, 0x2, 0x2, 0x1db, 0x3, \n-    0x2, 0x2, 0x2, 0x2, 0x1dd, 0x3, 0x2, 0x2, 0x2, 0x2, 0x1df, 0x3, 0x2, \n-    0x2, 0x2, 0x2, 0x1e1, 0x3, 0x2, 0x2, 0x2, 0x2, 0x1e3, 0x3, 0x2, 0x2, \n-    0x2, 0x2, 0x1e5, 0x3, 0x2, 0x2, 0x2, 0x2, 0x1e7, 0x3, 0x2, 0x2, 0x2, \n-    0x2, 0x1e9, 0x3, 0x2, 0x2, 0x2, 0x2, 0x1eb, 0x3, 0x2, 0x2, 0x2, 0x2, \n-    0x1ed, 0x3, 0x2, 0x2, 0x2, 0x2, 0x1ef, 0x3, 0x2, 0x2, 0x2, 0x2, 0x1f1, \n-    0x3, 0x2, 0x2, 0x2, 0x2, 0x1f3, 0x3, 0x2, 0x2, 0x2, 0x2, 0x1f5, 0x3, \n-    0x2, 0x2, 0x2, 0x2, 0x1f7, 0x3, 0x2, 0x2, 0x2, 0x2, 0x1f9, 0x3, 0x2, \n-    0x2, 0x2, 0x3, 0x1fb, 0x3, 0x2, 0x2, 0x2, 0x5, 0x1ff, 0x3, 0x2, 0x2, \n-    0x2, 0x7, 0x205, 0x3, 0x2, 0x2, 0x2, 0x9, 0x20b, 0x3, 0x2, 0x2, 0x2, \n-    0xb, 0x20f, 0x3, 0x2, 0x2, 0x2, 0xd, 0x215, 0x3, 0x2, 0x2, 0x2, 0xf, \n-    0x219, 0x3, 0x2, 0x2, 0x2, 0x11, 0x21e, 0x3, 0x2, 0x2, 0x2, 0x13, 0x222, \n-    0x3, 0x2, 0x2, 0x2, 0x15, 0x228, 0x3, 0x2, 0x2, 0x2, 0x17, 0x239, 0x3, \n-    0x2, 0x2, 0x2, 0x19, 0x23b, 0x3, 0x2, 0x2, 0x2, 0x1b, 0x240, 0x3, 0x2, \n-    0x2, 0x2, 0x1d, 0x244, 0x3, 0x2, 0x2, 0x2, 0x1f, 0x24a, 0x3, 0x2, 0x2, \n-    0x2, 0x21, 0x251, 0x3, 0x2, 0x2, 0x2, 0x23, 0x259, 0x3, 0x2, 0x2, 0x2, \n-    0x25, 0x25e, 0x3, 0x2, 0x2, 0x2, 0x27, 0x261, 0x3, 0x2, 0x2, 0x2, 0x29, \n-    0x266, 0x3, 0x2, 0x2, 0x2, 0x2b, 0x26b, 0x3, 0x2, 0x2, 0x2, 0x2d, 0x271, \n-    0x3, 0x2, 0x2, 0x2, 0x2f, 0x277, 0x3, 0x2, 0x2, 0x2, 0x31, 0x27f, 0x3, \n-    0x2, 0x2, 0x2, 0x33, 0x285, 0x3, 0x2, 0x2, 0x2, 0x35, 0x28d, 0x3, 0x2, \n-    0x2, 0x2, 0x37, 0x294, 0x3, 0x2, 0x2, 0x2, 0x39, 0x29c, 0x3, 0x2, 0x2, \n-    0x2, 0x3b, 0x2a7, 0x3, 0x2, 0x2, 0x2, 0x3d, 0x2ae, 0x3, 0x2, 0x2, 0x2, \n-    0x3f, 0x2b4, 0x3, 0x2, 0x2, 0x2, 0x41, 0x2b9, 0x3, 0x2, 0x2, 0x2, 0x43, \n-    0x2c2, 0x3, 0x2, 0x2, 0x2, 0x45, 0x2cc, 0x3, 0x2, 0x2, 0x2, 0x47, 0x2d1, \n-    0x3, 0x2, 0x2, 0x2, 0x49, 0x2d5, 0x3, 0x2, 0x2, 0x2, 0x4b, 0x2e1, 0x3, \n-    0x2, 0x2, 0x2, 0x4d, 0x2e9, 0x3, 0x2, 0x2, 0x2, 0x4f, 0x2ef, 0x3, 0x2, \n-    0x2, 0x2, 0x51, 0x2f6, 0x3, 0x2, 0x2, 0x2, 0x53, 0x2fb, 0x3, 0x2, 0x2, \n-    0x2, 0x55, 0x306, 0x3, 0x2, 0x2, 0x2, 0x57, 0x30f, 0x3, 0x2, 0x2, 0x2, \n-    0x59, 0x316, 0x3, 0x2, 0x2, 0x2, 0x5b, 0x323, 0x3, 0x2, 0x2, 0x2, 0x5d, \n-    0x32e, 0x3, 0x2, 0x2, 0x2, 0x5f, 0x333, 0x3, 0x2, 0x2, 0x2, 0x61, 0x33c, \n-    0x3, 0x2, 0x2, 0x2, 0x63, 0x348, 0x3, 0x2, 0x2, 0x2, 0x65, 0x34d, 0x3, \n-    0x2, 0x2, 0x2, 0x67, 0x352, 0x3, 0x2, 0x2, 0x2, 0x69, 0x356, 0x3, 0x2, \n-    0x2, 0x2, 0x6b, 0x35d, 0x3, 0x2, 0x2, 0x2, 0x6d, 0x364, 0x3, 0x2, 0x2, \n-    0x2, 0x6f, 0x36b, 0x3, 0x2, 0x2, 0x2, 0x71, 0x373, 0x3, 0x2, 0x2, 0x2, \n-    0x73, 0x37e, 0x3, 0x2, 0x2, 0x2, 0x75, 0x386, 0x3, 0x2, 0x2, 0x2, 0x77, \n-    0x38e, 0x3, 0x2, 0x2, 0x2, 0x79, 0x394, 0x3, 0x2, 0x2, 0x2, 0x7b, 0x39a, \n-    0x3, 0x2, 0x2, 0x2, 0x7d, 0x3a0, 0x3, 0x2, 0x2, 0x2, 0x7f, 0x3a4, 0x3, \n-    0x2, 0x2, 0x2, 0x81, 0x3ab, 0x3, 0x2, 0x2, 0x2, 0x83, 0x3b2, 0x3, 0x2, \n-    0x2, 0x2, 0x85, 0x3b7, 0x3, 0x2, 0x2, 0x2, 0x87, 0x3bc, 0x3, 0x2, 0x2, \n-    0x2, 0x89, 0x3c5, 0x3, 0x2, 0x2, 0x2, 0x8b, 0x3cc, 0x3, 0x2, 0x2, 0x2, \n-    0x8d, 0x3d8, 0x3, 0x2, 0x2, 0x2, 0x8f, 0x3de, 0x3, 0x2, 0x2, 0x2, 0x91, \n-    0x3e5, 0x3, 0x2, 0x2, 0x2, 0x93, 0x3f2, 0x3, 0x2, 0x2, 0x2, 0x95, 0x3f7, \n-    0x3, 0x2, 0x2, 0x2, 0x97, 0x3fa, 0x3, 0x2, 0x2, 0x2, 0x99, 0x3fd, 0x3, \n-    0x2, 0x2, 0x2, 0x9b, 0x403, 0x3, 0x2, 0x2, 0x2, 0x9d, 0x406, 0x3, 0x2, \n-    0x2, 0x2, 0x9f, 0x419, 0x3, 0x2, 0x2, 0x2, 0xa1, 0x41b, 0x3, 0x2, 0x2, \n-    0x2, 0xa3, 0x425, 0x3, 0x2, 0x2, 0x2, 0xa5, 0x42b, 0x3, 0x2, 0x2, 0x2, \n-    0xa7, 0x432, 0x3, 0x2, 0x2, 0x2, 0xa9, 0x43b, 0x3, 0x2, 0x2, 0x2, 0xab, \n-    0x440, 0x3, 0x2, 0x2, 0x2, 0xad, 0x443, 0x3, 0x2, 0x2, 0x2, 0xaf, 0x450, \n-    0x3, 0x2, 0x2, 0x2, 0xb1, 0x455, 0x3, 0x2, 0x2, 0x2, 0xb3, 0x459, 0x3, \n-    0x2, 0x2, 0x2, 0xb5, 0x45e, 0x3, 0x2, 0x2, 0x2, 0xb7, 0x463, 0x3, 0x2, \n-    0x2, 0x2, 0xb9, 0x46a, 0x3, 0x2, 0x2, 0x2, 0xbb, 0x472, 0x3, 0x2, 0x2, \n-    0x2, 0xbd, 0x477, 0x3, 0x2, 0x2, 0x2, 0xbf, 0x480, 0x3, 0x2, 0x2, 0x2, \n-    0xc1, 0x485, 0x3, 0x2, 0x2, 0x2, 0xc3, 0x48b, 0x3, 0x2, 0x2, 0x2, 0xc5, \n-    0x490, 0x3, 0x2, 0x2, 0x2, 0xc7, 0x496, 0x3, 0x2, 0x2, 0x2, 0xc9, 0x49b, \n-    0x3, 0x2, 0x2, 0x2, 0xcb, 0x4a7, 0x3, 0x2, 0x2, 0x2, 0xcd, 0x4b4, 0x3, \n-    0x2, 0x2, 0x2, 0xcf, 0x4b8, 0x3, 0x2, 0x2, 0x2, 0xd1, 0x4bf, 0x3, 0x2, \n-    0x2, 0x2, 0xd3, 0x4c3, 0x3, 0x2, 0x2, 0x2, 0xd5, 0x4ca, 0x3, 0x2, 0x2, \n-    0x2, 0xd7, 0x4d1, 0x3, 0x2, 0x2, 0x2, 0xd9, 0x4d7, 0x3, 0x2, 0x2, 0x2, \n-    0xdb, 0x4dc, 0x3, 0x2, 0x2, 0x2, 0xdd, 0x4e5, 0x3, 0x2, 0x2, 0x2, 0xdf, \n-    0x4e9, 0x3, 0x2, 0x2, 0x2, 0xe1, 0x4ec, 0x3, 0x2, 0x2, 0x2, 0xe3, 0x4f0, \n-    0x3, 0x2, 0x2, 0x2, 0xe5, 0x4f5, 0x3, 0x2, 0x2, 0x2, 0xe7, 0x4fb, 0x3, \n-    0x2, 0x2, 0x2, 0xe9, 0x502, 0x3, 0x2, 0x2, 0x2, 0xeb, 0x505, 0x3, 0x2, \n-    0x2, 0x2, 0xed, 0x50e, 0x3, 0x2, 0x2, 0x2, 0xef, 0x511, 0x3, 0x2, 0x2, \n-    0x2, 0xf1, 0x517, 0x3, 0x2, 0x2, 0x2, 0xf3, 0x51d, 0x3, 0x2, 0x2, 0x2, \n-    0xf5, 0x525, 0x3, 0x2, 0x2, 0x2, 0xf7, 0x52f, 0x3, 0x2, 0x2, 0x2, 0xf9, \n-    0x538, 0x3, 0x2, 0x2, 0x2, 0xfb, 0x541, 0x3, 0x2, 0x2, 0x2, 0xfd, 0x549, \n-    0x3, 0x2, 0x2, 0x2, 0xff, 0x554, 0x3, 0x2, 0x2, 0x2, 0x101, 0x55c, 0x3, \n-    0x2, 0x2, 0x2, 0x103, 0x562, 0x3, 0x2, 0x2, 0x2, 0x105, 0x569, 0x3, \n-    0x2, 0x2, 0x2, 0x107, 0x570, 0x3, 0x2, 0x2, 0x2, 0x109, 0x577, 0x3, \n-    0x2, 0x2, 0x2, 0x10b, 0x57f, 0x3, 0x2, 0x2, 0x2, 0x10d, 0x587, 0x3, \n-    0x2, 0x2, 0x2, 0x10f, 0x592, 0x3, 0x2, 0x2, 0x2, 0x111, 0x598, 0x3, \n-    0x2, 0x2, 0x2, 0x113, 0x59f, 0x3, 0x2, 0x2, 0x2, 0x115, 0x5a6, 0x3, \n-    0x2, 0x2, 0x2, 0x117, 0x5ad, 0x3, 0x2, 0x2, 0x2, 0x119, 0x5b4, 0x3, \n-    0x2, 0x2, 0x2, 0x11b, 0x5b9, 0x3, 0x2, 0x2, 0x2, 0x11d, 0x5bf, 0x3, \n-    0x2, 0x2, 0x2, 0x11f, 0x5c3, 0x3, 0x2, 0x2, 0x2, 0x121, 0x5cc, 0x3, \n-    0x2, 0x2, 0x2, 0x123, 0x5d1, 0x3, 0x2, 0x2, 0x2, 0x125, 0x5d8, 0x3, \n-    0x2, 0x2, 0x2, 0x127, 0x5de, 0x3, 0x2, 0x2, 0x2, 0x129, 0x5e3, 0x3, \n-    0x2, 0x2, 0x2, 0x12b, 0x5ed, 0x3, 0x2, 0x2, 0x2, 0x12d, 0x5f2, 0x3, \n-    0x2, 0x2, 0x2, 0x12f, 0x5f9, 0x3, 0x2, 0x2, 0x2, 0x131, 0x600, 0x3, \n-    0x2, 0x2, 0x2, 0x133, 0x606, 0x3, 0x2, 0x2, 0x2, 0x135, 0x60d, 0x3, \n-    0x2, 0x2, 0x2, 0x137, 0x617, 0x3, 0x2, 0x2, 0x2, 0x139, 0x61c, 0x3, \n-    0x2, 0x2, 0x2, 0x13b, 0x621, 0x3, 0x2, 0x2, 0x2, 0x13d, 0x626, 0x3, \n-    0x2, 0x2, 0x2, 0x13f, 0x62e, 0x3, 0x2, 0x2, 0x2, 0x141, 0x638, 0x3, \n-    0x2, 0x2, 0x2, 0x143, 0x63b, 0x3, 0x2, 0x2, 0x2, 0x145, 0x63f, 0x3, \n-    0x2, 0x2, 0x2, 0x147, 0x646, 0x3, 0x2, 0x2, 0x2, 0x149, 0x64f, 0x3, \n-    0x2, 0x2, 0x2, 0x14b, 0x654, 0x3, 0x2, 0x2, 0x2, 0x14d, 0x65d, 0x3, \n-    0x2, 0x2, 0x2, 0x14f, 0x661, 0x3, 0x2, 0x2, 0x2, 0x151, 0x666, 0x3, \n-    0x2, 0x2, 0x2, 0x153, 0x66c, 0x3, 0x2, 0x2, 0x2, 0x155, 0x673, 0x3, \n-    0x2, 0x2, 0x2, 0x157, 0x677, 0x3, 0x2, 0x2, 0x2, 0x159, 0x67d, 0x3, \n-    0x2, 0x2, 0x2, 0x15b, 0x682, 0x3, 0x2, 0x2, 0x2, 0x15d, 0x689, 0x3, \n-    0x2, 0x2, 0x2, 0x15f, 0x68e, 0x3, 0x2, 0x2, 0x2, 0x161, 0x695, 0x3, \n-    0x2, 0x2, 0x2, 0x163, 0x69b, 0x3, 0x2, 0x2, 0x2, 0x165, 0x6a0, 0x3, \n-    0x2, 0x2, 0x2, 0x167, 0x6a5, 0x3, 0x2, 0x2, 0x2, 0x169, 0x6ab, 0x3, \n-    0x2, 0x2, 0x2, 0x16b, 0x6ba, 0x3, 0x2, 0x2, 0x2, 0x16d, 0x6bc, 0x3, \n-    0x2, 0x2, 0x2, 0x16f, 0x6c2, 0x3, 0x2, 0x2, 0x2, 0x171, 0x6f1, 0x3, \n-    0x2, 0x2, 0x2, 0x173, 0x73f, 0x3, 0x2, 0x2, 0x2, 0x175, 0x741, 0x3, \n-    0x2, 0x2, 0x2, 0x177, 0x748, 0x3, 0x2, 0x2, 0x2, 0x179, 0x74c, 0x3, \n-    0x2, 0x2, 0x2, 0x17b, 0x753, 0x3, 0x2, 0x2, 0x2, 0x17d, 0x762, 0x3, \n-    0x2, 0x2, 0x2, 0x17f, 0x764, 0x3, 0x2, 0x2, 0x2, 0x181, 0x766, 0x3, \n-    0x2, 0x2, 0x2, 0x183, 0x768, 0x3, 0x2, 0x2, 0x2, 0x185, 0x76a, 0x3, \n-    0x2, 0x2, 0x2, 0x187, 0x76c, 0x3, 0x2, 0x2, 0x2, 0x189, 0x76e, 0x3, \n-    0x2, 0x2, 0x2, 0x18b, 0x770, 0x3, 0x2, 0x2, 0x2, 0x18d, 0x772, 0x3, \n-    0x2, 0x2, 0x2, 0x18f, 0x774, 0x3, 0x2, 0x2, 0x2, 0x191, 0x776, 0x3, \n-    0x2, 0x2, 0x2, 0x193, 0x778, 0x3, 0x2, 0x2, 0x2, 0x195, 0x77a, 0x3, \n-    0x2, 0x2, 0x2, 0x197, 0x77c, 0x3, 0x2, 0x2, 0x2, 0x199, 0x77e, 0x3, \n-    0x2, 0x2, 0x2, 0x19b, 0x780, 0x3, 0x2, 0x2, 0x2, 0x19d, 0x782, 0x3, \n-    0x2, 0x2, 0x2, 0x19f, 0x784, 0x3, 0x2, 0x2, 0x2, 0x1a1, 0x786, 0x3, \n-    0x2, 0x2, 0x2, 0x1a3, 0x788, 0x3, 0x2, 0x2, 0x2, 0x1a5, 0x78a, 0x3, \n-    0x2, 0x2, 0x2, 0x1a7, 0x78c, 0x3, 0x2, 0x2, 0x2, 0x1a9, 0x78e, 0x3, \n-    0x2, 0x2, 0x2, 0x1ab, 0x790, 0x3, 0x2, 0x2, 0x2, 0x1ad, 0x792, 0x3, \n-    0x2, 0x2, 0x2, 0x1af, 0x794, 0x3, 0x2, 0x2, 0x2, 0x1b1, 0x796, 0x3, \n-    0x2, 0x2, 0x2, 0x1b3, 0x798, 0x3, 0x2, 0x2, 0x2, 0x1b5, 0x79a, 0x3, \n-    0x2, 0x2, 0x2, 0x1b7, 0x79c, 0x3, 0x2, 0x2, 0x2, 0x1b9, 0x79e, 0x3, \n-    0x2, 0x2, 0x2, 0x1bb, 0x7a1, 0x3, 0x2, 0x2, 0x2, 0x1bd, 0x7a3, 0x3, \n-    0x2, 0x2, 0x2, 0x1bf, 0x7a5, 0x3, 0x2, 0x2, 0x2, 0x1c1, 0x7a7, 0x3, \n-    0x2, 0x2, 0x2, 0x1c3, 0x7a9, 0x3, 0x2, 0x2, 0x2, 0x1c5, 0x7ab, 0x3, \n-    0x2, 0x2, 0x2, 0x1c7, 0x7ae, 0x3, 0x2, 0x2, 0x2, 0x1c9, 0x7b0, 0x3, \n-    0x2, 0x2, 0x2, 0x1cb, 0x7b2, 0x3, 0x2, 0x2, 0x2, 0x1cd, 0x7b5, 0x3, \n-    0x2, 0x2, 0x2, 0x1cf, 0x7b7, 0x3, 0x2, 0x2, 0x2, 0x1d1, 0x7ba, 0x3, \n-    0x2, 0x2, 0x2, 0x1d3, 0x7bc, 0x3, 0x2, 0x2, 0x2, 0x1d5, 0x7be, 0x3, \n-    0x2, 0x2, 0x2, 0x1d7, 0x7c0, 0x3, 0x2, 0x2, 0x2, 0x1d9, 0x7c3, 0x3, \n-    0x2, 0x2, 0x2, 0x1db, 0x7c5, 0x3, 0x2, 0x2, 0x2, 0x1dd, 0x7cb, 0x3, \n-    0x2, 0x2, 0x2, 0x1df, 0x7cd, 0x3, 0x2, 0x2, 0x2, 0x1e1, 0x7cf, 0x3, \n-    0x2, 0x2, 0x2, 0x1e3, 0x7d1, 0x3, 0x2, 0x2, 0x2, 0x1e5, 0x7d3, 0x3, \n-    0x2, 0x2, 0x2, 0x1e7, 0x7d5, 0x3, 0x2, 0x2, 0x2, 0x1e9, 0x7d7, 0x3, \n-    0x2, 0x2, 0x2, 0x1eb, 0x7d9, 0x3, 0x2, 0x2, 0x2, 0x1ed, 0x7db, 0x3, \n-    0x2, 0x2, 0x2, 0x1ef, 0x7dd, 0x3, 0x2, 0x2, 0x2, 0x1f1, 0x7df, 0x3, \n-    0x2, 0x2, 0x2, 0x1f3, 0x7e1, 0x3, 0x2, 0x2, 0x2, 0x1f5, 0x7e3, 0x3, \n-    0x2, 0x2, 0x2, 0x1f7, 0x7f1, 0x3, 0x2, 0x2, 0x2, 0x1f9, 0x7ff, 0x3, \n-    0x2, 0x2, 0x2, 0x1fb, 0x1fc, 0x5, 0x17d, 0xbf, 0x2, 0x1fc, 0x1fd, 0x5, \n-    0x183, 0xc2, 0x2, 0x1fd, 0x1fe, 0x5, 0x183, 0xc2, 0x2, 0x1fe, 0x4, 0x3, \n-    0x2, 0x2, 0x2, 0x1ff, 0x200, 0x5, 0x17d, 0xbf, 0x2, 0x200, 0x201, 0x5, \n-    0x187, 0xc4, 0x2, 0x201, 0x202, 0x5, 0x1a3, 0xd2, 0x2, 0x202, 0x203, \n-    0x5, 0x185, 0xc3, 0x2, 0x203, 0x204, 0x5, 0x19f, 0xd0, 0x2, 0x204, 0x6, \n-    0x3, 0x2, 0x2, 0x2, 0x205, 0x206, 0x5, 0x17d, 0xbf, 0x2, 0x206, 0x207, \n-    0x5, 0x193, 0xca, 0x2, 0x207, 0x208, 0x5, 0x18d, 0xc7, 0x2, 0x208, 0x209, \n-    0x5, 0x17d, 0xbf, 0x2, 0x209, 0x20a, 0x5, 0x1a1, 0xd1, 0x2, 0x20a, 0x8, \n-    0x3, 0x2, 0x2, 0x2, 0x20b, 0x20c, 0x5, 0x17d, 0xbf, 0x2, 0x20c, 0x20d, \n-    0x5, 0x193, 0xca, 0x2, 0x20d, 0x20e, 0x5, 0x193, 0xca, 0x2, 0x20e, 0xa, \n-    0x3, 0x2, 0x2, 0x2, 0x20f, 0x210, 0x5, 0x17d, 0xbf, 0x2, 0x210, 0x211, \n-    0x5, 0x193, 0xca, 0x2, 0x211, 0x212, 0x5, 0x1a3, 0xd2, 0x2, 0x212, 0x213, \n-    0x5, 0x185, 0xc3, 0x2, 0x213, 0x214, 0x5, 0x19f, 0xd0, 0x2, 0x214, 0xc, \n-    0x3, 0x2, 0x2, 0x2, 0x215, 0x216, 0x5, 0x17d, 0xbf, 0x2, 0x216, 0x217, \n-    0x5, 0x197, 0xcc, 0x2, 0x217, 0x218, 0x5, 0x183, 0xc2, 0x2, 0x218, 0xe, \n-    0x3, 0x2, 0x2, 0x2, 0x219, 0x21a, 0x5, 0x17d, 0xbf, 0x2, 0x21a, 0x21b, \n-    0x5, 0x197, 0xcc, 0x2, 0x21b, 0x21c, 0x5, 0x1a3, 0xd2, 0x2, 0x21c, 0x21d, \n-    0x5, 0x18d, 0xc7, 0x2, 0x21d, 0x10, 0x3, 0x2, 0x2, 0x2, 0x21e, 0x21f, \n-    0x5, 0x17d, 0xbf, 0x2, 0x21f, 0x220, 0x5, 0x197, 0xcc, 0x2, 0x220, 0x221, \n-    0x5, 0x1ad, 0xd7, 0x2, 0x221, 0x12, 0x3, 0x2, 0x2, 0x2, 0x222, 0x223, \n-    0x5, 0x17d, 0xbf, 0x2, 0x223, 0x224, 0x5, 0x19f, 0xd0, 0x2, 0x224, 0x225, \n-    0x5, 0x19f, 0xd0, 0x2, 0x225, 0x226, 0x5, 0x17d, 0xbf, 0x2, 0x226, 0x227, \n-    0x5, 0x1ad, 0xd7, 0x2, 0x227, 0x14, 0x3, 0x2, 0x2, 0x2, 0x228, 0x229, \n-    0x5, 0x17d, 0xbf, 0x2, 0x229, 0x22a, 0x5, 0x1a1, 0xd1, 0x2, 0x22a, 0x16, \n-    0x3, 0x2, 0x2, 0x2, 0x22b, 0x22c, 0x5, 0x17d, 0xbf, 0x2, 0x22c, 0x22d, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x22d, 0x22e, 0x5, 0x181, 0xc1, 0x2, 0x22e, 0x23a, \n-    0x3, 0x2, 0x2, 0x2, 0x22f, 0x230, 0x5, 0x17d, 0xbf, 0x2, 0x230, 0x231, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x231, 0x232, 0x5, 0x181, 0xc1, 0x2, 0x232, 0x233, \n-    0x5, 0x185, 0xc3, 0x2, 0x233, 0x234, 0x5, 0x197, 0xcc, 0x2, 0x234, 0x235, \n-    0x5, 0x183, 0xc2, 0x2, 0x235, 0x236, 0x5, 0x18d, 0xc7, 0x2, 0x236, 0x237, \n-    0x5, 0x197, 0xcc, 0x2, 0x237, 0x238, 0x5, 0x189, 0xc5, 0x2, 0x238, 0x23a, \n-    0x3, 0x2, 0x2, 0x2, 0x239, 0x22b, 0x3, 0x2, 0x2, 0x2, 0x239, 0x22f, \n-    0x3, 0x2, 0x2, 0x2, 0x23a, 0x18, 0x3, 0x2, 0x2, 0x2, 0x23b, 0x23c, 0x5, \n-    0x17d, 0xbf, 0x2, 0x23c, 0x23d, 0x5, 0x1a1, 0xd1, 0x2, 0x23d, 0x23e, \n-    0x5, 0x199, 0xcd, 0x2, 0x23e, 0x23f, 0x5, 0x187, 0xc4, 0x2, 0x23f, 0x1a, \n-    0x3, 0x2, 0x2, 0x2, 0x240, 0x241, 0x5, 0x17d, 0xbf, 0x2, 0x241, 0x242, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x242, 0x243, 0x5, 0x1a3, 0xd2, 0x2, 0x243, 0x1c, \n-    0x3, 0x2, 0x2, 0x2, 0x244, 0x245, 0x5, 0x17d, 0xbf, 0x2, 0x245, 0x246, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x246, 0x247, 0x5, 0x1ad, 0xd7, 0x2, 0x247, 0x248, \n-    0x5, 0x197, 0xcc, 0x2, 0x248, 0x249, 0x5, 0x181, 0xc1, 0x2, 0x249, 0x1e, \n-    0x3, 0x2, 0x2, 0x2, 0x24a, 0x24b, 0x5, 0x17d, 0xbf, 0x2, 0x24b, 0x24c, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x24c, 0x24d, 0x5, 0x1a3, 0xd2, 0x2, 0x24d, 0x24e, \n-    0x5, 0x17d, 0xbf, 0x2, 0x24e, 0x24f, 0x5, 0x181, 0xc1, 0x2, 0x24f, 0x250, \n-    0x5, 0x18b, 0xc6, 0x2, 0x250, 0x20, 0x3, 0x2, 0x2, 0x2, 0x251, 0x252, \n-    0x5, 0x17f, 0xc0, 0x2, 0x252, 0x253, 0x5, 0x185, 0xc3, 0x2, 0x253, 0x254, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x254, 0x255, 0x5, 0x1a9, 0xd5, 0x2, 0x255, 0x256, \n-    0x5, 0x185, 0xc3, 0x2, 0x256, 0x257, 0x5, 0x185, 0xc3, 0x2, 0x257, 0x258, \n-    0x5, 0x197, 0xcc, 0x2, 0x258, 0x22, 0x3, 0x2, 0x2, 0x2, 0x259, 0x25a, \n-    0x5, 0x17f, 0xc0, 0x2, 0x25a, 0x25b, 0x5, 0x199, 0xcd, 0x2, 0x25b, 0x25c, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x25c, 0x25d, 0x5, 0x18b, 0xc6, 0x2, 0x25d, 0x24, \n-    0x3, 0x2, 0x2, 0x2, 0x25e, 0x25f, 0x5, 0x17f, 0xc0, 0x2, 0x25f, 0x260, \n-    0x5, 0x1ad, 0xd7, 0x2, 0x260, 0x26, 0x3, 0x2, 0x2, 0x2, 0x261, 0x262, \n-    0x5, 0x181, 0xc1, 0x2, 0x262, 0x263, 0x5, 0x17d, 0xbf, 0x2, 0x263, 0x264, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x264, 0x265, 0x5, 0x185, 0xc3, 0x2, 0x265, 0x28, \n-    0x3, 0x2, 0x2, 0x2, 0x266, 0x267, 0x5, 0x181, 0xc1, 0x2, 0x267, 0x268, \n-    0x5, 0x17d, 0xbf, 0x2, 0x268, 0x269, 0x5, 0x1a1, 0xd1, 0x2, 0x269, 0x26a, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x26a, 0x2a, 0x3, 0x2, 0x2, 0x2, 0x26b, 0x26c, \n-    0x5, 0x181, 0xc1, 0x2, 0x26c, 0x26d, 0x5, 0x18b, 0xc6, 0x2, 0x26d, 0x26e, \n-    0x5, 0x185, 0xc3, 0x2, 0x26e, 0x26f, 0x5, 0x181, 0xc1, 0x2, 0x26f, 0x270, \n-    0x5, 0x191, 0xc9, 0x2, 0x270, 0x2c, 0x3, 0x2, 0x2, 0x2, 0x271, 0x272, \n-    0x5, 0x181, 0xc1, 0x2, 0x272, 0x273, 0x5, 0x193, 0xca, 0x2, 0x273, 0x274, \n-    0x5, 0x185, 0xc3, 0x2, 0x274, 0x275, 0x5, 0x17d, 0xbf, 0x2, 0x275, 0x276, \n-    0x5, 0x19f, 0xd0, 0x2, 0x276, 0x2e, 0x3, 0x2, 0x2, 0x2, 0x277, 0x278, \n-    0x5, 0x181, 0xc1, 0x2, 0x278, 0x279, 0x5, 0x193, 0xca, 0x2, 0x279, 0x27a, \n-    0x5, 0x1a5, 0xd3, 0x2, 0x27a, 0x27b, 0x5, 0x1a1, 0xd1, 0x2, 0x27b, 0x27c, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x27c, 0x27d, 0x5, 0x185, 0xc3, 0x2, 0x27d, 0x27e, \n-    0x5, 0x19f, 0xd0, 0x2, 0x27e, 0x30, 0x3, 0x2, 0x2, 0x2, 0x27f, 0x280, \n-    0x5, 0x181, 0xc1, 0x2, 0x280, 0x281, 0x5, 0x199, 0xcd, 0x2, 0x281, 0x282, \n-    0x5, 0x183, 0xc2, 0x2, 0x282, 0x283, 0x5, 0x185, 0xc3, 0x2, 0x283, 0x284, \n-    0x5, 0x181, 0xc1, 0x2, 0x284, 0x32, 0x3, 0x2, 0x2, 0x2, 0x285, 0x286, \n-    0x5, 0x181, 0xc1, 0x2, 0x286, 0x287, 0x5, 0x199, 0xcd, 0x2, 0x287, 0x288, \n-    0x5, 0x193, 0xca, 0x2, 0x288, 0x289, 0x5, 0x193, 0xca, 0x2, 0x289, 0x28a, \n-    0x5, 0x17d, 0xbf, 0x2, 0x28a, 0x28b, 0x5, 0x1a3, 0xd2, 0x2, 0x28b, 0x28c, \n-    0x5, 0x185, 0xc3, 0x2, 0x28c, 0x34, 0x3, 0x2, 0x2, 0x2, 0x28d, 0x28e, \n-    0x5, 0x181, 0xc1, 0x2, 0x28e, 0x28f, 0x5, 0x199, 0xcd, 0x2, 0x28f, 0x290, \n-    0x5, 0x193, 0xca, 0x2, 0x290, 0x291, 0x5, 0x1a5, 0xd3, 0x2, 0x291, 0x292, \n-    0x5, 0x195, 0xcb, 0x2, 0x292, 0x293, 0x5, 0x197, 0xcc, 0x2, 0x293, 0x36, \n-    0x3, 0x2, 0x2, 0x2, 0x294, 0x295, 0x5, 0x181, 0xc1, 0x2, 0x295, 0x296, \n-    0x5, 0x199, 0xcd, 0x2, 0x296, 0x297, 0x5, 0x195, 0xcb, 0x2, 0x297, 0x298, \n-    0x5, 0x195, 0xcb, 0x2, 0x298, 0x299, 0x5, 0x185, 0xc3, 0x2, 0x299, 0x29a, \n-    0x5, 0x197, 0xcc, 0x2, 0x29a, 0x29b, 0x5, 0x1a3, 0xd2, 0x2, 0x29b, 0x38, \n-    0x3, 0x2, 0x2, 0x2, 0x29c, 0x29d, 0x5, 0x181, 0xc1, 0x2, 0x29d, 0x29e, \n-    0x5, 0x199, 0xcd, 0x2, 0x29e, 0x29f, 0x5, 0x197, 0xcc, 0x2, 0x29f, 0x2a0, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x2a0, 0x2a1, 0x5, 0x1a3, 0xd2, 0x2, 0x2a1, 0x2a2, \n-    0x5, 0x19f, 0xd0, 0x2, 0x2a2, 0x2a3, 0x5, 0x17d, 0xbf, 0x2, 0x2a3, 0x2a4, \n-    0x5, 0x18d, 0xc7, 0x2, 0x2a4, 0x2a5, 0x5, 0x197, 0xcc, 0x2, 0x2a5, 0x2a6, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x2a6, 0x3a, 0x3, 0x2, 0x2, 0x2, 0x2a7, 0x2a8, \n-    0x5, 0x181, 0xc1, 0x2, 0x2a8, 0x2a9, 0x5, 0x19f, 0xd0, 0x2, 0x2a9, 0x2aa, \n-    0x5, 0x185, 0xc3, 0x2, 0x2aa, 0x2ab, 0x5, 0x17d, 0xbf, 0x2, 0x2ab, 0x2ac, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x2ac, 0x2ad, 0x5, 0x185, 0xc3, 0x2, 0x2ad, 0x3c, \n-    0x3, 0x2, 0x2, 0x2, 0x2ae, 0x2af, 0x5, 0x181, 0xc1, 0x2, 0x2af, 0x2b0, \n-    0x5, 0x19f, 0xd0, 0x2, 0x2b0, 0x2b1, 0x5, 0x199, 0xcd, 0x2, 0x2b1, 0x2b2, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x2b2, 0x2b3, 0x5, 0x1a1, 0xd1, 0x2, 0x2b3, 0x3e, \n-    0x3, 0x2, 0x2, 0x2, 0x2b4, 0x2b5, 0x5, 0x181, 0xc1, 0x2, 0x2b5, 0x2b6, \n-    0x5, 0x1a5, 0xd3, 0x2, 0x2b6, 0x2b7, 0x5, 0x17f, 0xc0, 0x2, 0x2b7, 0x2b8, \n-    0x5, 0x185, 0xc3, 0x2, 0x2b8, 0x40, 0x3, 0x2, 0x2, 0x2, 0x2b9, 0x2ba, \n-    0x5, 0x183, 0xc2, 0x2, 0x2ba, 0x2bb, 0x5, 0x17d, 0xbf, 0x2, 0x2bb, 0x2bc, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x2bc, 0x2bd, 0x5, 0x17d, 0xbf, 0x2, 0x2bd, 0x2be, \n-    0x5, 0x17f, 0xc0, 0x2, 0x2be, 0x2bf, 0x5, 0x17d, 0xbf, 0x2, 0x2bf, 0x2c0, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x2c0, 0x2c1, 0x5, 0x185, 0xc3, 0x2, 0x2c1, 0x42, \n-    0x3, 0x2, 0x2, 0x2, 0x2c2, 0x2c3, 0x5, 0x183, 0xc2, 0x2, 0x2c3, 0x2c4, \n-    0x5, 0x17d, 0xbf, 0x2, 0x2c4, 0x2c5, 0x5, 0x1a3, 0xd2, 0x2, 0x2c5, 0x2c6, \n-    0x5, 0x17d, 0xbf, 0x2, 0x2c6, 0x2c7, 0x5, 0x17f, 0xc0, 0x2, 0x2c7, 0x2c8, \n-    0x5, 0x17d, 0xbf, 0x2, 0x2c8, 0x2c9, 0x5, 0x1a1, 0xd1, 0x2, 0x2c9, 0x2ca, \n-    0x5, 0x185, 0xc3, 0x2, 0x2ca, 0x2cb, 0x5, 0x1a1, 0xd1, 0x2, 0x2cb, 0x44, \n-    0x3, 0x2, 0x2, 0x2, 0x2cc, 0x2cd, 0x5, 0x183, 0xc2, 0x2, 0x2cd, 0x2ce, \n-    0x5, 0x17d, 0xbf, 0x2, 0x2ce, 0x2cf, 0x5, 0x1a3, 0xd2, 0x2, 0x2cf, 0x2d0, \n-    0x5, 0x185, 0xc3, 0x2, 0x2d0, 0x46, 0x3, 0x2, 0x2, 0x2, 0x2d1, 0x2d2, \n-    0x5, 0x183, 0xc2, 0x2, 0x2d2, 0x2d3, 0x5, 0x17d, 0xbf, 0x2, 0x2d3, 0x2d4, \n-    0x5, 0x1ad, 0xd7, 0x2, 0x2d4, 0x48, 0x3, 0x2, 0x2, 0x2, 0x2d5, 0x2d6, \n-    0x5, 0x183, 0xc2, 0x2, 0x2d6, 0x2d7, 0x5, 0x185, 0xc3, 0x2, 0x2d7, 0x2d8, \n-    0x5, 0x183, 0xc2, 0x2, 0x2d8, 0x2d9, 0x5, 0x1a5, 0xd3, 0x2, 0x2d9, 0x2da, \n-    0x5, 0x19b, 0xce, 0x2, 0x2da, 0x2db, 0x5, 0x193, 0xca, 0x2, 0x2db, 0x2dc, \n-    0x5, 0x18d, 0xc7, 0x2, 0x2dc, 0x2dd, 0x5, 0x181, 0xc1, 0x2, 0x2dd, 0x2de, \n-    0x5, 0x17d, 0xbf, 0x2, 0x2de, 0x2df, 0x5, 0x1a3, 0xd2, 0x2, 0x2df, 0x2e0, \n-    0x5, 0x185, 0xc3, 0x2, 0x2e0, 0x4a, 0x3, 0x2, 0x2, 0x2, 0x2e1, 0x2e2, \n-    0x5, 0x183, 0xc2, 0x2, 0x2e2, 0x2e3, 0x5, 0x185, 0xc3, 0x2, 0x2e3, 0x2e4, \n-    0x5, 0x187, 0xc4, 0x2, 0x2e4, 0x2e5, 0x5, 0x17d, 0xbf, 0x2, 0x2e5, 0x2e6, \n-    0x5, 0x1a5, 0xd3, 0x2, 0x2e6, 0x2e7, 0x5, 0x193, 0xca, 0x2, 0x2e7, 0x2e8, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x2e8, 0x4c, 0x3, 0x2, 0x2, 0x2, 0x2e9, 0x2ea, \n-    0x5, 0x183, 0xc2, 0x2, 0x2ea, 0x2eb, 0x5, 0x185, 0xc3, 0x2, 0x2eb, 0x2ec, \n-    0x5, 0x193, 0xca, 0x2, 0x2ec, 0x2ed, 0x5, 0x17d, 0xbf, 0x2, 0x2ed, 0x2ee, \n-    0x5, 0x1ad, 0xd7, 0x2, 0x2ee, 0x4e, 0x3, 0x2, 0x2, 0x2, 0x2ef, 0x2f0, \n-    0x5, 0x183, 0xc2, 0x2, 0x2f0, 0x2f1, 0x5, 0x185, 0xc3, 0x2, 0x2f1, 0x2f2, \n-    0x5, 0x193, 0xca, 0x2, 0x2f2, 0x2f3, 0x5, 0x185, 0xc3, 0x2, 0x2f3, 0x2f4, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x2f4, 0x2f5, 0x5, 0x185, 0xc3, 0x2, 0x2f5, 0x50, \n-    0x3, 0x2, 0x2, 0x2, 0x2f6, 0x2f7, 0x5, 0x183, 0xc2, 0x2, 0x2f7, 0x2f8, \n-    0x5, 0x185, 0xc3, 0x2, 0x2f8, 0x2f9, 0x5, 0x1a1, 0xd1, 0x2, 0x2f9, 0x2fa, \n-    0x5, 0x181, 0xc1, 0x2, 0x2fa, 0x52, 0x3, 0x2, 0x2, 0x2, 0x2fb, 0x2fc, \n-    0x5, 0x183, 0xc2, 0x2, 0x2fc, 0x2fd, 0x5, 0x185, 0xc3, 0x2, 0x2fd, 0x2fe, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x2fe, 0x2ff, 0x5, 0x181, 0xc1, 0x2, 0x2ff, 0x300, \n-    0x5, 0x185, 0xc3, 0x2, 0x300, 0x301, 0x5, 0x197, 0xcc, 0x2, 0x301, 0x302, \n-    0x5, 0x183, 0xc2, 0x2, 0x302, 0x303, 0x5, 0x18d, 0xc7, 0x2, 0x303, 0x304, \n-    0x5, 0x197, 0xcc, 0x2, 0x304, 0x305, 0x5, 0x189, 0xc5, 0x2, 0x305, 0x54, \n-    0x3, 0x2, 0x2, 0x2, 0x306, 0x307, 0x5, 0x183, 0xc2, 0x2, 0x307, 0x308, \n-    0x5, 0x185, 0xc3, 0x2, 0x308, 0x309, 0x5, 0x1a1, 0xd1, 0x2, 0x309, 0x30a, \n-    0x5, 0x181, 0xc1, 0x2, 0x30a, 0x30b, 0x5, 0x19f, 0xd0, 0x2, 0x30b, 0x30c, \n-    0x5, 0x18d, 0xc7, 0x2, 0x30c, 0x30d, 0x5, 0x17f, 0xc0, 0x2, 0x30d, 0x30e, \n-    0x5, 0x185, 0xc3, 0x2, 0x30e, 0x56, 0x3, 0x2, 0x2, 0x2, 0x30f, 0x310, \n-    0x5, 0x183, 0xc2, 0x2, 0x310, 0x311, 0x5, 0x185, 0xc3, 0x2, 0x311, 0x312, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x312, 0x313, 0x5, 0x17d, 0xbf, 0x2, 0x313, 0x314, \n-    0x5, 0x181, 0xc1, 0x2, 0x314, 0x315, 0x5, 0x18b, 0xc6, 0x2, 0x315, 0x58, \n-    0x3, 0x2, 0x2, 0x2, 0x316, 0x317, 0x5, 0x183, 0xc2, 0x2, 0x317, 0x318, \n-    0x5, 0x18d, 0xc7, 0x2, 0x318, 0x319, 0x5, 0x181, 0xc1, 0x2, 0x319, 0x31a, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x31a, 0x31b, 0x5, 0x18d, 0xc7, 0x2, 0x31b, 0x31c, \n-    0x5, 0x199, 0xcd, 0x2, 0x31c, 0x31d, 0x5, 0x197, 0xcc, 0x2, 0x31d, 0x31e, \n-    0x5, 0x17d, 0xbf, 0x2, 0x31e, 0x31f, 0x5, 0x19f, 0xd0, 0x2, 0x31f, 0x320, \n-    0x5, 0x18d, 0xc7, 0x2, 0x320, 0x321, 0x5, 0x185, 0xc3, 0x2, 0x321, 0x322, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x322, 0x5a, 0x3, 0x2, 0x2, 0x2, 0x323, 0x324, \n-    0x5, 0x183, 0xc2, 0x2, 0x324, 0x325, 0x5, 0x18d, 0xc7, 0x2, 0x325, 0x326, \n-    0x5, 0x181, 0xc1, 0x2, 0x326, 0x327, 0x5, 0x1a3, 0xd2, 0x2, 0x327, 0x328, \n-    0x5, 0x18d, 0xc7, 0x2, 0x328, 0x329, 0x5, 0x199, 0xcd, 0x2, 0x329, 0x32a, \n-    0x5, 0x197, 0xcc, 0x2, 0x32a, 0x32b, 0x5, 0x17d, 0xbf, 0x2, 0x32b, 0x32c, \n-    0x5, 0x19f, 0xd0, 0x2, 0x32c, 0x32d, 0x5, 0x1ad, 0xd7, 0x2, 0x32d, 0x5c, \n-    0x3, 0x2, 0x2, 0x2, 0x32e, 0x32f, 0x5, 0x183, 0xc2, 0x2, 0x32f, 0x330, \n-    0x5, 0x18d, 0xc7, 0x2, 0x330, 0x331, 0x5, 0x1a1, 0xd1, 0x2, 0x331, 0x332, \n-    0x5, 0x191, 0xc9, 0x2, 0x332, 0x5e, 0x3, 0x2, 0x2, 0x2, 0x333, 0x334, \n-    0x5, 0x183, 0xc2, 0x2, 0x334, 0x335, 0x5, 0x18d, 0xc7, 0x2, 0x335, 0x336, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x336, 0x337, 0x5, 0x1a3, 0xd2, 0x2, 0x337, 0x338, \n-    0x5, 0x18d, 0xc7, 0x2, 0x338, 0x339, 0x5, 0x197, 0xcc, 0x2, 0x339, 0x33a, \n-    0x5, 0x181, 0xc1, 0x2, 0x33a, 0x33b, 0x5, 0x1a3, 0xd2, 0x2, 0x33b, 0x60, \n-    0x3, 0x2, 0x2, 0x2, 0x33c, 0x33d, 0x5, 0x183, 0xc2, 0x2, 0x33d, 0x33e, \n-    0x5, 0x18d, 0xc7, 0x2, 0x33e, 0x33f, 0x5, 0x1a1, 0xd1, 0x2, 0x33f, 0x340, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x340, 0x341, 0x5, 0x19f, 0xd0, 0x2, 0x341, 0x342, \n-    0x5, 0x18d, 0xc7, 0x2, 0x342, 0x343, 0x5, 0x17f, 0xc0, 0x2, 0x343, 0x344, \n-    0x5, 0x1a5, 0xd3, 0x2, 0x344, 0x345, 0x5, 0x1a3, 0xd2, 0x2, 0x345, 0x346, \n-    0x5, 0x185, 0xc3, 0x2, 0x346, 0x347, 0x5, 0x183, 0xc2, 0x2, 0x347, 0x62, \n-    0x3, 0x2, 0x2, 0x2, 0x348, 0x349, 0x5, 0x183, 0xc2, 0x2, 0x349, 0x34a, \n-    0x5, 0x19f, 0xd0, 0x2, 0x34a, 0x34b, 0x5, 0x199, 0xcd, 0x2, 0x34b, 0x34c, \n-    0x5, 0x19b, 0xce, 0x2, 0x34c, 0x64, 0x3, 0x2, 0x2, 0x2, 0x34d, 0x34e, \n-    0x5, 0x185, 0xc3, 0x2, 0x34e, 0x34f, 0x5, 0x193, 0xca, 0x2, 0x34f, 0x350, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x350, 0x351, 0x5, 0x185, 0xc3, 0x2, 0x351, 0x66, \n-    0x3, 0x2, 0x2, 0x2, 0x352, 0x353, 0x5, 0x185, 0xc3, 0x2, 0x353, 0x354, \n-    0x5, 0x197, 0xcc, 0x2, 0x354, 0x355, 0x5, 0x183, 0xc2, 0x2, 0x355, 0x68, \n-    0x3, 0x2, 0x2, 0x2, 0x356, 0x357, 0x5, 0x185, 0xc3, 0x2, 0x357, 0x358, \n-    0x5, 0x197, 0xcc, 0x2, 0x358, 0x359, 0x5, 0x189, 0xc5, 0x2, 0x359, 0x35a, \n-    0x5, 0x18d, 0xc7, 0x2, 0x35a, 0x35b, 0x5, 0x197, 0xcc, 0x2, 0x35b, 0x35c, \n-    0x5, 0x185, 0xc3, 0x2, 0x35c, 0x6a, 0x3, 0x2, 0x2, 0x2, 0x35d, 0x35e, \n-    0x5, 0x185, 0xc3, 0x2, 0x35e, 0x35f, 0x5, 0x1a7, 0xd4, 0x2, 0x35f, 0x360, \n-    0x5, 0x185, 0xc3, 0x2, 0x360, 0x361, 0x5, 0x197, 0xcc, 0x2, 0x361, 0x362, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x362, 0x363, 0x5, 0x1a1, 0xd1, 0x2, 0x363, 0x6c, \n-    0x3, 0x2, 0x2, 0x2, 0x364, 0x365, 0x5, 0x185, 0xc3, 0x2, 0x365, 0x366, \n-    0x5, 0x1ab, 0xd6, 0x2, 0x366, 0x367, 0x5, 0x18d, 0xc7, 0x2, 0x367, 0x368, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x368, 0x369, 0x5, 0x1a3, 0xd2, 0x2, 0x369, 0x36a, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x36a, 0x6e, 0x3, 0x2, 0x2, 0x2, 0x36b, 0x36c, \n-    0x5, 0x185, 0xc3, 0x2, 0x36c, 0x36d, 0x5, 0x1ab, 0xd6, 0x2, 0x36d, 0x36e, \n-    0x5, 0x19b, 0xce, 0x2, 0x36e, 0x36f, 0x5, 0x193, 0xca, 0x2, 0x36f, 0x370, \n-    0x5, 0x17d, 0xbf, 0x2, 0x370, 0x371, 0x5, 0x18d, 0xc7, 0x2, 0x371, 0x372, \n-    0x5, 0x197, 0xcc, 0x2, 0x372, 0x70, 0x3, 0x2, 0x2, 0x2, 0x373, 0x374, \n-    0x5, 0x185, 0xc3, 0x2, 0x374, 0x375, 0x5, 0x1ab, 0xd6, 0x2, 0x375, 0x376, \n-    0x5, 0x19b, 0xce, 0x2, 0x376, 0x377, 0x5, 0x19f, 0xd0, 0x2, 0x377, 0x378, \n-    0x5, 0x185, 0xc3, 0x2, 0x378, 0x379, 0x5, 0x1a1, 0xd1, 0x2, 0x379, 0x37a, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x37a, 0x37b, 0x5, 0x18d, 0xc7, 0x2, 0x37b, 0x37c, \n-    0x5, 0x199, 0xcd, 0x2, 0x37c, 0x37d, 0x5, 0x197, 0xcc, 0x2, 0x37d, 0x72, \n-    0x3, 0x2, 0x2, 0x2, 0x37e, 0x37f, 0x5, 0x185, 0xc3, 0x2, 0x37f, 0x380, \n-    0x5, 0x1ab, 0xd6, 0x2, 0x380, 0x381, 0x5, 0x1a3, 0xd2, 0x2, 0x381, 0x382, \n-    0x5, 0x19f, 0xd0, 0x2, 0x382, 0x383, 0x5, 0x17d, 0xbf, 0x2, 0x383, 0x384, \n-    0x5, 0x181, 0xc1, 0x2, 0x384, 0x385, 0x5, 0x1a3, 0xd2, 0x2, 0x385, 0x74, \n-    0x3, 0x2, 0x2, 0x2, 0x386, 0x387, 0x5, 0x187, 0xc4, 0x2, 0x387, 0x388, \n-    0x5, 0x185, 0xc3, 0x2, 0x388, 0x389, 0x5, 0x1a3, 0xd2, 0x2, 0x389, 0x38a, \n-    0x5, 0x181, 0xc1, 0x2, 0x38a, 0x38b, 0x5, 0x18b, 0xc6, 0x2, 0x38b, 0x38c, \n-    0x5, 0x185, 0xc3, 0x2, 0x38c, 0x38d, 0x5, 0x1a1, 0xd1, 0x2, 0x38d, 0x76, \n-    0x3, 0x2, 0x2, 0x2, 0x38e, 0x38f, 0x5, 0x187, 0xc4, 0x2, 0x38f, 0x390, \n-    0x5, 0x18d, 0xc7, 0x2, 0x390, 0x391, 0x5, 0x197, 0xcc, 0x2, 0x391, 0x392, \n-    0x5, 0x17d, 0xbf, 0x2, 0x392, 0x393, 0x5, 0x193, 0xca, 0x2, 0x393, 0x78, \n-    0x3, 0x2, 0x2, 0x2, 0x394, 0x395, 0x5, 0x187, 0xc4, 0x2, 0x395, 0x396, \n-    0x5, 0x18d, 0xc7, 0x2, 0x396, 0x397, 0x5, 0x19f, 0xd0, 0x2, 0x397, 0x398, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x398, 0x399, 0x5, 0x1a3, 0xd2, 0x2, 0x399, 0x7a, \n-    0x3, 0x2, 0x2, 0x2, 0x39a, 0x39b, 0x5, 0x187, 0xc4, 0x2, 0x39b, 0x39c, \n-    0x5, 0x193, 0xca, 0x2, 0x39c, 0x39d, 0x5, 0x1a5, 0xd3, 0x2, 0x39d, 0x39e, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x39e, 0x39f, 0x5, 0x18b, 0xc6, 0x2, 0x39f, 0x7c, \n-    0x3, 0x2, 0x2, 0x2, 0x3a0, 0x3a1, 0x5, 0x187, 0xc4, 0x2, 0x3a1, 0x3a2, \n-    0x5, 0x199, 0xcd, 0x2, 0x3a2, 0x3a3, 0x5, 0x19f, 0xd0, 0x2, 0x3a3, 0x7e, \n-    0x3, 0x2, 0x2, 0x2, 0x3a4, 0x3a5, 0x5, 0x187, 0xc4, 0x2, 0x3a5, 0x3a6, \n-    0x5, 0x199, 0xcd, 0x2, 0x3a6, 0x3a7, 0x5, 0x19f, 0xd0, 0x2, 0x3a7, 0x3a8, \n-    0x5, 0x195, 0xcb, 0x2, 0x3a8, 0x3a9, 0x5, 0x17d, 0xbf, 0x2, 0x3a9, 0x3aa, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x3aa, 0x80, 0x3, 0x2, 0x2, 0x2, 0x3ab, 0x3ac, \n-    0x5, 0x187, 0xc4, 0x2, 0x3ac, 0x3ad, 0x5, 0x19f, 0xd0, 0x2, 0x3ad, 0x3ae, \n-    0x5, 0x185, 0xc3, 0x2, 0x3ae, 0x3af, 0x5, 0x185, 0xc3, 0x2, 0x3af, 0x3b0, \n-    0x5, 0x1af, 0xd8, 0x2, 0x3b0, 0x3b1, 0x5, 0x185, 0xc3, 0x2, 0x3b1, 0x82, \n-    0x3, 0x2, 0x2, 0x2, 0x3b2, 0x3b3, 0x5, 0x187, 0xc4, 0x2, 0x3b3, 0x3b4, \n-    0x5, 0x19f, 0xd0, 0x2, 0x3b4, 0x3b5, 0x5, 0x199, 0xcd, 0x2, 0x3b5, 0x3b6, \n-    0x5, 0x195, 0xcb, 0x2, 0x3b6, 0x84, 0x3, 0x2, 0x2, 0x2, 0x3b7, 0x3b8, \n-    0x5, 0x187, 0xc4, 0x2, 0x3b8, 0x3b9, 0x5, 0x1a5, 0xd3, 0x2, 0x3b9, 0x3ba, \n-    0x5, 0x193, 0xca, 0x2, 0x3ba, 0x3bb, 0x5, 0x193, 0xca, 0x2, 0x3bb, 0x86, \n-    0x3, 0x2, 0x2, 0x2, 0x3bc, 0x3bd, 0x5, 0x187, 0xc4, 0x2, 0x3bd, 0x3be, \n-    0x5, 0x1a5, 0xd3, 0x2, 0x3be, 0x3bf, 0x5, 0x197, 0xcc, 0x2, 0x3bf, 0x3c0, \n-    0x5, 0x181, 0xc1, 0x2, 0x3c0, 0x3c1, 0x5, 0x1a3, 0xd2, 0x2, 0x3c1, 0x3c2, \n-    0x5, 0x18d, 0xc7, 0x2, 0x3c2, 0x3c3, 0x5, 0x199, 0xcd, 0x2, 0x3c3, 0x3c4, \n-    0x5, 0x197, 0xcc, 0x2, 0x3c4, 0x88, 0x3, 0x2, 0x2, 0x2, 0x3c5, 0x3c6, \n-    0x5, 0x189, 0xc5, 0x2, 0x3c6, 0x3c7, 0x5, 0x193, 0xca, 0x2, 0x3c7, 0x3c8, \n-    0x5, 0x199, 0xcd, 0x2, 0x3c8, 0x3c9, 0x5, 0x17f, 0xc0, 0x2, 0x3c9, 0x3ca, \n-    0x5, 0x17d, 0xbf, 0x2, 0x3ca, 0x3cb, 0x5, 0x193, 0xca, 0x2, 0x3cb, 0x8a, \n-    0x3, 0x2, 0x2, 0x2, 0x3cc, 0x3cd, 0x5, 0x189, 0xc5, 0x2, 0x3cd, 0x3ce, \n-    0x5, 0x19f, 0xd0, 0x2, 0x3ce, 0x3cf, 0x5, 0x17d, 0xbf, 0x2, 0x3cf, 0x3d0, \n-    0x5, 0x197, 0xcc, 0x2, 0x3d0, 0x3d1, 0x5, 0x1a5, 0xd3, 0x2, 0x3d1, 0x3d2, \n-    0x5, 0x193, 0xca, 0x2, 0x3d2, 0x3d3, 0x5, 0x17d, 0xbf, 0x2, 0x3d3, 0x3d4, \n-    0x5, 0x19f, 0xd0, 0x2, 0x3d4, 0x3d5, 0x5, 0x18d, 0xc7, 0x2, 0x3d5, 0x3d6, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x3d6, 0x3d7, 0x5, 0x1ad, 0xd7, 0x2, 0x3d7, 0x8c, \n-    0x3, 0x2, 0x2, 0x2, 0x3d8, 0x3d9, 0x5, 0x189, 0xc5, 0x2, 0x3d9, 0x3da, \n-    0x5, 0x19f, 0xd0, 0x2, 0x3da, 0x3db, 0x5, 0x199, 0xcd, 0x2, 0x3db, 0x3dc, \n-    0x5, 0x1a5, 0xd3, 0x2, 0x3dc, 0x3dd, 0x5, 0x19b, 0xce, 0x2, 0x3dd, 0x8e, \n-    0x3, 0x2, 0x2, 0x2, 0x3de, 0x3df, 0x5, 0x18b, 0xc6, 0x2, 0x3df, 0x3e0, \n-    0x5, 0x17d, 0xbf, 0x2, 0x3e0, 0x3e1, 0x5, 0x1a7, 0xd4, 0x2, 0x3e1, 0x3e2, \n-    0x5, 0x18d, 0xc7, 0x2, 0x3e2, 0x3e3, 0x5, 0x197, 0xcc, 0x2, 0x3e3, 0x3e4, \n-    0x5, 0x189, 0xc5, 0x2, 0x3e4, 0x90, 0x3, 0x2, 0x2, 0x2, 0x3e5, 0x3e6, \n-    0x5, 0x18b, 0xc6, 0x2, 0x3e6, 0x3e7, 0x5, 0x18d, 0xc7, 0x2, 0x3e7, 0x3e8, \n-    0x5, 0x185, 0xc3, 0x2, 0x3e8, 0x3e9, 0x5, 0x19f, 0xd0, 0x2, 0x3e9, 0x3ea, \n-    0x5, 0x17d, 0xbf, 0x2, 0x3ea, 0x3eb, 0x5, 0x19f, 0xd0, 0x2, 0x3eb, 0x3ec, \n-    0x5, 0x181, 0xc1, 0x2, 0x3ec, 0x3ed, 0x5, 0x18b, 0xc6, 0x2, 0x3ed, 0x3ee, \n-    0x5, 0x18d, 0xc7, 0x2, 0x3ee, 0x3ef, 0x5, 0x181, 0xc1, 0x2, 0x3ef, 0x3f0, \n-    0x5, 0x17d, 0xbf, 0x2, 0x3f0, 0x3f1, 0x5, 0x193, 0xca, 0x2, 0x3f1, 0x92, \n-    0x3, 0x2, 0x2, 0x2, 0x3f2, 0x3f3, 0x5, 0x18b, 0xc6, 0x2, 0x3f3, 0x3f4, \n-    0x5, 0x199, 0xcd, 0x2, 0x3f4, 0x3f5, 0x5, 0x1a5, 0xd3, 0x2, 0x3f5, 0x3f6, \n-    0x5, 0x19f, 0xd0, 0x2, 0x3f6, 0x94, 0x3, 0x2, 0x2, 0x2, 0x3f7, 0x3f8, \n-    0x5, 0x18d, 0xc7, 0x2, 0x3f8, 0x3f9, 0x5, 0x183, 0xc2, 0x2, 0x3f9, 0x96, \n-    0x3, 0x2, 0x2, 0x2, 0x3fa, 0x3fb, 0x5, 0x18d, 0xc7, 0x2, 0x3fb, 0x3fc, \n-    0x5, 0x187, 0xc4, 0x2, 0x3fc, 0x98, 0x3, 0x2, 0x2, 0x2, 0x3fd, 0x3fe, \n-    0x5, 0x18d, 0xc7, 0x2, 0x3fe, 0x3ff, 0x5, 0x193, 0xca, 0x2, 0x3ff, 0x400, \n-    0x5, 0x18d, 0xc7, 0x2, 0x400, 0x401, 0x5, 0x191, 0xc9, 0x2, 0x401, 0x402, \n-    0x5, 0x185, 0xc3, 0x2, 0x402, 0x9a, 0x3, 0x2, 0x2, 0x2, 0x403, 0x404, \n-    0x5, 0x18d, 0xc7, 0x2, 0x404, 0x405, 0x5, 0x197, 0xcc, 0x2, 0x405, 0x9c, \n-    0x3, 0x2, 0x2, 0x2, 0x406, 0x407, 0x5, 0x18d, 0xc7, 0x2, 0x407, 0x408, \n-    0x5, 0x197, 0xcc, 0x2, 0x408, 0x409, 0x5, 0x183, 0xc2, 0x2, 0x409, 0x40a, \n-    0x5, 0x185, 0xc3, 0x2, 0x40a, 0x40b, 0x5, 0x1ab, 0xd6, 0x2, 0x40b, 0x9e, \n-    0x3, 0x2, 0x2, 0x2, 0x40c, 0x40d, 0x5, 0x18d, 0xc7, 0x2, 0x40d, 0x40e, \n-    0x5, 0x197, 0xcc, 0x2, 0x40e, 0x40f, 0x5, 0x187, 0xc4, 0x2, 0x40f, 0x41a, \n-    0x3, 0x2, 0x2, 0x2, 0x410, 0x411, 0x5, 0x18d, 0xc7, 0x2, 0x411, 0x412, \n-    0x5, 0x197, 0xcc, 0x2, 0x412, 0x413, 0x5, 0x187, 0xc4, 0x2, 0x413, 0x414, \n-    0x5, 0x18d, 0xc7, 0x2, 0x414, 0x415, 0x5, 0x197, 0xcc, 0x2, 0x415, 0x416, \n-    0x5, 0x18d, 0xc7, 0x2, 0x416, 0x417, 0x5, 0x1a3, 0xd2, 0x2, 0x417, 0x418, \n-    0x5, 0x1ad, 0xd7, 0x2, 0x418, 0x41a, 0x3, 0x2, 0x2, 0x2, 0x419, 0x40c, \n-    0x3, 0x2, 0x2, 0x2, 0x419, 0x410, 0x3, 0x2, 0x2, 0x2, 0x41a, 0xa0, 0x3, \n-    0x2, 0x2, 0x2, 0x41b, 0x41c, 0x5, 0x18d, 0xc7, 0x2, 0x41c, 0x41d, 0x5, \n-    0x197, 0xcc, 0x2, 0x41d, 0x41e, 0x5, 0x18f, 0xc8, 0x2, 0x41e, 0x41f, \n-    0x5, 0x185, 0xc3, 0x2, 0x41f, 0x420, 0x5, 0x181, 0xc1, 0x2, 0x420, 0x421, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x421, 0x422, 0x5, 0x18d, 0xc7, 0x2, 0x422, 0x423, \n-    0x5, 0x1a7, 0xd4, 0x2, 0x423, 0x424, 0x5, 0x185, 0xc3, 0x2, 0x424, 0xa2, \n-    0x3, 0x2, 0x2, 0x2, 0x425, 0x426, 0x5, 0x18d, 0xc7, 0x2, 0x426, 0x427, \n-    0x5, 0x197, 0xcc, 0x2, 0x427, 0x428, 0x5, 0x197, 0xcc, 0x2, 0x428, 0x429, \n-    0x5, 0x185, 0xc3, 0x2, 0x429, 0x42a, 0x5, 0x19f, 0xd0, 0x2, 0x42a, 0xa4, \n-    0x3, 0x2, 0x2, 0x2, 0x42b, 0x42c, 0x5, 0x18d, 0xc7, 0x2, 0x42c, 0x42d, \n-    0x5, 0x197, 0xcc, 0x2, 0x42d, 0x42e, 0x5, 0x1a1, 0xd1, 0x2, 0x42e, 0x42f, \n-    0x5, 0x185, 0xc3, 0x2, 0x42f, 0x430, 0x5, 0x19f, 0xd0, 0x2, 0x430, 0x431, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x431, 0xa6, 0x3, 0x2, 0x2, 0x2, 0x432, 0x433, \n-    0x5, 0x18d, 0xc7, 0x2, 0x433, 0x434, 0x5, 0x197, 0xcc, 0x2, 0x434, 0x435, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x435, 0x436, 0x5, 0x185, 0xc3, 0x2, 0x436, 0x437, \n-    0x5, 0x19f, 0xd0, 0x2, 0x437, 0x438, 0x5, 0x1a7, 0xd4, 0x2, 0x438, 0x439, \n-    0x5, 0x17d, 0xbf, 0x2, 0x439, 0x43a, 0x5, 0x193, 0xca, 0x2, 0x43a, 0xa8, \n-    0x3, 0x2, 0x2, 0x2, 0x43b, 0x43c, 0x5, 0x18d, 0xc7, 0x2, 0x43c, 0x43d, \n-    0x5, 0x197, 0xcc, 0x2, 0x43d, 0x43e, 0x5, 0x1a3, 0xd2, 0x2, 0x43e, 0x43f, \n-    0x5, 0x199, 0xcd, 0x2, 0x43f, 0xaa, 0x3, 0x2, 0x2, 0x2, 0x440, 0x441, \n-    0x5, 0x18d, 0xc7, 0x2, 0x441, 0x442, 0x5, 0x1a1, 0xd1, 0x2, 0x442, 0xac, \n-    0x3, 0x2, 0x2, 0x2, 0x443, 0x444, 0x5, 0x18d, 0xc7, 0x2, 0x444, 0x445, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x445, 0x446, 0x5, 0x1f3, 0xfa, 0x2, 0x446, 0x447, \n-    0x5, 0x199, 0xcd, 0x2, 0x447, 0x448, 0x5, 0x17f, 0xc0, 0x2, 0x448, 0x449, \n-    0x5, 0x18f, 0xc8, 0x2, 0x449, 0x44a, 0x5, 0x185, 0xc3, 0x2, 0x44a, 0x44b, \n-    0x5, 0x181, 0xc1, 0x2, 0x44b, 0x44c, 0x5, 0x1a3, 0xd2, 0x2, 0x44c, 0x44d, \n-    0x5, 0x1f3, 0xfa, 0x2, 0x44d, 0x44e, 0x5, 0x18d, 0xc7, 0x2, 0x44e, 0x44f, \n-    0x5, 0x183, 0xc2, 0x2, 0x44f, 0xae, 0x3, 0x2, 0x2, 0x2, 0x450, 0x451, \n-    0x5, 0x18f, 0xc8, 0x2, 0x451, 0x452, 0x5, 0x199, 0xcd, 0x2, 0x452, 0x453, \n-    0x5, 0x18d, 0xc7, 0x2, 0x453, 0x454, 0x5, 0x197, 0xcc, 0x2, 0x454, 0xb0, \n-    0x3, 0x2, 0x2, 0x2, 0x455, 0x456, 0x5, 0x191, 0xc9, 0x2, 0x456, 0x457, \n-    0x5, 0x185, 0xc3, 0x2, 0x457, 0x458, 0x5, 0x1ad, 0xd7, 0x2, 0x458, 0xb2, \n-    0x3, 0x2, 0x2, 0x2, 0x459, 0x45a, 0x5, 0x191, 0xc9, 0x2, 0x45a, 0x45b, \n-    0x5, 0x18d, 0xc7, 0x2, 0x45b, 0x45c, 0x5, 0x193, 0xca, 0x2, 0x45c, 0x45d, \n-    0x5, 0x193, 0xca, 0x2, 0x45d, 0xb4, 0x3, 0x2, 0x2, 0x2, 0x45e, 0x45f, \n-    0x5, 0x193, 0xca, 0x2, 0x45f, 0x460, 0x5, 0x17d, 0xbf, 0x2, 0x460, 0x461, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x461, 0x462, 0x5, 0x1a3, 0xd2, 0x2, 0x462, 0xb6, \n-    0x3, 0x2, 0x2, 0x2, 0x463, 0x464, 0x5, 0x193, 0xca, 0x2, 0x464, 0x465, \n-    0x5, 0x17d, 0xbf, 0x2, 0x465, 0x466, 0x5, 0x1ad, 0xd7, 0x2, 0x466, 0x467, \n-    0x5, 0x199, 0xcd, 0x2, 0x467, 0x468, 0x5, 0x1a5, 0xd3, 0x2, 0x468, 0x469, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x469, 0xb8, 0x3, 0x2, 0x2, 0x2, 0x46a, 0x46b, \n-    0x5, 0x193, 0xca, 0x2, 0x46b, 0x46c, 0x5, 0x185, 0xc3, 0x2, 0x46c, 0x46d, \n-    0x5, 0x17d, 0xbf, 0x2, 0x46d, 0x46e, 0x5, 0x183, 0xc2, 0x2, 0x46e, 0x46f, \n-    0x5, 0x18d, 0xc7, 0x2, 0x46f, 0x470, 0x5, 0x197, 0xcc, 0x2, 0x470, 0x471, \n-    0x5, 0x189, 0xc5, 0x2, 0x471, 0xba, 0x3, 0x2, 0x2, 0x2, 0x472, 0x473, \n-    0x5, 0x193, 0xca, 0x2, 0x473, 0x474, 0x5, 0x185, 0xc3, 0x2, 0x474, 0x475, \n-    0x5, 0x187, 0xc4, 0x2, 0x475, 0x476, 0x5, 0x1a3, 0xd2, 0x2, 0x476, 0xbc, \n-    0x3, 0x2, 0x2, 0x2, 0x477, 0x478, 0x5, 0x193, 0xca, 0x2, 0x478, 0x479, \n-    0x5, 0x18d, 0xc7, 0x2, 0x479, 0x47a, 0x5, 0x187, 0xc4, 0x2, 0x47a, 0x47b, \n-    0x5, 0x185, 0xc3, 0x2, 0x47b, 0x47c, 0x5, 0x1a3, 0xd2, 0x2, 0x47c, 0x47d, \n-    0x5, 0x18d, 0xc7, 0x2, 0x47d, 0x47e, 0x5, 0x195, 0xcb, 0x2, 0x47e, 0x47f, \n-    0x5, 0x185, 0xc3, 0x2, 0x47f, 0xbe, 0x3, 0x2, 0x2, 0x2, 0x480, 0x481, \n-    0x5, 0x193, 0xca, 0x2, 0x481, 0x482, 0x5, 0x18d, 0xc7, 0x2, 0x482, 0x483, \n-    0x5, 0x191, 0xc9, 0x2, 0x483, 0x484, 0x5, 0x185, 0xc3, 0x2, 0x484, 0xc0, \n-    0x3, 0x2, 0x2, 0x2, 0x485, 0x486, 0x5, 0x193, 0xca, 0x2, 0x486, 0x487, \n-    0x5, 0x18d, 0xc7, 0x2, 0x487, 0x488, 0x5, 0x195, 0xcb, 0x2, 0x488, 0x489, \n-    0x5, 0x18d, 0xc7, 0x2, 0x489, 0x48a, 0x5, 0x1a3, 0xd2, 0x2, 0x48a, 0xc2, \n-    0x3, 0x2, 0x2, 0x2, 0x48b, 0x48c, 0x5, 0x193, 0xca, 0x2, 0x48c, 0x48d, \n-    0x5, 0x18d, 0xc7, 0x2, 0x48d, 0x48e, 0x5, 0x1a7, 0xd4, 0x2, 0x48e, 0x48f, \n-    0x5, 0x185, 0xc3, 0x2, 0x48f, 0xc4, 0x3, 0x2, 0x2, 0x2, 0x490, 0x491, \n-    0x5, 0x193, 0xca, 0x2, 0x491, 0x492, 0x5, 0x199, 0xcd, 0x2, 0x492, 0x493, \n-    0x5, 0x181, 0xc1, 0x2, 0x493, 0x494, 0x5, 0x17d, 0xbf, 0x2, 0x494, 0x495, \n-    0x5, 0x193, 0xca, 0x2, 0x495, 0xc6, 0x3, 0x2, 0x2, 0x2, 0x496, 0x497, \n-    0x5, 0x193, 0xca, 0x2, 0x497, 0x498, 0x5, 0x199, 0xcd, 0x2, 0x498, 0x499, \n-    0x5, 0x189, 0xc5, 0x2, 0x499, 0x49a, 0x5, 0x1a1, 0xd1, 0x2, 0x49a, 0xc8, \n-    0x3, 0x2, 0x2, 0x2, 0x49b, 0x49c, 0x5, 0x195, 0xcb, 0x2, 0x49c, 0x49d, \n-    0x5, 0x17d, 0xbf, 0x2, 0x49d, 0x49e, 0x5, 0x1a3, 0xd2, 0x2, 0x49e, 0x49f, \n-    0x5, 0x185, 0xc3, 0x2, 0x49f, 0x4a0, 0x5, 0x19f, 0xd0, 0x2, 0x4a0, 0x4a1, \n-    0x5, 0x18d, 0xc7, 0x2, 0x4a1, 0x4a2, 0x5, 0x17d, 0xbf, 0x2, 0x4a2, 0x4a3, \n-    0x5, 0x193, 0xca, 0x2, 0x4a3, 0x4a4, 0x5, 0x18d, 0xc7, 0x2, 0x4a4, 0x4a5, \n-    0x5, 0x1af, 0xd8, 0x2, 0x4a5, 0x4a6, 0x5, 0x185, 0xc3, 0x2, 0x4a6, 0xca, \n-    0x3, 0x2, 0x2, 0x2, 0x4a7, 0x4a8, 0x5, 0x195, 0xcb, 0x2, 0x4a8, 0x4a9, \n-    0x5, 0x17d, 0xbf, 0x2, 0x4a9, 0x4aa, 0x5, 0x1a3, 0xd2, 0x2, 0x4aa, 0x4ab, \n-    0x5, 0x185, 0xc3, 0x2, 0x4ab, 0x4ac, 0x5, 0x19f, 0xd0, 0x2, 0x4ac, 0x4ad, \n-    0x5, 0x18d, 0xc7, 0x2, 0x4ad, 0x4ae, 0x5, 0x17d, 0xbf, 0x2, 0x4ae, 0x4af, \n-    0x5, 0x193, 0xca, 0x2, 0x4af, 0x4b0, 0x5, 0x18d, 0xc7, 0x2, 0x4b0, 0x4b1, \n-    0x5, 0x1af, 0xd8, 0x2, 0x4b1, 0x4b2, 0x5, 0x185, 0xc3, 0x2, 0x4b2, 0x4b3, \n-    0x5, 0x183, 0xc2, 0x2, 0x4b3, 0xcc, 0x3, 0x2, 0x2, 0x2, 0x4b4, 0x4b5, \n-    0x5, 0x195, 0xcb, 0x2, 0x4b5, 0x4b6, 0x5, 0x17d, 0xbf, 0x2, 0x4b6, 0x4b7, \n-    0x5, 0x1ab, 0xd6, 0x2, 0x4b7, 0xce, 0x3, 0x2, 0x2, 0x2, 0x4b8, 0x4b9, \n-    0x5, 0x195, 0xcb, 0x2, 0x4b9, 0x4ba, 0x5, 0x185, 0xc3, 0x2, 0x4ba, 0x4bb, \n-    0x5, 0x19f, 0xd0, 0x2, 0x4bb, 0x4bc, 0x5, 0x189, 0xc5, 0x2, 0x4bc, 0x4bd, \n-    0x5, 0x185, 0xc3, 0x2, 0x4bd, 0x4be, 0x5, 0x1a1, 0xd1, 0x2, 0x4be, 0xd0, \n-    0x3, 0x2, 0x2, 0x2, 0x4bf, 0x4c0, 0x5, 0x195, 0xcb, 0x2, 0x4c0, 0x4c1, \n-    0x5, 0x18d, 0xc7, 0x2, 0x4c1, 0x4c2, 0x5, 0x197, 0xcc, 0x2, 0x4c2, 0xd2, \n-    0x3, 0x2, 0x2, 0x2, 0x4c3, 0x4c4, 0x5, 0x195, 0xcb, 0x2, 0x4c4, 0x4c5, \n-    0x5, 0x18d, 0xc7, 0x2, 0x4c5, 0x4c6, 0x5, 0x197, 0xcc, 0x2, 0x4c6, 0x4c7, \n-    0x5, 0x1a5, 0xd3, 0x2, 0x4c7, 0x4c8, 0x5, 0x1a3, 0xd2, 0x2, 0x4c8, 0x4c9, \n-    0x5, 0x185, 0xc3, 0x2, 0x4c9, 0xd4, 0x3, 0x2, 0x2, 0x2, 0x4ca, 0x4cb, \n-    0x5, 0x195, 0xcb, 0x2, 0x4cb, 0x4cc, 0x5, 0x199, 0xcd, 0x2, 0x4cc, 0x4cd, \n-    0x5, 0x183, 0xc2, 0x2, 0x4cd, 0x4ce, 0x5, 0x18d, 0xc7, 0x2, 0x4ce, 0x4cf, \n-    0x5, 0x187, 0xc4, 0x2, 0x4cf, 0x4d0, 0x5, 0x1ad, 0xd7, 0x2, 0x4d0, 0xd6, \n-    0x3, 0x2, 0x2, 0x2, 0x4d1, 0x4d2, 0x5, 0x195, 0xcb, 0x2, 0x4d2, 0x4d3, \n-    0x5, 0x199, 0xcd, 0x2, 0x4d3, 0x4d4, 0x5, 0x197, 0xcc, 0x2, 0x4d4, 0x4d5, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x4d5, 0x4d6, 0x5, 0x18b, 0xc6, 0x2, 0x4d6, 0xd8, \n-    0x3, 0x2, 0x2, 0x2, 0x4d7, 0x4d8, 0x5, 0x195, 0xcb, 0x2, 0x4d8, 0x4d9, \n-    0x5, 0x199, 0xcd, 0x2, 0x4d9, 0x4da, 0x5, 0x1a7, 0xd4, 0x2, 0x4da, 0x4db, \n-    0x5, 0x185, 0xc3, 0x2, 0x4db, 0xda, 0x3, 0x2, 0x2, 0x2, 0x4dc, 0x4dd, \n-    0x5, 0x195, 0xcb, 0x2, 0x4dd, 0x4de, 0x5, 0x1a5, 0xd3, 0x2, 0x4de, 0x4df, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x4df, 0x4e0, 0x5, 0x17d, 0xbf, 0x2, 0x4e0, 0x4e1, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x4e1, 0x4e2, 0x5, 0x18d, 0xc7, 0x2, 0x4e2, 0x4e3, \n-    0x5, 0x199, 0xcd, 0x2, 0x4e3, 0x4e4, 0x5, 0x197, 0xcc, 0x2, 0x4e4, 0xdc, \n-    0x3, 0x2, 0x2, 0x2, 0x4e5, 0x4e6, 0x5, 0x197, 0xcc, 0x2, 0x4e6, 0x4e7, \n-    0x5, 0x17d, 0xbf, 0x2, 0x4e7, 0x4e8, 0x5, 0x197, 0xcc, 0x2, 0x4e8, 0xde, \n-    0x3, 0x2, 0x2, 0x2, 0x4e9, 0x4ea, 0x5, 0x197, 0xcc, 0x2, 0x4ea, 0x4eb, \n-    0x5, 0x199, 0xcd, 0x2, 0x4eb, 0xe0, 0x3, 0x2, 0x2, 0x2, 0x4ec, 0x4ed, \n-    0x5, 0x197, 0xcc, 0x2, 0x4ed, 0x4ee, 0x5, 0x199, 0xcd, 0x2, 0x4ee, 0x4ef, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x4ef, 0xe2, 0x3, 0x2, 0x2, 0x2, 0x4f0, 0x4f1, \n-    0x5, 0x197, 0xcc, 0x2, 0x4f1, 0x4f2, 0x5, 0x1a5, 0xd3, 0x2, 0x4f2, 0x4f3, \n-    0x5, 0x193, 0xca, 0x2, 0x4f3, 0x4f4, 0x5, 0x193, 0xca, 0x2, 0x4f4, 0xe4, \n-    0x3, 0x2, 0x2, 0x2, 0x4f5, 0x4f6, 0x5, 0x197, 0xcc, 0x2, 0x4f6, 0x4f7, \n-    0x5, 0x1a5, 0xd3, 0x2, 0x4f7, 0x4f8, 0x5, 0x193, 0xca, 0x2, 0x4f8, 0x4f9, \n-    0x5, 0x193, 0xca, 0x2, 0x4f9, 0x4fa, 0x5, 0x1a1, 0xd1, 0x2, 0x4fa, 0xe6, \n-    0x3, 0x2, 0x2, 0x2, 0x4fb, 0x4fc, 0x5, 0x199, 0xcd, 0x2, 0x4fc, 0x4fd, \n-    0x5, 0x187, 0xc4, 0x2, 0x4fd, 0x4fe, 0x5, 0x187, 0xc4, 0x2, 0x4fe, 0x4ff, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x4ff, 0x500, 0x5, 0x185, 0xc3, 0x2, 0x500, 0x501, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x501, 0xe8, 0x3, 0x2, 0x2, 0x2, 0x502, 0x503, \n-    0x5, 0x199, 0xcd, 0x2, 0x503, 0x504, 0x5, 0x197, 0xcc, 0x2, 0x504, 0xea, \n-    0x3, 0x2, 0x2, 0x2, 0x505, 0x506, 0x5, 0x199, 0xcd, 0x2, 0x506, 0x507, \n-    0x5, 0x19b, 0xce, 0x2, 0x507, 0x508, 0x5, 0x1a3, 0xd2, 0x2, 0x508, 0x509, \n-    0x5, 0x18d, 0xc7, 0x2, 0x509, 0x50a, 0x5, 0x195, 0xcb, 0x2, 0x50a, 0x50b, \n-    0x5, 0x18d, 0xc7, 0x2, 0x50b, 0x50c, 0x5, 0x1af, 0xd8, 0x2, 0x50c, 0x50d, \n-    0x5, 0x185, 0xc3, 0x2, 0x50d, 0xec, 0x3, 0x2, 0x2, 0x2, 0x50e, 0x50f, \n-    0x5, 0x199, 0xcd, 0x2, 0x50f, 0x510, 0x5, 0x19f, 0xd0, 0x2, 0x510, 0xee, \n-    0x3, 0x2, 0x2, 0x2, 0x511, 0x512, 0x5, 0x199, 0xcd, 0x2, 0x512, 0x513, \n-    0x5, 0x19f, 0xd0, 0x2, 0x513, 0x514, 0x5, 0x183, 0xc2, 0x2, 0x514, 0x515, \n-    0x5, 0x185, 0xc3, 0x2, 0x515, 0x516, 0x5, 0x19f, 0xd0, 0x2, 0x516, 0xf0, \n-    0x3, 0x2, 0x2, 0x2, 0x517, 0x518, 0x5, 0x199, 0xcd, 0x2, 0x518, 0x519, \n-    0x5, 0x1a5, 0xd3, 0x2, 0x519, 0x51a, 0x5, 0x1a3, 0xd2, 0x2, 0x51a, 0x51b, \n-    0x5, 0x185, 0xc3, 0x2, 0x51b, 0x51c, 0x5, 0x19f, 0xd0, 0x2, 0x51c, 0xf2, \n-    0x3, 0x2, 0x2, 0x2, 0x51d, 0x51e, 0x5, 0x199, 0xcd, 0x2, 0x51e, 0x51f, \n-    0x5, 0x1a5, 0xd3, 0x2, 0x51f, 0x520, 0x5, 0x1a3, 0xd2, 0x2, 0x520, 0x521, \n-    0x5, 0x187, 0xc4, 0x2, 0x521, 0x522, 0x5, 0x18d, 0xc7, 0x2, 0x522, 0x523, \n-    0x5, 0x193, 0xca, 0x2, 0x523, 0x524, 0x5, 0x185, 0xc3, 0x2, 0x524, 0xf4, \n-    0x3, 0x2, 0x2, 0x2, 0x525, 0x526, 0x5, 0x19b, 0xce, 0x2, 0x526, 0x527, \n-    0x5, 0x17d, 0xbf, 0x2, 0x527, 0x528, 0x5, 0x19f, 0xd0, 0x2, 0x528, 0x529, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x529, 0x52a, 0x5, 0x18d, 0xc7, 0x2, 0x52a, 0x52b, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x52b, 0x52c, 0x5, 0x18d, 0xc7, 0x2, 0x52c, 0x52d, \n-    0x5, 0x199, 0xcd, 0x2, 0x52d, 0x52e, 0x5, 0x197, 0xcc, 0x2, 0x52e, 0xf6, \n-    0x3, 0x2, 0x2, 0x2, 0x52f, 0x530, 0x5, 0x19b, 0xce, 0x2, 0x530, 0x531, \n-    0x5, 0x199, 0xcd, 0x2, 0x531, 0x532, 0x5, 0x19b, 0xce, 0x2, 0x532, 0x533, \n-    0x5, 0x1a5, 0xd3, 0x2, 0x533, 0x534, 0x5, 0x193, 0xca, 0x2, 0x534, 0x535, \n-    0x5, 0x17d, 0xbf, 0x2, 0x535, 0x536, 0x5, 0x1a3, 0xd2, 0x2, 0x536, 0x537, \n-    0x5, 0x185, 0xc3, 0x2, 0x537, 0xf8, 0x3, 0x2, 0x2, 0x2, 0x538, 0x539, \n-    0x5, 0x19b, 0xce, 0x2, 0x539, 0x53a, 0x5, 0x19f, 0xd0, 0x2, 0x53a, 0x53b, \n-    0x5, 0x185, 0xc3, 0x2, 0x53b, 0x53c, 0x5, 0x1a9, 0xd5, 0x2, 0x53c, 0x53d, \n-    0x5, 0x18b, 0xc6, 0x2, 0x53d, 0x53e, 0x5, 0x185, 0xc3, 0x2, 0x53e, 0x53f, \n-    0x5, 0x19f, 0xd0, 0x2, 0x53f, 0x540, 0x5, 0x185, 0xc3, 0x2, 0x540, 0xfa, \n-    0x3, 0x2, 0x2, 0x2, 0x541, 0x542, 0x5, 0x19b, 0xce, 0x2, 0x542, 0x543, \n-    0x5, 0x19f, 0xd0, 0x2, 0x543, 0x544, 0x5, 0x18d, 0xc7, 0x2, 0x544, 0x545, \n-    0x5, 0x195, 0xcb, 0x2, 0x545, 0x546, 0x5, 0x17d, 0xbf, 0x2, 0x546, 0x547, \n-    0x5, 0x19f, 0xd0, 0x2, 0x547, 0x548, 0x5, 0x1ad, 0xd7, 0x2, 0x548, 0xfc, \n-    0x3, 0x2, 0x2, 0x2, 0x549, 0x54a, 0x5, 0x19b, 0xce, 0x2, 0x54a, 0x54b, \n-    0x5, 0x19f, 0xd0, 0x2, 0x54b, 0x54c, 0x5, 0x199, 0xcd, 0x2, 0x54c, 0x54d, \n-    0x5, 0x18f, 0xc8, 0x2, 0x54d, 0x54e, 0x5, 0x185, 0xc3, 0x2, 0x54e, 0x54f, \n-    0x5, 0x181, 0xc1, 0x2, 0x54f, 0x550, 0x5, 0x1a3, 0xd2, 0x2, 0x550, 0x551, \n-    0x5, 0x18d, 0xc7, 0x2, 0x551, 0x552, 0x5, 0x199, 0xcd, 0x2, 0x552, 0x553, \n-    0x5, 0x197, 0xcc, 0x2, 0x553, 0xfe, 0x3, 0x2, 0x2, 0x2, 0x554, 0x555, \n-    0x5, 0x19d, 0xcf, 0x2, 0x555, 0x556, 0x5, 0x1a5, 0xd3, 0x2, 0x556, 0x557, \n-    0x5, 0x17d, 0xbf, 0x2, 0x557, 0x558, 0x5, 0x19f, 0xd0, 0x2, 0x558, 0x559, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x559, 0x55a, 0x5, 0x185, 0xc3, 0x2, 0x55a, 0x55b, \n-    0x5, 0x19f, 0xd0, 0x2, 0x55b, 0x100, 0x3, 0x2, 0x2, 0x2, 0x55c, 0x55d, \n-    0x5, 0x19f, 0xd0, 0x2, 0x55d, 0x55e, 0x5, 0x17d, 0xbf, 0x2, 0x55e, 0x55f, \n-    0x5, 0x197, 0xcc, 0x2, 0x55f, 0x560, 0x5, 0x189, 0xc5, 0x2, 0x560, 0x561, \n-    0x5, 0x185, 0xc3, 0x2, 0x561, 0x102, 0x3, 0x2, 0x2, 0x2, 0x562, 0x563, \n-    0x5, 0x19f, 0xd0, 0x2, 0x563, 0x564, 0x5, 0x185, 0xc3, 0x2, 0x564, 0x565, \n-    0x5, 0x193, 0xca, 0x2, 0x565, 0x566, 0x5, 0x199, 0xcd, 0x2, 0x566, 0x567, \n-    0x5, 0x17d, 0xbf, 0x2, 0x567, 0x568, 0x5, 0x183, 0xc2, 0x2, 0x568, 0x104, \n-    0x3, 0x2, 0x2, 0x2, 0x569, 0x56a, 0x5, 0x19f, 0xd0, 0x2, 0x56a, 0x56b, \n-    0x5, 0x185, 0xc3, 0x2, 0x56b, 0x56c, 0x5, 0x195, 0xcb, 0x2, 0x56c, 0x56d, \n-    0x5, 0x199, 0xcd, 0x2, 0x56d, 0x56e, 0x5, 0x1a7, 0xd4, 0x2, 0x56e, 0x56f, \n-    0x5, 0x185, 0xc3, 0x2, 0x56f, 0x106, 0x3, 0x2, 0x2, 0x2, 0x570, 0x571, \n-    0x5, 0x19f, 0xd0, 0x2, 0x571, 0x572, 0x5, 0x185, 0xc3, 0x2, 0x572, 0x573, \n-    0x5, 0x197, 0xcc, 0x2, 0x573, 0x574, 0x5, 0x17d, 0xbf, 0x2, 0x574, 0x575, \n-    0x5, 0x195, 0xcb, 0x2, 0x575, 0x576, 0x5, 0x185, 0xc3, 0x2, 0x576, 0x108, \n-    0x3, 0x2, 0x2, 0x2, 0x577, 0x578, 0x5, 0x19f, 0xd0, 0x2, 0x578, 0x579, \n-    0x5, 0x185, 0xc3, 0x2, 0x579, 0x57a, 0x5, 0x19b, 0xce, 0x2, 0x57a, 0x57b, \n-    0x5, 0x193, 0xca, 0x2, 0x57b, 0x57c, 0x5, 0x17d, 0xbf, 0x2, 0x57c, 0x57d, \n-    0x5, 0x181, 0xc1, 0x2, 0x57d, 0x57e, 0x5, 0x185, 0xc3, 0x2, 0x57e, 0x10a, \n-    0x3, 0x2, 0x2, 0x2, 0x57f, 0x580, 0x5, 0x19f, 0xd0, 0x2, 0x580, 0x581, \n-    0x5, 0x185, 0xc3, 0x2, 0x581, 0x582, 0x5, 0x19b, 0xce, 0x2, 0x582, 0x583, \n-    0x5, 0x193, 0xca, 0x2, 0x583, 0x584, 0x5, 0x18d, 0xc7, 0x2, 0x584, 0x585, \n-    0x5, 0x181, 0xc1, 0x2, 0x585, 0x586, 0x5, 0x17d, 0xbf, 0x2, 0x586, 0x10c, \n-    0x3, 0x2, 0x2, 0x2, 0x587, 0x588, 0x5, 0x19f, 0xd0, 0x2, 0x588, 0x589, \n-    0x5, 0x185, 0xc3, 0x2, 0x589, 0x58a, 0x5, 0x19b, 0xce, 0x2, 0x58a, 0x58b, \n-    0x5, 0x193, 0xca, 0x2, 0x58b, 0x58c, 0x5, 0x18d, 0xc7, 0x2, 0x58c, 0x58d, \n-    0x5, 0x181, 0xc1, 0x2, 0x58d, 0x58e, 0x5, 0x17d, 0xbf, 0x2, 0x58e, 0x58f, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x58f, 0x590, 0x5, 0x185, 0xc3, 0x2, 0x590, 0x591, \n-    0x5, 0x183, 0xc2, 0x2, 0x591, 0x10e, 0x3, 0x2, 0x2, 0x2, 0x592, 0x593, \n-    0x5, 0x19f, 0xd0, 0x2, 0x593, 0x594, 0x5, 0x18d, 0xc7, 0x2, 0x594, 0x595, \n-    0x5, 0x189, 0xc5, 0x2, 0x595, 0x596, 0x5, 0x18b, 0xc6, 0x2, 0x596, 0x597, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x597, 0x110, 0x3, 0x2, 0x2, 0x2, 0x598, 0x599, \n-    0x5, 0x19f, 0xd0, 0x2, 0x599, 0x59a, 0x5, 0x199, 0xcd, 0x2, 0x59a, 0x59b, \n-    0x5, 0x193, 0xca, 0x2, 0x59b, 0x59c, 0x5, 0x193, 0xca, 0x2, 0x59c, 0x59d, \n-    0x5, 0x1a5, 0xd3, 0x2, 0x59d, 0x59e, 0x5, 0x19b, 0xce, 0x2, 0x59e, 0x112, \n-    0x3, 0x2, 0x2, 0x2, 0x59f, 0x5a0, 0x5, 0x1a1, 0xd1, 0x2, 0x5a0, 0x5a1, \n-    0x5, 0x17d, 0xbf, 0x2, 0x5a1, 0x5a2, 0x5, 0x195, 0xcb, 0x2, 0x5a2, 0x5a3, \n-    0x5, 0x19b, 0xce, 0x2, 0x5a3, 0x5a4, 0x5, 0x193, 0xca, 0x2, 0x5a4, 0x5a5, \n-    0x5, 0x185, 0xc3, 0x2, 0x5a5, 0x114, 0x3, 0x2, 0x2, 0x2, 0x5a6, 0x5a7, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x5a7, 0x5a8, 0x5, 0x185, 0xc3, 0x2, 0x5a8, 0x5a9, \n-    0x5, 0x181, 0xc1, 0x2, 0x5a9, 0x5aa, 0x5, 0x199, 0xcd, 0x2, 0x5aa, 0x5ab, \n-    0x5, 0x197, 0xcc, 0x2, 0x5ab, 0x5ac, 0x5, 0x183, 0xc2, 0x2, 0x5ac, 0x116, \n-    0x3, 0x2, 0x2, 0x2, 0x5ad, 0x5ae, 0x5, 0x1a1, 0xd1, 0x2, 0x5ae, 0x5af, \n-    0x5, 0x185, 0xc3, 0x2, 0x5af, 0x5b0, 0x5, 0x193, 0xca, 0x2, 0x5b0, 0x5b1, \n-    0x5, 0x185, 0xc3, 0x2, 0x5b1, 0x5b2, 0x5, 0x181, 0xc1, 0x2, 0x5b2, 0x5b3, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x5b3, 0x118, 0x3, 0x2, 0x2, 0x2, 0x5b4, 0x5b5, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x5b5, 0x5b6, 0x5, 0x185, 0xc3, 0x2, 0x5b6, 0x5b7, \n-    0x5, 0x195, 0xcb, 0x2, 0x5b7, 0x5b8, 0x5, 0x18d, 0xc7, 0x2, 0x5b8, 0x11a, \n-    0x3, 0x2, 0x2, 0x2, 0x5b9, 0x5ba, 0x5, 0x1a1, 0xd1, 0x2, 0x5ba, 0x5bb, \n-    0x5, 0x185, 0xc3, 0x2, 0x5bb, 0x5bc, 0x5, 0x197, 0xcc, 0x2, 0x5bc, 0x5bd, \n-    0x5, 0x183, 0xc2, 0x2, 0x5bd, 0x5be, 0x5, 0x1a1, 0xd1, 0x2, 0x5be, 0x11c, \n-    0x3, 0x2, 0x2, 0x2, 0x5bf, 0x5c0, 0x5, 0x1a1, 0xd1, 0x2, 0x5c0, 0x5c1, \n-    0x5, 0x185, 0xc3, 0x2, 0x5c1, 0x5c2, 0x5, 0x1a3, 0xd2, 0x2, 0x5c2, 0x11e, \n-    0x3, 0x2, 0x2, 0x2, 0x5c3, 0x5c4, 0x5, 0x1a1, 0xd1, 0x2, 0x5c4, 0x5c5, \n-    0x5, 0x185, 0xc3, 0x2, 0x5c5, 0x5c6, 0x5, 0x1a3, 0xd2, 0x2, 0x5c6, 0x5c7, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x5c7, 0x5c8, 0x5, 0x18d, 0xc7, 0x2, 0x5c8, 0x5c9, \n-    0x5, 0x197, 0xcc, 0x2, 0x5c9, 0x5ca, 0x5, 0x189, 0xc5, 0x2, 0x5ca, 0x5cb, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x5cb, 0x120, 0x3, 0x2, 0x2, 0x2, 0x5cc, 0x5cd, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x5cd, 0x5ce, 0x5, 0x18b, 0xc6, 0x2, 0x5ce, 0x5cf, \n-    0x5, 0x199, 0xcd, 0x2, 0x5cf, 0x5d0, 0x5, 0x1a9, 0xd5, 0x2, 0x5d0, 0x122, \n-    0x3, 0x2, 0x2, 0x2, 0x5d1, 0x5d2, 0x5, 0x1a1, 0xd1, 0x2, 0x5d2, 0x5d3, \n-    0x5, 0x199, 0xcd, 0x2, 0x5d3, 0x5d4, 0x5, 0x1a5, 0xd3, 0x2, 0x5d4, 0x5d5, \n-    0x5, 0x19f, 0xd0, 0x2, 0x5d5, 0x5d6, 0x5, 0x181, 0xc1, 0x2, 0x5d6, 0x5d7, \n-    0x5, 0x185, 0xc3, 0x2, 0x5d7, 0x124, 0x3, 0x2, 0x2, 0x2, 0x5d8, 0x5d9, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x5d9, 0x5da, 0x5, 0x1a3, 0xd2, 0x2, 0x5da, 0x5db, \n-    0x5, 0x17d, 0xbf, 0x2, 0x5db, 0x5dc, 0x5, 0x19f, 0xd0, 0x2, 0x5dc, 0x5dd, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x5dd, 0x126, 0x3, 0x2, 0x2, 0x2, 0x5de, 0x5df, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x5df, 0x5e0, 0x5, 0x1a3, 0xd2, 0x2, 0x5e0, 0x5e1, \n-    0x5, 0x199, 0xcd, 0x2, 0x5e1, 0x5e2, 0x5, 0x19b, 0xce, 0x2, 0x5e2, 0x128, \n-    0x3, 0x2, 0x2, 0x2, 0x5e3, 0x5e4, 0x5, 0x1a1, 0xd1, 0x2, 0x5e4, 0x5e5, \n-    0x5, 0x1a5, 0xd3, 0x2, 0x5e5, 0x5e6, 0x5, 0x17f, 0xc0, 0x2, 0x5e6, 0x5e7, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x5e7, 0x5e8, 0x5, 0x1a3, 0xd2, 0x2, 0x5e8, 0x5e9, \n-    0x5, 0x19f, 0xd0, 0x2, 0x5e9, 0x5ea, 0x5, 0x18d, 0xc7, 0x2, 0x5ea, 0x5eb, \n-    0x5, 0x197, 0xcc, 0x2, 0x5eb, 0x5ec, 0x5, 0x189, 0xc5, 0x2, 0x5ec, 0x12a, \n-    0x3, 0x2, 0x2, 0x2, 0x5ed, 0x5ee, 0x5, 0x1a1, 0xd1, 0x2, 0x5ee, 0x5ef, \n-    0x5, 0x1ad, 0xd7, 0x2, 0x5ef, 0x5f0, 0x5, 0x197, 0xcc, 0x2, 0x5f0, 0x5f1, \n-    0x5, 0x181, 0xc1, 0x2, 0x5f1, 0x12c, 0x3, 0x2, 0x2, 0x2, 0x5f2, 0x5f3, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x5f3, 0x5f4, 0x5, 0x1ad, 0xd7, 0x2, 0x5f4, 0x5f5, \n-    0x5, 0x197, 0xcc, 0x2, 0x5f5, 0x5f6, 0x5, 0x1a3, 0xd2, 0x2, 0x5f6, 0x5f7, \n-    0x5, 0x17d, 0xbf, 0x2, 0x5f7, 0x5f8, 0x5, 0x1ab, 0xd6, 0x2, 0x5f8, 0x12e, \n-    0x3, 0x2, 0x2, 0x2, 0x5f9, 0x5fa, 0x5, 0x1a1, 0xd1, 0x2, 0x5fa, 0x5fb, \n-    0x5, 0x1ad, 0xd7, 0x2, 0x5fb, 0x5fc, 0x5, 0x1a1, 0xd1, 0x2, 0x5fc, 0x5fd, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x5fd, 0x5fe, 0x5, 0x185, 0xc3, 0x2, 0x5fe, 0x5ff, \n-    0x5, 0x195, 0xcb, 0x2, 0x5ff, 0x130, 0x3, 0x2, 0x2, 0x2, 0x600, 0x601, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x601, 0x602, 0x5, 0x17d, 0xbf, 0x2, 0x602, 0x603, \n-    0x5, 0x17f, 0xc0, 0x2, 0x603, 0x604, 0x5, 0x193, 0xca, 0x2, 0x604, 0x605, \n-    0x5, 0x185, 0xc3, 0x2, 0x605, 0x132, 0x3, 0x2, 0x2, 0x2, 0x606, 0x607, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x607, 0x608, 0x5, 0x17d, 0xbf, 0x2, 0x608, 0x609, \n-    0x5, 0x17f, 0xc0, 0x2, 0x609, 0x60a, 0x5, 0x193, 0xca, 0x2, 0x60a, 0x60b, \n-    0x5, 0x185, 0xc3, 0x2, 0x60b, 0x60c, 0x5, 0x1a1, 0xd1, 0x2, 0x60c, 0x134, \n-    0x3, 0x2, 0x2, 0x2, 0x60d, 0x60e, 0x5, 0x1a3, 0xd2, 0x2, 0x60e, 0x60f, \n-    0x5, 0x185, 0xc3, 0x2, 0x60f, 0x610, 0x5, 0x195, 0xcb, 0x2, 0x610, 0x611, \n-    0x5, 0x19b, 0xce, 0x2, 0x611, 0x612, 0x5, 0x199, 0xcd, 0x2, 0x612, 0x613, \n-    0x5, 0x19f, 0xd0, 0x2, 0x613, 0x614, 0x5, 0x17d, 0xbf, 0x2, 0x614, 0x615, \n-    0x5, 0x19f, 0xd0, 0x2, 0x615, 0x616, 0x5, 0x1ad, 0xd7, 0x2, 0x616, 0x136, \n-    0x3, 0x2, 0x2, 0x2, 0x617, 0x618, 0x5, 0x1a3, 0xd2, 0x2, 0x618, 0x619, \n-    0x5, 0x185, 0xc3, 0x2, 0x619, 0x61a, 0x5, 0x1a1, 0xd1, 0x2, 0x61a, 0x61b, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x61b, 0x138, 0x3, 0x2, 0x2, 0x2, 0x61c, 0x61d, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x61d, 0x61e, 0x5, 0x18b, 0xc6, 0x2, 0x61e, 0x61f, \n-    0x5, 0x185, 0xc3, 0x2, 0x61f, 0x620, 0x5, 0x197, 0xcc, 0x2, 0x620, 0x13a, \n-    0x3, 0x2, 0x2, 0x2, 0x621, 0x622, 0x5, 0x1a3, 0xd2, 0x2, 0x622, 0x623, \n-    0x5, 0x18d, 0xc7, 0x2, 0x623, 0x624, 0x5, 0x185, 0xc3, 0x2, 0x624, 0x625, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x625, 0x13c, 0x3, 0x2, 0x2, 0x2, 0x626, 0x627, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x627, 0x628, 0x5, 0x18d, 0xc7, 0x2, 0x628, 0x629, \n-    0x5, 0x195, 0xcb, 0x2, 0x629, 0x62a, 0x5, 0x185, 0xc3, 0x2, 0x62a, 0x62b, \n-    0x5, 0x199, 0xcd, 0x2, 0x62b, 0x62c, 0x5, 0x1a5, 0xd3, 0x2, 0x62c, 0x62d, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x62d, 0x13e, 0x3, 0x2, 0x2, 0x2, 0x62e, 0x62f, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x62f, 0x630, 0x5, 0x18d, 0xc7, 0x2, 0x630, 0x631, \n-    0x5, 0x195, 0xcb, 0x2, 0x631, 0x632, 0x5, 0x185, 0xc3, 0x2, 0x632, 0x633, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x633, 0x634, 0x5, 0x1a3, 0xd2, 0x2, 0x634, 0x635, \n-    0x5, 0x17d, 0xbf, 0x2, 0x635, 0x636, 0x5, 0x195, 0xcb, 0x2, 0x636, 0x637, \n-    0x5, 0x19b, 0xce, 0x2, 0x637, 0x140, 0x3, 0x2, 0x2, 0x2, 0x638, 0x639, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x639, 0x63a, 0x5, 0x199, 0xcd, 0x2, 0x63a, 0x142, \n-    0x3, 0x2, 0x2, 0x2, 0x63b, 0x63c, 0x5, 0x1a3, 0xd2, 0x2, 0x63c, 0x63d, \n-    0x5, 0x199, 0xcd, 0x2, 0x63d, 0x63e, 0x5, 0x19b, 0xce, 0x2, 0x63e, 0x144, \n-    0x3, 0x2, 0x2, 0x2, 0x63f, 0x640, 0x5, 0x1a3, 0xd2, 0x2, 0x640, 0x641, \n-    0x5, 0x199, 0xcd, 0x2, 0x641, 0x642, 0x5, 0x1a3, 0xd2, 0x2, 0x642, 0x643, \n-    0x5, 0x17d, 0xbf, 0x2, 0x643, 0x644, 0x5, 0x193, 0xca, 0x2, 0x644, 0x645, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x645, 0x146, 0x3, 0x2, 0x2, 0x2, 0x646, 0x647, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x647, 0x648, 0x5, 0x19f, 0xd0, 0x2, 0x648, 0x649, \n-    0x5, 0x17d, 0xbf, 0x2, 0x649, 0x64a, 0x5, 0x18d, 0xc7, 0x2, 0x64a, 0x64b, \n-    0x5, 0x193, 0xca, 0x2, 0x64b, 0x64c, 0x5, 0x18d, 0xc7, 0x2, 0x64c, 0x64d, \n-    0x5, 0x197, 0xcc, 0x2, 0x64d, 0x64e, 0x5, 0x189, 0xc5, 0x2, 0x64e, 0x148, \n-    0x3, 0x2, 0x2, 0x2, 0x64f, 0x650, 0x5, 0x1a3, 0xd2, 0x2, 0x650, 0x651, \n-    0x5, 0x19f, 0xd0, 0x2, 0x651, 0x652, 0x5, 0x18d, 0xc7, 0x2, 0x652, 0x653, \n-    0x5, 0x195, 0xcb, 0x2, 0x653, 0x14a, 0x3, 0x2, 0x2, 0x2, 0x654, 0x655, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x655, 0x656, 0x5, 0x19f, 0xd0, 0x2, 0x656, 0x657, \n-    0x5, 0x1a5, 0xd3, 0x2, 0x657, 0x658, 0x5, 0x197, 0xcc, 0x2, 0x658, 0x659, \n-    0x5, 0x181, 0xc1, 0x2, 0x659, 0x65a, 0x5, 0x17d, 0xbf, 0x2, 0x65a, 0x65b, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x65b, 0x65c, 0x5, 0x185, 0xc3, 0x2, 0x65c, 0x14c, \n-    0x3, 0x2, 0x2, 0x2, 0x65d, 0x65e, 0x5, 0x1a3, 0xd2, 0x2, 0x65e, 0x65f, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x65f, 0x660, 0x5, 0x193, 0xca, 0x2, 0x660, 0x14e, \n-    0x3, 0x2, 0x2, 0x2, 0x661, 0x662, 0x5, 0x1a3, 0xd2, 0x2, 0x662, 0x663, \n-    0x5, 0x1ad, 0xd7, 0x2, 0x663, 0x664, 0x5, 0x19b, 0xce, 0x2, 0x664, 0x665, \n-    0x5, 0x185, 0xc3, 0x2, 0x665, 0x150, 0x3, 0x2, 0x2, 0x2, 0x666, 0x667, \n-    0x5, 0x1a5, 0xd3, 0x2, 0x667, 0x668, 0x5, 0x197, 0xcc, 0x2, 0x668, 0x669, \n-    0x5, 0x18d, 0xc7, 0x2, 0x669, 0x66a, 0x5, 0x199, 0xcd, 0x2, 0x66a, 0x66b, \n-    0x5, 0x197, 0xcc, 0x2, 0x66b, 0x152, 0x3, 0x2, 0x2, 0x2, 0x66c, 0x66d, \n-    0x5, 0x1a5, 0xd3, 0x2, 0x66d, 0x66e, 0x5, 0x19b, 0xce, 0x2, 0x66e, 0x66f, \n-    0x5, 0x183, 0xc2, 0x2, 0x66f, 0x670, 0x5, 0x17d, 0xbf, 0x2, 0x670, 0x671, \n-    0x5, 0x1a3, 0xd2, 0x2, 0x671, 0x672, 0x5, 0x185, 0xc3, 0x2, 0x672, 0x154, \n-    0x3, 0x2, 0x2, 0x2, 0x673, 0x674, 0x5, 0x1a5, 0xd3, 0x2, 0x674, 0x675, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x675, 0x676, 0x5, 0x185, 0xc3, 0x2, 0x676, 0x156, \n-    0x3, 0x2, 0x2, 0x2, 0x677, 0x678, 0x5, 0x1a5, 0xd3, 0x2, 0x678, 0x679, \n-    0x5, 0x1a1, 0xd1, 0x2, 0x679, 0x67a, 0x5, 0x18d, 0xc7, 0x2, 0x67a, 0x67b, \n-    0x5, 0x197, 0xcc, 0x2, 0x67b, 0x67c, 0x5, 0x189, 0xc5, 0x2, 0x67c, 0x158, \n-    0x3, 0x2, 0x2, 0x2, 0x67d, 0x67e, 0x5, 0x1a5, 0xd3, 0x2, 0x67e, 0x67f, \n-    0x5, 0x1a5, 0xd3, 0x2, 0x67f, 0x680, 0x5, 0x18d, 0xc7, 0x2, 0x680, 0x681, \n-    0x5, 0x183, 0xc2, 0x2, 0x681, 0x15a, 0x3, 0x2, 0x2, 0x2, 0x682, 0x683, \n-    0x5, 0x1a7, 0xd4, 0x2, 0x683, 0x684, 0x5, 0x17d, 0xbf, 0x2, 0x684, 0x685, \n-    0x5, 0x193, 0xca, 0x2, 0x685, 0x686, 0x5, 0x1a5, 0xd3, 0x2, 0x686, 0x687, \n-    0x5, 0x185, 0xc3, 0x2, 0x687, 0x688, 0x5, 0x1a1, 0xd1, 0x2, 0x688, 0x15c, \n-    0x3, 0x2, 0x2, 0x2, 0x689, 0x68a, 0x5, 0x1a7, 0xd4, 0x2, 0x68a, 0x68b, \n-    0x5, 0x18d, 0xc7, 0x2, 0x68b, 0x68c, 0x5, 0x185, 0xc3, 0x2, 0x68c, 0x68d, \n-    0x5, 0x1a9, 0xd5, 0x2, 0x68d, 0x15e, 0x3, 0x2, 0x2, 0x2, 0x68e, 0x68f, \n-    0x5, 0x1a7, 0xd4, 0x2, 0x68f, 0x690, 0x5, 0x199, 0xcd, 0x2, 0x690, 0x691, \n-    0x5, 0x193, 0xca, 0x2, 0x691, 0x692, 0x5, 0x1a5, 0xd3, 0x2, 0x692, 0x693, \n-    0x5, 0x195, 0xcb, 0x2, 0x693, 0x694, 0x5, 0x185, 0xc3, 0x2, 0x694, 0x160, \n-    0x3, 0x2, 0x2, 0x2, 0x695, 0x696, 0x5, 0x1a9, 0xd5, 0x2, 0x696, 0x697, \n-    0x5, 0x17d, 0xbf, 0x2, 0x697, 0x698, 0x5, 0x1a3, 0xd2, 0x2, 0x698, 0x699, \n-    0x5, 0x181, 0xc1, 0x2, 0x699, 0x69a, 0x5, 0x18b, 0xc6, 0x2, 0x69a, 0x162, \n-    0x3, 0x2, 0x2, 0x2, 0x69b, 0x69c, 0x5, 0x1a9, 0xd5, 0x2, 0x69c, 0x69d, \n-    0x5, 0x185, 0xc3, 0x2, 0x69d, 0x69e, 0x5, 0x185, 0xc3, 0x2, 0x69e, 0x69f, \n-    0x5, 0x191, 0xc9, 0x2, 0x69f, 0x164, 0x3, 0x2, 0x2, 0x2, 0x6a0, 0x6a1, \n-    0x5, 0x1a9, 0xd5, 0x2, 0x6a1, 0x6a2, 0x5, 0x18b, 0xc6, 0x2, 0x6a2, 0x6a3, \n-    0x5, 0x185, 0xc3, 0x2, 0x6a3, 0x6a4, 0x5, 0x197, 0xcc, 0x2, 0x6a4, 0x166, \n-    0x3, 0x2, 0x2, 0x2, 0x6a5, 0x6a6, 0x5, 0x1a9, 0xd5, 0x2, 0x6a6, 0x6a7, \n-    0x5, 0x18b, 0xc6, 0x2, 0x6a7, 0x6a8, 0x5, 0x185, 0xc3, 0x2, 0x6a8, 0x6a9, \n-    0x5, 0x19f, 0xd0, 0x2, 0x6a9, 0x6aa, 0x5, 0x185, 0xc3, 0x2, 0x6aa, 0x168, \n-    0x3, 0x2, 0x2, 0x2, 0x6ab, 0x6ac, 0x5, 0x1a9, 0xd5, 0x2, 0x6ac, 0x6ad, \n-    0x5, 0x18d, 0xc7, 0x2, 0x6ad, 0x6ae, 0x5, 0x1a3, 0xd2, 0x2, 0x6ae, 0x6af, \n-    0x5, 0x18b, 0xc6, 0x2, 0x6af, 0x16a, 0x3, 0x2, 0x2, 0x2, 0x6b0, 0x6b1, \n-    0x5, 0x1ad, 0xd7, 0x2, 0x6b1, 0x6b2, 0x5, 0x185, 0xc3, 0x2, 0x6b2, 0x6b3, \n-    0x5, 0x17d, 0xbf, 0x2, 0x6b3, 0x6b4, 0x5, 0x19f, 0xd0, 0x2, 0x6b4, 0x6bb, \n-    0x3, 0x2, 0x2, 0x2, 0x6b5, 0x6b6, 0x5, 0x1ad, 0xd7, 0x2, 0x6b6, 0x6b7, \n-    0x5, 0x1ad, 0xd7, 0x2, 0x6b7, 0x6b8, 0x5, 0x1ad, 0xd7, 0x2, 0x6b8, 0x6b9, \n-    0x5, 0x1ad, 0xd7, 0x2, 0x6b9, 0x6bb, 0x3, 0x2, 0x2, 0x2, 0x6ba, 0x6b0, \n-    0x3, 0x2, 0x2, 0x2, 0x6ba, 0x6b5, 0x3, 0x2, 0x2, 0x2, 0x6bb, 0x16c, \n-    0x3, 0x2, 0x2, 0x2, 0x6bc, 0x6bd, 0x7, 0x68, 0x2, 0x2, 0x6bd, 0x6be, \n-    0x7, 0x63, 0x2, 0x2, 0x6be, 0x6bf, 0x7, 0x6e, 0x2, 0x2, 0x6bf, 0x6c0, \n-    0x7, 0x75, 0x2, 0x2, 0x6c0, 0x6c1, 0x7, 0x67, 0x2, 0x2, 0x6c1, 0x16e, \n-    0x3, 0x2, 0x2, 0x2, 0x6c2, 0x6c3, 0x7, 0x76, 0x2, 0x2, 0x6c3, 0x6c4, \n-    0x7, 0x74, 0x2, 0x2, 0x6c4, 0x6c5, 0x7, 0x77, 0x2, 0x2, 0x6c5, 0x6c6, \n-    0x7, 0x67, 0x2, 0x2, 0x6c6, 0x170, 0x3, 0x2, 0x2, 0x2, 0x6c7, 0x6ca, \n-    0x5, 0x1b1, 0xd9, 0x2, 0x6c8, 0x6ca, 0x5, 0x1f3, 0xfa, 0x2, 0x6c9, 0x6c7, \n-    0x3, 0x2, 0x2, 0x2, 0x6c9, 0x6c8, 0x3, 0x2, 0x2, 0x2, 0x6ca, 0x6d0, \n-    0x3, 0x2, 0x2, 0x2, 0x6cb, 0x6cf, 0x5, 0x1b1, 0xd9, 0x2, 0x6cc, 0x6cf, \n-    0x5, 0x1f3, 0xfa, 0x2, 0x6cd, 0x6cf, 0x5, 0x1b5, 0xdb, 0x2, 0x6ce, 0x6cb, \n-    0x3, 0x2, 0x2, 0x2, 0x6ce, 0x6cc, 0x3, 0x2, 0x2, 0x2, 0x6ce, 0x6cd, \n-    0x3, 0x2, 0x2, 0x2, 0x6cf, 0x6d2, 0x3, 0x2, 0x2, 0x2, 0x6d0, 0x6ce, \n-    0x3, 0x2, 0x2, 0x2, 0x6d0, 0x6d1, 0x3, 0x2, 0x2, 0x2, 0x6d1, 0x6f2, \n-    0x3, 0x2, 0x2, 0x2, 0x6d2, 0x6d0, 0x3, 0x2, 0x2, 0x2, 0x6d3, 0x6dd, \n-    0x5, 0x1bd, 0xdf, 0x2, 0x6d4, 0x6dc, 0xa, 0x2, 0x2, 0x2, 0x6d5, 0x6d6, \n-    0x5, 0x1bf, 0xe0, 0x2, 0x6d6, 0x6d7, 0xb, 0x2, 0x2, 0x2, 0x6d7, 0x6dc, \n-    0x3, 0x2, 0x2, 0x2, 0x6d8, 0x6d9, 0x5, 0x1bd, 0xdf, 0x2, 0x6d9, 0x6da, \n-    0x5, 0x1bd, 0xdf, 0x2, 0x6da, 0x6dc, 0x3, 0x2, 0x2, 0x2, 0x6db, 0x6d4, \n-    0x3, 0x2, 0x2, 0x2, 0x6db, 0x6d5, 0x3, 0x2, 0x2, 0x2, 0x6db, 0x6d8, \n-    0x3, 0x2, 0x2, 0x2, 0x6dc, 0x6df, 0x3, 0x2, 0x2, 0x2, 0x6dd, 0x6db, \n-    0x3, 0x2, 0x2, 0x2, 0x6dd, 0x6de, 0x3, 0x2, 0x2, 0x2, 0x6de, 0x6e0, \n-    0x3, 0x2, 0x2, 0x2, 0x6df, 0x6dd, 0x3, 0x2, 0x2, 0x2, 0x6e0, 0x6e1, \n-    0x5, 0x1bd, 0xdf, 0x2, 0x6e1, 0x6f2, 0x3, 0x2, 0x2, 0x2, 0x6e2, 0x6ec, \n-    0x5, 0x1e5, 0xf3, 0x2, 0x6e3, 0x6eb, 0xa, 0x3, 0x2, 0x2, 0x6e4, 0x6e5, \n-    0x5, 0x1bf, 0xe0, 0x2, 0x6e5, 0x6e6, 0xb, 0x2, 0x2, 0x2, 0x6e6, 0x6eb, \n-    0x3, 0x2, 0x2, 0x2, 0x6e7, 0x6e8, 0x5, 0x1e5, 0xf3, 0x2, 0x6e8, 0x6e9, \n-    0x5, 0x1e5, 0xf3, 0x2, 0x6e9, 0x6eb, 0x3, 0x2, 0x2, 0x2, 0x6ea, 0x6e3, \n-    0x3, 0x2, 0x2, 0x2, 0x6ea, 0x6e4, 0x3, 0x2, 0x2, 0x2, 0x6ea, 0x6e7, \n-    0x3, 0x2, 0x2, 0x2, 0x6eb, 0x6ee, 0x3, 0x2, 0x2, 0x2, 0x6ec, 0x6ea, \n-    0x3, 0x2, 0x2, 0x2, 0x6ec, 0x6ed, 0x3, 0x2, 0x2, 0x2, 0x6ed, 0x6ef, \n-    0x3, 0x2, 0x2, 0x2, 0x6ee, 0x6ec, 0x3, 0x2, 0x2, 0x2, 0x6ef, 0x6f0, \n-    0x5, 0x1e5, 0xf3, 0x2, 0x6f0, 0x6f2, 0x3, 0x2, 0x2, 0x2, 0x6f1, 0x6c9, \n-    0x3, 0x2, 0x2, 0x2, 0x6f1, 0x6d3, 0x3, 0x2, 0x2, 0x2, 0x6f1, 0x6e2, \n-    0x3, 0x2, 0x2, 0x2, 0x6f2, 0x172, 0x3, 0x2, 0x2, 0x2, 0x6f3, 0x6f4, \n-    0x5, 0x179, 0xbd, 0x2, 0x6f4, 0x6f8, 0x5, 0x1c9, 0xe5, 0x2, 0x6f5, 0x6f7, \n-    0x5, 0x1b7, 0xdc, 0x2, 0x6f6, 0x6f5, 0x3, 0x2, 0x2, 0x2, 0x6f7, 0x6fa, \n-    0x3, 0x2, 0x2, 0x2, 0x6f8, 0x6f6, 0x3, 0x2, 0x2, 0x2, 0x6f8, 0x6f9, \n-    0x3, 0x2, 0x2, 0x2, 0x6f9, 0x6fd, 0x3, 0x2, 0x2, 0x2, 0x6fa, 0x6f8, \n-    0x3, 0x2, 0x2, 0x2, 0x6fb, 0x6fe, 0x5, 0x19b, 0xce, 0x2, 0x6fc, 0x6fe, \n-    0x5, 0x185, 0xc3, 0x2, 0x6fd, 0x6fb, 0x3, 0x2, 0x2, 0x2, 0x6fd, 0x6fc, \n-    0x3, 0x2, 0x2, 0x2, 0x6fe, 0x701, 0x3, 0x2, 0x2, 0x2, 0x6ff, 0x702, \n-    0x5, 0x1e1, 0xf1, 0x2, 0x700, 0x702, 0x5, 0x1c7, 0xe4, 0x2, 0x701, 0x6ff, \n-    0x3, 0x2, 0x2, 0x2, 0x701, 0x700, 0x3, 0x2, 0x2, 0x2, 0x701, 0x702, \n-    0x3, 0x2, 0x2, 0x2, 0x702, 0x704, 0x3, 0x2, 0x2, 0x2, 0x703, 0x705, \n-    0x5, 0x1b5, 0xdb, 0x2, 0x704, 0x703, 0x3, 0x2, 0x2, 0x2, 0x705, 0x706, \n-    0x3, 0x2, 0x2, 0x2, 0x706, 0x704, 0x3, 0x2, 0x2, 0x2, 0x706, 0x707, \n-    0x3, 0x2, 0x2, 0x2, 0x707, 0x740, 0x3, 0x2, 0x2, 0x2, 0x708, 0x70b, \n-    0x5, 0x179, 0xbd, 0x2, 0x709, 0x70c, 0x5, 0x19b, 0xce, 0x2, 0x70a, 0x70c, \n-    0x5, 0x185, 0xc3, 0x2, 0x70b, 0x709, 0x3, 0x2, 0x2, 0x2, 0x70b, 0x70a, \n-    0x3, 0x2, 0x2, 0x2, 0x70c, 0x70f, 0x3, 0x2, 0x2, 0x2, 0x70d, 0x710, \n-    0x5, 0x1e1, 0xf1, 0x2, 0x70e, 0x710, 0x5, 0x1c7, 0xe4, 0x2, 0x70f, 0x70d, \n-    0x3, 0x2, 0x2, 0x2, 0x70f, 0x70e, 0x3, 0x2, 0x2, 0x2, 0x70f, 0x710, \n-    0x3, 0x2, 0x2, 0x2, 0x710, 0x712, 0x3, 0x2, 0x2, 0x2, 0x711, 0x713, \n-    0x5, 0x1b5, 0xdb, 0x2, 0x712, 0x711, 0x3, 0x2, 0x2, 0x2, 0x713, 0x714, \n-    0x3, 0x2, 0x2, 0x2, 0x714, 0x712, 0x3, 0x2, 0x2, 0x2, 0x714, 0x715, \n-    0x3, 0x2, 0x2, 0x2, 0x715, 0x740, 0x3, 0x2, 0x2, 0x2, 0x716, 0x717, \n-    0x5, 0x177, 0xbc, 0x2, 0x717, 0x71b, 0x5, 0x1c9, 0xe5, 0x2, 0x718, 0x71a, \n-    0x5, 0x1b5, 0xdb, 0x2, 0x719, 0x718, 0x3, 0x2, 0x2, 0x2, 0x71a, 0x71d, \n-    0x3, 0x2, 0x2, 0x2, 0x71b, 0x719, 0x3, 0x2, 0x2, 0x2, 0x71b, 0x71c, \n-    0x3, 0x2, 0x2, 0x2, 0x71c, 0x71e, 0x3, 0x2, 0x2, 0x2, 0x71d, 0x71b, \n-    0x3, 0x2, 0x2, 0x2, 0x71e, 0x721, 0x5, 0x185, 0xc3, 0x2, 0x71f, 0x722, \n-    0x5, 0x1e1, 0xf1, 0x2, 0x720, 0x722, 0x5, 0x1c7, 0xe4, 0x2, 0x721, 0x71f, \n-    0x3, 0x2, 0x2, 0x2, 0x721, 0x720, 0x3, 0x2, 0x2, 0x2, 0x721, 0x722, \n-    0x3, 0x2, 0x2, 0x2, 0x722, 0x724, 0x3, 0x2, 0x2, 0x2, 0x723, 0x725, \n-    0x5, 0x1b5, 0xdb, 0x2, 0x724, 0x723, 0x3, 0x2, 0x2, 0x2, 0x725, 0x726, \n-    0x3, 0x2, 0x2, 0x2, 0x726, 0x724, 0x3, 0x2, 0x2, 0x2, 0x726, 0x727, \n-    0x3, 0x2, 0x2, 0x2, 0x727, 0x740, 0x3, 0x2, 0x2, 0x2, 0x728, 0x729, \n-    0x5, 0x1c9, 0xe5, 0x2, 0x729, 0x72a, 0x5, 0x177, 0xbc, 0x2, 0x72a, 0x72d, \n-    0x5, 0x185, 0xc3, 0x2, 0x72b, 0x72e, 0x5, 0x1e1, 0xf1, 0x2, 0x72c, 0x72e, \n-    0x5, 0x1c7, 0xe4, 0x2, 0x72d, 0x72b, 0x3, 0x2, 0x2, 0x2, 0x72d, 0x72c, \n-    0x3, 0x2, 0x2, 0x2, 0x72d, 0x72e, 0x3, 0x2, 0x2, 0x2, 0x72e, 0x730, \n-    0x3, 0x2, 0x2, 0x2, 0x72f, 0x731, 0x5, 0x1b5, 0xdb, 0x2, 0x730, 0x72f, \n-    0x3, 0x2, 0x2, 0x2, 0x731, 0x732, 0x3, 0x2, 0x2, 0x2, 0x732, 0x730, \n-    0x3, 0x2, 0x2, 0x2, 0x732, 0x733, 0x3, 0x2, 0x2, 0x2, 0x733, 0x740, \n-    0x3, 0x2, 0x2, 0x2, 0x734, 0x735, 0x5, 0x177, 0xbc, 0x2, 0x735, 0x738, \n-    0x5, 0x185, 0xc3, 0x2, 0x736, 0x739, 0x5, 0x1e1, 0xf1, 0x2, 0x737, 0x739, \n-    0x5, 0x1c7, 0xe4, 0x2, 0x738, 0x736, 0x3, 0x2, 0x2, 0x2, 0x738, 0x737, \n-    0x3, 0x2, 0x2, 0x2, 0x738, 0x739, 0x3, 0x2, 0x2, 0x2, 0x739, 0x73b, \n-    0x3, 0x2, 0x2, 0x2, 0x73a, 0x73c, 0x5, 0x1b5, 0xdb, 0x2, 0x73b, 0x73a, \n-    0x3, 0x2, 0x2, 0x2, 0x73c, 0x73d, 0x3, 0x2, 0x2, 0x2, 0x73d, 0x73b, \n-    0x3, 0x2, 0x2, 0x2, 0x73d, 0x73e, 0x3, 0x2, 0x2, 0x2, 0x73e, 0x740, \n-    0x3, 0x2, 0x2, 0x2, 0x73f, 0x6f3, 0x3, 0x2, 0x2, 0x2, 0x73f, 0x708, \n-    0x3, 0x2, 0x2, 0x2, 0x73f, 0x716, 0x3, 0x2, 0x2, 0x2, 0x73f, 0x728, \n-    0x3, 0x2, 0x2, 0x2, 0x73f, 0x734, 0x3, 0x2, 0x2, 0x2, 0x740, 0x174, \n-    0x3, 0x2, 0x2, 0x2, 0x741, 0x743, 0x7, 0x32, 0x2, 0x2, 0x742, 0x744, \n-    0x5, 0x1b3, 0xda, 0x2, 0x743, 0x742, 0x3, 0x2, 0x2, 0x2, 0x744, 0x745, \n-    0x3, 0x2, 0x2, 0x2, 0x745, 0x743, 0x3, 0x2, 0x2, 0x2, 0x745, 0x746, \n-    0x3, 0x2, 0x2, 0x2, 0x746, 0x176, 0x3, 0x2, 0x2, 0x2, 0x747, 0x749, \n-    0x5, 0x1b5, 0xdb, 0x2, 0x748, 0x747, 0x3, 0x2, 0x2, 0x2, 0x749, 0x74a, \n-    0x3, 0x2, 0x2, 0x2, 0x74a, 0x748, 0x3, 0x2, 0x2, 0x2, 0x74a, 0x74b, \n-    0x3, 0x2, 0x2, 0x2, 0x74b, 0x178, 0x3, 0x2, 0x2, 0x2, 0x74c, 0x74d, \n-    0x7, 0x32, 0x2, 0x2, 0x74d, 0x74f, 0x5, 0x1ab, 0xd6, 0x2, 0x74e, 0x750, \n-    0x5, 0x1b7, 0xdc, 0x2, 0x74f, 0x74e, 0x3, 0x2, 0x2, 0x2, 0x750, 0x751, \n-    0x3, 0x2, 0x2, 0x2, 0x751, 0x74f, 0x3, 0x2, 0x2, 0x2, 0x751, 0x752, \n-    0x3, 0x2, 0x2, 0x2, 0x752, 0x17a, 0x3, 0x2, 0x2, 0x2, 0x753, 0x75d, \n-    0x5, 0x1e7, 0xf4, 0x2, 0x754, 0x75c, 0xa, 0x4, 0x2, 0x2, 0x755, 0x756, \n-    0x5, 0x1bf, 0xe0, 0x2, 0x756, 0x757, 0xb, 0x2, 0x2, 0x2, 0x757, 0x75c, \n-    0x3, 0x2, 0x2, 0x2, 0x758, 0x759, 0x5, 0x1e7, 0xf4, 0x2, 0x759, 0x75a, \n-    0x5, 0x1e7, 0xf4, 0x2, 0x75a, 0x75c, 0x3, 0x2, 0x2, 0x2, 0x75b, 0x754, \n-    0x3, 0x2, 0x2, 0x2, 0x75b, 0x755, 0x3, 0x2, 0x2, 0x2, 0x75b, 0x758, \n-    0x3, 0x2, 0x2, 0x2, 0x75c, 0x75f, 0x3, 0x2, 0x2, 0x2, 0x75d, 0x75b, \n-    0x3, 0x2, 0x2, 0x2, 0x75d, 0x75e, 0x3, 0x2, 0x2, 0x2, 0x75e, 0x760, \n-    0x3, 0x2, 0x2, 0x2, 0x75f, 0x75d, 0x3, 0x2, 0x2, 0x2, 0x760, 0x761, \n-    0x5, 0x1e7, 0xf4, 0x2, 0x761, 0x17c, 0x3, 0x2, 0x2, 0x2, 0x762, 0x763, \n-    0x9, 0x5, 0x2, 0x2, 0x763, 0x17e, 0x3, 0x2, 0x2, 0x2, 0x764, 0x765, \n-    0x9, 0x6, 0x2, 0x2, 0x765, 0x180, 0x3, 0x2, 0x2, 0x2, 0x766, 0x767, \n-    0x9, 0x7, 0x2, 0x2, 0x767, 0x182, 0x3, 0x2, 0x2, 0x2, 0x768, 0x769, \n-    0x9, 0x8, 0x2, 0x2, 0x769, 0x184, 0x3, 0x2, 0x2, 0x2, 0x76a, 0x76b, \n-    0x9, 0x9, 0x2, 0x2, 0x76b, 0x186, 0x3, 0x2, 0x2, 0x2, 0x76c, 0x76d, \n-    0x9, 0xa, 0x2, 0x2, 0x76d, 0x188, 0x3, 0x2, 0x2, 0x2, 0x76e, 0x76f, \n-    0x9, 0xb, 0x2, 0x2, 0x76f, 0x18a, 0x3, 0x2, 0x2, 0x2, 0x770, 0x771, \n-    0x9, 0xc, 0x2, 0x2, 0x771, 0x18c, 0x3, 0x2, 0x2, 0x2, 0x772, 0x773, \n-    0x9, 0xd, 0x2, 0x2, 0x773, 0x18e, 0x3, 0x2, 0x2, 0x2, 0x774, 0x775, \n-    0x9, 0xe, 0x2, 0x2, 0x775, 0x190, 0x3, 0x2, 0x2, 0x2, 0x776, 0x777, \n-    0x9, 0xf, 0x2, 0x2, 0x777, 0x192, 0x3, 0x2, 0x2, 0x2, 0x778, 0x779, \n-    0x9, 0x10, 0x2, 0x2, 0x779, 0x194, 0x3, 0x2, 0x2, 0x2, 0x77a, 0x77b, \n-    0x9, 0x11, 0x2, 0x2, 0x77b, 0x196, 0x3, 0x2, 0x2, 0x2, 0x77c, 0x77d, \n-    0x9, 0x12, 0x2, 0x2, 0x77d, 0x198, 0x3, 0x2, 0x2, 0x2, 0x77e, 0x77f, \n-    0x9, 0x13, 0x2, 0x2, 0x77f, 0x19a, 0x3, 0x2, 0x2, 0x2, 0x780, 0x781, \n-    0x9, 0x14, 0x2, 0x2, 0x781, 0x19c, 0x3, 0x2, 0x2, 0x2, 0x782, 0x783, \n-    0x9, 0x15, 0x2, 0x2, 0x783, 0x19e, 0x3, 0x2, 0x2, 0x2, 0x784, 0x785, \n-    0x9, 0x16, 0x2, 0x2, 0x785, 0x1a0, 0x3, 0x2, 0x2, 0x2, 0x786, 0x787, \n-    0x9, 0x17, 0x2, 0x2, 0x787, 0x1a2, 0x3, 0x2, 0x2, 0x2, 0x788, 0x789, \n-    0x9, 0x18, 0x2, 0x2, 0x789, 0x1a4, 0x3, 0x2, 0x2, 0x2, 0x78a, 0x78b, \n-    0x9, 0x19, 0x2, 0x2, 0x78b, 0x1a6, 0x3, 0x2, 0x2, 0x2, 0x78c, 0x78d, \n-    0x9, 0x1a, 0x2, 0x2, 0x78d, 0x1a8, 0x3, 0x2, 0x2, 0x2, 0x78e, 0x78f, \n-    0x9, 0x1b, 0x2, 0x2, 0x78f, 0x1aa, 0x3, 0x2, 0x2, 0x2, 0x790, 0x791, \n-    0x9, 0x1c, 0x2, 0x2, 0x791, 0x1ac, 0x3, 0x2, 0x2, 0x2, 0x792, 0x793, \n-    0x9, 0x1d, 0x2, 0x2, 0x793, 0x1ae, 0x3, 0x2, 0x2, 0x2, 0x794, 0x795, \n-    0x9, 0x1e, 0x2, 0x2, 0x795, 0x1b0, 0x3, 0x2, 0x2, 0x2, 0x796, 0x797, \n-    0x9, 0x1f, 0x2, 0x2, 0x797, 0x1b2, 0x3, 0x2, 0x2, 0x2, 0x798, 0x799, \n-    0x9, 0x20, 0x2, 0x2, 0x799, 0x1b4, 0x3, 0x2, 0x2, 0x2, 0x79a, 0x79b, \n-    0x9, 0x21, 0x2, 0x2, 0x79b, 0x1b6, 0x3, 0x2, 0x2, 0x2, 0x79c, 0x79d, \n-    0x9, 0x22, 0x2, 0x2, 0x79d, 0x1b8, 0x3, 0x2, 0x2, 0x2, 0x79e, 0x79f, \n-    0x7, 0x2f, 0x2, 0x2, 0x79f, 0x7a0, 0x7, 0x40, 0x2, 0x2, 0x7a0, 0x1ba, \n-    0x3, 0x2, 0x2, 0x2, 0x7a1, 0x7a2, 0x7, 0x2c, 0x2, 0x2, 0x7a2, 0x1bc, \n-    0x3, 0x2, 0x2, 0x2, 0x7a3, 0x7a4, 0x7, 0x62, 0x2, 0x2, 0x7a4, 0x1be, \n-    0x3, 0x2, 0x2, 0x2, 0x7a5, 0x7a6, 0x7, 0x5e, 0x2, 0x2, 0x7a6, 0x1c0, \n-    0x3, 0x2, 0x2, 0x2, 0x7a7, 0x7a8, 0x7, 0x3c, 0x2, 0x2, 0x7a8, 0x1c2, \n-    0x3, 0x2, 0x2, 0x2, 0x7a9, 0x7aa, 0x7, 0x2e, 0x2, 0x2, 0x7aa, 0x1c4, \n-    0x3, 0x2, 0x2, 0x2, 0x7ab, 0x7ac, 0x7, 0x7e, 0x2, 0x2, 0x7ac, 0x7ad, \n-    0x7, 0x7e, 0x2, 0x2, 0x7ad, 0x1c6, 0x3, 0x2, 0x2, 0x2, 0x7ae, 0x7af, \n-    0x7, 0x2f, 0x2, 0x2, 0x7af, 0x1c8, 0x3, 0x2, 0x2, 0x2, 0x7b0, 0x7b1, \n-    0x7, 0x30, 0x2, 0x2, 0x7b1, 0x1ca, 0x3, 0x2, 0x2, 0x2, 0x7b2, 0x7b3, \n-    0x7, 0x3f, 0x2, 0x2, 0x7b3, 0x7b4, 0x7, 0x3f, 0x2, 0x2, 0x7b4, 0x1cc, \n-    0x3, 0x2, 0x2, 0x2, 0x7b5, 0x7b6, 0x7, 0x3f, 0x2, 0x2, 0x7b6, 0x1ce, \n-    0x3, 0x2, 0x2, 0x2, 0x7b7, 0x7b8, 0x7, 0x40, 0x2, 0x2, 0x7b8, 0x7b9, \n-    0x7, 0x3f, 0x2, 0x2, 0x7b9, 0x1d0, 0x3, 0x2, 0x2, 0x2, 0x7ba, 0x7bb, \n-    0x7, 0x40, 0x2, 0x2, 0x7bb, 0x1d2, 0x3, 0x2, 0x2, 0x2, 0x7bc, 0x7bd, \n-    0x7, 0x7d, 0x2, 0x2, 0x7bd, 0x1d4, 0x3, 0x2, 0x2, 0x2, 0x7be, 0x7bf, \n-    0x7, 0x5d, 0x2, 0x2, 0x7bf, 0x1d6, 0x3, 0x2, 0x2, 0x2, 0x7c0, 0x7c1, \n-    0x7, 0x3e, 0x2, 0x2, 0x7c1, 0x7c2, 0x7, 0x3f, 0x2, 0x2, 0x7c2, 0x1d8, \n-    0x3, 0x2, 0x2, 0x2, 0x7c3, 0x7c4, 0x7, 0x2a, 0x2, 0x2, 0x7c4, 0x1da, \n-    0x3, 0x2, 0x2, 0x2, 0x7c5, 0x7c6, 0x7, 0x3e, 0x2, 0x2, 0x7c6, 0x1dc, \n-    0x3, 0x2, 0x2, 0x2, 0x7c7, 0x7c8, 0x7, 0x23, 0x2, 0x2, 0x7c8, 0x7cc, \n-    0x7, 0x3f, 0x2, 0x2, 0x7c9, 0x7ca, 0x7, 0x3e, 0x2, 0x2, 0x7ca, 0x7cc, \n-    0x7, 0x40, 0x2, 0x2, 0x7cb, 0x7c7, 0x3, 0x2, 0x2, 0x2, 0x7cb, 0x7c9, \n-    0x3, 0x2, 0x2, 0x2, 0x7cc, 0x1de, 0x3, 0x2, 0x2, 0x2, 0x7cd, 0x7ce, \n-    0x7, 0x27, 0x2, 0x2, 0x7ce, 0x1e0, 0x3, 0x2, 0x2, 0x2, 0x7cf, 0x7d0, \n-    0x7, 0x2d, 0x2, 0x2, 0x7d0, 0x1e2, 0x3, 0x2, 0x2, 0x2, 0x7d1, 0x7d2, \n-    0x7, 0x41, 0x2, 0x2, 0x7d2, 0x1e4, 0x3, 0x2, 0x2, 0x2, 0x7d3, 0x7d4, \n-    0x7, 0x24, 0x2, 0x2, 0x7d4, 0x1e6, 0x3, 0x2, 0x2, 0x2, 0x7d5, 0x7d6, \n-    0x7, 0x29, 0x2, 0x2, 0x7d6, 0x1e8, 0x3, 0x2, 0x2, 0x2, 0x7d7, 0x7d8, \n-    0x7, 0x7f, 0x2, 0x2, 0x7d8, 0x1ea, 0x3, 0x2, 0x2, 0x2, 0x7d9, 0x7da, \n-    0x7, 0x5f, 0x2, 0x2, 0x7da, 0x1ec, 0x3, 0x2, 0x2, 0x2, 0x7db, 0x7dc, \n-    0x7, 0x2b, 0x2, 0x2, 0x7dc, 0x1ee, 0x3, 0x2, 0x2, 0x2, 0x7dd, 0x7de, \n-    0x7, 0x3d, 0x2, 0x2, 0x7de, 0x1f0, 0x3, 0x2, 0x2, 0x2, 0x7df, 0x7e0, \n-    0x7, 0x31, 0x2, 0x2, 0x7e0, 0x1f2, 0x3, 0x2, 0x2, 0x2, 0x7e1, 0x7e2, \n-    0x7, 0x61, 0x2, 0x2, 0x7e2, 0x1f4, 0x3, 0x2, 0x2, 0x2, 0x7e3, 0x7e4, \n-    0x7, 0x31, 0x2, 0x2, 0x7e4, 0x7e5, 0x7, 0x2c, 0x2, 0x2, 0x7e5, 0x7e9, \n-    0x3, 0x2, 0x2, 0x2, 0x7e6, 0x7e8, 0xb, 0x2, 0x2, 0x2, 0x7e7, 0x7e6, \n-    0x3, 0x2, 0x2, 0x2, 0x7e8, 0x7eb, 0x3, 0x2, 0x2, 0x2, 0x7e9, 0x7ea, \n-    0x3, 0x2, 0x2, 0x2, 0x7e9, 0x7e7, 0x3, 0x2, 0x2, 0x2, 0x7ea, 0x7ec, \n-    0x3, 0x2, 0x2, 0x2, 0x7eb, 0x7e9, 0x3, 0x2, 0x2, 0x2, 0x7ec, 0x7ed, \n-    0x7, 0x2c, 0x2, 0x2, 0x7ed, 0x7ee, 0x7, 0x31, 0x2, 0x2, 0x7ee, 0x7ef, \n-    0x3, 0x2, 0x2, 0x2, 0x7ef, 0x7f0, 0x8, 0xfb, 0x2, 0x2, 0x7f0, 0x1f6, \n-    0x3, 0x2, 0x2, 0x2, 0x7f1, 0x7f2, 0x7, 0x2f, 0x2, 0x2, 0x7f2, 0x7f3, \n-    0x7, 0x2f, 0x2, 0x2, 0x7f3, 0x7f7, 0x3, 0x2, 0x2, 0x2, 0x7f4, 0x7f6, \n-    0xa, 0x23, 0x2, 0x2, 0x7f5, 0x7f4, 0x3, 0x2, 0x2, 0x2, 0x7f6, 0x7f9, \n-    0x3, 0x2, 0x2, 0x2, 0x7f7, 0x7f5, 0x3, 0x2, 0x2, 0x2, 0x7f7, 0x7f8, \n-    0x3, 0x2, 0x2, 0x2, 0x7f8, 0x7fb, 0x3, 0x2, 0x2, 0x2, 0x7f9, 0x7f7, \n-    0x3, 0x2, 0x2, 0x2, 0x7fa, 0x7fc, 0x9, 0x24, 0x2, 0x2, 0x7fb, 0x7fa, \n-    0x3, 0x2, 0x2, 0x2, 0x7fc, 0x7fd, 0x3, 0x2, 0x2, 0x2, 0x7fd, 0x7fe, \n-    0x8, 0xfc, 0x2, 0x2, 0x7fe, 0x1f8, 0x3, 0x2, 0x2, 0x2, 0x7ff, 0x800, \n-    0x9, 0x25, 0x2, 0x2, 0x800, 0x801, 0x3, 0x2, 0x2, 0x2, 0x801, 0x802, \n-    0x8, 0xfd, 0x2, 0x2, 0x802, 0x1fa, 0x3, 0x2, 0x2, 0x2, 0x26, 0x2, 0x239, \n-    0x419, 0x6ba, 0x6c9, 0x6ce, 0x6d0, 0x6db, 0x6dd, 0x6ea, 0x6ec, 0x6f1, \n-    0x6f8, 0x6fd, 0x701, 0x706, 0x70b, 0x70f, 0x714, 0x71b, 0x721, 0x726, \n-    0x72d, 0x732, 0x738, 0x73d, 0x73f, 0x745, 0x74a, 0x751, 0x75b, 0x75d, \n-    0x7cb, 0x7e9, 0x7f7, 0x7fb, 0x3, 0x8, 0x2, 0x2, \n-  };\n-\n-  atn::ATNDeserializer deserializer;\n-  _atn = deserializer.deserialize(_serializedATN);\n-\n-  size_t count = _atn.getNumberOfDecisions();\n-  _decisionToDFA.reserve(count);\n-  for (size_t i = 0; i < count; i++) { \n-    _decisionToDFA.emplace_back(_atn.getDecisionState(i), i);\n-  }\n-}\n-\n-ClickHouseLexer::Initializer ClickHouseLexer::_init;\ndiff --git a/src/Parsers/New/ClickHouseLexer.h b/src/Parsers/New/ClickHouseLexer.h\ndeleted file mode 100644\nindex 1cce0ee0bd74..000000000000\n--- a/src/Parsers/New/ClickHouseLexer.h\n+++ /dev/null\n@@ -1,98 +0,0 @@\n-\n-// Generated from ClickHouseLexer.g4 by ANTLR 4.7.2\n-\n-#pragma once\n-\n-\n-#include \"antlr4-runtime.h\"\n-\n-\n-namespace DB {\n-\n-\n-class  ClickHouseLexer : public antlr4::Lexer {\n-public:\n-  enum {\n-    ADD = 1, AFTER = 2, ALIAS = 3, ALL = 4, ALTER = 5, AND = 6, ANTI = 7, \n-    ANY = 8, ARRAY = 9, AS = 10, ASCENDING = 11, ASOF = 12, AST = 13, ASYNC = 14, \n-    ATTACH = 15, BETWEEN = 16, BOTH = 17, BY = 18, CASE = 19, CAST = 20, \n-    CHECK = 21, CLEAR = 22, CLUSTER = 23, CODEC = 24, COLLATE = 25, COLUMN = 26, \n-    COMMENT = 27, CONSTRAINT = 28, CREATE = 29, CROSS = 30, CUBE = 31, DATABASE = 32, \n-    DATABASES = 33, DATE = 34, DAY = 35, DEDUPLICATE = 36, DEFAULT = 37, \n-    DELAY = 38, DELETE = 39, DESC = 40, DESCENDING = 41, DESCRIBE = 42, \n-    DETACH = 43, DICTIONARIES = 44, DICTIONARY = 45, DISK = 46, DISTINCT = 47, \n-    DISTRIBUTED = 48, DROP = 49, ELSE = 50, END = 51, ENGINE = 52, EVENTS = 53, \n-    EXISTS = 54, EXPLAIN = 55, EXPRESSION = 56, EXTRACT = 57, FETCHES = 58, \n-    FINAL = 59, FIRST = 60, FLUSH = 61, FOR = 62, FORMAT = 63, FREEZE = 64, \n-    FROM = 65, FULL = 66, FUNCTION = 67, GLOBAL = 68, GRANULARITY = 69, \n-    GROUP = 70, HAVING = 71, HIERARCHICAL = 72, HOUR = 73, ID = 74, IF = 75, \n-    ILIKE = 76, IN = 77, INDEX = 78, INF = 79, INJECTIVE = 80, INNER = 81, \n-    INSERT = 82, INTERVAL = 83, INTO = 84, IS = 85, IS_OBJECT_ID = 86, JOIN = 87, \n-    KEY = 88, KILL = 89, LAST = 90, LAYOUT = 91, LEADING = 92, LEFT = 93, \n-    LIFETIME = 94, LIKE = 95, LIMIT = 96, LIVE = 97, LOCAL = 98, LOGS = 99, \n-    MATERIALIZE = 100, MATERIALIZED = 101, MAX = 102, MERGES = 103, MIN = 104, \n-    MINUTE = 105, MODIFY = 106, MONTH = 107, MOVE = 108, MUTATION = 109, \n-    NAN_SQL = 110, NO = 111, NOT = 112, NULL_SQL = 113, NULLS = 114, OFFSET = 115, \n-    ON = 116, OPTIMIZE = 117, OR = 118, ORDER = 119, OUTER = 120, OUTFILE = 121, \n-    PARTITION = 122, POPULATE = 123, PREWHERE = 124, PRIMARY = 125, PROJECTION = 126, \n-    QUARTER = 127, RANGE = 128, RELOAD = 129, REMOVE = 130, RENAME = 131, \n-    REPLACE = 132, REPLICA = 133, REPLICATED = 134, RIGHT = 135, ROLLUP = 136, \n-    SAMPLE = 137, SECOND = 138, SELECT = 139, SEMI = 140, SENDS = 141, SET = 142, \n-    SETTINGS = 143, SHOW = 144, SOURCE = 145, START = 146, STOP = 147, SUBSTRING = 148, \n-    SYNC = 149, SYNTAX = 150, SYSTEM = 151, TABLE = 152, TABLES = 153, TEMPORARY = 154, \n-    TEST = 155, THEN = 156, TIES = 157, TIMEOUT = 158, TIMESTAMP = 159, \n-    TO = 160, TOP = 161, TOTALS = 162, TRAILING = 163, TRIM = 164, TRUNCATE = 165, \n-    TTL = 166, TYPE = 167, UNION = 168, UPDATE = 169, USE = 170, USING = 171, \n-    UUID = 172, VALUES = 173, VIEW = 174, VOLUME = 175, WATCH = 176, WEEK = 177, \n-    WHEN = 178, WHERE = 179, WITH = 180, YEAR = 181, JSON_FALSE = 182, JSON_TRUE = 183, \n-    IDENTIFIER = 184, FLOATING_LITERAL = 185, OCTAL_LITERAL = 186, DECIMAL_LITERAL = 187, \n-    HEXADECIMAL_LITERAL = 188, STRING_LITERAL = 189, ARROW = 190, ASTERISK = 191, \n-    BACKQUOTE = 192, BACKSLASH = 193, COLON = 194, COMMA = 195, CONCAT = 196, \n-    DASH = 197, DOT = 198, EQ_DOUBLE = 199, EQ_SINGLE = 200, GE = 201, GT = 202, \n-    LBRACE = 203, LBRACKET = 204, LE = 205, LPAREN = 206, LT = 207, NOT_EQ = 208, \n-    PERCENT = 209, PLUS = 210, QUERY = 211, QUOTE_DOUBLE = 212, QUOTE_SINGLE = 213, \n-    RBRACE = 214, RBRACKET = 215, RPAREN = 216, SEMICOLON = 217, SLASH = 218, \n-    UNDERSCORE = 219, MULTI_LINE_COMMENT = 220, SINGLE_LINE_COMMENT = 221, \n-    WHITESPACE = 222\n-  };\n-\n-  ClickHouseLexer(antlr4::CharStream *input);\n-  ~ClickHouseLexer();\n-\n-  virtual std::string getGrammarFileName() const override;\n-  virtual const std::vector<std::string>& getRuleNames() const override;\n-\n-  virtual const std::vector<std::string>& getChannelNames() const override;\n-  virtual const std::vector<std::string>& getModeNames() const override;\n-  virtual const std::vector<std::string>& getTokenNames() const override; // deprecated, use vocabulary instead\n-  virtual antlr4::dfa::Vocabulary& getVocabulary() const override;\n-\n-  virtual const std::vector<uint16_t> getSerializedATN() const override;\n-  virtual const antlr4::atn::ATN& getATN() const override;\n-\n-private:\n-  static std::vector<antlr4::dfa::DFA> _decisionToDFA;\n-  static antlr4::atn::PredictionContextCache _sharedContextCache;\n-  static std::vector<std::string> _ruleNames;\n-  static std::vector<std::string> _tokenNames;\n-  static std::vector<std::string> _channelNames;\n-  static std::vector<std::string> _modeNames;\n-\n-  static std::vector<std::string> _literalNames;\n-  static std::vector<std::string> _symbolicNames;\n-  static antlr4::dfa::Vocabulary _vocabulary;\n-  static antlr4::atn::ATN _atn;\n-  static std::vector<uint16_t> _serializedATN;\n-\n-\n-  // Individual action functions triggered by action() above.\n-\n-  // Individual semantic predicate functions triggered by sempred() above.\n-\n-  struct Initializer {\n-    Initializer();\n-  };\n-  static Initializer _init;\n-};\n-\n-}  // namespace DB\ndiff --git a/src/Parsers/New/ClickHouseParser.cpp b/src/Parsers/New/ClickHouseParser.cpp\ndeleted file mode 100644\nindex 174f838f19dd..000000000000\n--- a/src/Parsers/New/ClickHouseParser.cpp\n+++ /dev/null\n@@ -1,20220 +0,0 @@\n-\n-// Generated from ClickHouseParser.g4 by ANTLR 4.7.2\n-\n-\n-#include \"ClickHouseParserVisitor.h\"\n-\n-#include \"ClickHouseParser.h\"\n-\n-\n-using namespace antlrcpp;\n-using namespace DB;\n-using namespace antlr4;\n-\n-ClickHouseParser::ClickHouseParser(TokenStream *input) : Parser(input) {\n-  _interpreter = new atn::ParserATNSimulator(this, _atn, _decisionToDFA, _sharedContextCache);\n-}\n-\n-ClickHouseParser::~ClickHouseParser() {\n-  delete _interpreter;\n-}\n-\n-std::string ClickHouseParser::getGrammarFileName() const {\n-  return \"ClickHouseParser.g4\";\n-}\n-\n-const std::vector<std::string>& ClickHouseParser::getRuleNames() const {\n-  return _ruleNames;\n-}\n-\n-dfa::Vocabulary& ClickHouseParser::getVocabulary() const {\n-  return _vocabulary;\n-}\n-\n-\n-//----------------- QueryStmtContext ------------------------------------------------------------------\n-\n-ClickHouseParser::QueryStmtContext::QueryStmtContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::QueryContext* ClickHouseParser::QueryStmtContext::query() {\n-  return getRuleContext<ClickHouseParser::QueryContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::QueryStmtContext::INTO() {\n-  return getToken(ClickHouseParser::INTO, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::QueryStmtContext::OUTFILE() {\n-  return getToken(ClickHouseParser::OUTFILE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::QueryStmtContext::STRING_LITERAL() {\n-  return getToken(ClickHouseParser::STRING_LITERAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::QueryStmtContext::FORMAT() {\n-  return getToken(ClickHouseParser::FORMAT, 0);\n-}\n-\n-ClickHouseParser::IdentifierOrNullContext* ClickHouseParser::QueryStmtContext::identifierOrNull() {\n-  return getRuleContext<ClickHouseParser::IdentifierOrNullContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::QueryStmtContext::SEMICOLON() {\n-  return getToken(ClickHouseParser::SEMICOLON, 0);\n-}\n-\n-ClickHouseParser::InsertStmtContext* ClickHouseParser::QueryStmtContext::insertStmt() {\n-  return getRuleContext<ClickHouseParser::InsertStmtContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::QueryStmtContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleQueryStmt;\n-}\n-\n-antlrcpp::Any ClickHouseParser::QueryStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitQueryStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::QueryStmtContext* ClickHouseParser::queryStmt() {\n-  QueryStmtContext *_localctx = _tracker.createInstance<QueryStmtContext>(_ctx, getState());\n-  enterRule(_localctx, 0, ClickHouseParser::RuleQueryStmt);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(232);\n-    _errHandler->sync(this);\n-    switch (_input->LA(1)) {\n-      case ClickHouseParser::ALTER:\n-      case ClickHouseParser::ATTACH:\n-      case ClickHouseParser::CHECK:\n-      case ClickHouseParser::CREATE:\n-      case ClickHouseParser::DESC:\n-      case ClickHouseParser::DESCRIBE:\n-      case ClickHouseParser::DETACH:\n-      case ClickHouseParser::DROP:\n-      case ClickHouseParser::EXISTS:\n-      case ClickHouseParser::EXPLAIN:\n-      case ClickHouseParser::KILL:\n-      case ClickHouseParser::OPTIMIZE:\n-      case ClickHouseParser::RENAME:\n-      case ClickHouseParser::SELECT:\n-      case ClickHouseParser::SET:\n-      case ClickHouseParser::SHOW:\n-      case ClickHouseParser::SYSTEM:\n-      case ClickHouseParser::TRUNCATE:\n-      case ClickHouseParser::USE:\n-      case ClickHouseParser::WATCH:\n-      case ClickHouseParser::WITH:\n-      case ClickHouseParser::LPAREN: {\n-        enterOuterAlt(_localctx, 1);\n-        setState(218);\n-        query();\n-        setState(222);\n-        _errHandler->sync(this);\n-\n-        _la = _input->LA(1);\n-        if (_la == ClickHouseParser::INTO) {\n-          setState(219);\n-          match(ClickHouseParser::INTO);\n-          setState(220);\n-          match(ClickHouseParser::OUTFILE);\n-          setState(221);\n-          match(ClickHouseParser::STRING_LITERAL);\n-        }\n-        setState(226);\n-        _errHandler->sync(this);\n-\n-        _la = _input->LA(1);\n-        if (_la == ClickHouseParser::FORMAT) {\n-          setState(224);\n-          match(ClickHouseParser::FORMAT);\n-          setState(225);\n-          identifierOrNull();\n-        }\n-        setState(229);\n-        _errHandler->sync(this);\n-\n-        _la = _input->LA(1);\n-        if (_la == ClickHouseParser::SEMICOLON) {\n-          setState(228);\n-          match(ClickHouseParser::SEMICOLON);\n-        }\n-        break;\n-      }\n-\n-      case ClickHouseParser::INSERT: {\n-        enterOuterAlt(_localctx, 2);\n-        setState(231);\n-        insertStmt();\n-        break;\n-      }\n-\n-    default:\n-      throw NoViableAltException(this);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- QueryContext ------------------------------------------------------------------\n-\n-ClickHouseParser::QueryContext::QueryContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::AlterStmtContext* ClickHouseParser::QueryContext::alterStmt() {\n-  return getRuleContext<ClickHouseParser::AlterStmtContext>(0);\n-}\n-\n-ClickHouseParser::AttachStmtContext* ClickHouseParser::QueryContext::attachStmt() {\n-  return getRuleContext<ClickHouseParser::AttachStmtContext>(0);\n-}\n-\n-ClickHouseParser::CheckStmtContext* ClickHouseParser::QueryContext::checkStmt() {\n-  return getRuleContext<ClickHouseParser::CheckStmtContext>(0);\n-}\n-\n-ClickHouseParser::CreateStmtContext* ClickHouseParser::QueryContext::createStmt() {\n-  return getRuleContext<ClickHouseParser::CreateStmtContext>(0);\n-}\n-\n-ClickHouseParser::DescribeStmtContext* ClickHouseParser::QueryContext::describeStmt() {\n-  return getRuleContext<ClickHouseParser::DescribeStmtContext>(0);\n-}\n-\n-ClickHouseParser::DropStmtContext* ClickHouseParser::QueryContext::dropStmt() {\n-  return getRuleContext<ClickHouseParser::DropStmtContext>(0);\n-}\n-\n-ClickHouseParser::ExistsStmtContext* ClickHouseParser::QueryContext::existsStmt() {\n-  return getRuleContext<ClickHouseParser::ExistsStmtContext>(0);\n-}\n-\n-ClickHouseParser::ExplainStmtContext* ClickHouseParser::QueryContext::explainStmt() {\n-  return getRuleContext<ClickHouseParser::ExplainStmtContext>(0);\n-}\n-\n-ClickHouseParser::KillStmtContext* ClickHouseParser::QueryContext::killStmt() {\n-  return getRuleContext<ClickHouseParser::KillStmtContext>(0);\n-}\n-\n-ClickHouseParser::OptimizeStmtContext* ClickHouseParser::QueryContext::optimizeStmt() {\n-  return getRuleContext<ClickHouseParser::OptimizeStmtContext>(0);\n-}\n-\n-ClickHouseParser::RenameStmtContext* ClickHouseParser::QueryContext::renameStmt() {\n-  return getRuleContext<ClickHouseParser::RenameStmtContext>(0);\n-}\n-\n-ClickHouseParser::SelectUnionStmtContext* ClickHouseParser::QueryContext::selectUnionStmt() {\n-  return getRuleContext<ClickHouseParser::SelectUnionStmtContext>(0);\n-}\n-\n-ClickHouseParser::SetStmtContext* ClickHouseParser::QueryContext::setStmt() {\n-  return getRuleContext<ClickHouseParser::SetStmtContext>(0);\n-}\n-\n-ClickHouseParser::ShowStmtContext* ClickHouseParser::QueryContext::showStmt() {\n-  return getRuleContext<ClickHouseParser::ShowStmtContext>(0);\n-}\n-\n-ClickHouseParser::SystemStmtContext* ClickHouseParser::QueryContext::systemStmt() {\n-  return getRuleContext<ClickHouseParser::SystemStmtContext>(0);\n-}\n-\n-ClickHouseParser::TruncateStmtContext* ClickHouseParser::QueryContext::truncateStmt() {\n-  return getRuleContext<ClickHouseParser::TruncateStmtContext>(0);\n-}\n-\n-ClickHouseParser::UseStmtContext* ClickHouseParser::QueryContext::useStmt() {\n-  return getRuleContext<ClickHouseParser::UseStmtContext>(0);\n-}\n-\n-ClickHouseParser::WatchStmtContext* ClickHouseParser::QueryContext::watchStmt() {\n-  return getRuleContext<ClickHouseParser::WatchStmtContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::QueryContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleQuery;\n-}\n-\n-antlrcpp::Any ClickHouseParser::QueryContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitQuery(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::QueryContext* ClickHouseParser::query() {\n-  QueryContext *_localctx = _tracker.createInstance<QueryContext>(_ctx, getState());\n-  enterRule(_localctx, 2, ClickHouseParser::RuleQuery);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(252);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx)) {\n-    case 1: {\n-      enterOuterAlt(_localctx, 1);\n-      setState(234);\n-      alterStmt();\n-      break;\n-    }\n-\n-    case 2: {\n-      enterOuterAlt(_localctx, 2);\n-      setState(235);\n-      attachStmt();\n-      break;\n-    }\n-\n-    case 3: {\n-      enterOuterAlt(_localctx, 3);\n-      setState(236);\n-      checkStmt();\n-      break;\n-    }\n-\n-    case 4: {\n-      enterOuterAlt(_localctx, 4);\n-      setState(237);\n-      createStmt();\n-      break;\n-    }\n-\n-    case 5: {\n-      enterOuterAlt(_localctx, 5);\n-      setState(238);\n-      describeStmt();\n-      break;\n-    }\n-\n-    case 6: {\n-      enterOuterAlt(_localctx, 6);\n-      setState(239);\n-      dropStmt();\n-      break;\n-    }\n-\n-    case 7: {\n-      enterOuterAlt(_localctx, 7);\n-      setState(240);\n-      existsStmt();\n-      break;\n-    }\n-\n-    case 8: {\n-      enterOuterAlt(_localctx, 8);\n-      setState(241);\n-      explainStmt();\n-      break;\n-    }\n-\n-    case 9: {\n-      enterOuterAlt(_localctx, 9);\n-      setState(242);\n-      killStmt();\n-      break;\n-    }\n-\n-    case 10: {\n-      enterOuterAlt(_localctx, 10);\n-      setState(243);\n-      optimizeStmt();\n-      break;\n-    }\n-\n-    case 11: {\n-      enterOuterAlt(_localctx, 11);\n-      setState(244);\n-      renameStmt();\n-      break;\n-    }\n-\n-    case 12: {\n-      enterOuterAlt(_localctx, 12);\n-      setState(245);\n-      selectUnionStmt();\n-      break;\n-    }\n-\n-    case 13: {\n-      enterOuterAlt(_localctx, 13);\n-      setState(246);\n-      setStmt();\n-      break;\n-    }\n-\n-    case 14: {\n-      enterOuterAlt(_localctx, 14);\n-      setState(247);\n-      showStmt();\n-      break;\n-    }\n-\n-    case 15: {\n-      enterOuterAlt(_localctx, 15);\n-      setState(248);\n-      systemStmt();\n-      break;\n-    }\n-\n-    case 16: {\n-      enterOuterAlt(_localctx, 16);\n-      setState(249);\n-      truncateStmt();\n-      break;\n-    }\n-\n-    case 17: {\n-      enterOuterAlt(_localctx, 17);\n-      setState(250);\n-      useStmt();\n-      break;\n-    }\n-\n-    case 18: {\n-      enterOuterAlt(_localctx, 18);\n-      setState(251);\n-      watchStmt();\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- AlterStmtContext ------------------------------------------------------------------\n-\n-ClickHouseParser::AlterStmtContext::AlterStmtContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-\n-size_t ClickHouseParser::AlterStmtContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleAlterStmt;\n-}\n-\n-void ClickHouseParser::AlterStmtContext::copyFrom(AlterStmtContext *ctx) {\n-  ParserRuleContext::copyFrom(ctx);\n-}\n-\n-//----------------- AlterTableStmtContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableStmtContext::ALTER() {\n-  return getToken(ClickHouseParser::ALTER, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableStmtContext::TABLE() {\n-  return getToken(ClickHouseParser::TABLE, 0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::AlterTableStmtContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-std::vector<ClickHouseParser::AlterTableClauseContext *> ClickHouseParser::AlterTableStmtContext::alterTableClause() {\n-  return getRuleContexts<ClickHouseParser::AlterTableClauseContext>();\n-}\n-\n-ClickHouseParser::AlterTableClauseContext* ClickHouseParser::AlterTableStmtContext::alterTableClause(size_t i) {\n-  return getRuleContext<ClickHouseParser::AlterTableClauseContext>(i);\n-}\n-\n-ClickHouseParser::ClusterClauseContext* ClickHouseParser::AlterTableStmtContext::clusterClause() {\n-  return getRuleContext<ClickHouseParser::ClusterClauseContext>(0);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::AlterTableStmtContext::COMMA() {\n-  return getTokens(ClickHouseParser::COMMA);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableStmtContext::COMMA(size_t i) {\n-  return getToken(ClickHouseParser::COMMA, i);\n-}\n-\n-ClickHouseParser::AlterTableStmtContext::AlterTableStmtContext(AlterStmtContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-ClickHouseParser::AlterStmtContext* ClickHouseParser::alterStmt() {\n-  AlterStmtContext *_localctx = _tracker.createInstance<AlterStmtContext>(_ctx, getState());\n-  enterRule(_localctx, 4, ClickHouseParser::RuleAlterStmt);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    _localctx = dynamic_cast<AlterStmtContext *>(_tracker.createInstance<ClickHouseParser::AlterTableStmtContext>(_localctx));\n-    enterOuterAlt(_localctx, 1);\n-    setState(254);\n-    match(ClickHouseParser::ALTER);\n-    setState(255);\n-    match(ClickHouseParser::TABLE);\n-    setState(256);\n-    tableIdentifier();\n-    setState(258);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::ON) {\n-      setState(257);\n-      clusterClause();\n-    }\n-    setState(260);\n-    alterTableClause();\n-    setState(265);\n-    _errHandler->sync(this);\n-    _la = _input->LA(1);\n-    while (_la == ClickHouseParser::COMMA) {\n-      setState(261);\n-      match(ClickHouseParser::COMMA);\n-      setState(262);\n-      alterTableClause();\n-      setState(267);\n-      _errHandler->sync(this);\n-      _la = _input->LA(1);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- AlterTableClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::AlterTableClauseContext::AlterTableClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-\n-size_t ClickHouseParser::AlterTableClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleAlterTableClause;\n-}\n-\n-void ClickHouseParser::AlterTableClauseContext::copyFrom(AlterTableClauseContext *ctx) {\n-  ParserRuleContext::copyFrom(ctx);\n-}\n-\n-//----------------- AlterTableClauseReplaceContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseReplaceContext::REPLACE() {\n-  return getToken(ClickHouseParser::REPLACE, 0);\n-}\n-\n-ClickHouseParser::PartitionClauseContext* ClickHouseParser::AlterTableClauseReplaceContext::partitionClause() {\n-  return getRuleContext<ClickHouseParser::PartitionClauseContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseReplaceContext::FROM() {\n-  return getToken(ClickHouseParser::FROM, 0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::AlterTableClauseReplaceContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::AlterTableClauseReplaceContext::AlterTableClauseReplaceContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseReplaceContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseReplace(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseModifyOrderByContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseModifyOrderByContext::MODIFY() {\n-  return getToken(ClickHouseParser::MODIFY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseModifyOrderByContext::ORDER() {\n-  return getToken(ClickHouseParser::ORDER, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseModifyOrderByContext::BY() {\n-  return getToken(ClickHouseParser::BY, 0);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::AlterTableClauseModifyOrderByContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-ClickHouseParser::AlterTableClauseModifyOrderByContext::AlterTableClauseModifyOrderByContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseModifyOrderByContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseModifyOrderBy(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseUpdateContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseUpdateContext::UPDATE() {\n-  return getToken(ClickHouseParser::UPDATE, 0);\n-}\n-\n-ClickHouseParser::AssignmentExprListContext* ClickHouseParser::AlterTableClauseUpdateContext::assignmentExprList() {\n-  return getRuleContext<ClickHouseParser::AssignmentExprListContext>(0);\n-}\n-\n-ClickHouseParser::WhereClauseContext* ClickHouseParser::AlterTableClauseUpdateContext::whereClause() {\n-  return getRuleContext<ClickHouseParser::WhereClauseContext>(0);\n-}\n-\n-ClickHouseParser::AlterTableClauseUpdateContext::AlterTableClauseUpdateContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseUpdateContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseUpdate(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseClearProjectionContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseClearProjectionContext::CLEAR() {\n-  return getToken(ClickHouseParser::CLEAR, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseClearProjectionContext::PROJECTION() {\n-  return getToken(ClickHouseParser::PROJECTION, 0);\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::AlterTableClauseClearProjectionContext::nestedIdentifier() {\n-  return getRuleContext<ClickHouseParser::NestedIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseClearProjectionContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseClearProjectionContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseClearProjectionContext::IN() {\n-  return getToken(ClickHouseParser::IN, 0);\n-}\n-\n-ClickHouseParser::PartitionClauseContext* ClickHouseParser::AlterTableClauseClearProjectionContext::partitionClause() {\n-  return getRuleContext<ClickHouseParser::PartitionClauseContext>(0);\n-}\n-\n-ClickHouseParser::AlterTableClauseClearProjectionContext::AlterTableClauseClearProjectionContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseClearProjectionContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseClearProjection(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseModifyRemoveContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseModifyRemoveContext::MODIFY() {\n-  return getToken(ClickHouseParser::MODIFY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseModifyRemoveContext::COLUMN() {\n-  return getToken(ClickHouseParser::COLUMN, 0);\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::AlterTableClauseModifyRemoveContext::nestedIdentifier() {\n-  return getRuleContext<ClickHouseParser::NestedIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseModifyRemoveContext::REMOVE() {\n-  return getToken(ClickHouseParser::REMOVE, 0);\n-}\n-\n-ClickHouseParser::TableColumnPropertyTypeContext* ClickHouseParser::AlterTableClauseModifyRemoveContext::tableColumnPropertyType() {\n-  return getRuleContext<ClickHouseParser::TableColumnPropertyTypeContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseModifyRemoveContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseModifyRemoveContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-ClickHouseParser::AlterTableClauseModifyRemoveContext::AlterTableClauseModifyRemoveContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseModifyRemoveContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseModifyRemove(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseDeleteContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseDeleteContext::DELETE() {\n-  return getToken(ClickHouseParser::DELETE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseDeleteContext::WHERE() {\n-  return getToken(ClickHouseParser::WHERE, 0);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::AlterTableClauseDeleteContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-ClickHouseParser::AlterTableClauseDeleteContext::AlterTableClauseDeleteContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseDeleteContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseDelete(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseCommentContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseCommentContext::COMMENT() {\n-  return getToken(ClickHouseParser::COMMENT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseCommentContext::COLUMN() {\n-  return getToken(ClickHouseParser::COLUMN, 0);\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::AlterTableClauseCommentContext::nestedIdentifier() {\n-  return getRuleContext<ClickHouseParser::NestedIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseCommentContext::STRING_LITERAL() {\n-  return getToken(ClickHouseParser::STRING_LITERAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseCommentContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseCommentContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-ClickHouseParser::AlterTableClauseCommentContext::AlterTableClauseCommentContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseCommentContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseComment(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseDropColumnContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseDropColumnContext::DROP() {\n-  return getToken(ClickHouseParser::DROP, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseDropColumnContext::COLUMN() {\n-  return getToken(ClickHouseParser::COLUMN, 0);\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::AlterTableClauseDropColumnContext::nestedIdentifier() {\n-  return getRuleContext<ClickHouseParser::NestedIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseDropColumnContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseDropColumnContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-ClickHouseParser::AlterTableClauseDropColumnContext::AlterTableClauseDropColumnContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseDropColumnContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseDropColumn(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseDetachContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseDetachContext::DETACH() {\n-  return getToken(ClickHouseParser::DETACH, 0);\n-}\n-\n-ClickHouseParser::PartitionClauseContext* ClickHouseParser::AlterTableClauseDetachContext::partitionClause() {\n-  return getRuleContext<ClickHouseParser::PartitionClauseContext>(0);\n-}\n-\n-ClickHouseParser::AlterTableClauseDetachContext::AlterTableClauseDetachContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseDetachContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseDetach(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseAddIndexContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseAddIndexContext::ADD() {\n-  return getToken(ClickHouseParser::ADD, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseAddIndexContext::INDEX() {\n-  return getToken(ClickHouseParser::INDEX, 0);\n-}\n-\n-ClickHouseParser::TableIndexDfntContext* ClickHouseParser::AlterTableClauseAddIndexContext::tableIndexDfnt() {\n-  return getRuleContext<ClickHouseParser::TableIndexDfntContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseAddIndexContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseAddIndexContext::NOT() {\n-  return getToken(ClickHouseParser::NOT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseAddIndexContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseAddIndexContext::AFTER() {\n-  return getToken(ClickHouseParser::AFTER, 0);\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::AlterTableClauseAddIndexContext::nestedIdentifier() {\n-  return getRuleContext<ClickHouseParser::NestedIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::AlterTableClauseAddIndexContext::AlterTableClauseAddIndexContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseAddIndexContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseAddIndex(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseDropPartitionContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseDropPartitionContext::DROP() {\n-  return getToken(ClickHouseParser::DROP, 0);\n-}\n-\n-ClickHouseParser::PartitionClauseContext* ClickHouseParser::AlterTableClauseDropPartitionContext::partitionClause() {\n-  return getRuleContext<ClickHouseParser::PartitionClauseContext>(0);\n-}\n-\n-ClickHouseParser::AlterTableClauseDropPartitionContext::AlterTableClauseDropPartitionContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseDropPartitionContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseDropPartition(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseMaterializeIndexContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseMaterializeIndexContext::MATERIALIZE() {\n-  return getToken(ClickHouseParser::MATERIALIZE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseMaterializeIndexContext::INDEX() {\n-  return getToken(ClickHouseParser::INDEX, 0);\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::AlterTableClauseMaterializeIndexContext::nestedIdentifier() {\n-  return getRuleContext<ClickHouseParser::NestedIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseMaterializeIndexContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseMaterializeIndexContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseMaterializeIndexContext::IN() {\n-  return getToken(ClickHouseParser::IN, 0);\n-}\n-\n-ClickHouseParser::PartitionClauseContext* ClickHouseParser::AlterTableClauseMaterializeIndexContext::partitionClause() {\n-  return getRuleContext<ClickHouseParser::PartitionClauseContext>(0);\n-}\n-\n-ClickHouseParser::AlterTableClauseMaterializeIndexContext::AlterTableClauseMaterializeIndexContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseMaterializeIndexContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseMaterializeIndex(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseMaterializeProjectionContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseMaterializeProjectionContext::MATERIALIZE() {\n-  return getToken(ClickHouseParser::MATERIALIZE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseMaterializeProjectionContext::PROJECTION() {\n-  return getToken(ClickHouseParser::PROJECTION, 0);\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::AlterTableClauseMaterializeProjectionContext::nestedIdentifier() {\n-  return getRuleContext<ClickHouseParser::NestedIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseMaterializeProjectionContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseMaterializeProjectionContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseMaterializeProjectionContext::IN() {\n-  return getToken(ClickHouseParser::IN, 0);\n-}\n-\n-ClickHouseParser::PartitionClauseContext* ClickHouseParser::AlterTableClauseMaterializeProjectionContext::partitionClause() {\n-  return getRuleContext<ClickHouseParser::PartitionClauseContext>(0);\n-}\n-\n-ClickHouseParser::AlterTableClauseMaterializeProjectionContext::AlterTableClauseMaterializeProjectionContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseMaterializeProjectionContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseMaterializeProjection(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseMovePartitionContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseMovePartitionContext::MOVE() {\n-  return getToken(ClickHouseParser::MOVE, 0);\n-}\n-\n-ClickHouseParser::PartitionClauseContext* ClickHouseParser::AlterTableClauseMovePartitionContext::partitionClause() {\n-  return getRuleContext<ClickHouseParser::PartitionClauseContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseMovePartitionContext::TO() {\n-  return getToken(ClickHouseParser::TO, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseMovePartitionContext::DISK() {\n-  return getToken(ClickHouseParser::DISK, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseMovePartitionContext::STRING_LITERAL() {\n-  return getToken(ClickHouseParser::STRING_LITERAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseMovePartitionContext::VOLUME() {\n-  return getToken(ClickHouseParser::VOLUME, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseMovePartitionContext::TABLE() {\n-  return getToken(ClickHouseParser::TABLE, 0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::AlterTableClauseMovePartitionContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::AlterTableClauseMovePartitionContext::AlterTableClauseMovePartitionContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseMovePartitionContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseMovePartition(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseRenameContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseRenameContext::RENAME() {\n-  return getToken(ClickHouseParser::RENAME, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseRenameContext::COLUMN() {\n-  return getToken(ClickHouseParser::COLUMN, 0);\n-}\n-\n-std::vector<ClickHouseParser::NestedIdentifierContext *> ClickHouseParser::AlterTableClauseRenameContext::nestedIdentifier() {\n-  return getRuleContexts<ClickHouseParser::NestedIdentifierContext>();\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::AlterTableClauseRenameContext::nestedIdentifier(size_t i) {\n-  return getRuleContext<ClickHouseParser::NestedIdentifierContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseRenameContext::TO() {\n-  return getToken(ClickHouseParser::TO, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseRenameContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseRenameContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-ClickHouseParser::AlterTableClauseRenameContext::AlterTableClauseRenameContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseRenameContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseRename(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseFreezePartitionContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseFreezePartitionContext::FREEZE() {\n-  return getToken(ClickHouseParser::FREEZE, 0);\n-}\n-\n-ClickHouseParser::PartitionClauseContext* ClickHouseParser::AlterTableClauseFreezePartitionContext::partitionClause() {\n-  return getRuleContext<ClickHouseParser::PartitionClauseContext>(0);\n-}\n-\n-ClickHouseParser::AlterTableClauseFreezePartitionContext::AlterTableClauseFreezePartitionContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseFreezePartitionContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseFreezePartition(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseClearColumnContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseClearColumnContext::CLEAR() {\n-  return getToken(ClickHouseParser::CLEAR, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseClearColumnContext::COLUMN() {\n-  return getToken(ClickHouseParser::COLUMN, 0);\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::AlterTableClauseClearColumnContext::nestedIdentifier() {\n-  return getRuleContext<ClickHouseParser::NestedIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseClearColumnContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseClearColumnContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseClearColumnContext::IN() {\n-  return getToken(ClickHouseParser::IN, 0);\n-}\n-\n-ClickHouseParser::PartitionClauseContext* ClickHouseParser::AlterTableClauseClearColumnContext::partitionClause() {\n-  return getRuleContext<ClickHouseParser::PartitionClauseContext>(0);\n-}\n-\n-ClickHouseParser::AlterTableClauseClearColumnContext::AlterTableClauseClearColumnContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseClearColumnContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseClearColumn(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseModifyContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseModifyContext::MODIFY() {\n-  return getToken(ClickHouseParser::MODIFY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseModifyContext::COLUMN() {\n-  return getToken(ClickHouseParser::COLUMN, 0);\n-}\n-\n-ClickHouseParser::TableColumnDfntContext* ClickHouseParser::AlterTableClauseModifyContext::tableColumnDfnt() {\n-  return getRuleContext<ClickHouseParser::TableColumnDfntContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseModifyContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseModifyContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-ClickHouseParser::AlterTableClauseModifyContext::AlterTableClauseModifyContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseModifyContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseModify(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseClearIndexContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseClearIndexContext::CLEAR() {\n-  return getToken(ClickHouseParser::CLEAR, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseClearIndexContext::INDEX() {\n-  return getToken(ClickHouseParser::INDEX, 0);\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::AlterTableClauseClearIndexContext::nestedIdentifier() {\n-  return getRuleContext<ClickHouseParser::NestedIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseClearIndexContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseClearIndexContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseClearIndexContext::IN() {\n-  return getToken(ClickHouseParser::IN, 0);\n-}\n-\n-ClickHouseParser::PartitionClauseContext* ClickHouseParser::AlterTableClauseClearIndexContext::partitionClause() {\n-  return getRuleContext<ClickHouseParser::PartitionClauseContext>(0);\n-}\n-\n-ClickHouseParser::AlterTableClauseClearIndexContext::AlterTableClauseClearIndexContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseClearIndexContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseClearIndex(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseRemoveTTLContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseRemoveTTLContext::REMOVE() {\n-  return getToken(ClickHouseParser::REMOVE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseRemoveTTLContext::TTL() {\n-  return getToken(ClickHouseParser::TTL, 0);\n-}\n-\n-ClickHouseParser::AlterTableClauseRemoveTTLContext::AlterTableClauseRemoveTTLContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseRemoveTTLContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseRemoveTTL(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseModifyCodecContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseModifyCodecContext::MODIFY() {\n-  return getToken(ClickHouseParser::MODIFY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseModifyCodecContext::COLUMN() {\n-  return getToken(ClickHouseParser::COLUMN, 0);\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::AlterTableClauseModifyCodecContext::nestedIdentifier() {\n-  return getRuleContext<ClickHouseParser::NestedIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::CodecExprContext* ClickHouseParser::AlterTableClauseModifyCodecContext::codecExpr() {\n-  return getRuleContext<ClickHouseParser::CodecExprContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseModifyCodecContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseModifyCodecContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-ClickHouseParser::AlterTableClauseModifyCodecContext::AlterTableClauseModifyCodecContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseModifyCodecContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseModifyCodec(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseAttachContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseAttachContext::ATTACH() {\n-  return getToken(ClickHouseParser::ATTACH, 0);\n-}\n-\n-ClickHouseParser::PartitionClauseContext* ClickHouseParser::AlterTableClauseAttachContext::partitionClause() {\n-  return getRuleContext<ClickHouseParser::PartitionClauseContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseAttachContext::FROM() {\n-  return getToken(ClickHouseParser::FROM, 0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::AlterTableClauseAttachContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::AlterTableClauseAttachContext::AlterTableClauseAttachContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseAttachContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseAttach(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseDropProjectionContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseDropProjectionContext::DROP() {\n-  return getToken(ClickHouseParser::DROP, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseDropProjectionContext::PROJECTION() {\n-  return getToken(ClickHouseParser::PROJECTION, 0);\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::AlterTableClauseDropProjectionContext::nestedIdentifier() {\n-  return getRuleContext<ClickHouseParser::NestedIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseDropProjectionContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseDropProjectionContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-ClickHouseParser::AlterTableClauseDropProjectionContext::AlterTableClauseDropProjectionContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseDropProjectionContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseDropProjection(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseDropIndexContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseDropIndexContext::DROP() {\n-  return getToken(ClickHouseParser::DROP, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseDropIndexContext::INDEX() {\n-  return getToken(ClickHouseParser::INDEX, 0);\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::AlterTableClauseDropIndexContext::nestedIdentifier() {\n-  return getRuleContext<ClickHouseParser::NestedIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseDropIndexContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseDropIndexContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-ClickHouseParser::AlterTableClauseDropIndexContext::AlterTableClauseDropIndexContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseDropIndexContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseDropIndex(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseModifyCommentContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseModifyCommentContext::MODIFY() {\n-  return getToken(ClickHouseParser::MODIFY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseModifyCommentContext::COLUMN() {\n-  return getToken(ClickHouseParser::COLUMN, 0);\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::AlterTableClauseModifyCommentContext::nestedIdentifier() {\n-  return getRuleContext<ClickHouseParser::NestedIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseModifyCommentContext::COMMENT() {\n-  return getToken(ClickHouseParser::COMMENT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseModifyCommentContext::STRING_LITERAL() {\n-  return getToken(ClickHouseParser::STRING_LITERAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseModifyCommentContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseModifyCommentContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-ClickHouseParser::AlterTableClauseModifyCommentContext::AlterTableClauseModifyCommentContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseModifyCommentContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseModifyComment(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseModifyTTLContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseModifyTTLContext::MODIFY() {\n-  return getToken(ClickHouseParser::MODIFY, 0);\n-}\n-\n-ClickHouseParser::TtlClauseContext* ClickHouseParser::AlterTableClauseModifyTTLContext::ttlClause() {\n-  return getRuleContext<ClickHouseParser::TtlClauseContext>(0);\n-}\n-\n-ClickHouseParser::AlterTableClauseModifyTTLContext::AlterTableClauseModifyTTLContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseModifyTTLContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseModifyTTL(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseAddProjectionContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseAddProjectionContext::ADD() {\n-  return getToken(ClickHouseParser::ADD, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseAddProjectionContext::PROJECTION() {\n-  return getToken(ClickHouseParser::PROJECTION, 0);\n-}\n-\n-ClickHouseParser::TableProjectionDfntContext* ClickHouseParser::AlterTableClauseAddProjectionContext::tableProjectionDfnt() {\n-  return getRuleContext<ClickHouseParser::TableProjectionDfntContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseAddProjectionContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseAddProjectionContext::NOT() {\n-  return getToken(ClickHouseParser::NOT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseAddProjectionContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseAddProjectionContext::AFTER() {\n-  return getToken(ClickHouseParser::AFTER, 0);\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::AlterTableClauseAddProjectionContext::nestedIdentifier() {\n-  return getRuleContext<ClickHouseParser::NestedIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::AlterTableClauseAddProjectionContext::AlterTableClauseAddProjectionContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseAddProjectionContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseAddProjection(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- AlterTableClauseAddColumnContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseAddColumnContext::ADD() {\n-  return getToken(ClickHouseParser::ADD, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseAddColumnContext::COLUMN() {\n-  return getToken(ClickHouseParser::COLUMN, 0);\n-}\n-\n-ClickHouseParser::TableColumnDfntContext* ClickHouseParser::AlterTableClauseAddColumnContext::tableColumnDfnt() {\n-  return getRuleContext<ClickHouseParser::TableColumnDfntContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseAddColumnContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseAddColumnContext::NOT() {\n-  return getToken(ClickHouseParser::NOT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseAddColumnContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AlterTableClauseAddColumnContext::AFTER() {\n-  return getToken(ClickHouseParser::AFTER, 0);\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::AlterTableClauseAddColumnContext::nestedIdentifier() {\n-  return getRuleContext<ClickHouseParser::NestedIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::AlterTableClauseAddColumnContext::AlterTableClauseAddColumnContext(AlterTableClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AlterTableClauseAddColumnContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlterTableClauseAddColumn(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-ClickHouseParser::AlterTableClauseContext* ClickHouseParser::alterTableClause() {\n-  AlterTableClauseContext *_localctx = _tracker.createInstance<AlterTableClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 6, ClickHouseParser::RuleAlterTableClause);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(482);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {\n-    case 1: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseAddColumnContext>(_localctx));\n-      enterOuterAlt(_localctx, 1);\n-      setState(268);\n-      match(ClickHouseParser::ADD);\n-      setState(269);\n-      match(ClickHouseParser::COLUMN);\n-      setState(273);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx)) {\n-      case 1: {\n-        setState(270);\n-        match(ClickHouseParser::IF);\n-        setState(271);\n-        match(ClickHouseParser::NOT);\n-        setState(272);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(275);\n-      tableColumnDfnt();\n-      setState(278);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::AFTER) {\n-        setState(276);\n-        match(ClickHouseParser::AFTER);\n-        setState(277);\n-        nestedIdentifier();\n-      }\n-      break;\n-    }\n-\n-    case 2: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseAddIndexContext>(_localctx));\n-      enterOuterAlt(_localctx, 2);\n-      setState(280);\n-      match(ClickHouseParser::ADD);\n-      setState(281);\n-      match(ClickHouseParser::INDEX);\n-      setState(285);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {\n-      case 1: {\n-        setState(282);\n-        match(ClickHouseParser::IF);\n-        setState(283);\n-        match(ClickHouseParser::NOT);\n-        setState(284);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(287);\n-      tableIndexDfnt();\n-      setState(290);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::AFTER) {\n-        setState(288);\n-        match(ClickHouseParser::AFTER);\n-        setState(289);\n-        nestedIdentifier();\n-      }\n-      break;\n-    }\n-\n-    case 3: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseAddProjectionContext>(_localctx));\n-      enterOuterAlt(_localctx, 3);\n-      setState(292);\n-      match(ClickHouseParser::ADD);\n-      setState(293);\n-      match(ClickHouseParser::PROJECTION);\n-      setState(297);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx)) {\n-      case 1: {\n-        setState(294);\n-        match(ClickHouseParser::IF);\n-        setState(295);\n-        match(ClickHouseParser::NOT);\n-        setState(296);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(299);\n-      tableProjectionDfnt();\n-      setState(302);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::AFTER) {\n-        setState(300);\n-        match(ClickHouseParser::AFTER);\n-        setState(301);\n-        nestedIdentifier();\n-      }\n-      break;\n-    }\n-\n-    case 4: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseAttachContext>(_localctx));\n-      enterOuterAlt(_localctx, 4);\n-      setState(304);\n-      match(ClickHouseParser::ATTACH);\n-      setState(305);\n-      partitionClause();\n-      setState(308);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::FROM) {\n-        setState(306);\n-        match(ClickHouseParser::FROM);\n-        setState(307);\n-        tableIdentifier();\n-      }\n-      break;\n-    }\n-\n-    case 5: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseClearColumnContext>(_localctx));\n-      enterOuterAlt(_localctx, 5);\n-      setState(310);\n-      match(ClickHouseParser::CLEAR);\n-      setState(311);\n-      match(ClickHouseParser::COLUMN);\n-      setState(314);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx)) {\n-      case 1: {\n-        setState(312);\n-        match(ClickHouseParser::IF);\n-        setState(313);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(316);\n-      nestedIdentifier();\n-      setState(319);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::IN) {\n-        setState(317);\n-        match(ClickHouseParser::IN);\n-        setState(318);\n-        partitionClause();\n-      }\n-      break;\n-    }\n-\n-    case 6: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseClearIndexContext>(_localctx));\n-      enterOuterAlt(_localctx, 6);\n-      setState(321);\n-      match(ClickHouseParser::CLEAR);\n-      setState(322);\n-      match(ClickHouseParser::INDEX);\n-      setState(325);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx)) {\n-      case 1: {\n-        setState(323);\n-        match(ClickHouseParser::IF);\n-        setState(324);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(327);\n-      nestedIdentifier();\n-      setState(330);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::IN) {\n-        setState(328);\n-        match(ClickHouseParser::IN);\n-        setState(329);\n-        partitionClause();\n-      }\n-      break;\n-    }\n-\n-    case 7: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseClearProjectionContext>(_localctx));\n-      enterOuterAlt(_localctx, 7);\n-      setState(332);\n-      match(ClickHouseParser::CLEAR);\n-      setState(333);\n-      match(ClickHouseParser::PROJECTION);\n-      setState(336);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {\n-      case 1: {\n-        setState(334);\n-        match(ClickHouseParser::IF);\n-        setState(335);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(338);\n-      nestedIdentifier();\n-      setState(341);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::IN) {\n-        setState(339);\n-        match(ClickHouseParser::IN);\n-        setState(340);\n-        partitionClause();\n-      }\n-      break;\n-    }\n-\n-    case 8: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseCommentContext>(_localctx));\n-      enterOuterAlt(_localctx, 8);\n-      setState(343);\n-      match(ClickHouseParser::COMMENT);\n-      setState(344);\n-      match(ClickHouseParser::COLUMN);\n-      setState(347);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx)) {\n-      case 1: {\n-        setState(345);\n-        match(ClickHouseParser::IF);\n-        setState(346);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(349);\n-      nestedIdentifier();\n-      setState(350);\n-      match(ClickHouseParser::STRING_LITERAL);\n-      break;\n-    }\n-\n-    case 9: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseDeleteContext>(_localctx));\n-      enterOuterAlt(_localctx, 9);\n-      setState(352);\n-      match(ClickHouseParser::DELETE);\n-      setState(353);\n-      match(ClickHouseParser::WHERE);\n-      setState(354);\n-      columnExpr(0);\n-      break;\n-    }\n-\n-    case 10: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseDetachContext>(_localctx));\n-      enterOuterAlt(_localctx, 10);\n-      setState(355);\n-      match(ClickHouseParser::DETACH);\n-      setState(356);\n-      partitionClause();\n-      break;\n-    }\n-\n-    case 11: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseDropColumnContext>(_localctx));\n-      enterOuterAlt(_localctx, 11);\n-      setState(357);\n-      match(ClickHouseParser::DROP);\n-      setState(358);\n-      match(ClickHouseParser::COLUMN);\n-      setState(361);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {\n-      case 1: {\n-        setState(359);\n-        match(ClickHouseParser::IF);\n-        setState(360);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(363);\n-      nestedIdentifier();\n-      break;\n-    }\n-\n-    case 12: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseDropIndexContext>(_localctx));\n-      enterOuterAlt(_localctx, 12);\n-      setState(364);\n-      match(ClickHouseParser::DROP);\n-      setState(365);\n-      match(ClickHouseParser::INDEX);\n-      setState(368);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx)) {\n-      case 1: {\n-        setState(366);\n-        match(ClickHouseParser::IF);\n-        setState(367);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(370);\n-      nestedIdentifier();\n-      break;\n-    }\n-\n-    case 13: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseDropProjectionContext>(_localctx));\n-      enterOuterAlt(_localctx, 13);\n-      setState(371);\n-      match(ClickHouseParser::DROP);\n-      setState(372);\n-      match(ClickHouseParser::PROJECTION);\n-      setState(375);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx)) {\n-      case 1: {\n-        setState(373);\n-        match(ClickHouseParser::IF);\n-        setState(374);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(377);\n-      nestedIdentifier();\n-      break;\n-    }\n-\n-    case 14: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseDropPartitionContext>(_localctx));\n-      enterOuterAlt(_localctx, 14);\n-      setState(378);\n-      match(ClickHouseParser::DROP);\n-      setState(379);\n-      partitionClause();\n-      break;\n-    }\n-\n-    case 15: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseFreezePartitionContext>(_localctx));\n-      enterOuterAlt(_localctx, 15);\n-      setState(380);\n-      match(ClickHouseParser::FREEZE);\n-      setState(382);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::PARTITION) {\n-        setState(381);\n-        partitionClause();\n-      }\n-      break;\n-    }\n-\n-    case 16: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseMaterializeIndexContext>(_localctx));\n-      enterOuterAlt(_localctx, 16);\n-      setState(384);\n-      match(ClickHouseParser::MATERIALIZE);\n-      setState(385);\n-      match(ClickHouseParser::INDEX);\n-      setState(388);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx)) {\n-      case 1: {\n-        setState(386);\n-        match(ClickHouseParser::IF);\n-        setState(387);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(390);\n-      nestedIdentifier();\n-      setState(393);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::IN) {\n-        setState(391);\n-        match(ClickHouseParser::IN);\n-        setState(392);\n-        partitionClause();\n-      }\n-      break;\n-    }\n-\n-    case 17: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseMaterializeProjectionContext>(_localctx));\n-      enterOuterAlt(_localctx, 17);\n-      setState(395);\n-      match(ClickHouseParser::MATERIALIZE);\n-      setState(396);\n-      match(ClickHouseParser::PROJECTION);\n-      setState(399);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {\n-      case 1: {\n-        setState(397);\n-        match(ClickHouseParser::IF);\n-        setState(398);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(401);\n-      nestedIdentifier();\n-      setState(404);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::IN) {\n-        setState(402);\n-        match(ClickHouseParser::IN);\n-        setState(403);\n-        partitionClause();\n-      }\n-      break;\n-    }\n-\n-    case 18: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseModifyCodecContext>(_localctx));\n-      enterOuterAlt(_localctx, 18);\n-      setState(406);\n-      match(ClickHouseParser::MODIFY);\n-      setState(407);\n-      match(ClickHouseParser::COLUMN);\n-      setState(410);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {\n-      case 1: {\n-        setState(408);\n-        match(ClickHouseParser::IF);\n-        setState(409);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(412);\n-      nestedIdentifier();\n-      setState(413);\n-      codecExpr();\n-      break;\n-    }\n-\n-    case 19: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseModifyCommentContext>(_localctx));\n-      enterOuterAlt(_localctx, 19);\n-      setState(415);\n-      match(ClickHouseParser::MODIFY);\n-      setState(416);\n-      match(ClickHouseParser::COLUMN);\n-      setState(419);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {\n-      case 1: {\n-        setState(417);\n-        match(ClickHouseParser::IF);\n-        setState(418);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(421);\n-      nestedIdentifier();\n-      setState(422);\n-      match(ClickHouseParser::COMMENT);\n-      setState(423);\n-      match(ClickHouseParser::STRING_LITERAL);\n-      break;\n-    }\n-\n-    case 20: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseModifyRemoveContext>(_localctx));\n-      enterOuterAlt(_localctx, 20);\n-      setState(425);\n-      match(ClickHouseParser::MODIFY);\n-      setState(426);\n-      match(ClickHouseParser::COLUMN);\n-      setState(429);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {\n-      case 1: {\n-        setState(427);\n-        match(ClickHouseParser::IF);\n-        setState(428);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(431);\n-      nestedIdentifier();\n-      setState(432);\n-      match(ClickHouseParser::REMOVE);\n-      setState(433);\n-      tableColumnPropertyType();\n-      break;\n-    }\n-\n-    case 21: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseModifyContext>(_localctx));\n-      enterOuterAlt(_localctx, 21);\n-      setState(435);\n-      match(ClickHouseParser::MODIFY);\n-      setState(436);\n-      match(ClickHouseParser::COLUMN);\n-      setState(439);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {\n-      case 1: {\n-        setState(437);\n-        match(ClickHouseParser::IF);\n-        setState(438);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(441);\n-      tableColumnDfnt();\n-      break;\n-    }\n-\n-    case 22: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseModifyOrderByContext>(_localctx));\n-      enterOuterAlt(_localctx, 22);\n-      setState(442);\n-      match(ClickHouseParser::MODIFY);\n-      setState(443);\n-      match(ClickHouseParser::ORDER);\n-      setState(444);\n-      match(ClickHouseParser::BY);\n-      setState(445);\n-      columnExpr(0);\n-      break;\n-    }\n-\n-    case 23: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseModifyTTLContext>(_localctx));\n-      enterOuterAlt(_localctx, 23);\n-      setState(446);\n-      match(ClickHouseParser::MODIFY);\n-      setState(447);\n-      ttlClause();\n-      break;\n-    }\n-\n-    case 24: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseMovePartitionContext>(_localctx));\n-      enterOuterAlt(_localctx, 24);\n-      setState(448);\n-      match(ClickHouseParser::MOVE);\n-      setState(449);\n-      partitionClause();\n-      setState(459);\n-      _errHandler->sync(this);\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx)) {\n-      case 1: {\n-        setState(450);\n-        match(ClickHouseParser::TO);\n-        setState(451);\n-        match(ClickHouseParser::DISK);\n-        setState(452);\n-        match(ClickHouseParser::STRING_LITERAL);\n-        break;\n-      }\n-\n-      case 2: {\n-        setState(453);\n-        match(ClickHouseParser::TO);\n-        setState(454);\n-        match(ClickHouseParser::VOLUME);\n-        setState(455);\n-        match(ClickHouseParser::STRING_LITERAL);\n-        break;\n-      }\n-\n-      case 3: {\n-        setState(456);\n-        match(ClickHouseParser::TO);\n-        setState(457);\n-        match(ClickHouseParser::TABLE);\n-        setState(458);\n-        tableIdentifier();\n-        break;\n-      }\n-\n-      }\n-      break;\n-    }\n-\n-    case 25: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseRemoveTTLContext>(_localctx));\n-      enterOuterAlt(_localctx, 25);\n-      setState(461);\n-      match(ClickHouseParser::REMOVE);\n-      setState(462);\n-      match(ClickHouseParser::TTL);\n-      break;\n-    }\n-\n-    case 26: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseRenameContext>(_localctx));\n-      enterOuterAlt(_localctx, 26);\n-      setState(463);\n-      match(ClickHouseParser::RENAME);\n-      setState(464);\n-      match(ClickHouseParser::COLUMN);\n-      setState(467);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx)) {\n-      case 1: {\n-        setState(465);\n-        match(ClickHouseParser::IF);\n-        setState(466);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(469);\n-      nestedIdentifier();\n-      setState(470);\n-      match(ClickHouseParser::TO);\n-      setState(471);\n-      nestedIdentifier();\n-      break;\n-    }\n-\n-    case 27: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseReplaceContext>(_localctx));\n-      enterOuterAlt(_localctx, 27);\n-      setState(473);\n-      match(ClickHouseParser::REPLACE);\n-      setState(474);\n-      partitionClause();\n-      setState(475);\n-      match(ClickHouseParser::FROM);\n-      setState(476);\n-      tableIdentifier();\n-      break;\n-    }\n-\n-    case 28: {\n-      _localctx = dynamic_cast<AlterTableClauseContext *>(_tracker.createInstance<ClickHouseParser::AlterTableClauseUpdateContext>(_localctx));\n-      enterOuterAlt(_localctx, 28);\n-      setState(478);\n-      match(ClickHouseParser::UPDATE);\n-      setState(479);\n-      assignmentExprList();\n-      setState(480);\n-      whereClause();\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- AssignmentExprListContext ------------------------------------------------------------------\n-\n-ClickHouseParser::AssignmentExprListContext::AssignmentExprListContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-std::vector<ClickHouseParser::AssignmentExprContext *> ClickHouseParser::AssignmentExprListContext::assignmentExpr() {\n-  return getRuleContexts<ClickHouseParser::AssignmentExprContext>();\n-}\n-\n-ClickHouseParser::AssignmentExprContext* ClickHouseParser::AssignmentExprListContext::assignmentExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::AssignmentExprContext>(i);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::AssignmentExprListContext::COMMA() {\n-  return getTokens(ClickHouseParser::COMMA);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AssignmentExprListContext::COMMA(size_t i) {\n-  return getToken(ClickHouseParser::COMMA, i);\n-}\n-\n-\n-size_t ClickHouseParser::AssignmentExprListContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleAssignmentExprList;\n-}\n-\n-antlrcpp::Any ClickHouseParser::AssignmentExprListContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAssignmentExprList(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::AssignmentExprListContext* ClickHouseParser::assignmentExprList() {\n-  AssignmentExprListContext *_localctx = _tracker.createInstance<AssignmentExprListContext>(_ctx, getState());\n-  enterRule(_localctx, 8, ClickHouseParser::RuleAssignmentExprList);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(484);\n-    assignmentExpr();\n-    setState(489);\n-    _errHandler->sync(this);\n-    _la = _input->LA(1);\n-    while (_la == ClickHouseParser::COMMA) {\n-      setState(485);\n-      match(ClickHouseParser::COMMA);\n-      setState(486);\n-      assignmentExpr();\n-      setState(491);\n-      _errHandler->sync(this);\n-      _la = _input->LA(1);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- AssignmentExprContext ------------------------------------------------------------------\n-\n-ClickHouseParser::AssignmentExprContext::AssignmentExprContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::AssignmentExprContext::nestedIdentifier() {\n-  return getRuleContext<ClickHouseParser::NestedIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AssignmentExprContext::EQ_SINGLE() {\n-  return getToken(ClickHouseParser::EQ_SINGLE, 0);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::AssignmentExprContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::AssignmentExprContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleAssignmentExpr;\n-}\n-\n-antlrcpp::Any ClickHouseParser::AssignmentExprContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAssignmentExpr(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::AssignmentExprContext* ClickHouseParser::assignmentExpr() {\n-  AssignmentExprContext *_localctx = _tracker.createInstance<AssignmentExprContext>(_ctx, getState());\n-  enterRule(_localctx, 10, ClickHouseParser::RuleAssignmentExpr);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(492);\n-    nestedIdentifier();\n-    setState(493);\n-    match(ClickHouseParser::EQ_SINGLE);\n-    setState(494);\n-    columnExpr(0);\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- TableColumnPropertyTypeContext ------------------------------------------------------------------\n-\n-ClickHouseParser::TableColumnPropertyTypeContext::TableColumnPropertyTypeContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TableColumnPropertyTypeContext::ALIAS() {\n-  return getToken(ClickHouseParser::ALIAS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TableColumnPropertyTypeContext::CODEC() {\n-  return getToken(ClickHouseParser::CODEC, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TableColumnPropertyTypeContext::COMMENT() {\n-  return getToken(ClickHouseParser::COMMENT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TableColumnPropertyTypeContext::DEFAULT() {\n-  return getToken(ClickHouseParser::DEFAULT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TableColumnPropertyTypeContext::MATERIALIZED() {\n-  return getToken(ClickHouseParser::MATERIALIZED, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TableColumnPropertyTypeContext::TTL() {\n-  return getToken(ClickHouseParser::TTL, 0);\n-}\n-\n-\n-size_t ClickHouseParser::TableColumnPropertyTypeContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleTableColumnPropertyType;\n-}\n-\n-antlrcpp::Any ClickHouseParser::TableColumnPropertyTypeContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitTableColumnPropertyType(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::TableColumnPropertyTypeContext* ClickHouseParser::tableColumnPropertyType() {\n-  TableColumnPropertyTypeContext *_localctx = _tracker.createInstance<TableColumnPropertyTypeContext>(_ctx, getState());\n-  enterRule(_localctx, 12, ClickHouseParser::RuleTableColumnPropertyType);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(496);\n-    _la = _input->LA(1);\n-    if (!((((_la & ~ 0x3fULL) == 0) &&\n-      ((1ULL << _la) & ((1ULL << ClickHouseParser::ALIAS)\n-      | (1ULL << ClickHouseParser::CODEC)\n-      | (1ULL << ClickHouseParser::COMMENT)\n-      | (1ULL << ClickHouseParser::DEFAULT))) != 0) || _la == ClickHouseParser::MATERIALIZED || _la == ClickHouseParser::TTL)) {\n-    _errHandler->recoverInline(this);\n-    }\n-    else {\n-      _errHandler->reportMatch(this);\n-      consume();\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- PartitionClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::PartitionClauseContext::PartitionClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::PartitionClauseContext::PARTITION() {\n-  return getToken(ClickHouseParser::PARTITION, 0);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::PartitionClauseContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::PartitionClauseContext::ID() {\n-  return getToken(ClickHouseParser::ID, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::PartitionClauseContext::STRING_LITERAL() {\n-  return getToken(ClickHouseParser::STRING_LITERAL, 0);\n-}\n-\n-\n-size_t ClickHouseParser::PartitionClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RulePartitionClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::PartitionClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitPartitionClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::PartitionClauseContext* ClickHouseParser::partitionClause() {\n-  PartitionClauseContext *_localctx = _tracker.createInstance<PartitionClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 14, ClickHouseParser::RulePartitionClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(503);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx)) {\n-    case 1: {\n-      enterOuterAlt(_localctx, 1);\n-      setState(498);\n-      match(ClickHouseParser::PARTITION);\n-      setState(499);\n-      columnExpr(0);\n-      break;\n-    }\n-\n-    case 2: {\n-      enterOuterAlt(_localctx, 2);\n-      setState(500);\n-      match(ClickHouseParser::PARTITION);\n-      setState(501);\n-      match(ClickHouseParser::ID);\n-      setState(502);\n-      match(ClickHouseParser::STRING_LITERAL);\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- AttachStmtContext ------------------------------------------------------------------\n-\n-ClickHouseParser::AttachStmtContext::AttachStmtContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-\n-size_t ClickHouseParser::AttachStmtContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleAttachStmt;\n-}\n-\n-void ClickHouseParser::AttachStmtContext::copyFrom(AttachStmtContext *ctx) {\n-  ParserRuleContext::copyFrom(ctx);\n-}\n-\n-//----------------- AttachDictionaryStmtContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::AttachDictionaryStmtContext::ATTACH() {\n-  return getToken(ClickHouseParser::ATTACH, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AttachDictionaryStmtContext::DICTIONARY() {\n-  return getToken(ClickHouseParser::DICTIONARY, 0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::AttachDictionaryStmtContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::ClusterClauseContext* ClickHouseParser::AttachDictionaryStmtContext::clusterClause() {\n-  return getRuleContext<ClickHouseParser::ClusterClauseContext>(0);\n-}\n-\n-ClickHouseParser::AttachDictionaryStmtContext::AttachDictionaryStmtContext(AttachStmtContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::AttachDictionaryStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAttachDictionaryStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-ClickHouseParser::AttachStmtContext* ClickHouseParser::attachStmt() {\n-  AttachStmtContext *_localctx = _tracker.createInstance<AttachStmtContext>(_ctx, getState());\n-  enterRule(_localctx, 16, ClickHouseParser::RuleAttachStmt);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    _localctx = dynamic_cast<AttachStmtContext *>(_tracker.createInstance<ClickHouseParser::AttachDictionaryStmtContext>(_localctx));\n-    enterOuterAlt(_localctx, 1);\n-    setState(505);\n-    match(ClickHouseParser::ATTACH);\n-    setState(506);\n-    match(ClickHouseParser::DICTIONARY);\n-    setState(507);\n-    tableIdentifier();\n-    setState(509);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::ON) {\n-      setState(508);\n-      clusterClause();\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- CheckStmtContext ------------------------------------------------------------------\n-\n-ClickHouseParser::CheckStmtContext::CheckStmtContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CheckStmtContext::CHECK() {\n-  return getToken(ClickHouseParser::CHECK, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CheckStmtContext::TABLE() {\n-  return getToken(ClickHouseParser::TABLE, 0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::CheckStmtContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::PartitionClauseContext* ClickHouseParser::CheckStmtContext::partitionClause() {\n-  return getRuleContext<ClickHouseParser::PartitionClauseContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::CheckStmtContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleCheckStmt;\n-}\n-\n-antlrcpp::Any ClickHouseParser::CheckStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitCheckStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::CheckStmtContext* ClickHouseParser::checkStmt() {\n-  CheckStmtContext *_localctx = _tracker.createInstance<CheckStmtContext>(_ctx, getState());\n-  enterRule(_localctx, 18, ClickHouseParser::RuleCheckStmt);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(511);\n-    match(ClickHouseParser::CHECK);\n-    setState(512);\n-    match(ClickHouseParser::TABLE);\n-    setState(513);\n-    tableIdentifier();\n-    setState(515);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::PARTITION) {\n-      setState(514);\n-      partitionClause();\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- CreateStmtContext ------------------------------------------------------------------\n-\n-ClickHouseParser::CreateStmtContext::CreateStmtContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-\n-size_t ClickHouseParser::CreateStmtContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleCreateStmt;\n-}\n-\n-void ClickHouseParser::CreateStmtContext::copyFrom(CreateStmtContext *ctx) {\n-  ParserRuleContext::copyFrom(ctx);\n-}\n-\n-//----------------- CreateViewStmtContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::CreateViewStmtContext::VIEW() {\n-  return getToken(ClickHouseParser::VIEW, 0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::CreateViewStmtContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::SubqueryClauseContext* ClickHouseParser::CreateViewStmtContext::subqueryClause() {\n-  return getRuleContext<ClickHouseParser::SubqueryClauseContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateViewStmtContext::ATTACH() {\n-  return getToken(ClickHouseParser::ATTACH, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateViewStmtContext::CREATE() {\n-  return getToken(ClickHouseParser::CREATE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateViewStmtContext::OR() {\n-  return getToken(ClickHouseParser::OR, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateViewStmtContext::REPLACE() {\n-  return getToken(ClickHouseParser::REPLACE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateViewStmtContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateViewStmtContext::NOT() {\n-  return getToken(ClickHouseParser::NOT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateViewStmtContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-ClickHouseParser::UuidClauseContext* ClickHouseParser::CreateViewStmtContext::uuidClause() {\n-  return getRuleContext<ClickHouseParser::UuidClauseContext>(0);\n-}\n-\n-ClickHouseParser::ClusterClauseContext* ClickHouseParser::CreateViewStmtContext::clusterClause() {\n-  return getRuleContext<ClickHouseParser::ClusterClauseContext>(0);\n-}\n-\n-ClickHouseParser::TableSchemaClauseContext* ClickHouseParser::CreateViewStmtContext::tableSchemaClause() {\n-  return getRuleContext<ClickHouseParser::TableSchemaClauseContext>(0);\n-}\n-\n-ClickHouseParser::CreateViewStmtContext::CreateViewStmtContext(CreateStmtContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::CreateViewStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitCreateViewStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- CreateDictionaryStmtContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::CreateDictionaryStmtContext::DICTIONARY() {\n-  return getToken(ClickHouseParser::DICTIONARY, 0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::CreateDictionaryStmtContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::DictionarySchemaClauseContext* ClickHouseParser::CreateDictionaryStmtContext::dictionarySchemaClause() {\n-  return getRuleContext<ClickHouseParser::DictionarySchemaClauseContext>(0);\n-}\n-\n-ClickHouseParser::DictionaryEngineClauseContext* ClickHouseParser::CreateDictionaryStmtContext::dictionaryEngineClause() {\n-  return getRuleContext<ClickHouseParser::DictionaryEngineClauseContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateDictionaryStmtContext::ATTACH() {\n-  return getToken(ClickHouseParser::ATTACH, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateDictionaryStmtContext::CREATE() {\n-  return getToken(ClickHouseParser::CREATE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateDictionaryStmtContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateDictionaryStmtContext::NOT() {\n-  return getToken(ClickHouseParser::NOT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateDictionaryStmtContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-ClickHouseParser::UuidClauseContext* ClickHouseParser::CreateDictionaryStmtContext::uuidClause() {\n-  return getRuleContext<ClickHouseParser::UuidClauseContext>(0);\n-}\n-\n-ClickHouseParser::ClusterClauseContext* ClickHouseParser::CreateDictionaryStmtContext::clusterClause() {\n-  return getRuleContext<ClickHouseParser::ClusterClauseContext>(0);\n-}\n-\n-ClickHouseParser::CreateDictionaryStmtContext::CreateDictionaryStmtContext(CreateStmtContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::CreateDictionaryStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitCreateDictionaryStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- CreateDatabaseStmtContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::CreateDatabaseStmtContext::DATABASE() {\n-  return getToken(ClickHouseParser::DATABASE, 0);\n-}\n-\n-ClickHouseParser::DatabaseIdentifierContext* ClickHouseParser::CreateDatabaseStmtContext::databaseIdentifier() {\n-  return getRuleContext<ClickHouseParser::DatabaseIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateDatabaseStmtContext::ATTACH() {\n-  return getToken(ClickHouseParser::ATTACH, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateDatabaseStmtContext::CREATE() {\n-  return getToken(ClickHouseParser::CREATE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateDatabaseStmtContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateDatabaseStmtContext::NOT() {\n-  return getToken(ClickHouseParser::NOT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateDatabaseStmtContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-ClickHouseParser::ClusterClauseContext* ClickHouseParser::CreateDatabaseStmtContext::clusterClause() {\n-  return getRuleContext<ClickHouseParser::ClusterClauseContext>(0);\n-}\n-\n-ClickHouseParser::EngineExprContext* ClickHouseParser::CreateDatabaseStmtContext::engineExpr() {\n-  return getRuleContext<ClickHouseParser::EngineExprContext>(0);\n-}\n-\n-ClickHouseParser::CreateDatabaseStmtContext::CreateDatabaseStmtContext(CreateStmtContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::CreateDatabaseStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitCreateDatabaseStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- CreateLiveViewStmtContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::CreateLiveViewStmtContext::LIVE() {\n-  return getToken(ClickHouseParser::LIVE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateLiveViewStmtContext::VIEW() {\n-  return getToken(ClickHouseParser::VIEW, 0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::CreateLiveViewStmtContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::SubqueryClauseContext* ClickHouseParser::CreateLiveViewStmtContext::subqueryClause() {\n-  return getRuleContext<ClickHouseParser::SubqueryClauseContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateLiveViewStmtContext::ATTACH() {\n-  return getToken(ClickHouseParser::ATTACH, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateLiveViewStmtContext::CREATE() {\n-  return getToken(ClickHouseParser::CREATE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateLiveViewStmtContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateLiveViewStmtContext::NOT() {\n-  return getToken(ClickHouseParser::NOT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateLiveViewStmtContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-ClickHouseParser::UuidClauseContext* ClickHouseParser::CreateLiveViewStmtContext::uuidClause() {\n-  return getRuleContext<ClickHouseParser::UuidClauseContext>(0);\n-}\n-\n-ClickHouseParser::ClusterClauseContext* ClickHouseParser::CreateLiveViewStmtContext::clusterClause() {\n-  return getRuleContext<ClickHouseParser::ClusterClauseContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateLiveViewStmtContext::WITH() {\n-  return getToken(ClickHouseParser::WITH, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateLiveViewStmtContext::TIMEOUT() {\n-  return getToken(ClickHouseParser::TIMEOUT, 0);\n-}\n-\n-ClickHouseParser::DestinationClauseContext* ClickHouseParser::CreateLiveViewStmtContext::destinationClause() {\n-  return getRuleContext<ClickHouseParser::DestinationClauseContext>(0);\n-}\n-\n-ClickHouseParser::TableSchemaClauseContext* ClickHouseParser::CreateLiveViewStmtContext::tableSchemaClause() {\n-  return getRuleContext<ClickHouseParser::TableSchemaClauseContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateLiveViewStmtContext::DECIMAL_LITERAL() {\n-  return getToken(ClickHouseParser::DECIMAL_LITERAL, 0);\n-}\n-\n-ClickHouseParser::CreateLiveViewStmtContext::CreateLiveViewStmtContext(CreateStmtContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::CreateLiveViewStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitCreateLiveViewStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- CreateMaterializedViewStmtContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::CreateMaterializedViewStmtContext::MATERIALIZED() {\n-  return getToken(ClickHouseParser::MATERIALIZED, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateMaterializedViewStmtContext::VIEW() {\n-  return getToken(ClickHouseParser::VIEW, 0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::CreateMaterializedViewStmtContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::SubqueryClauseContext* ClickHouseParser::CreateMaterializedViewStmtContext::subqueryClause() {\n-  return getRuleContext<ClickHouseParser::SubqueryClauseContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateMaterializedViewStmtContext::ATTACH() {\n-  return getToken(ClickHouseParser::ATTACH, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateMaterializedViewStmtContext::CREATE() {\n-  return getToken(ClickHouseParser::CREATE, 0);\n-}\n-\n-ClickHouseParser::DestinationClauseContext* ClickHouseParser::CreateMaterializedViewStmtContext::destinationClause() {\n-  return getRuleContext<ClickHouseParser::DestinationClauseContext>(0);\n-}\n-\n-ClickHouseParser::EngineClauseContext* ClickHouseParser::CreateMaterializedViewStmtContext::engineClause() {\n-  return getRuleContext<ClickHouseParser::EngineClauseContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateMaterializedViewStmtContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateMaterializedViewStmtContext::NOT() {\n-  return getToken(ClickHouseParser::NOT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateMaterializedViewStmtContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-ClickHouseParser::UuidClauseContext* ClickHouseParser::CreateMaterializedViewStmtContext::uuidClause() {\n-  return getRuleContext<ClickHouseParser::UuidClauseContext>(0);\n-}\n-\n-ClickHouseParser::ClusterClauseContext* ClickHouseParser::CreateMaterializedViewStmtContext::clusterClause() {\n-  return getRuleContext<ClickHouseParser::ClusterClauseContext>(0);\n-}\n-\n-ClickHouseParser::TableSchemaClauseContext* ClickHouseParser::CreateMaterializedViewStmtContext::tableSchemaClause() {\n-  return getRuleContext<ClickHouseParser::TableSchemaClauseContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateMaterializedViewStmtContext::POPULATE() {\n-  return getToken(ClickHouseParser::POPULATE, 0);\n-}\n-\n-ClickHouseParser::CreateMaterializedViewStmtContext::CreateMaterializedViewStmtContext(CreateStmtContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::CreateMaterializedViewStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitCreateMaterializedViewStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- CreateTableStmtContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::CreateTableStmtContext::TABLE() {\n-  return getToken(ClickHouseParser::TABLE, 0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::CreateTableStmtContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateTableStmtContext::ATTACH() {\n-  return getToken(ClickHouseParser::ATTACH, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateTableStmtContext::CREATE() {\n-  return getToken(ClickHouseParser::CREATE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateTableStmtContext::TEMPORARY() {\n-  return getToken(ClickHouseParser::TEMPORARY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateTableStmtContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateTableStmtContext::NOT() {\n-  return getToken(ClickHouseParser::NOT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CreateTableStmtContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-ClickHouseParser::UuidClauseContext* ClickHouseParser::CreateTableStmtContext::uuidClause() {\n-  return getRuleContext<ClickHouseParser::UuidClauseContext>(0);\n-}\n-\n-ClickHouseParser::ClusterClauseContext* ClickHouseParser::CreateTableStmtContext::clusterClause() {\n-  return getRuleContext<ClickHouseParser::ClusterClauseContext>(0);\n-}\n-\n-ClickHouseParser::TableSchemaClauseContext* ClickHouseParser::CreateTableStmtContext::tableSchemaClause() {\n-  return getRuleContext<ClickHouseParser::TableSchemaClauseContext>(0);\n-}\n-\n-ClickHouseParser::EngineClauseContext* ClickHouseParser::CreateTableStmtContext::engineClause() {\n-  return getRuleContext<ClickHouseParser::EngineClauseContext>(0);\n-}\n-\n-ClickHouseParser::SubqueryClauseContext* ClickHouseParser::CreateTableStmtContext::subqueryClause() {\n-  return getRuleContext<ClickHouseParser::SubqueryClauseContext>(0);\n-}\n-\n-ClickHouseParser::CreateTableStmtContext::CreateTableStmtContext(CreateStmtContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::CreateTableStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitCreateTableStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-ClickHouseParser::CreateStmtContext* ClickHouseParser::createStmt() {\n-  CreateStmtContext *_localctx = _tracker.createInstance<CreateStmtContext>(_ctx, getState());\n-  enterRule(_localctx, 20, ClickHouseParser::RuleCreateStmt);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(654);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx)) {\n-    case 1: {\n-      _localctx = dynamic_cast<CreateStmtContext *>(_tracker.createInstance<ClickHouseParser::CreateDatabaseStmtContext>(_localctx));\n-      enterOuterAlt(_localctx, 1);\n-      setState(517);\n-      _la = _input->LA(1);\n-      if (!(_la == ClickHouseParser::ATTACH\n-\n-      || _la == ClickHouseParser::CREATE)) {\n-      _errHandler->recoverInline(this);\n-      }\n-      else {\n-        _errHandler->reportMatch(this);\n-        consume();\n-      }\n-      setState(518);\n-      match(ClickHouseParser::DATABASE);\n-      setState(522);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {\n-      case 1: {\n-        setState(519);\n-        match(ClickHouseParser::IF);\n-        setState(520);\n-        match(ClickHouseParser::NOT);\n-        setState(521);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(524);\n-      databaseIdentifier();\n-      setState(526);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::ON) {\n-        setState(525);\n-        clusterClause();\n-      }\n-      setState(529);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::ENGINE) {\n-        setState(528);\n-        engineExpr();\n-      }\n-      break;\n-    }\n-\n-    case 2: {\n-      _localctx = dynamic_cast<CreateStmtContext *>(_tracker.createInstance<ClickHouseParser::CreateDictionaryStmtContext>(_localctx));\n-      enterOuterAlt(_localctx, 2);\n-      setState(531);\n-      _la = _input->LA(1);\n-      if (!(_la == ClickHouseParser::ATTACH\n-\n-      || _la == ClickHouseParser::CREATE)) {\n-      _errHandler->recoverInline(this);\n-      }\n-      else {\n-        _errHandler->reportMatch(this);\n-        consume();\n-      }\n-      setState(532);\n-      match(ClickHouseParser::DICTIONARY);\n-      setState(536);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {\n-      case 1: {\n-        setState(533);\n-        match(ClickHouseParser::IF);\n-        setState(534);\n-        match(ClickHouseParser::NOT);\n-        setState(535);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(538);\n-      tableIdentifier();\n-      setState(540);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::UUID) {\n-        setState(539);\n-        uuidClause();\n-      }\n-      setState(543);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::ON) {\n-        setState(542);\n-        clusterClause();\n-      }\n-      setState(545);\n-      dictionarySchemaClause();\n-      setState(546);\n-      dictionaryEngineClause();\n-      break;\n-    }\n-\n-    case 3: {\n-      _localctx = dynamic_cast<CreateStmtContext *>(_tracker.createInstance<ClickHouseParser::CreateLiveViewStmtContext>(_localctx));\n-      enterOuterAlt(_localctx, 3);\n-      setState(548);\n-      _la = _input->LA(1);\n-      if (!(_la == ClickHouseParser::ATTACH\n-\n-      || _la == ClickHouseParser::CREATE)) {\n-      _errHandler->recoverInline(this);\n-      }\n-      else {\n-        _errHandler->reportMatch(this);\n-        consume();\n-      }\n-      setState(549);\n-      match(ClickHouseParser::LIVE);\n-      setState(550);\n-      match(ClickHouseParser::VIEW);\n-      setState(554);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx)) {\n-      case 1: {\n-        setState(551);\n-        match(ClickHouseParser::IF);\n-        setState(552);\n-        match(ClickHouseParser::NOT);\n-        setState(553);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(556);\n-      tableIdentifier();\n-      setState(558);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::UUID) {\n-        setState(557);\n-        uuidClause();\n-      }\n-      setState(561);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::ON) {\n-        setState(560);\n-        clusterClause();\n-      }\n-      setState(568);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::WITH) {\n-        setState(563);\n-        match(ClickHouseParser::WITH);\n-        setState(564);\n-        match(ClickHouseParser::TIMEOUT);\n-        setState(566);\n-        _errHandler->sync(this);\n-\n-        _la = _input->LA(1);\n-        if (_la == ClickHouseParser::DECIMAL_LITERAL) {\n-          setState(565);\n-          match(ClickHouseParser::DECIMAL_LITERAL);\n-        }\n-      }\n-      setState(571);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::TO) {\n-        setState(570);\n-        destinationClause();\n-      }\n-      setState(574);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx)) {\n-      case 1: {\n-        setState(573);\n-        tableSchemaClause();\n-        break;\n-      }\n-\n-      }\n-      setState(576);\n-      subqueryClause();\n-      break;\n-    }\n-\n-    case 4: {\n-      _localctx = dynamic_cast<CreateStmtContext *>(_tracker.createInstance<ClickHouseParser::CreateMaterializedViewStmtContext>(_localctx));\n-      enterOuterAlt(_localctx, 4);\n-      setState(578);\n-      _la = _input->LA(1);\n-      if (!(_la == ClickHouseParser::ATTACH\n-\n-      || _la == ClickHouseParser::CREATE)) {\n-      _errHandler->recoverInline(this);\n-      }\n-      else {\n-        _errHandler->reportMatch(this);\n-        consume();\n-      }\n-      setState(579);\n-      match(ClickHouseParser::MATERIALIZED);\n-      setState(580);\n-      match(ClickHouseParser::VIEW);\n-      setState(584);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx)) {\n-      case 1: {\n-        setState(581);\n-        match(ClickHouseParser::IF);\n-        setState(582);\n-        match(ClickHouseParser::NOT);\n-        setState(583);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(586);\n-      tableIdentifier();\n-      setState(588);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::UUID) {\n-        setState(587);\n-        uuidClause();\n-      }\n-      setState(591);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::ON) {\n-        setState(590);\n-        clusterClause();\n-      }\n-      setState(594);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::AS || _la == ClickHouseParser::LPAREN) {\n-        setState(593);\n-        tableSchemaClause();\n-      }\n-      setState(601);\n-      _errHandler->sync(this);\n-      switch (_input->LA(1)) {\n-        case ClickHouseParser::TO: {\n-          setState(596);\n-          destinationClause();\n-          break;\n-        }\n-\n-        case ClickHouseParser::ENGINE: {\n-          setState(597);\n-          engineClause();\n-          setState(599);\n-          _errHandler->sync(this);\n-\n-          _la = _input->LA(1);\n-          if (_la == ClickHouseParser::POPULATE) {\n-            setState(598);\n-            match(ClickHouseParser::POPULATE);\n-          }\n-          break;\n-        }\n-\n-      default:\n-        throw NoViableAltException(this);\n-      }\n-      setState(603);\n-      subqueryClause();\n-      break;\n-    }\n-\n-    case 5: {\n-      _localctx = dynamic_cast<CreateStmtContext *>(_tracker.createInstance<ClickHouseParser::CreateTableStmtContext>(_localctx));\n-      enterOuterAlt(_localctx, 5);\n-      setState(605);\n-      _la = _input->LA(1);\n-      if (!(_la == ClickHouseParser::ATTACH\n-\n-      || _la == ClickHouseParser::CREATE)) {\n-      _errHandler->recoverInline(this);\n-      }\n-      else {\n-        _errHandler->reportMatch(this);\n-        consume();\n-      }\n-      setState(607);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::TEMPORARY) {\n-        setState(606);\n-        match(ClickHouseParser::TEMPORARY);\n-      }\n-      setState(609);\n-      match(ClickHouseParser::TABLE);\n-      setState(613);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx)) {\n-      case 1: {\n-        setState(610);\n-        match(ClickHouseParser::IF);\n-        setState(611);\n-        match(ClickHouseParser::NOT);\n-        setState(612);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(615);\n-      tableIdentifier();\n-      setState(617);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::UUID) {\n-        setState(616);\n-        uuidClause();\n-      }\n-      setState(620);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::ON) {\n-        setState(619);\n-        clusterClause();\n-      }\n-      setState(623);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx)) {\n-      case 1: {\n-        setState(622);\n-        tableSchemaClause();\n-        break;\n-      }\n-\n-      }\n-      setState(626);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::ENGINE) {\n-        setState(625);\n-        engineClause();\n-      }\n-      setState(629);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::AS) {\n-        setState(628);\n-        subqueryClause();\n-      }\n-      break;\n-    }\n-\n-    case 6: {\n-      _localctx = dynamic_cast<CreateStmtContext *>(_tracker.createInstance<ClickHouseParser::CreateViewStmtContext>(_localctx));\n-      enterOuterAlt(_localctx, 6);\n-      setState(631);\n-      _la = _input->LA(1);\n-      if (!(_la == ClickHouseParser::ATTACH\n-\n-      || _la == ClickHouseParser::CREATE)) {\n-      _errHandler->recoverInline(this);\n-      }\n-      else {\n-        _errHandler->reportMatch(this);\n-        consume();\n-      }\n-      setState(634);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::OR) {\n-        setState(632);\n-        match(ClickHouseParser::OR);\n-        setState(633);\n-        match(ClickHouseParser::REPLACE);\n-      }\n-      setState(636);\n-      match(ClickHouseParser::VIEW);\n-      setState(640);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx)) {\n-      case 1: {\n-        setState(637);\n-        match(ClickHouseParser::IF);\n-        setState(638);\n-        match(ClickHouseParser::NOT);\n-        setState(639);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(642);\n-      tableIdentifier();\n-      setState(644);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::UUID) {\n-        setState(643);\n-        uuidClause();\n-      }\n-      setState(647);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::ON) {\n-        setState(646);\n-        clusterClause();\n-      }\n-      setState(650);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx)) {\n-      case 1: {\n-        setState(649);\n-        tableSchemaClause();\n-        break;\n-      }\n-\n-      }\n-      setState(652);\n-      subqueryClause();\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- DictionarySchemaClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::DictionarySchemaClauseContext::DictionarySchemaClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DictionarySchemaClauseContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-std::vector<ClickHouseParser::DictionaryAttrDfntContext *> ClickHouseParser::DictionarySchemaClauseContext::dictionaryAttrDfnt() {\n-  return getRuleContexts<ClickHouseParser::DictionaryAttrDfntContext>();\n-}\n-\n-ClickHouseParser::DictionaryAttrDfntContext* ClickHouseParser::DictionarySchemaClauseContext::dictionaryAttrDfnt(size_t i) {\n-  return getRuleContext<ClickHouseParser::DictionaryAttrDfntContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DictionarySchemaClauseContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::DictionarySchemaClauseContext::COMMA() {\n-  return getTokens(ClickHouseParser::COMMA);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DictionarySchemaClauseContext::COMMA(size_t i) {\n-  return getToken(ClickHouseParser::COMMA, i);\n-}\n-\n-\n-size_t ClickHouseParser::DictionarySchemaClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleDictionarySchemaClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::DictionarySchemaClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitDictionarySchemaClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::DictionarySchemaClauseContext* ClickHouseParser::dictionarySchemaClause() {\n-  DictionarySchemaClauseContext *_localctx = _tracker.createInstance<DictionarySchemaClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 22, ClickHouseParser::RuleDictionarySchemaClause);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(656);\n-    match(ClickHouseParser::LPAREN);\n-    setState(657);\n-    dictionaryAttrDfnt();\n-    setState(662);\n-    _errHandler->sync(this);\n-    _la = _input->LA(1);\n-    while (_la == ClickHouseParser::COMMA) {\n-      setState(658);\n-      match(ClickHouseParser::COMMA);\n-      setState(659);\n-      dictionaryAttrDfnt();\n-      setState(664);\n-      _errHandler->sync(this);\n-      _la = _input->LA(1);\n-    }\n-    setState(665);\n-    match(ClickHouseParser::RPAREN);\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- DictionaryAttrDfntContext ------------------------------------------------------------------\n-\n-ClickHouseParser::DictionaryAttrDfntContext::DictionaryAttrDfntContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::DictionaryAttrDfntContext::identifier() {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(0);\n-}\n-\n-ClickHouseParser::ColumnTypeExprContext* ClickHouseParser::DictionaryAttrDfntContext::columnTypeExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnTypeExprContext>(0);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::DictionaryAttrDfntContext::DEFAULT() {\n-  return getTokens(ClickHouseParser::DEFAULT);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DictionaryAttrDfntContext::DEFAULT(size_t i) {\n-  return getToken(ClickHouseParser::DEFAULT, i);\n-}\n-\n-std::vector<ClickHouseParser::LiteralContext *> ClickHouseParser::DictionaryAttrDfntContext::literal() {\n-  return getRuleContexts<ClickHouseParser::LiteralContext>();\n-}\n-\n-ClickHouseParser::LiteralContext* ClickHouseParser::DictionaryAttrDfntContext::literal(size_t i) {\n-  return getRuleContext<ClickHouseParser::LiteralContext>(i);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::DictionaryAttrDfntContext::EXPRESSION() {\n-  return getTokens(ClickHouseParser::EXPRESSION);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DictionaryAttrDfntContext::EXPRESSION(size_t i) {\n-  return getToken(ClickHouseParser::EXPRESSION, i);\n-}\n-\n-std::vector<ClickHouseParser::ColumnExprContext *> ClickHouseParser::DictionaryAttrDfntContext::columnExpr() {\n-  return getRuleContexts<ClickHouseParser::ColumnExprContext>();\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::DictionaryAttrDfntContext::columnExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(i);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::DictionaryAttrDfntContext::HIERARCHICAL() {\n-  return getTokens(ClickHouseParser::HIERARCHICAL);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DictionaryAttrDfntContext::HIERARCHICAL(size_t i) {\n-  return getToken(ClickHouseParser::HIERARCHICAL, i);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::DictionaryAttrDfntContext::INJECTIVE() {\n-  return getTokens(ClickHouseParser::INJECTIVE);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DictionaryAttrDfntContext::INJECTIVE(size_t i) {\n-  return getToken(ClickHouseParser::INJECTIVE, i);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::DictionaryAttrDfntContext::IS_OBJECT_ID() {\n-  return getTokens(ClickHouseParser::IS_OBJECT_ID);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DictionaryAttrDfntContext::IS_OBJECT_ID(size_t i) {\n-  return getToken(ClickHouseParser::IS_OBJECT_ID, i);\n-}\n-\n-\n-size_t ClickHouseParser::DictionaryAttrDfntContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleDictionaryAttrDfnt;\n-}\n-\n-antlrcpp::Any ClickHouseParser::DictionaryAttrDfntContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitDictionaryAttrDfnt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::DictionaryAttrDfntContext* ClickHouseParser::dictionaryAttrDfnt() {\n-  DictionaryAttrDfntContext *_localctx = _tracker.createInstance<DictionaryAttrDfntContext>(_ctx, getState());\n-  enterRule(_localctx, 24, ClickHouseParser::RuleDictionaryAttrDfnt);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    size_t alt;\n-    enterOuterAlt(_localctx, 1);\n-    setState(667);\n-    identifier();\n-    setState(668);\n-    columnTypeExpr();\n-    setState(690);\n-    _errHandler->sync(this);\n-    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx);\n-    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {\n-      if (alt == 1) {\n-        setState(688);\n-        _errHandler->sync(this);\n-        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx)) {\n-        case 1: {\n-          setState(669);\n-\n-          if (!(!_localctx->attrs.count(\"default\"))) throw FailedPredicateException(this, \"!$attrs.count(\\\"default\\\")\");\n-          setState(670);\n-          match(ClickHouseParser::DEFAULT);\n-          setState(671);\n-          literal();\n-          _localctx->attrs.insert(\"default\");\n-          break;\n-        }\n-\n-        case 2: {\n-          setState(674);\n-\n-          if (!(!_localctx->attrs.count(\"expression\"))) throw FailedPredicateException(this, \"!$attrs.count(\\\"expression\\\")\");\n-          setState(675);\n-          match(ClickHouseParser::EXPRESSION);\n-          setState(676);\n-          columnExpr(0);\n-          _localctx->attrs.insert(\"expression\");\n-          break;\n-        }\n-\n-        case 3: {\n-          setState(679);\n-\n-          if (!(!_localctx->attrs.count(\"hierarchical\"))) throw FailedPredicateException(this, \"!$attrs.count(\\\"hierarchical\\\")\");\n-          setState(680);\n-          match(ClickHouseParser::HIERARCHICAL);\n-          _localctx->attrs.insert(\"hierarchical\");\n-          break;\n-        }\n-\n-        case 4: {\n-          setState(682);\n-\n-          if (!(!_localctx->attrs.count(\"injective\"))) throw FailedPredicateException(this, \"!$attrs.count(\\\"injective\\\")\");\n-          setState(683);\n-          match(ClickHouseParser::INJECTIVE);\n-          _localctx->attrs.insert(\"injective\");\n-          break;\n-        }\n-\n-        case 5: {\n-          setState(685);\n-\n-          if (!(!_localctx->attrs.count(\"is_object_id\"))) throw FailedPredicateException(this, \"!$attrs.count(\\\"is_object_id\\\")\");\n-          setState(686);\n-          match(ClickHouseParser::IS_OBJECT_ID);\n-          _localctx->attrs.insert(\"is_object_id\");\n-          break;\n-        }\n-\n-        } \n-      }\n-      setState(692);\n-      _errHandler->sync(this);\n-      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- DictionaryEngineClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::DictionaryEngineClauseContext::DictionaryEngineClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::DictionaryPrimaryKeyClauseContext* ClickHouseParser::DictionaryEngineClauseContext::dictionaryPrimaryKeyClause() {\n-  return getRuleContext<ClickHouseParser::DictionaryPrimaryKeyClauseContext>(0);\n-}\n-\n-std::vector<ClickHouseParser::SourceClauseContext *> ClickHouseParser::DictionaryEngineClauseContext::sourceClause() {\n-  return getRuleContexts<ClickHouseParser::SourceClauseContext>();\n-}\n-\n-ClickHouseParser::SourceClauseContext* ClickHouseParser::DictionaryEngineClauseContext::sourceClause(size_t i) {\n-  return getRuleContext<ClickHouseParser::SourceClauseContext>(i);\n-}\n-\n-std::vector<ClickHouseParser::LifetimeClauseContext *> ClickHouseParser::DictionaryEngineClauseContext::lifetimeClause() {\n-  return getRuleContexts<ClickHouseParser::LifetimeClauseContext>();\n-}\n-\n-ClickHouseParser::LifetimeClauseContext* ClickHouseParser::DictionaryEngineClauseContext::lifetimeClause(size_t i) {\n-  return getRuleContext<ClickHouseParser::LifetimeClauseContext>(i);\n-}\n-\n-std::vector<ClickHouseParser::LayoutClauseContext *> ClickHouseParser::DictionaryEngineClauseContext::layoutClause() {\n-  return getRuleContexts<ClickHouseParser::LayoutClauseContext>();\n-}\n-\n-ClickHouseParser::LayoutClauseContext* ClickHouseParser::DictionaryEngineClauseContext::layoutClause(size_t i) {\n-  return getRuleContext<ClickHouseParser::LayoutClauseContext>(i);\n-}\n-\n-std::vector<ClickHouseParser::RangeClauseContext *> ClickHouseParser::DictionaryEngineClauseContext::rangeClause() {\n-  return getRuleContexts<ClickHouseParser::RangeClauseContext>();\n-}\n-\n-ClickHouseParser::RangeClauseContext* ClickHouseParser::DictionaryEngineClauseContext::rangeClause(size_t i) {\n-  return getRuleContext<ClickHouseParser::RangeClauseContext>(i);\n-}\n-\n-std::vector<ClickHouseParser::DictionarySettingsClauseContext *> ClickHouseParser::DictionaryEngineClauseContext::dictionarySettingsClause() {\n-  return getRuleContexts<ClickHouseParser::DictionarySettingsClauseContext>();\n-}\n-\n-ClickHouseParser::DictionarySettingsClauseContext* ClickHouseParser::DictionaryEngineClauseContext::dictionarySettingsClause(size_t i) {\n-  return getRuleContext<ClickHouseParser::DictionarySettingsClauseContext>(i);\n-}\n-\n-\n-size_t ClickHouseParser::DictionaryEngineClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleDictionaryEngineClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::DictionaryEngineClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitDictionaryEngineClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::DictionaryEngineClauseContext* ClickHouseParser::dictionaryEngineClause() {\n-  DictionaryEngineClauseContext *_localctx = _tracker.createInstance<DictionaryEngineClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 26, ClickHouseParser::RuleDictionaryEngineClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    size_t alt;\n-    enterOuterAlt(_localctx, 1);\n-    setState(694);\n-    _errHandler->sync(this);\n-\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {\n-    case 1: {\n-      setState(693);\n-      dictionaryPrimaryKeyClause();\n-      break;\n-    }\n-\n-    }\n-    setState(718);\n-    _errHandler->sync(this);\n-    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx);\n-    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {\n-      if (alt == 1) {\n-        setState(716);\n-        _errHandler->sync(this);\n-        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx)) {\n-        case 1: {\n-          setState(696);\n-\n-          if (!(!_localctx->clauses.count(\"source\"))) throw FailedPredicateException(this, \"!$clauses.count(\\\"source\\\")\");\n-          setState(697);\n-          sourceClause();\n-          _localctx->clauses.insert(\"source\");\n-          break;\n-        }\n-\n-        case 2: {\n-          setState(700);\n-\n-          if (!(!_localctx->clauses.count(\"lifetime\"))) throw FailedPredicateException(this, \"!$clauses.count(\\\"lifetime\\\")\");\n-          setState(701);\n-          lifetimeClause();\n-          _localctx->clauses.insert(\"lifetime\");\n-          break;\n-        }\n-\n-        case 3: {\n-          setState(704);\n-\n-          if (!(!_localctx->clauses.count(\"layout\"))) throw FailedPredicateException(this, \"!$clauses.count(\\\"layout\\\")\");\n-          setState(705);\n-          layoutClause();\n-          _localctx->clauses.insert(\"layout\");\n-          break;\n-        }\n-\n-        case 4: {\n-          setState(708);\n-\n-          if (!(!_localctx->clauses.count(\"range\"))) throw FailedPredicateException(this, \"!$clauses.count(\\\"range\\\")\");\n-          setState(709);\n-          rangeClause();\n-          _localctx->clauses.insert(\"range\");\n-          break;\n-        }\n-\n-        case 5: {\n-          setState(712);\n-\n-          if (!(!_localctx->clauses.count(\"settings\"))) throw FailedPredicateException(this, \"!$clauses.count(\\\"settings\\\")\");\n-          setState(713);\n-          dictionarySettingsClause();\n-          _localctx->clauses.insert(\"settings\");\n-          break;\n-        }\n-\n-        } \n-      }\n-      setState(720);\n-      _errHandler->sync(this);\n-      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- DictionaryPrimaryKeyClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::DictionaryPrimaryKeyClauseContext::DictionaryPrimaryKeyClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DictionaryPrimaryKeyClauseContext::PRIMARY() {\n-  return getToken(ClickHouseParser::PRIMARY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DictionaryPrimaryKeyClauseContext::KEY() {\n-  return getToken(ClickHouseParser::KEY, 0);\n-}\n-\n-ClickHouseParser::ColumnExprListContext* ClickHouseParser::DictionaryPrimaryKeyClauseContext::columnExprList() {\n-  return getRuleContext<ClickHouseParser::ColumnExprListContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::DictionaryPrimaryKeyClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleDictionaryPrimaryKeyClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::DictionaryPrimaryKeyClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitDictionaryPrimaryKeyClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::DictionaryPrimaryKeyClauseContext* ClickHouseParser::dictionaryPrimaryKeyClause() {\n-  DictionaryPrimaryKeyClauseContext *_localctx = _tracker.createInstance<DictionaryPrimaryKeyClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 28, ClickHouseParser::RuleDictionaryPrimaryKeyClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(721);\n-    match(ClickHouseParser::PRIMARY);\n-    setState(722);\n-    match(ClickHouseParser::KEY);\n-    setState(723);\n-    columnExprList();\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- DictionaryArgExprContext ------------------------------------------------------------------\n-\n-ClickHouseParser::DictionaryArgExprContext::DictionaryArgExprContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-std::vector<ClickHouseParser::IdentifierContext *> ClickHouseParser::DictionaryArgExprContext::identifier() {\n-  return getRuleContexts<ClickHouseParser::IdentifierContext>();\n-}\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::DictionaryArgExprContext::identifier(size_t i) {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(i);\n-}\n-\n-ClickHouseParser::LiteralContext* ClickHouseParser::DictionaryArgExprContext::literal() {\n-  return getRuleContext<ClickHouseParser::LiteralContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DictionaryArgExprContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DictionaryArgExprContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-\n-size_t ClickHouseParser::DictionaryArgExprContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleDictionaryArgExpr;\n-}\n-\n-antlrcpp::Any ClickHouseParser::DictionaryArgExprContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitDictionaryArgExpr(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::DictionaryArgExprContext* ClickHouseParser::dictionaryArgExpr() {\n-  DictionaryArgExprContext *_localctx = _tracker.createInstance<DictionaryArgExprContext>(_ctx, getState());\n-  enterRule(_localctx, 30, ClickHouseParser::RuleDictionaryArgExpr);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(725);\n-    identifier();\n-    setState(732);\n-    _errHandler->sync(this);\n-    switch (_input->LA(1)) {\n-      case ClickHouseParser::AFTER:\n-      case ClickHouseParser::ALIAS:\n-      case ClickHouseParser::ALL:\n-      case ClickHouseParser::ALTER:\n-      case ClickHouseParser::AND:\n-      case ClickHouseParser::ANTI:\n-      case ClickHouseParser::ANY:\n-      case ClickHouseParser::ARRAY:\n-      case ClickHouseParser::AS:\n-      case ClickHouseParser::ASCENDING:\n-      case ClickHouseParser::ASOF:\n-      case ClickHouseParser::AST:\n-      case ClickHouseParser::ASYNC:\n-      case ClickHouseParser::ATTACH:\n-      case ClickHouseParser::BETWEEN:\n-      case ClickHouseParser::BOTH:\n-      case ClickHouseParser::BY:\n-      case ClickHouseParser::CASE:\n-      case ClickHouseParser::CAST:\n-      case ClickHouseParser::CHECK:\n-      case ClickHouseParser::CLEAR:\n-      case ClickHouseParser::CLUSTER:\n-      case ClickHouseParser::CODEC:\n-      case ClickHouseParser::COLLATE:\n-      case ClickHouseParser::COLUMN:\n-      case ClickHouseParser::COMMENT:\n-      case ClickHouseParser::CONSTRAINT:\n-      case ClickHouseParser::CREATE:\n-      case ClickHouseParser::CROSS:\n-      case ClickHouseParser::CUBE:\n-      case ClickHouseParser::DATABASE:\n-      case ClickHouseParser::DATABASES:\n-      case ClickHouseParser::DATE:\n-      case ClickHouseParser::DAY:\n-      case ClickHouseParser::DEDUPLICATE:\n-      case ClickHouseParser::DEFAULT:\n-      case ClickHouseParser::DELAY:\n-      case ClickHouseParser::DELETE:\n-      case ClickHouseParser::DESC:\n-      case ClickHouseParser::DESCENDING:\n-      case ClickHouseParser::DESCRIBE:\n-      case ClickHouseParser::DETACH:\n-      case ClickHouseParser::DICTIONARIES:\n-      case ClickHouseParser::DICTIONARY:\n-      case ClickHouseParser::DISK:\n-      case ClickHouseParser::DISTINCT:\n-      case ClickHouseParser::DISTRIBUTED:\n-      case ClickHouseParser::DROP:\n-      case ClickHouseParser::ELSE:\n-      case ClickHouseParser::END:\n-      case ClickHouseParser::ENGINE:\n-      case ClickHouseParser::EVENTS:\n-      case ClickHouseParser::EXISTS:\n-      case ClickHouseParser::EXPLAIN:\n-      case ClickHouseParser::EXPRESSION:\n-      case ClickHouseParser::EXTRACT:\n-      case ClickHouseParser::FETCHES:\n-      case ClickHouseParser::FINAL:\n-      case ClickHouseParser::FIRST:\n-      case ClickHouseParser::FLUSH:\n-      case ClickHouseParser::FOR:\n-      case ClickHouseParser::FORMAT:\n-      case ClickHouseParser::FREEZE:\n-      case ClickHouseParser::FROM:\n-      case ClickHouseParser::FULL:\n-      case ClickHouseParser::FUNCTION:\n-      case ClickHouseParser::GLOBAL:\n-      case ClickHouseParser::GRANULARITY:\n-      case ClickHouseParser::GROUP:\n-      case ClickHouseParser::HAVING:\n-      case ClickHouseParser::HIERARCHICAL:\n-      case ClickHouseParser::HOUR:\n-      case ClickHouseParser::ID:\n-      case ClickHouseParser::IF:\n-      case ClickHouseParser::ILIKE:\n-      case ClickHouseParser::IN:\n-      case ClickHouseParser::INDEX:\n-      case ClickHouseParser::INJECTIVE:\n-      case ClickHouseParser::INNER:\n-      case ClickHouseParser::INSERT:\n-      case ClickHouseParser::INTERVAL:\n-      case ClickHouseParser::INTO:\n-      case ClickHouseParser::IS:\n-      case ClickHouseParser::IS_OBJECT_ID:\n-      case ClickHouseParser::JOIN:\n-      case ClickHouseParser::KEY:\n-      case ClickHouseParser::KILL:\n-      case ClickHouseParser::LAST:\n-      case ClickHouseParser::LAYOUT:\n-      case ClickHouseParser::LEADING:\n-      case ClickHouseParser::LEFT:\n-      case ClickHouseParser::LIFETIME:\n-      case ClickHouseParser::LIKE:\n-      case ClickHouseParser::LIMIT:\n-      case ClickHouseParser::LIVE:\n-      case ClickHouseParser::LOCAL:\n-      case ClickHouseParser::LOGS:\n-      case ClickHouseParser::MATERIALIZE:\n-      case ClickHouseParser::MATERIALIZED:\n-      case ClickHouseParser::MAX:\n-      case ClickHouseParser::MERGES:\n-      case ClickHouseParser::MIN:\n-      case ClickHouseParser::MINUTE:\n-      case ClickHouseParser::MODIFY:\n-      case ClickHouseParser::MONTH:\n-      case ClickHouseParser::MOVE:\n-      case ClickHouseParser::MUTATION:\n-      case ClickHouseParser::NO:\n-      case ClickHouseParser::NOT:\n-      case ClickHouseParser::NULLS:\n-      case ClickHouseParser::OFFSET:\n-      case ClickHouseParser::ON:\n-      case ClickHouseParser::OPTIMIZE:\n-      case ClickHouseParser::OR:\n-      case ClickHouseParser::ORDER:\n-      case ClickHouseParser::OUTER:\n-      case ClickHouseParser::OUTFILE:\n-      case ClickHouseParser::PARTITION:\n-      case ClickHouseParser::POPULATE:\n-      case ClickHouseParser::PREWHERE:\n-      case ClickHouseParser::PRIMARY:\n-      case ClickHouseParser::QUARTER:\n-      case ClickHouseParser::RANGE:\n-      case ClickHouseParser::RELOAD:\n-      case ClickHouseParser::REMOVE:\n-      case ClickHouseParser::RENAME:\n-      case ClickHouseParser::REPLACE:\n-      case ClickHouseParser::REPLICA:\n-      case ClickHouseParser::REPLICATED:\n-      case ClickHouseParser::RIGHT:\n-      case ClickHouseParser::ROLLUP:\n-      case ClickHouseParser::SAMPLE:\n-      case ClickHouseParser::SECOND:\n-      case ClickHouseParser::SELECT:\n-      case ClickHouseParser::SEMI:\n-      case ClickHouseParser::SENDS:\n-      case ClickHouseParser::SET:\n-      case ClickHouseParser::SETTINGS:\n-      case ClickHouseParser::SHOW:\n-      case ClickHouseParser::SOURCE:\n-      case ClickHouseParser::START:\n-      case ClickHouseParser::STOP:\n-      case ClickHouseParser::SUBSTRING:\n-      case ClickHouseParser::SYNC:\n-      case ClickHouseParser::SYNTAX:\n-      case ClickHouseParser::SYSTEM:\n-      case ClickHouseParser::TABLE:\n-      case ClickHouseParser::TABLES:\n-      case ClickHouseParser::TEMPORARY:\n-      case ClickHouseParser::TEST:\n-      case ClickHouseParser::THEN:\n-      case ClickHouseParser::TIES:\n-      case ClickHouseParser::TIMEOUT:\n-      case ClickHouseParser::TIMESTAMP:\n-      case ClickHouseParser::TO:\n-      case ClickHouseParser::TOP:\n-      case ClickHouseParser::TOTALS:\n-      case ClickHouseParser::TRAILING:\n-      case ClickHouseParser::TRIM:\n-      case ClickHouseParser::TRUNCATE:\n-      case ClickHouseParser::TTL:\n-      case ClickHouseParser::TYPE:\n-      case ClickHouseParser::UNION:\n-      case ClickHouseParser::UPDATE:\n-      case ClickHouseParser::USE:\n-      case ClickHouseParser::USING:\n-      case ClickHouseParser::UUID:\n-      case ClickHouseParser::VALUES:\n-      case ClickHouseParser::VIEW:\n-      case ClickHouseParser::VOLUME:\n-      case ClickHouseParser::WATCH:\n-      case ClickHouseParser::WEEK:\n-      case ClickHouseParser::WHEN:\n-      case ClickHouseParser::WHERE:\n-      case ClickHouseParser::WITH:\n-      case ClickHouseParser::YEAR:\n-      case ClickHouseParser::JSON_FALSE:\n-      case ClickHouseParser::JSON_TRUE:\n-      case ClickHouseParser::IDENTIFIER: {\n-        setState(726);\n-        identifier();\n-        setState(729);\n-        _errHandler->sync(this);\n-\n-        _la = _input->LA(1);\n-        if (_la == ClickHouseParser::LPAREN) {\n-          setState(727);\n-          match(ClickHouseParser::LPAREN);\n-          setState(728);\n-          match(ClickHouseParser::RPAREN);\n-        }\n-        break;\n-      }\n-\n-      case ClickHouseParser::INF:\n-      case ClickHouseParser::NAN_SQL:\n-      case ClickHouseParser::NULL_SQL:\n-      case ClickHouseParser::FLOATING_LITERAL:\n-      case ClickHouseParser::OCTAL_LITERAL:\n-      case ClickHouseParser::DECIMAL_LITERAL:\n-      case ClickHouseParser::HEXADECIMAL_LITERAL:\n-      case ClickHouseParser::STRING_LITERAL:\n-      case ClickHouseParser::DASH:\n-      case ClickHouseParser::DOT:\n-      case ClickHouseParser::PLUS: {\n-        setState(731);\n-        literal();\n-        break;\n-      }\n-\n-    default:\n-      throw NoViableAltException(this);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- SourceClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::SourceClauseContext::SourceClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SourceClauseContext::SOURCE() {\n-  return getToken(ClickHouseParser::SOURCE, 0);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::SourceClauseContext::LPAREN() {\n-  return getTokens(ClickHouseParser::LPAREN);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SourceClauseContext::LPAREN(size_t i) {\n-  return getToken(ClickHouseParser::LPAREN, i);\n-}\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::SourceClauseContext::identifier() {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(0);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::SourceClauseContext::RPAREN() {\n-  return getTokens(ClickHouseParser::RPAREN);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SourceClauseContext::RPAREN(size_t i) {\n-  return getToken(ClickHouseParser::RPAREN, i);\n-}\n-\n-std::vector<ClickHouseParser::DictionaryArgExprContext *> ClickHouseParser::SourceClauseContext::dictionaryArgExpr() {\n-  return getRuleContexts<ClickHouseParser::DictionaryArgExprContext>();\n-}\n-\n-ClickHouseParser::DictionaryArgExprContext* ClickHouseParser::SourceClauseContext::dictionaryArgExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::DictionaryArgExprContext>(i);\n-}\n-\n-\n-size_t ClickHouseParser::SourceClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleSourceClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::SourceClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitSourceClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::SourceClauseContext* ClickHouseParser::sourceClause() {\n-  SourceClauseContext *_localctx = _tracker.createInstance<SourceClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 32, ClickHouseParser::RuleSourceClause);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(734);\n-    match(ClickHouseParser::SOURCE);\n-    setState(735);\n-    match(ClickHouseParser::LPAREN);\n-    setState(736);\n-    identifier();\n-    setState(737);\n-    match(ClickHouseParser::LPAREN);\n-    setState(741);\n-    _errHandler->sync(this);\n-    _la = _input->LA(1);\n-    while ((((_la & ~ 0x3fULL) == 0) &&\n-      ((1ULL << _la) & ((1ULL << ClickHouseParser::AFTER)\n-      | (1ULL << ClickHouseParser::ALIAS)\n-      | (1ULL << ClickHouseParser::ALL)\n-      | (1ULL << ClickHouseParser::ALTER)\n-      | (1ULL << ClickHouseParser::AND)\n-      | (1ULL << ClickHouseParser::ANTI)\n-      | (1ULL << ClickHouseParser::ANY)\n-      | (1ULL << ClickHouseParser::ARRAY)\n-      | (1ULL << ClickHouseParser::AS)\n-      | (1ULL << ClickHouseParser::ASCENDING)\n-      | (1ULL << ClickHouseParser::ASOF)\n-      | (1ULL << ClickHouseParser::AST)\n-      | (1ULL << ClickHouseParser::ASYNC)\n-      | (1ULL << ClickHouseParser::ATTACH)\n-      | (1ULL << ClickHouseParser::BETWEEN)\n-      | (1ULL << ClickHouseParser::BOTH)\n-      | (1ULL << ClickHouseParser::BY)\n-      | (1ULL << ClickHouseParser::CASE)\n-      | (1ULL << ClickHouseParser::CAST)\n-      | (1ULL << ClickHouseParser::CHECK)\n-      | (1ULL << ClickHouseParser::CLEAR)\n-      | (1ULL << ClickHouseParser::CLUSTER)\n-      | (1ULL << ClickHouseParser::CODEC)\n-      | (1ULL << ClickHouseParser::COLLATE)\n-      | (1ULL << ClickHouseParser::COLUMN)\n-      | (1ULL << ClickHouseParser::COMMENT)\n-      | (1ULL << ClickHouseParser::CONSTRAINT)\n-      | (1ULL << ClickHouseParser::CREATE)\n-      | (1ULL << ClickHouseParser::CROSS)\n-      | (1ULL << ClickHouseParser::CUBE)\n-      | (1ULL << ClickHouseParser::DATABASE)\n-      | (1ULL << ClickHouseParser::DATABASES)\n-      | (1ULL << ClickHouseParser::DATE)\n-      | (1ULL << ClickHouseParser::DAY)\n-      | (1ULL << ClickHouseParser::DEDUPLICATE)\n-      | (1ULL << ClickHouseParser::DEFAULT)\n-      | (1ULL << ClickHouseParser::DELAY)\n-      | (1ULL << ClickHouseParser::DELETE)\n-      | (1ULL << ClickHouseParser::DESC)\n-      | (1ULL << ClickHouseParser::DESCENDING)\n-      | (1ULL << ClickHouseParser::DESCRIBE)\n-      | (1ULL << ClickHouseParser::DETACH)\n-      | (1ULL << ClickHouseParser::DICTIONARIES)\n-      | (1ULL << ClickHouseParser::DICTIONARY)\n-      | (1ULL << ClickHouseParser::DISK)\n-      | (1ULL << ClickHouseParser::DISTINCT)\n-      | (1ULL << ClickHouseParser::DISTRIBUTED)\n-      | (1ULL << ClickHouseParser::DROP)\n-      | (1ULL << ClickHouseParser::ELSE)\n-      | (1ULL << ClickHouseParser::END)\n-      | (1ULL << ClickHouseParser::ENGINE)\n-      | (1ULL << ClickHouseParser::EVENTS)\n-      | (1ULL << ClickHouseParser::EXISTS)\n-      | (1ULL << ClickHouseParser::EXPLAIN)\n-      | (1ULL << ClickHouseParser::EXPRESSION)\n-      | (1ULL << ClickHouseParser::EXTRACT)\n-      | (1ULL << ClickHouseParser::FETCHES)\n-      | (1ULL << ClickHouseParser::FINAL)\n-      | (1ULL << ClickHouseParser::FIRST)\n-      | (1ULL << ClickHouseParser::FLUSH)\n-      | (1ULL << ClickHouseParser::FOR)\n-      | (1ULL << ClickHouseParser::FORMAT))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&\n-      ((1ULL << (_la - 64)) & ((1ULL << (ClickHouseParser::FREEZE - 64))\n-      | (1ULL << (ClickHouseParser::FROM - 64))\n-      | (1ULL << (ClickHouseParser::FULL - 64))\n-      | (1ULL << (ClickHouseParser::FUNCTION - 64))\n-      | (1ULL << (ClickHouseParser::GLOBAL - 64))\n-      | (1ULL << (ClickHouseParser::GRANULARITY - 64))\n-      | (1ULL << (ClickHouseParser::GROUP - 64))\n-      | (1ULL << (ClickHouseParser::HAVING - 64))\n-      | (1ULL << (ClickHouseParser::HIERARCHICAL - 64))\n-      | (1ULL << (ClickHouseParser::HOUR - 64))\n-      | (1ULL << (ClickHouseParser::ID - 64))\n-      | (1ULL << (ClickHouseParser::IF - 64))\n-      | (1ULL << (ClickHouseParser::ILIKE - 64))\n-      | (1ULL << (ClickHouseParser::IN - 64))\n-      | (1ULL << (ClickHouseParser::INDEX - 64))\n-      | (1ULL << (ClickHouseParser::INJECTIVE - 64))\n-      | (1ULL << (ClickHouseParser::INNER - 64))\n-      | (1ULL << (ClickHouseParser::INSERT - 64))\n-      | (1ULL << (ClickHouseParser::INTERVAL - 64))\n-      | (1ULL << (ClickHouseParser::INTO - 64))\n-      | (1ULL << (ClickHouseParser::IS - 64))\n-      | (1ULL << (ClickHouseParser::IS_OBJECT_ID - 64))\n-      | (1ULL << (ClickHouseParser::JOIN - 64))\n-      | (1ULL << (ClickHouseParser::KEY - 64))\n-      | (1ULL << (ClickHouseParser::KILL - 64))\n-      | (1ULL << (ClickHouseParser::LAST - 64))\n-      | (1ULL << (ClickHouseParser::LAYOUT - 64))\n-      | (1ULL << (ClickHouseParser::LEADING - 64))\n-      | (1ULL << (ClickHouseParser::LEFT - 64))\n-      | (1ULL << (ClickHouseParser::LIFETIME - 64))\n-      | (1ULL << (ClickHouseParser::LIKE - 64))\n-      | (1ULL << (ClickHouseParser::LIMIT - 64))\n-      | (1ULL << (ClickHouseParser::LIVE - 64))\n-      | (1ULL << (ClickHouseParser::LOCAL - 64))\n-      | (1ULL << (ClickHouseParser::LOGS - 64))\n-      | (1ULL << (ClickHouseParser::MATERIALIZE - 64))\n-      | (1ULL << (ClickHouseParser::MATERIALIZED - 64))\n-      | (1ULL << (ClickHouseParser::MAX - 64))\n-      | (1ULL << (ClickHouseParser::MERGES - 64))\n-      | (1ULL << (ClickHouseParser::MIN - 64))\n-      | (1ULL << (ClickHouseParser::MINUTE - 64))\n-      | (1ULL << (ClickHouseParser::MODIFY - 64))\n-      | (1ULL << (ClickHouseParser::MONTH - 64))\n-      | (1ULL << (ClickHouseParser::MOVE - 64))\n-      | (1ULL << (ClickHouseParser::MUTATION - 64))\n-      | (1ULL << (ClickHouseParser::NO - 64))\n-      | (1ULL << (ClickHouseParser::NOT - 64))\n-      | (1ULL << (ClickHouseParser::NULLS - 64))\n-      | (1ULL << (ClickHouseParser::OFFSET - 64))\n-      | (1ULL << (ClickHouseParser::ON - 64))\n-      | (1ULL << (ClickHouseParser::OPTIMIZE - 64))\n-      | (1ULL << (ClickHouseParser::OR - 64))\n-      | (1ULL << (ClickHouseParser::ORDER - 64))\n-      | (1ULL << (ClickHouseParser::OUTER - 64))\n-      | (1ULL << (ClickHouseParser::OUTFILE - 64))\n-      | (1ULL << (ClickHouseParser::PARTITION - 64))\n-      | (1ULL << (ClickHouseParser::POPULATE - 64))\n-      | (1ULL << (ClickHouseParser::PREWHERE - 64))\n-      | (1ULL << (ClickHouseParser::PRIMARY - 64))\n-      | (1ULL << (ClickHouseParser::QUARTER - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&\n-      ((1ULL << (_la - 128)) & ((1ULL << (ClickHouseParser::RANGE - 128))\n-      | (1ULL << (ClickHouseParser::RELOAD - 128))\n-      | (1ULL << (ClickHouseParser::REMOVE - 128))\n-      | (1ULL << (ClickHouseParser::RENAME - 128))\n-      | (1ULL << (ClickHouseParser::REPLACE - 128))\n-      | (1ULL << (ClickHouseParser::REPLICA - 128))\n-      | (1ULL << (ClickHouseParser::REPLICATED - 128))\n-      | (1ULL << (ClickHouseParser::RIGHT - 128))\n-      | (1ULL << (ClickHouseParser::ROLLUP - 128))\n-      | (1ULL << (ClickHouseParser::SAMPLE - 128))\n-      | (1ULL << (ClickHouseParser::SECOND - 128))\n-      | (1ULL << (ClickHouseParser::SELECT - 128))\n-      | (1ULL << (ClickHouseParser::SEMI - 128))\n-      | (1ULL << (ClickHouseParser::SENDS - 128))\n-      | (1ULL << (ClickHouseParser::SET - 128))\n-      | (1ULL << (ClickHouseParser::SETTINGS - 128))\n-      | (1ULL << (ClickHouseParser::SHOW - 128))\n-      | (1ULL << (ClickHouseParser::SOURCE - 128))\n-      | (1ULL << (ClickHouseParser::START - 128))\n-      | (1ULL << (ClickHouseParser::STOP - 128))\n-      | (1ULL << (ClickHouseParser::SUBSTRING - 128))\n-      | (1ULL << (ClickHouseParser::SYNC - 128))\n-      | (1ULL << (ClickHouseParser::SYNTAX - 128))\n-      | (1ULL << (ClickHouseParser::SYSTEM - 128))\n-      | (1ULL << (ClickHouseParser::TABLE - 128))\n-      | (1ULL << (ClickHouseParser::TABLES - 128))\n-      | (1ULL << (ClickHouseParser::TEMPORARY - 128))\n-      | (1ULL << (ClickHouseParser::TEST - 128))\n-      | (1ULL << (ClickHouseParser::THEN - 128))\n-      | (1ULL << (ClickHouseParser::TIES - 128))\n-      | (1ULL << (ClickHouseParser::TIMEOUT - 128))\n-      | (1ULL << (ClickHouseParser::TIMESTAMP - 128))\n-      | (1ULL << (ClickHouseParser::TO - 128))\n-      | (1ULL << (ClickHouseParser::TOP - 128))\n-      | (1ULL << (ClickHouseParser::TOTALS - 128))\n-      | (1ULL << (ClickHouseParser::TRAILING - 128))\n-      | (1ULL << (ClickHouseParser::TRIM - 128))\n-      | (1ULL << (ClickHouseParser::TRUNCATE - 128))\n-      | (1ULL << (ClickHouseParser::TTL - 128))\n-      | (1ULL << (ClickHouseParser::TYPE - 128))\n-      | (1ULL << (ClickHouseParser::UNION - 128))\n-      | (1ULL << (ClickHouseParser::UPDATE - 128))\n-      | (1ULL << (ClickHouseParser::USE - 128))\n-      | (1ULL << (ClickHouseParser::USING - 128))\n-      | (1ULL << (ClickHouseParser::UUID - 128))\n-      | (1ULL << (ClickHouseParser::VALUES - 128))\n-      | (1ULL << (ClickHouseParser::VIEW - 128))\n-      | (1ULL << (ClickHouseParser::VOLUME - 128))\n-      | (1ULL << (ClickHouseParser::WATCH - 128))\n-      | (1ULL << (ClickHouseParser::WEEK - 128))\n-      | (1ULL << (ClickHouseParser::WHEN - 128))\n-      | (1ULL << (ClickHouseParser::WHERE - 128))\n-      | (1ULL << (ClickHouseParser::WITH - 128))\n-      | (1ULL << (ClickHouseParser::YEAR - 128))\n-      | (1ULL << (ClickHouseParser::JSON_FALSE - 128))\n-      | (1ULL << (ClickHouseParser::JSON_TRUE - 128))\n-      | (1ULL << (ClickHouseParser::IDENTIFIER - 128)))) != 0)) {\n-      setState(738);\n-      dictionaryArgExpr();\n-      setState(743);\n-      _errHandler->sync(this);\n-      _la = _input->LA(1);\n-    }\n-    setState(744);\n-    match(ClickHouseParser::RPAREN);\n-    setState(745);\n-    match(ClickHouseParser::RPAREN);\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- LifetimeClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::LifetimeClauseContext::LifetimeClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::LifetimeClauseContext::LIFETIME() {\n-  return getToken(ClickHouseParser::LIFETIME, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::LifetimeClauseContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::LifetimeClauseContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::LifetimeClauseContext::DECIMAL_LITERAL() {\n-  return getTokens(ClickHouseParser::DECIMAL_LITERAL);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::LifetimeClauseContext::DECIMAL_LITERAL(size_t i) {\n-  return getToken(ClickHouseParser::DECIMAL_LITERAL, i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::LifetimeClauseContext::MIN() {\n-  return getToken(ClickHouseParser::MIN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::LifetimeClauseContext::MAX() {\n-  return getToken(ClickHouseParser::MAX, 0);\n-}\n-\n-\n-size_t ClickHouseParser::LifetimeClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleLifetimeClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::LifetimeClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitLifetimeClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::LifetimeClauseContext* ClickHouseParser::lifetimeClause() {\n-  LifetimeClauseContext *_localctx = _tracker.createInstance<LifetimeClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 34, ClickHouseParser::RuleLifetimeClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(747);\n-    match(ClickHouseParser::LIFETIME);\n-    setState(748);\n-    match(ClickHouseParser::LPAREN);\n-    setState(758);\n-    _errHandler->sync(this);\n-    switch (_input->LA(1)) {\n-      case ClickHouseParser::DECIMAL_LITERAL: {\n-        setState(749);\n-        match(ClickHouseParser::DECIMAL_LITERAL);\n-        break;\n-      }\n-\n-      case ClickHouseParser::MIN: {\n-        setState(750);\n-        match(ClickHouseParser::MIN);\n-        setState(751);\n-        match(ClickHouseParser::DECIMAL_LITERAL);\n-        setState(752);\n-        match(ClickHouseParser::MAX);\n-        setState(753);\n-        match(ClickHouseParser::DECIMAL_LITERAL);\n-        break;\n-      }\n-\n-      case ClickHouseParser::MAX: {\n-        setState(754);\n-        match(ClickHouseParser::MAX);\n-        setState(755);\n-        match(ClickHouseParser::DECIMAL_LITERAL);\n-        setState(756);\n-        match(ClickHouseParser::MIN);\n-        setState(757);\n-        match(ClickHouseParser::DECIMAL_LITERAL);\n-        break;\n-      }\n-\n-    default:\n-      throw NoViableAltException(this);\n-    }\n-    setState(760);\n-    match(ClickHouseParser::RPAREN);\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- LayoutClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::LayoutClauseContext::LayoutClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::LayoutClauseContext::LAYOUT() {\n-  return getToken(ClickHouseParser::LAYOUT, 0);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::LayoutClauseContext::LPAREN() {\n-  return getTokens(ClickHouseParser::LPAREN);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::LayoutClauseContext::LPAREN(size_t i) {\n-  return getToken(ClickHouseParser::LPAREN, i);\n-}\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::LayoutClauseContext::identifier() {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(0);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::LayoutClauseContext::RPAREN() {\n-  return getTokens(ClickHouseParser::RPAREN);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::LayoutClauseContext::RPAREN(size_t i) {\n-  return getToken(ClickHouseParser::RPAREN, i);\n-}\n-\n-std::vector<ClickHouseParser::DictionaryArgExprContext *> ClickHouseParser::LayoutClauseContext::dictionaryArgExpr() {\n-  return getRuleContexts<ClickHouseParser::DictionaryArgExprContext>();\n-}\n-\n-ClickHouseParser::DictionaryArgExprContext* ClickHouseParser::LayoutClauseContext::dictionaryArgExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::DictionaryArgExprContext>(i);\n-}\n-\n-\n-size_t ClickHouseParser::LayoutClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleLayoutClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::LayoutClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitLayoutClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::LayoutClauseContext* ClickHouseParser::layoutClause() {\n-  LayoutClauseContext *_localctx = _tracker.createInstance<LayoutClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 36, ClickHouseParser::RuleLayoutClause);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(762);\n-    match(ClickHouseParser::LAYOUT);\n-    setState(763);\n-    match(ClickHouseParser::LPAREN);\n-    setState(764);\n-    identifier();\n-    setState(765);\n-    match(ClickHouseParser::LPAREN);\n-    setState(769);\n-    _errHandler->sync(this);\n-    _la = _input->LA(1);\n-    while ((((_la & ~ 0x3fULL) == 0) &&\n-      ((1ULL << _la) & ((1ULL << ClickHouseParser::AFTER)\n-      | (1ULL << ClickHouseParser::ALIAS)\n-      | (1ULL << ClickHouseParser::ALL)\n-      | (1ULL << ClickHouseParser::ALTER)\n-      | (1ULL << ClickHouseParser::AND)\n-      | (1ULL << ClickHouseParser::ANTI)\n-      | (1ULL << ClickHouseParser::ANY)\n-      | (1ULL << ClickHouseParser::ARRAY)\n-      | (1ULL << ClickHouseParser::AS)\n-      | (1ULL << ClickHouseParser::ASCENDING)\n-      | (1ULL << ClickHouseParser::ASOF)\n-      | (1ULL << ClickHouseParser::AST)\n-      | (1ULL << ClickHouseParser::ASYNC)\n-      | (1ULL << ClickHouseParser::ATTACH)\n-      | (1ULL << ClickHouseParser::BETWEEN)\n-      | (1ULL << ClickHouseParser::BOTH)\n-      | (1ULL << ClickHouseParser::BY)\n-      | (1ULL << ClickHouseParser::CASE)\n-      | (1ULL << ClickHouseParser::CAST)\n-      | (1ULL << ClickHouseParser::CHECK)\n-      | (1ULL << ClickHouseParser::CLEAR)\n-      | (1ULL << ClickHouseParser::CLUSTER)\n-      | (1ULL << ClickHouseParser::CODEC)\n-      | (1ULL << ClickHouseParser::COLLATE)\n-      | (1ULL << ClickHouseParser::COLUMN)\n-      | (1ULL << ClickHouseParser::COMMENT)\n-      | (1ULL << ClickHouseParser::CONSTRAINT)\n-      | (1ULL << ClickHouseParser::CREATE)\n-      | (1ULL << ClickHouseParser::CROSS)\n-      | (1ULL << ClickHouseParser::CUBE)\n-      | (1ULL << ClickHouseParser::DATABASE)\n-      | (1ULL << ClickHouseParser::DATABASES)\n-      | (1ULL << ClickHouseParser::DATE)\n-      | (1ULL << ClickHouseParser::DAY)\n-      | (1ULL << ClickHouseParser::DEDUPLICATE)\n-      | (1ULL << ClickHouseParser::DEFAULT)\n-      | (1ULL << ClickHouseParser::DELAY)\n-      | (1ULL << ClickHouseParser::DELETE)\n-      | (1ULL << ClickHouseParser::DESC)\n-      | (1ULL << ClickHouseParser::DESCENDING)\n-      | (1ULL << ClickHouseParser::DESCRIBE)\n-      | (1ULL << ClickHouseParser::DETACH)\n-      | (1ULL << ClickHouseParser::DICTIONARIES)\n-      | (1ULL << ClickHouseParser::DICTIONARY)\n-      | (1ULL << ClickHouseParser::DISK)\n-      | (1ULL << ClickHouseParser::DISTINCT)\n-      | (1ULL << ClickHouseParser::DISTRIBUTED)\n-      | (1ULL << ClickHouseParser::DROP)\n-      | (1ULL << ClickHouseParser::ELSE)\n-      | (1ULL << ClickHouseParser::END)\n-      | (1ULL << ClickHouseParser::ENGINE)\n-      | (1ULL << ClickHouseParser::EVENTS)\n-      | (1ULL << ClickHouseParser::EXISTS)\n-      | (1ULL << ClickHouseParser::EXPLAIN)\n-      | (1ULL << ClickHouseParser::EXPRESSION)\n-      | (1ULL << ClickHouseParser::EXTRACT)\n-      | (1ULL << ClickHouseParser::FETCHES)\n-      | (1ULL << ClickHouseParser::FINAL)\n-      | (1ULL << ClickHouseParser::FIRST)\n-      | (1ULL << ClickHouseParser::FLUSH)\n-      | (1ULL << ClickHouseParser::FOR)\n-      | (1ULL << ClickHouseParser::FORMAT))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&\n-      ((1ULL << (_la - 64)) & ((1ULL << (ClickHouseParser::FREEZE - 64))\n-      | (1ULL << (ClickHouseParser::FROM - 64))\n-      | (1ULL << (ClickHouseParser::FULL - 64))\n-      | (1ULL << (ClickHouseParser::FUNCTION - 64))\n-      | (1ULL << (ClickHouseParser::GLOBAL - 64))\n-      | (1ULL << (ClickHouseParser::GRANULARITY - 64))\n-      | (1ULL << (ClickHouseParser::GROUP - 64))\n-      | (1ULL << (ClickHouseParser::HAVING - 64))\n-      | (1ULL << (ClickHouseParser::HIERARCHICAL - 64))\n-      | (1ULL << (ClickHouseParser::HOUR - 64))\n-      | (1ULL << (ClickHouseParser::ID - 64))\n-      | (1ULL << (ClickHouseParser::IF - 64))\n-      | (1ULL << (ClickHouseParser::ILIKE - 64))\n-      | (1ULL << (ClickHouseParser::IN - 64))\n-      | (1ULL << (ClickHouseParser::INDEX - 64))\n-      | (1ULL << (ClickHouseParser::INJECTIVE - 64))\n-      | (1ULL << (ClickHouseParser::INNER - 64))\n-      | (1ULL << (ClickHouseParser::INSERT - 64))\n-      | (1ULL << (ClickHouseParser::INTERVAL - 64))\n-      | (1ULL << (ClickHouseParser::INTO - 64))\n-      | (1ULL << (ClickHouseParser::IS - 64))\n-      | (1ULL << (ClickHouseParser::IS_OBJECT_ID - 64))\n-      | (1ULL << (ClickHouseParser::JOIN - 64))\n-      | (1ULL << (ClickHouseParser::KEY - 64))\n-      | (1ULL << (ClickHouseParser::KILL - 64))\n-      | (1ULL << (ClickHouseParser::LAST - 64))\n-      | (1ULL << (ClickHouseParser::LAYOUT - 64))\n-      | (1ULL << (ClickHouseParser::LEADING - 64))\n-      | (1ULL << (ClickHouseParser::LEFT - 64))\n-      | (1ULL << (ClickHouseParser::LIFETIME - 64))\n-      | (1ULL << (ClickHouseParser::LIKE - 64))\n-      | (1ULL << (ClickHouseParser::LIMIT - 64))\n-      | (1ULL << (ClickHouseParser::LIVE - 64))\n-      | (1ULL << (ClickHouseParser::LOCAL - 64))\n-      | (1ULL << (ClickHouseParser::LOGS - 64))\n-      | (1ULL << (ClickHouseParser::MATERIALIZE - 64))\n-      | (1ULL << (ClickHouseParser::MATERIALIZED - 64))\n-      | (1ULL << (ClickHouseParser::MAX - 64))\n-      | (1ULL << (ClickHouseParser::MERGES - 64))\n-      | (1ULL << (ClickHouseParser::MIN - 64))\n-      | (1ULL << (ClickHouseParser::MINUTE - 64))\n-      | (1ULL << (ClickHouseParser::MODIFY - 64))\n-      | (1ULL << (ClickHouseParser::MONTH - 64))\n-      | (1ULL << (ClickHouseParser::MOVE - 64))\n-      | (1ULL << (ClickHouseParser::MUTATION - 64))\n-      | (1ULL << (ClickHouseParser::NO - 64))\n-      | (1ULL << (ClickHouseParser::NOT - 64))\n-      | (1ULL << (ClickHouseParser::NULLS - 64))\n-      | (1ULL << (ClickHouseParser::OFFSET - 64))\n-      | (1ULL << (ClickHouseParser::ON - 64))\n-      | (1ULL << (ClickHouseParser::OPTIMIZE - 64))\n-      | (1ULL << (ClickHouseParser::OR - 64))\n-      | (1ULL << (ClickHouseParser::ORDER - 64))\n-      | (1ULL << (ClickHouseParser::OUTER - 64))\n-      | (1ULL << (ClickHouseParser::OUTFILE - 64))\n-      | (1ULL << (ClickHouseParser::PARTITION - 64))\n-      | (1ULL << (ClickHouseParser::POPULATE - 64))\n-      | (1ULL << (ClickHouseParser::PREWHERE - 64))\n-      | (1ULL << (ClickHouseParser::PRIMARY - 64))\n-      | (1ULL << (ClickHouseParser::QUARTER - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&\n-      ((1ULL << (_la - 128)) & ((1ULL << (ClickHouseParser::RANGE - 128))\n-      | (1ULL << (ClickHouseParser::RELOAD - 128))\n-      | (1ULL << (ClickHouseParser::REMOVE - 128))\n-      | (1ULL << (ClickHouseParser::RENAME - 128))\n-      | (1ULL << (ClickHouseParser::REPLACE - 128))\n-      | (1ULL << (ClickHouseParser::REPLICA - 128))\n-      | (1ULL << (ClickHouseParser::REPLICATED - 128))\n-      | (1ULL << (ClickHouseParser::RIGHT - 128))\n-      | (1ULL << (ClickHouseParser::ROLLUP - 128))\n-      | (1ULL << (ClickHouseParser::SAMPLE - 128))\n-      | (1ULL << (ClickHouseParser::SECOND - 128))\n-      | (1ULL << (ClickHouseParser::SELECT - 128))\n-      | (1ULL << (ClickHouseParser::SEMI - 128))\n-      | (1ULL << (ClickHouseParser::SENDS - 128))\n-      | (1ULL << (ClickHouseParser::SET - 128))\n-      | (1ULL << (ClickHouseParser::SETTINGS - 128))\n-      | (1ULL << (ClickHouseParser::SHOW - 128))\n-      | (1ULL << (ClickHouseParser::SOURCE - 128))\n-      | (1ULL << (ClickHouseParser::START - 128))\n-      | (1ULL << (ClickHouseParser::STOP - 128))\n-      | (1ULL << (ClickHouseParser::SUBSTRING - 128))\n-      | (1ULL << (ClickHouseParser::SYNC - 128))\n-      | (1ULL << (ClickHouseParser::SYNTAX - 128))\n-      | (1ULL << (ClickHouseParser::SYSTEM - 128))\n-      | (1ULL << (ClickHouseParser::TABLE - 128))\n-      | (1ULL << (ClickHouseParser::TABLES - 128))\n-      | (1ULL << (ClickHouseParser::TEMPORARY - 128))\n-      | (1ULL << (ClickHouseParser::TEST - 128))\n-      | (1ULL << (ClickHouseParser::THEN - 128))\n-      | (1ULL << (ClickHouseParser::TIES - 128))\n-      | (1ULL << (ClickHouseParser::TIMEOUT - 128))\n-      | (1ULL << (ClickHouseParser::TIMESTAMP - 128))\n-      | (1ULL << (ClickHouseParser::TO - 128))\n-      | (1ULL << (ClickHouseParser::TOP - 128))\n-      | (1ULL << (ClickHouseParser::TOTALS - 128))\n-      | (1ULL << (ClickHouseParser::TRAILING - 128))\n-      | (1ULL << (ClickHouseParser::TRIM - 128))\n-      | (1ULL << (ClickHouseParser::TRUNCATE - 128))\n-      | (1ULL << (ClickHouseParser::TTL - 128))\n-      | (1ULL << (ClickHouseParser::TYPE - 128))\n-      | (1ULL << (ClickHouseParser::UNION - 128))\n-      | (1ULL << (ClickHouseParser::UPDATE - 128))\n-      | (1ULL << (ClickHouseParser::USE - 128))\n-      | (1ULL << (ClickHouseParser::USING - 128))\n-      | (1ULL << (ClickHouseParser::UUID - 128))\n-      | (1ULL << (ClickHouseParser::VALUES - 128))\n-      | (1ULL << (ClickHouseParser::VIEW - 128))\n-      | (1ULL << (ClickHouseParser::VOLUME - 128))\n-      | (1ULL << (ClickHouseParser::WATCH - 128))\n-      | (1ULL << (ClickHouseParser::WEEK - 128))\n-      | (1ULL << (ClickHouseParser::WHEN - 128))\n-      | (1ULL << (ClickHouseParser::WHERE - 128))\n-      | (1ULL << (ClickHouseParser::WITH - 128))\n-      | (1ULL << (ClickHouseParser::YEAR - 128))\n-      | (1ULL << (ClickHouseParser::JSON_FALSE - 128))\n-      | (1ULL << (ClickHouseParser::JSON_TRUE - 128))\n-      | (1ULL << (ClickHouseParser::IDENTIFIER - 128)))) != 0)) {\n-      setState(766);\n-      dictionaryArgExpr();\n-      setState(771);\n-      _errHandler->sync(this);\n-      _la = _input->LA(1);\n-    }\n-    setState(772);\n-    match(ClickHouseParser::RPAREN);\n-    setState(773);\n-    match(ClickHouseParser::RPAREN);\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- RangeClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::RangeClauseContext::RangeClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::RangeClauseContext::RANGE() {\n-  return getToken(ClickHouseParser::RANGE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::RangeClauseContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::RangeClauseContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::RangeClauseContext::MIN() {\n-  return getToken(ClickHouseParser::MIN, 0);\n-}\n-\n-std::vector<ClickHouseParser::IdentifierContext *> ClickHouseParser::RangeClauseContext::identifier() {\n-  return getRuleContexts<ClickHouseParser::IdentifierContext>();\n-}\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::RangeClauseContext::identifier(size_t i) {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::RangeClauseContext::MAX() {\n-  return getToken(ClickHouseParser::MAX, 0);\n-}\n-\n-\n-size_t ClickHouseParser::RangeClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleRangeClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::RangeClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitRangeClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::RangeClauseContext* ClickHouseParser::rangeClause() {\n-  RangeClauseContext *_localctx = _tracker.createInstance<RangeClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 38, ClickHouseParser::RuleRangeClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(775);\n-    match(ClickHouseParser::RANGE);\n-    setState(776);\n-    match(ClickHouseParser::LPAREN);\n-    setState(787);\n-    _errHandler->sync(this);\n-    switch (_input->LA(1)) {\n-      case ClickHouseParser::MIN: {\n-        setState(777);\n-        match(ClickHouseParser::MIN);\n-        setState(778);\n-        identifier();\n-        setState(779);\n-        match(ClickHouseParser::MAX);\n-        setState(780);\n-        identifier();\n-        break;\n-      }\n-\n-      case ClickHouseParser::MAX: {\n-        setState(782);\n-        match(ClickHouseParser::MAX);\n-        setState(783);\n-        identifier();\n-        setState(784);\n-        match(ClickHouseParser::MIN);\n-        setState(785);\n-        identifier();\n-        break;\n-      }\n-\n-    default:\n-      throw NoViableAltException(this);\n-    }\n-    setState(789);\n-    match(ClickHouseParser::RPAREN);\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- DictionarySettingsClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::DictionarySettingsClauseContext::DictionarySettingsClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DictionarySettingsClauseContext::SETTINGS() {\n-  return getToken(ClickHouseParser::SETTINGS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DictionarySettingsClauseContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-ClickHouseParser::SettingExprListContext* ClickHouseParser::DictionarySettingsClauseContext::settingExprList() {\n-  return getRuleContext<ClickHouseParser::SettingExprListContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DictionarySettingsClauseContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-\n-size_t ClickHouseParser::DictionarySettingsClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleDictionarySettingsClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::DictionarySettingsClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitDictionarySettingsClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::DictionarySettingsClauseContext* ClickHouseParser::dictionarySettingsClause() {\n-  DictionarySettingsClauseContext *_localctx = _tracker.createInstance<DictionarySettingsClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 40, ClickHouseParser::RuleDictionarySettingsClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(791);\n-    match(ClickHouseParser::SETTINGS);\n-    setState(792);\n-    match(ClickHouseParser::LPAREN);\n-    setState(793);\n-    settingExprList();\n-    setState(794);\n-    match(ClickHouseParser::RPAREN);\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- ClusterClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::ClusterClauseContext::ClusterClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ClusterClauseContext::ON() {\n-  return getToken(ClickHouseParser::ON, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ClusterClauseContext::CLUSTER() {\n-  return getToken(ClickHouseParser::CLUSTER, 0);\n-}\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::ClusterClauseContext::identifier() {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ClusterClauseContext::STRING_LITERAL() {\n-  return getToken(ClickHouseParser::STRING_LITERAL, 0);\n-}\n-\n-\n-size_t ClickHouseParser::ClusterClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleClusterClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::ClusterClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitClusterClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::ClusterClauseContext* ClickHouseParser::clusterClause() {\n-  ClusterClauseContext *_localctx = _tracker.createInstance<ClusterClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 42, ClickHouseParser::RuleClusterClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(796);\n-    match(ClickHouseParser::ON);\n-    setState(797);\n-    match(ClickHouseParser::CLUSTER);\n-    setState(800);\n-    _errHandler->sync(this);\n-    switch (_input->LA(1)) {\n-      case ClickHouseParser::AFTER:\n-      case ClickHouseParser::ALIAS:\n-      case ClickHouseParser::ALL:\n-      case ClickHouseParser::ALTER:\n-      case ClickHouseParser::AND:\n-      case ClickHouseParser::ANTI:\n-      case ClickHouseParser::ANY:\n-      case ClickHouseParser::ARRAY:\n-      case ClickHouseParser::AS:\n-      case ClickHouseParser::ASCENDING:\n-      case ClickHouseParser::ASOF:\n-      case ClickHouseParser::AST:\n-      case ClickHouseParser::ASYNC:\n-      case ClickHouseParser::ATTACH:\n-      case ClickHouseParser::BETWEEN:\n-      case ClickHouseParser::BOTH:\n-      case ClickHouseParser::BY:\n-      case ClickHouseParser::CASE:\n-      case ClickHouseParser::CAST:\n-      case ClickHouseParser::CHECK:\n-      case ClickHouseParser::CLEAR:\n-      case ClickHouseParser::CLUSTER:\n-      case ClickHouseParser::CODEC:\n-      case ClickHouseParser::COLLATE:\n-      case ClickHouseParser::COLUMN:\n-      case ClickHouseParser::COMMENT:\n-      case ClickHouseParser::CONSTRAINT:\n-      case ClickHouseParser::CREATE:\n-      case ClickHouseParser::CROSS:\n-      case ClickHouseParser::CUBE:\n-      case ClickHouseParser::DATABASE:\n-      case ClickHouseParser::DATABASES:\n-      case ClickHouseParser::DATE:\n-      case ClickHouseParser::DAY:\n-      case ClickHouseParser::DEDUPLICATE:\n-      case ClickHouseParser::DEFAULT:\n-      case ClickHouseParser::DELAY:\n-      case ClickHouseParser::DELETE:\n-      case ClickHouseParser::DESC:\n-      case ClickHouseParser::DESCENDING:\n-      case ClickHouseParser::DESCRIBE:\n-      case ClickHouseParser::DETACH:\n-      case ClickHouseParser::DICTIONARIES:\n-      case ClickHouseParser::DICTIONARY:\n-      case ClickHouseParser::DISK:\n-      case ClickHouseParser::DISTINCT:\n-      case ClickHouseParser::DISTRIBUTED:\n-      case ClickHouseParser::DROP:\n-      case ClickHouseParser::ELSE:\n-      case ClickHouseParser::END:\n-      case ClickHouseParser::ENGINE:\n-      case ClickHouseParser::EVENTS:\n-      case ClickHouseParser::EXISTS:\n-      case ClickHouseParser::EXPLAIN:\n-      case ClickHouseParser::EXPRESSION:\n-      case ClickHouseParser::EXTRACT:\n-      case ClickHouseParser::FETCHES:\n-      case ClickHouseParser::FINAL:\n-      case ClickHouseParser::FIRST:\n-      case ClickHouseParser::FLUSH:\n-      case ClickHouseParser::FOR:\n-      case ClickHouseParser::FORMAT:\n-      case ClickHouseParser::FREEZE:\n-      case ClickHouseParser::FROM:\n-      case ClickHouseParser::FULL:\n-      case ClickHouseParser::FUNCTION:\n-      case ClickHouseParser::GLOBAL:\n-      case ClickHouseParser::GRANULARITY:\n-      case ClickHouseParser::GROUP:\n-      case ClickHouseParser::HAVING:\n-      case ClickHouseParser::HIERARCHICAL:\n-      case ClickHouseParser::HOUR:\n-      case ClickHouseParser::ID:\n-      case ClickHouseParser::IF:\n-      case ClickHouseParser::ILIKE:\n-      case ClickHouseParser::IN:\n-      case ClickHouseParser::INDEX:\n-      case ClickHouseParser::INJECTIVE:\n-      case ClickHouseParser::INNER:\n-      case ClickHouseParser::INSERT:\n-      case ClickHouseParser::INTERVAL:\n-      case ClickHouseParser::INTO:\n-      case ClickHouseParser::IS:\n-      case ClickHouseParser::IS_OBJECT_ID:\n-      case ClickHouseParser::JOIN:\n-      case ClickHouseParser::KEY:\n-      case ClickHouseParser::KILL:\n-      case ClickHouseParser::LAST:\n-      case ClickHouseParser::LAYOUT:\n-      case ClickHouseParser::LEADING:\n-      case ClickHouseParser::LEFT:\n-      case ClickHouseParser::LIFETIME:\n-      case ClickHouseParser::LIKE:\n-      case ClickHouseParser::LIMIT:\n-      case ClickHouseParser::LIVE:\n-      case ClickHouseParser::LOCAL:\n-      case ClickHouseParser::LOGS:\n-      case ClickHouseParser::MATERIALIZE:\n-      case ClickHouseParser::MATERIALIZED:\n-      case ClickHouseParser::MAX:\n-      case ClickHouseParser::MERGES:\n-      case ClickHouseParser::MIN:\n-      case ClickHouseParser::MINUTE:\n-      case ClickHouseParser::MODIFY:\n-      case ClickHouseParser::MONTH:\n-      case ClickHouseParser::MOVE:\n-      case ClickHouseParser::MUTATION:\n-      case ClickHouseParser::NO:\n-      case ClickHouseParser::NOT:\n-      case ClickHouseParser::NULLS:\n-      case ClickHouseParser::OFFSET:\n-      case ClickHouseParser::ON:\n-      case ClickHouseParser::OPTIMIZE:\n-      case ClickHouseParser::OR:\n-      case ClickHouseParser::ORDER:\n-      case ClickHouseParser::OUTER:\n-      case ClickHouseParser::OUTFILE:\n-      case ClickHouseParser::PARTITION:\n-      case ClickHouseParser::POPULATE:\n-      case ClickHouseParser::PREWHERE:\n-      case ClickHouseParser::PRIMARY:\n-      case ClickHouseParser::QUARTER:\n-      case ClickHouseParser::RANGE:\n-      case ClickHouseParser::RELOAD:\n-      case ClickHouseParser::REMOVE:\n-      case ClickHouseParser::RENAME:\n-      case ClickHouseParser::REPLACE:\n-      case ClickHouseParser::REPLICA:\n-      case ClickHouseParser::REPLICATED:\n-      case ClickHouseParser::RIGHT:\n-      case ClickHouseParser::ROLLUP:\n-      case ClickHouseParser::SAMPLE:\n-      case ClickHouseParser::SECOND:\n-      case ClickHouseParser::SELECT:\n-      case ClickHouseParser::SEMI:\n-      case ClickHouseParser::SENDS:\n-      case ClickHouseParser::SET:\n-      case ClickHouseParser::SETTINGS:\n-      case ClickHouseParser::SHOW:\n-      case ClickHouseParser::SOURCE:\n-      case ClickHouseParser::START:\n-      case ClickHouseParser::STOP:\n-      case ClickHouseParser::SUBSTRING:\n-      case ClickHouseParser::SYNC:\n-      case ClickHouseParser::SYNTAX:\n-      case ClickHouseParser::SYSTEM:\n-      case ClickHouseParser::TABLE:\n-      case ClickHouseParser::TABLES:\n-      case ClickHouseParser::TEMPORARY:\n-      case ClickHouseParser::TEST:\n-      case ClickHouseParser::THEN:\n-      case ClickHouseParser::TIES:\n-      case ClickHouseParser::TIMEOUT:\n-      case ClickHouseParser::TIMESTAMP:\n-      case ClickHouseParser::TO:\n-      case ClickHouseParser::TOP:\n-      case ClickHouseParser::TOTALS:\n-      case ClickHouseParser::TRAILING:\n-      case ClickHouseParser::TRIM:\n-      case ClickHouseParser::TRUNCATE:\n-      case ClickHouseParser::TTL:\n-      case ClickHouseParser::TYPE:\n-      case ClickHouseParser::UNION:\n-      case ClickHouseParser::UPDATE:\n-      case ClickHouseParser::USE:\n-      case ClickHouseParser::USING:\n-      case ClickHouseParser::UUID:\n-      case ClickHouseParser::VALUES:\n-      case ClickHouseParser::VIEW:\n-      case ClickHouseParser::VOLUME:\n-      case ClickHouseParser::WATCH:\n-      case ClickHouseParser::WEEK:\n-      case ClickHouseParser::WHEN:\n-      case ClickHouseParser::WHERE:\n-      case ClickHouseParser::WITH:\n-      case ClickHouseParser::YEAR:\n-      case ClickHouseParser::JSON_FALSE:\n-      case ClickHouseParser::JSON_TRUE:\n-      case ClickHouseParser::IDENTIFIER: {\n-        setState(798);\n-        identifier();\n-        break;\n-      }\n-\n-      case ClickHouseParser::STRING_LITERAL: {\n-        setState(799);\n-        match(ClickHouseParser::STRING_LITERAL);\n-        break;\n-      }\n-\n-    default:\n-      throw NoViableAltException(this);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- UuidClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::UuidClauseContext::UuidClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::UuidClauseContext::UUID() {\n-  return getToken(ClickHouseParser::UUID, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::UuidClauseContext::STRING_LITERAL() {\n-  return getToken(ClickHouseParser::STRING_LITERAL, 0);\n-}\n-\n-\n-size_t ClickHouseParser::UuidClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleUuidClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::UuidClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitUuidClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::UuidClauseContext* ClickHouseParser::uuidClause() {\n-  UuidClauseContext *_localctx = _tracker.createInstance<UuidClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 44, ClickHouseParser::RuleUuidClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(802);\n-    match(ClickHouseParser::UUID);\n-    setState(803);\n-    match(ClickHouseParser::STRING_LITERAL);\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- DestinationClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::DestinationClauseContext::DestinationClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DestinationClauseContext::TO() {\n-  return getToken(ClickHouseParser::TO, 0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::DestinationClauseContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::DestinationClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleDestinationClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::DestinationClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitDestinationClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::DestinationClauseContext* ClickHouseParser::destinationClause() {\n-  DestinationClauseContext *_localctx = _tracker.createInstance<DestinationClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 46, ClickHouseParser::RuleDestinationClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(805);\n-    match(ClickHouseParser::TO);\n-    setState(806);\n-    tableIdentifier();\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- SubqueryClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::SubqueryClauseContext::SubqueryClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SubqueryClauseContext::AS() {\n-  return getToken(ClickHouseParser::AS, 0);\n-}\n-\n-ClickHouseParser::SelectUnionStmtContext* ClickHouseParser::SubqueryClauseContext::selectUnionStmt() {\n-  return getRuleContext<ClickHouseParser::SelectUnionStmtContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::SubqueryClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleSubqueryClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::SubqueryClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitSubqueryClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::SubqueryClauseContext* ClickHouseParser::subqueryClause() {\n-  SubqueryClauseContext *_localctx = _tracker.createInstance<SubqueryClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 48, ClickHouseParser::RuleSubqueryClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(808);\n-    match(ClickHouseParser::AS);\n-    setState(809);\n-    selectUnionStmt();\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- TableSchemaClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::TableSchemaClauseContext::TableSchemaClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-\n-size_t ClickHouseParser::TableSchemaClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleTableSchemaClause;\n-}\n-\n-void ClickHouseParser::TableSchemaClauseContext::copyFrom(TableSchemaClauseContext *ctx) {\n-  ParserRuleContext::copyFrom(ctx);\n-}\n-\n-//----------------- SchemaAsTableClauseContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::SchemaAsTableClauseContext::AS() {\n-  return getToken(ClickHouseParser::AS, 0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::SchemaAsTableClauseContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::SchemaAsTableClauseContext::SchemaAsTableClauseContext(TableSchemaClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::SchemaAsTableClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitSchemaAsTableClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- SchemaAsFunctionClauseContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::SchemaAsFunctionClauseContext::AS() {\n-  return getToken(ClickHouseParser::AS, 0);\n-}\n-\n-ClickHouseParser::TableFunctionExprContext* ClickHouseParser::SchemaAsFunctionClauseContext::tableFunctionExpr() {\n-  return getRuleContext<ClickHouseParser::TableFunctionExprContext>(0);\n-}\n-\n-ClickHouseParser::SchemaAsFunctionClauseContext::SchemaAsFunctionClauseContext(TableSchemaClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::SchemaAsFunctionClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitSchemaAsFunctionClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- SchemaDescriptionClauseContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::SchemaDescriptionClauseContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-std::vector<ClickHouseParser::TableElementExprContext *> ClickHouseParser::SchemaDescriptionClauseContext::tableElementExpr() {\n-  return getRuleContexts<ClickHouseParser::TableElementExprContext>();\n-}\n-\n-ClickHouseParser::TableElementExprContext* ClickHouseParser::SchemaDescriptionClauseContext::tableElementExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::TableElementExprContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SchemaDescriptionClauseContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::SchemaDescriptionClauseContext::COMMA() {\n-  return getTokens(ClickHouseParser::COMMA);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SchemaDescriptionClauseContext::COMMA(size_t i) {\n-  return getToken(ClickHouseParser::COMMA, i);\n-}\n-\n-ClickHouseParser::SchemaDescriptionClauseContext::SchemaDescriptionClauseContext(TableSchemaClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::SchemaDescriptionClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitSchemaDescriptionClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-ClickHouseParser::TableSchemaClauseContext* ClickHouseParser::tableSchemaClause() {\n-  TableSchemaClauseContext *_localctx = _tracker.createInstance<TableSchemaClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 50, ClickHouseParser::RuleTableSchemaClause);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(826);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx)) {\n-    case 1: {\n-      _localctx = dynamic_cast<TableSchemaClauseContext *>(_tracker.createInstance<ClickHouseParser::SchemaDescriptionClauseContext>(_localctx));\n-      enterOuterAlt(_localctx, 1);\n-      setState(811);\n-      match(ClickHouseParser::LPAREN);\n-      setState(812);\n-      tableElementExpr();\n-      setState(817);\n-      _errHandler->sync(this);\n-      _la = _input->LA(1);\n-      while (_la == ClickHouseParser::COMMA) {\n-        setState(813);\n-        match(ClickHouseParser::COMMA);\n-        setState(814);\n-        tableElementExpr();\n-        setState(819);\n-        _errHandler->sync(this);\n-        _la = _input->LA(1);\n-      }\n-      setState(820);\n-      match(ClickHouseParser::RPAREN);\n-      break;\n-    }\n-\n-    case 2: {\n-      _localctx = dynamic_cast<TableSchemaClauseContext *>(_tracker.createInstance<ClickHouseParser::SchemaAsTableClauseContext>(_localctx));\n-      enterOuterAlt(_localctx, 2);\n-      setState(822);\n-      match(ClickHouseParser::AS);\n-      setState(823);\n-      tableIdentifier();\n-      break;\n-    }\n-\n-    case 3: {\n-      _localctx = dynamic_cast<TableSchemaClauseContext *>(_tracker.createInstance<ClickHouseParser::SchemaAsFunctionClauseContext>(_localctx));\n-      enterOuterAlt(_localctx, 3);\n-      setState(824);\n-      match(ClickHouseParser::AS);\n-      setState(825);\n-      tableFunctionExpr();\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- EngineClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::EngineClauseContext::EngineClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::EngineExprContext* ClickHouseParser::EngineClauseContext::engineExpr() {\n-  return getRuleContext<ClickHouseParser::EngineExprContext>(0);\n-}\n-\n-std::vector<ClickHouseParser::OrderByClauseContext *> ClickHouseParser::EngineClauseContext::orderByClause() {\n-  return getRuleContexts<ClickHouseParser::OrderByClauseContext>();\n-}\n-\n-ClickHouseParser::OrderByClauseContext* ClickHouseParser::EngineClauseContext::orderByClause(size_t i) {\n-  return getRuleContext<ClickHouseParser::OrderByClauseContext>(i);\n-}\n-\n-std::vector<ClickHouseParser::PartitionByClauseContext *> ClickHouseParser::EngineClauseContext::partitionByClause() {\n-  return getRuleContexts<ClickHouseParser::PartitionByClauseContext>();\n-}\n-\n-ClickHouseParser::PartitionByClauseContext* ClickHouseParser::EngineClauseContext::partitionByClause(size_t i) {\n-  return getRuleContext<ClickHouseParser::PartitionByClauseContext>(i);\n-}\n-\n-std::vector<ClickHouseParser::PrimaryKeyClauseContext *> ClickHouseParser::EngineClauseContext::primaryKeyClause() {\n-  return getRuleContexts<ClickHouseParser::PrimaryKeyClauseContext>();\n-}\n-\n-ClickHouseParser::PrimaryKeyClauseContext* ClickHouseParser::EngineClauseContext::primaryKeyClause(size_t i) {\n-  return getRuleContext<ClickHouseParser::PrimaryKeyClauseContext>(i);\n-}\n-\n-std::vector<ClickHouseParser::SampleByClauseContext *> ClickHouseParser::EngineClauseContext::sampleByClause() {\n-  return getRuleContexts<ClickHouseParser::SampleByClauseContext>();\n-}\n-\n-ClickHouseParser::SampleByClauseContext* ClickHouseParser::EngineClauseContext::sampleByClause(size_t i) {\n-  return getRuleContext<ClickHouseParser::SampleByClauseContext>(i);\n-}\n-\n-std::vector<ClickHouseParser::TtlClauseContext *> ClickHouseParser::EngineClauseContext::ttlClause() {\n-  return getRuleContexts<ClickHouseParser::TtlClauseContext>();\n-}\n-\n-ClickHouseParser::TtlClauseContext* ClickHouseParser::EngineClauseContext::ttlClause(size_t i) {\n-  return getRuleContext<ClickHouseParser::TtlClauseContext>(i);\n-}\n-\n-std::vector<ClickHouseParser::SettingsClauseContext *> ClickHouseParser::EngineClauseContext::settingsClause() {\n-  return getRuleContexts<ClickHouseParser::SettingsClauseContext>();\n-}\n-\n-ClickHouseParser::SettingsClauseContext* ClickHouseParser::EngineClauseContext::settingsClause(size_t i) {\n-  return getRuleContext<ClickHouseParser::SettingsClauseContext>(i);\n-}\n-\n-\n-size_t ClickHouseParser::EngineClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleEngineClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::EngineClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitEngineClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::EngineClauseContext* ClickHouseParser::engineClause() {\n-  EngineClauseContext *_localctx = _tracker.createInstance<EngineClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 52, ClickHouseParser::RuleEngineClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    size_t alt;\n-    enterOuterAlt(_localctx, 1);\n-    setState(828);\n-    engineExpr();\n-    setState(855);\n-    _errHandler->sync(this);\n-    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx);\n-    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {\n-      if (alt == 1) {\n-        setState(853);\n-        _errHandler->sync(this);\n-        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx)) {\n-        case 1: {\n-          setState(829);\n-\n-          if (!(!_localctx->clauses.count(\"orderByClause\"))) throw FailedPredicateException(this, \"!$clauses.count(\\\"orderByClause\\\")\");\n-          setState(830);\n-          orderByClause();\n-          _localctx->clauses.insert(\"orderByClause\");\n-          break;\n-        }\n-\n-        case 2: {\n-          setState(833);\n-\n-          if (!(!_localctx->clauses.count(\"partitionByClause\"))) throw FailedPredicateException(this, \"!$clauses.count(\\\"partitionByClause\\\")\");\n-          setState(834);\n-          partitionByClause();\n-          _localctx->clauses.insert(\"partitionByClause\");\n-          break;\n-        }\n-\n-        case 3: {\n-          setState(837);\n-\n-          if (!(!_localctx->clauses.count(\"primaryKeyClause\"))) throw FailedPredicateException(this, \"!$clauses.count(\\\"primaryKeyClause\\\")\");\n-          setState(838);\n-          primaryKeyClause();\n-          _localctx->clauses.insert(\"primaryKeyClause\");\n-          break;\n-        }\n-\n-        case 4: {\n-          setState(841);\n-\n-          if (!(!_localctx->clauses.count(\"sampleByClause\"))) throw FailedPredicateException(this, \"!$clauses.count(\\\"sampleByClause\\\")\");\n-          setState(842);\n-          sampleByClause();\n-          _localctx->clauses.insert(\"sampleByClause\");\n-          break;\n-        }\n-\n-        case 5: {\n-          setState(845);\n-\n-          if (!(!_localctx->clauses.count(\"ttlClause\"))) throw FailedPredicateException(this, \"!$clauses.count(\\\"ttlClause\\\")\");\n-          setState(846);\n-          ttlClause();\n-          _localctx->clauses.insert(\"ttlClause\");\n-          break;\n-        }\n-\n-        case 6: {\n-          setState(849);\n-\n-          if (!(!_localctx->clauses.count(\"settingsClause\"))) throw FailedPredicateException(this, \"!$clauses.count(\\\"settingsClause\\\")\");\n-          setState(850);\n-          settingsClause();\n-          _localctx->clauses.insert(\"settingsClause\");\n-          break;\n-        }\n-\n-        } \n-      }\n-      setState(857);\n-      _errHandler->sync(this);\n-      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- PartitionByClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::PartitionByClauseContext::PartitionByClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::PartitionByClauseContext::PARTITION() {\n-  return getToken(ClickHouseParser::PARTITION, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::PartitionByClauseContext::BY() {\n-  return getToken(ClickHouseParser::BY, 0);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::PartitionByClauseContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::PartitionByClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RulePartitionByClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::PartitionByClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitPartitionByClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::PartitionByClauseContext* ClickHouseParser::partitionByClause() {\n-  PartitionByClauseContext *_localctx = _tracker.createInstance<PartitionByClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 54, ClickHouseParser::RulePartitionByClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(858);\n-    match(ClickHouseParser::PARTITION);\n-    setState(859);\n-    match(ClickHouseParser::BY);\n-    setState(860);\n-    columnExpr(0);\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- PrimaryKeyClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::PrimaryKeyClauseContext::PrimaryKeyClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::PrimaryKeyClauseContext::PRIMARY() {\n-  return getToken(ClickHouseParser::PRIMARY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::PrimaryKeyClauseContext::KEY() {\n-  return getToken(ClickHouseParser::KEY, 0);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::PrimaryKeyClauseContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::PrimaryKeyClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RulePrimaryKeyClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::PrimaryKeyClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitPrimaryKeyClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::PrimaryKeyClauseContext* ClickHouseParser::primaryKeyClause() {\n-  PrimaryKeyClauseContext *_localctx = _tracker.createInstance<PrimaryKeyClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 56, ClickHouseParser::RulePrimaryKeyClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(862);\n-    match(ClickHouseParser::PRIMARY);\n-    setState(863);\n-    match(ClickHouseParser::KEY);\n-    setState(864);\n-    columnExpr(0);\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- SampleByClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::SampleByClauseContext::SampleByClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SampleByClauseContext::SAMPLE() {\n-  return getToken(ClickHouseParser::SAMPLE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SampleByClauseContext::BY() {\n-  return getToken(ClickHouseParser::BY, 0);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::SampleByClauseContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::SampleByClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleSampleByClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::SampleByClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitSampleByClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::SampleByClauseContext* ClickHouseParser::sampleByClause() {\n-  SampleByClauseContext *_localctx = _tracker.createInstance<SampleByClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 58, ClickHouseParser::RuleSampleByClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(866);\n-    match(ClickHouseParser::SAMPLE);\n-    setState(867);\n-    match(ClickHouseParser::BY);\n-    setState(868);\n-    columnExpr(0);\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- TtlClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::TtlClauseContext::TtlClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TtlClauseContext::TTL() {\n-  return getToken(ClickHouseParser::TTL, 0);\n-}\n-\n-std::vector<ClickHouseParser::TtlExprContext *> ClickHouseParser::TtlClauseContext::ttlExpr() {\n-  return getRuleContexts<ClickHouseParser::TtlExprContext>();\n-}\n-\n-ClickHouseParser::TtlExprContext* ClickHouseParser::TtlClauseContext::ttlExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::TtlExprContext>(i);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::TtlClauseContext::COMMA() {\n-  return getTokens(ClickHouseParser::COMMA);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TtlClauseContext::COMMA(size_t i) {\n-  return getToken(ClickHouseParser::COMMA, i);\n-}\n-\n-\n-size_t ClickHouseParser::TtlClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleTtlClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::TtlClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitTtlClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::TtlClauseContext* ClickHouseParser::ttlClause() {\n-  TtlClauseContext *_localctx = _tracker.createInstance<TtlClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 60, ClickHouseParser::RuleTtlClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    size_t alt;\n-    enterOuterAlt(_localctx, 1);\n-    setState(870);\n-    match(ClickHouseParser::TTL);\n-    setState(871);\n-    ttlExpr();\n-    setState(876);\n-    _errHandler->sync(this);\n-    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx);\n-    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {\n-      if (alt == 1) {\n-        setState(872);\n-        match(ClickHouseParser::COMMA);\n-        setState(873);\n-        ttlExpr(); \n-      }\n-      setState(878);\n-      _errHandler->sync(this);\n-      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- EngineExprContext ------------------------------------------------------------------\n-\n-ClickHouseParser::EngineExprContext::EngineExprContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::EngineExprContext::ENGINE() {\n-  return getToken(ClickHouseParser::ENGINE, 0);\n-}\n-\n-ClickHouseParser::IdentifierOrNullContext* ClickHouseParser::EngineExprContext::identifierOrNull() {\n-  return getRuleContext<ClickHouseParser::IdentifierOrNullContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::EngineExprContext::EQ_SINGLE() {\n-  return getToken(ClickHouseParser::EQ_SINGLE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::EngineExprContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::EngineExprContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-ClickHouseParser::ColumnExprListContext* ClickHouseParser::EngineExprContext::columnExprList() {\n-  return getRuleContext<ClickHouseParser::ColumnExprListContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::EngineExprContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleEngineExpr;\n-}\n-\n-antlrcpp::Any ClickHouseParser::EngineExprContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitEngineExpr(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::EngineExprContext* ClickHouseParser::engineExpr() {\n-  EngineExprContext *_localctx = _tracker.createInstance<EngineExprContext>(_ctx, getState());\n-  enterRule(_localctx, 62, ClickHouseParser::RuleEngineExpr);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(879);\n-    match(ClickHouseParser::ENGINE);\n-    setState(881);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::EQ_SINGLE) {\n-      setState(880);\n-      match(ClickHouseParser::EQ_SINGLE);\n-    }\n-    setState(883);\n-    identifierOrNull();\n-    setState(889);\n-    _errHandler->sync(this);\n-\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 92, _ctx)) {\n-    case 1: {\n-      setState(884);\n-      match(ClickHouseParser::LPAREN);\n-      setState(886);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if ((((_la & ~ 0x3fULL) == 0) &&\n-        ((1ULL << _la) & ((1ULL << ClickHouseParser::AFTER)\n-        | (1ULL << ClickHouseParser::ALIAS)\n-        | (1ULL << ClickHouseParser::ALL)\n-        | (1ULL << ClickHouseParser::ALTER)\n-        | (1ULL << ClickHouseParser::AND)\n-        | (1ULL << ClickHouseParser::ANTI)\n-        | (1ULL << ClickHouseParser::ANY)\n-        | (1ULL << ClickHouseParser::ARRAY)\n-        | (1ULL << ClickHouseParser::AS)\n-        | (1ULL << ClickHouseParser::ASCENDING)\n-        | (1ULL << ClickHouseParser::ASOF)\n-        | (1ULL << ClickHouseParser::AST)\n-        | (1ULL << ClickHouseParser::ASYNC)\n-        | (1ULL << ClickHouseParser::ATTACH)\n-        | (1ULL << ClickHouseParser::BETWEEN)\n-        | (1ULL << ClickHouseParser::BOTH)\n-        | (1ULL << ClickHouseParser::BY)\n-        | (1ULL << ClickHouseParser::CASE)\n-        | (1ULL << ClickHouseParser::CAST)\n-        | (1ULL << ClickHouseParser::CHECK)\n-        | (1ULL << ClickHouseParser::CLEAR)\n-        | (1ULL << ClickHouseParser::CLUSTER)\n-        | (1ULL << ClickHouseParser::CODEC)\n-        | (1ULL << ClickHouseParser::COLLATE)\n-        | (1ULL << ClickHouseParser::COLUMN)\n-        | (1ULL << ClickHouseParser::COMMENT)\n-        | (1ULL << ClickHouseParser::CONSTRAINT)\n-        | (1ULL << ClickHouseParser::CREATE)\n-        | (1ULL << ClickHouseParser::CROSS)\n-        | (1ULL << ClickHouseParser::CUBE)\n-        | (1ULL << ClickHouseParser::DATABASE)\n-        | (1ULL << ClickHouseParser::DATABASES)\n-        | (1ULL << ClickHouseParser::DATE)\n-        | (1ULL << ClickHouseParser::DAY)\n-        | (1ULL << ClickHouseParser::DEDUPLICATE)\n-        | (1ULL << ClickHouseParser::DEFAULT)\n-        | (1ULL << ClickHouseParser::DELAY)\n-        | (1ULL << ClickHouseParser::DELETE)\n-        | (1ULL << ClickHouseParser::DESC)\n-        | (1ULL << ClickHouseParser::DESCENDING)\n-        | (1ULL << ClickHouseParser::DESCRIBE)\n-        | (1ULL << ClickHouseParser::DETACH)\n-        | (1ULL << ClickHouseParser::DICTIONARIES)\n-        | (1ULL << ClickHouseParser::DICTIONARY)\n-        | (1ULL << ClickHouseParser::DISK)\n-        | (1ULL << ClickHouseParser::DISTINCT)\n-        | (1ULL << ClickHouseParser::DISTRIBUTED)\n-        | (1ULL << ClickHouseParser::DROP)\n-        | (1ULL << ClickHouseParser::ELSE)\n-        | (1ULL << ClickHouseParser::END)\n-        | (1ULL << ClickHouseParser::ENGINE)\n-        | (1ULL << ClickHouseParser::EVENTS)\n-        | (1ULL << ClickHouseParser::EXISTS)\n-        | (1ULL << ClickHouseParser::EXPLAIN)\n-        | (1ULL << ClickHouseParser::EXPRESSION)\n-        | (1ULL << ClickHouseParser::EXTRACT)\n-        | (1ULL << ClickHouseParser::FETCHES)\n-        | (1ULL << ClickHouseParser::FINAL)\n-        | (1ULL << ClickHouseParser::FIRST)\n-        | (1ULL << ClickHouseParser::FLUSH)\n-        | (1ULL << ClickHouseParser::FOR)\n-        | (1ULL << ClickHouseParser::FORMAT))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&\n-        ((1ULL << (_la - 64)) & ((1ULL << (ClickHouseParser::FREEZE - 64))\n-        | (1ULL << (ClickHouseParser::FROM - 64))\n-        | (1ULL << (ClickHouseParser::FULL - 64))\n-        | (1ULL << (ClickHouseParser::FUNCTION - 64))\n-        | (1ULL << (ClickHouseParser::GLOBAL - 64))\n-        | (1ULL << (ClickHouseParser::GRANULARITY - 64))\n-        | (1ULL << (ClickHouseParser::GROUP - 64))\n-        | (1ULL << (ClickHouseParser::HAVING - 64))\n-        | (1ULL << (ClickHouseParser::HIERARCHICAL - 64))\n-        | (1ULL << (ClickHouseParser::HOUR - 64))\n-        | (1ULL << (ClickHouseParser::ID - 64))\n-        | (1ULL << (ClickHouseParser::IF - 64))\n-        | (1ULL << (ClickHouseParser::ILIKE - 64))\n-        | (1ULL << (ClickHouseParser::IN - 64))\n-        | (1ULL << (ClickHouseParser::INDEX - 64))\n-        | (1ULL << (ClickHouseParser::INF - 64))\n-        | (1ULL << (ClickHouseParser::INJECTIVE - 64))\n-        | (1ULL << (ClickHouseParser::INNER - 64))\n-        | (1ULL << (ClickHouseParser::INSERT - 64))\n-        | (1ULL << (ClickHouseParser::INTERVAL - 64))\n-        | (1ULL << (ClickHouseParser::INTO - 64))\n-        | (1ULL << (ClickHouseParser::IS - 64))\n-        | (1ULL << (ClickHouseParser::IS_OBJECT_ID - 64))\n-        | (1ULL << (ClickHouseParser::JOIN - 64))\n-        | (1ULL << (ClickHouseParser::KEY - 64))\n-        | (1ULL << (ClickHouseParser::KILL - 64))\n-        | (1ULL << (ClickHouseParser::LAST - 64))\n-        | (1ULL << (ClickHouseParser::LAYOUT - 64))\n-        | (1ULL << (ClickHouseParser::LEADING - 64))\n-        | (1ULL << (ClickHouseParser::LEFT - 64))\n-        | (1ULL << (ClickHouseParser::LIFETIME - 64))\n-        | (1ULL << (ClickHouseParser::LIKE - 64))\n-        | (1ULL << (ClickHouseParser::LIMIT - 64))\n-        | (1ULL << (ClickHouseParser::LIVE - 64))\n-        | (1ULL << (ClickHouseParser::LOCAL - 64))\n-        | (1ULL << (ClickHouseParser::LOGS - 64))\n-        | (1ULL << (ClickHouseParser::MATERIALIZE - 64))\n-        | (1ULL << (ClickHouseParser::MATERIALIZED - 64))\n-        | (1ULL << (ClickHouseParser::MAX - 64))\n-        | (1ULL << (ClickHouseParser::MERGES - 64))\n-        | (1ULL << (ClickHouseParser::MIN - 64))\n-        | (1ULL << (ClickHouseParser::MINUTE - 64))\n-        | (1ULL << (ClickHouseParser::MODIFY - 64))\n-        | (1ULL << (ClickHouseParser::MONTH - 64))\n-        | (1ULL << (ClickHouseParser::MOVE - 64))\n-        | (1ULL << (ClickHouseParser::MUTATION - 64))\n-        | (1ULL << (ClickHouseParser::NAN_SQL - 64))\n-        | (1ULL << (ClickHouseParser::NO - 64))\n-        | (1ULL << (ClickHouseParser::NOT - 64))\n-        | (1ULL << (ClickHouseParser::NULL_SQL - 64))\n-        | (1ULL << (ClickHouseParser::NULLS - 64))\n-        | (1ULL << (ClickHouseParser::OFFSET - 64))\n-        | (1ULL << (ClickHouseParser::ON - 64))\n-        | (1ULL << (ClickHouseParser::OPTIMIZE - 64))\n-        | (1ULL << (ClickHouseParser::OR - 64))\n-        | (1ULL << (ClickHouseParser::ORDER - 64))\n-        | (1ULL << (ClickHouseParser::OUTER - 64))\n-        | (1ULL << (ClickHouseParser::OUTFILE - 64))\n-        | (1ULL << (ClickHouseParser::PARTITION - 64))\n-        | (1ULL << (ClickHouseParser::POPULATE - 64))\n-        | (1ULL << (ClickHouseParser::PREWHERE - 64))\n-        | (1ULL << (ClickHouseParser::PRIMARY - 64))\n-        | (1ULL << (ClickHouseParser::QUARTER - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&\n-        ((1ULL << (_la - 128)) & ((1ULL << (ClickHouseParser::RANGE - 128))\n-        | (1ULL << (ClickHouseParser::RELOAD - 128))\n-        | (1ULL << (ClickHouseParser::REMOVE - 128))\n-        | (1ULL << (ClickHouseParser::RENAME - 128))\n-        | (1ULL << (ClickHouseParser::REPLACE - 128))\n-        | (1ULL << (ClickHouseParser::REPLICA - 128))\n-        | (1ULL << (ClickHouseParser::REPLICATED - 128))\n-        | (1ULL << (ClickHouseParser::RIGHT - 128))\n-        | (1ULL << (ClickHouseParser::ROLLUP - 128))\n-        | (1ULL << (ClickHouseParser::SAMPLE - 128))\n-        | (1ULL << (ClickHouseParser::SECOND - 128))\n-        | (1ULL << (ClickHouseParser::SELECT - 128))\n-        | (1ULL << (ClickHouseParser::SEMI - 128))\n-        | (1ULL << (ClickHouseParser::SENDS - 128))\n-        | (1ULL << (ClickHouseParser::SET - 128))\n-        | (1ULL << (ClickHouseParser::SETTINGS - 128))\n-        | (1ULL << (ClickHouseParser::SHOW - 128))\n-        | (1ULL << (ClickHouseParser::SOURCE - 128))\n-        | (1ULL << (ClickHouseParser::START - 128))\n-        | (1ULL << (ClickHouseParser::STOP - 128))\n-        | (1ULL << (ClickHouseParser::SUBSTRING - 128))\n-        | (1ULL << (ClickHouseParser::SYNC - 128))\n-        | (1ULL << (ClickHouseParser::SYNTAX - 128))\n-        | (1ULL << (ClickHouseParser::SYSTEM - 128))\n-        | (1ULL << (ClickHouseParser::TABLE - 128))\n-        | (1ULL << (ClickHouseParser::TABLES - 128))\n-        | (1ULL << (ClickHouseParser::TEMPORARY - 128))\n-        | (1ULL << (ClickHouseParser::TEST - 128))\n-        | (1ULL << (ClickHouseParser::THEN - 128))\n-        | (1ULL << (ClickHouseParser::TIES - 128))\n-        | (1ULL << (ClickHouseParser::TIMEOUT - 128))\n-        | (1ULL << (ClickHouseParser::TIMESTAMP - 128))\n-        | (1ULL << (ClickHouseParser::TO - 128))\n-        | (1ULL << (ClickHouseParser::TOP - 128))\n-        | (1ULL << (ClickHouseParser::TOTALS - 128))\n-        | (1ULL << (ClickHouseParser::TRAILING - 128))\n-        | (1ULL << (ClickHouseParser::TRIM - 128))\n-        | (1ULL << (ClickHouseParser::TRUNCATE - 128))\n-        | (1ULL << (ClickHouseParser::TTL - 128))\n-        | (1ULL << (ClickHouseParser::TYPE - 128))\n-        | (1ULL << (ClickHouseParser::UNION - 128))\n-        | (1ULL << (ClickHouseParser::UPDATE - 128))\n-        | (1ULL << (ClickHouseParser::USE - 128))\n-        | (1ULL << (ClickHouseParser::USING - 128))\n-        | (1ULL << (ClickHouseParser::UUID - 128))\n-        | (1ULL << (ClickHouseParser::VALUES - 128))\n-        | (1ULL << (ClickHouseParser::VIEW - 128))\n-        | (1ULL << (ClickHouseParser::VOLUME - 128))\n-        | (1ULL << (ClickHouseParser::WATCH - 128))\n-        | (1ULL << (ClickHouseParser::WEEK - 128))\n-        | (1ULL << (ClickHouseParser::WHEN - 128))\n-        | (1ULL << (ClickHouseParser::WHERE - 128))\n-        | (1ULL << (ClickHouseParser::WITH - 128))\n-        | (1ULL << (ClickHouseParser::YEAR - 128))\n-        | (1ULL << (ClickHouseParser::JSON_FALSE - 128))\n-        | (1ULL << (ClickHouseParser::JSON_TRUE - 128))\n-        | (1ULL << (ClickHouseParser::IDENTIFIER - 128))\n-        | (1ULL << (ClickHouseParser::FLOATING_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::OCTAL_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::DECIMAL_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::HEXADECIMAL_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::STRING_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::ASTERISK - 128)))) != 0) || ((((_la - 197) & ~ 0x3fULL) == 0) &&\n-        ((1ULL << (_la - 197)) & ((1ULL << (ClickHouseParser::DASH - 197))\n-        | (1ULL << (ClickHouseParser::DOT - 197))\n-        | (1ULL << (ClickHouseParser::LBRACKET - 197))\n-        | (1ULL << (ClickHouseParser::LPAREN - 197))\n-        | (1ULL << (ClickHouseParser::PLUS - 197)))) != 0)) {\n-        setState(885);\n-        columnExprList();\n-      }\n-      setState(888);\n-      match(ClickHouseParser::RPAREN);\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- TableElementExprContext ------------------------------------------------------------------\n-\n-ClickHouseParser::TableElementExprContext::TableElementExprContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-\n-size_t ClickHouseParser::TableElementExprContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleTableElementExpr;\n-}\n-\n-void ClickHouseParser::TableElementExprContext::copyFrom(TableElementExprContext *ctx) {\n-  ParserRuleContext::copyFrom(ctx);\n-}\n-\n-//----------------- TableElementExprProjectionContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::TableElementExprProjectionContext::PROJECTION() {\n-  return getToken(ClickHouseParser::PROJECTION, 0);\n-}\n-\n-ClickHouseParser::TableProjectionDfntContext* ClickHouseParser::TableElementExprProjectionContext::tableProjectionDfnt() {\n-  return getRuleContext<ClickHouseParser::TableProjectionDfntContext>(0);\n-}\n-\n-ClickHouseParser::TableElementExprProjectionContext::TableElementExprProjectionContext(TableElementExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::TableElementExprProjectionContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitTableElementExprProjection(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- TableElementExprConstraintContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::TableElementExprConstraintContext::CONSTRAINT() {\n-  return getToken(ClickHouseParser::CONSTRAINT, 0);\n-}\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::TableElementExprConstraintContext::identifier() {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TableElementExprConstraintContext::CHECK() {\n-  return getToken(ClickHouseParser::CHECK, 0);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::TableElementExprConstraintContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-ClickHouseParser::TableElementExprConstraintContext::TableElementExprConstraintContext(TableElementExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::TableElementExprConstraintContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitTableElementExprConstraint(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- TableElementExprColumnContext ------------------------------------------------------------------\n-\n-ClickHouseParser::TableColumnDfntContext* ClickHouseParser::TableElementExprColumnContext::tableColumnDfnt() {\n-  return getRuleContext<ClickHouseParser::TableColumnDfntContext>(0);\n-}\n-\n-ClickHouseParser::TableElementExprColumnContext::TableElementExprColumnContext(TableElementExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::TableElementExprColumnContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitTableElementExprColumn(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- TableElementExprIndexContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::TableElementExprIndexContext::INDEX() {\n-  return getToken(ClickHouseParser::INDEX, 0);\n-}\n-\n-ClickHouseParser::TableIndexDfntContext* ClickHouseParser::TableElementExprIndexContext::tableIndexDfnt() {\n-  return getRuleContext<ClickHouseParser::TableIndexDfntContext>(0);\n-}\n-\n-ClickHouseParser::TableElementExprIndexContext::TableElementExprIndexContext(TableElementExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::TableElementExprIndexContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitTableElementExprIndex(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-ClickHouseParser::TableElementExprContext* ClickHouseParser::tableElementExpr() {\n-  TableElementExprContext *_localctx = _tracker.createInstance<TableElementExprContext>(_ctx, getState());\n-  enterRule(_localctx, 64, ClickHouseParser::RuleTableElementExpr);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(901);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx)) {\n-    case 1: {\n-      _localctx = dynamic_cast<TableElementExprContext *>(_tracker.createInstance<ClickHouseParser::TableElementExprColumnContext>(_localctx));\n-      enterOuterAlt(_localctx, 1);\n-      setState(891);\n-      tableColumnDfnt();\n-      break;\n-    }\n-\n-    case 2: {\n-      _localctx = dynamic_cast<TableElementExprContext *>(_tracker.createInstance<ClickHouseParser::TableElementExprConstraintContext>(_localctx));\n-      enterOuterAlt(_localctx, 2);\n-      setState(892);\n-      match(ClickHouseParser::CONSTRAINT);\n-      setState(893);\n-      identifier();\n-      setState(894);\n-      match(ClickHouseParser::CHECK);\n-      setState(895);\n-      columnExpr(0);\n-      break;\n-    }\n-\n-    case 3: {\n-      _localctx = dynamic_cast<TableElementExprContext *>(_tracker.createInstance<ClickHouseParser::TableElementExprIndexContext>(_localctx));\n-      enterOuterAlt(_localctx, 3);\n-      setState(897);\n-      match(ClickHouseParser::INDEX);\n-      setState(898);\n-      tableIndexDfnt();\n-      break;\n-    }\n-\n-    case 4: {\n-      _localctx = dynamic_cast<TableElementExprContext *>(_tracker.createInstance<ClickHouseParser::TableElementExprProjectionContext>(_localctx));\n-      enterOuterAlt(_localctx, 4);\n-      setState(899);\n-      match(ClickHouseParser::PROJECTION);\n-      setState(900);\n-      tableProjectionDfnt();\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- TableColumnDfntContext ------------------------------------------------------------------\n-\n-ClickHouseParser::TableColumnDfntContext::TableColumnDfntContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::TableColumnDfntContext::nestedIdentifier() {\n-  return getRuleContext<ClickHouseParser::NestedIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::ColumnTypeExprContext* ClickHouseParser::TableColumnDfntContext::columnTypeExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnTypeExprContext>(0);\n-}\n-\n-ClickHouseParser::TableColumnPropertyExprContext* ClickHouseParser::TableColumnDfntContext::tableColumnPropertyExpr() {\n-  return getRuleContext<ClickHouseParser::TableColumnPropertyExprContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TableColumnDfntContext::COMMENT() {\n-  return getToken(ClickHouseParser::COMMENT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TableColumnDfntContext::STRING_LITERAL() {\n-  return getToken(ClickHouseParser::STRING_LITERAL, 0);\n-}\n-\n-ClickHouseParser::CodecExprContext* ClickHouseParser::TableColumnDfntContext::codecExpr() {\n-  return getRuleContext<ClickHouseParser::CodecExprContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TableColumnDfntContext::TTL() {\n-  return getToken(ClickHouseParser::TTL, 0);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::TableColumnDfntContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::TableColumnDfntContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleTableColumnDfnt;\n-}\n-\n-antlrcpp::Any ClickHouseParser::TableColumnDfntContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitTableColumnDfnt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::TableColumnDfntContext* ClickHouseParser::tableColumnDfnt() {\n-  TableColumnDfntContext *_localctx = _tracker.createInstance<TableColumnDfntContext>(_ctx, getState());\n-  enterRule(_localctx, 66, ClickHouseParser::RuleTableColumnDfnt);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(935);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx)) {\n-    case 1: {\n-      enterOuterAlt(_localctx, 1);\n-      setState(903);\n-      nestedIdentifier();\n-      setState(904);\n-      columnTypeExpr();\n-      setState(906);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::ALIAS\n-\n-      || _la == ClickHouseParser::DEFAULT || _la == ClickHouseParser::MATERIALIZED) {\n-        setState(905);\n-        tableColumnPropertyExpr();\n-      }\n-      setState(910);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::COMMENT) {\n-        setState(908);\n-        match(ClickHouseParser::COMMENT);\n-        setState(909);\n-        match(ClickHouseParser::STRING_LITERAL);\n-      }\n-      setState(913);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::CODEC) {\n-        setState(912);\n-        codecExpr();\n-      }\n-      setState(917);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::TTL) {\n-        setState(915);\n-        match(ClickHouseParser::TTL);\n-        setState(916);\n-        columnExpr(0);\n-      }\n-      break;\n-    }\n-\n-    case 2: {\n-      enterOuterAlt(_localctx, 2);\n-      setState(919);\n-      nestedIdentifier();\n-      setState(921);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx)) {\n-      case 1: {\n-        setState(920);\n-        columnTypeExpr();\n-        break;\n-      }\n-\n-      }\n-      setState(923);\n-      tableColumnPropertyExpr();\n-      setState(926);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::COMMENT) {\n-        setState(924);\n-        match(ClickHouseParser::COMMENT);\n-        setState(925);\n-        match(ClickHouseParser::STRING_LITERAL);\n-      }\n-      setState(929);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::CODEC) {\n-        setState(928);\n-        codecExpr();\n-      }\n-      setState(933);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::TTL) {\n-        setState(931);\n-        match(ClickHouseParser::TTL);\n-        setState(932);\n-        columnExpr(0);\n-      }\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- TableColumnPropertyExprContext ------------------------------------------------------------------\n-\n-ClickHouseParser::TableColumnPropertyExprContext::TableColumnPropertyExprContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::TableColumnPropertyExprContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TableColumnPropertyExprContext::DEFAULT() {\n-  return getToken(ClickHouseParser::DEFAULT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TableColumnPropertyExprContext::MATERIALIZED() {\n-  return getToken(ClickHouseParser::MATERIALIZED, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TableColumnPropertyExprContext::ALIAS() {\n-  return getToken(ClickHouseParser::ALIAS, 0);\n-}\n-\n-\n-size_t ClickHouseParser::TableColumnPropertyExprContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleTableColumnPropertyExpr;\n-}\n-\n-antlrcpp::Any ClickHouseParser::TableColumnPropertyExprContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitTableColumnPropertyExpr(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::TableColumnPropertyExprContext* ClickHouseParser::tableColumnPropertyExpr() {\n-  TableColumnPropertyExprContext *_localctx = _tracker.createInstance<TableColumnPropertyExprContext>(_ctx, getState());\n-  enterRule(_localctx, 68, ClickHouseParser::RuleTableColumnPropertyExpr);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(937);\n-    _la = _input->LA(1);\n-    if (!(_la == ClickHouseParser::ALIAS\n-\n-    || _la == ClickHouseParser::DEFAULT || _la == ClickHouseParser::MATERIALIZED)) {\n-    _errHandler->recoverInline(this);\n-    }\n-    else {\n-      _errHandler->reportMatch(this);\n-      consume();\n-    }\n-    setState(938);\n-    columnExpr(0);\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- TableIndexDfntContext ------------------------------------------------------------------\n-\n-ClickHouseParser::TableIndexDfntContext::TableIndexDfntContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::TableIndexDfntContext::nestedIdentifier() {\n-  return getRuleContext<ClickHouseParser::NestedIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::TableIndexDfntContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TableIndexDfntContext::TYPE() {\n-  return getToken(ClickHouseParser::TYPE, 0);\n-}\n-\n-ClickHouseParser::ColumnTypeExprContext* ClickHouseParser::TableIndexDfntContext::columnTypeExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnTypeExprContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TableIndexDfntContext::GRANULARITY() {\n-  return getToken(ClickHouseParser::GRANULARITY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TableIndexDfntContext::DECIMAL_LITERAL() {\n-  return getToken(ClickHouseParser::DECIMAL_LITERAL, 0);\n-}\n-\n-\n-size_t ClickHouseParser::TableIndexDfntContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleTableIndexDfnt;\n-}\n-\n-antlrcpp::Any ClickHouseParser::TableIndexDfntContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitTableIndexDfnt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::TableIndexDfntContext* ClickHouseParser::tableIndexDfnt() {\n-  TableIndexDfntContext *_localctx = _tracker.createInstance<TableIndexDfntContext>(_ctx, getState());\n-  enterRule(_localctx, 70, ClickHouseParser::RuleTableIndexDfnt);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(940);\n-    nestedIdentifier();\n-    setState(941);\n-    columnExpr(0);\n-    setState(942);\n-    match(ClickHouseParser::TYPE);\n-    setState(943);\n-    columnTypeExpr();\n-    setState(944);\n-    match(ClickHouseParser::GRANULARITY);\n-    setState(945);\n-    match(ClickHouseParser::DECIMAL_LITERAL);\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- TableProjectionDfntContext ------------------------------------------------------------------\n-\n-ClickHouseParser::TableProjectionDfntContext::TableProjectionDfntContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::TableProjectionDfntContext::nestedIdentifier() {\n-  return getRuleContext<ClickHouseParser::NestedIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::ProjectionSelectStmtContext* ClickHouseParser::TableProjectionDfntContext::projectionSelectStmt() {\n-  return getRuleContext<ClickHouseParser::ProjectionSelectStmtContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::TableProjectionDfntContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleTableProjectionDfnt;\n-}\n-\n-antlrcpp::Any ClickHouseParser::TableProjectionDfntContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitTableProjectionDfnt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::TableProjectionDfntContext* ClickHouseParser::tableProjectionDfnt() {\n-  TableProjectionDfntContext *_localctx = _tracker.createInstance<TableProjectionDfntContext>(_ctx, getState());\n-  enterRule(_localctx, 72, ClickHouseParser::RuleTableProjectionDfnt);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(947);\n-    nestedIdentifier();\n-    setState(948);\n-    projectionSelectStmt();\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- CodecExprContext ------------------------------------------------------------------\n-\n-ClickHouseParser::CodecExprContext::CodecExprContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CodecExprContext::CODEC() {\n-  return getToken(ClickHouseParser::CODEC, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CodecExprContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-std::vector<ClickHouseParser::CodecArgExprContext *> ClickHouseParser::CodecExprContext::codecArgExpr() {\n-  return getRuleContexts<ClickHouseParser::CodecArgExprContext>();\n-}\n-\n-ClickHouseParser::CodecArgExprContext* ClickHouseParser::CodecExprContext::codecArgExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::CodecArgExprContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CodecExprContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::CodecExprContext::COMMA() {\n-  return getTokens(ClickHouseParser::COMMA);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CodecExprContext::COMMA(size_t i) {\n-  return getToken(ClickHouseParser::COMMA, i);\n-}\n-\n-\n-size_t ClickHouseParser::CodecExprContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleCodecExpr;\n-}\n-\n-antlrcpp::Any ClickHouseParser::CodecExprContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitCodecExpr(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::CodecExprContext* ClickHouseParser::codecExpr() {\n-  CodecExprContext *_localctx = _tracker.createInstance<CodecExprContext>(_ctx, getState());\n-  enterRule(_localctx, 74, ClickHouseParser::RuleCodecExpr);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(950);\n-    match(ClickHouseParser::CODEC);\n-    setState(951);\n-    match(ClickHouseParser::LPAREN);\n-    setState(952);\n-    codecArgExpr();\n-    setState(957);\n-    _errHandler->sync(this);\n-    _la = _input->LA(1);\n-    while (_la == ClickHouseParser::COMMA) {\n-      setState(953);\n-      match(ClickHouseParser::COMMA);\n-      setState(954);\n-      codecArgExpr();\n-      setState(959);\n-      _errHandler->sync(this);\n-      _la = _input->LA(1);\n-    }\n-    setState(960);\n-    match(ClickHouseParser::RPAREN);\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- CodecArgExprContext ------------------------------------------------------------------\n-\n-ClickHouseParser::CodecArgExprContext::CodecArgExprContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::CodecArgExprContext::identifier() {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CodecArgExprContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::CodecArgExprContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-ClickHouseParser::ColumnExprListContext* ClickHouseParser::CodecArgExprContext::columnExprList() {\n-  return getRuleContext<ClickHouseParser::ColumnExprListContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::CodecArgExprContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleCodecArgExpr;\n-}\n-\n-antlrcpp::Any ClickHouseParser::CodecArgExprContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitCodecArgExpr(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::CodecArgExprContext* ClickHouseParser::codecArgExpr() {\n-  CodecArgExprContext *_localctx = _tracker.createInstance<CodecArgExprContext>(_ctx, getState());\n-  enterRule(_localctx, 76, ClickHouseParser::RuleCodecArgExpr);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(962);\n-    identifier();\n-    setState(968);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::LPAREN) {\n-      setState(963);\n-      match(ClickHouseParser::LPAREN);\n-      setState(965);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if ((((_la & ~ 0x3fULL) == 0) &&\n-        ((1ULL << _la) & ((1ULL << ClickHouseParser::AFTER)\n-        | (1ULL << ClickHouseParser::ALIAS)\n-        | (1ULL << ClickHouseParser::ALL)\n-        | (1ULL << ClickHouseParser::ALTER)\n-        | (1ULL << ClickHouseParser::AND)\n-        | (1ULL << ClickHouseParser::ANTI)\n-        | (1ULL << ClickHouseParser::ANY)\n-        | (1ULL << ClickHouseParser::ARRAY)\n-        | (1ULL << ClickHouseParser::AS)\n-        | (1ULL << ClickHouseParser::ASCENDING)\n-        | (1ULL << ClickHouseParser::ASOF)\n-        | (1ULL << ClickHouseParser::AST)\n-        | (1ULL << ClickHouseParser::ASYNC)\n-        | (1ULL << ClickHouseParser::ATTACH)\n-        | (1ULL << ClickHouseParser::BETWEEN)\n-        | (1ULL << ClickHouseParser::BOTH)\n-        | (1ULL << ClickHouseParser::BY)\n-        | (1ULL << ClickHouseParser::CASE)\n-        | (1ULL << ClickHouseParser::CAST)\n-        | (1ULL << ClickHouseParser::CHECK)\n-        | (1ULL << ClickHouseParser::CLEAR)\n-        | (1ULL << ClickHouseParser::CLUSTER)\n-        | (1ULL << ClickHouseParser::CODEC)\n-        | (1ULL << ClickHouseParser::COLLATE)\n-        | (1ULL << ClickHouseParser::COLUMN)\n-        | (1ULL << ClickHouseParser::COMMENT)\n-        | (1ULL << ClickHouseParser::CONSTRAINT)\n-        | (1ULL << ClickHouseParser::CREATE)\n-        | (1ULL << ClickHouseParser::CROSS)\n-        | (1ULL << ClickHouseParser::CUBE)\n-        | (1ULL << ClickHouseParser::DATABASE)\n-        | (1ULL << ClickHouseParser::DATABASES)\n-        | (1ULL << ClickHouseParser::DATE)\n-        | (1ULL << ClickHouseParser::DAY)\n-        | (1ULL << ClickHouseParser::DEDUPLICATE)\n-        | (1ULL << ClickHouseParser::DEFAULT)\n-        | (1ULL << ClickHouseParser::DELAY)\n-        | (1ULL << ClickHouseParser::DELETE)\n-        | (1ULL << ClickHouseParser::DESC)\n-        | (1ULL << ClickHouseParser::DESCENDING)\n-        | (1ULL << ClickHouseParser::DESCRIBE)\n-        | (1ULL << ClickHouseParser::DETACH)\n-        | (1ULL << ClickHouseParser::DICTIONARIES)\n-        | (1ULL << ClickHouseParser::DICTIONARY)\n-        | (1ULL << ClickHouseParser::DISK)\n-        | (1ULL << ClickHouseParser::DISTINCT)\n-        | (1ULL << ClickHouseParser::DISTRIBUTED)\n-        | (1ULL << ClickHouseParser::DROP)\n-        | (1ULL << ClickHouseParser::ELSE)\n-        | (1ULL << ClickHouseParser::END)\n-        | (1ULL << ClickHouseParser::ENGINE)\n-        | (1ULL << ClickHouseParser::EVENTS)\n-        | (1ULL << ClickHouseParser::EXISTS)\n-        | (1ULL << ClickHouseParser::EXPLAIN)\n-        | (1ULL << ClickHouseParser::EXPRESSION)\n-        | (1ULL << ClickHouseParser::EXTRACT)\n-        | (1ULL << ClickHouseParser::FETCHES)\n-        | (1ULL << ClickHouseParser::FINAL)\n-        | (1ULL << ClickHouseParser::FIRST)\n-        | (1ULL << ClickHouseParser::FLUSH)\n-        | (1ULL << ClickHouseParser::FOR)\n-        | (1ULL << ClickHouseParser::FORMAT))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&\n-        ((1ULL << (_la - 64)) & ((1ULL << (ClickHouseParser::FREEZE - 64))\n-        | (1ULL << (ClickHouseParser::FROM - 64))\n-        | (1ULL << (ClickHouseParser::FULL - 64))\n-        | (1ULL << (ClickHouseParser::FUNCTION - 64))\n-        | (1ULL << (ClickHouseParser::GLOBAL - 64))\n-        | (1ULL << (ClickHouseParser::GRANULARITY - 64))\n-        | (1ULL << (ClickHouseParser::GROUP - 64))\n-        | (1ULL << (ClickHouseParser::HAVING - 64))\n-        | (1ULL << (ClickHouseParser::HIERARCHICAL - 64))\n-        | (1ULL << (ClickHouseParser::HOUR - 64))\n-        | (1ULL << (ClickHouseParser::ID - 64))\n-        | (1ULL << (ClickHouseParser::IF - 64))\n-        | (1ULL << (ClickHouseParser::ILIKE - 64))\n-        | (1ULL << (ClickHouseParser::IN - 64))\n-        | (1ULL << (ClickHouseParser::INDEX - 64))\n-        | (1ULL << (ClickHouseParser::INF - 64))\n-        | (1ULL << (ClickHouseParser::INJECTIVE - 64))\n-        | (1ULL << (ClickHouseParser::INNER - 64))\n-        | (1ULL << (ClickHouseParser::INSERT - 64))\n-        | (1ULL << (ClickHouseParser::INTERVAL - 64))\n-        | (1ULL << (ClickHouseParser::INTO - 64))\n-        | (1ULL << (ClickHouseParser::IS - 64))\n-        | (1ULL << (ClickHouseParser::IS_OBJECT_ID - 64))\n-        | (1ULL << (ClickHouseParser::JOIN - 64))\n-        | (1ULL << (ClickHouseParser::KEY - 64))\n-        | (1ULL << (ClickHouseParser::KILL - 64))\n-        | (1ULL << (ClickHouseParser::LAST - 64))\n-        | (1ULL << (ClickHouseParser::LAYOUT - 64))\n-        | (1ULL << (ClickHouseParser::LEADING - 64))\n-        | (1ULL << (ClickHouseParser::LEFT - 64))\n-        | (1ULL << (ClickHouseParser::LIFETIME - 64))\n-        | (1ULL << (ClickHouseParser::LIKE - 64))\n-        | (1ULL << (ClickHouseParser::LIMIT - 64))\n-        | (1ULL << (ClickHouseParser::LIVE - 64))\n-        | (1ULL << (ClickHouseParser::LOCAL - 64))\n-        | (1ULL << (ClickHouseParser::LOGS - 64))\n-        | (1ULL << (ClickHouseParser::MATERIALIZE - 64))\n-        | (1ULL << (ClickHouseParser::MATERIALIZED - 64))\n-        | (1ULL << (ClickHouseParser::MAX - 64))\n-        | (1ULL << (ClickHouseParser::MERGES - 64))\n-        | (1ULL << (ClickHouseParser::MIN - 64))\n-        | (1ULL << (ClickHouseParser::MINUTE - 64))\n-        | (1ULL << (ClickHouseParser::MODIFY - 64))\n-        | (1ULL << (ClickHouseParser::MONTH - 64))\n-        | (1ULL << (ClickHouseParser::MOVE - 64))\n-        | (1ULL << (ClickHouseParser::MUTATION - 64))\n-        | (1ULL << (ClickHouseParser::NAN_SQL - 64))\n-        | (1ULL << (ClickHouseParser::NO - 64))\n-        | (1ULL << (ClickHouseParser::NOT - 64))\n-        | (1ULL << (ClickHouseParser::NULL_SQL - 64))\n-        | (1ULL << (ClickHouseParser::NULLS - 64))\n-        | (1ULL << (ClickHouseParser::OFFSET - 64))\n-        | (1ULL << (ClickHouseParser::ON - 64))\n-        | (1ULL << (ClickHouseParser::OPTIMIZE - 64))\n-        | (1ULL << (ClickHouseParser::OR - 64))\n-        | (1ULL << (ClickHouseParser::ORDER - 64))\n-        | (1ULL << (ClickHouseParser::OUTER - 64))\n-        | (1ULL << (ClickHouseParser::OUTFILE - 64))\n-        | (1ULL << (ClickHouseParser::PARTITION - 64))\n-        | (1ULL << (ClickHouseParser::POPULATE - 64))\n-        | (1ULL << (ClickHouseParser::PREWHERE - 64))\n-        | (1ULL << (ClickHouseParser::PRIMARY - 64))\n-        | (1ULL << (ClickHouseParser::QUARTER - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&\n-        ((1ULL << (_la - 128)) & ((1ULL << (ClickHouseParser::RANGE - 128))\n-        | (1ULL << (ClickHouseParser::RELOAD - 128))\n-        | (1ULL << (ClickHouseParser::REMOVE - 128))\n-        | (1ULL << (ClickHouseParser::RENAME - 128))\n-        | (1ULL << (ClickHouseParser::REPLACE - 128))\n-        | (1ULL << (ClickHouseParser::REPLICA - 128))\n-        | (1ULL << (ClickHouseParser::REPLICATED - 128))\n-        | (1ULL << (ClickHouseParser::RIGHT - 128))\n-        | (1ULL << (ClickHouseParser::ROLLUP - 128))\n-        | (1ULL << (ClickHouseParser::SAMPLE - 128))\n-        | (1ULL << (ClickHouseParser::SECOND - 128))\n-        | (1ULL << (ClickHouseParser::SELECT - 128))\n-        | (1ULL << (ClickHouseParser::SEMI - 128))\n-        | (1ULL << (ClickHouseParser::SENDS - 128))\n-        | (1ULL << (ClickHouseParser::SET - 128))\n-        | (1ULL << (ClickHouseParser::SETTINGS - 128))\n-        | (1ULL << (ClickHouseParser::SHOW - 128))\n-        | (1ULL << (ClickHouseParser::SOURCE - 128))\n-        | (1ULL << (ClickHouseParser::START - 128))\n-        | (1ULL << (ClickHouseParser::STOP - 128))\n-        | (1ULL << (ClickHouseParser::SUBSTRING - 128))\n-        | (1ULL << (ClickHouseParser::SYNC - 128))\n-        | (1ULL << (ClickHouseParser::SYNTAX - 128))\n-        | (1ULL << (ClickHouseParser::SYSTEM - 128))\n-        | (1ULL << (ClickHouseParser::TABLE - 128))\n-        | (1ULL << (ClickHouseParser::TABLES - 128))\n-        | (1ULL << (ClickHouseParser::TEMPORARY - 128))\n-        | (1ULL << (ClickHouseParser::TEST - 128))\n-        | (1ULL << (ClickHouseParser::THEN - 128))\n-        | (1ULL << (ClickHouseParser::TIES - 128))\n-        | (1ULL << (ClickHouseParser::TIMEOUT - 128))\n-        | (1ULL << (ClickHouseParser::TIMESTAMP - 128))\n-        | (1ULL << (ClickHouseParser::TO - 128))\n-        | (1ULL << (ClickHouseParser::TOP - 128))\n-        | (1ULL << (ClickHouseParser::TOTALS - 128))\n-        | (1ULL << (ClickHouseParser::TRAILING - 128))\n-        | (1ULL << (ClickHouseParser::TRIM - 128))\n-        | (1ULL << (ClickHouseParser::TRUNCATE - 128))\n-        | (1ULL << (ClickHouseParser::TTL - 128))\n-        | (1ULL << (ClickHouseParser::TYPE - 128))\n-        | (1ULL << (ClickHouseParser::UNION - 128))\n-        | (1ULL << (ClickHouseParser::UPDATE - 128))\n-        | (1ULL << (ClickHouseParser::USE - 128))\n-        | (1ULL << (ClickHouseParser::USING - 128))\n-        | (1ULL << (ClickHouseParser::UUID - 128))\n-        | (1ULL << (ClickHouseParser::VALUES - 128))\n-        | (1ULL << (ClickHouseParser::VIEW - 128))\n-        | (1ULL << (ClickHouseParser::VOLUME - 128))\n-        | (1ULL << (ClickHouseParser::WATCH - 128))\n-        | (1ULL << (ClickHouseParser::WEEK - 128))\n-        | (1ULL << (ClickHouseParser::WHEN - 128))\n-        | (1ULL << (ClickHouseParser::WHERE - 128))\n-        | (1ULL << (ClickHouseParser::WITH - 128))\n-        | (1ULL << (ClickHouseParser::YEAR - 128))\n-        | (1ULL << (ClickHouseParser::JSON_FALSE - 128))\n-        | (1ULL << (ClickHouseParser::JSON_TRUE - 128))\n-        | (1ULL << (ClickHouseParser::IDENTIFIER - 128))\n-        | (1ULL << (ClickHouseParser::FLOATING_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::OCTAL_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::DECIMAL_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::HEXADECIMAL_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::STRING_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::ASTERISK - 128)))) != 0) || ((((_la - 197) & ~ 0x3fULL) == 0) &&\n-        ((1ULL << (_la - 197)) & ((1ULL << (ClickHouseParser::DASH - 197))\n-        | (1ULL << (ClickHouseParser::DOT - 197))\n-        | (1ULL << (ClickHouseParser::LBRACKET - 197))\n-        | (1ULL << (ClickHouseParser::LPAREN - 197))\n-        | (1ULL << (ClickHouseParser::PLUS - 197)))) != 0)) {\n-        setState(964);\n-        columnExprList();\n-      }\n-      setState(967);\n-      match(ClickHouseParser::RPAREN);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- TtlExprContext ------------------------------------------------------------------\n-\n-ClickHouseParser::TtlExprContext::TtlExprContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::TtlExprContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TtlExprContext::DELETE() {\n-  return getToken(ClickHouseParser::DELETE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TtlExprContext::TO() {\n-  return getToken(ClickHouseParser::TO, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TtlExprContext::DISK() {\n-  return getToken(ClickHouseParser::DISK, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TtlExprContext::STRING_LITERAL() {\n-  return getToken(ClickHouseParser::STRING_LITERAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TtlExprContext::VOLUME() {\n-  return getToken(ClickHouseParser::VOLUME, 0);\n-}\n-\n-\n-size_t ClickHouseParser::TtlExprContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleTtlExpr;\n-}\n-\n-antlrcpp::Any ClickHouseParser::TtlExprContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitTtlExpr(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::TtlExprContext* ClickHouseParser::ttlExpr() {\n-  TtlExprContext *_localctx = _tracker.createInstance<TtlExprContext>(_ctx, getState());\n-  enterRule(_localctx, 78, ClickHouseParser::RuleTtlExpr);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(970);\n-    columnExpr(0);\n-    setState(978);\n-    _errHandler->sync(this);\n-\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx)) {\n-    case 1: {\n-      setState(971);\n-      match(ClickHouseParser::DELETE);\n-      break;\n-    }\n-\n-    case 2: {\n-      setState(972);\n-      match(ClickHouseParser::TO);\n-      setState(973);\n-      match(ClickHouseParser::DISK);\n-      setState(974);\n-      match(ClickHouseParser::STRING_LITERAL);\n-      break;\n-    }\n-\n-    case 3: {\n-      setState(975);\n-      match(ClickHouseParser::TO);\n-      setState(976);\n-      match(ClickHouseParser::VOLUME);\n-      setState(977);\n-      match(ClickHouseParser::STRING_LITERAL);\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- DescribeStmtContext ------------------------------------------------------------------\n-\n-ClickHouseParser::DescribeStmtContext::DescribeStmtContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::TableExprContext* ClickHouseParser::DescribeStmtContext::tableExpr() {\n-  return getRuleContext<ClickHouseParser::TableExprContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DescribeStmtContext::DESCRIBE() {\n-  return getToken(ClickHouseParser::DESCRIBE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DescribeStmtContext::DESC() {\n-  return getToken(ClickHouseParser::DESC, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DescribeStmtContext::TABLE() {\n-  return getToken(ClickHouseParser::TABLE, 0);\n-}\n-\n-\n-size_t ClickHouseParser::DescribeStmtContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleDescribeStmt;\n-}\n-\n-antlrcpp::Any ClickHouseParser::DescribeStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitDescribeStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::DescribeStmtContext* ClickHouseParser::describeStmt() {\n-  DescribeStmtContext *_localctx = _tracker.createInstance<DescribeStmtContext>(_ctx, getState());\n-  enterRule(_localctx, 80, ClickHouseParser::RuleDescribeStmt);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(980);\n-    _la = _input->LA(1);\n-    if (!(_la == ClickHouseParser::DESC\n-\n-    || _la == ClickHouseParser::DESCRIBE)) {\n-    _errHandler->recoverInline(this);\n-    }\n-    else {\n-      _errHandler->reportMatch(this);\n-      consume();\n-    }\n-    setState(982);\n-    _errHandler->sync(this);\n-\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx)) {\n-    case 1: {\n-      setState(981);\n-      match(ClickHouseParser::TABLE);\n-      break;\n-    }\n-\n-    }\n-    setState(984);\n-    tableExpr(0);\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- DropStmtContext ------------------------------------------------------------------\n-\n-ClickHouseParser::DropStmtContext::DropStmtContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-\n-size_t ClickHouseParser::DropStmtContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleDropStmt;\n-}\n-\n-void ClickHouseParser::DropStmtContext::copyFrom(DropStmtContext *ctx) {\n-  ParserRuleContext::copyFrom(ctx);\n-}\n-\n-//----------------- DropDatabaseStmtContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::DropDatabaseStmtContext::DATABASE() {\n-  return getToken(ClickHouseParser::DATABASE, 0);\n-}\n-\n-ClickHouseParser::DatabaseIdentifierContext* ClickHouseParser::DropDatabaseStmtContext::databaseIdentifier() {\n-  return getRuleContext<ClickHouseParser::DatabaseIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DropDatabaseStmtContext::DETACH() {\n-  return getToken(ClickHouseParser::DETACH, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DropDatabaseStmtContext::DROP() {\n-  return getToken(ClickHouseParser::DROP, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DropDatabaseStmtContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DropDatabaseStmtContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-ClickHouseParser::ClusterClauseContext* ClickHouseParser::DropDatabaseStmtContext::clusterClause() {\n-  return getRuleContext<ClickHouseParser::ClusterClauseContext>(0);\n-}\n-\n-ClickHouseParser::DropDatabaseStmtContext::DropDatabaseStmtContext(DropStmtContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::DropDatabaseStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitDropDatabaseStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- DropTableStmtContext ------------------------------------------------------------------\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::DropTableStmtContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DropTableStmtContext::DETACH() {\n-  return getToken(ClickHouseParser::DETACH, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DropTableStmtContext::DROP() {\n-  return getToken(ClickHouseParser::DROP, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DropTableStmtContext::DICTIONARY() {\n-  return getToken(ClickHouseParser::DICTIONARY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DropTableStmtContext::TABLE() {\n-  return getToken(ClickHouseParser::TABLE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DropTableStmtContext::VIEW() {\n-  return getToken(ClickHouseParser::VIEW, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DropTableStmtContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DropTableStmtContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-ClickHouseParser::ClusterClauseContext* ClickHouseParser::DropTableStmtContext::clusterClause() {\n-  return getRuleContext<ClickHouseParser::ClusterClauseContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DropTableStmtContext::NO() {\n-  return getToken(ClickHouseParser::NO, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DropTableStmtContext::DELAY() {\n-  return getToken(ClickHouseParser::DELAY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DropTableStmtContext::TEMPORARY() {\n-  return getToken(ClickHouseParser::TEMPORARY, 0);\n-}\n-\n-ClickHouseParser::DropTableStmtContext::DropTableStmtContext(DropStmtContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::DropTableStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitDropTableStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-ClickHouseParser::DropStmtContext* ClickHouseParser::dropStmt() {\n-  DropStmtContext *_localctx = _tracker.createInstance<DropStmtContext>(_ctx, getState());\n-  enterRule(_localctx, 82, ClickHouseParser::RuleDropStmt);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(1017);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 115, _ctx)) {\n-    case 1: {\n-      _localctx = dynamic_cast<DropStmtContext *>(_tracker.createInstance<ClickHouseParser::DropDatabaseStmtContext>(_localctx));\n-      enterOuterAlt(_localctx, 1);\n-      setState(986);\n-      _la = _input->LA(1);\n-      if (!(_la == ClickHouseParser::DETACH\n-\n-      || _la == ClickHouseParser::DROP)) {\n-      _errHandler->recoverInline(this);\n-      }\n-      else {\n-        _errHandler->reportMatch(this);\n-        consume();\n-      }\n-      setState(987);\n-      match(ClickHouseParser::DATABASE);\n-      setState(990);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 108, _ctx)) {\n-      case 1: {\n-        setState(988);\n-        match(ClickHouseParser::IF);\n-        setState(989);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(992);\n-      databaseIdentifier();\n-      setState(994);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::ON) {\n-        setState(993);\n-        clusterClause();\n-      }\n-      break;\n-    }\n-\n-    case 2: {\n-      _localctx = dynamic_cast<DropStmtContext *>(_tracker.createInstance<ClickHouseParser::DropTableStmtContext>(_localctx));\n-      enterOuterAlt(_localctx, 2);\n-      setState(996);\n-      _la = _input->LA(1);\n-      if (!(_la == ClickHouseParser::DETACH\n-\n-      || _la == ClickHouseParser::DROP)) {\n-      _errHandler->recoverInline(this);\n-      }\n-      else {\n-        _errHandler->reportMatch(this);\n-        consume();\n-      }\n-      setState(1003);\n-      _errHandler->sync(this);\n-      switch (_input->LA(1)) {\n-        case ClickHouseParser::DICTIONARY: {\n-          setState(997);\n-          match(ClickHouseParser::DICTIONARY);\n-          break;\n-        }\n-\n-        case ClickHouseParser::TABLE:\n-        case ClickHouseParser::TEMPORARY: {\n-          setState(999);\n-          _errHandler->sync(this);\n-\n-          _la = _input->LA(1);\n-          if (_la == ClickHouseParser::TEMPORARY) {\n-            setState(998);\n-            match(ClickHouseParser::TEMPORARY);\n-          }\n-          setState(1001);\n-          match(ClickHouseParser::TABLE);\n-          break;\n-        }\n-\n-        case ClickHouseParser::VIEW: {\n-          setState(1002);\n-          match(ClickHouseParser::VIEW);\n-          break;\n-        }\n-\n-      default:\n-        throw NoViableAltException(this);\n-      }\n-      setState(1007);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 112, _ctx)) {\n-      case 1: {\n-        setState(1005);\n-        match(ClickHouseParser::IF);\n-        setState(1006);\n-        match(ClickHouseParser::EXISTS);\n-        break;\n-      }\n-\n-      }\n-      setState(1009);\n-      tableIdentifier();\n-      setState(1011);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::ON) {\n-        setState(1010);\n-        clusterClause();\n-      }\n-      setState(1015);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::NO) {\n-        setState(1013);\n-        match(ClickHouseParser::NO);\n-        setState(1014);\n-        match(ClickHouseParser::DELAY);\n-      }\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- ExistsStmtContext ------------------------------------------------------------------\n-\n-ClickHouseParser::ExistsStmtContext::ExistsStmtContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-\n-size_t ClickHouseParser::ExistsStmtContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleExistsStmt;\n-}\n-\n-void ClickHouseParser::ExistsStmtContext::copyFrom(ExistsStmtContext *ctx) {\n-  ParserRuleContext::copyFrom(ctx);\n-}\n-\n-//----------------- ExistsTableStmtContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ExistsTableStmtContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::ExistsTableStmtContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ExistsTableStmtContext::DICTIONARY() {\n-  return getToken(ClickHouseParser::DICTIONARY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ExistsTableStmtContext::TABLE() {\n-  return getToken(ClickHouseParser::TABLE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ExistsTableStmtContext::VIEW() {\n-  return getToken(ClickHouseParser::VIEW, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ExistsTableStmtContext::TEMPORARY() {\n-  return getToken(ClickHouseParser::TEMPORARY, 0);\n-}\n-\n-ClickHouseParser::ExistsTableStmtContext::ExistsTableStmtContext(ExistsStmtContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ExistsTableStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitExistsTableStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ExistsDatabaseStmtContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ExistsDatabaseStmtContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ExistsDatabaseStmtContext::DATABASE() {\n-  return getToken(ClickHouseParser::DATABASE, 0);\n-}\n-\n-ClickHouseParser::DatabaseIdentifierContext* ClickHouseParser::ExistsDatabaseStmtContext::databaseIdentifier() {\n-  return getRuleContext<ClickHouseParser::DatabaseIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::ExistsDatabaseStmtContext::ExistsDatabaseStmtContext(ExistsStmtContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ExistsDatabaseStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitExistsDatabaseStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-ClickHouseParser::ExistsStmtContext* ClickHouseParser::existsStmt() {\n-  ExistsStmtContext *_localctx = _tracker.createInstance<ExistsStmtContext>(_ctx, getState());\n-  enterRule(_localctx, 84, ClickHouseParser::RuleExistsStmt);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(1032);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 118, _ctx)) {\n-    case 1: {\n-      _localctx = dynamic_cast<ExistsStmtContext *>(_tracker.createInstance<ClickHouseParser::ExistsDatabaseStmtContext>(_localctx));\n-      enterOuterAlt(_localctx, 1);\n-      setState(1019);\n-      match(ClickHouseParser::EXISTS);\n-      setState(1020);\n-      match(ClickHouseParser::DATABASE);\n-      setState(1021);\n-      databaseIdentifier();\n-      break;\n-    }\n-\n-    case 2: {\n-      _localctx = dynamic_cast<ExistsStmtContext *>(_tracker.createInstance<ClickHouseParser::ExistsTableStmtContext>(_localctx));\n-      enterOuterAlt(_localctx, 2);\n-      setState(1022);\n-      match(ClickHouseParser::EXISTS);\n-      setState(1029);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx)) {\n-      case 1: {\n-        setState(1023);\n-        match(ClickHouseParser::DICTIONARY);\n-        break;\n-      }\n-\n-      case 2: {\n-        setState(1025);\n-        _errHandler->sync(this);\n-\n-        _la = _input->LA(1);\n-        if (_la == ClickHouseParser::TEMPORARY) {\n-          setState(1024);\n-          match(ClickHouseParser::TEMPORARY);\n-        }\n-        setState(1027);\n-        match(ClickHouseParser::TABLE);\n-        break;\n-      }\n-\n-      case 3: {\n-        setState(1028);\n-        match(ClickHouseParser::VIEW);\n-        break;\n-      }\n-\n-      }\n-      setState(1031);\n-      tableIdentifier();\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- ExplainStmtContext ------------------------------------------------------------------\n-\n-ClickHouseParser::ExplainStmtContext::ExplainStmtContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-\n-size_t ClickHouseParser::ExplainStmtContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleExplainStmt;\n-}\n-\n-void ClickHouseParser::ExplainStmtContext::copyFrom(ExplainStmtContext *ctx) {\n-  ParserRuleContext::copyFrom(ctx);\n-}\n-\n-//----------------- ExplainSyntaxStmtContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ExplainSyntaxStmtContext::EXPLAIN() {\n-  return getToken(ClickHouseParser::EXPLAIN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ExplainSyntaxStmtContext::SYNTAX() {\n-  return getToken(ClickHouseParser::SYNTAX, 0);\n-}\n-\n-ClickHouseParser::QueryContext* ClickHouseParser::ExplainSyntaxStmtContext::query() {\n-  return getRuleContext<ClickHouseParser::QueryContext>(0);\n-}\n-\n-ClickHouseParser::ExplainSyntaxStmtContext::ExplainSyntaxStmtContext(ExplainStmtContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ExplainSyntaxStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitExplainSyntaxStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ExplainASTStmtContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ExplainASTStmtContext::EXPLAIN() {\n-  return getToken(ClickHouseParser::EXPLAIN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ExplainASTStmtContext::AST() {\n-  return getToken(ClickHouseParser::AST, 0);\n-}\n-\n-ClickHouseParser::QueryContext* ClickHouseParser::ExplainASTStmtContext::query() {\n-  return getRuleContext<ClickHouseParser::QueryContext>(0);\n-}\n-\n-ClickHouseParser::ExplainASTStmtContext::ExplainASTStmtContext(ExplainStmtContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ExplainASTStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitExplainASTStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-ClickHouseParser::ExplainStmtContext* ClickHouseParser::explainStmt() {\n-  ExplainStmtContext *_localctx = _tracker.createInstance<ExplainStmtContext>(_ctx, getState());\n-  enterRule(_localctx, 86, ClickHouseParser::RuleExplainStmt);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(1040);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 119, _ctx)) {\n-    case 1: {\n-      _localctx = dynamic_cast<ExplainStmtContext *>(_tracker.createInstance<ClickHouseParser::ExplainASTStmtContext>(_localctx));\n-      enterOuterAlt(_localctx, 1);\n-      setState(1034);\n-      match(ClickHouseParser::EXPLAIN);\n-      setState(1035);\n-      match(ClickHouseParser::AST);\n-      setState(1036);\n-      query();\n-      break;\n-    }\n-\n-    case 2: {\n-      _localctx = dynamic_cast<ExplainStmtContext *>(_tracker.createInstance<ClickHouseParser::ExplainSyntaxStmtContext>(_localctx));\n-      enterOuterAlt(_localctx, 2);\n-      setState(1037);\n-      match(ClickHouseParser::EXPLAIN);\n-      setState(1038);\n-      match(ClickHouseParser::SYNTAX);\n-      setState(1039);\n-      query();\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- InsertStmtContext ------------------------------------------------------------------\n-\n-ClickHouseParser::InsertStmtContext::InsertStmtContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::InsertStmtContext::INSERT() {\n-  return getToken(ClickHouseParser::INSERT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::InsertStmtContext::INTO() {\n-  return getToken(ClickHouseParser::INTO, 0);\n-}\n-\n-ClickHouseParser::DataClauseContext* ClickHouseParser::InsertStmtContext::dataClause() {\n-  return getRuleContext<ClickHouseParser::DataClauseContext>(0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::InsertStmtContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::InsertStmtContext::FUNCTION() {\n-  return getToken(ClickHouseParser::FUNCTION, 0);\n-}\n-\n-ClickHouseParser::TableFunctionExprContext* ClickHouseParser::InsertStmtContext::tableFunctionExpr() {\n-  return getRuleContext<ClickHouseParser::TableFunctionExprContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::InsertStmtContext::TABLE() {\n-  return getToken(ClickHouseParser::TABLE, 0);\n-}\n-\n-ClickHouseParser::ColumnsClauseContext* ClickHouseParser::InsertStmtContext::columnsClause() {\n-  return getRuleContext<ClickHouseParser::ColumnsClauseContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::InsertStmtContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleInsertStmt;\n-}\n-\n-antlrcpp::Any ClickHouseParser::InsertStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitInsertStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::InsertStmtContext* ClickHouseParser::insertStmt() {\n-  InsertStmtContext *_localctx = _tracker.createInstance<InsertStmtContext>(_ctx, getState());\n-  enterRule(_localctx, 88, ClickHouseParser::RuleInsertStmt);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1042);\n-    match(ClickHouseParser::INSERT);\n-    setState(1043);\n-    match(ClickHouseParser::INTO);\n-    setState(1045);\n-    _errHandler->sync(this);\n-\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 120, _ctx)) {\n-    case 1: {\n-      setState(1044);\n-      match(ClickHouseParser::TABLE);\n-      break;\n-    }\n-\n-    }\n-    setState(1050);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx)) {\n-    case 1: {\n-      setState(1047);\n-      tableIdentifier();\n-      break;\n-    }\n-\n-    case 2: {\n-      setState(1048);\n-      match(ClickHouseParser::FUNCTION);\n-      setState(1049);\n-      tableFunctionExpr();\n-      break;\n-    }\n-\n-    }\n-    setState(1053);\n-    _errHandler->sync(this);\n-\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx)) {\n-    case 1: {\n-      setState(1052);\n-      columnsClause();\n-      break;\n-    }\n-\n-    }\n-    setState(1055);\n-    dataClause();\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- ColumnsClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::ColumnsClauseContext::ColumnsClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnsClauseContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-std::vector<ClickHouseParser::NestedIdentifierContext *> ClickHouseParser::ColumnsClauseContext::nestedIdentifier() {\n-  return getRuleContexts<ClickHouseParser::NestedIdentifierContext>();\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::ColumnsClauseContext::nestedIdentifier(size_t i) {\n-  return getRuleContext<ClickHouseParser::NestedIdentifierContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnsClauseContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::ColumnsClauseContext::COMMA() {\n-  return getTokens(ClickHouseParser::COMMA);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnsClauseContext::COMMA(size_t i) {\n-  return getToken(ClickHouseParser::COMMA, i);\n-}\n-\n-\n-size_t ClickHouseParser::ColumnsClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleColumnsClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::ColumnsClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnsClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::ColumnsClauseContext* ClickHouseParser::columnsClause() {\n-  ColumnsClauseContext *_localctx = _tracker.createInstance<ColumnsClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 90, ClickHouseParser::RuleColumnsClause);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1057);\n-    match(ClickHouseParser::LPAREN);\n-    setState(1058);\n-    nestedIdentifier();\n-    setState(1063);\n-    _errHandler->sync(this);\n-    _la = _input->LA(1);\n-    while (_la == ClickHouseParser::COMMA) {\n-      setState(1059);\n-      match(ClickHouseParser::COMMA);\n-      setState(1060);\n-      nestedIdentifier();\n-      setState(1065);\n-      _errHandler->sync(this);\n-      _la = _input->LA(1);\n-    }\n-    setState(1066);\n-    match(ClickHouseParser::RPAREN);\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- DataClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::DataClauseContext::DataClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-\n-size_t ClickHouseParser::DataClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleDataClause;\n-}\n-\n-void ClickHouseParser::DataClauseContext::copyFrom(DataClauseContext *ctx) {\n-  ParserRuleContext::copyFrom(ctx);\n-}\n-\n-//----------------- DataClauseValuesContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::DataClauseValuesContext::VALUES() {\n-  return getToken(ClickHouseParser::VALUES, 0);\n-}\n-\n-ClickHouseParser::DataClauseValuesContext::DataClauseValuesContext(DataClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::DataClauseValuesContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitDataClauseValues(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- DataClauseFormatContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::DataClauseFormatContext::FORMAT() {\n-  return getToken(ClickHouseParser::FORMAT, 0);\n-}\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::DataClauseFormatContext::identifier() {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(0);\n-}\n-\n-ClickHouseParser::DataClauseFormatContext::DataClauseFormatContext(DataClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::DataClauseFormatContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitDataClauseFormat(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- DataClauseSelectContext ------------------------------------------------------------------\n-\n-ClickHouseParser::SelectUnionStmtContext* ClickHouseParser::DataClauseSelectContext::selectUnionStmt() {\n-  return getRuleContext<ClickHouseParser::SelectUnionStmtContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DataClauseSelectContext::EOF() {\n-  return getToken(ClickHouseParser::EOF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::DataClauseSelectContext::SEMICOLON() {\n-  return getToken(ClickHouseParser::SEMICOLON, 0);\n-}\n-\n-ClickHouseParser::DataClauseSelectContext::DataClauseSelectContext(DataClauseContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::DataClauseSelectContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitDataClauseSelect(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-ClickHouseParser::DataClauseContext* ClickHouseParser::dataClause() {\n-  DataClauseContext *_localctx = _tracker.createInstance<DataClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 92, ClickHouseParser::RuleDataClause);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(1077);\n-    _errHandler->sync(this);\n-    switch (_input->LA(1)) {\n-      case ClickHouseParser::FORMAT: {\n-        _localctx = dynamic_cast<DataClauseContext *>(_tracker.createInstance<ClickHouseParser::DataClauseFormatContext>(_localctx));\n-        enterOuterAlt(_localctx, 1);\n-        setState(1068);\n-        match(ClickHouseParser::FORMAT);\n-        setState(1069);\n-        identifier();\n-        break;\n-      }\n-\n-      case ClickHouseParser::VALUES: {\n-        _localctx = dynamic_cast<DataClauseContext *>(_tracker.createInstance<ClickHouseParser::DataClauseValuesContext>(_localctx));\n-        enterOuterAlt(_localctx, 2);\n-        setState(1070);\n-        match(ClickHouseParser::VALUES);\n-        break;\n-      }\n-\n-      case ClickHouseParser::SELECT:\n-      case ClickHouseParser::WITH:\n-      case ClickHouseParser::LPAREN: {\n-        _localctx = dynamic_cast<DataClauseContext *>(_tracker.createInstance<ClickHouseParser::DataClauseSelectContext>(_localctx));\n-        enterOuterAlt(_localctx, 3);\n-        setState(1071);\n-        selectUnionStmt();\n-        setState(1073);\n-        _errHandler->sync(this);\n-\n-        _la = _input->LA(1);\n-        if (_la == ClickHouseParser::SEMICOLON) {\n-          setState(1072);\n-          match(ClickHouseParser::SEMICOLON);\n-        }\n-        setState(1075);\n-        match(ClickHouseParser::EOF);\n-        break;\n-      }\n-\n-    default:\n-      throw NoViableAltException(this);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- KillStmtContext ------------------------------------------------------------------\n-\n-ClickHouseParser::KillStmtContext::KillStmtContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-\n-size_t ClickHouseParser::KillStmtContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleKillStmt;\n-}\n-\n-void ClickHouseParser::KillStmtContext::copyFrom(KillStmtContext *ctx) {\n-  ParserRuleContext::copyFrom(ctx);\n-}\n-\n-//----------------- KillMutationStmtContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::KillMutationStmtContext::KILL() {\n-  return getToken(ClickHouseParser::KILL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KillMutationStmtContext::MUTATION() {\n-  return getToken(ClickHouseParser::MUTATION, 0);\n-}\n-\n-ClickHouseParser::WhereClauseContext* ClickHouseParser::KillMutationStmtContext::whereClause() {\n-  return getRuleContext<ClickHouseParser::WhereClauseContext>(0);\n-}\n-\n-ClickHouseParser::ClusterClauseContext* ClickHouseParser::KillMutationStmtContext::clusterClause() {\n-  return getRuleContext<ClickHouseParser::ClusterClauseContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KillMutationStmtContext::SYNC() {\n-  return getToken(ClickHouseParser::SYNC, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KillMutationStmtContext::ASYNC() {\n-  return getToken(ClickHouseParser::ASYNC, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KillMutationStmtContext::TEST() {\n-  return getToken(ClickHouseParser::TEST, 0);\n-}\n-\n-ClickHouseParser::KillMutationStmtContext::KillMutationStmtContext(KillStmtContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::KillMutationStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitKillMutationStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-ClickHouseParser::KillStmtContext* ClickHouseParser::killStmt() {\n-  KillStmtContext *_localctx = _tracker.createInstance<KillStmtContext>(_ctx, getState());\n-  enterRule(_localctx, 94, ClickHouseParser::RuleKillStmt);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    _localctx = dynamic_cast<KillStmtContext *>(_tracker.createInstance<ClickHouseParser::KillMutationStmtContext>(_localctx));\n-    enterOuterAlt(_localctx, 1);\n-    setState(1079);\n-    match(ClickHouseParser::KILL);\n-    setState(1080);\n-    match(ClickHouseParser::MUTATION);\n-    setState(1082);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::ON) {\n-      setState(1081);\n-      clusterClause();\n-    }\n-    setState(1084);\n-    whereClause();\n-    setState(1086);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::ASYNC || _la == ClickHouseParser::SYNC\n-\n-    || _la == ClickHouseParser::TEST) {\n-      setState(1085);\n-      _la = _input->LA(1);\n-      if (!(_la == ClickHouseParser::ASYNC || _la == ClickHouseParser::SYNC\n-\n-      || _la == ClickHouseParser::TEST)) {\n-      _errHandler->recoverInline(this);\n-      }\n-      else {\n-        _errHandler->reportMatch(this);\n-        consume();\n-      }\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- OptimizeStmtContext ------------------------------------------------------------------\n-\n-ClickHouseParser::OptimizeStmtContext::OptimizeStmtContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::OptimizeStmtContext::OPTIMIZE() {\n-  return getToken(ClickHouseParser::OPTIMIZE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::OptimizeStmtContext::TABLE() {\n-  return getToken(ClickHouseParser::TABLE, 0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::OptimizeStmtContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::ClusterClauseContext* ClickHouseParser::OptimizeStmtContext::clusterClause() {\n-  return getRuleContext<ClickHouseParser::ClusterClauseContext>(0);\n-}\n-\n-ClickHouseParser::PartitionClauseContext* ClickHouseParser::OptimizeStmtContext::partitionClause() {\n-  return getRuleContext<ClickHouseParser::PartitionClauseContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::OptimizeStmtContext::FINAL() {\n-  return getToken(ClickHouseParser::FINAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::OptimizeStmtContext::DEDUPLICATE() {\n-  return getToken(ClickHouseParser::DEDUPLICATE, 0);\n-}\n-\n-\n-size_t ClickHouseParser::OptimizeStmtContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleOptimizeStmt;\n-}\n-\n-antlrcpp::Any ClickHouseParser::OptimizeStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitOptimizeStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::OptimizeStmtContext* ClickHouseParser::optimizeStmt() {\n-  OptimizeStmtContext *_localctx = _tracker.createInstance<OptimizeStmtContext>(_ctx, getState());\n-  enterRule(_localctx, 96, ClickHouseParser::RuleOptimizeStmt);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1088);\n-    match(ClickHouseParser::OPTIMIZE);\n-    setState(1089);\n-    match(ClickHouseParser::TABLE);\n-    setState(1090);\n-    tableIdentifier();\n-    setState(1092);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::ON) {\n-      setState(1091);\n-      clusterClause();\n-    }\n-    setState(1095);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::PARTITION) {\n-      setState(1094);\n-      partitionClause();\n-    }\n-    setState(1098);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::FINAL) {\n-      setState(1097);\n-      match(ClickHouseParser::FINAL);\n-    }\n-    setState(1101);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::DEDUPLICATE) {\n-      setState(1100);\n-      match(ClickHouseParser::DEDUPLICATE);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- RenameStmtContext ------------------------------------------------------------------\n-\n-ClickHouseParser::RenameStmtContext::RenameStmtContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::RenameStmtContext::RENAME() {\n-  return getToken(ClickHouseParser::RENAME, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::RenameStmtContext::TABLE() {\n-  return getToken(ClickHouseParser::TABLE, 0);\n-}\n-\n-std::vector<ClickHouseParser::TableIdentifierContext *> ClickHouseParser::RenameStmtContext::tableIdentifier() {\n-  return getRuleContexts<ClickHouseParser::TableIdentifierContext>();\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::RenameStmtContext::tableIdentifier(size_t i) {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(i);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::RenameStmtContext::TO() {\n-  return getTokens(ClickHouseParser::TO);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::RenameStmtContext::TO(size_t i) {\n-  return getToken(ClickHouseParser::TO, i);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::RenameStmtContext::COMMA() {\n-  return getTokens(ClickHouseParser::COMMA);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::RenameStmtContext::COMMA(size_t i) {\n-  return getToken(ClickHouseParser::COMMA, i);\n-}\n-\n-ClickHouseParser::ClusterClauseContext* ClickHouseParser::RenameStmtContext::clusterClause() {\n-  return getRuleContext<ClickHouseParser::ClusterClauseContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::RenameStmtContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleRenameStmt;\n-}\n-\n-antlrcpp::Any ClickHouseParser::RenameStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitRenameStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::RenameStmtContext* ClickHouseParser::renameStmt() {\n-  RenameStmtContext *_localctx = _tracker.createInstance<RenameStmtContext>(_ctx, getState());\n-  enterRule(_localctx, 98, ClickHouseParser::RuleRenameStmt);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1103);\n-    match(ClickHouseParser::RENAME);\n-    setState(1104);\n-    match(ClickHouseParser::TABLE);\n-    setState(1105);\n-    tableIdentifier();\n-    setState(1106);\n-    match(ClickHouseParser::TO);\n-    setState(1107);\n-    tableIdentifier();\n-    setState(1115);\n-    _errHandler->sync(this);\n-    _la = _input->LA(1);\n-    while (_la == ClickHouseParser::COMMA) {\n-      setState(1108);\n-      match(ClickHouseParser::COMMA);\n-      setState(1109);\n-      tableIdentifier();\n-      setState(1110);\n-      match(ClickHouseParser::TO);\n-      setState(1111);\n-      tableIdentifier();\n-      setState(1117);\n-      _errHandler->sync(this);\n-      _la = _input->LA(1);\n-    }\n-    setState(1119);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::ON) {\n-      setState(1118);\n-      clusterClause();\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- ProjectionSelectStmtContext ------------------------------------------------------------------\n-\n-ClickHouseParser::ProjectionSelectStmtContext::ProjectionSelectStmtContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ProjectionSelectStmtContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ProjectionSelectStmtContext::SELECT() {\n-  return getToken(ClickHouseParser::SELECT, 0);\n-}\n-\n-ClickHouseParser::ColumnExprListContext* ClickHouseParser::ProjectionSelectStmtContext::columnExprList() {\n-  return getRuleContext<ClickHouseParser::ColumnExprListContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ProjectionSelectStmtContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-ClickHouseParser::WithClauseContext* ClickHouseParser::ProjectionSelectStmtContext::withClause() {\n-  return getRuleContext<ClickHouseParser::WithClauseContext>(0);\n-}\n-\n-ClickHouseParser::GroupByClauseContext* ClickHouseParser::ProjectionSelectStmtContext::groupByClause() {\n-  return getRuleContext<ClickHouseParser::GroupByClauseContext>(0);\n-}\n-\n-ClickHouseParser::ProjectionOrderByClauseContext* ClickHouseParser::ProjectionSelectStmtContext::projectionOrderByClause() {\n-  return getRuleContext<ClickHouseParser::ProjectionOrderByClauseContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::ProjectionSelectStmtContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleProjectionSelectStmt;\n-}\n-\n-antlrcpp::Any ClickHouseParser::ProjectionSelectStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitProjectionSelectStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::ProjectionSelectStmtContext* ClickHouseParser::projectionSelectStmt() {\n-  ProjectionSelectStmtContext *_localctx = _tracker.createInstance<ProjectionSelectStmtContext>(_ctx, getState());\n-  enterRule(_localctx, 100, ClickHouseParser::RuleProjectionSelectStmt);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1121);\n-    match(ClickHouseParser::LPAREN);\n-    setState(1123);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::WITH) {\n-      setState(1122);\n-      withClause();\n-    }\n-    setState(1125);\n-    match(ClickHouseParser::SELECT);\n-    setState(1126);\n-    columnExprList();\n-    setState(1128);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::GROUP) {\n-      setState(1127);\n-      groupByClause();\n-    }\n-    setState(1131);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::ORDER) {\n-      setState(1130);\n-      projectionOrderByClause();\n-    }\n-    setState(1133);\n-    match(ClickHouseParser::RPAREN);\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- SelectUnionStmtContext ------------------------------------------------------------------\n-\n-ClickHouseParser::SelectUnionStmtContext::SelectUnionStmtContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-std::vector<ClickHouseParser::SelectStmtWithParensContext *> ClickHouseParser::SelectUnionStmtContext::selectStmtWithParens() {\n-  return getRuleContexts<ClickHouseParser::SelectStmtWithParensContext>();\n-}\n-\n-ClickHouseParser::SelectStmtWithParensContext* ClickHouseParser::SelectUnionStmtContext::selectStmtWithParens(size_t i) {\n-  return getRuleContext<ClickHouseParser::SelectStmtWithParensContext>(i);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::SelectUnionStmtContext::UNION() {\n-  return getTokens(ClickHouseParser::UNION);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SelectUnionStmtContext::UNION(size_t i) {\n-  return getToken(ClickHouseParser::UNION, i);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::SelectUnionStmtContext::ALL() {\n-  return getTokens(ClickHouseParser::ALL);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SelectUnionStmtContext::ALL(size_t i) {\n-  return getToken(ClickHouseParser::ALL, i);\n-}\n-\n-\n-size_t ClickHouseParser::SelectUnionStmtContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleSelectUnionStmt;\n-}\n-\n-antlrcpp::Any ClickHouseParser::SelectUnionStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitSelectUnionStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::SelectUnionStmtContext* ClickHouseParser::selectUnionStmt() {\n-  SelectUnionStmtContext *_localctx = _tracker.createInstance<SelectUnionStmtContext>(_ctx, getState());\n-  enterRule(_localctx, 102, ClickHouseParser::RuleSelectUnionStmt);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1135);\n-    selectStmtWithParens();\n-    setState(1141);\n-    _errHandler->sync(this);\n-    _la = _input->LA(1);\n-    while (_la == ClickHouseParser::UNION) {\n-      setState(1136);\n-      match(ClickHouseParser::UNION);\n-      setState(1137);\n-      match(ClickHouseParser::ALL);\n-      setState(1138);\n-      selectStmtWithParens();\n-      setState(1143);\n-      _errHandler->sync(this);\n-      _la = _input->LA(1);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- SelectStmtWithParensContext ------------------------------------------------------------------\n-\n-ClickHouseParser::SelectStmtWithParensContext::SelectStmtWithParensContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::SelectStmtContext* ClickHouseParser::SelectStmtWithParensContext::selectStmt() {\n-  return getRuleContext<ClickHouseParser::SelectStmtContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SelectStmtWithParensContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-ClickHouseParser::SelectUnionStmtContext* ClickHouseParser::SelectStmtWithParensContext::selectUnionStmt() {\n-  return getRuleContext<ClickHouseParser::SelectUnionStmtContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SelectStmtWithParensContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-\n-size_t ClickHouseParser::SelectStmtWithParensContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleSelectStmtWithParens;\n-}\n-\n-antlrcpp::Any ClickHouseParser::SelectStmtWithParensContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitSelectStmtWithParens(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::SelectStmtWithParensContext* ClickHouseParser::selectStmtWithParens() {\n-  SelectStmtWithParensContext *_localctx = _tracker.createInstance<SelectStmtWithParensContext>(_ctx, getState());\n-  enterRule(_localctx, 104, ClickHouseParser::RuleSelectStmtWithParens);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(1149);\n-    _errHandler->sync(this);\n-    switch (_input->LA(1)) {\n-      case ClickHouseParser::SELECT:\n-      case ClickHouseParser::WITH: {\n-        enterOuterAlt(_localctx, 1);\n-        setState(1144);\n-        selectStmt();\n-        break;\n-      }\n-\n-      case ClickHouseParser::LPAREN: {\n-        enterOuterAlt(_localctx, 2);\n-        setState(1145);\n-        match(ClickHouseParser::LPAREN);\n-        setState(1146);\n-        selectUnionStmt();\n-        setState(1147);\n-        match(ClickHouseParser::RPAREN);\n-        break;\n-      }\n-\n-    default:\n-      throw NoViableAltException(this);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- SelectStmtContext ------------------------------------------------------------------\n-\n-ClickHouseParser::SelectStmtContext::SelectStmtContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SelectStmtContext::SELECT() {\n-  return getToken(ClickHouseParser::SELECT, 0);\n-}\n-\n-ClickHouseParser::ColumnExprListContext* ClickHouseParser::SelectStmtContext::columnExprList() {\n-  return getRuleContext<ClickHouseParser::ColumnExprListContext>(0);\n-}\n-\n-ClickHouseParser::WithClauseContext* ClickHouseParser::SelectStmtContext::withClause() {\n-  return getRuleContext<ClickHouseParser::WithClauseContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SelectStmtContext::DISTINCT() {\n-  return getToken(ClickHouseParser::DISTINCT, 0);\n-}\n-\n-ClickHouseParser::TopClauseContext* ClickHouseParser::SelectStmtContext::topClause() {\n-  return getRuleContext<ClickHouseParser::TopClauseContext>(0);\n-}\n-\n-ClickHouseParser::FromClauseContext* ClickHouseParser::SelectStmtContext::fromClause() {\n-  return getRuleContext<ClickHouseParser::FromClauseContext>(0);\n-}\n-\n-ClickHouseParser::ArrayJoinClauseContext* ClickHouseParser::SelectStmtContext::arrayJoinClause() {\n-  return getRuleContext<ClickHouseParser::ArrayJoinClauseContext>(0);\n-}\n-\n-ClickHouseParser::PrewhereClauseContext* ClickHouseParser::SelectStmtContext::prewhereClause() {\n-  return getRuleContext<ClickHouseParser::PrewhereClauseContext>(0);\n-}\n-\n-ClickHouseParser::WhereClauseContext* ClickHouseParser::SelectStmtContext::whereClause() {\n-  return getRuleContext<ClickHouseParser::WhereClauseContext>(0);\n-}\n-\n-ClickHouseParser::GroupByClauseContext* ClickHouseParser::SelectStmtContext::groupByClause() {\n-  return getRuleContext<ClickHouseParser::GroupByClauseContext>(0);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::SelectStmtContext::WITH() {\n-  return getTokens(ClickHouseParser::WITH);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SelectStmtContext::WITH(size_t i) {\n-  return getToken(ClickHouseParser::WITH, i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SelectStmtContext::TOTALS() {\n-  return getToken(ClickHouseParser::TOTALS, 0);\n-}\n-\n-ClickHouseParser::HavingClauseContext* ClickHouseParser::SelectStmtContext::havingClause() {\n-  return getRuleContext<ClickHouseParser::HavingClauseContext>(0);\n-}\n-\n-ClickHouseParser::OrderByClauseContext* ClickHouseParser::SelectStmtContext::orderByClause() {\n-  return getRuleContext<ClickHouseParser::OrderByClauseContext>(0);\n-}\n-\n-ClickHouseParser::LimitByClauseContext* ClickHouseParser::SelectStmtContext::limitByClause() {\n-  return getRuleContext<ClickHouseParser::LimitByClauseContext>(0);\n-}\n-\n-ClickHouseParser::LimitClauseContext* ClickHouseParser::SelectStmtContext::limitClause() {\n-  return getRuleContext<ClickHouseParser::LimitClauseContext>(0);\n-}\n-\n-ClickHouseParser::SettingsClauseContext* ClickHouseParser::SelectStmtContext::settingsClause() {\n-  return getRuleContext<ClickHouseParser::SettingsClauseContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SelectStmtContext::CUBE() {\n-  return getToken(ClickHouseParser::CUBE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SelectStmtContext::ROLLUP() {\n-  return getToken(ClickHouseParser::ROLLUP, 0);\n-}\n-\n-\n-size_t ClickHouseParser::SelectStmtContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleSelectStmt;\n-}\n-\n-antlrcpp::Any ClickHouseParser::SelectStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitSelectStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::SelectStmtContext* ClickHouseParser::selectStmt() {\n-  SelectStmtContext *_localctx = _tracker.createInstance<SelectStmtContext>(_ctx, getState());\n-  enterRule(_localctx, 106, ClickHouseParser::RuleSelectStmt);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1152);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::WITH) {\n-      setState(1151);\n-      withClause();\n-    }\n-    setState(1154);\n-    match(ClickHouseParser::SELECT);\n-    setState(1156);\n-    _errHandler->sync(this);\n-\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 140, _ctx)) {\n-    case 1: {\n-      setState(1155);\n-      match(ClickHouseParser::DISTINCT);\n-      break;\n-    }\n-\n-    }\n-    setState(1159);\n-    _errHandler->sync(this);\n-\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, _ctx)) {\n-    case 1: {\n-      setState(1158);\n-      topClause();\n-      break;\n-    }\n-\n-    }\n-    setState(1161);\n-    columnExprList();\n-    setState(1163);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::FROM) {\n-      setState(1162);\n-      fromClause();\n-    }\n-    setState(1166);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::ARRAY || _la == ClickHouseParser::INNER\n-\n-    || _la == ClickHouseParser::LEFT) {\n-      setState(1165);\n-      arrayJoinClause();\n-    }\n-    setState(1169);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::PREWHERE) {\n-      setState(1168);\n-      prewhereClause();\n-    }\n-    setState(1172);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::WHERE) {\n-      setState(1171);\n-      whereClause();\n-    }\n-    setState(1175);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::GROUP) {\n-      setState(1174);\n-      groupByClause();\n-    }\n-    setState(1179);\n-    _errHandler->sync(this);\n-\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 147, _ctx)) {\n-    case 1: {\n-      setState(1177);\n-      match(ClickHouseParser::WITH);\n-      setState(1178);\n-      _la = _input->LA(1);\n-      if (!(_la == ClickHouseParser::CUBE || _la == ClickHouseParser::ROLLUP)) {\n-      _errHandler->recoverInline(this);\n-      }\n-      else {\n-        _errHandler->reportMatch(this);\n-        consume();\n-      }\n-      break;\n-    }\n-\n-    }\n-    setState(1183);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::WITH) {\n-      setState(1181);\n-      match(ClickHouseParser::WITH);\n-      setState(1182);\n-      match(ClickHouseParser::TOTALS);\n-    }\n-    setState(1186);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::HAVING) {\n-      setState(1185);\n-      havingClause();\n-    }\n-    setState(1189);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::ORDER) {\n-      setState(1188);\n-      orderByClause();\n-    }\n-    setState(1192);\n-    _errHandler->sync(this);\n-\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 151, _ctx)) {\n-    case 1: {\n-      setState(1191);\n-      limitByClause();\n-      break;\n-    }\n-\n-    }\n-    setState(1195);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::LIMIT) {\n-      setState(1194);\n-      limitClause();\n-    }\n-    setState(1198);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::SETTINGS) {\n-      setState(1197);\n-      settingsClause();\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- WithClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::WithClauseContext::WithClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::WithClauseContext::WITH() {\n-  return getToken(ClickHouseParser::WITH, 0);\n-}\n-\n-ClickHouseParser::ColumnExprListContext* ClickHouseParser::WithClauseContext::columnExprList() {\n-  return getRuleContext<ClickHouseParser::ColumnExprListContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::WithClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleWithClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::WithClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitWithClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::WithClauseContext* ClickHouseParser::withClause() {\n-  WithClauseContext *_localctx = _tracker.createInstance<WithClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 108, ClickHouseParser::RuleWithClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1200);\n-    match(ClickHouseParser::WITH);\n-    setState(1201);\n-    columnExprList();\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- TopClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::TopClauseContext::TopClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TopClauseContext::TOP() {\n-  return getToken(ClickHouseParser::TOP, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TopClauseContext::DECIMAL_LITERAL() {\n-  return getToken(ClickHouseParser::DECIMAL_LITERAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TopClauseContext::WITH() {\n-  return getToken(ClickHouseParser::WITH, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TopClauseContext::TIES() {\n-  return getToken(ClickHouseParser::TIES, 0);\n-}\n-\n-\n-size_t ClickHouseParser::TopClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleTopClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::TopClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitTopClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::TopClauseContext* ClickHouseParser::topClause() {\n-  TopClauseContext *_localctx = _tracker.createInstance<TopClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 110, ClickHouseParser::RuleTopClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1203);\n-    match(ClickHouseParser::TOP);\n-    setState(1204);\n-    match(ClickHouseParser::DECIMAL_LITERAL);\n-    setState(1207);\n-    _errHandler->sync(this);\n-\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx)) {\n-    case 1: {\n-      setState(1205);\n-      match(ClickHouseParser::WITH);\n-      setState(1206);\n-      match(ClickHouseParser::TIES);\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- FromClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::FromClauseContext::FromClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::FromClauseContext::FROM() {\n-  return getToken(ClickHouseParser::FROM, 0);\n-}\n-\n-ClickHouseParser::JoinExprContext* ClickHouseParser::FromClauseContext::joinExpr() {\n-  return getRuleContext<ClickHouseParser::JoinExprContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::FromClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleFromClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::FromClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitFromClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::FromClauseContext* ClickHouseParser::fromClause() {\n-  FromClauseContext *_localctx = _tracker.createInstance<FromClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 112, ClickHouseParser::RuleFromClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1209);\n-    match(ClickHouseParser::FROM);\n-    setState(1210);\n-    joinExpr(0);\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- ArrayJoinClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::ArrayJoinClauseContext::ArrayJoinClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ArrayJoinClauseContext::ARRAY() {\n-  return getToken(ClickHouseParser::ARRAY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ArrayJoinClauseContext::JOIN() {\n-  return getToken(ClickHouseParser::JOIN, 0);\n-}\n-\n-ClickHouseParser::ColumnExprListContext* ClickHouseParser::ArrayJoinClauseContext::columnExprList() {\n-  return getRuleContext<ClickHouseParser::ColumnExprListContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ArrayJoinClauseContext::LEFT() {\n-  return getToken(ClickHouseParser::LEFT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ArrayJoinClauseContext::INNER() {\n-  return getToken(ClickHouseParser::INNER, 0);\n-}\n-\n-\n-size_t ClickHouseParser::ArrayJoinClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleArrayJoinClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::ArrayJoinClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitArrayJoinClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::ArrayJoinClauseContext* ClickHouseParser::arrayJoinClause() {\n-  ArrayJoinClauseContext *_localctx = _tracker.createInstance<ArrayJoinClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 114, ClickHouseParser::RuleArrayJoinClause);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1213);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::INNER\n-\n-    || _la == ClickHouseParser::LEFT) {\n-      setState(1212);\n-      _la = _input->LA(1);\n-      if (!(_la == ClickHouseParser::INNER\n-\n-      || _la == ClickHouseParser::LEFT)) {\n-      _errHandler->recoverInline(this);\n-      }\n-      else {\n-        _errHandler->reportMatch(this);\n-        consume();\n-      }\n-    }\n-    setState(1215);\n-    match(ClickHouseParser::ARRAY);\n-    setState(1216);\n-    match(ClickHouseParser::JOIN);\n-    setState(1217);\n-    columnExprList();\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- PrewhereClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::PrewhereClauseContext::PrewhereClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::PrewhereClauseContext::PREWHERE() {\n-  return getToken(ClickHouseParser::PREWHERE, 0);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::PrewhereClauseContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::PrewhereClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RulePrewhereClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::PrewhereClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitPrewhereClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::PrewhereClauseContext* ClickHouseParser::prewhereClause() {\n-  PrewhereClauseContext *_localctx = _tracker.createInstance<PrewhereClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 116, ClickHouseParser::RulePrewhereClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1219);\n-    match(ClickHouseParser::PREWHERE);\n-    setState(1220);\n-    columnExpr(0);\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- WhereClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::WhereClauseContext::WhereClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::WhereClauseContext::WHERE() {\n-  return getToken(ClickHouseParser::WHERE, 0);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::WhereClauseContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::WhereClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleWhereClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::WhereClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitWhereClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::WhereClauseContext* ClickHouseParser::whereClause() {\n-  WhereClauseContext *_localctx = _tracker.createInstance<WhereClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 118, ClickHouseParser::RuleWhereClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1222);\n-    match(ClickHouseParser::WHERE);\n-    setState(1223);\n-    columnExpr(0);\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- GroupByClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::GroupByClauseContext::GroupByClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::GroupByClauseContext::GROUP() {\n-  return getToken(ClickHouseParser::GROUP, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::GroupByClauseContext::BY() {\n-  return getToken(ClickHouseParser::BY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::GroupByClauseContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-ClickHouseParser::ColumnExprListContext* ClickHouseParser::GroupByClauseContext::columnExprList() {\n-  return getRuleContext<ClickHouseParser::ColumnExprListContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::GroupByClauseContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::GroupByClauseContext::CUBE() {\n-  return getToken(ClickHouseParser::CUBE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::GroupByClauseContext::ROLLUP() {\n-  return getToken(ClickHouseParser::ROLLUP, 0);\n-}\n-\n-\n-size_t ClickHouseParser::GroupByClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleGroupByClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::GroupByClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitGroupByClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::GroupByClauseContext* ClickHouseParser::groupByClause() {\n-  GroupByClauseContext *_localctx = _tracker.createInstance<GroupByClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 120, ClickHouseParser::RuleGroupByClause);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1225);\n-    match(ClickHouseParser::GROUP);\n-    setState(1226);\n-    match(ClickHouseParser::BY);\n-    setState(1233);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 156, _ctx)) {\n-    case 1: {\n-      setState(1227);\n-      _la = _input->LA(1);\n-      if (!(_la == ClickHouseParser::CUBE || _la == ClickHouseParser::ROLLUP)) {\n-      _errHandler->recoverInline(this);\n-      }\n-      else {\n-        _errHandler->reportMatch(this);\n-        consume();\n-      }\n-      setState(1228);\n-      match(ClickHouseParser::LPAREN);\n-      setState(1229);\n-      columnExprList();\n-      setState(1230);\n-      match(ClickHouseParser::RPAREN);\n-      break;\n-    }\n-\n-    case 2: {\n-      setState(1232);\n-      columnExprList();\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- HavingClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::HavingClauseContext::HavingClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::HavingClauseContext::HAVING() {\n-  return getToken(ClickHouseParser::HAVING, 0);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::HavingClauseContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::HavingClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleHavingClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::HavingClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitHavingClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::HavingClauseContext* ClickHouseParser::havingClause() {\n-  HavingClauseContext *_localctx = _tracker.createInstance<HavingClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 122, ClickHouseParser::RuleHavingClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1235);\n-    match(ClickHouseParser::HAVING);\n-    setState(1236);\n-    columnExpr(0);\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- OrderByClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::OrderByClauseContext::OrderByClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::OrderByClauseContext::ORDER() {\n-  return getToken(ClickHouseParser::ORDER, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::OrderByClauseContext::BY() {\n-  return getToken(ClickHouseParser::BY, 0);\n-}\n-\n-ClickHouseParser::OrderExprListContext* ClickHouseParser::OrderByClauseContext::orderExprList() {\n-  return getRuleContext<ClickHouseParser::OrderExprListContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::OrderByClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleOrderByClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::OrderByClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitOrderByClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::OrderByClauseContext* ClickHouseParser::orderByClause() {\n-  OrderByClauseContext *_localctx = _tracker.createInstance<OrderByClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 124, ClickHouseParser::RuleOrderByClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1238);\n-    match(ClickHouseParser::ORDER);\n-    setState(1239);\n-    match(ClickHouseParser::BY);\n-    setState(1240);\n-    orderExprList();\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- ProjectionOrderByClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::ProjectionOrderByClauseContext::ProjectionOrderByClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ProjectionOrderByClauseContext::ORDER() {\n-  return getToken(ClickHouseParser::ORDER, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ProjectionOrderByClauseContext::BY() {\n-  return getToken(ClickHouseParser::BY, 0);\n-}\n-\n-ClickHouseParser::ColumnExprListContext* ClickHouseParser::ProjectionOrderByClauseContext::columnExprList() {\n-  return getRuleContext<ClickHouseParser::ColumnExprListContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::ProjectionOrderByClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleProjectionOrderByClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::ProjectionOrderByClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitProjectionOrderByClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::ProjectionOrderByClauseContext* ClickHouseParser::projectionOrderByClause() {\n-  ProjectionOrderByClauseContext *_localctx = _tracker.createInstance<ProjectionOrderByClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 126, ClickHouseParser::RuleProjectionOrderByClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1242);\n-    match(ClickHouseParser::ORDER);\n-    setState(1243);\n-    match(ClickHouseParser::BY);\n-    setState(1244);\n-    columnExprList();\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- LimitByClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::LimitByClauseContext::LimitByClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::LimitByClauseContext::LIMIT() {\n-  return getToken(ClickHouseParser::LIMIT, 0);\n-}\n-\n-ClickHouseParser::LimitExprContext* ClickHouseParser::LimitByClauseContext::limitExpr() {\n-  return getRuleContext<ClickHouseParser::LimitExprContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::LimitByClauseContext::BY() {\n-  return getToken(ClickHouseParser::BY, 0);\n-}\n-\n-ClickHouseParser::ColumnExprListContext* ClickHouseParser::LimitByClauseContext::columnExprList() {\n-  return getRuleContext<ClickHouseParser::ColumnExprListContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::LimitByClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleLimitByClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::LimitByClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitLimitByClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::LimitByClauseContext* ClickHouseParser::limitByClause() {\n-  LimitByClauseContext *_localctx = _tracker.createInstance<LimitByClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 128, ClickHouseParser::RuleLimitByClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1246);\n-    match(ClickHouseParser::LIMIT);\n-    setState(1247);\n-    limitExpr();\n-    setState(1248);\n-    match(ClickHouseParser::BY);\n-    setState(1249);\n-    columnExprList();\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- LimitClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::LimitClauseContext::LimitClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::LimitClauseContext::LIMIT() {\n-  return getToken(ClickHouseParser::LIMIT, 0);\n-}\n-\n-ClickHouseParser::LimitExprContext* ClickHouseParser::LimitClauseContext::limitExpr() {\n-  return getRuleContext<ClickHouseParser::LimitExprContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::LimitClauseContext::WITH() {\n-  return getToken(ClickHouseParser::WITH, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::LimitClauseContext::TIES() {\n-  return getToken(ClickHouseParser::TIES, 0);\n-}\n-\n-\n-size_t ClickHouseParser::LimitClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleLimitClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::LimitClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitLimitClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::LimitClauseContext* ClickHouseParser::limitClause() {\n-  LimitClauseContext *_localctx = _tracker.createInstance<LimitClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 130, ClickHouseParser::RuleLimitClause);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1251);\n-    match(ClickHouseParser::LIMIT);\n-    setState(1252);\n-    limitExpr();\n-    setState(1255);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::WITH) {\n-      setState(1253);\n-      match(ClickHouseParser::WITH);\n-      setState(1254);\n-      match(ClickHouseParser::TIES);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- SettingsClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::SettingsClauseContext::SettingsClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SettingsClauseContext::SETTINGS() {\n-  return getToken(ClickHouseParser::SETTINGS, 0);\n-}\n-\n-ClickHouseParser::SettingExprListContext* ClickHouseParser::SettingsClauseContext::settingExprList() {\n-  return getRuleContext<ClickHouseParser::SettingExprListContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::SettingsClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleSettingsClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::SettingsClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitSettingsClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::SettingsClauseContext* ClickHouseParser::settingsClause() {\n-  SettingsClauseContext *_localctx = _tracker.createInstance<SettingsClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 132, ClickHouseParser::RuleSettingsClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1257);\n-    match(ClickHouseParser::SETTINGS);\n-    setState(1258);\n-    settingExprList();\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- JoinExprContext ------------------------------------------------------------------\n-\n-ClickHouseParser::JoinExprContext::JoinExprContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-\n-size_t ClickHouseParser::JoinExprContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleJoinExpr;\n-}\n-\n-void ClickHouseParser::JoinExprContext::copyFrom(JoinExprContext *ctx) {\n-  ParserRuleContext::copyFrom(ctx);\n-}\n-\n-//----------------- JoinExprOpContext ------------------------------------------------------------------\n-\n-std::vector<ClickHouseParser::JoinExprContext *> ClickHouseParser::JoinExprOpContext::joinExpr() {\n-  return getRuleContexts<ClickHouseParser::JoinExprContext>();\n-}\n-\n-ClickHouseParser::JoinExprContext* ClickHouseParser::JoinExprOpContext::joinExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::JoinExprContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinExprOpContext::JOIN() {\n-  return getToken(ClickHouseParser::JOIN, 0);\n-}\n-\n-ClickHouseParser::JoinConstraintClauseContext* ClickHouseParser::JoinExprOpContext::joinConstraintClause() {\n-  return getRuleContext<ClickHouseParser::JoinConstraintClauseContext>(0);\n-}\n-\n-ClickHouseParser::JoinOpContext* ClickHouseParser::JoinExprOpContext::joinOp() {\n-  return getRuleContext<ClickHouseParser::JoinOpContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinExprOpContext::GLOBAL() {\n-  return getToken(ClickHouseParser::GLOBAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinExprOpContext::LOCAL() {\n-  return getToken(ClickHouseParser::LOCAL, 0);\n-}\n-\n-ClickHouseParser::JoinExprOpContext::JoinExprOpContext(JoinExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::JoinExprOpContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitJoinExprOp(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- JoinExprTableContext ------------------------------------------------------------------\n-\n-ClickHouseParser::TableExprContext* ClickHouseParser::JoinExprTableContext::tableExpr() {\n-  return getRuleContext<ClickHouseParser::TableExprContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinExprTableContext::FINAL() {\n-  return getToken(ClickHouseParser::FINAL, 0);\n-}\n-\n-ClickHouseParser::SampleClauseContext* ClickHouseParser::JoinExprTableContext::sampleClause() {\n-  return getRuleContext<ClickHouseParser::SampleClauseContext>(0);\n-}\n-\n-ClickHouseParser::JoinExprTableContext::JoinExprTableContext(JoinExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::JoinExprTableContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitJoinExprTable(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- JoinExprParensContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::JoinExprParensContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-ClickHouseParser::JoinExprContext* ClickHouseParser::JoinExprParensContext::joinExpr() {\n-  return getRuleContext<ClickHouseParser::JoinExprContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinExprParensContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-ClickHouseParser::JoinExprParensContext::JoinExprParensContext(JoinExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::JoinExprParensContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitJoinExprParens(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- JoinExprCrossOpContext ------------------------------------------------------------------\n-\n-std::vector<ClickHouseParser::JoinExprContext *> ClickHouseParser::JoinExprCrossOpContext::joinExpr() {\n-  return getRuleContexts<ClickHouseParser::JoinExprContext>();\n-}\n-\n-ClickHouseParser::JoinExprContext* ClickHouseParser::JoinExprCrossOpContext::joinExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::JoinExprContext>(i);\n-}\n-\n-ClickHouseParser::JoinOpCrossContext* ClickHouseParser::JoinExprCrossOpContext::joinOpCross() {\n-  return getRuleContext<ClickHouseParser::JoinOpCrossContext>(0);\n-}\n-\n-ClickHouseParser::JoinExprCrossOpContext::JoinExprCrossOpContext(JoinExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::JoinExprCrossOpContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitJoinExprCrossOp(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::JoinExprContext* ClickHouseParser::joinExpr() {\n-   return joinExpr(0);\n-}\n-\n-ClickHouseParser::JoinExprContext* ClickHouseParser::joinExpr(int precedence) {\n-  ParserRuleContext *parentContext = _ctx;\n-  size_t parentState = getState();\n-  ClickHouseParser::JoinExprContext *_localctx = _tracker.createInstance<JoinExprContext>(_ctx, parentState);\n-  ClickHouseParser::JoinExprContext *previousContext = _localctx;\n-  (void)previousContext; // Silence compiler, in case the context is not used by generated code.\n-  size_t startState = 134;\n-  enterRecursionRule(_localctx, 134, ClickHouseParser::RuleJoinExpr, precedence);\n-\n-    size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    unrollRecursionContexts(parentContext);\n-  });\n-  try {\n-    size_t alt;\n-    enterOuterAlt(_localctx, 1);\n-    setState(1272);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 160, _ctx)) {\n-    case 1: {\n-      _localctx = _tracker.createInstance<JoinExprTableContext>(_localctx);\n-      _ctx = _localctx;\n-      previousContext = _localctx;\n-\n-      setState(1261);\n-      tableExpr(0);\n-      setState(1263);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 158, _ctx)) {\n-      case 1: {\n-        setState(1262);\n-        match(ClickHouseParser::FINAL);\n-        break;\n-      }\n-\n-      }\n-      setState(1266);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 159, _ctx)) {\n-      case 1: {\n-        setState(1265);\n-        sampleClause();\n-        break;\n-      }\n-\n-      }\n-      break;\n-    }\n-\n-    case 2: {\n-      _localctx = _tracker.createInstance<JoinExprParensContext>(_localctx);\n-      _ctx = _localctx;\n-      previousContext = _localctx;\n-      setState(1268);\n-      match(ClickHouseParser::LPAREN);\n-      setState(1269);\n-      joinExpr(0);\n-      setState(1270);\n-      match(ClickHouseParser::RPAREN);\n-      break;\n-    }\n-\n-    }\n-    _ctx->stop = _input->LT(-1);\n-    setState(1291);\n-    _errHandler->sync(this);\n-    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 164, _ctx);\n-    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {\n-      if (alt == 1) {\n-        if (!_parseListeners.empty())\n-          triggerExitRuleEvent();\n-        previousContext = _localctx;\n-        setState(1289);\n-        _errHandler->sync(this);\n-        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 163, _ctx)) {\n-        case 1: {\n-          auto newContext = _tracker.createInstance<JoinExprCrossOpContext>(_tracker.createInstance<JoinExprContext>(parentContext, parentState));\n-          _localctx = newContext;\n-          pushNewRecursionContext(newContext, startState, RuleJoinExpr);\n-          setState(1274);\n-\n-          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, \"precpred(_ctx, 3)\");\n-          setState(1275);\n-          joinOpCross();\n-          setState(1276);\n-          joinExpr(4);\n-          break;\n-        }\n-\n-        case 2: {\n-          auto newContext = _tracker.createInstance<JoinExprOpContext>(_tracker.createInstance<JoinExprContext>(parentContext, parentState));\n-          _localctx = newContext;\n-          pushNewRecursionContext(newContext, startState, RuleJoinExpr);\n-          setState(1278);\n-\n-          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, \"precpred(_ctx, 4)\");\n-          setState(1280);\n-          _errHandler->sync(this);\n-\n-          _la = _input->LA(1);\n-          if (_la == ClickHouseParser::GLOBAL\n-\n-          || _la == ClickHouseParser::LOCAL) {\n-            setState(1279);\n-            _la = _input->LA(1);\n-            if (!(_la == ClickHouseParser::GLOBAL\n-\n-            || _la == ClickHouseParser::LOCAL)) {\n-            _errHandler->recoverInline(this);\n-            }\n-            else {\n-              _errHandler->reportMatch(this);\n-              consume();\n-            }\n-          }\n-          setState(1283);\n-          _errHandler->sync(this);\n-\n-          _la = _input->LA(1);\n-          if (((((_la - 4) & ~ 0x3fULL) == 0) &&\n-            ((1ULL << (_la - 4)) & ((1ULL << (ClickHouseParser::ALL - 4))\n-            | (1ULL << (ClickHouseParser::ANTI - 4))\n-            | (1ULL << (ClickHouseParser::ANY - 4))\n-            | (1ULL << (ClickHouseParser::ASOF - 4))\n-            | (1ULL << (ClickHouseParser::FULL - 4)))) != 0) || ((((_la - 81) & ~ 0x3fULL) == 0) &&\n-            ((1ULL << (_la - 81)) & ((1ULL << (ClickHouseParser::INNER - 81))\n-            | (1ULL << (ClickHouseParser::LEFT - 81))\n-            | (1ULL << (ClickHouseParser::RIGHT - 81))\n-            | (1ULL << (ClickHouseParser::SEMI - 81)))) != 0)) {\n-            setState(1282);\n-            joinOp();\n-          }\n-          setState(1285);\n-          match(ClickHouseParser::JOIN);\n-          setState(1286);\n-          joinExpr(0);\n-          setState(1287);\n-          joinConstraintClause();\n-          break;\n-        }\n-\n-        } \n-      }\n-      setState(1293);\n-      _errHandler->sync(this);\n-      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 164, _ctx);\n-    }\n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-  return _localctx;\n-}\n-\n-//----------------- JoinOpContext ------------------------------------------------------------------\n-\n-ClickHouseParser::JoinOpContext::JoinOpContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-\n-size_t ClickHouseParser::JoinOpContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleJoinOp;\n-}\n-\n-void ClickHouseParser::JoinOpContext::copyFrom(JoinOpContext *ctx) {\n-  ParserRuleContext::copyFrom(ctx);\n-}\n-\n-//----------------- JoinOpFullContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::JoinOpFullContext::FULL() {\n-  return getToken(ClickHouseParser::FULL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinOpFullContext::OUTER() {\n-  return getToken(ClickHouseParser::OUTER, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinOpFullContext::ALL() {\n-  return getToken(ClickHouseParser::ALL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinOpFullContext::ANY() {\n-  return getToken(ClickHouseParser::ANY, 0);\n-}\n-\n-ClickHouseParser::JoinOpFullContext::JoinOpFullContext(JoinOpContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::JoinOpFullContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitJoinOpFull(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- JoinOpInnerContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::JoinOpInnerContext::INNER() {\n-  return getToken(ClickHouseParser::INNER, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinOpInnerContext::ALL() {\n-  return getToken(ClickHouseParser::ALL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinOpInnerContext::ANY() {\n-  return getToken(ClickHouseParser::ANY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinOpInnerContext::ASOF() {\n-  return getToken(ClickHouseParser::ASOF, 0);\n-}\n-\n-ClickHouseParser::JoinOpInnerContext::JoinOpInnerContext(JoinOpContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::JoinOpInnerContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitJoinOpInner(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- JoinOpLeftRightContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::JoinOpLeftRightContext::LEFT() {\n-  return getToken(ClickHouseParser::LEFT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinOpLeftRightContext::RIGHT() {\n-  return getToken(ClickHouseParser::RIGHT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinOpLeftRightContext::OUTER() {\n-  return getToken(ClickHouseParser::OUTER, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinOpLeftRightContext::SEMI() {\n-  return getToken(ClickHouseParser::SEMI, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinOpLeftRightContext::ALL() {\n-  return getToken(ClickHouseParser::ALL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinOpLeftRightContext::ANTI() {\n-  return getToken(ClickHouseParser::ANTI, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinOpLeftRightContext::ANY() {\n-  return getToken(ClickHouseParser::ANY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinOpLeftRightContext::ASOF() {\n-  return getToken(ClickHouseParser::ASOF, 0);\n-}\n-\n-ClickHouseParser::JoinOpLeftRightContext::JoinOpLeftRightContext(JoinOpContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::JoinOpLeftRightContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitJoinOpLeftRight(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-ClickHouseParser::JoinOpContext* ClickHouseParser::joinOp() {\n-  JoinOpContext *_localctx = _tracker.createInstance<JoinOpContext>(_ctx, getState());\n-  enterRule(_localctx, 136, ClickHouseParser::RuleJoinOp);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(1337);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 178, _ctx)) {\n-    case 1: {\n-      _localctx = dynamic_cast<JoinOpContext *>(_tracker.createInstance<ClickHouseParser::JoinOpInnerContext>(_localctx));\n-      enterOuterAlt(_localctx, 1);\n-      setState(1303);\n-      _errHandler->sync(this);\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 167, _ctx)) {\n-      case 1: {\n-        setState(1295);\n-        _errHandler->sync(this);\n-\n-        _la = _input->LA(1);\n-        if ((((_la & ~ 0x3fULL) == 0) &&\n-          ((1ULL << _la) & ((1ULL << ClickHouseParser::ALL)\n-          | (1ULL << ClickHouseParser::ANY)\n-          | (1ULL << ClickHouseParser::ASOF))) != 0)) {\n-          setState(1294);\n-          _la = _input->LA(1);\n-          if (!((((_la & ~ 0x3fULL) == 0) &&\n-            ((1ULL << _la) & ((1ULL << ClickHouseParser::ALL)\n-            | (1ULL << ClickHouseParser::ANY)\n-            | (1ULL << ClickHouseParser::ASOF))) != 0))) {\n-          _errHandler->recoverInline(this);\n-          }\n-          else {\n-            _errHandler->reportMatch(this);\n-            consume();\n-          }\n-        }\n-        setState(1297);\n-        match(ClickHouseParser::INNER);\n-        break;\n-      }\n-\n-      case 2: {\n-        setState(1298);\n-        match(ClickHouseParser::INNER);\n-        setState(1300);\n-        _errHandler->sync(this);\n-\n-        _la = _input->LA(1);\n-        if ((((_la & ~ 0x3fULL) == 0) &&\n-          ((1ULL << _la) & ((1ULL << ClickHouseParser::ALL)\n-          | (1ULL << ClickHouseParser::ANY)\n-          | (1ULL << ClickHouseParser::ASOF))) != 0)) {\n-          setState(1299);\n-          _la = _input->LA(1);\n-          if (!((((_la & ~ 0x3fULL) == 0) &&\n-            ((1ULL << _la) & ((1ULL << ClickHouseParser::ALL)\n-            | (1ULL << ClickHouseParser::ANY)\n-            | (1ULL << ClickHouseParser::ASOF))) != 0))) {\n-          _errHandler->recoverInline(this);\n-          }\n-          else {\n-            _errHandler->reportMatch(this);\n-            consume();\n-          }\n-        }\n-        break;\n-      }\n-\n-      case 3: {\n-        setState(1302);\n-        _la = _input->LA(1);\n-        if (!((((_la & ~ 0x3fULL) == 0) &&\n-          ((1ULL << _la) & ((1ULL << ClickHouseParser::ALL)\n-          | (1ULL << ClickHouseParser::ANY)\n-          | (1ULL << ClickHouseParser::ASOF))) != 0))) {\n-        _errHandler->recoverInline(this);\n-        }\n-        else {\n-          _errHandler->reportMatch(this);\n-          consume();\n-        }\n-        break;\n-      }\n-\n-      }\n-      break;\n-    }\n-\n-    case 2: {\n-      _localctx = dynamic_cast<JoinOpContext *>(_tracker.createInstance<ClickHouseParser::JoinOpLeftRightContext>(_localctx));\n-      enterOuterAlt(_localctx, 2);\n-      setState(1319);\n-      _errHandler->sync(this);\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 172, _ctx)) {\n-      case 1: {\n-        setState(1306);\n-        _errHandler->sync(this);\n-\n-        _la = _input->LA(1);\n-        if ((((_la & ~ 0x3fULL) == 0) &&\n-          ((1ULL << _la) & ((1ULL << ClickHouseParser::ALL)\n-          | (1ULL << ClickHouseParser::ANTI)\n-          | (1ULL << ClickHouseParser::ANY)\n-          | (1ULL << ClickHouseParser::ASOF))) != 0) || _la == ClickHouseParser::SEMI) {\n-          setState(1305);\n-          _la = _input->LA(1);\n-          if (!((((_la & ~ 0x3fULL) == 0) &&\n-            ((1ULL << _la) & ((1ULL << ClickHouseParser::ALL)\n-            | (1ULL << ClickHouseParser::ANTI)\n-            | (1ULL << ClickHouseParser::ANY)\n-            | (1ULL << ClickHouseParser::ASOF))) != 0) || _la == ClickHouseParser::SEMI)) {\n-          _errHandler->recoverInline(this);\n-          }\n-          else {\n-            _errHandler->reportMatch(this);\n-            consume();\n-          }\n-        }\n-        setState(1308);\n-        _la = _input->LA(1);\n-        if (!(_la == ClickHouseParser::LEFT\n-\n-        || _la == ClickHouseParser::RIGHT)) {\n-        _errHandler->recoverInline(this);\n-        }\n-        else {\n-          _errHandler->reportMatch(this);\n-          consume();\n-        }\n-        setState(1310);\n-        _errHandler->sync(this);\n-\n-        _la = _input->LA(1);\n-        if (_la == ClickHouseParser::OUTER) {\n-          setState(1309);\n-          match(ClickHouseParser::OUTER);\n-        }\n-        break;\n-      }\n-\n-      case 2: {\n-        setState(1312);\n-        _la = _input->LA(1);\n-        if (!(_la == ClickHouseParser::LEFT\n-\n-        || _la == ClickHouseParser::RIGHT)) {\n-        _errHandler->recoverInline(this);\n-        }\n-        else {\n-          _errHandler->reportMatch(this);\n-          consume();\n-        }\n-        setState(1314);\n-        _errHandler->sync(this);\n-\n-        _la = _input->LA(1);\n-        if (_la == ClickHouseParser::OUTER) {\n-          setState(1313);\n-          match(ClickHouseParser::OUTER);\n-        }\n-        setState(1317);\n-        _errHandler->sync(this);\n-\n-        _la = _input->LA(1);\n-        if ((((_la & ~ 0x3fULL) == 0) &&\n-          ((1ULL << _la) & ((1ULL << ClickHouseParser::ALL)\n-          | (1ULL << ClickHouseParser::ANTI)\n-          | (1ULL << ClickHouseParser::ANY)\n-          | (1ULL << ClickHouseParser::ASOF))) != 0) || _la == ClickHouseParser::SEMI) {\n-          setState(1316);\n-          _la = _input->LA(1);\n-          if (!((((_la & ~ 0x3fULL) == 0) &&\n-            ((1ULL << _la) & ((1ULL << ClickHouseParser::ALL)\n-            | (1ULL << ClickHouseParser::ANTI)\n-            | (1ULL << ClickHouseParser::ANY)\n-            | (1ULL << ClickHouseParser::ASOF))) != 0) || _la == ClickHouseParser::SEMI)) {\n-          _errHandler->recoverInline(this);\n-          }\n-          else {\n-            _errHandler->reportMatch(this);\n-            consume();\n-          }\n-        }\n-        break;\n-      }\n-\n-      }\n-      break;\n-    }\n-\n-    case 3: {\n-      _localctx = dynamic_cast<JoinOpContext *>(_tracker.createInstance<ClickHouseParser::JoinOpFullContext>(_localctx));\n-      enterOuterAlt(_localctx, 3);\n-      setState(1335);\n-      _errHandler->sync(this);\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 177, _ctx)) {\n-      case 1: {\n-        setState(1322);\n-        _errHandler->sync(this);\n-\n-        _la = _input->LA(1);\n-        if (_la == ClickHouseParser::ALL\n-\n-        || _la == ClickHouseParser::ANY) {\n-          setState(1321);\n-          _la = _input->LA(1);\n-          if (!(_la == ClickHouseParser::ALL\n-\n-          || _la == ClickHouseParser::ANY)) {\n-          _errHandler->recoverInline(this);\n-          }\n-          else {\n-            _errHandler->reportMatch(this);\n-            consume();\n-          }\n-        }\n-        setState(1324);\n-        match(ClickHouseParser::FULL);\n-        setState(1326);\n-        _errHandler->sync(this);\n-\n-        _la = _input->LA(1);\n-        if (_la == ClickHouseParser::OUTER) {\n-          setState(1325);\n-          match(ClickHouseParser::OUTER);\n-        }\n-        break;\n-      }\n-\n-      case 2: {\n-        setState(1328);\n-        match(ClickHouseParser::FULL);\n-        setState(1330);\n-        _errHandler->sync(this);\n-\n-        _la = _input->LA(1);\n-        if (_la == ClickHouseParser::OUTER) {\n-          setState(1329);\n-          match(ClickHouseParser::OUTER);\n-        }\n-        setState(1333);\n-        _errHandler->sync(this);\n-\n-        _la = _input->LA(1);\n-        if (_la == ClickHouseParser::ALL\n-\n-        || _la == ClickHouseParser::ANY) {\n-          setState(1332);\n-          _la = _input->LA(1);\n-          if (!(_la == ClickHouseParser::ALL\n-\n-          || _la == ClickHouseParser::ANY)) {\n-          _errHandler->recoverInline(this);\n-          }\n-          else {\n-            _errHandler->reportMatch(this);\n-            consume();\n-          }\n-        }\n-        break;\n-      }\n-\n-      }\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- JoinOpCrossContext ------------------------------------------------------------------\n-\n-ClickHouseParser::JoinOpCrossContext::JoinOpCrossContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinOpCrossContext::CROSS() {\n-  return getToken(ClickHouseParser::CROSS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinOpCrossContext::JOIN() {\n-  return getToken(ClickHouseParser::JOIN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinOpCrossContext::GLOBAL() {\n-  return getToken(ClickHouseParser::GLOBAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinOpCrossContext::LOCAL() {\n-  return getToken(ClickHouseParser::LOCAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinOpCrossContext::COMMA() {\n-  return getToken(ClickHouseParser::COMMA, 0);\n-}\n-\n-\n-size_t ClickHouseParser::JoinOpCrossContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleJoinOpCross;\n-}\n-\n-antlrcpp::Any ClickHouseParser::JoinOpCrossContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitJoinOpCross(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::JoinOpCrossContext* ClickHouseParser::joinOpCross() {\n-  JoinOpCrossContext *_localctx = _tracker.createInstance<JoinOpCrossContext>(_ctx, getState());\n-  enterRule(_localctx, 138, ClickHouseParser::RuleJoinOpCross);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(1345);\n-    _errHandler->sync(this);\n-    switch (_input->LA(1)) {\n-      case ClickHouseParser::CROSS:\n-      case ClickHouseParser::GLOBAL:\n-      case ClickHouseParser::LOCAL: {\n-        enterOuterAlt(_localctx, 1);\n-        setState(1340);\n-        _errHandler->sync(this);\n-\n-        _la = _input->LA(1);\n-        if (_la == ClickHouseParser::GLOBAL\n-\n-        || _la == ClickHouseParser::LOCAL) {\n-          setState(1339);\n-          _la = _input->LA(1);\n-          if (!(_la == ClickHouseParser::GLOBAL\n-\n-          || _la == ClickHouseParser::LOCAL)) {\n-          _errHandler->recoverInline(this);\n-          }\n-          else {\n-            _errHandler->reportMatch(this);\n-            consume();\n-          }\n-        }\n-        setState(1342);\n-        match(ClickHouseParser::CROSS);\n-        setState(1343);\n-        match(ClickHouseParser::JOIN);\n-        break;\n-      }\n-\n-      case ClickHouseParser::COMMA: {\n-        enterOuterAlt(_localctx, 2);\n-        setState(1344);\n-        match(ClickHouseParser::COMMA);\n-        break;\n-      }\n-\n-    default:\n-      throw NoViableAltException(this);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- JoinConstraintClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::JoinConstraintClauseContext::JoinConstraintClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinConstraintClauseContext::ON() {\n-  return getToken(ClickHouseParser::ON, 0);\n-}\n-\n-ClickHouseParser::ColumnExprListContext* ClickHouseParser::JoinConstraintClauseContext::columnExprList() {\n-  return getRuleContext<ClickHouseParser::ColumnExprListContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinConstraintClauseContext::USING() {\n-  return getToken(ClickHouseParser::USING, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinConstraintClauseContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::JoinConstraintClauseContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-\n-size_t ClickHouseParser::JoinConstraintClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleJoinConstraintClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::JoinConstraintClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitJoinConstraintClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::JoinConstraintClauseContext* ClickHouseParser::joinConstraintClause() {\n-  JoinConstraintClauseContext *_localctx = _tracker.createInstance<JoinConstraintClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 140, ClickHouseParser::RuleJoinConstraintClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(1356);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 181, _ctx)) {\n-    case 1: {\n-      enterOuterAlt(_localctx, 1);\n-      setState(1347);\n-      match(ClickHouseParser::ON);\n-      setState(1348);\n-      columnExprList();\n-      break;\n-    }\n-\n-    case 2: {\n-      enterOuterAlt(_localctx, 2);\n-      setState(1349);\n-      match(ClickHouseParser::USING);\n-      setState(1350);\n-      match(ClickHouseParser::LPAREN);\n-      setState(1351);\n-      columnExprList();\n-      setState(1352);\n-      match(ClickHouseParser::RPAREN);\n-      break;\n-    }\n-\n-    case 3: {\n-      enterOuterAlt(_localctx, 3);\n-      setState(1354);\n-      match(ClickHouseParser::USING);\n-      setState(1355);\n-      columnExprList();\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- SampleClauseContext ------------------------------------------------------------------\n-\n-ClickHouseParser::SampleClauseContext::SampleClauseContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SampleClauseContext::SAMPLE() {\n-  return getToken(ClickHouseParser::SAMPLE, 0);\n-}\n-\n-std::vector<ClickHouseParser::RatioExprContext *> ClickHouseParser::SampleClauseContext::ratioExpr() {\n-  return getRuleContexts<ClickHouseParser::RatioExprContext>();\n-}\n-\n-ClickHouseParser::RatioExprContext* ClickHouseParser::SampleClauseContext::ratioExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::RatioExprContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SampleClauseContext::OFFSET() {\n-  return getToken(ClickHouseParser::OFFSET, 0);\n-}\n-\n-\n-size_t ClickHouseParser::SampleClauseContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleSampleClause;\n-}\n-\n-antlrcpp::Any ClickHouseParser::SampleClauseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitSampleClause(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::SampleClauseContext* ClickHouseParser::sampleClause() {\n-  SampleClauseContext *_localctx = _tracker.createInstance<SampleClauseContext>(_ctx, getState());\n-  enterRule(_localctx, 142, ClickHouseParser::RuleSampleClause);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1358);\n-    match(ClickHouseParser::SAMPLE);\n-    setState(1359);\n-    ratioExpr();\n-    setState(1362);\n-    _errHandler->sync(this);\n-\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 182, _ctx)) {\n-    case 1: {\n-      setState(1360);\n-      match(ClickHouseParser::OFFSET);\n-      setState(1361);\n-      ratioExpr();\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- LimitExprContext ------------------------------------------------------------------\n-\n-ClickHouseParser::LimitExprContext::LimitExprContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-std::vector<ClickHouseParser::ColumnExprContext *> ClickHouseParser::LimitExprContext::columnExpr() {\n-  return getRuleContexts<ClickHouseParser::ColumnExprContext>();\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::LimitExprContext::columnExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::LimitExprContext::COMMA() {\n-  return getToken(ClickHouseParser::COMMA, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::LimitExprContext::OFFSET() {\n-  return getToken(ClickHouseParser::OFFSET, 0);\n-}\n-\n-\n-size_t ClickHouseParser::LimitExprContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleLimitExpr;\n-}\n-\n-antlrcpp::Any ClickHouseParser::LimitExprContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitLimitExpr(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::LimitExprContext* ClickHouseParser::limitExpr() {\n-  LimitExprContext *_localctx = _tracker.createInstance<LimitExprContext>(_ctx, getState());\n-  enterRule(_localctx, 144, ClickHouseParser::RuleLimitExpr);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1364);\n-    columnExpr(0);\n-    setState(1367);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::OFFSET || _la == ClickHouseParser::COMMA) {\n-      setState(1365);\n-      _la = _input->LA(1);\n-      if (!(_la == ClickHouseParser::OFFSET || _la == ClickHouseParser::COMMA)) {\n-      _errHandler->recoverInline(this);\n-      }\n-      else {\n-        _errHandler->reportMatch(this);\n-        consume();\n-      }\n-      setState(1366);\n-      columnExpr(0);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- OrderExprListContext ------------------------------------------------------------------\n-\n-ClickHouseParser::OrderExprListContext::OrderExprListContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-std::vector<ClickHouseParser::OrderExprContext *> ClickHouseParser::OrderExprListContext::orderExpr() {\n-  return getRuleContexts<ClickHouseParser::OrderExprContext>();\n-}\n-\n-ClickHouseParser::OrderExprContext* ClickHouseParser::OrderExprListContext::orderExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::OrderExprContext>(i);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::OrderExprListContext::COMMA() {\n-  return getTokens(ClickHouseParser::COMMA);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::OrderExprListContext::COMMA(size_t i) {\n-  return getToken(ClickHouseParser::COMMA, i);\n-}\n-\n-\n-size_t ClickHouseParser::OrderExprListContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleOrderExprList;\n-}\n-\n-antlrcpp::Any ClickHouseParser::OrderExprListContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitOrderExprList(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::OrderExprListContext* ClickHouseParser::orderExprList() {\n-  OrderExprListContext *_localctx = _tracker.createInstance<OrderExprListContext>(_ctx, getState());\n-  enterRule(_localctx, 146, ClickHouseParser::RuleOrderExprList);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    size_t alt;\n-    enterOuterAlt(_localctx, 1);\n-    setState(1369);\n-    orderExpr();\n-    setState(1374);\n-    _errHandler->sync(this);\n-    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 184, _ctx);\n-    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {\n-      if (alt == 1) {\n-        setState(1370);\n-        match(ClickHouseParser::COMMA);\n-        setState(1371);\n-        orderExpr(); \n-      }\n-      setState(1376);\n-      _errHandler->sync(this);\n-      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 184, _ctx);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- OrderExprContext ------------------------------------------------------------------\n-\n-ClickHouseParser::OrderExprContext::OrderExprContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::OrderExprContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::OrderExprContext::NULLS() {\n-  return getToken(ClickHouseParser::NULLS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::OrderExprContext::COLLATE() {\n-  return getToken(ClickHouseParser::COLLATE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::OrderExprContext::STRING_LITERAL() {\n-  return getToken(ClickHouseParser::STRING_LITERAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::OrderExprContext::ASCENDING() {\n-  return getToken(ClickHouseParser::ASCENDING, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::OrderExprContext::DESCENDING() {\n-  return getToken(ClickHouseParser::DESCENDING, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::OrderExprContext::DESC() {\n-  return getToken(ClickHouseParser::DESC, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::OrderExprContext::FIRST() {\n-  return getToken(ClickHouseParser::FIRST, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::OrderExprContext::LAST() {\n-  return getToken(ClickHouseParser::LAST, 0);\n-}\n-\n-\n-size_t ClickHouseParser::OrderExprContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleOrderExpr;\n-}\n-\n-antlrcpp::Any ClickHouseParser::OrderExprContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitOrderExpr(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::OrderExprContext* ClickHouseParser::orderExpr() {\n-  OrderExprContext *_localctx = _tracker.createInstance<OrderExprContext>(_ctx, getState());\n-  enterRule(_localctx, 148, ClickHouseParser::RuleOrderExpr);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1377);\n-    columnExpr(0);\n-    setState(1379);\n-    _errHandler->sync(this);\n-\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 185, _ctx)) {\n-    case 1: {\n-      setState(1378);\n-      _la = _input->LA(1);\n-      if (!((((_la & ~ 0x3fULL) == 0) &&\n-        ((1ULL << _la) & ((1ULL << ClickHouseParser::ASCENDING)\n-        | (1ULL << ClickHouseParser::DESC)\n-        | (1ULL << ClickHouseParser::DESCENDING))) != 0))) {\n-      _errHandler->recoverInline(this);\n-      }\n-      else {\n-        _errHandler->reportMatch(this);\n-        consume();\n-      }\n-      break;\n-    }\n-\n-    }\n-    setState(1383);\n-    _errHandler->sync(this);\n-\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 186, _ctx)) {\n-    case 1: {\n-      setState(1381);\n-      match(ClickHouseParser::NULLS);\n-      setState(1382);\n-      _la = _input->LA(1);\n-      if (!(_la == ClickHouseParser::FIRST\n-\n-      || _la == ClickHouseParser::LAST)) {\n-      _errHandler->recoverInline(this);\n-      }\n-      else {\n-        _errHandler->reportMatch(this);\n-        consume();\n-      }\n-      break;\n-    }\n-\n-    }\n-    setState(1387);\n-    _errHandler->sync(this);\n-\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 187, _ctx)) {\n-    case 1: {\n-      setState(1385);\n-      match(ClickHouseParser::COLLATE);\n-      setState(1386);\n-      match(ClickHouseParser::STRING_LITERAL);\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- RatioExprContext ------------------------------------------------------------------\n-\n-ClickHouseParser::RatioExprContext::RatioExprContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-std::vector<ClickHouseParser::NumberLiteralContext *> ClickHouseParser::RatioExprContext::numberLiteral() {\n-  return getRuleContexts<ClickHouseParser::NumberLiteralContext>();\n-}\n-\n-ClickHouseParser::NumberLiteralContext* ClickHouseParser::RatioExprContext::numberLiteral(size_t i) {\n-  return getRuleContext<ClickHouseParser::NumberLiteralContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::RatioExprContext::SLASH() {\n-  return getToken(ClickHouseParser::SLASH, 0);\n-}\n-\n-\n-size_t ClickHouseParser::RatioExprContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleRatioExpr;\n-}\n-\n-antlrcpp::Any ClickHouseParser::RatioExprContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitRatioExpr(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::RatioExprContext* ClickHouseParser::ratioExpr() {\n-  RatioExprContext *_localctx = _tracker.createInstance<RatioExprContext>(_ctx, getState());\n-  enterRule(_localctx, 150, ClickHouseParser::RuleRatioExpr);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1389);\n-    numberLiteral();\n-    setState(1392);\n-    _errHandler->sync(this);\n-\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 188, _ctx)) {\n-    case 1: {\n-      setState(1390);\n-      match(ClickHouseParser::SLASH);\n-      setState(1391);\n-      numberLiteral();\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- SettingExprListContext ------------------------------------------------------------------\n-\n-ClickHouseParser::SettingExprListContext::SettingExprListContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-std::vector<ClickHouseParser::SettingExprContext *> ClickHouseParser::SettingExprListContext::settingExpr() {\n-  return getRuleContexts<ClickHouseParser::SettingExprContext>();\n-}\n-\n-ClickHouseParser::SettingExprContext* ClickHouseParser::SettingExprListContext::settingExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::SettingExprContext>(i);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::SettingExprListContext::COMMA() {\n-  return getTokens(ClickHouseParser::COMMA);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SettingExprListContext::COMMA(size_t i) {\n-  return getToken(ClickHouseParser::COMMA, i);\n-}\n-\n-\n-size_t ClickHouseParser::SettingExprListContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleSettingExprList;\n-}\n-\n-antlrcpp::Any ClickHouseParser::SettingExprListContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitSettingExprList(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::SettingExprListContext* ClickHouseParser::settingExprList() {\n-  SettingExprListContext *_localctx = _tracker.createInstance<SettingExprListContext>(_ctx, getState());\n-  enterRule(_localctx, 152, ClickHouseParser::RuleSettingExprList);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    size_t alt;\n-    enterOuterAlt(_localctx, 1);\n-    setState(1394);\n-    settingExpr();\n-    setState(1399);\n-    _errHandler->sync(this);\n-    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 189, _ctx);\n-    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {\n-      if (alt == 1) {\n-        setState(1395);\n-        match(ClickHouseParser::COMMA);\n-        setState(1396);\n-        settingExpr(); \n-      }\n-      setState(1401);\n-      _errHandler->sync(this);\n-      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 189, _ctx);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- SettingExprContext ------------------------------------------------------------------\n-\n-ClickHouseParser::SettingExprContext::SettingExprContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::SettingExprContext::identifier() {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SettingExprContext::EQ_SINGLE() {\n-  return getToken(ClickHouseParser::EQ_SINGLE, 0);\n-}\n-\n-ClickHouseParser::LiteralContext* ClickHouseParser::SettingExprContext::literal() {\n-  return getRuleContext<ClickHouseParser::LiteralContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::SettingExprContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleSettingExpr;\n-}\n-\n-antlrcpp::Any ClickHouseParser::SettingExprContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitSettingExpr(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::SettingExprContext* ClickHouseParser::settingExpr() {\n-  SettingExprContext *_localctx = _tracker.createInstance<SettingExprContext>(_ctx, getState());\n-  enterRule(_localctx, 154, ClickHouseParser::RuleSettingExpr);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1402);\n-    identifier();\n-    setState(1403);\n-    match(ClickHouseParser::EQ_SINGLE);\n-    setState(1404);\n-    literal();\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- SetStmtContext ------------------------------------------------------------------\n-\n-ClickHouseParser::SetStmtContext::SetStmtContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SetStmtContext::SET() {\n-  return getToken(ClickHouseParser::SET, 0);\n-}\n-\n-ClickHouseParser::SettingExprListContext* ClickHouseParser::SetStmtContext::settingExprList() {\n-  return getRuleContext<ClickHouseParser::SettingExprListContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::SetStmtContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleSetStmt;\n-}\n-\n-antlrcpp::Any ClickHouseParser::SetStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitSetStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::SetStmtContext* ClickHouseParser::setStmt() {\n-  SetStmtContext *_localctx = _tracker.createInstance<SetStmtContext>(_ctx, getState());\n-  enterRule(_localctx, 156, ClickHouseParser::RuleSetStmt);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1406);\n-    match(ClickHouseParser::SET);\n-    setState(1407);\n-    settingExprList();\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- ShowStmtContext ------------------------------------------------------------------\n-\n-ClickHouseParser::ShowStmtContext::ShowStmtContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-\n-size_t ClickHouseParser::ShowStmtContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleShowStmt;\n-}\n-\n-void ClickHouseParser::ShowStmtContext::copyFrom(ShowStmtContext *ctx) {\n-  ParserRuleContext::copyFrom(ctx);\n-}\n-\n-//----------------- ShowCreateDatabaseStmtContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ShowCreateDatabaseStmtContext::SHOW() {\n-  return getToken(ClickHouseParser::SHOW, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ShowCreateDatabaseStmtContext::CREATE() {\n-  return getToken(ClickHouseParser::CREATE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ShowCreateDatabaseStmtContext::DATABASE() {\n-  return getToken(ClickHouseParser::DATABASE, 0);\n-}\n-\n-ClickHouseParser::DatabaseIdentifierContext* ClickHouseParser::ShowCreateDatabaseStmtContext::databaseIdentifier() {\n-  return getRuleContext<ClickHouseParser::DatabaseIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::ShowCreateDatabaseStmtContext::ShowCreateDatabaseStmtContext(ShowStmtContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ShowCreateDatabaseStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitShowCreateDatabaseStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ShowDatabasesStmtContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ShowDatabasesStmtContext::SHOW() {\n-  return getToken(ClickHouseParser::SHOW, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ShowDatabasesStmtContext::DATABASES() {\n-  return getToken(ClickHouseParser::DATABASES, 0);\n-}\n-\n-ClickHouseParser::ShowDatabasesStmtContext::ShowDatabasesStmtContext(ShowStmtContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ShowDatabasesStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitShowDatabasesStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ShowCreateTableStmtContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ShowCreateTableStmtContext::SHOW() {\n-  return getToken(ClickHouseParser::SHOW, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ShowCreateTableStmtContext::CREATE() {\n-  return getToken(ClickHouseParser::CREATE, 0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::ShowCreateTableStmtContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ShowCreateTableStmtContext::TEMPORARY() {\n-  return getToken(ClickHouseParser::TEMPORARY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ShowCreateTableStmtContext::TABLE() {\n-  return getToken(ClickHouseParser::TABLE, 0);\n-}\n-\n-ClickHouseParser::ShowCreateTableStmtContext::ShowCreateTableStmtContext(ShowStmtContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ShowCreateTableStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitShowCreateTableStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ShowTablesStmtContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ShowTablesStmtContext::SHOW() {\n-  return getToken(ClickHouseParser::SHOW, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ShowTablesStmtContext::TABLES() {\n-  return getToken(ClickHouseParser::TABLES, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ShowTablesStmtContext::TEMPORARY() {\n-  return getToken(ClickHouseParser::TEMPORARY, 0);\n-}\n-\n-ClickHouseParser::DatabaseIdentifierContext* ClickHouseParser::ShowTablesStmtContext::databaseIdentifier() {\n-  return getRuleContext<ClickHouseParser::DatabaseIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ShowTablesStmtContext::LIKE() {\n-  return getToken(ClickHouseParser::LIKE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ShowTablesStmtContext::STRING_LITERAL() {\n-  return getToken(ClickHouseParser::STRING_LITERAL, 0);\n-}\n-\n-ClickHouseParser::WhereClauseContext* ClickHouseParser::ShowTablesStmtContext::whereClause() {\n-  return getRuleContext<ClickHouseParser::WhereClauseContext>(0);\n-}\n-\n-ClickHouseParser::LimitClauseContext* ClickHouseParser::ShowTablesStmtContext::limitClause() {\n-  return getRuleContext<ClickHouseParser::LimitClauseContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ShowTablesStmtContext::FROM() {\n-  return getToken(ClickHouseParser::FROM, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ShowTablesStmtContext::IN() {\n-  return getToken(ClickHouseParser::IN, 0);\n-}\n-\n-ClickHouseParser::ShowTablesStmtContext::ShowTablesStmtContext(ShowStmtContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ShowTablesStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitShowTablesStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ShowDictionariesStmtContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ShowDictionariesStmtContext::SHOW() {\n-  return getToken(ClickHouseParser::SHOW, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ShowDictionariesStmtContext::DICTIONARIES() {\n-  return getToken(ClickHouseParser::DICTIONARIES, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ShowDictionariesStmtContext::FROM() {\n-  return getToken(ClickHouseParser::FROM, 0);\n-}\n-\n-ClickHouseParser::DatabaseIdentifierContext* ClickHouseParser::ShowDictionariesStmtContext::databaseIdentifier() {\n-  return getRuleContext<ClickHouseParser::DatabaseIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::ShowDictionariesStmtContext::ShowDictionariesStmtContext(ShowStmtContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ShowDictionariesStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitShowDictionariesStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ShowCreateDictionaryStmtContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ShowCreateDictionaryStmtContext::SHOW() {\n-  return getToken(ClickHouseParser::SHOW, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ShowCreateDictionaryStmtContext::CREATE() {\n-  return getToken(ClickHouseParser::CREATE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ShowCreateDictionaryStmtContext::DICTIONARY() {\n-  return getToken(ClickHouseParser::DICTIONARY, 0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::ShowCreateDictionaryStmtContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::ShowCreateDictionaryStmtContext::ShowCreateDictionaryStmtContext(ShowStmtContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ShowCreateDictionaryStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitShowCreateDictionaryStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-ClickHouseParser::ShowStmtContext* ClickHouseParser::showStmt() {\n-  ShowStmtContext *_localctx = _tracker.createInstance<ShowStmtContext>(_ctx, getState());\n-  enterRule(_localctx, 158, ClickHouseParser::RuleShowStmt);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(1451);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 197, _ctx)) {\n-    case 1: {\n-      _localctx = dynamic_cast<ShowStmtContext *>(_tracker.createInstance<ClickHouseParser::ShowCreateDatabaseStmtContext>(_localctx));\n-      enterOuterAlt(_localctx, 1);\n-      setState(1409);\n-      match(ClickHouseParser::SHOW);\n-      setState(1410);\n-      match(ClickHouseParser::CREATE);\n-      setState(1411);\n-      match(ClickHouseParser::DATABASE);\n-      setState(1412);\n-      databaseIdentifier();\n-      break;\n-    }\n-\n-    case 2: {\n-      _localctx = dynamic_cast<ShowStmtContext *>(_tracker.createInstance<ClickHouseParser::ShowCreateDictionaryStmtContext>(_localctx));\n-      enterOuterAlt(_localctx, 2);\n-      setState(1413);\n-      match(ClickHouseParser::SHOW);\n-      setState(1414);\n-      match(ClickHouseParser::CREATE);\n-      setState(1415);\n-      match(ClickHouseParser::DICTIONARY);\n-      setState(1416);\n-      tableIdentifier();\n-      break;\n-    }\n-\n-    case 3: {\n-      _localctx = dynamic_cast<ShowStmtContext *>(_tracker.createInstance<ClickHouseParser::ShowCreateTableStmtContext>(_localctx));\n-      enterOuterAlt(_localctx, 3);\n-      setState(1417);\n-      match(ClickHouseParser::SHOW);\n-      setState(1418);\n-      match(ClickHouseParser::CREATE);\n-      setState(1420);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 190, _ctx)) {\n-      case 1: {\n-        setState(1419);\n-        match(ClickHouseParser::TEMPORARY);\n-        break;\n-      }\n-\n-      }\n-      setState(1423);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 191, _ctx)) {\n-      case 1: {\n-        setState(1422);\n-        match(ClickHouseParser::TABLE);\n-        break;\n-      }\n-\n-      }\n-      setState(1425);\n-      tableIdentifier();\n-      break;\n-    }\n-\n-    case 4: {\n-      _localctx = dynamic_cast<ShowStmtContext *>(_tracker.createInstance<ClickHouseParser::ShowDatabasesStmtContext>(_localctx));\n-      enterOuterAlt(_localctx, 4);\n-      setState(1426);\n-      match(ClickHouseParser::SHOW);\n-      setState(1427);\n-      match(ClickHouseParser::DATABASES);\n-      break;\n-    }\n-\n-    case 5: {\n-      _localctx = dynamic_cast<ShowStmtContext *>(_tracker.createInstance<ClickHouseParser::ShowDictionariesStmtContext>(_localctx));\n-      enterOuterAlt(_localctx, 5);\n-      setState(1428);\n-      match(ClickHouseParser::SHOW);\n-      setState(1429);\n-      match(ClickHouseParser::DICTIONARIES);\n-      setState(1432);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::FROM) {\n-        setState(1430);\n-        match(ClickHouseParser::FROM);\n-        setState(1431);\n-        databaseIdentifier();\n-      }\n-      break;\n-    }\n-\n-    case 6: {\n-      _localctx = dynamic_cast<ShowStmtContext *>(_tracker.createInstance<ClickHouseParser::ShowTablesStmtContext>(_localctx));\n-      enterOuterAlt(_localctx, 6);\n-      setState(1434);\n-      match(ClickHouseParser::SHOW);\n-      setState(1436);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::TEMPORARY) {\n-        setState(1435);\n-        match(ClickHouseParser::TEMPORARY);\n-      }\n-      setState(1438);\n-      match(ClickHouseParser::TABLES);\n-      setState(1441);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::FROM\n-\n-      || _la == ClickHouseParser::IN) {\n-        setState(1439);\n-        _la = _input->LA(1);\n-        if (!(_la == ClickHouseParser::FROM\n-\n-        || _la == ClickHouseParser::IN)) {\n-        _errHandler->recoverInline(this);\n-        }\n-        else {\n-          _errHandler->reportMatch(this);\n-          consume();\n-        }\n-        setState(1440);\n-        databaseIdentifier();\n-      }\n-      setState(1446);\n-      _errHandler->sync(this);\n-      switch (_input->LA(1)) {\n-        case ClickHouseParser::LIKE: {\n-          setState(1443);\n-          match(ClickHouseParser::LIKE);\n-          setState(1444);\n-          match(ClickHouseParser::STRING_LITERAL);\n-          break;\n-        }\n-\n-        case ClickHouseParser::WHERE: {\n-          setState(1445);\n-          whereClause();\n-          break;\n-        }\n-\n-        case ClickHouseParser::EOF:\n-        case ClickHouseParser::FORMAT:\n-        case ClickHouseParser::INTO:\n-        case ClickHouseParser::LIMIT:\n-        case ClickHouseParser::SEMICOLON: {\n-          break;\n-        }\n-\n-      default:\n-        break;\n-      }\n-      setState(1449);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::LIMIT) {\n-        setState(1448);\n-        limitClause();\n-      }\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- SystemStmtContext ------------------------------------------------------------------\n-\n-ClickHouseParser::SystemStmtContext::SystemStmtContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SystemStmtContext::SYSTEM() {\n-  return getToken(ClickHouseParser::SYSTEM, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SystemStmtContext::FLUSH() {\n-  return getToken(ClickHouseParser::FLUSH, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SystemStmtContext::DISTRIBUTED() {\n-  return getToken(ClickHouseParser::DISTRIBUTED, 0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::SystemStmtContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SystemStmtContext::LOGS() {\n-  return getToken(ClickHouseParser::LOGS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SystemStmtContext::RELOAD() {\n-  return getToken(ClickHouseParser::RELOAD, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SystemStmtContext::DICTIONARIES() {\n-  return getToken(ClickHouseParser::DICTIONARIES, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SystemStmtContext::DICTIONARY() {\n-  return getToken(ClickHouseParser::DICTIONARY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SystemStmtContext::START() {\n-  return getToken(ClickHouseParser::START, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SystemStmtContext::STOP() {\n-  return getToken(ClickHouseParser::STOP, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SystemStmtContext::SENDS() {\n-  return getToken(ClickHouseParser::SENDS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SystemStmtContext::FETCHES() {\n-  return getToken(ClickHouseParser::FETCHES, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SystemStmtContext::MERGES() {\n-  return getToken(ClickHouseParser::MERGES, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SystemStmtContext::TTL() {\n-  return getToken(ClickHouseParser::TTL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SystemStmtContext::REPLICATED() {\n-  return getToken(ClickHouseParser::REPLICATED, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SystemStmtContext::SYNC() {\n-  return getToken(ClickHouseParser::SYNC, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::SystemStmtContext::REPLICA() {\n-  return getToken(ClickHouseParser::REPLICA, 0);\n-}\n-\n-\n-size_t ClickHouseParser::SystemStmtContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleSystemStmt;\n-}\n-\n-antlrcpp::Any ClickHouseParser::SystemStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitSystemStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::SystemStmtContext* ClickHouseParser::systemStmt() {\n-  SystemStmtContext *_localctx = _tracker.createInstance<SystemStmtContext>(_ctx, getState());\n-  enterRule(_localctx, 160, ClickHouseParser::RuleSystemStmt);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(1487);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 200, _ctx)) {\n-    case 1: {\n-      enterOuterAlt(_localctx, 1);\n-      setState(1453);\n-      match(ClickHouseParser::SYSTEM);\n-      setState(1454);\n-      match(ClickHouseParser::FLUSH);\n-      setState(1455);\n-      match(ClickHouseParser::DISTRIBUTED);\n-      setState(1456);\n-      tableIdentifier();\n-      break;\n-    }\n-\n-    case 2: {\n-      enterOuterAlt(_localctx, 2);\n-      setState(1457);\n-      match(ClickHouseParser::SYSTEM);\n-      setState(1458);\n-      match(ClickHouseParser::FLUSH);\n-      setState(1459);\n-      match(ClickHouseParser::LOGS);\n-      break;\n-    }\n-\n-    case 3: {\n-      enterOuterAlt(_localctx, 3);\n-      setState(1460);\n-      match(ClickHouseParser::SYSTEM);\n-      setState(1461);\n-      match(ClickHouseParser::RELOAD);\n-      setState(1462);\n-      match(ClickHouseParser::DICTIONARIES);\n-      break;\n-    }\n-\n-    case 4: {\n-      enterOuterAlt(_localctx, 4);\n-      setState(1463);\n-      match(ClickHouseParser::SYSTEM);\n-      setState(1464);\n-      match(ClickHouseParser::RELOAD);\n-      setState(1465);\n-      match(ClickHouseParser::DICTIONARY);\n-      setState(1466);\n-      tableIdentifier();\n-      break;\n-    }\n-\n-    case 5: {\n-      enterOuterAlt(_localctx, 5);\n-      setState(1467);\n-      match(ClickHouseParser::SYSTEM);\n-      setState(1468);\n-      _la = _input->LA(1);\n-      if (!(_la == ClickHouseParser::START\n-\n-      || _la == ClickHouseParser::STOP)) {\n-      _errHandler->recoverInline(this);\n-      }\n-      else {\n-        _errHandler->reportMatch(this);\n-        consume();\n-      }\n-      setState(1476);\n-      _errHandler->sync(this);\n-      switch (_input->LA(1)) {\n-        case ClickHouseParser::DISTRIBUTED: {\n-          setState(1469);\n-          match(ClickHouseParser::DISTRIBUTED);\n-          setState(1470);\n-          match(ClickHouseParser::SENDS);\n-          break;\n-        }\n-\n-        case ClickHouseParser::FETCHES: {\n-          setState(1471);\n-          match(ClickHouseParser::FETCHES);\n-          break;\n-        }\n-\n-        case ClickHouseParser::MERGES:\n-        case ClickHouseParser::TTL: {\n-          setState(1473);\n-          _errHandler->sync(this);\n-\n-          _la = _input->LA(1);\n-          if (_la == ClickHouseParser::TTL) {\n-            setState(1472);\n-            match(ClickHouseParser::TTL);\n-          }\n-          setState(1475);\n-          match(ClickHouseParser::MERGES);\n-          break;\n-        }\n-\n-      default:\n-        throw NoViableAltException(this);\n-      }\n-      setState(1478);\n-      tableIdentifier();\n-      break;\n-    }\n-\n-    case 6: {\n-      enterOuterAlt(_localctx, 6);\n-      setState(1479);\n-      match(ClickHouseParser::SYSTEM);\n-      setState(1480);\n-      _la = _input->LA(1);\n-      if (!(_la == ClickHouseParser::START\n-\n-      || _la == ClickHouseParser::STOP)) {\n-      _errHandler->recoverInline(this);\n-      }\n-      else {\n-        _errHandler->reportMatch(this);\n-        consume();\n-      }\n-      setState(1481);\n-      match(ClickHouseParser::REPLICATED);\n-      setState(1482);\n-      match(ClickHouseParser::SENDS);\n-      break;\n-    }\n-\n-    case 7: {\n-      enterOuterAlt(_localctx, 7);\n-      setState(1483);\n-      match(ClickHouseParser::SYSTEM);\n-      setState(1484);\n-      match(ClickHouseParser::SYNC);\n-      setState(1485);\n-      match(ClickHouseParser::REPLICA);\n-      setState(1486);\n-      tableIdentifier();\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- TruncateStmtContext ------------------------------------------------------------------\n-\n-ClickHouseParser::TruncateStmtContext::TruncateStmtContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TruncateStmtContext::TRUNCATE() {\n-  return getToken(ClickHouseParser::TRUNCATE, 0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::TruncateStmtContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TruncateStmtContext::TEMPORARY() {\n-  return getToken(ClickHouseParser::TEMPORARY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TruncateStmtContext::TABLE() {\n-  return getToken(ClickHouseParser::TABLE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TruncateStmtContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TruncateStmtContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-ClickHouseParser::ClusterClauseContext* ClickHouseParser::TruncateStmtContext::clusterClause() {\n-  return getRuleContext<ClickHouseParser::ClusterClauseContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::TruncateStmtContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleTruncateStmt;\n-}\n-\n-antlrcpp::Any ClickHouseParser::TruncateStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitTruncateStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::TruncateStmtContext* ClickHouseParser::truncateStmt() {\n-  TruncateStmtContext *_localctx = _tracker.createInstance<TruncateStmtContext>(_ctx, getState());\n-  enterRule(_localctx, 162, ClickHouseParser::RuleTruncateStmt);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1489);\n-    match(ClickHouseParser::TRUNCATE);\n-    setState(1491);\n-    _errHandler->sync(this);\n-\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 201, _ctx)) {\n-    case 1: {\n-      setState(1490);\n-      match(ClickHouseParser::TEMPORARY);\n-      break;\n-    }\n-\n-    }\n-    setState(1494);\n-    _errHandler->sync(this);\n-\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 202, _ctx)) {\n-    case 1: {\n-      setState(1493);\n-      match(ClickHouseParser::TABLE);\n-      break;\n-    }\n-\n-    }\n-    setState(1498);\n-    _errHandler->sync(this);\n-\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 203, _ctx)) {\n-    case 1: {\n-      setState(1496);\n-      match(ClickHouseParser::IF);\n-      setState(1497);\n-      match(ClickHouseParser::EXISTS);\n-      break;\n-    }\n-\n-    }\n-    setState(1500);\n-    tableIdentifier();\n-    setState(1502);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::ON) {\n-      setState(1501);\n-      clusterClause();\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- UseStmtContext ------------------------------------------------------------------\n-\n-ClickHouseParser::UseStmtContext::UseStmtContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::UseStmtContext::USE() {\n-  return getToken(ClickHouseParser::USE, 0);\n-}\n-\n-ClickHouseParser::DatabaseIdentifierContext* ClickHouseParser::UseStmtContext::databaseIdentifier() {\n-  return getRuleContext<ClickHouseParser::DatabaseIdentifierContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::UseStmtContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleUseStmt;\n-}\n-\n-antlrcpp::Any ClickHouseParser::UseStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitUseStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::UseStmtContext* ClickHouseParser::useStmt() {\n-  UseStmtContext *_localctx = _tracker.createInstance<UseStmtContext>(_ctx, getState());\n-  enterRule(_localctx, 164, ClickHouseParser::RuleUseStmt);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1504);\n-    match(ClickHouseParser::USE);\n-    setState(1505);\n-    databaseIdentifier();\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- WatchStmtContext ------------------------------------------------------------------\n-\n-ClickHouseParser::WatchStmtContext::WatchStmtContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::WatchStmtContext::WATCH() {\n-  return getToken(ClickHouseParser::WATCH, 0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::WatchStmtContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::WatchStmtContext::EVENTS() {\n-  return getToken(ClickHouseParser::EVENTS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::WatchStmtContext::LIMIT() {\n-  return getToken(ClickHouseParser::LIMIT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::WatchStmtContext::DECIMAL_LITERAL() {\n-  return getToken(ClickHouseParser::DECIMAL_LITERAL, 0);\n-}\n-\n-\n-size_t ClickHouseParser::WatchStmtContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleWatchStmt;\n-}\n-\n-antlrcpp::Any ClickHouseParser::WatchStmtContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitWatchStmt(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::WatchStmtContext* ClickHouseParser::watchStmt() {\n-  WatchStmtContext *_localctx = _tracker.createInstance<WatchStmtContext>(_ctx, getState());\n-  enterRule(_localctx, 166, ClickHouseParser::RuleWatchStmt);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1507);\n-    match(ClickHouseParser::WATCH);\n-    setState(1508);\n-    tableIdentifier();\n-    setState(1510);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::EVENTS) {\n-      setState(1509);\n-      match(ClickHouseParser::EVENTS);\n-    }\n-    setState(1514);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::LIMIT) {\n-      setState(1512);\n-      match(ClickHouseParser::LIMIT);\n-      setState(1513);\n-      match(ClickHouseParser::DECIMAL_LITERAL);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- ColumnTypeExprContext ------------------------------------------------------------------\n-\n-ClickHouseParser::ColumnTypeExprContext::ColumnTypeExprContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-\n-size_t ClickHouseParser::ColumnTypeExprContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleColumnTypeExpr;\n-}\n-\n-void ClickHouseParser::ColumnTypeExprContext::copyFrom(ColumnTypeExprContext *ctx) {\n-  ParserRuleContext::copyFrom(ctx);\n-}\n-\n-//----------------- ColumnTypeExprNestedContext ------------------------------------------------------------------\n-\n-std::vector<ClickHouseParser::IdentifierContext *> ClickHouseParser::ColumnTypeExprNestedContext::identifier() {\n-  return getRuleContexts<ClickHouseParser::IdentifierContext>();\n-}\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::ColumnTypeExprNestedContext::identifier(size_t i) {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnTypeExprNestedContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-std::vector<ClickHouseParser::ColumnTypeExprContext *> ClickHouseParser::ColumnTypeExprNestedContext::columnTypeExpr() {\n-  return getRuleContexts<ClickHouseParser::ColumnTypeExprContext>();\n-}\n-\n-ClickHouseParser::ColumnTypeExprContext* ClickHouseParser::ColumnTypeExprNestedContext::columnTypeExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::ColumnTypeExprContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnTypeExprNestedContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::ColumnTypeExprNestedContext::COMMA() {\n-  return getTokens(ClickHouseParser::COMMA);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnTypeExprNestedContext::COMMA(size_t i) {\n-  return getToken(ClickHouseParser::COMMA, i);\n-}\n-\n-ClickHouseParser::ColumnTypeExprNestedContext::ColumnTypeExprNestedContext(ColumnTypeExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnTypeExprNestedContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnTypeExprNested(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnTypeExprParamContext ------------------------------------------------------------------\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::ColumnTypeExprParamContext::identifier() {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnTypeExprParamContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnTypeExprParamContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-ClickHouseParser::ColumnExprListContext* ClickHouseParser::ColumnTypeExprParamContext::columnExprList() {\n-  return getRuleContext<ClickHouseParser::ColumnExprListContext>(0);\n-}\n-\n-ClickHouseParser::ColumnTypeExprParamContext::ColumnTypeExprParamContext(ColumnTypeExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnTypeExprParamContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnTypeExprParam(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnTypeExprSimpleContext ------------------------------------------------------------------\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::ColumnTypeExprSimpleContext::identifier() {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(0);\n-}\n-\n-ClickHouseParser::ColumnTypeExprSimpleContext::ColumnTypeExprSimpleContext(ColumnTypeExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnTypeExprSimpleContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnTypeExprSimple(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnTypeExprComplexContext ------------------------------------------------------------------\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::ColumnTypeExprComplexContext::identifier() {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnTypeExprComplexContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-std::vector<ClickHouseParser::ColumnTypeExprContext *> ClickHouseParser::ColumnTypeExprComplexContext::columnTypeExpr() {\n-  return getRuleContexts<ClickHouseParser::ColumnTypeExprContext>();\n-}\n-\n-ClickHouseParser::ColumnTypeExprContext* ClickHouseParser::ColumnTypeExprComplexContext::columnTypeExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::ColumnTypeExprContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnTypeExprComplexContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::ColumnTypeExprComplexContext::COMMA() {\n-  return getTokens(ClickHouseParser::COMMA);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnTypeExprComplexContext::COMMA(size_t i) {\n-  return getToken(ClickHouseParser::COMMA, i);\n-}\n-\n-ClickHouseParser::ColumnTypeExprComplexContext::ColumnTypeExprComplexContext(ColumnTypeExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnTypeExprComplexContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnTypeExprComplex(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnTypeExprEnumContext ------------------------------------------------------------------\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::ColumnTypeExprEnumContext::identifier() {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnTypeExprEnumContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-std::vector<ClickHouseParser::EnumValueContext *> ClickHouseParser::ColumnTypeExprEnumContext::enumValue() {\n-  return getRuleContexts<ClickHouseParser::EnumValueContext>();\n-}\n-\n-ClickHouseParser::EnumValueContext* ClickHouseParser::ColumnTypeExprEnumContext::enumValue(size_t i) {\n-  return getRuleContext<ClickHouseParser::EnumValueContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnTypeExprEnumContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::ColumnTypeExprEnumContext::COMMA() {\n-  return getTokens(ClickHouseParser::COMMA);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnTypeExprEnumContext::COMMA(size_t i) {\n-  return getToken(ClickHouseParser::COMMA, i);\n-}\n-\n-ClickHouseParser::ColumnTypeExprEnumContext::ColumnTypeExprEnumContext(ColumnTypeExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnTypeExprEnumContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnTypeExprEnum(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-ClickHouseParser::ColumnTypeExprContext* ClickHouseParser::columnTypeExpr() {\n-  ColumnTypeExprContext *_localctx = _tracker.createInstance<ColumnTypeExprContext>(_ctx, getState());\n-  enterRule(_localctx, 168, ClickHouseParser::RuleColumnTypeExpr);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(1563);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 211, _ctx)) {\n-    case 1: {\n-      _localctx = dynamic_cast<ColumnTypeExprContext *>(_tracker.createInstance<ClickHouseParser::ColumnTypeExprSimpleContext>(_localctx));\n-      enterOuterAlt(_localctx, 1);\n-      setState(1516);\n-      identifier();\n-      break;\n-    }\n-\n-    case 2: {\n-      _localctx = dynamic_cast<ColumnTypeExprContext *>(_tracker.createInstance<ClickHouseParser::ColumnTypeExprNestedContext>(_localctx));\n-      enterOuterAlt(_localctx, 2);\n-      setState(1517);\n-      identifier();\n-      setState(1518);\n-      match(ClickHouseParser::LPAREN);\n-      setState(1519);\n-      identifier();\n-      setState(1520);\n-      columnTypeExpr();\n-      setState(1527);\n-      _errHandler->sync(this);\n-      _la = _input->LA(1);\n-      while (_la == ClickHouseParser::COMMA) {\n-        setState(1521);\n-        match(ClickHouseParser::COMMA);\n-        setState(1522);\n-        identifier();\n-        setState(1523);\n-        columnTypeExpr();\n-        setState(1529);\n-        _errHandler->sync(this);\n-        _la = _input->LA(1);\n-      }\n-      setState(1530);\n-      match(ClickHouseParser::RPAREN);\n-      break;\n-    }\n-\n-    case 3: {\n-      _localctx = dynamic_cast<ColumnTypeExprContext *>(_tracker.createInstance<ClickHouseParser::ColumnTypeExprEnumContext>(_localctx));\n-      enterOuterAlt(_localctx, 3);\n-      setState(1532);\n-      identifier();\n-      setState(1533);\n-      match(ClickHouseParser::LPAREN);\n-      setState(1534);\n-      enumValue();\n-      setState(1539);\n-      _errHandler->sync(this);\n-      _la = _input->LA(1);\n-      while (_la == ClickHouseParser::COMMA) {\n-        setState(1535);\n-        match(ClickHouseParser::COMMA);\n-        setState(1536);\n-        enumValue();\n-        setState(1541);\n-        _errHandler->sync(this);\n-        _la = _input->LA(1);\n-      }\n-      setState(1542);\n-      match(ClickHouseParser::RPAREN);\n-      break;\n-    }\n-\n-    case 4: {\n-      _localctx = dynamic_cast<ColumnTypeExprContext *>(_tracker.createInstance<ClickHouseParser::ColumnTypeExprComplexContext>(_localctx));\n-      enterOuterAlt(_localctx, 4);\n-      setState(1544);\n-      identifier();\n-      setState(1545);\n-      match(ClickHouseParser::LPAREN);\n-      setState(1546);\n-      columnTypeExpr();\n-      setState(1551);\n-      _errHandler->sync(this);\n-      _la = _input->LA(1);\n-      while (_la == ClickHouseParser::COMMA) {\n-        setState(1547);\n-        match(ClickHouseParser::COMMA);\n-        setState(1548);\n-        columnTypeExpr();\n-        setState(1553);\n-        _errHandler->sync(this);\n-        _la = _input->LA(1);\n-      }\n-      setState(1554);\n-      match(ClickHouseParser::RPAREN);\n-      break;\n-    }\n-\n-    case 5: {\n-      _localctx = dynamic_cast<ColumnTypeExprContext *>(_tracker.createInstance<ClickHouseParser::ColumnTypeExprParamContext>(_localctx));\n-      enterOuterAlt(_localctx, 5);\n-      setState(1556);\n-      identifier();\n-      setState(1557);\n-      match(ClickHouseParser::LPAREN);\n-      setState(1559);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if ((((_la & ~ 0x3fULL) == 0) &&\n-        ((1ULL << _la) & ((1ULL << ClickHouseParser::AFTER)\n-        | (1ULL << ClickHouseParser::ALIAS)\n-        | (1ULL << ClickHouseParser::ALL)\n-        | (1ULL << ClickHouseParser::ALTER)\n-        | (1ULL << ClickHouseParser::AND)\n-        | (1ULL << ClickHouseParser::ANTI)\n-        | (1ULL << ClickHouseParser::ANY)\n-        | (1ULL << ClickHouseParser::ARRAY)\n-        | (1ULL << ClickHouseParser::AS)\n-        | (1ULL << ClickHouseParser::ASCENDING)\n-        | (1ULL << ClickHouseParser::ASOF)\n-        | (1ULL << ClickHouseParser::AST)\n-        | (1ULL << ClickHouseParser::ASYNC)\n-        | (1ULL << ClickHouseParser::ATTACH)\n-        | (1ULL << ClickHouseParser::BETWEEN)\n-        | (1ULL << ClickHouseParser::BOTH)\n-        | (1ULL << ClickHouseParser::BY)\n-        | (1ULL << ClickHouseParser::CASE)\n-        | (1ULL << ClickHouseParser::CAST)\n-        | (1ULL << ClickHouseParser::CHECK)\n-        | (1ULL << ClickHouseParser::CLEAR)\n-        | (1ULL << ClickHouseParser::CLUSTER)\n-        | (1ULL << ClickHouseParser::CODEC)\n-        | (1ULL << ClickHouseParser::COLLATE)\n-        | (1ULL << ClickHouseParser::COLUMN)\n-        | (1ULL << ClickHouseParser::COMMENT)\n-        | (1ULL << ClickHouseParser::CONSTRAINT)\n-        | (1ULL << ClickHouseParser::CREATE)\n-        | (1ULL << ClickHouseParser::CROSS)\n-        | (1ULL << ClickHouseParser::CUBE)\n-        | (1ULL << ClickHouseParser::DATABASE)\n-        | (1ULL << ClickHouseParser::DATABASES)\n-        | (1ULL << ClickHouseParser::DATE)\n-        | (1ULL << ClickHouseParser::DAY)\n-        | (1ULL << ClickHouseParser::DEDUPLICATE)\n-        | (1ULL << ClickHouseParser::DEFAULT)\n-        | (1ULL << ClickHouseParser::DELAY)\n-        | (1ULL << ClickHouseParser::DELETE)\n-        | (1ULL << ClickHouseParser::DESC)\n-        | (1ULL << ClickHouseParser::DESCENDING)\n-        | (1ULL << ClickHouseParser::DESCRIBE)\n-        | (1ULL << ClickHouseParser::DETACH)\n-        | (1ULL << ClickHouseParser::DICTIONARIES)\n-        | (1ULL << ClickHouseParser::DICTIONARY)\n-        | (1ULL << ClickHouseParser::DISK)\n-        | (1ULL << ClickHouseParser::DISTINCT)\n-        | (1ULL << ClickHouseParser::DISTRIBUTED)\n-        | (1ULL << ClickHouseParser::DROP)\n-        | (1ULL << ClickHouseParser::ELSE)\n-        | (1ULL << ClickHouseParser::END)\n-        | (1ULL << ClickHouseParser::ENGINE)\n-        | (1ULL << ClickHouseParser::EVENTS)\n-        | (1ULL << ClickHouseParser::EXISTS)\n-        | (1ULL << ClickHouseParser::EXPLAIN)\n-        | (1ULL << ClickHouseParser::EXPRESSION)\n-        | (1ULL << ClickHouseParser::EXTRACT)\n-        | (1ULL << ClickHouseParser::FETCHES)\n-        | (1ULL << ClickHouseParser::FINAL)\n-        | (1ULL << ClickHouseParser::FIRST)\n-        | (1ULL << ClickHouseParser::FLUSH)\n-        | (1ULL << ClickHouseParser::FOR)\n-        | (1ULL << ClickHouseParser::FORMAT))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&\n-        ((1ULL << (_la - 64)) & ((1ULL << (ClickHouseParser::FREEZE - 64))\n-        | (1ULL << (ClickHouseParser::FROM - 64))\n-        | (1ULL << (ClickHouseParser::FULL - 64))\n-        | (1ULL << (ClickHouseParser::FUNCTION - 64))\n-        | (1ULL << (ClickHouseParser::GLOBAL - 64))\n-        | (1ULL << (ClickHouseParser::GRANULARITY - 64))\n-        | (1ULL << (ClickHouseParser::GROUP - 64))\n-        | (1ULL << (ClickHouseParser::HAVING - 64))\n-        | (1ULL << (ClickHouseParser::HIERARCHICAL - 64))\n-        | (1ULL << (ClickHouseParser::HOUR - 64))\n-        | (1ULL << (ClickHouseParser::ID - 64))\n-        | (1ULL << (ClickHouseParser::IF - 64))\n-        | (1ULL << (ClickHouseParser::ILIKE - 64))\n-        | (1ULL << (ClickHouseParser::IN - 64))\n-        | (1ULL << (ClickHouseParser::INDEX - 64))\n-        | (1ULL << (ClickHouseParser::INF - 64))\n-        | (1ULL << (ClickHouseParser::INJECTIVE - 64))\n-        | (1ULL << (ClickHouseParser::INNER - 64))\n-        | (1ULL << (ClickHouseParser::INSERT - 64))\n-        | (1ULL << (ClickHouseParser::INTERVAL - 64))\n-        | (1ULL << (ClickHouseParser::INTO - 64))\n-        | (1ULL << (ClickHouseParser::IS - 64))\n-        | (1ULL << (ClickHouseParser::IS_OBJECT_ID - 64))\n-        | (1ULL << (ClickHouseParser::JOIN - 64))\n-        | (1ULL << (ClickHouseParser::KEY - 64))\n-        | (1ULL << (ClickHouseParser::KILL - 64))\n-        | (1ULL << (ClickHouseParser::LAST - 64))\n-        | (1ULL << (ClickHouseParser::LAYOUT - 64))\n-        | (1ULL << (ClickHouseParser::LEADING - 64))\n-        | (1ULL << (ClickHouseParser::LEFT - 64))\n-        | (1ULL << (ClickHouseParser::LIFETIME - 64))\n-        | (1ULL << (ClickHouseParser::LIKE - 64))\n-        | (1ULL << (ClickHouseParser::LIMIT - 64))\n-        | (1ULL << (ClickHouseParser::LIVE - 64))\n-        | (1ULL << (ClickHouseParser::LOCAL - 64))\n-        | (1ULL << (ClickHouseParser::LOGS - 64))\n-        | (1ULL << (ClickHouseParser::MATERIALIZE - 64))\n-        | (1ULL << (ClickHouseParser::MATERIALIZED - 64))\n-        | (1ULL << (ClickHouseParser::MAX - 64))\n-        | (1ULL << (ClickHouseParser::MERGES - 64))\n-        | (1ULL << (ClickHouseParser::MIN - 64))\n-        | (1ULL << (ClickHouseParser::MINUTE - 64))\n-        | (1ULL << (ClickHouseParser::MODIFY - 64))\n-        | (1ULL << (ClickHouseParser::MONTH - 64))\n-        | (1ULL << (ClickHouseParser::MOVE - 64))\n-        | (1ULL << (ClickHouseParser::MUTATION - 64))\n-        | (1ULL << (ClickHouseParser::NAN_SQL - 64))\n-        | (1ULL << (ClickHouseParser::NO - 64))\n-        | (1ULL << (ClickHouseParser::NOT - 64))\n-        | (1ULL << (ClickHouseParser::NULL_SQL - 64))\n-        | (1ULL << (ClickHouseParser::NULLS - 64))\n-        | (1ULL << (ClickHouseParser::OFFSET - 64))\n-        | (1ULL << (ClickHouseParser::ON - 64))\n-        | (1ULL << (ClickHouseParser::OPTIMIZE - 64))\n-        | (1ULL << (ClickHouseParser::OR - 64))\n-        | (1ULL << (ClickHouseParser::ORDER - 64))\n-        | (1ULL << (ClickHouseParser::OUTER - 64))\n-        | (1ULL << (ClickHouseParser::OUTFILE - 64))\n-        | (1ULL << (ClickHouseParser::PARTITION - 64))\n-        | (1ULL << (ClickHouseParser::POPULATE - 64))\n-        | (1ULL << (ClickHouseParser::PREWHERE - 64))\n-        | (1ULL << (ClickHouseParser::PRIMARY - 64))\n-        | (1ULL << (ClickHouseParser::QUARTER - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&\n-        ((1ULL << (_la - 128)) & ((1ULL << (ClickHouseParser::RANGE - 128))\n-        | (1ULL << (ClickHouseParser::RELOAD - 128))\n-        | (1ULL << (ClickHouseParser::REMOVE - 128))\n-        | (1ULL << (ClickHouseParser::RENAME - 128))\n-        | (1ULL << (ClickHouseParser::REPLACE - 128))\n-        | (1ULL << (ClickHouseParser::REPLICA - 128))\n-        | (1ULL << (ClickHouseParser::REPLICATED - 128))\n-        | (1ULL << (ClickHouseParser::RIGHT - 128))\n-        | (1ULL << (ClickHouseParser::ROLLUP - 128))\n-        | (1ULL << (ClickHouseParser::SAMPLE - 128))\n-        | (1ULL << (ClickHouseParser::SECOND - 128))\n-        | (1ULL << (ClickHouseParser::SELECT - 128))\n-        | (1ULL << (ClickHouseParser::SEMI - 128))\n-        | (1ULL << (ClickHouseParser::SENDS - 128))\n-        | (1ULL << (ClickHouseParser::SET - 128))\n-        | (1ULL << (ClickHouseParser::SETTINGS - 128))\n-        | (1ULL << (ClickHouseParser::SHOW - 128))\n-        | (1ULL << (ClickHouseParser::SOURCE - 128))\n-        | (1ULL << (ClickHouseParser::START - 128))\n-        | (1ULL << (ClickHouseParser::STOP - 128))\n-        | (1ULL << (ClickHouseParser::SUBSTRING - 128))\n-        | (1ULL << (ClickHouseParser::SYNC - 128))\n-        | (1ULL << (ClickHouseParser::SYNTAX - 128))\n-        | (1ULL << (ClickHouseParser::SYSTEM - 128))\n-        | (1ULL << (ClickHouseParser::TABLE - 128))\n-        | (1ULL << (ClickHouseParser::TABLES - 128))\n-        | (1ULL << (ClickHouseParser::TEMPORARY - 128))\n-        | (1ULL << (ClickHouseParser::TEST - 128))\n-        | (1ULL << (ClickHouseParser::THEN - 128))\n-        | (1ULL << (ClickHouseParser::TIES - 128))\n-        | (1ULL << (ClickHouseParser::TIMEOUT - 128))\n-        | (1ULL << (ClickHouseParser::TIMESTAMP - 128))\n-        | (1ULL << (ClickHouseParser::TO - 128))\n-        | (1ULL << (ClickHouseParser::TOP - 128))\n-        | (1ULL << (ClickHouseParser::TOTALS - 128))\n-        | (1ULL << (ClickHouseParser::TRAILING - 128))\n-        | (1ULL << (ClickHouseParser::TRIM - 128))\n-        | (1ULL << (ClickHouseParser::TRUNCATE - 128))\n-        | (1ULL << (ClickHouseParser::TTL - 128))\n-        | (1ULL << (ClickHouseParser::TYPE - 128))\n-        | (1ULL << (ClickHouseParser::UNION - 128))\n-        | (1ULL << (ClickHouseParser::UPDATE - 128))\n-        | (1ULL << (ClickHouseParser::USE - 128))\n-        | (1ULL << (ClickHouseParser::USING - 128))\n-        | (1ULL << (ClickHouseParser::UUID - 128))\n-        | (1ULL << (ClickHouseParser::VALUES - 128))\n-        | (1ULL << (ClickHouseParser::VIEW - 128))\n-        | (1ULL << (ClickHouseParser::VOLUME - 128))\n-        | (1ULL << (ClickHouseParser::WATCH - 128))\n-        | (1ULL << (ClickHouseParser::WEEK - 128))\n-        | (1ULL << (ClickHouseParser::WHEN - 128))\n-        | (1ULL << (ClickHouseParser::WHERE - 128))\n-        | (1ULL << (ClickHouseParser::WITH - 128))\n-        | (1ULL << (ClickHouseParser::YEAR - 128))\n-        | (1ULL << (ClickHouseParser::JSON_FALSE - 128))\n-        | (1ULL << (ClickHouseParser::JSON_TRUE - 128))\n-        | (1ULL << (ClickHouseParser::IDENTIFIER - 128))\n-        | (1ULL << (ClickHouseParser::FLOATING_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::OCTAL_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::DECIMAL_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::HEXADECIMAL_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::STRING_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::ASTERISK - 128)))) != 0) || ((((_la - 197) & ~ 0x3fULL) == 0) &&\n-        ((1ULL << (_la - 197)) & ((1ULL << (ClickHouseParser::DASH - 197))\n-        | (1ULL << (ClickHouseParser::DOT - 197))\n-        | (1ULL << (ClickHouseParser::LBRACKET - 197))\n-        | (1ULL << (ClickHouseParser::LPAREN - 197))\n-        | (1ULL << (ClickHouseParser::PLUS - 197)))) != 0)) {\n-        setState(1558);\n-        columnExprList();\n-      }\n-      setState(1561);\n-      match(ClickHouseParser::RPAREN);\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- ColumnExprListContext ------------------------------------------------------------------\n-\n-ClickHouseParser::ColumnExprListContext::ColumnExprListContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-std::vector<ClickHouseParser::ColumnsExprContext *> ClickHouseParser::ColumnExprListContext::columnsExpr() {\n-  return getRuleContexts<ClickHouseParser::ColumnsExprContext>();\n-}\n-\n-ClickHouseParser::ColumnsExprContext* ClickHouseParser::ColumnExprListContext::columnsExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::ColumnsExprContext>(i);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::ColumnExprListContext::COMMA() {\n-  return getTokens(ClickHouseParser::COMMA);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprListContext::COMMA(size_t i) {\n-  return getToken(ClickHouseParser::COMMA, i);\n-}\n-\n-\n-size_t ClickHouseParser::ColumnExprListContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleColumnExprList;\n-}\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprListContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprList(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::ColumnExprListContext* ClickHouseParser::columnExprList() {\n-  ColumnExprListContext *_localctx = _tracker.createInstance<ColumnExprListContext>(_ctx, getState());\n-  enterRule(_localctx, 170, ClickHouseParser::RuleColumnExprList);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    size_t alt;\n-    enterOuterAlt(_localctx, 1);\n-    setState(1565);\n-    columnsExpr();\n-    setState(1570);\n-    _errHandler->sync(this);\n-    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 212, _ctx);\n-    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {\n-      if (alt == 1) {\n-        setState(1566);\n-        match(ClickHouseParser::COMMA);\n-        setState(1567);\n-        columnsExpr(); \n-      }\n-      setState(1572);\n-      _errHandler->sync(this);\n-      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 212, _ctx);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- ColumnsExprContext ------------------------------------------------------------------\n-\n-ClickHouseParser::ColumnsExprContext::ColumnsExprContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-\n-size_t ClickHouseParser::ColumnsExprContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleColumnsExpr;\n-}\n-\n-void ClickHouseParser::ColumnsExprContext::copyFrom(ColumnsExprContext *ctx) {\n-  ParserRuleContext::copyFrom(ctx);\n-}\n-\n-//----------------- ColumnsExprColumnContext ------------------------------------------------------------------\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::ColumnsExprColumnContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-ClickHouseParser::ColumnsExprColumnContext::ColumnsExprColumnContext(ColumnsExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnsExprColumnContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnsExprColumn(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnsExprAsteriskContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ColumnsExprAsteriskContext::ASTERISK() {\n-  return getToken(ClickHouseParser::ASTERISK, 0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::ColumnsExprAsteriskContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnsExprAsteriskContext::DOT() {\n-  return getToken(ClickHouseParser::DOT, 0);\n-}\n-\n-ClickHouseParser::ColumnsExprAsteriskContext::ColumnsExprAsteriskContext(ColumnsExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnsExprAsteriskContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnsExprAsterisk(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnsExprSubqueryContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ColumnsExprSubqueryContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-ClickHouseParser::SelectUnionStmtContext* ClickHouseParser::ColumnsExprSubqueryContext::selectUnionStmt() {\n-  return getRuleContext<ClickHouseParser::SelectUnionStmtContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnsExprSubqueryContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-ClickHouseParser::ColumnsExprSubqueryContext::ColumnsExprSubqueryContext(ColumnsExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnsExprSubqueryContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnsExprSubquery(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-ClickHouseParser::ColumnsExprContext* ClickHouseParser::columnsExpr() {\n-  ColumnsExprContext *_localctx = _tracker.createInstance<ColumnsExprContext>(_ctx, getState());\n-  enterRule(_localctx, 172, ClickHouseParser::RuleColumnsExpr);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(1584);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 214, _ctx)) {\n-    case 1: {\n-      _localctx = dynamic_cast<ColumnsExprContext *>(_tracker.createInstance<ClickHouseParser::ColumnsExprAsteriskContext>(_localctx));\n-      enterOuterAlt(_localctx, 1);\n-      setState(1576);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if ((((_la & ~ 0x3fULL) == 0) &&\n-        ((1ULL << _la) & ((1ULL << ClickHouseParser::AFTER)\n-        | (1ULL << ClickHouseParser::ALIAS)\n-        | (1ULL << ClickHouseParser::ALL)\n-        | (1ULL << ClickHouseParser::ALTER)\n-        | (1ULL << ClickHouseParser::AND)\n-        | (1ULL << ClickHouseParser::ANTI)\n-        | (1ULL << ClickHouseParser::ANY)\n-        | (1ULL << ClickHouseParser::ARRAY)\n-        | (1ULL << ClickHouseParser::AS)\n-        | (1ULL << ClickHouseParser::ASCENDING)\n-        | (1ULL << ClickHouseParser::ASOF)\n-        | (1ULL << ClickHouseParser::AST)\n-        | (1ULL << ClickHouseParser::ASYNC)\n-        | (1ULL << ClickHouseParser::ATTACH)\n-        | (1ULL << ClickHouseParser::BETWEEN)\n-        | (1ULL << ClickHouseParser::BOTH)\n-        | (1ULL << ClickHouseParser::BY)\n-        | (1ULL << ClickHouseParser::CASE)\n-        | (1ULL << ClickHouseParser::CAST)\n-        | (1ULL << ClickHouseParser::CHECK)\n-        | (1ULL << ClickHouseParser::CLEAR)\n-        | (1ULL << ClickHouseParser::CLUSTER)\n-        | (1ULL << ClickHouseParser::CODEC)\n-        | (1ULL << ClickHouseParser::COLLATE)\n-        | (1ULL << ClickHouseParser::COLUMN)\n-        | (1ULL << ClickHouseParser::COMMENT)\n-        | (1ULL << ClickHouseParser::CONSTRAINT)\n-        | (1ULL << ClickHouseParser::CREATE)\n-        | (1ULL << ClickHouseParser::CROSS)\n-        | (1ULL << ClickHouseParser::CUBE)\n-        | (1ULL << ClickHouseParser::DATABASE)\n-        | (1ULL << ClickHouseParser::DATABASES)\n-        | (1ULL << ClickHouseParser::DATE)\n-        | (1ULL << ClickHouseParser::DAY)\n-        | (1ULL << ClickHouseParser::DEDUPLICATE)\n-        | (1ULL << ClickHouseParser::DEFAULT)\n-        | (1ULL << ClickHouseParser::DELAY)\n-        | (1ULL << ClickHouseParser::DELETE)\n-        | (1ULL << ClickHouseParser::DESC)\n-        | (1ULL << ClickHouseParser::DESCENDING)\n-        | (1ULL << ClickHouseParser::DESCRIBE)\n-        | (1ULL << ClickHouseParser::DETACH)\n-        | (1ULL << ClickHouseParser::DICTIONARIES)\n-        | (1ULL << ClickHouseParser::DICTIONARY)\n-        | (1ULL << ClickHouseParser::DISK)\n-        | (1ULL << ClickHouseParser::DISTINCT)\n-        | (1ULL << ClickHouseParser::DISTRIBUTED)\n-        | (1ULL << ClickHouseParser::DROP)\n-        | (1ULL << ClickHouseParser::ELSE)\n-        | (1ULL << ClickHouseParser::END)\n-        | (1ULL << ClickHouseParser::ENGINE)\n-        | (1ULL << ClickHouseParser::EVENTS)\n-        | (1ULL << ClickHouseParser::EXISTS)\n-        | (1ULL << ClickHouseParser::EXPLAIN)\n-        | (1ULL << ClickHouseParser::EXPRESSION)\n-        | (1ULL << ClickHouseParser::EXTRACT)\n-        | (1ULL << ClickHouseParser::FETCHES)\n-        | (1ULL << ClickHouseParser::FINAL)\n-        | (1ULL << ClickHouseParser::FIRST)\n-        | (1ULL << ClickHouseParser::FLUSH)\n-        | (1ULL << ClickHouseParser::FOR)\n-        | (1ULL << ClickHouseParser::FORMAT))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&\n-        ((1ULL << (_la - 64)) & ((1ULL << (ClickHouseParser::FREEZE - 64))\n-        | (1ULL << (ClickHouseParser::FROM - 64))\n-        | (1ULL << (ClickHouseParser::FULL - 64))\n-        | (1ULL << (ClickHouseParser::FUNCTION - 64))\n-        | (1ULL << (ClickHouseParser::GLOBAL - 64))\n-        | (1ULL << (ClickHouseParser::GRANULARITY - 64))\n-        | (1ULL << (ClickHouseParser::GROUP - 64))\n-        | (1ULL << (ClickHouseParser::HAVING - 64))\n-        | (1ULL << (ClickHouseParser::HIERARCHICAL - 64))\n-        | (1ULL << (ClickHouseParser::HOUR - 64))\n-        | (1ULL << (ClickHouseParser::ID - 64))\n-        | (1ULL << (ClickHouseParser::IF - 64))\n-        | (1ULL << (ClickHouseParser::ILIKE - 64))\n-        | (1ULL << (ClickHouseParser::IN - 64))\n-        | (1ULL << (ClickHouseParser::INDEX - 64))\n-        | (1ULL << (ClickHouseParser::INJECTIVE - 64))\n-        | (1ULL << (ClickHouseParser::INNER - 64))\n-        | (1ULL << (ClickHouseParser::INSERT - 64))\n-        | (1ULL << (ClickHouseParser::INTERVAL - 64))\n-        | (1ULL << (ClickHouseParser::INTO - 64))\n-        | (1ULL << (ClickHouseParser::IS - 64))\n-        | (1ULL << (ClickHouseParser::IS_OBJECT_ID - 64))\n-        | (1ULL << (ClickHouseParser::JOIN - 64))\n-        | (1ULL << (ClickHouseParser::KEY - 64))\n-        | (1ULL << (ClickHouseParser::KILL - 64))\n-        | (1ULL << (ClickHouseParser::LAST - 64))\n-        | (1ULL << (ClickHouseParser::LAYOUT - 64))\n-        | (1ULL << (ClickHouseParser::LEADING - 64))\n-        | (1ULL << (ClickHouseParser::LEFT - 64))\n-        | (1ULL << (ClickHouseParser::LIFETIME - 64))\n-        | (1ULL << (ClickHouseParser::LIKE - 64))\n-        | (1ULL << (ClickHouseParser::LIMIT - 64))\n-        | (1ULL << (ClickHouseParser::LIVE - 64))\n-        | (1ULL << (ClickHouseParser::LOCAL - 64))\n-        | (1ULL << (ClickHouseParser::LOGS - 64))\n-        | (1ULL << (ClickHouseParser::MATERIALIZE - 64))\n-        | (1ULL << (ClickHouseParser::MATERIALIZED - 64))\n-        | (1ULL << (ClickHouseParser::MAX - 64))\n-        | (1ULL << (ClickHouseParser::MERGES - 64))\n-        | (1ULL << (ClickHouseParser::MIN - 64))\n-        | (1ULL << (ClickHouseParser::MINUTE - 64))\n-        | (1ULL << (ClickHouseParser::MODIFY - 64))\n-        | (1ULL << (ClickHouseParser::MONTH - 64))\n-        | (1ULL << (ClickHouseParser::MOVE - 64))\n-        | (1ULL << (ClickHouseParser::MUTATION - 64))\n-        | (1ULL << (ClickHouseParser::NO - 64))\n-        | (1ULL << (ClickHouseParser::NOT - 64))\n-        | (1ULL << (ClickHouseParser::NULLS - 64))\n-        | (1ULL << (ClickHouseParser::OFFSET - 64))\n-        | (1ULL << (ClickHouseParser::ON - 64))\n-        | (1ULL << (ClickHouseParser::OPTIMIZE - 64))\n-        | (1ULL << (ClickHouseParser::OR - 64))\n-        | (1ULL << (ClickHouseParser::ORDER - 64))\n-        | (1ULL << (ClickHouseParser::OUTER - 64))\n-        | (1ULL << (ClickHouseParser::OUTFILE - 64))\n-        | (1ULL << (ClickHouseParser::PARTITION - 64))\n-        | (1ULL << (ClickHouseParser::POPULATE - 64))\n-        | (1ULL << (ClickHouseParser::PREWHERE - 64))\n-        | (1ULL << (ClickHouseParser::PRIMARY - 64))\n-        | (1ULL << (ClickHouseParser::QUARTER - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&\n-        ((1ULL << (_la - 128)) & ((1ULL << (ClickHouseParser::RANGE - 128))\n-        | (1ULL << (ClickHouseParser::RELOAD - 128))\n-        | (1ULL << (ClickHouseParser::REMOVE - 128))\n-        | (1ULL << (ClickHouseParser::RENAME - 128))\n-        | (1ULL << (ClickHouseParser::REPLACE - 128))\n-        | (1ULL << (ClickHouseParser::REPLICA - 128))\n-        | (1ULL << (ClickHouseParser::REPLICATED - 128))\n-        | (1ULL << (ClickHouseParser::RIGHT - 128))\n-        | (1ULL << (ClickHouseParser::ROLLUP - 128))\n-        | (1ULL << (ClickHouseParser::SAMPLE - 128))\n-        | (1ULL << (ClickHouseParser::SECOND - 128))\n-        | (1ULL << (ClickHouseParser::SELECT - 128))\n-        | (1ULL << (ClickHouseParser::SEMI - 128))\n-        | (1ULL << (ClickHouseParser::SENDS - 128))\n-        | (1ULL << (ClickHouseParser::SET - 128))\n-        | (1ULL << (ClickHouseParser::SETTINGS - 128))\n-        | (1ULL << (ClickHouseParser::SHOW - 128))\n-        | (1ULL << (ClickHouseParser::SOURCE - 128))\n-        | (1ULL << (ClickHouseParser::START - 128))\n-        | (1ULL << (ClickHouseParser::STOP - 128))\n-        | (1ULL << (ClickHouseParser::SUBSTRING - 128))\n-        | (1ULL << (ClickHouseParser::SYNC - 128))\n-        | (1ULL << (ClickHouseParser::SYNTAX - 128))\n-        | (1ULL << (ClickHouseParser::SYSTEM - 128))\n-        | (1ULL << (ClickHouseParser::TABLE - 128))\n-        | (1ULL << (ClickHouseParser::TABLES - 128))\n-        | (1ULL << (ClickHouseParser::TEMPORARY - 128))\n-        | (1ULL << (ClickHouseParser::TEST - 128))\n-        | (1ULL << (ClickHouseParser::THEN - 128))\n-        | (1ULL << (ClickHouseParser::TIES - 128))\n-        | (1ULL << (ClickHouseParser::TIMEOUT - 128))\n-        | (1ULL << (ClickHouseParser::TIMESTAMP - 128))\n-        | (1ULL << (ClickHouseParser::TO - 128))\n-        | (1ULL << (ClickHouseParser::TOP - 128))\n-        | (1ULL << (ClickHouseParser::TOTALS - 128))\n-        | (1ULL << (ClickHouseParser::TRAILING - 128))\n-        | (1ULL << (ClickHouseParser::TRIM - 128))\n-        | (1ULL << (ClickHouseParser::TRUNCATE - 128))\n-        | (1ULL << (ClickHouseParser::TTL - 128))\n-        | (1ULL << (ClickHouseParser::TYPE - 128))\n-        | (1ULL << (ClickHouseParser::UNION - 128))\n-        | (1ULL << (ClickHouseParser::UPDATE - 128))\n-        | (1ULL << (ClickHouseParser::USE - 128))\n-        | (1ULL << (ClickHouseParser::USING - 128))\n-        | (1ULL << (ClickHouseParser::UUID - 128))\n-        | (1ULL << (ClickHouseParser::VALUES - 128))\n-        | (1ULL << (ClickHouseParser::VIEW - 128))\n-        | (1ULL << (ClickHouseParser::VOLUME - 128))\n-        | (1ULL << (ClickHouseParser::WATCH - 128))\n-        | (1ULL << (ClickHouseParser::WEEK - 128))\n-        | (1ULL << (ClickHouseParser::WHEN - 128))\n-        | (1ULL << (ClickHouseParser::WHERE - 128))\n-        | (1ULL << (ClickHouseParser::WITH - 128))\n-        | (1ULL << (ClickHouseParser::YEAR - 128))\n-        | (1ULL << (ClickHouseParser::JSON_FALSE - 128))\n-        | (1ULL << (ClickHouseParser::JSON_TRUE - 128))\n-        | (1ULL << (ClickHouseParser::IDENTIFIER - 128)))) != 0)) {\n-        setState(1573);\n-        tableIdentifier();\n-        setState(1574);\n-        match(ClickHouseParser::DOT);\n-      }\n-      setState(1578);\n-      match(ClickHouseParser::ASTERISK);\n-      break;\n-    }\n-\n-    case 2: {\n-      _localctx = dynamic_cast<ColumnsExprContext *>(_tracker.createInstance<ClickHouseParser::ColumnsExprSubqueryContext>(_localctx));\n-      enterOuterAlt(_localctx, 2);\n-      setState(1579);\n-      match(ClickHouseParser::LPAREN);\n-      setState(1580);\n-      selectUnionStmt();\n-      setState(1581);\n-      match(ClickHouseParser::RPAREN);\n-      break;\n-    }\n-\n-    case 3: {\n-      _localctx = dynamic_cast<ColumnsExprContext *>(_tracker.createInstance<ClickHouseParser::ColumnsExprColumnContext>(_localctx));\n-      enterOuterAlt(_localctx, 3);\n-      setState(1583);\n-      columnExpr(0);\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- ColumnExprContext ------------------------------------------------------------------\n-\n-ClickHouseParser::ColumnExprContext::ColumnExprContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-\n-size_t ClickHouseParser::ColumnExprContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleColumnExpr;\n-}\n-\n-void ClickHouseParser::ColumnExprContext::copyFrom(ColumnExprContext *ctx) {\n-  ParserRuleContext::copyFrom(ctx);\n-}\n-\n-//----------------- ColumnExprTernaryOpContext ------------------------------------------------------------------\n-\n-std::vector<ClickHouseParser::ColumnExprContext *> ClickHouseParser::ColumnExprTernaryOpContext::columnExpr() {\n-  return getRuleContexts<ClickHouseParser::ColumnExprContext>();\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::ColumnExprTernaryOpContext::columnExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprTernaryOpContext::QUERY() {\n-  return getToken(ClickHouseParser::QUERY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprTernaryOpContext::COLON() {\n-  return getToken(ClickHouseParser::COLON, 0);\n-}\n-\n-ClickHouseParser::ColumnExprTernaryOpContext::ColumnExprTernaryOpContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprTernaryOpContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprTernaryOp(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprAliasContext ------------------------------------------------------------------\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::ColumnExprAliasContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-ClickHouseParser::AliasContext* ClickHouseParser::ColumnExprAliasContext::alias() {\n-  return getRuleContext<ClickHouseParser::AliasContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprAliasContext::AS() {\n-  return getToken(ClickHouseParser::AS, 0);\n-}\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::ColumnExprAliasContext::identifier() {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(0);\n-}\n-\n-ClickHouseParser::ColumnExprAliasContext::ColumnExprAliasContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprAliasContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprAlias(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprExtractContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprExtractContext::EXTRACT() {\n-  return getToken(ClickHouseParser::EXTRACT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprExtractContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-ClickHouseParser::IntervalContext* ClickHouseParser::ColumnExprExtractContext::interval() {\n-  return getRuleContext<ClickHouseParser::IntervalContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprExtractContext::FROM() {\n-  return getToken(ClickHouseParser::FROM, 0);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::ColumnExprExtractContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprExtractContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-ClickHouseParser::ColumnExprExtractContext::ColumnExprExtractContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprExtractContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprExtract(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprNegateContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprNegateContext::DASH() {\n-  return getToken(ClickHouseParser::DASH, 0);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::ColumnExprNegateContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-ClickHouseParser::ColumnExprNegateContext::ColumnExprNegateContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprNegateContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprNegate(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprSubqueryContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprSubqueryContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-ClickHouseParser::SelectUnionStmtContext* ClickHouseParser::ColumnExprSubqueryContext::selectUnionStmt() {\n-  return getRuleContext<ClickHouseParser::SelectUnionStmtContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprSubqueryContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-ClickHouseParser::ColumnExprSubqueryContext::ColumnExprSubqueryContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprSubqueryContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprSubquery(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprLiteralContext ------------------------------------------------------------------\n-\n-ClickHouseParser::LiteralContext* ClickHouseParser::ColumnExprLiteralContext::literal() {\n-  return getRuleContext<ClickHouseParser::LiteralContext>(0);\n-}\n-\n-ClickHouseParser::ColumnExprLiteralContext::ColumnExprLiteralContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprLiteralContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprLiteral(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprArrayContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprArrayContext::LBRACKET() {\n-  return getToken(ClickHouseParser::LBRACKET, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprArrayContext::RBRACKET() {\n-  return getToken(ClickHouseParser::RBRACKET, 0);\n-}\n-\n-ClickHouseParser::ColumnExprListContext* ClickHouseParser::ColumnExprArrayContext::columnExprList() {\n-  return getRuleContext<ClickHouseParser::ColumnExprListContext>(0);\n-}\n-\n-ClickHouseParser::ColumnExprArrayContext::ColumnExprArrayContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprArrayContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprArray(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprSubstringContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprSubstringContext::SUBSTRING() {\n-  return getToken(ClickHouseParser::SUBSTRING, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprSubstringContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-std::vector<ClickHouseParser::ColumnExprContext *> ClickHouseParser::ColumnExprSubstringContext::columnExpr() {\n-  return getRuleContexts<ClickHouseParser::ColumnExprContext>();\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::ColumnExprSubstringContext::columnExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprSubstringContext::FROM() {\n-  return getToken(ClickHouseParser::FROM, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprSubstringContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprSubstringContext::FOR() {\n-  return getToken(ClickHouseParser::FOR, 0);\n-}\n-\n-ClickHouseParser::ColumnExprSubstringContext::ColumnExprSubstringContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprSubstringContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprSubstring(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprCastContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprCastContext::CAST() {\n-  return getToken(ClickHouseParser::CAST, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprCastContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::ColumnExprCastContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprCastContext::AS() {\n-  return getToken(ClickHouseParser::AS, 0);\n-}\n-\n-ClickHouseParser::ColumnTypeExprContext* ClickHouseParser::ColumnExprCastContext::columnTypeExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnTypeExprContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprCastContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-ClickHouseParser::ColumnExprCastContext::ColumnExprCastContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprCastContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprCast(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprOrContext ------------------------------------------------------------------\n-\n-std::vector<ClickHouseParser::ColumnExprContext *> ClickHouseParser::ColumnExprOrContext::columnExpr() {\n-  return getRuleContexts<ClickHouseParser::ColumnExprContext>();\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::ColumnExprOrContext::columnExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprOrContext::OR() {\n-  return getToken(ClickHouseParser::OR, 0);\n-}\n-\n-ClickHouseParser::ColumnExprOrContext::ColumnExprOrContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprOrContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprOr(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprPrecedence1Context ------------------------------------------------------------------\n-\n-std::vector<ClickHouseParser::ColumnExprContext *> ClickHouseParser::ColumnExprPrecedence1Context::columnExpr() {\n-  return getRuleContexts<ClickHouseParser::ColumnExprContext>();\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::ColumnExprPrecedence1Context::columnExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprPrecedence1Context::ASTERISK() {\n-  return getToken(ClickHouseParser::ASTERISK, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprPrecedence1Context::SLASH() {\n-  return getToken(ClickHouseParser::SLASH, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprPrecedence1Context::PERCENT() {\n-  return getToken(ClickHouseParser::PERCENT, 0);\n-}\n-\n-ClickHouseParser::ColumnExprPrecedence1Context::ColumnExprPrecedence1Context(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprPrecedence1Context::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprPrecedence1(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprPrecedence2Context ------------------------------------------------------------------\n-\n-std::vector<ClickHouseParser::ColumnExprContext *> ClickHouseParser::ColumnExprPrecedence2Context::columnExpr() {\n-  return getRuleContexts<ClickHouseParser::ColumnExprContext>();\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::ColumnExprPrecedence2Context::columnExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprPrecedence2Context::PLUS() {\n-  return getToken(ClickHouseParser::PLUS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprPrecedence2Context::DASH() {\n-  return getToken(ClickHouseParser::DASH, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprPrecedence2Context::CONCAT() {\n-  return getToken(ClickHouseParser::CONCAT, 0);\n-}\n-\n-ClickHouseParser::ColumnExprPrecedence2Context::ColumnExprPrecedence2Context(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprPrecedence2Context::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprPrecedence2(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprPrecedence3Context ------------------------------------------------------------------\n-\n-std::vector<ClickHouseParser::ColumnExprContext *> ClickHouseParser::ColumnExprPrecedence3Context::columnExpr() {\n-  return getRuleContexts<ClickHouseParser::ColumnExprContext>();\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::ColumnExprPrecedence3Context::columnExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprPrecedence3Context::EQ_DOUBLE() {\n-  return getToken(ClickHouseParser::EQ_DOUBLE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprPrecedence3Context::EQ_SINGLE() {\n-  return getToken(ClickHouseParser::EQ_SINGLE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprPrecedence3Context::NOT_EQ() {\n-  return getToken(ClickHouseParser::NOT_EQ, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprPrecedence3Context::LE() {\n-  return getToken(ClickHouseParser::LE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprPrecedence3Context::GE() {\n-  return getToken(ClickHouseParser::GE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprPrecedence3Context::LT() {\n-  return getToken(ClickHouseParser::LT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprPrecedence3Context::GT() {\n-  return getToken(ClickHouseParser::GT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprPrecedence3Context::IN() {\n-  return getToken(ClickHouseParser::IN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprPrecedence3Context::LIKE() {\n-  return getToken(ClickHouseParser::LIKE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprPrecedence3Context::ILIKE() {\n-  return getToken(ClickHouseParser::ILIKE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprPrecedence3Context::GLOBAL() {\n-  return getToken(ClickHouseParser::GLOBAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprPrecedence3Context::NOT() {\n-  return getToken(ClickHouseParser::NOT, 0);\n-}\n-\n-ClickHouseParser::ColumnExprPrecedence3Context::ColumnExprPrecedence3Context(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprPrecedence3Context::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprPrecedence3(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprIntervalContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprIntervalContext::INTERVAL() {\n-  return getToken(ClickHouseParser::INTERVAL, 0);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::ColumnExprIntervalContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-ClickHouseParser::IntervalContext* ClickHouseParser::ColumnExprIntervalContext::interval() {\n-  return getRuleContext<ClickHouseParser::IntervalContext>(0);\n-}\n-\n-ClickHouseParser::ColumnExprIntervalContext::ColumnExprIntervalContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprIntervalContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprInterval(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprIsNullContext ------------------------------------------------------------------\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::ColumnExprIsNullContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprIsNullContext::IS() {\n-  return getToken(ClickHouseParser::IS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprIsNullContext::NULL_SQL() {\n-  return getToken(ClickHouseParser::NULL_SQL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprIsNullContext::NOT() {\n-  return getToken(ClickHouseParser::NOT, 0);\n-}\n-\n-ClickHouseParser::ColumnExprIsNullContext::ColumnExprIsNullContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprIsNullContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprIsNull(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprTrimContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprTrimContext::TRIM() {\n-  return getToken(ClickHouseParser::TRIM, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprTrimContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprTrimContext::STRING_LITERAL() {\n-  return getToken(ClickHouseParser::STRING_LITERAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprTrimContext::FROM() {\n-  return getToken(ClickHouseParser::FROM, 0);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::ColumnExprTrimContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprTrimContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprTrimContext::BOTH() {\n-  return getToken(ClickHouseParser::BOTH, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprTrimContext::LEADING() {\n-  return getToken(ClickHouseParser::LEADING, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprTrimContext::TRAILING() {\n-  return getToken(ClickHouseParser::TRAILING, 0);\n-}\n-\n-ClickHouseParser::ColumnExprTrimContext::ColumnExprTrimContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprTrimContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprTrim(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprTupleContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprTupleContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-ClickHouseParser::ColumnExprListContext* ClickHouseParser::ColumnExprTupleContext::columnExprList() {\n-  return getRuleContext<ClickHouseParser::ColumnExprListContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprTupleContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-ClickHouseParser::ColumnExprTupleContext::ColumnExprTupleContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprTupleContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprTuple(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprArrayAccessContext ------------------------------------------------------------------\n-\n-std::vector<ClickHouseParser::ColumnExprContext *> ClickHouseParser::ColumnExprArrayAccessContext::columnExpr() {\n-  return getRuleContexts<ClickHouseParser::ColumnExprContext>();\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::ColumnExprArrayAccessContext::columnExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprArrayAccessContext::LBRACKET() {\n-  return getToken(ClickHouseParser::LBRACKET, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprArrayAccessContext::RBRACKET() {\n-  return getToken(ClickHouseParser::RBRACKET, 0);\n-}\n-\n-ClickHouseParser::ColumnExprArrayAccessContext::ColumnExprArrayAccessContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprArrayAccessContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprArrayAccess(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprBetweenContext ------------------------------------------------------------------\n-\n-std::vector<ClickHouseParser::ColumnExprContext *> ClickHouseParser::ColumnExprBetweenContext::columnExpr() {\n-  return getRuleContexts<ClickHouseParser::ColumnExprContext>();\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::ColumnExprBetweenContext::columnExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprBetweenContext::BETWEEN() {\n-  return getToken(ClickHouseParser::BETWEEN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprBetweenContext::AND() {\n-  return getToken(ClickHouseParser::AND, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprBetweenContext::NOT() {\n-  return getToken(ClickHouseParser::NOT, 0);\n-}\n-\n-ClickHouseParser::ColumnExprBetweenContext::ColumnExprBetweenContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprBetweenContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprBetween(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprParensContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprParensContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::ColumnExprParensContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprParensContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-ClickHouseParser::ColumnExprParensContext::ColumnExprParensContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprParensContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprParens(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprTimestampContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprTimestampContext::TIMESTAMP() {\n-  return getToken(ClickHouseParser::TIMESTAMP, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprTimestampContext::STRING_LITERAL() {\n-  return getToken(ClickHouseParser::STRING_LITERAL, 0);\n-}\n-\n-ClickHouseParser::ColumnExprTimestampContext::ColumnExprTimestampContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprTimestampContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprTimestamp(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprAndContext ------------------------------------------------------------------\n-\n-std::vector<ClickHouseParser::ColumnExprContext *> ClickHouseParser::ColumnExprAndContext::columnExpr() {\n-  return getRuleContexts<ClickHouseParser::ColumnExprContext>();\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::ColumnExprAndContext::columnExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprAndContext::AND() {\n-  return getToken(ClickHouseParser::AND, 0);\n-}\n-\n-ClickHouseParser::ColumnExprAndContext::ColumnExprAndContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprAndContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprAnd(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprTupleAccessContext ------------------------------------------------------------------\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::ColumnExprTupleAccessContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprTupleAccessContext::DOT() {\n-  return getToken(ClickHouseParser::DOT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprTupleAccessContext::DECIMAL_LITERAL() {\n-  return getToken(ClickHouseParser::DECIMAL_LITERAL, 0);\n-}\n-\n-ClickHouseParser::ColumnExprTupleAccessContext::ColumnExprTupleAccessContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprTupleAccessContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprTupleAccess(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprCaseContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprCaseContext::CASE() {\n-  return getToken(ClickHouseParser::CASE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprCaseContext::END() {\n-  return getToken(ClickHouseParser::END, 0);\n-}\n-\n-std::vector<ClickHouseParser::ColumnExprContext *> ClickHouseParser::ColumnExprCaseContext::columnExpr() {\n-  return getRuleContexts<ClickHouseParser::ColumnExprContext>();\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::ColumnExprCaseContext::columnExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(i);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::ColumnExprCaseContext::WHEN() {\n-  return getTokens(ClickHouseParser::WHEN);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprCaseContext::WHEN(size_t i) {\n-  return getToken(ClickHouseParser::WHEN, i);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::ColumnExprCaseContext::THEN() {\n-  return getTokens(ClickHouseParser::THEN);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprCaseContext::THEN(size_t i) {\n-  return getToken(ClickHouseParser::THEN, i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprCaseContext::ELSE() {\n-  return getToken(ClickHouseParser::ELSE, 0);\n-}\n-\n-ClickHouseParser::ColumnExprCaseContext::ColumnExprCaseContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprCaseContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprCase(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprDateContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprDateContext::DATE() {\n-  return getToken(ClickHouseParser::DATE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprDateContext::STRING_LITERAL() {\n-  return getToken(ClickHouseParser::STRING_LITERAL, 0);\n-}\n-\n-ClickHouseParser::ColumnExprDateContext::ColumnExprDateContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprDateContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprDate(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprNotContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprNotContext::NOT() {\n-  return getToken(ClickHouseParser::NOT, 0);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::ColumnExprNotContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-ClickHouseParser::ColumnExprNotContext::ColumnExprNotContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprNotContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprNot(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprIdentifierContext ------------------------------------------------------------------\n-\n-ClickHouseParser::ColumnIdentifierContext* ClickHouseParser::ColumnExprIdentifierContext::columnIdentifier() {\n-  return getRuleContext<ClickHouseParser::ColumnIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::ColumnExprIdentifierContext::ColumnExprIdentifierContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprIdentifier(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprFunctionContext ------------------------------------------------------------------\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::ColumnExprFunctionContext::identifier() {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(0);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::ColumnExprFunctionContext::LPAREN() {\n-  return getTokens(ClickHouseParser::LPAREN);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprFunctionContext::LPAREN(size_t i) {\n-  return getToken(ClickHouseParser::LPAREN, i);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::ColumnExprFunctionContext::RPAREN() {\n-  return getTokens(ClickHouseParser::RPAREN);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprFunctionContext::RPAREN(size_t i) {\n-  return getToken(ClickHouseParser::RPAREN, i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprFunctionContext::DISTINCT() {\n-  return getToken(ClickHouseParser::DISTINCT, 0);\n-}\n-\n-ClickHouseParser::ColumnArgListContext* ClickHouseParser::ColumnExprFunctionContext::columnArgList() {\n-  return getRuleContext<ClickHouseParser::ColumnArgListContext>(0);\n-}\n-\n-ClickHouseParser::ColumnExprListContext* ClickHouseParser::ColumnExprFunctionContext::columnExprList() {\n-  return getRuleContext<ClickHouseParser::ColumnExprListContext>(0);\n-}\n-\n-ClickHouseParser::ColumnExprFunctionContext::ColumnExprFunctionContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprFunctionContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprFunction(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- ColumnExprAsteriskContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprAsteriskContext::ASTERISK() {\n-  return getToken(ClickHouseParser::ASTERISK, 0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::ColumnExprAsteriskContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnExprAsteriskContext::DOT() {\n-  return getToken(ClickHouseParser::DOT, 0);\n-}\n-\n-ClickHouseParser::ColumnExprAsteriskContext::ColumnExprAsteriskContext(ColumnExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::ColumnExprAsteriskContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnExprAsterisk(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::columnExpr() {\n-   return columnExpr(0);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::columnExpr(int precedence) {\n-  ParserRuleContext *parentContext = _ctx;\n-  size_t parentState = getState();\n-  ClickHouseParser::ColumnExprContext *_localctx = _tracker.createInstance<ColumnExprContext>(_ctx, parentState);\n-  ClickHouseParser::ColumnExprContext *previousContext = _localctx;\n-  (void)previousContext; // Silence compiler, in case the context is not used by generated code.\n-  size_t startState = 174;\n-  enterRecursionRule(_localctx, 174, ClickHouseParser::RuleColumnExpr, precedence);\n-\n-    size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    unrollRecursionContexts(parentContext);\n-  });\n-  try {\n-    size_t alt;\n-    enterOuterAlt(_localctx, 1);\n-    setState(1693);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 225, _ctx)) {\n-    case 1: {\n-      _localctx = _tracker.createInstance<ColumnExprCaseContext>(_localctx);\n-      _ctx = _localctx;\n-      previousContext = _localctx;\n-\n-      setState(1587);\n-      match(ClickHouseParser::CASE);\n-      setState(1589);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 215, _ctx)) {\n-      case 1: {\n-        setState(1588);\n-        columnExpr(0);\n-        break;\n-      }\n-\n-      }\n-      setState(1596); \n-      _errHandler->sync(this);\n-      _la = _input->LA(1);\n-      do {\n-        setState(1591);\n-        match(ClickHouseParser::WHEN);\n-        setState(1592);\n-        columnExpr(0);\n-        setState(1593);\n-        match(ClickHouseParser::THEN);\n-        setState(1594);\n-        columnExpr(0);\n-        setState(1598); \n-        _errHandler->sync(this);\n-        _la = _input->LA(1);\n-      } while (_la == ClickHouseParser::WHEN);\n-      setState(1602);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::ELSE) {\n-        setState(1600);\n-        match(ClickHouseParser::ELSE);\n-        setState(1601);\n-        columnExpr(0);\n-      }\n-      setState(1604);\n-      match(ClickHouseParser::END);\n-      break;\n-    }\n-\n-    case 2: {\n-      _localctx = _tracker.createInstance<ColumnExprCastContext>(_localctx);\n-      _ctx = _localctx;\n-      previousContext = _localctx;\n-      setState(1606);\n-      match(ClickHouseParser::CAST);\n-      setState(1607);\n-      match(ClickHouseParser::LPAREN);\n-      setState(1608);\n-      columnExpr(0);\n-      setState(1609);\n-      match(ClickHouseParser::AS);\n-      setState(1610);\n-      columnTypeExpr();\n-      setState(1611);\n-      match(ClickHouseParser::RPAREN);\n-      break;\n-    }\n-\n-    case 3: {\n-      _localctx = _tracker.createInstance<ColumnExprDateContext>(_localctx);\n-      _ctx = _localctx;\n-      previousContext = _localctx;\n-      setState(1613);\n-      match(ClickHouseParser::DATE);\n-      setState(1614);\n-      match(ClickHouseParser::STRING_LITERAL);\n-      break;\n-    }\n-\n-    case 4: {\n-      _localctx = _tracker.createInstance<ColumnExprExtractContext>(_localctx);\n-      _ctx = _localctx;\n-      previousContext = _localctx;\n-      setState(1615);\n-      match(ClickHouseParser::EXTRACT);\n-      setState(1616);\n-      match(ClickHouseParser::LPAREN);\n-      setState(1617);\n-      interval();\n-      setState(1618);\n-      match(ClickHouseParser::FROM);\n-      setState(1619);\n-      columnExpr(0);\n-      setState(1620);\n-      match(ClickHouseParser::RPAREN);\n-      break;\n-    }\n-\n-    case 5: {\n-      _localctx = _tracker.createInstance<ColumnExprIntervalContext>(_localctx);\n-      _ctx = _localctx;\n-      previousContext = _localctx;\n-      setState(1622);\n-      match(ClickHouseParser::INTERVAL);\n-      setState(1623);\n-      columnExpr(0);\n-      setState(1624);\n-      interval();\n-      break;\n-    }\n-\n-    case 6: {\n-      _localctx = _tracker.createInstance<ColumnExprSubstringContext>(_localctx);\n-      _ctx = _localctx;\n-      previousContext = _localctx;\n-      setState(1626);\n-      match(ClickHouseParser::SUBSTRING);\n-      setState(1627);\n-      match(ClickHouseParser::LPAREN);\n-      setState(1628);\n-      columnExpr(0);\n-      setState(1629);\n-      match(ClickHouseParser::FROM);\n-      setState(1630);\n-      columnExpr(0);\n-      setState(1633);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if (_la == ClickHouseParser::FOR) {\n-        setState(1631);\n-        match(ClickHouseParser::FOR);\n-        setState(1632);\n-        columnExpr(0);\n-      }\n-      setState(1635);\n-      match(ClickHouseParser::RPAREN);\n-      break;\n-    }\n-\n-    case 7: {\n-      _localctx = _tracker.createInstance<ColumnExprTimestampContext>(_localctx);\n-      _ctx = _localctx;\n-      previousContext = _localctx;\n-      setState(1637);\n-      match(ClickHouseParser::TIMESTAMP);\n-      setState(1638);\n-      match(ClickHouseParser::STRING_LITERAL);\n-      break;\n-    }\n-\n-    case 8: {\n-      _localctx = _tracker.createInstance<ColumnExprTrimContext>(_localctx);\n-      _ctx = _localctx;\n-      previousContext = _localctx;\n-      setState(1639);\n-      match(ClickHouseParser::TRIM);\n-      setState(1640);\n-      match(ClickHouseParser::LPAREN);\n-      setState(1641);\n-      _la = _input->LA(1);\n-      if (!(_la == ClickHouseParser::BOTH || _la == ClickHouseParser::LEADING || _la == ClickHouseParser::TRAILING)) {\n-      _errHandler->recoverInline(this);\n-      }\n-      else {\n-        _errHandler->reportMatch(this);\n-        consume();\n-      }\n-      setState(1642);\n-      match(ClickHouseParser::STRING_LITERAL);\n-      setState(1643);\n-      match(ClickHouseParser::FROM);\n-      setState(1644);\n-      columnExpr(0);\n-      setState(1645);\n-      match(ClickHouseParser::RPAREN);\n-      break;\n-    }\n-\n-    case 9: {\n-      _localctx = _tracker.createInstance<ColumnExprFunctionContext>(_localctx);\n-      _ctx = _localctx;\n-      previousContext = _localctx;\n-      setState(1647);\n-      identifier();\n-      setState(1653);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 220, _ctx)) {\n-      case 1: {\n-        setState(1648);\n-        match(ClickHouseParser::LPAREN);\n-        setState(1650);\n-        _errHandler->sync(this);\n-\n-        _la = _input->LA(1);\n-        if ((((_la & ~ 0x3fULL) == 0) &&\n-          ((1ULL << _la) & ((1ULL << ClickHouseParser::AFTER)\n-          | (1ULL << ClickHouseParser::ALIAS)\n-          | (1ULL << ClickHouseParser::ALL)\n-          | (1ULL << ClickHouseParser::ALTER)\n-          | (1ULL << ClickHouseParser::AND)\n-          | (1ULL << ClickHouseParser::ANTI)\n-          | (1ULL << ClickHouseParser::ANY)\n-          | (1ULL << ClickHouseParser::ARRAY)\n-          | (1ULL << ClickHouseParser::AS)\n-          | (1ULL << ClickHouseParser::ASCENDING)\n-          | (1ULL << ClickHouseParser::ASOF)\n-          | (1ULL << ClickHouseParser::AST)\n-          | (1ULL << ClickHouseParser::ASYNC)\n-          | (1ULL << ClickHouseParser::ATTACH)\n-          | (1ULL << ClickHouseParser::BETWEEN)\n-          | (1ULL << ClickHouseParser::BOTH)\n-          | (1ULL << ClickHouseParser::BY)\n-          | (1ULL << ClickHouseParser::CASE)\n-          | (1ULL << ClickHouseParser::CAST)\n-          | (1ULL << ClickHouseParser::CHECK)\n-          | (1ULL << ClickHouseParser::CLEAR)\n-          | (1ULL << ClickHouseParser::CLUSTER)\n-          | (1ULL << ClickHouseParser::CODEC)\n-          | (1ULL << ClickHouseParser::COLLATE)\n-          | (1ULL << ClickHouseParser::COLUMN)\n-          | (1ULL << ClickHouseParser::COMMENT)\n-          | (1ULL << ClickHouseParser::CONSTRAINT)\n-          | (1ULL << ClickHouseParser::CREATE)\n-          | (1ULL << ClickHouseParser::CROSS)\n-          | (1ULL << ClickHouseParser::CUBE)\n-          | (1ULL << ClickHouseParser::DATABASE)\n-          | (1ULL << ClickHouseParser::DATABASES)\n-          | (1ULL << ClickHouseParser::DATE)\n-          | (1ULL << ClickHouseParser::DAY)\n-          | (1ULL << ClickHouseParser::DEDUPLICATE)\n-          | (1ULL << ClickHouseParser::DEFAULT)\n-          | (1ULL << ClickHouseParser::DELAY)\n-          | (1ULL << ClickHouseParser::DELETE)\n-          | (1ULL << ClickHouseParser::DESC)\n-          | (1ULL << ClickHouseParser::DESCENDING)\n-          | (1ULL << ClickHouseParser::DESCRIBE)\n-          | (1ULL << ClickHouseParser::DETACH)\n-          | (1ULL << ClickHouseParser::DICTIONARIES)\n-          | (1ULL << ClickHouseParser::DICTIONARY)\n-          | (1ULL << ClickHouseParser::DISK)\n-          | (1ULL << ClickHouseParser::DISTINCT)\n-          | (1ULL << ClickHouseParser::DISTRIBUTED)\n-          | (1ULL << ClickHouseParser::DROP)\n-          | (1ULL << ClickHouseParser::ELSE)\n-          | (1ULL << ClickHouseParser::END)\n-          | (1ULL << ClickHouseParser::ENGINE)\n-          | (1ULL << ClickHouseParser::EVENTS)\n-          | (1ULL << ClickHouseParser::EXISTS)\n-          | (1ULL << ClickHouseParser::EXPLAIN)\n-          | (1ULL << ClickHouseParser::EXPRESSION)\n-          | (1ULL << ClickHouseParser::EXTRACT)\n-          | (1ULL << ClickHouseParser::FETCHES)\n-          | (1ULL << ClickHouseParser::FINAL)\n-          | (1ULL << ClickHouseParser::FIRST)\n-          | (1ULL << ClickHouseParser::FLUSH)\n-          | (1ULL << ClickHouseParser::FOR)\n-          | (1ULL << ClickHouseParser::FORMAT))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&\n-          ((1ULL << (_la - 64)) & ((1ULL << (ClickHouseParser::FREEZE - 64))\n-          | (1ULL << (ClickHouseParser::FROM - 64))\n-          | (1ULL << (ClickHouseParser::FULL - 64))\n-          | (1ULL << (ClickHouseParser::FUNCTION - 64))\n-          | (1ULL << (ClickHouseParser::GLOBAL - 64))\n-          | (1ULL << (ClickHouseParser::GRANULARITY - 64))\n-          | (1ULL << (ClickHouseParser::GROUP - 64))\n-          | (1ULL << (ClickHouseParser::HAVING - 64))\n-          | (1ULL << (ClickHouseParser::HIERARCHICAL - 64))\n-          | (1ULL << (ClickHouseParser::HOUR - 64))\n-          | (1ULL << (ClickHouseParser::ID - 64))\n-          | (1ULL << (ClickHouseParser::IF - 64))\n-          | (1ULL << (ClickHouseParser::ILIKE - 64))\n-          | (1ULL << (ClickHouseParser::IN - 64))\n-          | (1ULL << (ClickHouseParser::INDEX - 64))\n-          | (1ULL << (ClickHouseParser::INF - 64))\n-          | (1ULL << (ClickHouseParser::INJECTIVE - 64))\n-          | (1ULL << (ClickHouseParser::INNER - 64))\n-          | (1ULL << (ClickHouseParser::INSERT - 64))\n-          | (1ULL << (ClickHouseParser::INTERVAL - 64))\n-          | (1ULL << (ClickHouseParser::INTO - 64))\n-          | (1ULL << (ClickHouseParser::IS - 64))\n-          | (1ULL << (ClickHouseParser::IS_OBJECT_ID - 64))\n-          | (1ULL << (ClickHouseParser::JOIN - 64))\n-          | (1ULL << (ClickHouseParser::KEY - 64))\n-          | (1ULL << (ClickHouseParser::KILL - 64))\n-          | (1ULL << (ClickHouseParser::LAST - 64))\n-          | (1ULL << (ClickHouseParser::LAYOUT - 64))\n-          | (1ULL << (ClickHouseParser::LEADING - 64))\n-          | (1ULL << (ClickHouseParser::LEFT - 64))\n-          | (1ULL << (ClickHouseParser::LIFETIME - 64))\n-          | (1ULL << (ClickHouseParser::LIKE - 64))\n-          | (1ULL << (ClickHouseParser::LIMIT - 64))\n-          | (1ULL << (ClickHouseParser::LIVE - 64))\n-          | (1ULL << (ClickHouseParser::LOCAL - 64))\n-          | (1ULL << (ClickHouseParser::LOGS - 64))\n-          | (1ULL << (ClickHouseParser::MATERIALIZE - 64))\n-          | (1ULL << (ClickHouseParser::MATERIALIZED - 64))\n-          | (1ULL << (ClickHouseParser::MAX - 64))\n-          | (1ULL << (ClickHouseParser::MERGES - 64))\n-          | (1ULL << (ClickHouseParser::MIN - 64))\n-          | (1ULL << (ClickHouseParser::MINUTE - 64))\n-          | (1ULL << (ClickHouseParser::MODIFY - 64))\n-          | (1ULL << (ClickHouseParser::MONTH - 64))\n-          | (1ULL << (ClickHouseParser::MOVE - 64))\n-          | (1ULL << (ClickHouseParser::MUTATION - 64))\n-          | (1ULL << (ClickHouseParser::NAN_SQL - 64))\n-          | (1ULL << (ClickHouseParser::NO - 64))\n-          | (1ULL << (ClickHouseParser::NOT - 64))\n-          | (1ULL << (ClickHouseParser::NULL_SQL - 64))\n-          | (1ULL << (ClickHouseParser::NULLS - 64))\n-          | (1ULL << (ClickHouseParser::OFFSET - 64))\n-          | (1ULL << (ClickHouseParser::ON - 64))\n-          | (1ULL << (ClickHouseParser::OPTIMIZE - 64))\n-          | (1ULL << (ClickHouseParser::OR - 64))\n-          | (1ULL << (ClickHouseParser::ORDER - 64))\n-          | (1ULL << (ClickHouseParser::OUTER - 64))\n-          | (1ULL << (ClickHouseParser::OUTFILE - 64))\n-          | (1ULL << (ClickHouseParser::PARTITION - 64))\n-          | (1ULL << (ClickHouseParser::POPULATE - 64))\n-          | (1ULL << (ClickHouseParser::PREWHERE - 64))\n-          | (1ULL << (ClickHouseParser::PRIMARY - 64))\n-          | (1ULL << (ClickHouseParser::QUARTER - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&\n-          ((1ULL << (_la - 128)) & ((1ULL << (ClickHouseParser::RANGE - 128))\n-          | (1ULL << (ClickHouseParser::RELOAD - 128))\n-          | (1ULL << (ClickHouseParser::REMOVE - 128))\n-          | (1ULL << (ClickHouseParser::RENAME - 128))\n-          | (1ULL << (ClickHouseParser::REPLACE - 128))\n-          | (1ULL << (ClickHouseParser::REPLICA - 128))\n-          | (1ULL << (ClickHouseParser::REPLICATED - 128))\n-          | (1ULL << (ClickHouseParser::RIGHT - 128))\n-          | (1ULL << (ClickHouseParser::ROLLUP - 128))\n-          | (1ULL << (ClickHouseParser::SAMPLE - 128))\n-          | (1ULL << (ClickHouseParser::SECOND - 128))\n-          | (1ULL << (ClickHouseParser::SELECT - 128))\n-          | (1ULL << (ClickHouseParser::SEMI - 128))\n-          | (1ULL << (ClickHouseParser::SENDS - 128))\n-          | (1ULL << (ClickHouseParser::SET - 128))\n-          | (1ULL << (ClickHouseParser::SETTINGS - 128))\n-          | (1ULL << (ClickHouseParser::SHOW - 128))\n-          | (1ULL << (ClickHouseParser::SOURCE - 128))\n-          | (1ULL << (ClickHouseParser::START - 128))\n-          | (1ULL << (ClickHouseParser::STOP - 128))\n-          | (1ULL << (ClickHouseParser::SUBSTRING - 128))\n-          | (1ULL << (ClickHouseParser::SYNC - 128))\n-          | (1ULL << (ClickHouseParser::SYNTAX - 128))\n-          | (1ULL << (ClickHouseParser::SYSTEM - 128))\n-          | (1ULL << (ClickHouseParser::TABLE - 128))\n-          | (1ULL << (ClickHouseParser::TABLES - 128))\n-          | (1ULL << (ClickHouseParser::TEMPORARY - 128))\n-          | (1ULL << (ClickHouseParser::TEST - 128))\n-          | (1ULL << (ClickHouseParser::THEN - 128))\n-          | (1ULL << (ClickHouseParser::TIES - 128))\n-          | (1ULL << (ClickHouseParser::TIMEOUT - 128))\n-          | (1ULL << (ClickHouseParser::TIMESTAMP - 128))\n-          | (1ULL << (ClickHouseParser::TO - 128))\n-          | (1ULL << (ClickHouseParser::TOP - 128))\n-          | (1ULL << (ClickHouseParser::TOTALS - 128))\n-          | (1ULL << (ClickHouseParser::TRAILING - 128))\n-          | (1ULL << (ClickHouseParser::TRIM - 128))\n-          | (1ULL << (ClickHouseParser::TRUNCATE - 128))\n-          | (1ULL << (ClickHouseParser::TTL - 128))\n-          | (1ULL << (ClickHouseParser::TYPE - 128))\n-          | (1ULL << (ClickHouseParser::UNION - 128))\n-          | (1ULL << (ClickHouseParser::UPDATE - 128))\n-          | (1ULL << (ClickHouseParser::USE - 128))\n-          | (1ULL << (ClickHouseParser::USING - 128))\n-          | (1ULL << (ClickHouseParser::UUID - 128))\n-          | (1ULL << (ClickHouseParser::VALUES - 128))\n-          | (1ULL << (ClickHouseParser::VIEW - 128))\n-          | (1ULL << (ClickHouseParser::VOLUME - 128))\n-          | (1ULL << (ClickHouseParser::WATCH - 128))\n-          | (1ULL << (ClickHouseParser::WEEK - 128))\n-          | (1ULL << (ClickHouseParser::WHEN - 128))\n-          | (1ULL << (ClickHouseParser::WHERE - 128))\n-          | (1ULL << (ClickHouseParser::WITH - 128))\n-          | (1ULL << (ClickHouseParser::YEAR - 128))\n-          | (1ULL << (ClickHouseParser::JSON_FALSE - 128))\n-          | (1ULL << (ClickHouseParser::JSON_TRUE - 128))\n-          | (1ULL << (ClickHouseParser::IDENTIFIER - 128))\n-          | (1ULL << (ClickHouseParser::FLOATING_LITERAL - 128))\n-          | (1ULL << (ClickHouseParser::OCTAL_LITERAL - 128))\n-          | (1ULL << (ClickHouseParser::DECIMAL_LITERAL - 128))\n-          | (1ULL << (ClickHouseParser::HEXADECIMAL_LITERAL - 128))\n-          | (1ULL << (ClickHouseParser::STRING_LITERAL - 128))\n-          | (1ULL << (ClickHouseParser::ASTERISK - 128)))) != 0) || ((((_la - 197) & ~ 0x3fULL) == 0) &&\n-          ((1ULL << (_la - 197)) & ((1ULL << (ClickHouseParser::DASH - 197))\n-          | (1ULL << (ClickHouseParser::DOT - 197))\n-          | (1ULL << (ClickHouseParser::LBRACKET - 197))\n-          | (1ULL << (ClickHouseParser::LPAREN - 197))\n-          | (1ULL << (ClickHouseParser::PLUS - 197)))) != 0)) {\n-          setState(1649);\n-          columnExprList();\n-        }\n-        setState(1652);\n-        match(ClickHouseParser::RPAREN);\n-        break;\n-      }\n-\n-      }\n-      setState(1655);\n-      match(ClickHouseParser::LPAREN);\n-      setState(1657);\n-      _errHandler->sync(this);\n-\n-      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx)) {\n-      case 1: {\n-        setState(1656);\n-        match(ClickHouseParser::DISTINCT);\n-        break;\n-      }\n-\n-      }\n-      setState(1660);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if ((((_la & ~ 0x3fULL) == 0) &&\n-        ((1ULL << _la) & ((1ULL << ClickHouseParser::AFTER)\n-        | (1ULL << ClickHouseParser::ALIAS)\n-        | (1ULL << ClickHouseParser::ALL)\n-        | (1ULL << ClickHouseParser::ALTER)\n-        | (1ULL << ClickHouseParser::AND)\n-        | (1ULL << ClickHouseParser::ANTI)\n-        | (1ULL << ClickHouseParser::ANY)\n-        | (1ULL << ClickHouseParser::ARRAY)\n-        | (1ULL << ClickHouseParser::AS)\n-        | (1ULL << ClickHouseParser::ASCENDING)\n-        | (1ULL << ClickHouseParser::ASOF)\n-        | (1ULL << ClickHouseParser::AST)\n-        | (1ULL << ClickHouseParser::ASYNC)\n-        | (1ULL << ClickHouseParser::ATTACH)\n-        | (1ULL << ClickHouseParser::BETWEEN)\n-        | (1ULL << ClickHouseParser::BOTH)\n-        | (1ULL << ClickHouseParser::BY)\n-        | (1ULL << ClickHouseParser::CASE)\n-        | (1ULL << ClickHouseParser::CAST)\n-        | (1ULL << ClickHouseParser::CHECK)\n-        | (1ULL << ClickHouseParser::CLEAR)\n-        | (1ULL << ClickHouseParser::CLUSTER)\n-        | (1ULL << ClickHouseParser::CODEC)\n-        | (1ULL << ClickHouseParser::COLLATE)\n-        | (1ULL << ClickHouseParser::COLUMN)\n-        | (1ULL << ClickHouseParser::COMMENT)\n-        | (1ULL << ClickHouseParser::CONSTRAINT)\n-        | (1ULL << ClickHouseParser::CREATE)\n-        | (1ULL << ClickHouseParser::CROSS)\n-        | (1ULL << ClickHouseParser::CUBE)\n-        | (1ULL << ClickHouseParser::DATABASE)\n-        | (1ULL << ClickHouseParser::DATABASES)\n-        | (1ULL << ClickHouseParser::DATE)\n-        | (1ULL << ClickHouseParser::DAY)\n-        | (1ULL << ClickHouseParser::DEDUPLICATE)\n-        | (1ULL << ClickHouseParser::DEFAULT)\n-        | (1ULL << ClickHouseParser::DELAY)\n-        | (1ULL << ClickHouseParser::DELETE)\n-        | (1ULL << ClickHouseParser::DESC)\n-        | (1ULL << ClickHouseParser::DESCENDING)\n-        | (1ULL << ClickHouseParser::DESCRIBE)\n-        | (1ULL << ClickHouseParser::DETACH)\n-        | (1ULL << ClickHouseParser::DICTIONARIES)\n-        | (1ULL << ClickHouseParser::DICTIONARY)\n-        | (1ULL << ClickHouseParser::DISK)\n-        | (1ULL << ClickHouseParser::DISTINCT)\n-        | (1ULL << ClickHouseParser::DISTRIBUTED)\n-        | (1ULL << ClickHouseParser::DROP)\n-        | (1ULL << ClickHouseParser::ELSE)\n-        | (1ULL << ClickHouseParser::END)\n-        | (1ULL << ClickHouseParser::ENGINE)\n-        | (1ULL << ClickHouseParser::EVENTS)\n-        | (1ULL << ClickHouseParser::EXISTS)\n-        | (1ULL << ClickHouseParser::EXPLAIN)\n-        | (1ULL << ClickHouseParser::EXPRESSION)\n-        | (1ULL << ClickHouseParser::EXTRACT)\n-        | (1ULL << ClickHouseParser::FETCHES)\n-        | (1ULL << ClickHouseParser::FINAL)\n-        | (1ULL << ClickHouseParser::FIRST)\n-        | (1ULL << ClickHouseParser::FLUSH)\n-        | (1ULL << ClickHouseParser::FOR)\n-        | (1ULL << ClickHouseParser::FORMAT))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&\n-        ((1ULL << (_la - 64)) & ((1ULL << (ClickHouseParser::FREEZE - 64))\n-        | (1ULL << (ClickHouseParser::FROM - 64))\n-        | (1ULL << (ClickHouseParser::FULL - 64))\n-        | (1ULL << (ClickHouseParser::FUNCTION - 64))\n-        | (1ULL << (ClickHouseParser::GLOBAL - 64))\n-        | (1ULL << (ClickHouseParser::GRANULARITY - 64))\n-        | (1ULL << (ClickHouseParser::GROUP - 64))\n-        | (1ULL << (ClickHouseParser::HAVING - 64))\n-        | (1ULL << (ClickHouseParser::HIERARCHICAL - 64))\n-        | (1ULL << (ClickHouseParser::HOUR - 64))\n-        | (1ULL << (ClickHouseParser::ID - 64))\n-        | (1ULL << (ClickHouseParser::IF - 64))\n-        | (1ULL << (ClickHouseParser::ILIKE - 64))\n-        | (1ULL << (ClickHouseParser::IN - 64))\n-        | (1ULL << (ClickHouseParser::INDEX - 64))\n-        | (1ULL << (ClickHouseParser::INF - 64))\n-        | (1ULL << (ClickHouseParser::INJECTIVE - 64))\n-        | (1ULL << (ClickHouseParser::INNER - 64))\n-        | (1ULL << (ClickHouseParser::INSERT - 64))\n-        | (1ULL << (ClickHouseParser::INTERVAL - 64))\n-        | (1ULL << (ClickHouseParser::INTO - 64))\n-        | (1ULL << (ClickHouseParser::IS - 64))\n-        | (1ULL << (ClickHouseParser::IS_OBJECT_ID - 64))\n-        | (1ULL << (ClickHouseParser::JOIN - 64))\n-        | (1ULL << (ClickHouseParser::KEY - 64))\n-        | (1ULL << (ClickHouseParser::KILL - 64))\n-        | (1ULL << (ClickHouseParser::LAST - 64))\n-        | (1ULL << (ClickHouseParser::LAYOUT - 64))\n-        | (1ULL << (ClickHouseParser::LEADING - 64))\n-        | (1ULL << (ClickHouseParser::LEFT - 64))\n-        | (1ULL << (ClickHouseParser::LIFETIME - 64))\n-        | (1ULL << (ClickHouseParser::LIKE - 64))\n-        | (1ULL << (ClickHouseParser::LIMIT - 64))\n-        | (1ULL << (ClickHouseParser::LIVE - 64))\n-        | (1ULL << (ClickHouseParser::LOCAL - 64))\n-        | (1ULL << (ClickHouseParser::LOGS - 64))\n-        | (1ULL << (ClickHouseParser::MATERIALIZE - 64))\n-        | (1ULL << (ClickHouseParser::MATERIALIZED - 64))\n-        | (1ULL << (ClickHouseParser::MAX - 64))\n-        | (1ULL << (ClickHouseParser::MERGES - 64))\n-        | (1ULL << (ClickHouseParser::MIN - 64))\n-        | (1ULL << (ClickHouseParser::MINUTE - 64))\n-        | (1ULL << (ClickHouseParser::MODIFY - 64))\n-        | (1ULL << (ClickHouseParser::MONTH - 64))\n-        | (1ULL << (ClickHouseParser::MOVE - 64))\n-        | (1ULL << (ClickHouseParser::MUTATION - 64))\n-        | (1ULL << (ClickHouseParser::NAN_SQL - 64))\n-        | (1ULL << (ClickHouseParser::NO - 64))\n-        | (1ULL << (ClickHouseParser::NOT - 64))\n-        | (1ULL << (ClickHouseParser::NULL_SQL - 64))\n-        | (1ULL << (ClickHouseParser::NULLS - 64))\n-        | (1ULL << (ClickHouseParser::OFFSET - 64))\n-        | (1ULL << (ClickHouseParser::ON - 64))\n-        | (1ULL << (ClickHouseParser::OPTIMIZE - 64))\n-        | (1ULL << (ClickHouseParser::OR - 64))\n-        | (1ULL << (ClickHouseParser::ORDER - 64))\n-        | (1ULL << (ClickHouseParser::OUTER - 64))\n-        | (1ULL << (ClickHouseParser::OUTFILE - 64))\n-        | (1ULL << (ClickHouseParser::PARTITION - 64))\n-        | (1ULL << (ClickHouseParser::POPULATE - 64))\n-        | (1ULL << (ClickHouseParser::PREWHERE - 64))\n-        | (1ULL << (ClickHouseParser::PRIMARY - 64))\n-        | (1ULL << (ClickHouseParser::QUARTER - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&\n-        ((1ULL << (_la - 128)) & ((1ULL << (ClickHouseParser::RANGE - 128))\n-        | (1ULL << (ClickHouseParser::RELOAD - 128))\n-        | (1ULL << (ClickHouseParser::REMOVE - 128))\n-        | (1ULL << (ClickHouseParser::RENAME - 128))\n-        | (1ULL << (ClickHouseParser::REPLACE - 128))\n-        | (1ULL << (ClickHouseParser::REPLICA - 128))\n-        | (1ULL << (ClickHouseParser::REPLICATED - 128))\n-        | (1ULL << (ClickHouseParser::RIGHT - 128))\n-        | (1ULL << (ClickHouseParser::ROLLUP - 128))\n-        | (1ULL << (ClickHouseParser::SAMPLE - 128))\n-        | (1ULL << (ClickHouseParser::SECOND - 128))\n-        | (1ULL << (ClickHouseParser::SELECT - 128))\n-        | (1ULL << (ClickHouseParser::SEMI - 128))\n-        | (1ULL << (ClickHouseParser::SENDS - 128))\n-        | (1ULL << (ClickHouseParser::SET - 128))\n-        | (1ULL << (ClickHouseParser::SETTINGS - 128))\n-        | (1ULL << (ClickHouseParser::SHOW - 128))\n-        | (1ULL << (ClickHouseParser::SOURCE - 128))\n-        | (1ULL << (ClickHouseParser::START - 128))\n-        | (1ULL << (ClickHouseParser::STOP - 128))\n-        | (1ULL << (ClickHouseParser::SUBSTRING - 128))\n-        | (1ULL << (ClickHouseParser::SYNC - 128))\n-        | (1ULL << (ClickHouseParser::SYNTAX - 128))\n-        | (1ULL << (ClickHouseParser::SYSTEM - 128))\n-        | (1ULL << (ClickHouseParser::TABLE - 128))\n-        | (1ULL << (ClickHouseParser::TABLES - 128))\n-        | (1ULL << (ClickHouseParser::TEMPORARY - 128))\n-        | (1ULL << (ClickHouseParser::TEST - 128))\n-        | (1ULL << (ClickHouseParser::THEN - 128))\n-        | (1ULL << (ClickHouseParser::TIES - 128))\n-        | (1ULL << (ClickHouseParser::TIMEOUT - 128))\n-        | (1ULL << (ClickHouseParser::TIMESTAMP - 128))\n-        | (1ULL << (ClickHouseParser::TO - 128))\n-        | (1ULL << (ClickHouseParser::TOP - 128))\n-        | (1ULL << (ClickHouseParser::TOTALS - 128))\n-        | (1ULL << (ClickHouseParser::TRAILING - 128))\n-        | (1ULL << (ClickHouseParser::TRIM - 128))\n-        | (1ULL << (ClickHouseParser::TRUNCATE - 128))\n-        | (1ULL << (ClickHouseParser::TTL - 128))\n-        | (1ULL << (ClickHouseParser::TYPE - 128))\n-        | (1ULL << (ClickHouseParser::UNION - 128))\n-        | (1ULL << (ClickHouseParser::UPDATE - 128))\n-        | (1ULL << (ClickHouseParser::USE - 128))\n-        | (1ULL << (ClickHouseParser::USING - 128))\n-        | (1ULL << (ClickHouseParser::UUID - 128))\n-        | (1ULL << (ClickHouseParser::VALUES - 128))\n-        | (1ULL << (ClickHouseParser::VIEW - 128))\n-        | (1ULL << (ClickHouseParser::VOLUME - 128))\n-        | (1ULL << (ClickHouseParser::WATCH - 128))\n-        | (1ULL << (ClickHouseParser::WEEK - 128))\n-        | (1ULL << (ClickHouseParser::WHEN - 128))\n-        | (1ULL << (ClickHouseParser::WHERE - 128))\n-        | (1ULL << (ClickHouseParser::WITH - 128))\n-        | (1ULL << (ClickHouseParser::YEAR - 128))\n-        | (1ULL << (ClickHouseParser::JSON_FALSE - 128))\n-        | (1ULL << (ClickHouseParser::JSON_TRUE - 128))\n-        | (1ULL << (ClickHouseParser::IDENTIFIER - 128))\n-        | (1ULL << (ClickHouseParser::FLOATING_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::OCTAL_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::DECIMAL_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::HEXADECIMAL_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::STRING_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::ASTERISK - 128)))) != 0) || ((((_la - 197) & ~ 0x3fULL) == 0) &&\n-        ((1ULL << (_la - 197)) & ((1ULL << (ClickHouseParser::DASH - 197))\n-        | (1ULL << (ClickHouseParser::DOT - 197))\n-        | (1ULL << (ClickHouseParser::LBRACKET - 197))\n-        | (1ULL << (ClickHouseParser::LPAREN - 197))\n-        | (1ULL << (ClickHouseParser::PLUS - 197)))) != 0)) {\n-        setState(1659);\n-        columnArgList();\n-      }\n-      setState(1662);\n-      match(ClickHouseParser::RPAREN);\n-      break;\n-    }\n-\n-    case 10: {\n-      _localctx = _tracker.createInstance<ColumnExprLiteralContext>(_localctx);\n-      _ctx = _localctx;\n-      previousContext = _localctx;\n-      setState(1664);\n-      literal();\n-      break;\n-    }\n-\n-    case 11: {\n-      _localctx = _tracker.createInstance<ColumnExprNegateContext>(_localctx);\n-      _ctx = _localctx;\n-      previousContext = _localctx;\n-      setState(1665);\n-      match(ClickHouseParser::DASH);\n-      setState(1666);\n-      columnExpr(17);\n-      break;\n-    }\n-\n-    case 12: {\n-      _localctx = _tracker.createInstance<ColumnExprNotContext>(_localctx);\n-      _ctx = _localctx;\n-      previousContext = _localctx;\n-      setState(1667);\n-      match(ClickHouseParser::NOT);\n-      setState(1668);\n-      columnExpr(12);\n-      break;\n-    }\n-\n-    case 13: {\n-      _localctx = _tracker.createInstance<ColumnExprAsteriskContext>(_localctx);\n-      _ctx = _localctx;\n-      previousContext = _localctx;\n-      setState(1672);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if ((((_la & ~ 0x3fULL) == 0) &&\n-        ((1ULL << _la) & ((1ULL << ClickHouseParser::AFTER)\n-        | (1ULL << ClickHouseParser::ALIAS)\n-        | (1ULL << ClickHouseParser::ALL)\n-        | (1ULL << ClickHouseParser::ALTER)\n-        | (1ULL << ClickHouseParser::AND)\n-        | (1ULL << ClickHouseParser::ANTI)\n-        | (1ULL << ClickHouseParser::ANY)\n-        | (1ULL << ClickHouseParser::ARRAY)\n-        | (1ULL << ClickHouseParser::AS)\n-        | (1ULL << ClickHouseParser::ASCENDING)\n-        | (1ULL << ClickHouseParser::ASOF)\n-        | (1ULL << ClickHouseParser::AST)\n-        | (1ULL << ClickHouseParser::ASYNC)\n-        | (1ULL << ClickHouseParser::ATTACH)\n-        | (1ULL << ClickHouseParser::BETWEEN)\n-        | (1ULL << ClickHouseParser::BOTH)\n-        | (1ULL << ClickHouseParser::BY)\n-        | (1ULL << ClickHouseParser::CASE)\n-        | (1ULL << ClickHouseParser::CAST)\n-        | (1ULL << ClickHouseParser::CHECK)\n-        | (1ULL << ClickHouseParser::CLEAR)\n-        | (1ULL << ClickHouseParser::CLUSTER)\n-        | (1ULL << ClickHouseParser::CODEC)\n-        | (1ULL << ClickHouseParser::COLLATE)\n-        | (1ULL << ClickHouseParser::COLUMN)\n-        | (1ULL << ClickHouseParser::COMMENT)\n-        | (1ULL << ClickHouseParser::CONSTRAINT)\n-        | (1ULL << ClickHouseParser::CREATE)\n-        | (1ULL << ClickHouseParser::CROSS)\n-        | (1ULL << ClickHouseParser::CUBE)\n-        | (1ULL << ClickHouseParser::DATABASE)\n-        | (1ULL << ClickHouseParser::DATABASES)\n-        | (1ULL << ClickHouseParser::DATE)\n-        | (1ULL << ClickHouseParser::DAY)\n-        | (1ULL << ClickHouseParser::DEDUPLICATE)\n-        | (1ULL << ClickHouseParser::DEFAULT)\n-        | (1ULL << ClickHouseParser::DELAY)\n-        | (1ULL << ClickHouseParser::DELETE)\n-        | (1ULL << ClickHouseParser::DESC)\n-        | (1ULL << ClickHouseParser::DESCENDING)\n-        | (1ULL << ClickHouseParser::DESCRIBE)\n-        | (1ULL << ClickHouseParser::DETACH)\n-        | (1ULL << ClickHouseParser::DICTIONARIES)\n-        | (1ULL << ClickHouseParser::DICTIONARY)\n-        | (1ULL << ClickHouseParser::DISK)\n-        | (1ULL << ClickHouseParser::DISTINCT)\n-        | (1ULL << ClickHouseParser::DISTRIBUTED)\n-        | (1ULL << ClickHouseParser::DROP)\n-        | (1ULL << ClickHouseParser::ELSE)\n-        | (1ULL << ClickHouseParser::END)\n-        | (1ULL << ClickHouseParser::ENGINE)\n-        | (1ULL << ClickHouseParser::EVENTS)\n-        | (1ULL << ClickHouseParser::EXISTS)\n-        | (1ULL << ClickHouseParser::EXPLAIN)\n-        | (1ULL << ClickHouseParser::EXPRESSION)\n-        | (1ULL << ClickHouseParser::EXTRACT)\n-        | (1ULL << ClickHouseParser::FETCHES)\n-        | (1ULL << ClickHouseParser::FINAL)\n-        | (1ULL << ClickHouseParser::FIRST)\n-        | (1ULL << ClickHouseParser::FLUSH)\n-        | (1ULL << ClickHouseParser::FOR)\n-        | (1ULL << ClickHouseParser::FORMAT))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&\n-        ((1ULL << (_la - 64)) & ((1ULL << (ClickHouseParser::FREEZE - 64))\n-        | (1ULL << (ClickHouseParser::FROM - 64))\n-        | (1ULL << (ClickHouseParser::FULL - 64))\n-        | (1ULL << (ClickHouseParser::FUNCTION - 64))\n-        | (1ULL << (ClickHouseParser::GLOBAL - 64))\n-        | (1ULL << (ClickHouseParser::GRANULARITY - 64))\n-        | (1ULL << (ClickHouseParser::GROUP - 64))\n-        | (1ULL << (ClickHouseParser::HAVING - 64))\n-        | (1ULL << (ClickHouseParser::HIERARCHICAL - 64))\n-        | (1ULL << (ClickHouseParser::HOUR - 64))\n-        | (1ULL << (ClickHouseParser::ID - 64))\n-        | (1ULL << (ClickHouseParser::IF - 64))\n-        | (1ULL << (ClickHouseParser::ILIKE - 64))\n-        | (1ULL << (ClickHouseParser::IN - 64))\n-        | (1ULL << (ClickHouseParser::INDEX - 64))\n-        | (1ULL << (ClickHouseParser::INJECTIVE - 64))\n-        | (1ULL << (ClickHouseParser::INNER - 64))\n-        | (1ULL << (ClickHouseParser::INSERT - 64))\n-        | (1ULL << (ClickHouseParser::INTERVAL - 64))\n-        | (1ULL << (ClickHouseParser::INTO - 64))\n-        | (1ULL << (ClickHouseParser::IS - 64))\n-        | (1ULL << (ClickHouseParser::IS_OBJECT_ID - 64))\n-        | (1ULL << (ClickHouseParser::JOIN - 64))\n-        | (1ULL << (ClickHouseParser::KEY - 64))\n-        | (1ULL << (ClickHouseParser::KILL - 64))\n-        | (1ULL << (ClickHouseParser::LAST - 64))\n-        | (1ULL << (ClickHouseParser::LAYOUT - 64))\n-        | (1ULL << (ClickHouseParser::LEADING - 64))\n-        | (1ULL << (ClickHouseParser::LEFT - 64))\n-        | (1ULL << (ClickHouseParser::LIFETIME - 64))\n-        | (1ULL << (ClickHouseParser::LIKE - 64))\n-        | (1ULL << (ClickHouseParser::LIMIT - 64))\n-        | (1ULL << (ClickHouseParser::LIVE - 64))\n-        | (1ULL << (ClickHouseParser::LOCAL - 64))\n-        | (1ULL << (ClickHouseParser::LOGS - 64))\n-        | (1ULL << (ClickHouseParser::MATERIALIZE - 64))\n-        | (1ULL << (ClickHouseParser::MATERIALIZED - 64))\n-        | (1ULL << (ClickHouseParser::MAX - 64))\n-        | (1ULL << (ClickHouseParser::MERGES - 64))\n-        | (1ULL << (ClickHouseParser::MIN - 64))\n-        | (1ULL << (ClickHouseParser::MINUTE - 64))\n-        | (1ULL << (ClickHouseParser::MODIFY - 64))\n-        | (1ULL << (ClickHouseParser::MONTH - 64))\n-        | (1ULL << (ClickHouseParser::MOVE - 64))\n-        | (1ULL << (ClickHouseParser::MUTATION - 64))\n-        | (1ULL << (ClickHouseParser::NO - 64))\n-        | (1ULL << (ClickHouseParser::NOT - 64))\n-        | (1ULL << (ClickHouseParser::NULLS - 64))\n-        | (1ULL << (ClickHouseParser::OFFSET - 64))\n-        | (1ULL << (ClickHouseParser::ON - 64))\n-        | (1ULL << (ClickHouseParser::OPTIMIZE - 64))\n-        | (1ULL << (ClickHouseParser::OR - 64))\n-        | (1ULL << (ClickHouseParser::ORDER - 64))\n-        | (1ULL << (ClickHouseParser::OUTER - 64))\n-        | (1ULL << (ClickHouseParser::OUTFILE - 64))\n-        | (1ULL << (ClickHouseParser::PARTITION - 64))\n-        | (1ULL << (ClickHouseParser::POPULATE - 64))\n-        | (1ULL << (ClickHouseParser::PREWHERE - 64))\n-        | (1ULL << (ClickHouseParser::PRIMARY - 64))\n-        | (1ULL << (ClickHouseParser::QUARTER - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&\n-        ((1ULL << (_la - 128)) & ((1ULL << (ClickHouseParser::RANGE - 128))\n-        | (1ULL << (ClickHouseParser::RELOAD - 128))\n-        | (1ULL << (ClickHouseParser::REMOVE - 128))\n-        | (1ULL << (ClickHouseParser::RENAME - 128))\n-        | (1ULL << (ClickHouseParser::REPLACE - 128))\n-        | (1ULL << (ClickHouseParser::REPLICA - 128))\n-        | (1ULL << (ClickHouseParser::REPLICATED - 128))\n-        | (1ULL << (ClickHouseParser::RIGHT - 128))\n-        | (1ULL << (ClickHouseParser::ROLLUP - 128))\n-        | (1ULL << (ClickHouseParser::SAMPLE - 128))\n-        | (1ULL << (ClickHouseParser::SECOND - 128))\n-        | (1ULL << (ClickHouseParser::SELECT - 128))\n-        | (1ULL << (ClickHouseParser::SEMI - 128))\n-        | (1ULL << (ClickHouseParser::SENDS - 128))\n-        | (1ULL << (ClickHouseParser::SET - 128))\n-        | (1ULL << (ClickHouseParser::SETTINGS - 128))\n-        | (1ULL << (ClickHouseParser::SHOW - 128))\n-        | (1ULL << (ClickHouseParser::SOURCE - 128))\n-        | (1ULL << (ClickHouseParser::START - 128))\n-        | (1ULL << (ClickHouseParser::STOP - 128))\n-        | (1ULL << (ClickHouseParser::SUBSTRING - 128))\n-        | (1ULL << (ClickHouseParser::SYNC - 128))\n-        | (1ULL << (ClickHouseParser::SYNTAX - 128))\n-        | (1ULL << (ClickHouseParser::SYSTEM - 128))\n-        | (1ULL << (ClickHouseParser::TABLE - 128))\n-        | (1ULL << (ClickHouseParser::TABLES - 128))\n-        | (1ULL << (ClickHouseParser::TEMPORARY - 128))\n-        | (1ULL << (ClickHouseParser::TEST - 128))\n-        | (1ULL << (ClickHouseParser::THEN - 128))\n-        | (1ULL << (ClickHouseParser::TIES - 128))\n-        | (1ULL << (ClickHouseParser::TIMEOUT - 128))\n-        | (1ULL << (ClickHouseParser::TIMESTAMP - 128))\n-        | (1ULL << (ClickHouseParser::TO - 128))\n-        | (1ULL << (ClickHouseParser::TOP - 128))\n-        | (1ULL << (ClickHouseParser::TOTALS - 128))\n-        | (1ULL << (ClickHouseParser::TRAILING - 128))\n-        | (1ULL << (ClickHouseParser::TRIM - 128))\n-        | (1ULL << (ClickHouseParser::TRUNCATE - 128))\n-        | (1ULL << (ClickHouseParser::TTL - 128))\n-        | (1ULL << (ClickHouseParser::TYPE - 128))\n-        | (1ULL << (ClickHouseParser::UNION - 128))\n-        | (1ULL << (ClickHouseParser::UPDATE - 128))\n-        | (1ULL << (ClickHouseParser::USE - 128))\n-        | (1ULL << (ClickHouseParser::USING - 128))\n-        | (1ULL << (ClickHouseParser::UUID - 128))\n-        | (1ULL << (ClickHouseParser::VALUES - 128))\n-        | (1ULL << (ClickHouseParser::VIEW - 128))\n-        | (1ULL << (ClickHouseParser::VOLUME - 128))\n-        | (1ULL << (ClickHouseParser::WATCH - 128))\n-        | (1ULL << (ClickHouseParser::WEEK - 128))\n-        | (1ULL << (ClickHouseParser::WHEN - 128))\n-        | (1ULL << (ClickHouseParser::WHERE - 128))\n-        | (1ULL << (ClickHouseParser::WITH - 128))\n-        | (1ULL << (ClickHouseParser::YEAR - 128))\n-        | (1ULL << (ClickHouseParser::JSON_FALSE - 128))\n-        | (1ULL << (ClickHouseParser::JSON_TRUE - 128))\n-        | (1ULL << (ClickHouseParser::IDENTIFIER - 128)))) != 0)) {\n-        setState(1669);\n-        tableIdentifier();\n-        setState(1670);\n-        match(ClickHouseParser::DOT);\n-      }\n-      setState(1674);\n-      match(ClickHouseParser::ASTERISK);\n-      break;\n-    }\n-\n-    case 14: {\n-      _localctx = _tracker.createInstance<ColumnExprSubqueryContext>(_localctx);\n-      _ctx = _localctx;\n-      previousContext = _localctx;\n-      setState(1675);\n-      match(ClickHouseParser::LPAREN);\n-      setState(1676);\n-      selectUnionStmt();\n-      setState(1677);\n-      match(ClickHouseParser::RPAREN);\n-      break;\n-    }\n-\n-    case 15: {\n-      _localctx = _tracker.createInstance<ColumnExprParensContext>(_localctx);\n-      _ctx = _localctx;\n-      previousContext = _localctx;\n-      setState(1679);\n-      match(ClickHouseParser::LPAREN);\n-      setState(1680);\n-      columnExpr(0);\n-      setState(1681);\n-      match(ClickHouseParser::RPAREN);\n-      break;\n-    }\n-\n-    case 16: {\n-      _localctx = _tracker.createInstance<ColumnExprTupleContext>(_localctx);\n-      _ctx = _localctx;\n-      previousContext = _localctx;\n-      setState(1683);\n-      match(ClickHouseParser::LPAREN);\n-      setState(1684);\n-      columnExprList();\n-      setState(1685);\n-      match(ClickHouseParser::RPAREN);\n-      break;\n-    }\n-\n-    case 17: {\n-      _localctx = _tracker.createInstance<ColumnExprArrayContext>(_localctx);\n-      _ctx = _localctx;\n-      previousContext = _localctx;\n-      setState(1687);\n-      match(ClickHouseParser::LBRACKET);\n-      setState(1689);\n-      _errHandler->sync(this);\n-\n-      _la = _input->LA(1);\n-      if ((((_la & ~ 0x3fULL) == 0) &&\n-        ((1ULL << _la) & ((1ULL << ClickHouseParser::AFTER)\n-        | (1ULL << ClickHouseParser::ALIAS)\n-        | (1ULL << ClickHouseParser::ALL)\n-        | (1ULL << ClickHouseParser::ALTER)\n-        | (1ULL << ClickHouseParser::AND)\n-        | (1ULL << ClickHouseParser::ANTI)\n-        | (1ULL << ClickHouseParser::ANY)\n-        | (1ULL << ClickHouseParser::ARRAY)\n-        | (1ULL << ClickHouseParser::AS)\n-        | (1ULL << ClickHouseParser::ASCENDING)\n-        | (1ULL << ClickHouseParser::ASOF)\n-        | (1ULL << ClickHouseParser::AST)\n-        | (1ULL << ClickHouseParser::ASYNC)\n-        | (1ULL << ClickHouseParser::ATTACH)\n-        | (1ULL << ClickHouseParser::BETWEEN)\n-        | (1ULL << ClickHouseParser::BOTH)\n-        | (1ULL << ClickHouseParser::BY)\n-        | (1ULL << ClickHouseParser::CASE)\n-        | (1ULL << ClickHouseParser::CAST)\n-        | (1ULL << ClickHouseParser::CHECK)\n-        | (1ULL << ClickHouseParser::CLEAR)\n-        | (1ULL << ClickHouseParser::CLUSTER)\n-        | (1ULL << ClickHouseParser::CODEC)\n-        | (1ULL << ClickHouseParser::COLLATE)\n-        | (1ULL << ClickHouseParser::COLUMN)\n-        | (1ULL << ClickHouseParser::COMMENT)\n-        | (1ULL << ClickHouseParser::CONSTRAINT)\n-        | (1ULL << ClickHouseParser::CREATE)\n-        | (1ULL << ClickHouseParser::CROSS)\n-        | (1ULL << ClickHouseParser::CUBE)\n-        | (1ULL << ClickHouseParser::DATABASE)\n-        | (1ULL << ClickHouseParser::DATABASES)\n-        | (1ULL << ClickHouseParser::DATE)\n-        | (1ULL << ClickHouseParser::DAY)\n-        | (1ULL << ClickHouseParser::DEDUPLICATE)\n-        | (1ULL << ClickHouseParser::DEFAULT)\n-        | (1ULL << ClickHouseParser::DELAY)\n-        | (1ULL << ClickHouseParser::DELETE)\n-        | (1ULL << ClickHouseParser::DESC)\n-        | (1ULL << ClickHouseParser::DESCENDING)\n-        | (1ULL << ClickHouseParser::DESCRIBE)\n-        | (1ULL << ClickHouseParser::DETACH)\n-        | (1ULL << ClickHouseParser::DICTIONARIES)\n-        | (1ULL << ClickHouseParser::DICTIONARY)\n-        | (1ULL << ClickHouseParser::DISK)\n-        | (1ULL << ClickHouseParser::DISTINCT)\n-        | (1ULL << ClickHouseParser::DISTRIBUTED)\n-        | (1ULL << ClickHouseParser::DROP)\n-        | (1ULL << ClickHouseParser::ELSE)\n-        | (1ULL << ClickHouseParser::END)\n-        | (1ULL << ClickHouseParser::ENGINE)\n-        | (1ULL << ClickHouseParser::EVENTS)\n-        | (1ULL << ClickHouseParser::EXISTS)\n-        | (1ULL << ClickHouseParser::EXPLAIN)\n-        | (1ULL << ClickHouseParser::EXPRESSION)\n-        | (1ULL << ClickHouseParser::EXTRACT)\n-        | (1ULL << ClickHouseParser::FETCHES)\n-        | (1ULL << ClickHouseParser::FINAL)\n-        | (1ULL << ClickHouseParser::FIRST)\n-        | (1ULL << ClickHouseParser::FLUSH)\n-        | (1ULL << ClickHouseParser::FOR)\n-        | (1ULL << ClickHouseParser::FORMAT))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&\n-        ((1ULL << (_la - 64)) & ((1ULL << (ClickHouseParser::FREEZE - 64))\n-        | (1ULL << (ClickHouseParser::FROM - 64))\n-        | (1ULL << (ClickHouseParser::FULL - 64))\n-        | (1ULL << (ClickHouseParser::FUNCTION - 64))\n-        | (1ULL << (ClickHouseParser::GLOBAL - 64))\n-        | (1ULL << (ClickHouseParser::GRANULARITY - 64))\n-        | (1ULL << (ClickHouseParser::GROUP - 64))\n-        | (1ULL << (ClickHouseParser::HAVING - 64))\n-        | (1ULL << (ClickHouseParser::HIERARCHICAL - 64))\n-        | (1ULL << (ClickHouseParser::HOUR - 64))\n-        | (1ULL << (ClickHouseParser::ID - 64))\n-        | (1ULL << (ClickHouseParser::IF - 64))\n-        | (1ULL << (ClickHouseParser::ILIKE - 64))\n-        | (1ULL << (ClickHouseParser::IN - 64))\n-        | (1ULL << (ClickHouseParser::INDEX - 64))\n-        | (1ULL << (ClickHouseParser::INF - 64))\n-        | (1ULL << (ClickHouseParser::INJECTIVE - 64))\n-        | (1ULL << (ClickHouseParser::INNER - 64))\n-        | (1ULL << (ClickHouseParser::INSERT - 64))\n-        | (1ULL << (ClickHouseParser::INTERVAL - 64))\n-        | (1ULL << (ClickHouseParser::INTO - 64))\n-        | (1ULL << (ClickHouseParser::IS - 64))\n-        | (1ULL << (ClickHouseParser::IS_OBJECT_ID - 64))\n-        | (1ULL << (ClickHouseParser::JOIN - 64))\n-        | (1ULL << (ClickHouseParser::KEY - 64))\n-        | (1ULL << (ClickHouseParser::KILL - 64))\n-        | (1ULL << (ClickHouseParser::LAST - 64))\n-        | (1ULL << (ClickHouseParser::LAYOUT - 64))\n-        | (1ULL << (ClickHouseParser::LEADING - 64))\n-        | (1ULL << (ClickHouseParser::LEFT - 64))\n-        | (1ULL << (ClickHouseParser::LIFETIME - 64))\n-        | (1ULL << (ClickHouseParser::LIKE - 64))\n-        | (1ULL << (ClickHouseParser::LIMIT - 64))\n-        | (1ULL << (ClickHouseParser::LIVE - 64))\n-        | (1ULL << (ClickHouseParser::LOCAL - 64))\n-        | (1ULL << (ClickHouseParser::LOGS - 64))\n-        | (1ULL << (ClickHouseParser::MATERIALIZE - 64))\n-        | (1ULL << (ClickHouseParser::MATERIALIZED - 64))\n-        | (1ULL << (ClickHouseParser::MAX - 64))\n-        | (1ULL << (ClickHouseParser::MERGES - 64))\n-        | (1ULL << (ClickHouseParser::MIN - 64))\n-        | (1ULL << (ClickHouseParser::MINUTE - 64))\n-        | (1ULL << (ClickHouseParser::MODIFY - 64))\n-        | (1ULL << (ClickHouseParser::MONTH - 64))\n-        | (1ULL << (ClickHouseParser::MOVE - 64))\n-        | (1ULL << (ClickHouseParser::MUTATION - 64))\n-        | (1ULL << (ClickHouseParser::NAN_SQL - 64))\n-        | (1ULL << (ClickHouseParser::NO - 64))\n-        | (1ULL << (ClickHouseParser::NOT - 64))\n-        | (1ULL << (ClickHouseParser::NULL_SQL - 64))\n-        | (1ULL << (ClickHouseParser::NULLS - 64))\n-        | (1ULL << (ClickHouseParser::OFFSET - 64))\n-        | (1ULL << (ClickHouseParser::ON - 64))\n-        | (1ULL << (ClickHouseParser::OPTIMIZE - 64))\n-        | (1ULL << (ClickHouseParser::OR - 64))\n-        | (1ULL << (ClickHouseParser::ORDER - 64))\n-        | (1ULL << (ClickHouseParser::OUTER - 64))\n-        | (1ULL << (ClickHouseParser::OUTFILE - 64))\n-        | (1ULL << (ClickHouseParser::PARTITION - 64))\n-        | (1ULL << (ClickHouseParser::POPULATE - 64))\n-        | (1ULL << (ClickHouseParser::PREWHERE - 64))\n-        | (1ULL << (ClickHouseParser::PRIMARY - 64))\n-        | (1ULL << (ClickHouseParser::QUARTER - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&\n-        ((1ULL << (_la - 128)) & ((1ULL << (ClickHouseParser::RANGE - 128))\n-        | (1ULL << (ClickHouseParser::RELOAD - 128))\n-        | (1ULL << (ClickHouseParser::REMOVE - 128))\n-        | (1ULL << (ClickHouseParser::RENAME - 128))\n-        | (1ULL << (ClickHouseParser::REPLACE - 128))\n-        | (1ULL << (ClickHouseParser::REPLICA - 128))\n-        | (1ULL << (ClickHouseParser::REPLICATED - 128))\n-        | (1ULL << (ClickHouseParser::RIGHT - 128))\n-        | (1ULL << (ClickHouseParser::ROLLUP - 128))\n-        | (1ULL << (ClickHouseParser::SAMPLE - 128))\n-        | (1ULL << (ClickHouseParser::SECOND - 128))\n-        | (1ULL << (ClickHouseParser::SELECT - 128))\n-        | (1ULL << (ClickHouseParser::SEMI - 128))\n-        | (1ULL << (ClickHouseParser::SENDS - 128))\n-        | (1ULL << (ClickHouseParser::SET - 128))\n-        | (1ULL << (ClickHouseParser::SETTINGS - 128))\n-        | (1ULL << (ClickHouseParser::SHOW - 128))\n-        | (1ULL << (ClickHouseParser::SOURCE - 128))\n-        | (1ULL << (ClickHouseParser::START - 128))\n-        | (1ULL << (ClickHouseParser::STOP - 128))\n-        | (1ULL << (ClickHouseParser::SUBSTRING - 128))\n-        | (1ULL << (ClickHouseParser::SYNC - 128))\n-        | (1ULL << (ClickHouseParser::SYNTAX - 128))\n-        | (1ULL << (ClickHouseParser::SYSTEM - 128))\n-        | (1ULL << (ClickHouseParser::TABLE - 128))\n-        | (1ULL << (ClickHouseParser::TABLES - 128))\n-        | (1ULL << (ClickHouseParser::TEMPORARY - 128))\n-        | (1ULL << (ClickHouseParser::TEST - 128))\n-        | (1ULL << (ClickHouseParser::THEN - 128))\n-        | (1ULL << (ClickHouseParser::TIES - 128))\n-        | (1ULL << (ClickHouseParser::TIMEOUT - 128))\n-        | (1ULL << (ClickHouseParser::TIMESTAMP - 128))\n-        | (1ULL << (ClickHouseParser::TO - 128))\n-        | (1ULL << (ClickHouseParser::TOP - 128))\n-        | (1ULL << (ClickHouseParser::TOTALS - 128))\n-        | (1ULL << (ClickHouseParser::TRAILING - 128))\n-        | (1ULL << (ClickHouseParser::TRIM - 128))\n-        | (1ULL << (ClickHouseParser::TRUNCATE - 128))\n-        | (1ULL << (ClickHouseParser::TTL - 128))\n-        | (1ULL << (ClickHouseParser::TYPE - 128))\n-        | (1ULL << (ClickHouseParser::UNION - 128))\n-        | (1ULL << (ClickHouseParser::UPDATE - 128))\n-        | (1ULL << (ClickHouseParser::USE - 128))\n-        | (1ULL << (ClickHouseParser::USING - 128))\n-        | (1ULL << (ClickHouseParser::UUID - 128))\n-        | (1ULL << (ClickHouseParser::VALUES - 128))\n-        | (1ULL << (ClickHouseParser::VIEW - 128))\n-        | (1ULL << (ClickHouseParser::VOLUME - 128))\n-        | (1ULL << (ClickHouseParser::WATCH - 128))\n-        | (1ULL << (ClickHouseParser::WEEK - 128))\n-        | (1ULL << (ClickHouseParser::WHEN - 128))\n-        | (1ULL << (ClickHouseParser::WHERE - 128))\n-        | (1ULL << (ClickHouseParser::WITH - 128))\n-        | (1ULL << (ClickHouseParser::YEAR - 128))\n-        | (1ULL << (ClickHouseParser::JSON_FALSE - 128))\n-        | (1ULL << (ClickHouseParser::JSON_TRUE - 128))\n-        | (1ULL << (ClickHouseParser::IDENTIFIER - 128))\n-        | (1ULL << (ClickHouseParser::FLOATING_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::OCTAL_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::DECIMAL_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::HEXADECIMAL_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::STRING_LITERAL - 128))\n-        | (1ULL << (ClickHouseParser::ASTERISK - 128)))) != 0) || ((((_la - 197) & ~ 0x3fULL) == 0) &&\n-        ((1ULL << (_la - 197)) & ((1ULL << (ClickHouseParser::DASH - 197))\n-        | (1ULL << (ClickHouseParser::DOT - 197))\n-        | (1ULL << (ClickHouseParser::LBRACKET - 197))\n-        | (1ULL << (ClickHouseParser::LPAREN - 197))\n-        | (1ULL << (ClickHouseParser::PLUS - 197)))) != 0)) {\n-        setState(1688);\n-        columnExprList();\n-      }\n-      setState(1691);\n-      match(ClickHouseParser::RBRACKET);\n-      break;\n-    }\n-\n-    case 18: {\n-      _localctx = _tracker.createInstance<ColumnExprIdentifierContext>(_localctx);\n-      _ctx = _localctx;\n-      previousContext = _localctx;\n-      setState(1692);\n-      columnIdentifier();\n-      break;\n-    }\n-\n-    }\n-    _ctx->stop = _input->LT(-1);\n-    setState(1766);\n-    _errHandler->sync(this);\n-    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 234, _ctx);\n-    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {\n-      if (alt == 1) {\n-        if (!_parseListeners.empty())\n-          triggerExitRuleEvent();\n-        previousContext = _localctx;\n-        setState(1764);\n-        _errHandler->sync(this);\n-        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 233, _ctx)) {\n-        case 1: {\n-          auto newContext = _tracker.createInstance<ColumnExprPrecedence1Context>(_tracker.createInstance<ColumnExprContext>(parentContext, parentState));\n-          _localctx = newContext;\n-          pushNewRecursionContext(newContext, startState, RuleColumnExpr);\n-          setState(1695);\n-\n-          if (!(precpred(_ctx, 16))) throw FailedPredicateException(this, \"precpred(_ctx, 16)\");\n-          setState(1696);\n-          _la = _input->LA(1);\n-          if (!(((((_la - 191) & ~ 0x3fULL) == 0) &&\n-            ((1ULL << (_la - 191)) & ((1ULL << (ClickHouseParser::ASTERISK - 191))\n-            | (1ULL << (ClickHouseParser::PERCENT - 191))\n-            | (1ULL << (ClickHouseParser::SLASH - 191)))) != 0))) {\n-          _errHandler->recoverInline(this);\n-          }\n-          else {\n-            _errHandler->reportMatch(this);\n-            consume();\n-          }\n-          setState(1697);\n-          columnExpr(17);\n-          break;\n-        }\n-\n-        case 2: {\n-          auto newContext = _tracker.createInstance<ColumnExprPrecedence2Context>(_tracker.createInstance<ColumnExprContext>(parentContext, parentState));\n-          _localctx = newContext;\n-          pushNewRecursionContext(newContext, startState, RuleColumnExpr);\n-          setState(1698);\n-\n-          if (!(precpred(_ctx, 15))) throw FailedPredicateException(this, \"precpred(_ctx, 15)\");\n-          setState(1699);\n-          _la = _input->LA(1);\n-          if (!(((((_la - 196) & ~ 0x3fULL) == 0) &&\n-            ((1ULL << (_la - 196)) & ((1ULL << (ClickHouseParser::CONCAT - 196))\n-            | (1ULL << (ClickHouseParser::DASH - 196))\n-            | (1ULL << (ClickHouseParser::PLUS - 196)))) != 0))) {\n-          _errHandler->recoverInline(this);\n-          }\n-          else {\n-            _errHandler->reportMatch(this);\n-            consume();\n-          }\n-          setState(1700);\n-          columnExpr(16);\n-          break;\n-        }\n-\n-        case 3: {\n-          auto newContext = _tracker.createInstance<ColumnExprPrecedence3Context>(_tracker.createInstance<ColumnExprContext>(parentContext, parentState));\n-          _localctx = newContext;\n-          pushNewRecursionContext(newContext, startState, RuleColumnExpr);\n-          setState(1701);\n-\n-          if (!(precpred(_ctx, 14))) throw FailedPredicateException(this, \"precpred(_ctx, 14)\");\n-          setState(1720);\n-          _errHandler->sync(this);\n-          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 229, _ctx)) {\n-          case 1: {\n-            setState(1702);\n-            match(ClickHouseParser::EQ_DOUBLE);\n-            break;\n-          }\n-\n-          case 2: {\n-            setState(1703);\n-            match(ClickHouseParser::EQ_SINGLE);\n-            break;\n-          }\n-\n-          case 3: {\n-            setState(1704);\n-            match(ClickHouseParser::NOT_EQ);\n-            break;\n-          }\n-\n-          case 4: {\n-            setState(1705);\n-            match(ClickHouseParser::LE);\n-            break;\n-          }\n-\n-          case 5: {\n-            setState(1706);\n-            match(ClickHouseParser::GE);\n-            break;\n-          }\n-\n-          case 6: {\n-            setState(1707);\n-            match(ClickHouseParser::LT);\n-            break;\n-          }\n-\n-          case 7: {\n-            setState(1708);\n-            match(ClickHouseParser::GT);\n-            break;\n-          }\n-\n-          case 8: {\n-            setState(1710);\n-            _errHandler->sync(this);\n-\n-            _la = _input->LA(1);\n-            if (_la == ClickHouseParser::GLOBAL) {\n-              setState(1709);\n-              match(ClickHouseParser::GLOBAL);\n-            }\n-            setState(1713);\n-            _errHandler->sync(this);\n-\n-            _la = _input->LA(1);\n-            if (_la == ClickHouseParser::NOT) {\n-              setState(1712);\n-              match(ClickHouseParser::NOT);\n-            }\n-            setState(1715);\n-            match(ClickHouseParser::IN);\n-            break;\n-          }\n-\n-          case 9: {\n-            setState(1717);\n-            _errHandler->sync(this);\n-\n-            _la = _input->LA(1);\n-            if (_la == ClickHouseParser::NOT) {\n-              setState(1716);\n-              match(ClickHouseParser::NOT);\n-            }\n-            setState(1719);\n-            _la = _input->LA(1);\n-            if (!(_la == ClickHouseParser::ILIKE\n-\n-            || _la == ClickHouseParser::LIKE)) {\n-            _errHandler->recoverInline(this);\n-            }\n-            else {\n-              _errHandler->reportMatch(this);\n-              consume();\n-            }\n-            break;\n-          }\n-\n-          }\n-          setState(1722);\n-          columnExpr(15);\n-          break;\n-        }\n-\n-        case 4: {\n-          auto newContext = _tracker.createInstance<ColumnExprAndContext>(_tracker.createInstance<ColumnExprContext>(parentContext, parentState));\n-          _localctx = newContext;\n-          pushNewRecursionContext(newContext, startState, RuleColumnExpr);\n-          setState(1723);\n-\n-          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, \"precpred(_ctx, 11)\");\n-          setState(1724);\n-          match(ClickHouseParser::AND);\n-          setState(1725);\n-          columnExpr(12);\n-          break;\n-        }\n-\n-        case 5: {\n-          auto newContext = _tracker.createInstance<ColumnExprOrContext>(_tracker.createInstance<ColumnExprContext>(parentContext, parentState));\n-          _localctx = newContext;\n-          pushNewRecursionContext(newContext, startState, RuleColumnExpr);\n-          setState(1726);\n-\n-          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, \"precpred(_ctx, 10)\");\n-          setState(1727);\n-          match(ClickHouseParser::OR);\n-          setState(1728);\n-          columnExpr(11);\n-          break;\n-        }\n-\n-        case 6: {\n-          auto newContext = _tracker.createInstance<ColumnExprBetweenContext>(_tracker.createInstance<ColumnExprContext>(parentContext, parentState));\n-          _localctx = newContext;\n-          pushNewRecursionContext(newContext, startState, RuleColumnExpr);\n-          setState(1729);\n-\n-          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, \"precpred(_ctx, 9)\");\n-          setState(1731);\n-          _errHandler->sync(this);\n-\n-          _la = _input->LA(1);\n-          if (_la == ClickHouseParser::NOT) {\n-            setState(1730);\n-            match(ClickHouseParser::NOT);\n-          }\n-          setState(1733);\n-          match(ClickHouseParser::BETWEEN);\n-          setState(1734);\n-          columnExpr(0);\n-          setState(1735);\n-          match(ClickHouseParser::AND);\n-          setState(1736);\n-          columnExpr(10);\n-          break;\n-        }\n-\n-        case 7: {\n-          auto newContext = _tracker.createInstance<ColumnExprTernaryOpContext>(_tracker.createInstance<ColumnExprContext>(parentContext, parentState));\n-          _localctx = newContext;\n-          pushNewRecursionContext(newContext, startState, RuleColumnExpr);\n-          setState(1738);\n-\n-          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, \"precpred(_ctx, 8)\");\n-          setState(1739);\n-          match(ClickHouseParser::QUERY);\n-          setState(1740);\n-          columnExpr(0);\n-          setState(1741);\n-          match(ClickHouseParser::COLON);\n-          setState(1742);\n-          columnExpr(8);\n-          break;\n-        }\n-\n-        case 8: {\n-          auto newContext = _tracker.createInstance<ColumnExprArrayAccessContext>(_tracker.createInstance<ColumnExprContext>(parentContext, parentState));\n-          _localctx = newContext;\n-          pushNewRecursionContext(newContext, startState, RuleColumnExpr);\n-          setState(1744);\n-\n-          if (!(precpred(_ctx, 19))) throw FailedPredicateException(this, \"precpred(_ctx, 19)\");\n-          setState(1745);\n-          match(ClickHouseParser::LBRACKET);\n-          setState(1746);\n-          columnExpr(0);\n-          setState(1747);\n-          match(ClickHouseParser::RBRACKET);\n-          break;\n-        }\n-\n-        case 9: {\n-          auto newContext = _tracker.createInstance<ColumnExprTupleAccessContext>(_tracker.createInstance<ColumnExprContext>(parentContext, parentState));\n-          _localctx = newContext;\n-          pushNewRecursionContext(newContext, startState, RuleColumnExpr);\n-          setState(1749);\n-\n-          if (!(precpred(_ctx, 18))) throw FailedPredicateException(this, \"precpred(_ctx, 18)\");\n-          setState(1750);\n-          match(ClickHouseParser::DOT);\n-          setState(1751);\n-          match(ClickHouseParser::DECIMAL_LITERAL);\n-          break;\n-        }\n-\n-        case 10: {\n-          auto newContext = _tracker.createInstance<ColumnExprIsNullContext>(_tracker.createInstance<ColumnExprContext>(parentContext, parentState));\n-          _localctx = newContext;\n-          pushNewRecursionContext(newContext, startState, RuleColumnExpr);\n-          setState(1752);\n-\n-          if (!(precpred(_ctx, 13))) throw FailedPredicateException(this, \"precpred(_ctx, 13)\");\n-          setState(1753);\n-          match(ClickHouseParser::IS);\n-          setState(1755);\n-          _errHandler->sync(this);\n-\n-          _la = _input->LA(1);\n-          if (_la == ClickHouseParser::NOT) {\n-            setState(1754);\n-            match(ClickHouseParser::NOT);\n-          }\n-          setState(1757);\n-          match(ClickHouseParser::NULL_SQL);\n-          break;\n-        }\n-\n-        case 11: {\n-          auto newContext = _tracker.createInstance<ColumnExprAliasContext>(_tracker.createInstance<ColumnExprContext>(parentContext, parentState));\n-          _localctx = newContext;\n-          pushNewRecursionContext(newContext, startState, RuleColumnExpr);\n-          setState(1758);\n-\n-          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, \"precpred(_ctx, 7)\");\n-          setState(1762);\n-          _errHandler->sync(this);\n-          switch (_input->LA(1)) {\n-            case ClickHouseParser::DATE:\n-            case ClickHouseParser::FIRST:\n-            case ClickHouseParser::ID:\n-            case ClickHouseParser::KEY:\n-            case ClickHouseParser::IDENTIFIER: {\n-              setState(1759);\n-              alias();\n-              break;\n-            }\n-\n-            case ClickHouseParser::AS: {\n-              setState(1760);\n-              match(ClickHouseParser::AS);\n-              setState(1761);\n-              identifier();\n-              break;\n-            }\n-\n-          default:\n-            throw NoViableAltException(this);\n-          }\n-          break;\n-        }\n-\n-        } \n-      }\n-      setState(1768);\n-      _errHandler->sync(this);\n-      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 234, _ctx);\n-    }\n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-  return _localctx;\n-}\n-\n-//----------------- ColumnArgListContext ------------------------------------------------------------------\n-\n-ClickHouseParser::ColumnArgListContext::ColumnArgListContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-std::vector<ClickHouseParser::ColumnArgExprContext *> ClickHouseParser::ColumnArgListContext::columnArgExpr() {\n-  return getRuleContexts<ClickHouseParser::ColumnArgExprContext>();\n-}\n-\n-ClickHouseParser::ColumnArgExprContext* ClickHouseParser::ColumnArgListContext::columnArgExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::ColumnArgExprContext>(i);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::ColumnArgListContext::COMMA() {\n-  return getTokens(ClickHouseParser::COMMA);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnArgListContext::COMMA(size_t i) {\n-  return getToken(ClickHouseParser::COMMA, i);\n-}\n-\n-\n-size_t ClickHouseParser::ColumnArgListContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleColumnArgList;\n-}\n-\n-antlrcpp::Any ClickHouseParser::ColumnArgListContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnArgList(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::ColumnArgListContext* ClickHouseParser::columnArgList() {\n-  ColumnArgListContext *_localctx = _tracker.createInstance<ColumnArgListContext>(_ctx, getState());\n-  enterRule(_localctx, 176, ClickHouseParser::RuleColumnArgList);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1769);\n-    columnArgExpr();\n-    setState(1774);\n-    _errHandler->sync(this);\n-    _la = _input->LA(1);\n-    while (_la == ClickHouseParser::COMMA) {\n-      setState(1770);\n-      match(ClickHouseParser::COMMA);\n-      setState(1771);\n-      columnArgExpr();\n-      setState(1776);\n-      _errHandler->sync(this);\n-      _la = _input->LA(1);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- ColumnArgExprContext ------------------------------------------------------------------\n-\n-ClickHouseParser::ColumnArgExprContext::ColumnArgExprContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::ColumnLambdaExprContext* ClickHouseParser::ColumnArgExprContext::columnLambdaExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnLambdaExprContext>(0);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::ColumnArgExprContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::ColumnArgExprContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleColumnArgExpr;\n-}\n-\n-antlrcpp::Any ClickHouseParser::ColumnArgExprContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnArgExpr(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::ColumnArgExprContext* ClickHouseParser::columnArgExpr() {\n-  ColumnArgExprContext *_localctx = _tracker.createInstance<ColumnArgExprContext>(_ctx, getState());\n-  enterRule(_localctx, 178, ClickHouseParser::RuleColumnArgExpr);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(1779);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 236, _ctx)) {\n-    case 1: {\n-      enterOuterAlt(_localctx, 1);\n-      setState(1777);\n-      columnLambdaExpr();\n-      break;\n-    }\n-\n-    case 2: {\n-      enterOuterAlt(_localctx, 2);\n-      setState(1778);\n-      columnExpr(0);\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- ColumnLambdaExprContext ------------------------------------------------------------------\n-\n-ClickHouseParser::ColumnLambdaExprContext::ColumnLambdaExprContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnLambdaExprContext::ARROW() {\n-  return getToken(ClickHouseParser::ARROW, 0);\n-}\n-\n-ClickHouseParser::ColumnExprContext* ClickHouseParser::ColumnLambdaExprContext::columnExpr() {\n-  return getRuleContext<ClickHouseParser::ColumnExprContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnLambdaExprContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-std::vector<ClickHouseParser::IdentifierContext *> ClickHouseParser::ColumnLambdaExprContext::identifier() {\n-  return getRuleContexts<ClickHouseParser::IdentifierContext>();\n-}\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::ColumnLambdaExprContext::identifier(size_t i) {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnLambdaExprContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::ColumnLambdaExprContext::COMMA() {\n-  return getTokens(ClickHouseParser::COMMA);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnLambdaExprContext::COMMA(size_t i) {\n-  return getToken(ClickHouseParser::COMMA, i);\n-}\n-\n-\n-size_t ClickHouseParser::ColumnLambdaExprContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleColumnLambdaExpr;\n-}\n-\n-antlrcpp::Any ClickHouseParser::ColumnLambdaExprContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnLambdaExpr(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::ColumnLambdaExprContext* ClickHouseParser::columnLambdaExpr() {\n-  ColumnLambdaExprContext *_localctx = _tracker.createInstance<ColumnLambdaExprContext>(_ctx, getState());\n-  enterRule(_localctx, 180, ClickHouseParser::RuleColumnLambdaExpr);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1800);\n-    _errHandler->sync(this);\n-    switch (_input->LA(1)) {\n-      case ClickHouseParser::LPAREN: {\n-        setState(1781);\n-        match(ClickHouseParser::LPAREN);\n-        setState(1782);\n-        identifier();\n-        setState(1787);\n-        _errHandler->sync(this);\n-        _la = _input->LA(1);\n-        while (_la == ClickHouseParser::COMMA) {\n-          setState(1783);\n-          match(ClickHouseParser::COMMA);\n-          setState(1784);\n-          identifier();\n-          setState(1789);\n-          _errHandler->sync(this);\n-          _la = _input->LA(1);\n-        }\n-        setState(1790);\n-        match(ClickHouseParser::RPAREN);\n-        break;\n-      }\n-\n-      case ClickHouseParser::AFTER:\n-      case ClickHouseParser::ALIAS:\n-      case ClickHouseParser::ALL:\n-      case ClickHouseParser::ALTER:\n-      case ClickHouseParser::AND:\n-      case ClickHouseParser::ANTI:\n-      case ClickHouseParser::ANY:\n-      case ClickHouseParser::ARRAY:\n-      case ClickHouseParser::AS:\n-      case ClickHouseParser::ASCENDING:\n-      case ClickHouseParser::ASOF:\n-      case ClickHouseParser::AST:\n-      case ClickHouseParser::ASYNC:\n-      case ClickHouseParser::ATTACH:\n-      case ClickHouseParser::BETWEEN:\n-      case ClickHouseParser::BOTH:\n-      case ClickHouseParser::BY:\n-      case ClickHouseParser::CASE:\n-      case ClickHouseParser::CAST:\n-      case ClickHouseParser::CHECK:\n-      case ClickHouseParser::CLEAR:\n-      case ClickHouseParser::CLUSTER:\n-      case ClickHouseParser::CODEC:\n-      case ClickHouseParser::COLLATE:\n-      case ClickHouseParser::COLUMN:\n-      case ClickHouseParser::COMMENT:\n-      case ClickHouseParser::CONSTRAINT:\n-      case ClickHouseParser::CREATE:\n-      case ClickHouseParser::CROSS:\n-      case ClickHouseParser::CUBE:\n-      case ClickHouseParser::DATABASE:\n-      case ClickHouseParser::DATABASES:\n-      case ClickHouseParser::DATE:\n-      case ClickHouseParser::DAY:\n-      case ClickHouseParser::DEDUPLICATE:\n-      case ClickHouseParser::DEFAULT:\n-      case ClickHouseParser::DELAY:\n-      case ClickHouseParser::DELETE:\n-      case ClickHouseParser::DESC:\n-      case ClickHouseParser::DESCENDING:\n-      case ClickHouseParser::DESCRIBE:\n-      case ClickHouseParser::DETACH:\n-      case ClickHouseParser::DICTIONARIES:\n-      case ClickHouseParser::DICTIONARY:\n-      case ClickHouseParser::DISK:\n-      case ClickHouseParser::DISTINCT:\n-      case ClickHouseParser::DISTRIBUTED:\n-      case ClickHouseParser::DROP:\n-      case ClickHouseParser::ELSE:\n-      case ClickHouseParser::END:\n-      case ClickHouseParser::ENGINE:\n-      case ClickHouseParser::EVENTS:\n-      case ClickHouseParser::EXISTS:\n-      case ClickHouseParser::EXPLAIN:\n-      case ClickHouseParser::EXPRESSION:\n-      case ClickHouseParser::EXTRACT:\n-      case ClickHouseParser::FETCHES:\n-      case ClickHouseParser::FINAL:\n-      case ClickHouseParser::FIRST:\n-      case ClickHouseParser::FLUSH:\n-      case ClickHouseParser::FOR:\n-      case ClickHouseParser::FORMAT:\n-      case ClickHouseParser::FREEZE:\n-      case ClickHouseParser::FROM:\n-      case ClickHouseParser::FULL:\n-      case ClickHouseParser::FUNCTION:\n-      case ClickHouseParser::GLOBAL:\n-      case ClickHouseParser::GRANULARITY:\n-      case ClickHouseParser::GROUP:\n-      case ClickHouseParser::HAVING:\n-      case ClickHouseParser::HIERARCHICAL:\n-      case ClickHouseParser::HOUR:\n-      case ClickHouseParser::ID:\n-      case ClickHouseParser::IF:\n-      case ClickHouseParser::ILIKE:\n-      case ClickHouseParser::IN:\n-      case ClickHouseParser::INDEX:\n-      case ClickHouseParser::INJECTIVE:\n-      case ClickHouseParser::INNER:\n-      case ClickHouseParser::INSERT:\n-      case ClickHouseParser::INTERVAL:\n-      case ClickHouseParser::INTO:\n-      case ClickHouseParser::IS:\n-      case ClickHouseParser::IS_OBJECT_ID:\n-      case ClickHouseParser::JOIN:\n-      case ClickHouseParser::KEY:\n-      case ClickHouseParser::KILL:\n-      case ClickHouseParser::LAST:\n-      case ClickHouseParser::LAYOUT:\n-      case ClickHouseParser::LEADING:\n-      case ClickHouseParser::LEFT:\n-      case ClickHouseParser::LIFETIME:\n-      case ClickHouseParser::LIKE:\n-      case ClickHouseParser::LIMIT:\n-      case ClickHouseParser::LIVE:\n-      case ClickHouseParser::LOCAL:\n-      case ClickHouseParser::LOGS:\n-      case ClickHouseParser::MATERIALIZE:\n-      case ClickHouseParser::MATERIALIZED:\n-      case ClickHouseParser::MAX:\n-      case ClickHouseParser::MERGES:\n-      case ClickHouseParser::MIN:\n-      case ClickHouseParser::MINUTE:\n-      case ClickHouseParser::MODIFY:\n-      case ClickHouseParser::MONTH:\n-      case ClickHouseParser::MOVE:\n-      case ClickHouseParser::MUTATION:\n-      case ClickHouseParser::NO:\n-      case ClickHouseParser::NOT:\n-      case ClickHouseParser::NULLS:\n-      case ClickHouseParser::OFFSET:\n-      case ClickHouseParser::ON:\n-      case ClickHouseParser::OPTIMIZE:\n-      case ClickHouseParser::OR:\n-      case ClickHouseParser::ORDER:\n-      case ClickHouseParser::OUTER:\n-      case ClickHouseParser::OUTFILE:\n-      case ClickHouseParser::PARTITION:\n-      case ClickHouseParser::POPULATE:\n-      case ClickHouseParser::PREWHERE:\n-      case ClickHouseParser::PRIMARY:\n-      case ClickHouseParser::QUARTER:\n-      case ClickHouseParser::RANGE:\n-      case ClickHouseParser::RELOAD:\n-      case ClickHouseParser::REMOVE:\n-      case ClickHouseParser::RENAME:\n-      case ClickHouseParser::REPLACE:\n-      case ClickHouseParser::REPLICA:\n-      case ClickHouseParser::REPLICATED:\n-      case ClickHouseParser::RIGHT:\n-      case ClickHouseParser::ROLLUP:\n-      case ClickHouseParser::SAMPLE:\n-      case ClickHouseParser::SECOND:\n-      case ClickHouseParser::SELECT:\n-      case ClickHouseParser::SEMI:\n-      case ClickHouseParser::SENDS:\n-      case ClickHouseParser::SET:\n-      case ClickHouseParser::SETTINGS:\n-      case ClickHouseParser::SHOW:\n-      case ClickHouseParser::SOURCE:\n-      case ClickHouseParser::START:\n-      case ClickHouseParser::STOP:\n-      case ClickHouseParser::SUBSTRING:\n-      case ClickHouseParser::SYNC:\n-      case ClickHouseParser::SYNTAX:\n-      case ClickHouseParser::SYSTEM:\n-      case ClickHouseParser::TABLE:\n-      case ClickHouseParser::TABLES:\n-      case ClickHouseParser::TEMPORARY:\n-      case ClickHouseParser::TEST:\n-      case ClickHouseParser::THEN:\n-      case ClickHouseParser::TIES:\n-      case ClickHouseParser::TIMEOUT:\n-      case ClickHouseParser::TIMESTAMP:\n-      case ClickHouseParser::TO:\n-      case ClickHouseParser::TOP:\n-      case ClickHouseParser::TOTALS:\n-      case ClickHouseParser::TRAILING:\n-      case ClickHouseParser::TRIM:\n-      case ClickHouseParser::TRUNCATE:\n-      case ClickHouseParser::TTL:\n-      case ClickHouseParser::TYPE:\n-      case ClickHouseParser::UNION:\n-      case ClickHouseParser::UPDATE:\n-      case ClickHouseParser::USE:\n-      case ClickHouseParser::USING:\n-      case ClickHouseParser::UUID:\n-      case ClickHouseParser::VALUES:\n-      case ClickHouseParser::VIEW:\n-      case ClickHouseParser::VOLUME:\n-      case ClickHouseParser::WATCH:\n-      case ClickHouseParser::WEEK:\n-      case ClickHouseParser::WHEN:\n-      case ClickHouseParser::WHERE:\n-      case ClickHouseParser::WITH:\n-      case ClickHouseParser::YEAR:\n-      case ClickHouseParser::JSON_FALSE:\n-      case ClickHouseParser::JSON_TRUE:\n-      case ClickHouseParser::IDENTIFIER: {\n-        setState(1792);\n-        identifier();\n-        setState(1797);\n-        _errHandler->sync(this);\n-        _la = _input->LA(1);\n-        while (_la == ClickHouseParser::COMMA) {\n-          setState(1793);\n-          match(ClickHouseParser::COMMA);\n-          setState(1794);\n-          identifier();\n-          setState(1799);\n-          _errHandler->sync(this);\n-          _la = _input->LA(1);\n-        }\n-        break;\n-      }\n-\n-    default:\n-      throw NoViableAltException(this);\n-    }\n-    setState(1802);\n-    match(ClickHouseParser::ARROW);\n-    setState(1803);\n-    columnExpr(0);\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- ColumnIdentifierContext ------------------------------------------------------------------\n-\n-ClickHouseParser::ColumnIdentifierContext::ColumnIdentifierContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::ColumnIdentifierContext::nestedIdentifier() {\n-  return getRuleContext<ClickHouseParser::NestedIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::ColumnIdentifierContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::ColumnIdentifierContext::DOT() {\n-  return getToken(ClickHouseParser::DOT, 0);\n-}\n-\n-\n-size_t ClickHouseParser::ColumnIdentifierContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleColumnIdentifier;\n-}\n-\n-antlrcpp::Any ClickHouseParser::ColumnIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitColumnIdentifier(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::ColumnIdentifierContext* ClickHouseParser::columnIdentifier() {\n-  ColumnIdentifierContext *_localctx = _tracker.createInstance<ColumnIdentifierContext>(_ctx, getState());\n-  enterRule(_localctx, 182, ClickHouseParser::RuleColumnIdentifier);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1808);\n-    _errHandler->sync(this);\n-\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 240, _ctx)) {\n-    case 1: {\n-      setState(1805);\n-      tableIdentifier();\n-      setState(1806);\n-      match(ClickHouseParser::DOT);\n-      break;\n-    }\n-\n-    }\n-    setState(1810);\n-    nestedIdentifier();\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- NestedIdentifierContext ------------------------------------------------------------------\n-\n-ClickHouseParser::NestedIdentifierContext::NestedIdentifierContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-std::vector<ClickHouseParser::IdentifierContext *> ClickHouseParser::NestedIdentifierContext::identifier() {\n-  return getRuleContexts<ClickHouseParser::IdentifierContext>();\n-}\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::NestedIdentifierContext::identifier(size_t i) {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::NestedIdentifierContext::DOT() {\n-  return getToken(ClickHouseParser::DOT, 0);\n-}\n-\n-\n-size_t ClickHouseParser::NestedIdentifierContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleNestedIdentifier;\n-}\n-\n-antlrcpp::Any ClickHouseParser::NestedIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitNestedIdentifier(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::nestedIdentifier() {\n-  NestedIdentifierContext *_localctx = _tracker.createInstance<NestedIdentifierContext>(_ctx, getState());\n-  enterRule(_localctx, 184, ClickHouseParser::RuleNestedIdentifier);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1812);\n-    identifier();\n-    setState(1815);\n-    _errHandler->sync(this);\n-\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 241, _ctx)) {\n-    case 1: {\n-      setState(1813);\n-      match(ClickHouseParser::DOT);\n-      setState(1814);\n-      identifier();\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- TableExprContext ------------------------------------------------------------------\n-\n-ClickHouseParser::TableExprContext::TableExprContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-\n-size_t ClickHouseParser::TableExprContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleTableExpr;\n-}\n-\n-void ClickHouseParser::TableExprContext::copyFrom(TableExprContext *ctx) {\n-  ParserRuleContext::copyFrom(ctx);\n-}\n-\n-//----------------- TableExprIdentifierContext ------------------------------------------------------------------\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::TableExprIdentifierContext::tableIdentifier() {\n-  return getRuleContext<ClickHouseParser::TableIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::TableExprIdentifierContext::TableExprIdentifierContext(TableExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::TableExprIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitTableExprIdentifier(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- TableExprSubqueryContext ------------------------------------------------------------------\n-\n-tree::TerminalNode* ClickHouseParser::TableExprSubqueryContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-ClickHouseParser::SelectUnionStmtContext* ClickHouseParser::TableExprSubqueryContext::selectUnionStmt() {\n-  return getRuleContext<ClickHouseParser::SelectUnionStmtContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TableExprSubqueryContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-ClickHouseParser::TableExprSubqueryContext::TableExprSubqueryContext(TableExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::TableExprSubqueryContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitTableExprSubquery(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- TableExprAliasContext ------------------------------------------------------------------\n-\n-ClickHouseParser::TableExprContext* ClickHouseParser::TableExprAliasContext::tableExpr() {\n-  return getRuleContext<ClickHouseParser::TableExprContext>(0);\n-}\n-\n-ClickHouseParser::AliasContext* ClickHouseParser::TableExprAliasContext::alias() {\n-  return getRuleContext<ClickHouseParser::AliasContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TableExprAliasContext::AS() {\n-  return getToken(ClickHouseParser::AS, 0);\n-}\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::TableExprAliasContext::identifier() {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(0);\n-}\n-\n-ClickHouseParser::TableExprAliasContext::TableExprAliasContext(TableExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::TableExprAliasContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitTableExprAlias(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-//----------------- TableExprFunctionContext ------------------------------------------------------------------\n-\n-ClickHouseParser::TableFunctionExprContext* ClickHouseParser::TableExprFunctionContext::tableFunctionExpr() {\n-  return getRuleContext<ClickHouseParser::TableFunctionExprContext>(0);\n-}\n-\n-ClickHouseParser::TableExprFunctionContext::TableExprFunctionContext(TableExprContext *ctx) { copyFrom(ctx); }\n-\n-antlrcpp::Any ClickHouseParser::TableExprFunctionContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitTableExprFunction(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::TableExprContext* ClickHouseParser::tableExpr() {\n-   return tableExpr(0);\n-}\n-\n-ClickHouseParser::TableExprContext* ClickHouseParser::tableExpr(int precedence) {\n-  ParserRuleContext *parentContext = _ctx;\n-  size_t parentState = getState();\n-  ClickHouseParser::TableExprContext *_localctx = _tracker.createInstance<TableExprContext>(_ctx, parentState);\n-  ClickHouseParser::TableExprContext *previousContext = _localctx;\n-  (void)previousContext; // Silence compiler, in case the context is not used by generated code.\n-  size_t startState = 186;\n-  enterRecursionRule(_localctx, 186, ClickHouseParser::RuleTableExpr, precedence);\n-\n-    \n-\n-  auto onExit = finally([=] {\n-    unrollRecursionContexts(parentContext);\n-  });\n-  try {\n-    size_t alt;\n-    enterOuterAlt(_localctx, 1);\n-    setState(1824);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx)) {\n-    case 1: {\n-      _localctx = _tracker.createInstance<TableExprIdentifierContext>(_localctx);\n-      _ctx = _localctx;\n-      previousContext = _localctx;\n-\n-      setState(1818);\n-      tableIdentifier();\n-      break;\n-    }\n-\n-    case 2: {\n-      _localctx = _tracker.createInstance<TableExprFunctionContext>(_localctx);\n-      _ctx = _localctx;\n-      previousContext = _localctx;\n-      setState(1819);\n-      tableFunctionExpr();\n-      break;\n-    }\n-\n-    case 3: {\n-      _localctx = _tracker.createInstance<TableExprSubqueryContext>(_localctx);\n-      _ctx = _localctx;\n-      previousContext = _localctx;\n-      setState(1820);\n-      match(ClickHouseParser::LPAREN);\n-      setState(1821);\n-      selectUnionStmt();\n-      setState(1822);\n-      match(ClickHouseParser::RPAREN);\n-      break;\n-    }\n-\n-    }\n-    _ctx->stop = _input->LT(-1);\n-    setState(1834);\n-    _errHandler->sync(this);\n-    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 244, _ctx);\n-    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {\n-      if (alt == 1) {\n-        if (!_parseListeners.empty())\n-          triggerExitRuleEvent();\n-        previousContext = _localctx;\n-        auto newContext = _tracker.createInstance<TableExprAliasContext>(_tracker.createInstance<TableExprContext>(parentContext, parentState));\n-        _localctx = newContext;\n-        pushNewRecursionContext(newContext, startState, RuleTableExpr);\n-        setState(1826);\n-\n-        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, \"precpred(_ctx, 1)\");\n-        setState(1830);\n-        _errHandler->sync(this);\n-        switch (_input->LA(1)) {\n-          case ClickHouseParser::DATE:\n-          case ClickHouseParser::FIRST:\n-          case ClickHouseParser::ID:\n-          case ClickHouseParser::KEY:\n-          case ClickHouseParser::IDENTIFIER: {\n-            setState(1827);\n-            alias();\n-            break;\n-          }\n-\n-          case ClickHouseParser::AS: {\n-            setState(1828);\n-            match(ClickHouseParser::AS);\n-            setState(1829);\n-            identifier();\n-            break;\n-          }\n-\n-        default:\n-          throw NoViableAltException(this);\n-        } \n-      }\n-      setState(1836);\n-      _errHandler->sync(this);\n-      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 244, _ctx);\n-    }\n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-  return _localctx;\n-}\n-\n-//----------------- TableFunctionExprContext ------------------------------------------------------------------\n-\n-ClickHouseParser::TableFunctionExprContext::TableFunctionExprContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::TableFunctionExprContext::identifier() {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TableFunctionExprContext::LPAREN() {\n-  return getToken(ClickHouseParser::LPAREN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TableFunctionExprContext::RPAREN() {\n-  return getToken(ClickHouseParser::RPAREN, 0);\n-}\n-\n-ClickHouseParser::TableArgListContext* ClickHouseParser::TableFunctionExprContext::tableArgList() {\n-  return getRuleContext<ClickHouseParser::TableArgListContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::TableFunctionExprContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleTableFunctionExpr;\n-}\n-\n-antlrcpp::Any ClickHouseParser::TableFunctionExprContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitTableFunctionExpr(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::TableFunctionExprContext* ClickHouseParser::tableFunctionExpr() {\n-  TableFunctionExprContext *_localctx = _tracker.createInstance<TableFunctionExprContext>(_ctx, getState());\n-  enterRule(_localctx, 188, ClickHouseParser::RuleTableFunctionExpr);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1837);\n-    identifier();\n-    setState(1838);\n-    match(ClickHouseParser::LPAREN);\n-    setState(1840);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if ((((_la & ~ 0x3fULL) == 0) &&\n-      ((1ULL << _la) & ((1ULL << ClickHouseParser::AFTER)\n-      | (1ULL << ClickHouseParser::ALIAS)\n-      | (1ULL << ClickHouseParser::ALL)\n-      | (1ULL << ClickHouseParser::ALTER)\n-      | (1ULL << ClickHouseParser::AND)\n-      | (1ULL << ClickHouseParser::ANTI)\n-      | (1ULL << ClickHouseParser::ANY)\n-      | (1ULL << ClickHouseParser::ARRAY)\n-      | (1ULL << ClickHouseParser::AS)\n-      | (1ULL << ClickHouseParser::ASCENDING)\n-      | (1ULL << ClickHouseParser::ASOF)\n-      | (1ULL << ClickHouseParser::AST)\n-      | (1ULL << ClickHouseParser::ASYNC)\n-      | (1ULL << ClickHouseParser::ATTACH)\n-      | (1ULL << ClickHouseParser::BETWEEN)\n-      | (1ULL << ClickHouseParser::BOTH)\n-      | (1ULL << ClickHouseParser::BY)\n-      | (1ULL << ClickHouseParser::CASE)\n-      | (1ULL << ClickHouseParser::CAST)\n-      | (1ULL << ClickHouseParser::CHECK)\n-      | (1ULL << ClickHouseParser::CLEAR)\n-      | (1ULL << ClickHouseParser::CLUSTER)\n-      | (1ULL << ClickHouseParser::CODEC)\n-      | (1ULL << ClickHouseParser::COLLATE)\n-      | (1ULL << ClickHouseParser::COLUMN)\n-      | (1ULL << ClickHouseParser::COMMENT)\n-      | (1ULL << ClickHouseParser::CONSTRAINT)\n-      | (1ULL << ClickHouseParser::CREATE)\n-      | (1ULL << ClickHouseParser::CROSS)\n-      | (1ULL << ClickHouseParser::CUBE)\n-      | (1ULL << ClickHouseParser::DATABASE)\n-      | (1ULL << ClickHouseParser::DATABASES)\n-      | (1ULL << ClickHouseParser::DATE)\n-      | (1ULL << ClickHouseParser::DAY)\n-      | (1ULL << ClickHouseParser::DEDUPLICATE)\n-      | (1ULL << ClickHouseParser::DEFAULT)\n-      | (1ULL << ClickHouseParser::DELAY)\n-      | (1ULL << ClickHouseParser::DELETE)\n-      | (1ULL << ClickHouseParser::DESC)\n-      | (1ULL << ClickHouseParser::DESCENDING)\n-      | (1ULL << ClickHouseParser::DESCRIBE)\n-      | (1ULL << ClickHouseParser::DETACH)\n-      | (1ULL << ClickHouseParser::DICTIONARIES)\n-      | (1ULL << ClickHouseParser::DICTIONARY)\n-      | (1ULL << ClickHouseParser::DISK)\n-      | (1ULL << ClickHouseParser::DISTINCT)\n-      | (1ULL << ClickHouseParser::DISTRIBUTED)\n-      | (1ULL << ClickHouseParser::DROP)\n-      | (1ULL << ClickHouseParser::ELSE)\n-      | (1ULL << ClickHouseParser::END)\n-      | (1ULL << ClickHouseParser::ENGINE)\n-      | (1ULL << ClickHouseParser::EVENTS)\n-      | (1ULL << ClickHouseParser::EXISTS)\n-      | (1ULL << ClickHouseParser::EXPLAIN)\n-      | (1ULL << ClickHouseParser::EXPRESSION)\n-      | (1ULL << ClickHouseParser::EXTRACT)\n-      | (1ULL << ClickHouseParser::FETCHES)\n-      | (1ULL << ClickHouseParser::FINAL)\n-      | (1ULL << ClickHouseParser::FIRST)\n-      | (1ULL << ClickHouseParser::FLUSH)\n-      | (1ULL << ClickHouseParser::FOR)\n-      | (1ULL << ClickHouseParser::FORMAT))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&\n-      ((1ULL << (_la - 64)) & ((1ULL << (ClickHouseParser::FREEZE - 64))\n-      | (1ULL << (ClickHouseParser::FROM - 64))\n-      | (1ULL << (ClickHouseParser::FULL - 64))\n-      | (1ULL << (ClickHouseParser::FUNCTION - 64))\n-      | (1ULL << (ClickHouseParser::GLOBAL - 64))\n-      | (1ULL << (ClickHouseParser::GRANULARITY - 64))\n-      | (1ULL << (ClickHouseParser::GROUP - 64))\n-      | (1ULL << (ClickHouseParser::HAVING - 64))\n-      | (1ULL << (ClickHouseParser::HIERARCHICAL - 64))\n-      | (1ULL << (ClickHouseParser::HOUR - 64))\n-      | (1ULL << (ClickHouseParser::ID - 64))\n-      | (1ULL << (ClickHouseParser::IF - 64))\n-      | (1ULL << (ClickHouseParser::ILIKE - 64))\n-      | (1ULL << (ClickHouseParser::IN - 64))\n-      | (1ULL << (ClickHouseParser::INDEX - 64))\n-      | (1ULL << (ClickHouseParser::INF - 64))\n-      | (1ULL << (ClickHouseParser::INJECTIVE - 64))\n-      | (1ULL << (ClickHouseParser::INNER - 64))\n-      | (1ULL << (ClickHouseParser::INSERT - 64))\n-      | (1ULL << (ClickHouseParser::INTERVAL - 64))\n-      | (1ULL << (ClickHouseParser::INTO - 64))\n-      | (1ULL << (ClickHouseParser::IS - 64))\n-      | (1ULL << (ClickHouseParser::IS_OBJECT_ID - 64))\n-      | (1ULL << (ClickHouseParser::JOIN - 64))\n-      | (1ULL << (ClickHouseParser::KEY - 64))\n-      | (1ULL << (ClickHouseParser::KILL - 64))\n-      | (1ULL << (ClickHouseParser::LAST - 64))\n-      | (1ULL << (ClickHouseParser::LAYOUT - 64))\n-      | (1ULL << (ClickHouseParser::LEADING - 64))\n-      | (1ULL << (ClickHouseParser::LEFT - 64))\n-      | (1ULL << (ClickHouseParser::LIFETIME - 64))\n-      | (1ULL << (ClickHouseParser::LIKE - 64))\n-      | (1ULL << (ClickHouseParser::LIMIT - 64))\n-      | (1ULL << (ClickHouseParser::LIVE - 64))\n-      | (1ULL << (ClickHouseParser::LOCAL - 64))\n-      | (1ULL << (ClickHouseParser::LOGS - 64))\n-      | (1ULL << (ClickHouseParser::MATERIALIZE - 64))\n-      | (1ULL << (ClickHouseParser::MATERIALIZED - 64))\n-      | (1ULL << (ClickHouseParser::MAX - 64))\n-      | (1ULL << (ClickHouseParser::MERGES - 64))\n-      | (1ULL << (ClickHouseParser::MIN - 64))\n-      | (1ULL << (ClickHouseParser::MINUTE - 64))\n-      | (1ULL << (ClickHouseParser::MODIFY - 64))\n-      | (1ULL << (ClickHouseParser::MONTH - 64))\n-      | (1ULL << (ClickHouseParser::MOVE - 64))\n-      | (1ULL << (ClickHouseParser::MUTATION - 64))\n-      | (1ULL << (ClickHouseParser::NAN_SQL - 64))\n-      | (1ULL << (ClickHouseParser::NO - 64))\n-      | (1ULL << (ClickHouseParser::NOT - 64))\n-      | (1ULL << (ClickHouseParser::NULL_SQL - 64))\n-      | (1ULL << (ClickHouseParser::NULLS - 64))\n-      | (1ULL << (ClickHouseParser::OFFSET - 64))\n-      | (1ULL << (ClickHouseParser::ON - 64))\n-      | (1ULL << (ClickHouseParser::OPTIMIZE - 64))\n-      | (1ULL << (ClickHouseParser::OR - 64))\n-      | (1ULL << (ClickHouseParser::ORDER - 64))\n-      | (1ULL << (ClickHouseParser::OUTER - 64))\n-      | (1ULL << (ClickHouseParser::OUTFILE - 64))\n-      | (1ULL << (ClickHouseParser::PARTITION - 64))\n-      | (1ULL << (ClickHouseParser::POPULATE - 64))\n-      | (1ULL << (ClickHouseParser::PREWHERE - 64))\n-      | (1ULL << (ClickHouseParser::PRIMARY - 64))\n-      | (1ULL << (ClickHouseParser::QUARTER - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&\n-      ((1ULL << (_la - 128)) & ((1ULL << (ClickHouseParser::RANGE - 128))\n-      | (1ULL << (ClickHouseParser::RELOAD - 128))\n-      | (1ULL << (ClickHouseParser::REMOVE - 128))\n-      | (1ULL << (ClickHouseParser::RENAME - 128))\n-      | (1ULL << (ClickHouseParser::REPLACE - 128))\n-      | (1ULL << (ClickHouseParser::REPLICA - 128))\n-      | (1ULL << (ClickHouseParser::REPLICATED - 128))\n-      | (1ULL << (ClickHouseParser::RIGHT - 128))\n-      | (1ULL << (ClickHouseParser::ROLLUP - 128))\n-      | (1ULL << (ClickHouseParser::SAMPLE - 128))\n-      | (1ULL << (ClickHouseParser::SECOND - 128))\n-      | (1ULL << (ClickHouseParser::SELECT - 128))\n-      | (1ULL << (ClickHouseParser::SEMI - 128))\n-      | (1ULL << (ClickHouseParser::SENDS - 128))\n-      | (1ULL << (ClickHouseParser::SET - 128))\n-      | (1ULL << (ClickHouseParser::SETTINGS - 128))\n-      | (1ULL << (ClickHouseParser::SHOW - 128))\n-      | (1ULL << (ClickHouseParser::SOURCE - 128))\n-      | (1ULL << (ClickHouseParser::START - 128))\n-      | (1ULL << (ClickHouseParser::STOP - 128))\n-      | (1ULL << (ClickHouseParser::SUBSTRING - 128))\n-      | (1ULL << (ClickHouseParser::SYNC - 128))\n-      | (1ULL << (ClickHouseParser::SYNTAX - 128))\n-      | (1ULL << (ClickHouseParser::SYSTEM - 128))\n-      | (1ULL << (ClickHouseParser::TABLE - 128))\n-      | (1ULL << (ClickHouseParser::TABLES - 128))\n-      | (1ULL << (ClickHouseParser::TEMPORARY - 128))\n-      | (1ULL << (ClickHouseParser::TEST - 128))\n-      | (1ULL << (ClickHouseParser::THEN - 128))\n-      | (1ULL << (ClickHouseParser::TIES - 128))\n-      | (1ULL << (ClickHouseParser::TIMEOUT - 128))\n-      | (1ULL << (ClickHouseParser::TIMESTAMP - 128))\n-      | (1ULL << (ClickHouseParser::TO - 128))\n-      | (1ULL << (ClickHouseParser::TOP - 128))\n-      | (1ULL << (ClickHouseParser::TOTALS - 128))\n-      | (1ULL << (ClickHouseParser::TRAILING - 128))\n-      | (1ULL << (ClickHouseParser::TRIM - 128))\n-      | (1ULL << (ClickHouseParser::TRUNCATE - 128))\n-      | (1ULL << (ClickHouseParser::TTL - 128))\n-      | (1ULL << (ClickHouseParser::TYPE - 128))\n-      | (1ULL << (ClickHouseParser::UNION - 128))\n-      | (1ULL << (ClickHouseParser::UPDATE - 128))\n-      | (1ULL << (ClickHouseParser::USE - 128))\n-      | (1ULL << (ClickHouseParser::USING - 128))\n-      | (1ULL << (ClickHouseParser::UUID - 128))\n-      | (1ULL << (ClickHouseParser::VALUES - 128))\n-      | (1ULL << (ClickHouseParser::VIEW - 128))\n-      | (1ULL << (ClickHouseParser::VOLUME - 128))\n-      | (1ULL << (ClickHouseParser::WATCH - 128))\n-      | (1ULL << (ClickHouseParser::WEEK - 128))\n-      | (1ULL << (ClickHouseParser::WHEN - 128))\n-      | (1ULL << (ClickHouseParser::WHERE - 128))\n-      | (1ULL << (ClickHouseParser::WITH - 128))\n-      | (1ULL << (ClickHouseParser::YEAR - 128))\n-      | (1ULL << (ClickHouseParser::JSON_FALSE - 128))\n-      | (1ULL << (ClickHouseParser::JSON_TRUE - 128))\n-      | (1ULL << (ClickHouseParser::IDENTIFIER - 128))\n-      | (1ULL << (ClickHouseParser::FLOATING_LITERAL - 128))\n-      | (1ULL << (ClickHouseParser::OCTAL_LITERAL - 128))\n-      | (1ULL << (ClickHouseParser::DECIMAL_LITERAL - 128))\n-      | (1ULL << (ClickHouseParser::HEXADECIMAL_LITERAL - 128))\n-      | (1ULL << (ClickHouseParser::STRING_LITERAL - 128)))) != 0) || ((((_la - 197) & ~ 0x3fULL) == 0) &&\n-      ((1ULL << (_la - 197)) & ((1ULL << (ClickHouseParser::DASH - 197))\n-      | (1ULL << (ClickHouseParser::DOT - 197))\n-      | (1ULL << (ClickHouseParser::PLUS - 197)))) != 0)) {\n-      setState(1839);\n-      tableArgList();\n-    }\n-    setState(1842);\n-    match(ClickHouseParser::RPAREN);\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- TableIdentifierContext ------------------------------------------------------------------\n-\n-ClickHouseParser::TableIdentifierContext::TableIdentifierContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::TableIdentifierContext::identifier() {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(0);\n-}\n-\n-ClickHouseParser::DatabaseIdentifierContext* ClickHouseParser::TableIdentifierContext::databaseIdentifier() {\n-  return getRuleContext<ClickHouseParser::DatabaseIdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TableIdentifierContext::DOT() {\n-  return getToken(ClickHouseParser::DOT, 0);\n-}\n-\n-\n-size_t ClickHouseParser::TableIdentifierContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleTableIdentifier;\n-}\n-\n-antlrcpp::Any ClickHouseParser::TableIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitTableIdentifier(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::TableIdentifierContext* ClickHouseParser::tableIdentifier() {\n-  TableIdentifierContext *_localctx = _tracker.createInstance<TableIdentifierContext>(_ctx, getState());\n-  enterRule(_localctx, 190, ClickHouseParser::RuleTableIdentifier);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1847);\n-    _errHandler->sync(this);\n-\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 246, _ctx)) {\n-    case 1: {\n-      setState(1844);\n-      databaseIdentifier();\n-      setState(1845);\n-      match(ClickHouseParser::DOT);\n-      break;\n-    }\n-\n-    }\n-    setState(1849);\n-    identifier();\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- TableArgListContext ------------------------------------------------------------------\n-\n-ClickHouseParser::TableArgListContext::TableArgListContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-std::vector<ClickHouseParser::TableArgExprContext *> ClickHouseParser::TableArgListContext::tableArgExpr() {\n-  return getRuleContexts<ClickHouseParser::TableArgExprContext>();\n-}\n-\n-ClickHouseParser::TableArgExprContext* ClickHouseParser::TableArgListContext::tableArgExpr(size_t i) {\n-  return getRuleContext<ClickHouseParser::TableArgExprContext>(i);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::TableArgListContext::COMMA() {\n-  return getTokens(ClickHouseParser::COMMA);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::TableArgListContext::COMMA(size_t i) {\n-  return getToken(ClickHouseParser::COMMA, i);\n-}\n-\n-\n-size_t ClickHouseParser::TableArgListContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleTableArgList;\n-}\n-\n-antlrcpp::Any ClickHouseParser::TableArgListContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitTableArgList(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::TableArgListContext* ClickHouseParser::tableArgList() {\n-  TableArgListContext *_localctx = _tracker.createInstance<TableArgListContext>(_ctx, getState());\n-  enterRule(_localctx, 192, ClickHouseParser::RuleTableArgList);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1851);\n-    tableArgExpr();\n-    setState(1856);\n-    _errHandler->sync(this);\n-    _la = _input->LA(1);\n-    while (_la == ClickHouseParser::COMMA) {\n-      setState(1852);\n-      match(ClickHouseParser::COMMA);\n-      setState(1853);\n-      tableArgExpr();\n-      setState(1858);\n-      _errHandler->sync(this);\n-      _la = _input->LA(1);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- TableArgExprContext ------------------------------------------------------------------\n-\n-ClickHouseParser::TableArgExprContext::TableArgExprContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::NestedIdentifierContext* ClickHouseParser::TableArgExprContext::nestedIdentifier() {\n-  return getRuleContext<ClickHouseParser::NestedIdentifierContext>(0);\n-}\n-\n-ClickHouseParser::TableFunctionExprContext* ClickHouseParser::TableArgExprContext::tableFunctionExpr() {\n-  return getRuleContext<ClickHouseParser::TableFunctionExprContext>(0);\n-}\n-\n-ClickHouseParser::LiteralContext* ClickHouseParser::TableArgExprContext::literal() {\n-  return getRuleContext<ClickHouseParser::LiteralContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::TableArgExprContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleTableArgExpr;\n-}\n-\n-antlrcpp::Any ClickHouseParser::TableArgExprContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitTableArgExpr(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::TableArgExprContext* ClickHouseParser::tableArgExpr() {\n-  TableArgExprContext *_localctx = _tracker.createInstance<TableArgExprContext>(_ctx, getState());\n-  enterRule(_localctx, 194, ClickHouseParser::RuleTableArgExpr);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(1862);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 248, _ctx)) {\n-    case 1: {\n-      enterOuterAlt(_localctx, 1);\n-      setState(1859);\n-      nestedIdentifier();\n-      break;\n-    }\n-\n-    case 2: {\n-      enterOuterAlt(_localctx, 2);\n-      setState(1860);\n-      tableFunctionExpr();\n-      break;\n-    }\n-\n-    case 3: {\n-      enterOuterAlt(_localctx, 3);\n-      setState(1861);\n-      literal();\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- DatabaseIdentifierContext ------------------------------------------------------------------\n-\n-ClickHouseParser::DatabaseIdentifierContext::DatabaseIdentifierContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::DatabaseIdentifierContext::identifier() {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::DatabaseIdentifierContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleDatabaseIdentifier;\n-}\n-\n-antlrcpp::Any ClickHouseParser::DatabaseIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitDatabaseIdentifier(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::DatabaseIdentifierContext* ClickHouseParser::databaseIdentifier() {\n-  DatabaseIdentifierContext *_localctx = _tracker.createInstance<DatabaseIdentifierContext>(_ctx, getState());\n-  enterRule(_localctx, 196, ClickHouseParser::RuleDatabaseIdentifier);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1864);\n-    identifier();\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- FloatingLiteralContext ------------------------------------------------------------------\n-\n-ClickHouseParser::FloatingLiteralContext::FloatingLiteralContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::FloatingLiteralContext::FLOATING_LITERAL() {\n-  return getToken(ClickHouseParser::FLOATING_LITERAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::FloatingLiteralContext::DOT() {\n-  return getToken(ClickHouseParser::DOT, 0);\n-}\n-\n-std::vector<tree::TerminalNode *> ClickHouseParser::FloatingLiteralContext::DECIMAL_LITERAL() {\n-  return getTokens(ClickHouseParser::DECIMAL_LITERAL);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::FloatingLiteralContext::DECIMAL_LITERAL(size_t i) {\n-  return getToken(ClickHouseParser::DECIMAL_LITERAL, i);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::FloatingLiteralContext::OCTAL_LITERAL() {\n-  return getToken(ClickHouseParser::OCTAL_LITERAL, 0);\n-}\n-\n-\n-size_t ClickHouseParser::FloatingLiteralContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleFloatingLiteral;\n-}\n-\n-antlrcpp::Any ClickHouseParser::FloatingLiteralContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitFloatingLiteral(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::FloatingLiteralContext* ClickHouseParser::floatingLiteral() {\n-  FloatingLiteralContext *_localctx = _tracker.createInstance<FloatingLiteralContext>(_ctx, getState());\n-  enterRule(_localctx, 198, ClickHouseParser::RuleFloatingLiteral);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(1874);\n-    _errHandler->sync(this);\n-    switch (_input->LA(1)) {\n-      case ClickHouseParser::FLOATING_LITERAL: {\n-        enterOuterAlt(_localctx, 1);\n-        setState(1866);\n-        match(ClickHouseParser::FLOATING_LITERAL);\n-        break;\n-      }\n-\n-      case ClickHouseParser::DOT: {\n-        enterOuterAlt(_localctx, 2);\n-        setState(1867);\n-        match(ClickHouseParser::DOT);\n-        setState(1868);\n-        _la = _input->LA(1);\n-        if (!(_la == ClickHouseParser::OCTAL_LITERAL\n-\n-        || _la == ClickHouseParser::DECIMAL_LITERAL)) {\n-        _errHandler->recoverInline(this);\n-        }\n-        else {\n-          _errHandler->reportMatch(this);\n-          consume();\n-        }\n-        break;\n-      }\n-\n-      case ClickHouseParser::DECIMAL_LITERAL: {\n-        enterOuterAlt(_localctx, 3);\n-        setState(1869);\n-        match(ClickHouseParser::DECIMAL_LITERAL);\n-        setState(1870);\n-        match(ClickHouseParser::DOT);\n-        setState(1872);\n-        _errHandler->sync(this);\n-\n-        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 249, _ctx)) {\n-        case 1: {\n-          setState(1871);\n-          _la = _input->LA(1);\n-          if (!(_la == ClickHouseParser::OCTAL_LITERAL\n-\n-          || _la == ClickHouseParser::DECIMAL_LITERAL)) {\n-          _errHandler->recoverInline(this);\n-          }\n-          else {\n-            _errHandler->reportMatch(this);\n-            consume();\n-          }\n-          break;\n-        }\n-\n-        }\n-        break;\n-      }\n-\n-    default:\n-      throw NoViableAltException(this);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- NumberLiteralContext ------------------------------------------------------------------\n-\n-ClickHouseParser::NumberLiteralContext::NumberLiteralContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::FloatingLiteralContext* ClickHouseParser::NumberLiteralContext::floatingLiteral() {\n-  return getRuleContext<ClickHouseParser::FloatingLiteralContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::NumberLiteralContext::OCTAL_LITERAL() {\n-  return getToken(ClickHouseParser::OCTAL_LITERAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::NumberLiteralContext::DECIMAL_LITERAL() {\n-  return getToken(ClickHouseParser::DECIMAL_LITERAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::NumberLiteralContext::HEXADECIMAL_LITERAL() {\n-  return getToken(ClickHouseParser::HEXADECIMAL_LITERAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::NumberLiteralContext::INF() {\n-  return getToken(ClickHouseParser::INF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::NumberLiteralContext::NAN_SQL() {\n-  return getToken(ClickHouseParser::NAN_SQL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::NumberLiteralContext::PLUS() {\n-  return getToken(ClickHouseParser::PLUS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::NumberLiteralContext::DASH() {\n-  return getToken(ClickHouseParser::DASH, 0);\n-}\n-\n-\n-size_t ClickHouseParser::NumberLiteralContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleNumberLiteral;\n-}\n-\n-antlrcpp::Any ClickHouseParser::NumberLiteralContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitNumberLiteral(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::NumberLiteralContext* ClickHouseParser::numberLiteral() {\n-  NumberLiteralContext *_localctx = _tracker.createInstance<NumberLiteralContext>(_ctx, getState());\n-  enterRule(_localctx, 200, ClickHouseParser::RuleNumberLiteral);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1877);\n-    _errHandler->sync(this);\n-\n-    _la = _input->LA(1);\n-    if (_la == ClickHouseParser::DASH\n-\n-    || _la == ClickHouseParser::PLUS) {\n-      setState(1876);\n-      _la = _input->LA(1);\n-      if (!(_la == ClickHouseParser::DASH\n-\n-      || _la == ClickHouseParser::PLUS)) {\n-      _errHandler->recoverInline(this);\n-      }\n-      else {\n-        _errHandler->reportMatch(this);\n-        consume();\n-      }\n-    }\n-    setState(1885);\n-    _errHandler->sync(this);\n-    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 252, _ctx)) {\n-    case 1: {\n-      setState(1879);\n-      floatingLiteral();\n-      break;\n-    }\n-\n-    case 2: {\n-      setState(1880);\n-      match(ClickHouseParser::OCTAL_LITERAL);\n-      break;\n-    }\n-\n-    case 3: {\n-      setState(1881);\n-      match(ClickHouseParser::DECIMAL_LITERAL);\n-      break;\n-    }\n-\n-    case 4: {\n-      setState(1882);\n-      match(ClickHouseParser::HEXADECIMAL_LITERAL);\n-      break;\n-    }\n-\n-    case 5: {\n-      setState(1883);\n-      match(ClickHouseParser::INF);\n-      break;\n-    }\n-\n-    case 6: {\n-      setState(1884);\n-      match(ClickHouseParser::NAN_SQL);\n-      break;\n-    }\n-\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- LiteralContext ------------------------------------------------------------------\n-\n-ClickHouseParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::NumberLiteralContext* ClickHouseParser::LiteralContext::numberLiteral() {\n-  return getRuleContext<ClickHouseParser::NumberLiteralContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::LiteralContext::STRING_LITERAL() {\n-  return getToken(ClickHouseParser::STRING_LITERAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::LiteralContext::NULL_SQL() {\n-  return getToken(ClickHouseParser::NULL_SQL, 0);\n-}\n-\n-\n-size_t ClickHouseParser::LiteralContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleLiteral;\n-}\n-\n-antlrcpp::Any ClickHouseParser::LiteralContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitLiteral(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::LiteralContext* ClickHouseParser::literal() {\n-  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());\n-  enterRule(_localctx, 202, ClickHouseParser::RuleLiteral);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(1890);\n-    _errHandler->sync(this);\n-    switch (_input->LA(1)) {\n-      case ClickHouseParser::INF:\n-      case ClickHouseParser::NAN_SQL:\n-      case ClickHouseParser::FLOATING_LITERAL:\n-      case ClickHouseParser::OCTAL_LITERAL:\n-      case ClickHouseParser::DECIMAL_LITERAL:\n-      case ClickHouseParser::HEXADECIMAL_LITERAL:\n-      case ClickHouseParser::DASH:\n-      case ClickHouseParser::DOT:\n-      case ClickHouseParser::PLUS: {\n-        enterOuterAlt(_localctx, 1);\n-        setState(1887);\n-        numberLiteral();\n-        break;\n-      }\n-\n-      case ClickHouseParser::STRING_LITERAL: {\n-        enterOuterAlt(_localctx, 2);\n-        setState(1888);\n-        match(ClickHouseParser::STRING_LITERAL);\n-        break;\n-      }\n-\n-      case ClickHouseParser::NULL_SQL: {\n-        enterOuterAlt(_localctx, 3);\n-        setState(1889);\n-        match(ClickHouseParser::NULL_SQL);\n-        break;\n-      }\n-\n-    default:\n-      throw NoViableAltException(this);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- IntervalContext ------------------------------------------------------------------\n-\n-ClickHouseParser::IntervalContext::IntervalContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::IntervalContext::SECOND() {\n-  return getToken(ClickHouseParser::SECOND, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::IntervalContext::MINUTE() {\n-  return getToken(ClickHouseParser::MINUTE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::IntervalContext::HOUR() {\n-  return getToken(ClickHouseParser::HOUR, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::IntervalContext::DAY() {\n-  return getToken(ClickHouseParser::DAY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::IntervalContext::WEEK() {\n-  return getToken(ClickHouseParser::WEEK, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::IntervalContext::MONTH() {\n-  return getToken(ClickHouseParser::MONTH, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::IntervalContext::QUARTER() {\n-  return getToken(ClickHouseParser::QUARTER, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::IntervalContext::YEAR() {\n-  return getToken(ClickHouseParser::YEAR, 0);\n-}\n-\n-\n-size_t ClickHouseParser::IntervalContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleInterval;\n-}\n-\n-antlrcpp::Any ClickHouseParser::IntervalContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitInterval(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::IntervalContext* ClickHouseParser::interval() {\n-  IntervalContext *_localctx = _tracker.createInstance<IntervalContext>(_ctx, getState());\n-  enterRule(_localctx, 204, ClickHouseParser::RuleInterval);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1892);\n-    _la = _input->LA(1);\n-    if (!(_la == ClickHouseParser::DAY || ((((_la - 73) & ~ 0x3fULL) == 0) &&\n-      ((1ULL << (_la - 73)) & ((1ULL << (ClickHouseParser::HOUR - 73))\n-      | (1ULL << (ClickHouseParser::MINUTE - 73))\n-      | (1ULL << (ClickHouseParser::MONTH - 73))\n-      | (1ULL << (ClickHouseParser::QUARTER - 73)))) != 0) || ((((_la - 138) & ~ 0x3fULL) == 0) &&\n-      ((1ULL << (_la - 138)) & ((1ULL << (ClickHouseParser::SECOND - 138))\n-      | (1ULL << (ClickHouseParser::WEEK - 138))\n-      | (1ULL << (ClickHouseParser::YEAR - 138)))) != 0))) {\n-    _errHandler->recoverInline(this);\n-    }\n-    else {\n-      _errHandler->reportMatch(this);\n-      consume();\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- KeywordContext ------------------------------------------------------------------\n-\n-ClickHouseParser::KeywordContext::KeywordContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::AFTER() {\n-  return getToken(ClickHouseParser::AFTER, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::ALIAS() {\n-  return getToken(ClickHouseParser::ALIAS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::ALL() {\n-  return getToken(ClickHouseParser::ALL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::ALTER() {\n-  return getToken(ClickHouseParser::ALTER, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::AND() {\n-  return getToken(ClickHouseParser::AND, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::ANTI() {\n-  return getToken(ClickHouseParser::ANTI, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::ANY() {\n-  return getToken(ClickHouseParser::ANY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::ARRAY() {\n-  return getToken(ClickHouseParser::ARRAY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::AS() {\n-  return getToken(ClickHouseParser::AS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::ASCENDING() {\n-  return getToken(ClickHouseParser::ASCENDING, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::ASOF() {\n-  return getToken(ClickHouseParser::ASOF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::AST() {\n-  return getToken(ClickHouseParser::AST, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::ASYNC() {\n-  return getToken(ClickHouseParser::ASYNC, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::ATTACH() {\n-  return getToken(ClickHouseParser::ATTACH, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::BETWEEN() {\n-  return getToken(ClickHouseParser::BETWEEN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::BOTH() {\n-  return getToken(ClickHouseParser::BOTH, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::BY() {\n-  return getToken(ClickHouseParser::BY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::CASE() {\n-  return getToken(ClickHouseParser::CASE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::CAST() {\n-  return getToken(ClickHouseParser::CAST, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::CHECK() {\n-  return getToken(ClickHouseParser::CHECK, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::CLEAR() {\n-  return getToken(ClickHouseParser::CLEAR, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::CLUSTER() {\n-  return getToken(ClickHouseParser::CLUSTER, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::CODEC() {\n-  return getToken(ClickHouseParser::CODEC, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::COLLATE() {\n-  return getToken(ClickHouseParser::COLLATE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::COLUMN() {\n-  return getToken(ClickHouseParser::COLUMN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::COMMENT() {\n-  return getToken(ClickHouseParser::COMMENT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::CONSTRAINT() {\n-  return getToken(ClickHouseParser::CONSTRAINT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::CREATE() {\n-  return getToken(ClickHouseParser::CREATE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::CROSS() {\n-  return getToken(ClickHouseParser::CROSS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::CUBE() {\n-  return getToken(ClickHouseParser::CUBE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::DATABASE() {\n-  return getToken(ClickHouseParser::DATABASE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::DATABASES() {\n-  return getToken(ClickHouseParser::DATABASES, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::DATE() {\n-  return getToken(ClickHouseParser::DATE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::DEDUPLICATE() {\n-  return getToken(ClickHouseParser::DEDUPLICATE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::DEFAULT() {\n-  return getToken(ClickHouseParser::DEFAULT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::DELAY() {\n-  return getToken(ClickHouseParser::DELAY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::DELETE() {\n-  return getToken(ClickHouseParser::DELETE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::DESCRIBE() {\n-  return getToken(ClickHouseParser::DESCRIBE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::DESC() {\n-  return getToken(ClickHouseParser::DESC, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::DESCENDING() {\n-  return getToken(ClickHouseParser::DESCENDING, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::DETACH() {\n-  return getToken(ClickHouseParser::DETACH, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::DICTIONARIES() {\n-  return getToken(ClickHouseParser::DICTIONARIES, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::DICTIONARY() {\n-  return getToken(ClickHouseParser::DICTIONARY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::DISK() {\n-  return getToken(ClickHouseParser::DISK, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::DISTINCT() {\n-  return getToken(ClickHouseParser::DISTINCT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::DISTRIBUTED() {\n-  return getToken(ClickHouseParser::DISTRIBUTED, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::DROP() {\n-  return getToken(ClickHouseParser::DROP, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::ELSE() {\n-  return getToken(ClickHouseParser::ELSE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::END() {\n-  return getToken(ClickHouseParser::END, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::ENGINE() {\n-  return getToken(ClickHouseParser::ENGINE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::EVENTS() {\n-  return getToken(ClickHouseParser::EVENTS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::EXISTS() {\n-  return getToken(ClickHouseParser::EXISTS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::EXPLAIN() {\n-  return getToken(ClickHouseParser::EXPLAIN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::EXPRESSION() {\n-  return getToken(ClickHouseParser::EXPRESSION, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::EXTRACT() {\n-  return getToken(ClickHouseParser::EXTRACT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::FETCHES() {\n-  return getToken(ClickHouseParser::FETCHES, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::FINAL() {\n-  return getToken(ClickHouseParser::FINAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::FIRST() {\n-  return getToken(ClickHouseParser::FIRST, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::FLUSH() {\n-  return getToken(ClickHouseParser::FLUSH, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::FOR() {\n-  return getToken(ClickHouseParser::FOR, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::FORMAT() {\n-  return getToken(ClickHouseParser::FORMAT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::FREEZE() {\n-  return getToken(ClickHouseParser::FREEZE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::FROM() {\n-  return getToken(ClickHouseParser::FROM, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::FULL() {\n-  return getToken(ClickHouseParser::FULL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::FUNCTION() {\n-  return getToken(ClickHouseParser::FUNCTION, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::GLOBAL() {\n-  return getToken(ClickHouseParser::GLOBAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::GRANULARITY() {\n-  return getToken(ClickHouseParser::GRANULARITY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::GROUP() {\n-  return getToken(ClickHouseParser::GROUP, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::HAVING() {\n-  return getToken(ClickHouseParser::HAVING, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::HIERARCHICAL() {\n-  return getToken(ClickHouseParser::HIERARCHICAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::ID() {\n-  return getToken(ClickHouseParser::ID, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::IF() {\n-  return getToken(ClickHouseParser::IF, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::ILIKE() {\n-  return getToken(ClickHouseParser::ILIKE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::IN() {\n-  return getToken(ClickHouseParser::IN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::INDEX() {\n-  return getToken(ClickHouseParser::INDEX, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::INJECTIVE() {\n-  return getToken(ClickHouseParser::INJECTIVE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::INNER() {\n-  return getToken(ClickHouseParser::INNER, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::INSERT() {\n-  return getToken(ClickHouseParser::INSERT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::INTERVAL() {\n-  return getToken(ClickHouseParser::INTERVAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::INTO() {\n-  return getToken(ClickHouseParser::INTO, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::IS() {\n-  return getToken(ClickHouseParser::IS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::IS_OBJECT_ID() {\n-  return getToken(ClickHouseParser::IS_OBJECT_ID, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::JOIN() {\n-  return getToken(ClickHouseParser::JOIN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::JSON_FALSE() {\n-  return getToken(ClickHouseParser::JSON_FALSE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::JSON_TRUE() {\n-  return getToken(ClickHouseParser::JSON_TRUE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::KEY() {\n-  return getToken(ClickHouseParser::KEY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::KILL() {\n-  return getToken(ClickHouseParser::KILL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::LAST() {\n-  return getToken(ClickHouseParser::LAST, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::LAYOUT() {\n-  return getToken(ClickHouseParser::LAYOUT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::LEADING() {\n-  return getToken(ClickHouseParser::LEADING, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::LEFT() {\n-  return getToken(ClickHouseParser::LEFT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::LIFETIME() {\n-  return getToken(ClickHouseParser::LIFETIME, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::LIKE() {\n-  return getToken(ClickHouseParser::LIKE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::LIMIT() {\n-  return getToken(ClickHouseParser::LIMIT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::LIVE() {\n-  return getToken(ClickHouseParser::LIVE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::LOCAL() {\n-  return getToken(ClickHouseParser::LOCAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::LOGS() {\n-  return getToken(ClickHouseParser::LOGS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::MATERIALIZE() {\n-  return getToken(ClickHouseParser::MATERIALIZE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::MATERIALIZED() {\n-  return getToken(ClickHouseParser::MATERIALIZED, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::MAX() {\n-  return getToken(ClickHouseParser::MAX, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::MERGES() {\n-  return getToken(ClickHouseParser::MERGES, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::MIN() {\n-  return getToken(ClickHouseParser::MIN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::MODIFY() {\n-  return getToken(ClickHouseParser::MODIFY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::MOVE() {\n-  return getToken(ClickHouseParser::MOVE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::MUTATION() {\n-  return getToken(ClickHouseParser::MUTATION, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::NO() {\n-  return getToken(ClickHouseParser::NO, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::NOT() {\n-  return getToken(ClickHouseParser::NOT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::NULLS() {\n-  return getToken(ClickHouseParser::NULLS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::OFFSET() {\n-  return getToken(ClickHouseParser::OFFSET, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::ON() {\n-  return getToken(ClickHouseParser::ON, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::OPTIMIZE() {\n-  return getToken(ClickHouseParser::OPTIMIZE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::OR() {\n-  return getToken(ClickHouseParser::OR, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::ORDER() {\n-  return getToken(ClickHouseParser::ORDER, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::OUTER() {\n-  return getToken(ClickHouseParser::OUTER, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::OUTFILE() {\n-  return getToken(ClickHouseParser::OUTFILE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::PARTITION() {\n-  return getToken(ClickHouseParser::PARTITION, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::POPULATE() {\n-  return getToken(ClickHouseParser::POPULATE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::PREWHERE() {\n-  return getToken(ClickHouseParser::PREWHERE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::PRIMARY() {\n-  return getToken(ClickHouseParser::PRIMARY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::RANGE() {\n-  return getToken(ClickHouseParser::RANGE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::RELOAD() {\n-  return getToken(ClickHouseParser::RELOAD, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::REMOVE() {\n-  return getToken(ClickHouseParser::REMOVE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::RENAME() {\n-  return getToken(ClickHouseParser::RENAME, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::REPLACE() {\n-  return getToken(ClickHouseParser::REPLACE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::REPLICA() {\n-  return getToken(ClickHouseParser::REPLICA, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::REPLICATED() {\n-  return getToken(ClickHouseParser::REPLICATED, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::RIGHT() {\n-  return getToken(ClickHouseParser::RIGHT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::ROLLUP() {\n-  return getToken(ClickHouseParser::ROLLUP, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::SAMPLE() {\n-  return getToken(ClickHouseParser::SAMPLE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::SELECT() {\n-  return getToken(ClickHouseParser::SELECT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::SEMI() {\n-  return getToken(ClickHouseParser::SEMI, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::SENDS() {\n-  return getToken(ClickHouseParser::SENDS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::SET() {\n-  return getToken(ClickHouseParser::SET, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::SETTINGS() {\n-  return getToken(ClickHouseParser::SETTINGS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::SHOW() {\n-  return getToken(ClickHouseParser::SHOW, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::SOURCE() {\n-  return getToken(ClickHouseParser::SOURCE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::START() {\n-  return getToken(ClickHouseParser::START, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::STOP() {\n-  return getToken(ClickHouseParser::STOP, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::SUBSTRING() {\n-  return getToken(ClickHouseParser::SUBSTRING, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::SYNC() {\n-  return getToken(ClickHouseParser::SYNC, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::SYNTAX() {\n-  return getToken(ClickHouseParser::SYNTAX, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::SYSTEM() {\n-  return getToken(ClickHouseParser::SYSTEM, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::TABLE() {\n-  return getToken(ClickHouseParser::TABLE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::TABLES() {\n-  return getToken(ClickHouseParser::TABLES, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::TEMPORARY() {\n-  return getToken(ClickHouseParser::TEMPORARY, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::TEST() {\n-  return getToken(ClickHouseParser::TEST, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::THEN() {\n-  return getToken(ClickHouseParser::THEN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::TIES() {\n-  return getToken(ClickHouseParser::TIES, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::TIMEOUT() {\n-  return getToken(ClickHouseParser::TIMEOUT, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::TIMESTAMP() {\n-  return getToken(ClickHouseParser::TIMESTAMP, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::TOTALS() {\n-  return getToken(ClickHouseParser::TOTALS, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::TRAILING() {\n-  return getToken(ClickHouseParser::TRAILING, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::TRIM() {\n-  return getToken(ClickHouseParser::TRIM, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::TRUNCATE() {\n-  return getToken(ClickHouseParser::TRUNCATE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::TO() {\n-  return getToken(ClickHouseParser::TO, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::TOP() {\n-  return getToken(ClickHouseParser::TOP, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::TTL() {\n-  return getToken(ClickHouseParser::TTL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::TYPE() {\n-  return getToken(ClickHouseParser::TYPE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::UNION() {\n-  return getToken(ClickHouseParser::UNION, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::UPDATE() {\n-  return getToken(ClickHouseParser::UPDATE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::USE() {\n-  return getToken(ClickHouseParser::USE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::USING() {\n-  return getToken(ClickHouseParser::USING, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::UUID() {\n-  return getToken(ClickHouseParser::UUID, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::VALUES() {\n-  return getToken(ClickHouseParser::VALUES, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::VIEW() {\n-  return getToken(ClickHouseParser::VIEW, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::VOLUME() {\n-  return getToken(ClickHouseParser::VOLUME, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::WATCH() {\n-  return getToken(ClickHouseParser::WATCH, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::WHEN() {\n-  return getToken(ClickHouseParser::WHEN, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::WHERE() {\n-  return getToken(ClickHouseParser::WHERE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordContext::WITH() {\n-  return getToken(ClickHouseParser::WITH, 0);\n-}\n-\n-\n-size_t ClickHouseParser::KeywordContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleKeyword;\n-}\n-\n-antlrcpp::Any ClickHouseParser::KeywordContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitKeyword(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::KeywordContext* ClickHouseParser::keyword() {\n-  KeywordContext *_localctx = _tracker.createInstance<KeywordContext>(_ctx, getState());\n-  enterRule(_localctx, 206, ClickHouseParser::RuleKeyword);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1894);\n-    _la = _input->LA(1);\n-    if (!((((_la & ~ 0x3fULL) == 0) &&\n-      ((1ULL << _la) & ((1ULL << ClickHouseParser::AFTER)\n-      | (1ULL << ClickHouseParser::ALIAS)\n-      | (1ULL << ClickHouseParser::ALL)\n-      | (1ULL << ClickHouseParser::ALTER)\n-      | (1ULL << ClickHouseParser::AND)\n-      | (1ULL << ClickHouseParser::ANTI)\n-      | (1ULL << ClickHouseParser::ANY)\n-      | (1ULL << ClickHouseParser::ARRAY)\n-      | (1ULL << ClickHouseParser::AS)\n-      | (1ULL << ClickHouseParser::ASCENDING)\n-      | (1ULL << ClickHouseParser::ASOF)\n-      | (1ULL << ClickHouseParser::AST)\n-      | (1ULL << ClickHouseParser::ASYNC)\n-      | (1ULL << ClickHouseParser::ATTACH)\n-      | (1ULL << ClickHouseParser::BETWEEN)\n-      | (1ULL << ClickHouseParser::BOTH)\n-      | (1ULL << ClickHouseParser::BY)\n-      | (1ULL << ClickHouseParser::CASE)\n-      | (1ULL << ClickHouseParser::CAST)\n-      | (1ULL << ClickHouseParser::CHECK)\n-      | (1ULL << ClickHouseParser::CLEAR)\n-      | (1ULL << ClickHouseParser::CLUSTER)\n-      | (1ULL << ClickHouseParser::CODEC)\n-      | (1ULL << ClickHouseParser::COLLATE)\n-      | (1ULL << ClickHouseParser::COLUMN)\n-      | (1ULL << ClickHouseParser::COMMENT)\n-      | (1ULL << ClickHouseParser::CONSTRAINT)\n-      | (1ULL << ClickHouseParser::CREATE)\n-      | (1ULL << ClickHouseParser::CROSS)\n-      | (1ULL << ClickHouseParser::CUBE)\n-      | (1ULL << ClickHouseParser::DATABASE)\n-      | (1ULL << ClickHouseParser::DATABASES)\n-      | (1ULL << ClickHouseParser::DATE)\n-      | (1ULL << ClickHouseParser::DEDUPLICATE)\n-      | (1ULL << ClickHouseParser::DEFAULT)\n-      | (1ULL << ClickHouseParser::DELAY)\n-      | (1ULL << ClickHouseParser::DELETE)\n-      | (1ULL << ClickHouseParser::DESC)\n-      | (1ULL << ClickHouseParser::DESCENDING)\n-      | (1ULL << ClickHouseParser::DESCRIBE)\n-      | (1ULL << ClickHouseParser::DETACH)\n-      | (1ULL << ClickHouseParser::DICTIONARIES)\n-      | (1ULL << ClickHouseParser::DICTIONARY)\n-      | (1ULL << ClickHouseParser::DISK)\n-      | (1ULL << ClickHouseParser::DISTINCT)\n-      | (1ULL << ClickHouseParser::DISTRIBUTED)\n-      | (1ULL << ClickHouseParser::DROP)\n-      | (1ULL << ClickHouseParser::ELSE)\n-      | (1ULL << ClickHouseParser::END)\n-      | (1ULL << ClickHouseParser::ENGINE)\n-      | (1ULL << ClickHouseParser::EVENTS)\n-      | (1ULL << ClickHouseParser::EXISTS)\n-      | (1ULL << ClickHouseParser::EXPLAIN)\n-      | (1ULL << ClickHouseParser::EXPRESSION)\n-      | (1ULL << ClickHouseParser::EXTRACT)\n-      | (1ULL << ClickHouseParser::FETCHES)\n-      | (1ULL << ClickHouseParser::FINAL)\n-      | (1ULL << ClickHouseParser::FIRST)\n-      | (1ULL << ClickHouseParser::FLUSH)\n-      | (1ULL << ClickHouseParser::FOR)\n-      | (1ULL << ClickHouseParser::FORMAT))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&\n-      ((1ULL << (_la - 64)) & ((1ULL << (ClickHouseParser::FREEZE - 64))\n-      | (1ULL << (ClickHouseParser::FROM - 64))\n-      | (1ULL << (ClickHouseParser::FULL - 64))\n-      | (1ULL << (ClickHouseParser::FUNCTION - 64))\n-      | (1ULL << (ClickHouseParser::GLOBAL - 64))\n-      | (1ULL << (ClickHouseParser::GRANULARITY - 64))\n-      | (1ULL << (ClickHouseParser::GROUP - 64))\n-      | (1ULL << (ClickHouseParser::HAVING - 64))\n-      | (1ULL << (ClickHouseParser::HIERARCHICAL - 64))\n-      | (1ULL << (ClickHouseParser::ID - 64))\n-      | (1ULL << (ClickHouseParser::IF - 64))\n-      | (1ULL << (ClickHouseParser::ILIKE - 64))\n-      | (1ULL << (ClickHouseParser::IN - 64))\n-      | (1ULL << (ClickHouseParser::INDEX - 64))\n-      | (1ULL << (ClickHouseParser::INJECTIVE - 64))\n-      | (1ULL << (ClickHouseParser::INNER - 64))\n-      | (1ULL << (ClickHouseParser::INSERT - 64))\n-      | (1ULL << (ClickHouseParser::INTERVAL - 64))\n-      | (1ULL << (ClickHouseParser::INTO - 64))\n-      | (1ULL << (ClickHouseParser::IS - 64))\n-      | (1ULL << (ClickHouseParser::IS_OBJECT_ID - 64))\n-      | (1ULL << (ClickHouseParser::JOIN - 64))\n-      | (1ULL << (ClickHouseParser::KEY - 64))\n-      | (1ULL << (ClickHouseParser::KILL - 64))\n-      | (1ULL << (ClickHouseParser::LAST - 64))\n-      | (1ULL << (ClickHouseParser::LAYOUT - 64))\n-      | (1ULL << (ClickHouseParser::LEADING - 64))\n-      | (1ULL << (ClickHouseParser::LEFT - 64))\n-      | (1ULL << (ClickHouseParser::LIFETIME - 64))\n-      | (1ULL << (ClickHouseParser::LIKE - 64))\n-      | (1ULL << (ClickHouseParser::LIMIT - 64))\n-      | (1ULL << (ClickHouseParser::LIVE - 64))\n-      | (1ULL << (ClickHouseParser::LOCAL - 64))\n-      | (1ULL << (ClickHouseParser::LOGS - 64))\n-      | (1ULL << (ClickHouseParser::MATERIALIZE - 64))\n-      | (1ULL << (ClickHouseParser::MATERIALIZED - 64))\n-      | (1ULL << (ClickHouseParser::MAX - 64))\n-      | (1ULL << (ClickHouseParser::MERGES - 64))\n-      | (1ULL << (ClickHouseParser::MIN - 64))\n-      | (1ULL << (ClickHouseParser::MODIFY - 64))\n-      | (1ULL << (ClickHouseParser::MOVE - 64))\n-      | (1ULL << (ClickHouseParser::MUTATION - 64))\n-      | (1ULL << (ClickHouseParser::NO - 64))\n-      | (1ULL << (ClickHouseParser::NOT - 64))\n-      | (1ULL << (ClickHouseParser::NULLS - 64))\n-      | (1ULL << (ClickHouseParser::OFFSET - 64))\n-      | (1ULL << (ClickHouseParser::ON - 64))\n-      | (1ULL << (ClickHouseParser::OPTIMIZE - 64))\n-      | (1ULL << (ClickHouseParser::OR - 64))\n-      | (1ULL << (ClickHouseParser::ORDER - 64))\n-      | (1ULL << (ClickHouseParser::OUTER - 64))\n-      | (1ULL << (ClickHouseParser::OUTFILE - 64))\n-      | (1ULL << (ClickHouseParser::PARTITION - 64))\n-      | (1ULL << (ClickHouseParser::POPULATE - 64))\n-      | (1ULL << (ClickHouseParser::PREWHERE - 64))\n-      | (1ULL << (ClickHouseParser::PRIMARY - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&\n-      ((1ULL << (_la - 128)) & ((1ULL << (ClickHouseParser::RANGE - 128))\n-      | (1ULL << (ClickHouseParser::RELOAD - 128))\n-      | (1ULL << (ClickHouseParser::REMOVE - 128))\n-      | (1ULL << (ClickHouseParser::RENAME - 128))\n-      | (1ULL << (ClickHouseParser::REPLACE - 128))\n-      | (1ULL << (ClickHouseParser::REPLICA - 128))\n-      | (1ULL << (ClickHouseParser::REPLICATED - 128))\n-      | (1ULL << (ClickHouseParser::RIGHT - 128))\n-      | (1ULL << (ClickHouseParser::ROLLUP - 128))\n-      | (1ULL << (ClickHouseParser::SAMPLE - 128))\n-      | (1ULL << (ClickHouseParser::SELECT - 128))\n-      | (1ULL << (ClickHouseParser::SEMI - 128))\n-      | (1ULL << (ClickHouseParser::SENDS - 128))\n-      | (1ULL << (ClickHouseParser::SET - 128))\n-      | (1ULL << (ClickHouseParser::SETTINGS - 128))\n-      | (1ULL << (ClickHouseParser::SHOW - 128))\n-      | (1ULL << (ClickHouseParser::SOURCE - 128))\n-      | (1ULL << (ClickHouseParser::START - 128))\n-      | (1ULL << (ClickHouseParser::STOP - 128))\n-      | (1ULL << (ClickHouseParser::SUBSTRING - 128))\n-      | (1ULL << (ClickHouseParser::SYNC - 128))\n-      | (1ULL << (ClickHouseParser::SYNTAX - 128))\n-      | (1ULL << (ClickHouseParser::SYSTEM - 128))\n-      | (1ULL << (ClickHouseParser::TABLE - 128))\n-      | (1ULL << (ClickHouseParser::TABLES - 128))\n-      | (1ULL << (ClickHouseParser::TEMPORARY - 128))\n-      | (1ULL << (ClickHouseParser::TEST - 128))\n-      | (1ULL << (ClickHouseParser::THEN - 128))\n-      | (1ULL << (ClickHouseParser::TIES - 128))\n-      | (1ULL << (ClickHouseParser::TIMEOUT - 128))\n-      | (1ULL << (ClickHouseParser::TIMESTAMP - 128))\n-      | (1ULL << (ClickHouseParser::TO - 128))\n-      | (1ULL << (ClickHouseParser::TOP - 128))\n-      | (1ULL << (ClickHouseParser::TOTALS - 128))\n-      | (1ULL << (ClickHouseParser::TRAILING - 128))\n-      | (1ULL << (ClickHouseParser::TRIM - 128))\n-      | (1ULL << (ClickHouseParser::TRUNCATE - 128))\n-      | (1ULL << (ClickHouseParser::TTL - 128))\n-      | (1ULL << (ClickHouseParser::TYPE - 128))\n-      | (1ULL << (ClickHouseParser::UNION - 128))\n-      | (1ULL << (ClickHouseParser::UPDATE - 128))\n-      | (1ULL << (ClickHouseParser::USE - 128))\n-      | (1ULL << (ClickHouseParser::USING - 128))\n-      | (1ULL << (ClickHouseParser::UUID - 128))\n-      | (1ULL << (ClickHouseParser::VALUES - 128))\n-      | (1ULL << (ClickHouseParser::VIEW - 128))\n-      | (1ULL << (ClickHouseParser::VOLUME - 128))\n-      | (1ULL << (ClickHouseParser::WATCH - 128))\n-      | (1ULL << (ClickHouseParser::WHEN - 128))\n-      | (1ULL << (ClickHouseParser::WHERE - 128))\n-      | (1ULL << (ClickHouseParser::WITH - 128))\n-      | (1ULL << (ClickHouseParser::JSON_FALSE - 128))\n-      | (1ULL << (ClickHouseParser::JSON_TRUE - 128)))) != 0))) {\n-    _errHandler->recoverInline(this);\n-    }\n-    else {\n-      _errHandler->reportMatch(this);\n-      consume();\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- KeywordForAliasContext ------------------------------------------------------------------\n-\n-ClickHouseParser::KeywordForAliasContext::KeywordForAliasContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordForAliasContext::DATE() {\n-  return getToken(ClickHouseParser::DATE, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordForAliasContext::FIRST() {\n-  return getToken(ClickHouseParser::FIRST, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordForAliasContext::ID() {\n-  return getToken(ClickHouseParser::ID, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::KeywordForAliasContext::KEY() {\n-  return getToken(ClickHouseParser::KEY, 0);\n-}\n-\n-\n-size_t ClickHouseParser::KeywordForAliasContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleKeywordForAlias;\n-}\n-\n-antlrcpp::Any ClickHouseParser::KeywordForAliasContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitKeywordForAlias(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::KeywordForAliasContext* ClickHouseParser::keywordForAlias() {\n-  KeywordForAliasContext *_localctx = _tracker.createInstance<KeywordForAliasContext>(_ctx, getState());\n-  enterRule(_localctx, 208, ClickHouseParser::RuleKeywordForAlias);\n-  size_t _la = 0;\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1896);\n-    _la = _input->LA(1);\n-    if (!(((((_la - 34) & ~ 0x3fULL) == 0) &&\n-      ((1ULL << (_la - 34)) & ((1ULL << (ClickHouseParser::DATE - 34))\n-      | (1ULL << (ClickHouseParser::FIRST - 34))\n-      | (1ULL << (ClickHouseParser::ID - 34))\n-      | (1ULL << (ClickHouseParser::KEY - 34)))) != 0))) {\n-    _errHandler->recoverInline(this);\n-    }\n-    else {\n-      _errHandler->reportMatch(this);\n-      consume();\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- AliasContext ------------------------------------------------------------------\n-\n-ClickHouseParser::AliasContext::AliasContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::AliasContext::IDENTIFIER() {\n-  return getToken(ClickHouseParser::IDENTIFIER, 0);\n-}\n-\n-ClickHouseParser::KeywordForAliasContext* ClickHouseParser::AliasContext::keywordForAlias() {\n-  return getRuleContext<ClickHouseParser::KeywordForAliasContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::AliasContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleAlias;\n-}\n-\n-antlrcpp::Any ClickHouseParser::AliasContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitAlias(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::AliasContext* ClickHouseParser::alias() {\n-  AliasContext *_localctx = _tracker.createInstance<AliasContext>(_ctx, getState());\n-  enterRule(_localctx, 210, ClickHouseParser::RuleAlias);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(1900);\n-    _errHandler->sync(this);\n-    switch (_input->LA(1)) {\n-      case ClickHouseParser::IDENTIFIER: {\n-        enterOuterAlt(_localctx, 1);\n-        setState(1898);\n-        match(ClickHouseParser::IDENTIFIER);\n-        break;\n-      }\n-\n-      case ClickHouseParser::DATE:\n-      case ClickHouseParser::FIRST:\n-      case ClickHouseParser::ID:\n-      case ClickHouseParser::KEY: {\n-        enterOuterAlt(_localctx, 2);\n-        setState(1899);\n-        keywordForAlias();\n-        break;\n-      }\n-\n-    default:\n-      throw NoViableAltException(this);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- IdentifierContext ------------------------------------------------------------------\n-\n-ClickHouseParser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::IdentifierContext::IDENTIFIER() {\n-  return getToken(ClickHouseParser::IDENTIFIER, 0);\n-}\n-\n-ClickHouseParser::IntervalContext* ClickHouseParser::IdentifierContext::interval() {\n-  return getRuleContext<ClickHouseParser::IntervalContext>(0);\n-}\n-\n-ClickHouseParser::KeywordContext* ClickHouseParser::IdentifierContext::keyword() {\n-  return getRuleContext<ClickHouseParser::KeywordContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::IdentifierContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleIdentifier;\n-}\n-\n-antlrcpp::Any ClickHouseParser::IdentifierContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitIdentifier(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::identifier() {\n-  IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());\n-  enterRule(_localctx, 212, ClickHouseParser::RuleIdentifier);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(1905);\n-    _errHandler->sync(this);\n-    switch (_input->LA(1)) {\n-      case ClickHouseParser::IDENTIFIER: {\n-        enterOuterAlt(_localctx, 1);\n-        setState(1902);\n-        match(ClickHouseParser::IDENTIFIER);\n-        break;\n-      }\n-\n-      case ClickHouseParser::DAY:\n-      case ClickHouseParser::HOUR:\n-      case ClickHouseParser::MINUTE:\n-      case ClickHouseParser::MONTH:\n-      case ClickHouseParser::QUARTER:\n-      case ClickHouseParser::SECOND:\n-      case ClickHouseParser::WEEK:\n-      case ClickHouseParser::YEAR: {\n-        enterOuterAlt(_localctx, 2);\n-        setState(1903);\n-        interval();\n-        break;\n-      }\n-\n-      case ClickHouseParser::AFTER:\n-      case ClickHouseParser::ALIAS:\n-      case ClickHouseParser::ALL:\n-      case ClickHouseParser::ALTER:\n-      case ClickHouseParser::AND:\n-      case ClickHouseParser::ANTI:\n-      case ClickHouseParser::ANY:\n-      case ClickHouseParser::ARRAY:\n-      case ClickHouseParser::AS:\n-      case ClickHouseParser::ASCENDING:\n-      case ClickHouseParser::ASOF:\n-      case ClickHouseParser::AST:\n-      case ClickHouseParser::ASYNC:\n-      case ClickHouseParser::ATTACH:\n-      case ClickHouseParser::BETWEEN:\n-      case ClickHouseParser::BOTH:\n-      case ClickHouseParser::BY:\n-      case ClickHouseParser::CASE:\n-      case ClickHouseParser::CAST:\n-      case ClickHouseParser::CHECK:\n-      case ClickHouseParser::CLEAR:\n-      case ClickHouseParser::CLUSTER:\n-      case ClickHouseParser::CODEC:\n-      case ClickHouseParser::COLLATE:\n-      case ClickHouseParser::COLUMN:\n-      case ClickHouseParser::COMMENT:\n-      case ClickHouseParser::CONSTRAINT:\n-      case ClickHouseParser::CREATE:\n-      case ClickHouseParser::CROSS:\n-      case ClickHouseParser::CUBE:\n-      case ClickHouseParser::DATABASE:\n-      case ClickHouseParser::DATABASES:\n-      case ClickHouseParser::DATE:\n-      case ClickHouseParser::DEDUPLICATE:\n-      case ClickHouseParser::DEFAULT:\n-      case ClickHouseParser::DELAY:\n-      case ClickHouseParser::DELETE:\n-      case ClickHouseParser::DESC:\n-      case ClickHouseParser::DESCENDING:\n-      case ClickHouseParser::DESCRIBE:\n-      case ClickHouseParser::DETACH:\n-      case ClickHouseParser::DICTIONARIES:\n-      case ClickHouseParser::DICTIONARY:\n-      case ClickHouseParser::DISK:\n-      case ClickHouseParser::DISTINCT:\n-      case ClickHouseParser::DISTRIBUTED:\n-      case ClickHouseParser::DROP:\n-      case ClickHouseParser::ELSE:\n-      case ClickHouseParser::END:\n-      case ClickHouseParser::ENGINE:\n-      case ClickHouseParser::EVENTS:\n-      case ClickHouseParser::EXISTS:\n-      case ClickHouseParser::EXPLAIN:\n-      case ClickHouseParser::EXPRESSION:\n-      case ClickHouseParser::EXTRACT:\n-      case ClickHouseParser::FETCHES:\n-      case ClickHouseParser::FINAL:\n-      case ClickHouseParser::FIRST:\n-      case ClickHouseParser::FLUSH:\n-      case ClickHouseParser::FOR:\n-      case ClickHouseParser::FORMAT:\n-      case ClickHouseParser::FREEZE:\n-      case ClickHouseParser::FROM:\n-      case ClickHouseParser::FULL:\n-      case ClickHouseParser::FUNCTION:\n-      case ClickHouseParser::GLOBAL:\n-      case ClickHouseParser::GRANULARITY:\n-      case ClickHouseParser::GROUP:\n-      case ClickHouseParser::HAVING:\n-      case ClickHouseParser::HIERARCHICAL:\n-      case ClickHouseParser::ID:\n-      case ClickHouseParser::IF:\n-      case ClickHouseParser::ILIKE:\n-      case ClickHouseParser::IN:\n-      case ClickHouseParser::INDEX:\n-      case ClickHouseParser::INJECTIVE:\n-      case ClickHouseParser::INNER:\n-      case ClickHouseParser::INSERT:\n-      case ClickHouseParser::INTERVAL:\n-      case ClickHouseParser::INTO:\n-      case ClickHouseParser::IS:\n-      case ClickHouseParser::IS_OBJECT_ID:\n-      case ClickHouseParser::JOIN:\n-      case ClickHouseParser::KEY:\n-      case ClickHouseParser::KILL:\n-      case ClickHouseParser::LAST:\n-      case ClickHouseParser::LAYOUT:\n-      case ClickHouseParser::LEADING:\n-      case ClickHouseParser::LEFT:\n-      case ClickHouseParser::LIFETIME:\n-      case ClickHouseParser::LIKE:\n-      case ClickHouseParser::LIMIT:\n-      case ClickHouseParser::LIVE:\n-      case ClickHouseParser::LOCAL:\n-      case ClickHouseParser::LOGS:\n-      case ClickHouseParser::MATERIALIZE:\n-      case ClickHouseParser::MATERIALIZED:\n-      case ClickHouseParser::MAX:\n-      case ClickHouseParser::MERGES:\n-      case ClickHouseParser::MIN:\n-      case ClickHouseParser::MODIFY:\n-      case ClickHouseParser::MOVE:\n-      case ClickHouseParser::MUTATION:\n-      case ClickHouseParser::NO:\n-      case ClickHouseParser::NOT:\n-      case ClickHouseParser::NULLS:\n-      case ClickHouseParser::OFFSET:\n-      case ClickHouseParser::ON:\n-      case ClickHouseParser::OPTIMIZE:\n-      case ClickHouseParser::OR:\n-      case ClickHouseParser::ORDER:\n-      case ClickHouseParser::OUTER:\n-      case ClickHouseParser::OUTFILE:\n-      case ClickHouseParser::PARTITION:\n-      case ClickHouseParser::POPULATE:\n-      case ClickHouseParser::PREWHERE:\n-      case ClickHouseParser::PRIMARY:\n-      case ClickHouseParser::RANGE:\n-      case ClickHouseParser::RELOAD:\n-      case ClickHouseParser::REMOVE:\n-      case ClickHouseParser::RENAME:\n-      case ClickHouseParser::REPLACE:\n-      case ClickHouseParser::REPLICA:\n-      case ClickHouseParser::REPLICATED:\n-      case ClickHouseParser::RIGHT:\n-      case ClickHouseParser::ROLLUP:\n-      case ClickHouseParser::SAMPLE:\n-      case ClickHouseParser::SELECT:\n-      case ClickHouseParser::SEMI:\n-      case ClickHouseParser::SENDS:\n-      case ClickHouseParser::SET:\n-      case ClickHouseParser::SETTINGS:\n-      case ClickHouseParser::SHOW:\n-      case ClickHouseParser::SOURCE:\n-      case ClickHouseParser::START:\n-      case ClickHouseParser::STOP:\n-      case ClickHouseParser::SUBSTRING:\n-      case ClickHouseParser::SYNC:\n-      case ClickHouseParser::SYNTAX:\n-      case ClickHouseParser::SYSTEM:\n-      case ClickHouseParser::TABLE:\n-      case ClickHouseParser::TABLES:\n-      case ClickHouseParser::TEMPORARY:\n-      case ClickHouseParser::TEST:\n-      case ClickHouseParser::THEN:\n-      case ClickHouseParser::TIES:\n-      case ClickHouseParser::TIMEOUT:\n-      case ClickHouseParser::TIMESTAMP:\n-      case ClickHouseParser::TO:\n-      case ClickHouseParser::TOP:\n-      case ClickHouseParser::TOTALS:\n-      case ClickHouseParser::TRAILING:\n-      case ClickHouseParser::TRIM:\n-      case ClickHouseParser::TRUNCATE:\n-      case ClickHouseParser::TTL:\n-      case ClickHouseParser::TYPE:\n-      case ClickHouseParser::UNION:\n-      case ClickHouseParser::UPDATE:\n-      case ClickHouseParser::USE:\n-      case ClickHouseParser::USING:\n-      case ClickHouseParser::UUID:\n-      case ClickHouseParser::VALUES:\n-      case ClickHouseParser::VIEW:\n-      case ClickHouseParser::VOLUME:\n-      case ClickHouseParser::WATCH:\n-      case ClickHouseParser::WHEN:\n-      case ClickHouseParser::WHERE:\n-      case ClickHouseParser::WITH:\n-      case ClickHouseParser::JSON_FALSE:\n-      case ClickHouseParser::JSON_TRUE: {\n-        enterOuterAlt(_localctx, 3);\n-        setState(1904);\n-        keyword();\n-        break;\n-      }\n-\n-    default:\n-      throw NoViableAltException(this);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- IdentifierOrNullContext ------------------------------------------------------------------\n-\n-ClickHouseParser::IdentifierOrNullContext::IdentifierOrNullContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-ClickHouseParser::IdentifierContext* ClickHouseParser::IdentifierOrNullContext::identifier() {\n-  return getRuleContext<ClickHouseParser::IdentifierContext>(0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::IdentifierOrNullContext::NULL_SQL() {\n-  return getToken(ClickHouseParser::NULL_SQL, 0);\n-}\n-\n-\n-size_t ClickHouseParser::IdentifierOrNullContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleIdentifierOrNull;\n-}\n-\n-antlrcpp::Any ClickHouseParser::IdentifierOrNullContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitIdentifierOrNull(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::IdentifierOrNullContext* ClickHouseParser::identifierOrNull() {\n-  IdentifierOrNullContext *_localctx = _tracker.createInstance<IdentifierOrNullContext>(_ctx, getState());\n-  enterRule(_localctx, 214, ClickHouseParser::RuleIdentifierOrNull);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    setState(1909);\n-    _errHandler->sync(this);\n-    switch (_input->LA(1)) {\n-      case ClickHouseParser::AFTER:\n-      case ClickHouseParser::ALIAS:\n-      case ClickHouseParser::ALL:\n-      case ClickHouseParser::ALTER:\n-      case ClickHouseParser::AND:\n-      case ClickHouseParser::ANTI:\n-      case ClickHouseParser::ANY:\n-      case ClickHouseParser::ARRAY:\n-      case ClickHouseParser::AS:\n-      case ClickHouseParser::ASCENDING:\n-      case ClickHouseParser::ASOF:\n-      case ClickHouseParser::AST:\n-      case ClickHouseParser::ASYNC:\n-      case ClickHouseParser::ATTACH:\n-      case ClickHouseParser::BETWEEN:\n-      case ClickHouseParser::BOTH:\n-      case ClickHouseParser::BY:\n-      case ClickHouseParser::CASE:\n-      case ClickHouseParser::CAST:\n-      case ClickHouseParser::CHECK:\n-      case ClickHouseParser::CLEAR:\n-      case ClickHouseParser::CLUSTER:\n-      case ClickHouseParser::CODEC:\n-      case ClickHouseParser::COLLATE:\n-      case ClickHouseParser::COLUMN:\n-      case ClickHouseParser::COMMENT:\n-      case ClickHouseParser::CONSTRAINT:\n-      case ClickHouseParser::CREATE:\n-      case ClickHouseParser::CROSS:\n-      case ClickHouseParser::CUBE:\n-      case ClickHouseParser::DATABASE:\n-      case ClickHouseParser::DATABASES:\n-      case ClickHouseParser::DATE:\n-      case ClickHouseParser::DAY:\n-      case ClickHouseParser::DEDUPLICATE:\n-      case ClickHouseParser::DEFAULT:\n-      case ClickHouseParser::DELAY:\n-      case ClickHouseParser::DELETE:\n-      case ClickHouseParser::DESC:\n-      case ClickHouseParser::DESCENDING:\n-      case ClickHouseParser::DESCRIBE:\n-      case ClickHouseParser::DETACH:\n-      case ClickHouseParser::DICTIONARIES:\n-      case ClickHouseParser::DICTIONARY:\n-      case ClickHouseParser::DISK:\n-      case ClickHouseParser::DISTINCT:\n-      case ClickHouseParser::DISTRIBUTED:\n-      case ClickHouseParser::DROP:\n-      case ClickHouseParser::ELSE:\n-      case ClickHouseParser::END:\n-      case ClickHouseParser::ENGINE:\n-      case ClickHouseParser::EVENTS:\n-      case ClickHouseParser::EXISTS:\n-      case ClickHouseParser::EXPLAIN:\n-      case ClickHouseParser::EXPRESSION:\n-      case ClickHouseParser::EXTRACT:\n-      case ClickHouseParser::FETCHES:\n-      case ClickHouseParser::FINAL:\n-      case ClickHouseParser::FIRST:\n-      case ClickHouseParser::FLUSH:\n-      case ClickHouseParser::FOR:\n-      case ClickHouseParser::FORMAT:\n-      case ClickHouseParser::FREEZE:\n-      case ClickHouseParser::FROM:\n-      case ClickHouseParser::FULL:\n-      case ClickHouseParser::FUNCTION:\n-      case ClickHouseParser::GLOBAL:\n-      case ClickHouseParser::GRANULARITY:\n-      case ClickHouseParser::GROUP:\n-      case ClickHouseParser::HAVING:\n-      case ClickHouseParser::HIERARCHICAL:\n-      case ClickHouseParser::HOUR:\n-      case ClickHouseParser::ID:\n-      case ClickHouseParser::IF:\n-      case ClickHouseParser::ILIKE:\n-      case ClickHouseParser::IN:\n-      case ClickHouseParser::INDEX:\n-      case ClickHouseParser::INJECTIVE:\n-      case ClickHouseParser::INNER:\n-      case ClickHouseParser::INSERT:\n-      case ClickHouseParser::INTERVAL:\n-      case ClickHouseParser::INTO:\n-      case ClickHouseParser::IS:\n-      case ClickHouseParser::IS_OBJECT_ID:\n-      case ClickHouseParser::JOIN:\n-      case ClickHouseParser::KEY:\n-      case ClickHouseParser::KILL:\n-      case ClickHouseParser::LAST:\n-      case ClickHouseParser::LAYOUT:\n-      case ClickHouseParser::LEADING:\n-      case ClickHouseParser::LEFT:\n-      case ClickHouseParser::LIFETIME:\n-      case ClickHouseParser::LIKE:\n-      case ClickHouseParser::LIMIT:\n-      case ClickHouseParser::LIVE:\n-      case ClickHouseParser::LOCAL:\n-      case ClickHouseParser::LOGS:\n-      case ClickHouseParser::MATERIALIZE:\n-      case ClickHouseParser::MATERIALIZED:\n-      case ClickHouseParser::MAX:\n-      case ClickHouseParser::MERGES:\n-      case ClickHouseParser::MIN:\n-      case ClickHouseParser::MINUTE:\n-      case ClickHouseParser::MODIFY:\n-      case ClickHouseParser::MONTH:\n-      case ClickHouseParser::MOVE:\n-      case ClickHouseParser::MUTATION:\n-      case ClickHouseParser::NO:\n-      case ClickHouseParser::NOT:\n-      case ClickHouseParser::NULLS:\n-      case ClickHouseParser::OFFSET:\n-      case ClickHouseParser::ON:\n-      case ClickHouseParser::OPTIMIZE:\n-      case ClickHouseParser::OR:\n-      case ClickHouseParser::ORDER:\n-      case ClickHouseParser::OUTER:\n-      case ClickHouseParser::OUTFILE:\n-      case ClickHouseParser::PARTITION:\n-      case ClickHouseParser::POPULATE:\n-      case ClickHouseParser::PREWHERE:\n-      case ClickHouseParser::PRIMARY:\n-      case ClickHouseParser::QUARTER:\n-      case ClickHouseParser::RANGE:\n-      case ClickHouseParser::RELOAD:\n-      case ClickHouseParser::REMOVE:\n-      case ClickHouseParser::RENAME:\n-      case ClickHouseParser::REPLACE:\n-      case ClickHouseParser::REPLICA:\n-      case ClickHouseParser::REPLICATED:\n-      case ClickHouseParser::RIGHT:\n-      case ClickHouseParser::ROLLUP:\n-      case ClickHouseParser::SAMPLE:\n-      case ClickHouseParser::SECOND:\n-      case ClickHouseParser::SELECT:\n-      case ClickHouseParser::SEMI:\n-      case ClickHouseParser::SENDS:\n-      case ClickHouseParser::SET:\n-      case ClickHouseParser::SETTINGS:\n-      case ClickHouseParser::SHOW:\n-      case ClickHouseParser::SOURCE:\n-      case ClickHouseParser::START:\n-      case ClickHouseParser::STOP:\n-      case ClickHouseParser::SUBSTRING:\n-      case ClickHouseParser::SYNC:\n-      case ClickHouseParser::SYNTAX:\n-      case ClickHouseParser::SYSTEM:\n-      case ClickHouseParser::TABLE:\n-      case ClickHouseParser::TABLES:\n-      case ClickHouseParser::TEMPORARY:\n-      case ClickHouseParser::TEST:\n-      case ClickHouseParser::THEN:\n-      case ClickHouseParser::TIES:\n-      case ClickHouseParser::TIMEOUT:\n-      case ClickHouseParser::TIMESTAMP:\n-      case ClickHouseParser::TO:\n-      case ClickHouseParser::TOP:\n-      case ClickHouseParser::TOTALS:\n-      case ClickHouseParser::TRAILING:\n-      case ClickHouseParser::TRIM:\n-      case ClickHouseParser::TRUNCATE:\n-      case ClickHouseParser::TTL:\n-      case ClickHouseParser::TYPE:\n-      case ClickHouseParser::UNION:\n-      case ClickHouseParser::UPDATE:\n-      case ClickHouseParser::USE:\n-      case ClickHouseParser::USING:\n-      case ClickHouseParser::UUID:\n-      case ClickHouseParser::VALUES:\n-      case ClickHouseParser::VIEW:\n-      case ClickHouseParser::VOLUME:\n-      case ClickHouseParser::WATCH:\n-      case ClickHouseParser::WEEK:\n-      case ClickHouseParser::WHEN:\n-      case ClickHouseParser::WHERE:\n-      case ClickHouseParser::WITH:\n-      case ClickHouseParser::YEAR:\n-      case ClickHouseParser::JSON_FALSE:\n-      case ClickHouseParser::JSON_TRUE:\n-      case ClickHouseParser::IDENTIFIER: {\n-        enterOuterAlt(_localctx, 1);\n-        setState(1907);\n-        identifier();\n-        break;\n-      }\n-\n-      case ClickHouseParser::NULL_SQL: {\n-        enterOuterAlt(_localctx, 2);\n-        setState(1908);\n-        match(ClickHouseParser::NULL_SQL);\n-        break;\n-      }\n-\n-    default:\n-      throw NoViableAltException(this);\n-    }\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-//----------------- EnumValueContext ------------------------------------------------------------------\n-\n-ClickHouseParser::EnumValueContext::EnumValueContext(ParserRuleContext *parent, size_t invokingState)\n-  : ParserRuleContext(parent, invokingState) {\n-}\n-\n-tree::TerminalNode* ClickHouseParser::EnumValueContext::STRING_LITERAL() {\n-  return getToken(ClickHouseParser::STRING_LITERAL, 0);\n-}\n-\n-tree::TerminalNode* ClickHouseParser::EnumValueContext::EQ_SINGLE() {\n-  return getToken(ClickHouseParser::EQ_SINGLE, 0);\n-}\n-\n-ClickHouseParser::NumberLiteralContext* ClickHouseParser::EnumValueContext::numberLiteral() {\n-  return getRuleContext<ClickHouseParser::NumberLiteralContext>(0);\n-}\n-\n-\n-size_t ClickHouseParser::EnumValueContext::getRuleIndex() const {\n-  return ClickHouseParser::RuleEnumValue;\n-}\n-\n-antlrcpp::Any ClickHouseParser::EnumValueContext::accept(tree::ParseTreeVisitor *visitor) {\n-  if (auto parserVisitor = dynamic_cast<ClickHouseParserVisitor*>(visitor))\n-    return parserVisitor->visitEnumValue(this);\n-  else\n-    return visitor->visitChildren(this);\n-}\n-\n-ClickHouseParser::EnumValueContext* ClickHouseParser::enumValue() {\n-  EnumValueContext *_localctx = _tracker.createInstance<EnumValueContext>(_ctx, getState());\n-  enterRule(_localctx, 216, ClickHouseParser::RuleEnumValue);\n-\n-  auto onExit = finally([=] {\n-    exitRule();\n-  });\n-  try {\n-    enterOuterAlt(_localctx, 1);\n-    setState(1911);\n-    match(ClickHouseParser::STRING_LITERAL);\n-    setState(1912);\n-    match(ClickHouseParser::EQ_SINGLE);\n-    setState(1913);\n-    numberLiteral();\n-   \n-  }\n-  catch (RecognitionException &e) {\n-    _errHandler->reportError(this, e);\n-    _localctx->exception = std::current_exception();\n-    _errHandler->recover(this, _localctx->exception);\n-  }\n-\n-  return _localctx;\n-}\n-\n-bool ClickHouseParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {\n-  switch (ruleIndex) {\n-    case 12: return dictionaryAttrDfntSempred(dynamic_cast<DictionaryAttrDfntContext *>(context), predicateIndex);\n-    case 13: return dictionaryEngineClauseSempred(dynamic_cast<DictionaryEngineClauseContext *>(context), predicateIndex);\n-    case 26: return engineClauseSempred(dynamic_cast<EngineClauseContext *>(context), predicateIndex);\n-    case 67: return joinExprSempred(dynamic_cast<JoinExprContext *>(context), predicateIndex);\n-    case 87: return columnExprSempred(dynamic_cast<ColumnExprContext *>(context), predicateIndex);\n-    case 93: return tableExprSempred(dynamic_cast<TableExprContext *>(context), predicateIndex);\n-\n-  default:\n-    break;\n-  }\n-  return true;\n-}\n-\n-bool ClickHouseParser::dictionaryAttrDfntSempred(DictionaryAttrDfntContext *_localctx, size_t predicateIndex) {\n-  switch (predicateIndex) {\n-    case 0: return !_localctx->attrs.count(\"default\");\n-    case 1: return !_localctx->attrs.count(\"expression\");\n-    case 2: return !_localctx->attrs.count(\"hierarchical\");\n-    case 3: return !_localctx->attrs.count(\"injective\");\n-    case 4: return !_localctx->attrs.count(\"is_object_id\");\n-\n-  default:\n-    break;\n-  }\n-  return true;\n-}\n-\n-bool ClickHouseParser::dictionaryEngineClauseSempred(DictionaryEngineClauseContext *_localctx, size_t predicateIndex) {\n-  switch (predicateIndex) {\n-    case 5: return !_localctx->clauses.count(\"source\");\n-    case 6: return !_localctx->clauses.count(\"lifetime\");\n-    case 7: return !_localctx->clauses.count(\"layout\");\n-    case 8: return !_localctx->clauses.count(\"range\");\n-    case 9: return !_localctx->clauses.count(\"settings\");\n-\n-  default:\n-    break;\n-  }\n-  return true;\n-}\n-\n-bool ClickHouseParser::engineClauseSempred(EngineClauseContext *_localctx, size_t predicateIndex) {\n-  switch (predicateIndex) {\n-    case 10: return !_localctx->clauses.count(\"orderByClause\");\n-    case 11: return !_localctx->clauses.count(\"partitionByClause\");\n-    case 12: return !_localctx->clauses.count(\"primaryKeyClause\");\n-    case 13: return !_localctx->clauses.count(\"sampleByClause\");\n-    case 14: return !_localctx->clauses.count(\"ttlClause\");\n-    case 15: return !_localctx->clauses.count(\"settingsClause\");\n-\n-  default:\n-    break;\n-  }\n-  return true;\n-}\n-\n-bool ClickHouseParser::joinExprSempred(JoinExprContext *_localctx, size_t predicateIndex) {\n-  switch (predicateIndex) {\n-    case 16: return precpred(_ctx, 3);\n-    case 17: return precpred(_ctx, 4);\n-\n-  default:\n-    break;\n-  }\n-  return true;\n-}\n-\n-bool ClickHouseParser::columnExprSempred(ColumnExprContext *_localctx, size_t predicateIndex) {\n-  switch (predicateIndex) {\n-    case 18: return precpred(_ctx, 16);\n-    case 19: return precpred(_ctx, 15);\n-    case 20: return precpred(_ctx, 14);\n-    case 21: return precpred(_ctx, 11);\n-    case 22: return precpred(_ctx, 10);\n-    case 23: return precpred(_ctx, 9);\n-    case 24: return precpred(_ctx, 8);\n-    case 25: return precpred(_ctx, 19);\n-    case 26: return precpred(_ctx, 18);\n-    case 27: return precpred(_ctx, 13);\n-    case 28: return precpred(_ctx, 7);\n-\n-  default:\n-    break;\n-  }\n-  return true;\n-}\n-\n-bool ClickHouseParser::tableExprSempred(TableExprContext *_localctx, size_t predicateIndex) {\n-  switch (predicateIndex) {\n-    case 29: return precpred(_ctx, 1);\n-\n-  default:\n-    break;\n-  }\n-  return true;\n-}\n-\n-// Static vars and initialization.\n-std::vector<dfa::DFA> ClickHouseParser::_decisionToDFA;\n-atn::PredictionContextCache ClickHouseParser::_sharedContextCache;\n-\n-// We own the ATN which in turn owns the ATN states.\n-atn::ATN ClickHouseParser::_atn;\n-std::vector<uint16_t> ClickHouseParser::_serializedATN;\n-\n-std::vector<std::string> ClickHouseParser::_ruleNames = {\n-  \"queryStmt\", \"query\", \"alterStmt\", \"alterTableClause\", \"assignmentExprList\", \n-  \"assignmentExpr\", \"tableColumnPropertyType\", \"partitionClause\", \"attachStmt\", \n-  \"checkStmt\", \"createStmt\", \"dictionarySchemaClause\", \"dictionaryAttrDfnt\", \n-  \"dictionaryEngineClause\", \"dictionaryPrimaryKeyClause\", \"dictionaryArgExpr\", \n-  \"sourceClause\", \"lifetimeClause\", \"layoutClause\", \"rangeClause\", \"dictionarySettingsClause\", \n-  \"clusterClause\", \"uuidClause\", \"destinationClause\", \"subqueryClause\", \n-  \"tableSchemaClause\", \"engineClause\", \"partitionByClause\", \"primaryKeyClause\", \n-  \"sampleByClause\", \"ttlClause\", \"engineExpr\", \"tableElementExpr\", \"tableColumnDfnt\", \n-  \"tableColumnPropertyExpr\", \"tableIndexDfnt\", \"tableProjectionDfnt\", \"codecExpr\", \n-  \"codecArgExpr\", \"ttlExpr\", \"describeStmt\", \"dropStmt\", \"existsStmt\", \"explainStmt\", \n-  \"insertStmt\", \"columnsClause\", \"dataClause\", \"killStmt\", \"optimizeStmt\", \n-  \"renameStmt\", \"projectionSelectStmt\", \"selectUnionStmt\", \"selectStmtWithParens\", \n-  \"selectStmt\", \"withClause\", \"topClause\", \"fromClause\", \"arrayJoinClause\", \n-  \"prewhereClause\", \"whereClause\", \"groupByClause\", \"havingClause\", \"orderByClause\", \n-  \"projectionOrderByClause\", \"limitByClause\", \"limitClause\", \"settingsClause\", \n-  \"joinExpr\", \"joinOp\", \"joinOpCross\", \"joinConstraintClause\", \"sampleClause\", \n-  \"limitExpr\", \"orderExprList\", \"orderExpr\", \"ratioExpr\", \"settingExprList\", \n-  \"settingExpr\", \"setStmt\", \"showStmt\", \"systemStmt\", \"truncateStmt\", \"useStmt\", \n-  \"watchStmt\", \"columnTypeExpr\", \"columnExprList\", \"columnsExpr\", \"columnExpr\", \n-  \"columnArgList\", \"columnArgExpr\", \"columnLambdaExpr\", \"columnIdentifier\", \n-  \"nestedIdentifier\", \"tableExpr\", \"tableFunctionExpr\", \"tableIdentifier\", \n-  \"tableArgList\", \"tableArgExpr\", \"databaseIdentifier\", \"floatingLiteral\", \n-  \"numberLiteral\", \"literal\", \"interval\", \"keyword\", \"keywordForAlias\", \n-  \"alias\", \"identifier\", \"identifierOrNull\", \"enumValue\"\n-};\n-\n-std::vector<std::string> ClickHouseParser::_literalNames = {\n-  \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \n-  \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \n-  \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \n-  \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \n-  \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \n-  \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \n-  \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \n-  \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \n-  \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \n-  \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \n-  \"\", \"\", \"'false'\", \"'true'\", \"\", \"\", \"\", \"\", \"\", \"\", \"'->'\", \"'*'\", \"'`'\", \n-  \"'\\\\'\", \"':'\", \"','\", \"'||'\", \"'-'\", \"'.'\", \"'=='\", \"'='\", \"'>='\", \"'>'\", \n-  \"'{'\", \"'['\", \"'<='\", \"'('\", \"'<'\", \"\", \"'%'\", \"'+'\", \"'?'\", \"'\\\"'\", \"'''\", \n-  \"'}'\", \"']'\", \"')'\", \"';'\", \"'/'\", \"'_'\"\n-};\n-\n-std::vector<std::string> ClickHouseParser::_symbolicNames = {\n-  \"\", \"ADD\", \"AFTER\", \"ALIAS\", \"ALL\", \"ALTER\", \"AND\", \"ANTI\", \"ANY\", \"ARRAY\", \n-  \"AS\", \"ASCENDING\", \"ASOF\", \"AST\", \"ASYNC\", \"ATTACH\", \"BETWEEN\", \"BOTH\", \n-  \"BY\", \"CASE\", \"CAST\", \"CHECK\", \"CLEAR\", \"CLUSTER\", \"CODEC\", \"COLLATE\", \n-  \"COLUMN\", \"COMMENT\", \"CONSTRAINT\", \"CREATE\", \"CROSS\", \"CUBE\", \"DATABASE\", \n-  \"DATABASES\", \"DATE\", \"DAY\", \"DEDUPLICATE\", \"DEFAULT\", \"DELAY\", \"DELETE\", \n-  \"DESC\", \"DESCENDING\", \"DESCRIBE\", \"DETACH\", \"DICTIONARIES\", \"DICTIONARY\", \n-  \"DISK\", \"DISTINCT\", \"DISTRIBUTED\", \"DROP\", \"ELSE\", \"END\", \"ENGINE\", \"EVENTS\", \n-  \"EXISTS\", \"EXPLAIN\", \"EXPRESSION\", \"EXTRACT\", \"FETCHES\", \"FINAL\", \"FIRST\", \n-  \"FLUSH\", \"FOR\", \"FORMAT\", \"FREEZE\", \"FROM\", \"FULL\", \"FUNCTION\", \"GLOBAL\", \n-  \"GRANULARITY\", \"GROUP\", \"HAVING\", \"HIERARCHICAL\", \"HOUR\", \"ID\", \"IF\", \n-  \"ILIKE\", \"IN\", \"INDEX\", \"INF\", \"INJECTIVE\", \"INNER\", \"INSERT\", \"INTERVAL\", \n-  \"INTO\", \"IS\", \"IS_OBJECT_ID\", \"JOIN\", \"KEY\", \"KILL\", \"LAST\", \"LAYOUT\", \n-  \"LEADING\", \"LEFT\", \"LIFETIME\", \"LIKE\", \"LIMIT\", \"LIVE\", \"LOCAL\", \"LOGS\", \n-  \"MATERIALIZE\", \"MATERIALIZED\", \"MAX\", \"MERGES\", \"MIN\", \"MINUTE\", \"MODIFY\", \n-  \"MONTH\", \"MOVE\", \"MUTATION\", \"NAN_SQL\", \"NO\", \"NOT\", \"NULL_SQL\", \"NULLS\", \n-  \"OFFSET\", \"ON\", \"OPTIMIZE\", \"OR\", \"ORDER\", \"OUTER\", \"OUTFILE\", \"PARTITION\", \n-  \"POPULATE\", \"PREWHERE\", \"PRIMARY\", \"PROJECTION\", \"QUARTER\", \"RANGE\", \"RELOAD\", \n-  \"REMOVE\", \"RENAME\", \"REPLACE\", \"REPLICA\", \"REPLICATED\", \"RIGHT\", \"ROLLUP\", \n-  \"SAMPLE\", \"SECOND\", \"SELECT\", \"SEMI\", \"SENDS\", \"SET\", \"SETTINGS\", \"SHOW\", \n-  \"SOURCE\", \"START\", \"STOP\", \"SUBSTRING\", \"SYNC\", \"SYNTAX\", \"SYSTEM\", \"TABLE\", \n-  \"TABLES\", \"TEMPORARY\", \"TEST\", \"THEN\", \"TIES\", \"TIMEOUT\", \"TIMESTAMP\", \n-  \"TO\", \"TOP\", \"TOTALS\", \"TRAILING\", \"TRIM\", \"TRUNCATE\", \"TTL\", \"TYPE\", \n-  \"UNION\", \"UPDATE\", \"USE\", \"USING\", \"UUID\", \"VALUES\", \"VIEW\", \"VOLUME\", \n-  \"WATCH\", \"WEEK\", \"WHEN\", \"WHERE\", \"WITH\", \"YEAR\", \"JSON_FALSE\", \"JSON_TRUE\", \n-  \"IDENTIFIER\", \"FLOATING_LITERAL\", \"OCTAL_LITERAL\", \"DECIMAL_LITERAL\", \n-  \"HEXADECIMAL_LITERAL\", \"STRING_LITERAL\", \"ARROW\", \"ASTERISK\", \"BACKQUOTE\", \n-  \"BACKSLASH\", \"COLON\", \"COMMA\", \"CONCAT\", \"DASH\", \"DOT\", \"EQ_DOUBLE\", \"EQ_SINGLE\", \n-  \"GE\", \"GT\", \"LBRACE\", \"LBRACKET\", \"LE\", \"LPAREN\", \"LT\", \"NOT_EQ\", \"PERCENT\", \n-  \"PLUS\", \"QUERY\", \"QUOTE_DOUBLE\", \"QUOTE_SINGLE\", \"RBRACE\", \"RBRACKET\", \n-  \"RPAREN\", \"SEMICOLON\", \"SLASH\", \"UNDERSCORE\", \"MULTI_LINE_COMMENT\", \"SINGLE_LINE_COMMENT\", \n-  \"WHITESPACE\"\n-};\n-\n-dfa::Vocabulary ClickHouseParser::_vocabulary(_literalNames, _symbolicNames);\n-\n-std::vector<std::string> ClickHouseParser::_tokenNames;\n-\n-ClickHouseParser::Initializer::Initializer() {\n-\tfor (size_t i = 0; i < _symbolicNames.size(); ++i) {\n-\t\tstd::string name = _vocabulary.getLiteralName(i);\n-\t\tif (name.empty()) {\n-\t\t\tname = _vocabulary.getSymbolicName(i);\n-\t\t}\n-\n-\t\tif (name.empty()) {\n-\t\t\t_tokenNames.push_back(\"<INVALID>\");\n-\t\t} else {\n-      _tokenNames.push_back(name);\n-    }\n-\t}\n-\n-  _serializedATN = {\n-    0x3, 0x608b, 0xa72a, 0x8133, 0xb9ed, 0x417c, 0x3be7, 0x7786, 0x5964, \n-    0x3, 0xe0, 0x77e, 0x4, 0x2, 0x9, 0x2, 0x4, 0x3, 0x9, 0x3, 0x4, 0x4, \n-    0x9, 0x4, 0x4, 0x5, 0x9, 0x5, 0x4, 0x6, 0x9, 0x6, 0x4, 0x7, 0x9, 0x7, \n-    0x4, 0x8, 0x9, 0x8, 0x4, 0x9, 0x9, 0x9, 0x4, 0xa, 0x9, 0xa, 0x4, 0xb, \n-    0x9, 0xb, 0x4, 0xc, 0x9, 0xc, 0x4, 0xd, 0x9, 0xd, 0x4, 0xe, 0x9, 0xe, \n-    0x4, 0xf, 0x9, 0xf, 0x4, 0x10, 0x9, 0x10, 0x4, 0x11, 0x9, 0x11, 0x4, \n-    0x12, 0x9, 0x12, 0x4, 0x13, 0x9, 0x13, 0x4, 0x14, 0x9, 0x14, 0x4, 0x15, \n-    0x9, 0x15, 0x4, 0x16, 0x9, 0x16, 0x4, 0x17, 0x9, 0x17, 0x4, 0x18, 0x9, \n-    0x18, 0x4, 0x19, 0x9, 0x19, 0x4, 0x1a, 0x9, 0x1a, 0x4, 0x1b, 0x9, 0x1b, \n-    0x4, 0x1c, 0x9, 0x1c, 0x4, 0x1d, 0x9, 0x1d, 0x4, 0x1e, 0x9, 0x1e, 0x4, \n-    0x1f, 0x9, 0x1f, 0x4, 0x20, 0x9, 0x20, 0x4, 0x21, 0x9, 0x21, 0x4, 0x22, \n-    0x9, 0x22, 0x4, 0x23, 0x9, 0x23, 0x4, 0x24, 0x9, 0x24, 0x4, 0x25, 0x9, \n-    0x25, 0x4, 0x26, 0x9, 0x26, 0x4, 0x27, 0x9, 0x27, 0x4, 0x28, 0x9, 0x28, \n-    0x4, 0x29, 0x9, 0x29, 0x4, 0x2a, 0x9, 0x2a, 0x4, 0x2b, 0x9, 0x2b, 0x4, \n-    0x2c, 0x9, 0x2c, 0x4, 0x2d, 0x9, 0x2d, 0x4, 0x2e, 0x9, 0x2e, 0x4, 0x2f, \n-    0x9, 0x2f, 0x4, 0x30, 0x9, 0x30, 0x4, 0x31, 0x9, 0x31, 0x4, 0x32, 0x9, \n-    0x32, 0x4, 0x33, 0x9, 0x33, 0x4, 0x34, 0x9, 0x34, 0x4, 0x35, 0x9, 0x35, \n-    0x4, 0x36, 0x9, 0x36, 0x4, 0x37, 0x9, 0x37, 0x4, 0x38, 0x9, 0x38, 0x4, \n-    0x39, 0x9, 0x39, 0x4, 0x3a, 0x9, 0x3a, 0x4, 0x3b, 0x9, 0x3b, 0x4, 0x3c, \n-    0x9, 0x3c, 0x4, 0x3d, 0x9, 0x3d, 0x4, 0x3e, 0x9, 0x3e, 0x4, 0x3f, 0x9, \n-    0x3f, 0x4, 0x40, 0x9, 0x40, 0x4, 0x41, 0x9, 0x41, 0x4, 0x42, 0x9, 0x42, \n-    0x4, 0x43, 0x9, 0x43, 0x4, 0x44, 0x9, 0x44, 0x4, 0x45, 0x9, 0x45, 0x4, \n-    0x46, 0x9, 0x46, 0x4, 0x47, 0x9, 0x47, 0x4, 0x48, 0x9, 0x48, 0x4, 0x49, \n-    0x9, 0x49, 0x4, 0x4a, 0x9, 0x4a, 0x4, 0x4b, 0x9, 0x4b, 0x4, 0x4c, 0x9, \n-    0x4c, 0x4, 0x4d, 0x9, 0x4d, 0x4, 0x4e, 0x9, 0x4e, 0x4, 0x4f, 0x9, 0x4f, \n-    0x4, 0x50, 0x9, 0x50, 0x4, 0x51, 0x9, 0x51, 0x4, 0x52, 0x9, 0x52, 0x4, \n-    0x53, 0x9, 0x53, 0x4, 0x54, 0x9, 0x54, 0x4, 0x55, 0x9, 0x55, 0x4, 0x56, \n-    0x9, 0x56, 0x4, 0x57, 0x9, 0x57, 0x4, 0x58, 0x9, 0x58, 0x4, 0x59, 0x9, \n-    0x59, 0x4, 0x5a, 0x9, 0x5a, 0x4, 0x5b, 0x9, 0x5b, 0x4, 0x5c, 0x9, 0x5c, \n-    0x4, 0x5d, 0x9, 0x5d, 0x4, 0x5e, 0x9, 0x5e, 0x4, 0x5f, 0x9, 0x5f, 0x4, \n-    0x60, 0x9, 0x60, 0x4, 0x61, 0x9, 0x61, 0x4, 0x62, 0x9, 0x62, 0x4, 0x63, \n-    0x9, 0x63, 0x4, 0x64, 0x9, 0x64, 0x4, 0x65, 0x9, 0x65, 0x4, 0x66, 0x9, \n-    0x66, 0x4, 0x67, 0x9, 0x67, 0x4, 0x68, 0x9, 0x68, 0x4, 0x69, 0x9, 0x69, \n-    0x4, 0x6a, 0x9, 0x6a, 0x4, 0x6b, 0x9, 0x6b, 0x4, 0x6c, 0x9, 0x6c, 0x4, \n-    0x6d, 0x9, 0x6d, 0x4, 0x6e, 0x9, 0x6e, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, \n-    0x3, 0x2, 0x5, 0x2, 0xe1, 0xa, 0x2, 0x3, 0x2, 0x3, 0x2, 0x5, 0x2, 0xe5, \n-    0xa, 0x2, 0x3, 0x2, 0x5, 0x2, 0xe8, 0xa, 0x2, 0x3, 0x2, 0x5, 0x2, 0xeb, \n-    0xa, 0x2, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, \n-    0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, \n-    0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x5, 0x3, 0xff, 0xa, \n-    0x3, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x5, 0x4, 0x105, 0xa, 0x4, \n-    0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x7, 0x4, 0x10a, 0xa, 0x4, 0xc, 0x4, 0xe, \n-    0x4, 0x10d, 0xb, 0x4, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, \n-    0x5, 0x5, 0x114, 0xa, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x119, \n-    0xa, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, \n-    0x120, 0xa, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x125, 0xa, \n-    0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x12c, \n-    0xa, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x131, 0xa, 0x5, 0x3, \n-    0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x137, 0xa, 0x5, 0x3, 0x5, \n-    0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x13d, 0xa, 0x5, 0x3, 0x5, 0x3, \n-    0x5, 0x3, 0x5, 0x5, 0x5, 0x142, 0xa, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, \n-    0x3, 0x5, 0x5, 0x5, 0x148, 0xa, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, \n-    0x5, 0x14d, 0xa, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, \n-    0x153, 0xa, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x158, 0xa, \n-    0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x15e, 0xa, 0x5, \n-    0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, \n-    0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x16c, 0xa, \n-    0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x173, \n-    0xa, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, \n-    0x17a, 0xa, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, \n-    0x5, 0x181, 0xa, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, \n-    0x187, 0xa, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x18c, 0xa, \n-    0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x192, 0xa, 0x5, \n-    0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x197, 0xa, 0x5, 0x3, 0x5, 0x3, \n-    0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x19d, 0xa, 0x5, 0x3, 0x5, 0x3, 0x5, \n-    0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x1a6, 0xa, \n-    0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, \n-    0x5, 0x3, 0x5, 0x5, 0x5, 0x1b0, 0xa, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, \n-    0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x1ba, 0xa, \n-    0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, \n-    0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, \n-    0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x1ce, 0xa, 0x5, \n-    0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, \n-    0x1d6, 0xa, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, \n-    0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, \n-    0x5, 0x5, 0x5, 0x1e5, 0xa, 0x5, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x7, 0x6, \n-    0x1ea, 0xa, 0x6, 0xc, 0x6, 0xe, 0x6, 0x1ed, 0xb, 0x6, 0x3, 0x7, 0x3, \n-    0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 0x8, 0x3, 0x8, 0x3, 0x9, 0x3, 0x9, 0x3, \n-    0x9, 0x3, 0x9, 0x3, 0x9, 0x5, 0x9, 0x1fa, 0xa, 0x9, 0x3, 0xa, 0x3, 0xa, \n-    0x3, 0xa, 0x3, 0xa, 0x5, 0xa, 0x200, 0xa, 0xa, 0x3, 0xb, 0x3, 0xb, 0x3, \n-    0xb, 0x3, 0xb, 0x5, 0xb, 0x206, 0xa, 0xb, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, \n-    0x3, 0xc, 0x3, 0xc, 0x5, 0xc, 0x20d, 0xa, 0xc, 0x3, 0xc, 0x3, 0xc, 0x5, \n-    0xc, 0x211, 0xa, 0xc, 0x3, 0xc, 0x5, 0xc, 0x214, 0xa, 0xc, 0x3, 0xc, \n-    0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x5, 0xc, 0x21b, 0xa, 0xc, 0x3, \n-    0xc, 0x3, 0xc, 0x5, 0xc, 0x21f, 0xa, 0xc, 0x3, 0xc, 0x5, 0xc, 0x222, \n-    0xa, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, \n-    0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x5, 0xc, 0x22d, 0xa, 0xc, 0x3, 0xc, 0x3, \n-    0xc, 0x5, 0xc, 0x231, 0xa, 0xc, 0x3, 0xc, 0x5, 0xc, 0x234, 0xa, 0xc, \n-    0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x5, 0xc, 0x239, 0xa, 0xc, 0x5, 0xc, 0x23b, \n-    0xa, 0xc, 0x3, 0xc, 0x5, 0xc, 0x23e, 0xa, 0xc, 0x3, 0xc, 0x5, 0xc, 0x241, \n-    0xa, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, \n-    0x3, 0xc, 0x3, 0xc, 0x5, 0xc, 0x24b, 0xa, 0xc, 0x3, 0xc, 0x3, 0xc, 0x5, \n-    0xc, 0x24f, 0xa, 0xc, 0x3, 0xc, 0x5, 0xc, 0x252, 0xa, 0xc, 0x3, 0xc, \n-    0x5, 0xc, 0x255, 0xa, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x5, 0xc, 0x25a, \n-    0xa, 0xc, 0x5, 0xc, 0x25c, 0xa, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, \n-    0xc, 0x5, 0xc, 0x262, 0xa, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, \n-    0x5, 0xc, 0x268, 0xa, 0xc, 0x3, 0xc, 0x3, 0xc, 0x5, 0xc, 0x26c, 0xa, \n-    0xc, 0x3, 0xc, 0x5, 0xc, 0x26f, 0xa, 0xc, 0x3, 0xc, 0x5, 0xc, 0x272, \n-    0xa, 0xc, 0x3, 0xc, 0x5, 0xc, 0x275, 0xa, 0xc, 0x3, 0xc, 0x5, 0xc, 0x278, \n-    0xa, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x5, 0xc, 0x27d, 0xa, 0xc, 0x3, \n-    0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x5, 0xc, 0x283, 0xa, 0xc, 0x3, 0xc, \n-    0x3, 0xc, 0x5, 0xc, 0x287, 0xa, 0xc, 0x3, 0xc, 0x5, 0xc, 0x28a, 0xa, \n-    0xc, 0x3, 0xc, 0x5, 0xc, 0x28d, 0xa, 0xc, 0x3, 0xc, 0x3, 0xc, 0x5, 0xc, \n-    0x291, 0xa, 0xc, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 0x7, 0xd, 0x297, \n-    0xa, 0xd, 0xc, 0xd, 0xe, 0xd, 0x29a, 0xb, 0xd, 0x3, 0xd, 0x3, 0xd, 0x3, \n-    0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x3, \n-    0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x3, \n-    0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x7, \n-    0xe, 0x2b3, 0xa, 0xe, 0xc, 0xe, 0xe, 0xe, 0x2b6, 0xb, 0xe, 0x3, 0xf, \n-    0x5, 0xf, 0x2b9, 0xa, 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, \n-    0xf, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, \n-    0xf, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, 0xf, 0x3, \n-    0xf, 0x3, 0xf, 0x7, 0xf, 0x2cf, 0xa, 0xf, 0xc, 0xf, 0xe, 0xf, 0x2d2, \n-    0xb, 0xf, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x11, 0x3, \n-    0x11, 0x3, 0x11, 0x3, 0x11, 0x5, 0x11, 0x2dc, 0xa, 0x11, 0x3, 0x11, \n-    0x5, 0x11, 0x2df, 0xa, 0x11, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, \n-    0x3, 0x12, 0x7, 0x12, 0x2e6, 0xa, 0x12, 0xc, 0x12, 0xe, 0x12, 0x2e9, \n-    0xb, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x13, 0x3, 0x13, 0x3, \n-    0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, \n-    0x3, 0x13, 0x3, 0x13, 0x5, 0x13, 0x2f9, 0xa, 0x13, 0x3, 0x13, 0x3, 0x13, \n-    0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x7, 0x14, 0x302, \n-    0xa, 0x14, 0xc, 0x14, 0xe, 0x14, 0x305, 0xb, 0x14, 0x3, 0x14, 0x3, 0x14, \n-    0x3, 0x14, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, \n-    0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, \n-    0x5, 0x15, 0x316, 0xa, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x16, 0x3, 0x16, \n-    0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 0x3, \n-    0x17, 0x5, 0x17, 0x323, 0xa, 0x17, 0x3, 0x18, 0x3, 0x18, 0x3, 0x18, \n-    0x3, 0x19, 0x3, 0x19, 0x3, 0x19, 0x3, 0x1a, 0x3, 0x1a, 0x3, 0x1a, 0x3, \n-    0x1b, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1b, 0x7, 0x1b, 0x332, 0xa, 0x1b, \n-    0xc, 0x1b, 0xe, 0x1b, 0x335, 0xb, 0x1b, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1b, \n-    0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1b, 0x5, 0x1b, 0x33d, 0xa, 0x1b, 0x3, 0x1c, \n-    0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x3, \n-    0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, \n-    0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x3, \n-    0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x7, 0x1c, 0x358, \n-    0xa, 0x1c, 0xc, 0x1c, 0xe, 0x1c, 0x35b, 0xb, 0x1c, 0x3, 0x1d, 0x3, 0x1d, \n-    0x3, 0x1d, 0x3, 0x1d, 0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x3, \n-    0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x3, 0x20, 0x3, 0x20, 0x3, 0x20, \n-    0x3, 0x20, 0x7, 0x20, 0x36d, 0xa, 0x20, 0xc, 0x20, 0xe, 0x20, 0x370, \n-    0xb, 0x20, 0x3, 0x21, 0x3, 0x21, 0x5, 0x21, 0x374, 0xa, 0x21, 0x3, 0x21, \n-    0x3, 0x21, 0x3, 0x21, 0x5, 0x21, 0x379, 0xa, 0x21, 0x3, 0x21, 0x5, 0x21, \n-    0x37c, 0xa, 0x21, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, \n-    0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x5, 0x22, 0x388, \n-    0xa, 0x22, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x5, 0x23, 0x38d, 0xa, 0x23, \n-    0x3, 0x23, 0x3, 0x23, 0x5, 0x23, 0x391, 0xa, 0x23, 0x3, 0x23, 0x5, 0x23, \n-    0x394, 0xa, 0x23, 0x3, 0x23, 0x3, 0x23, 0x5, 0x23, 0x398, 0xa, 0x23, \n-    0x3, 0x23, 0x3, 0x23, 0x5, 0x23, 0x39c, 0xa, 0x23, 0x3, 0x23, 0x3, 0x23, \n-    0x3, 0x23, 0x5, 0x23, 0x3a1, 0xa, 0x23, 0x3, 0x23, 0x5, 0x23, 0x3a4, \n-    0xa, 0x23, 0x3, 0x23, 0x3, 0x23, 0x5, 0x23, 0x3a8, 0xa, 0x23, 0x5, 0x23, \n-    0x3aa, 0xa, 0x23, 0x3, 0x24, 0x3, 0x24, 0x3, 0x24, 0x3, 0x25, 0x3, 0x25, \n-    0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x26, 0x3, \n-    0x26, 0x3, 0x26, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, \n-    0x7, 0x27, 0x3be, 0xa, 0x27, 0xc, 0x27, 0xe, 0x27, 0x3c1, 0xb, 0x27, \n-    0x3, 0x27, 0x3, 0x27, 0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 0x5, 0x28, 0x3c8, \n-    0xa, 0x28, 0x3, 0x28, 0x5, 0x28, 0x3cb, 0xa, 0x28, 0x3, 0x29, 0x3, 0x29, \n-    0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x5, \n-    0x29, 0x3d5, 0xa, 0x29, 0x3, 0x2a, 0x3, 0x2a, 0x5, 0x2a, 0x3d9, 0xa, \n-    0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, \n-    0x5, 0x2b, 0x3e1, 0xa, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x5, 0x2b, 0x3e5, \n-    0xa, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x5, 0x2b, 0x3ea, 0xa, 0x2b, \n-    0x3, 0x2b, 0x3, 0x2b, 0x5, 0x2b, 0x3ee, 0xa, 0x2b, 0x3, 0x2b, 0x3, 0x2b, \n-    0x5, 0x2b, 0x3f2, 0xa, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x5, 0x2b, 0x3f6, \n-    0xa, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x5, 0x2b, 0x3fa, 0xa, 0x2b, 0x5, 0x2b, \n-    0x3fc, 0xa, 0x2b, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, \n-    0x3, 0x2c, 0x5, 0x2c, 0x404, 0xa, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x5, 0x2c, \n-    0x408, 0xa, 0x2c, 0x3, 0x2c, 0x5, 0x2c, 0x40b, 0xa, 0x2c, 0x3, 0x2d, \n-    0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x5, 0x2d, 0x413, \n-    0xa, 0x2d, 0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x5, 0x2e, 0x418, 0xa, 0x2e, \n-    0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x5, 0x2e, 0x41d, 0xa, 0x2e, 0x3, 0x2e, \n-    0x5, 0x2e, 0x420, 0xa, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2f, 0x3, 0x2f, \n-    0x3, 0x2f, 0x3, 0x2f, 0x7, 0x2f, 0x428, 0xa, 0x2f, 0xc, 0x2f, 0xe, 0x2f, \n-    0x42b, 0xb, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, \n-    0x3, 0x30, 0x3, 0x30, 0x5, 0x30, 0x434, 0xa, 0x30, 0x3, 0x30, 0x3, 0x30, \n-    0x5, 0x30, 0x438, 0xa, 0x30, 0x3, 0x31, 0x3, 0x31, 0x3, 0x31, 0x5, 0x31, \n-    0x43d, 0xa, 0x31, 0x3, 0x31, 0x3, 0x31, 0x5, 0x31, 0x441, 0xa, 0x31, \n-    0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 0x5, 0x32, 0x447, 0xa, 0x32, \n-    0x3, 0x32, 0x5, 0x32, 0x44a, 0xa, 0x32, 0x3, 0x32, 0x5, 0x32, 0x44d, \n-    0xa, 0x32, 0x3, 0x32, 0x5, 0x32, 0x450, 0xa, 0x32, 0x3, 0x33, 0x3, 0x33, \n-    0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, \n-    0x33, 0x3, 0x33, 0x7, 0x33, 0x45c, 0xa, 0x33, 0xc, 0x33, 0xe, 0x33, \n-    0x45f, 0xb, 0x33, 0x3, 0x33, 0x5, 0x33, 0x462, 0xa, 0x33, 0x3, 0x34, \n-    0x3, 0x34, 0x5, 0x34, 0x466, 0xa, 0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 0x34, \n-    0x5, 0x34, 0x46b, 0xa, 0x34, 0x3, 0x34, 0x5, 0x34, 0x46e, 0xa, 0x34, \n-    0x3, 0x34, 0x3, 0x34, 0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 0x7, \n-    0x35, 0x476, 0xa, 0x35, 0xc, 0x35, 0xe, 0x35, 0x479, 0xb, 0x35, 0x3, \n-    0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 0x5, 0x36, 0x480, \n-    0xa, 0x36, 0x3, 0x37, 0x5, 0x37, 0x483, 0xa, 0x37, 0x3, 0x37, 0x3, 0x37, \n-    0x5, 0x37, 0x487, 0xa, 0x37, 0x3, 0x37, 0x5, 0x37, 0x48a, 0xa, 0x37, \n-    0x3, 0x37, 0x3, 0x37, 0x5, 0x37, 0x48e, 0xa, 0x37, 0x3, 0x37, 0x5, 0x37, \n-    0x491, 0xa, 0x37, 0x3, 0x37, 0x5, 0x37, 0x494, 0xa, 0x37, 0x3, 0x37, \n-    0x5, 0x37, 0x497, 0xa, 0x37, 0x3, 0x37, 0x5, 0x37, 0x49a, 0xa, 0x37, \n-    0x3, 0x37, 0x3, 0x37, 0x5, 0x37, 0x49e, 0xa, 0x37, 0x3, 0x37, 0x3, 0x37, \n-    0x5, 0x37, 0x4a2, 0xa, 0x37, 0x3, 0x37, 0x5, 0x37, 0x4a5, 0xa, 0x37, \n-    0x3, 0x37, 0x5, 0x37, 0x4a8, 0xa, 0x37, 0x3, 0x37, 0x5, 0x37, 0x4ab, \n-    0xa, 0x37, 0x3, 0x37, 0x5, 0x37, 0x4ae, 0xa, 0x37, 0x3, 0x37, 0x5, 0x37, \n-    0x4b1, 0xa, 0x37, 0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x39, 0x3, 0x39, \n-    0x3, 0x39, 0x3, 0x39, 0x5, 0x39, 0x4ba, 0xa, 0x39, 0x3, 0x3a, 0x3, 0x3a, \n-    0x3, 0x3a, 0x3, 0x3b, 0x5, 0x3b, 0x4c0, 0xa, 0x3b, 0x3, 0x3b, 0x3, 0x3b, \n-    0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3d, 0x3, \n-    0x3d, 0x3, 0x3d, 0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3e, \n-    0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x5, 0x3e, 0x4d4, 0xa, 0x3e, 0x3, 0x3f, \n-    0x3, 0x3f, 0x3, 0x3f, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, \n-    0x41, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, \n-    0x3, 0x42, 0x3, 0x42, 0x3, 0x43, 0x3, 0x43, 0x3, 0x43, 0x3, 0x43, 0x5, \n-    0x43, 0x4ea, 0xa, 0x43, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x45, \n-    0x3, 0x45, 0x3, 0x45, 0x5, 0x45, 0x4f2, 0xa, 0x45, 0x3, 0x45, 0x5, 0x45, \n-    0x4f5, 0xa, 0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x5, 0x45, \n-    0x4fb, 0xa, 0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, \n-    0x3, 0x45, 0x5, 0x45, 0x503, 0xa, 0x45, 0x3, 0x45, 0x5, 0x45, 0x506, \n-    0xa, 0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x7, 0x45, 0x50c, \n-    0xa, 0x45, 0xc, 0x45, 0xe, 0x45, 0x50f, 0xb, 0x45, 0x3, 0x46, 0x5, 0x46, \n-    0x512, 0xa, 0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x5, 0x46, 0x517, \n-    0xa, 0x46, 0x3, 0x46, 0x5, 0x46, 0x51a, 0xa, 0x46, 0x3, 0x46, 0x5, 0x46, \n-    0x51d, 0xa, 0x46, 0x3, 0x46, 0x3, 0x46, 0x5, 0x46, 0x521, 0xa, 0x46, \n-    0x3, 0x46, 0x3, 0x46, 0x5, 0x46, 0x525, 0xa, 0x46, 0x3, 0x46, 0x5, 0x46, \n-    0x528, 0xa, 0x46, 0x5, 0x46, 0x52a, 0xa, 0x46, 0x3, 0x46, 0x5, 0x46, \n-    0x52d, 0xa, 0x46, 0x3, 0x46, 0x3, 0x46, 0x5, 0x46, 0x531, 0xa, 0x46, \n-    0x3, 0x46, 0x3, 0x46, 0x5, 0x46, 0x535, 0xa, 0x46, 0x3, 0x46, 0x5, 0x46, \n-    0x538, 0xa, 0x46, 0x5, 0x46, 0x53a, 0xa, 0x46, 0x5, 0x46, 0x53c, 0xa, \n-    0x46, 0x3, 0x47, 0x5, 0x47, 0x53f, 0xa, 0x47, 0x3, 0x47, 0x3, 0x47, \n-    0x3, 0x47, 0x5, 0x47, 0x544, 0xa, 0x47, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, \n-    0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x5, \n-    0x48, 0x54f, 0xa, 0x48, 0x3, 0x49, 0x3, 0x49, 0x3, 0x49, 0x3, 0x49, \n-    0x5, 0x49, 0x555, 0xa, 0x49, 0x3, 0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x5, 0x4a, \n-    0x55a, 0xa, 0x4a, 0x3, 0x4b, 0x3, 0x4b, 0x3, 0x4b, 0x7, 0x4b, 0x55f, \n-    0xa, 0x4b, 0xc, 0x4b, 0xe, 0x4b, 0x562, 0xb, 0x4b, 0x3, 0x4c, 0x3, 0x4c, \n-    0x5, 0x4c, 0x566, 0xa, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x5, 0x4c, 0x56a, \n-    0xa, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x5, 0x4c, 0x56e, 0xa, 0x4c, 0x3, 0x4d, \n-    0x3, 0x4d, 0x3, 0x4d, 0x5, 0x4d, 0x573, 0xa, 0x4d, 0x3, 0x4e, 0x3, 0x4e, \n-    0x3, 0x4e, 0x7, 0x4e, 0x578, 0xa, 0x4e, 0xc, 0x4e, 0xe, 0x4e, 0x57b, \n-    0xb, 0x4e, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x50, 0x3, \n-    0x50, 0x3, 0x50, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, \n-    0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x5, \n-    0x51, 0x58f, 0xa, 0x51, 0x3, 0x51, 0x5, 0x51, 0x592, 0xa, 0x51, 0x3, \n-    0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, \n-    0x5, 0x51, 0x59b, 0xa, 0x51, 0x3, 0x51, 0x3, 0x51, 0x5, 0x51, 0x59f, \n-    0xa, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x5, 0x51, 0x5a4, 0xa, 0x51, \n-    0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 0x5, 0x51, 0x5a9, 0xa, 0x51, 0x3, 0x51, \n-    0x5, 0x51, 0x5ac, 0xa, 0x51, 0x5, 0x51, 0x5ae, 0xa, 0x51, 0x3, 0x52, \n-    0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, \n-    0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, \n-    0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x5, \n-    0x52, 0x5c4, 0xa, 0x52, 0x3, 0x52, 0x5, 0x52, 0x5c7, 0xa, 0x52, 0x3, \n-    0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, \n-    0x3, 0x52, 0x3, 0x52, 0x5, 0x52, 0x5d2, 0xa, 0x52, 0x3, 0x53, 0x3, 0x53, \n-    0x5, 0x53, 0x5d6, 0xa, 0x53, 0x3, 0x53, 0x5, 0x53, 0x5d9, 0xa, 0x53, \n-    0x3, 0x53, 0x3, 0x53, 0x5, 0x53, 0x5dd, 0xa, 0x53, 0x3, 0x53, 0x3, 0x53, \n-    0x5, 0x53, 0x5e1, 0xa, 0x53, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x55, \n-    0x3, 0x55, 0x3, 0x55, 0x5, 0x55, 0x5e9, 0xa, 0x55, 0x3, 0x55, 0x3, 0x55, \n-    0x5, 0x55, 0x5ed, 0xa, 0x55, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, \n-    0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x7, 0x56, 0x5f8, \n-    0xa, 0x56, 0xc, 0x56, 0xe, 0x56, 0x5fb, 0xb, 0x56, 0x3, 0x56, 0x3, 0x56, \n-    0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x7, 0x56, 0x604, \n-    0xa, 0x56, 0xc, 0x56, 0xe, 0x56, 0x607, 0xb, 0x56, 0x3, 0x56, 0x3, 0x56, \n-    0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x7, 0x56, 0x610, \n-    0xa, 0x56, 0xc, 0x56, 0xe, 0x56, 0x613, 0xb, 0x56, 0x3, 0x56, 0x3, 0x56, \n-    0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x5, 0x56, 0x61a, 0xa, 0x56, 0x3, 0x56, \n-    0x3, 0x56, 0x5, 0x56, 0x61e, 0xa, 0x56, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, \n-    0x7, 0x57, 0x623, 0xa, 0x57, 0xc, 0x57, 0xe, 0x57, 0x626, 0xb, 0x57, \n-    0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 0x5, 0x58, 0x62b, 0xa, 0x58, 0x3, 0x58, \n-    0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 0x5, 0x58, 0x633, \n-    0xa, 0x58, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x5, 0x59, 0x638, 0xa, 0x59, \n-    0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x6, 0x59, 0x63f, \n-    0xa, 0x59, 0xd, 0x59, 0xe, 0x59, 0x640, 0x3, 0x59, 0x3, 0x59, 0x5, 0x59, \n-    0x645, 0xa, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, \n-    0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, \n-    0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, \n-    0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, \n-    0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x5, 0x59, 0x664, \n-    0xa, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, \n-    0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, \n-    0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x5, 0x59, 0x675, 0xa, 0x59, 0x3, 0x59, \n-    0x5, 0x59, 0x678, 0xa, 0x59, 0x3, 0x59, 0x3, 0x59, 0x5, 0x59, 0x67c, \n-    0xa, 0x59, 0x3, 0x59, 0x5, 0x59, 0x67f, 0xa, 0x59, 0x3, 0x59, 0x3, 0x59, \n-    0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, \n-    0x59, 0x3, 0x59, 0x5, 0x59, 0x68b, 0xa, 0x59, 0x3, 0x59, 0x3, 0x59, \n-    0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, \n-    0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, \n-    0x5, 0x59, 0x69c, 0xa, 0x59, 0x3, 0x59, 0x3, 0x59, 0x5, 0x59, 0x6a0, \n-    0xa, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, \n-    0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, \n-    0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x5, 0x59, 0x6b1, 0xa, 0x59, 0x3, 0x59, \n-    0x5, 0x59, 0x6b4, 0xa, 0x59, 0x3, 0x59, 0x3, 0x59, 0x5, 0x59, 0x6b8, \n-    0xa, 0x59, 0x3, 0x59, 0x5, 0x59, 0x6bb, 0xa, 0x59, 0x3, 0x59, 0x3, 0x59, \n-    0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, \n-    0x59, 0x5, 0x59, 0x6c6, 0xa, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, \n-    0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, \n-    0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, \n-    0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x5, \n-    0x59, 0x6de, 0xa, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, \n-    0x3, 0x59, 0x5, 0x59, 0x6e5, 0xa, 0x59, 0x7, 0x59, 0x6e7, 0xa, 0x59, \n-    0xc, 0x59, 0xe, 0x59, 0x6ea, 0xb, 0x59, 0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5a, \n-    0x7, 0x5a, 0x6ef, 0xa, 0x5a, 0xc, 0x5a, 0xe, 0x5a, 0x6f2, 0xb, 0x5a, \n-    0x3, 0x5b, 0x3, 0x5b, 0x5, 0x5b, 0x6f6, 0xa, 0x5b, 0x3, 0x5c, 0x3, 0x5c, \n-    0x3, 0x5c, 0x3, 0x5c, 0x7, 0x5c, 0x6fc, 0xa, 0x5c, 0xc, 0x5c, 0xe, 0x5c, \n-    0x6ff, 0xb, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, \n-    0x7, 0x5c, 0x706, 0xa, 0x5c, 0xc, 0x5c, 0xe, 0x5c, 0x709, 0xb, 0x5c, \n-    0x5, 0x5c, 0x70b, 0xa, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5d, \n-    0x3, 0x5d, 0x3, 0x5d, 0x5, 0x5d, 0x713, 0xa, 0x5d, 0x3, 0x5d, 0x3, 0x5d, \n-    0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x5, 0x5e, 0x71a, 0xa, 0x5e, 0x3, 0x5f, \n-    0x3, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x5, \n-    0x5f, 0x723, 0xa, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x3, 0x5f, \n-    0x5, 0x5f, 0x729, 0xa, 0x5f, 0x7, 0x5f, 0x72b, 0xa, 0x5f, 0xc, 0x5f, \n-    0xe, 0x5f, 0x72e, 0xb, 0x5f, 0x3, 0x60, 0x3, 0x60, 0x3, 0x60, 0x5, 0x60, \n-    0x733, 0xa, 0x60, 0x3, 0x60, 0x3, 0x60, 0x3, 0x61, 0x3, 0x61, 0x3, 0x61, \n-    0x5, 0x61, 0x73a, 0xa, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 0x62, 0x3, 0x62, \n-    0x3, 0x62, 0x7, 0x62, 0x741, 0xa, 0x62, 0xc, 0x62, 0xe, 0x62, 0x744, \n-    0xb, 0x62, 0x3, 0x63, 0x3, 0x63, 0x3, 0x63, 0x5, 0x63, 0x749, 0xa, 0x63, \n-    0x3, 0x64, 0x3, 0x64, 0x3, 0x65, 0x3, 0x65, 0x3, 0x65, 0x3, 0x65, 0x3, \n-    0x65, 0x3, 0x65, 0x5, 0x65, 0x753, 0xa, 0x65, 0x5, 0x65, 0x755, 0xa, \n-    0x65, 0x3, 0x66, 0x5, 0x66, 0x758, 0xa, 0x66, 0x3, 0x66, 0x3, 0x66, \n-    0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x66, 0x5, 0x66, 0x760, 0xa, 0x66, \n-    0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x5, 0x67, 0x765, 0xa, 0x67, 0x3, 0x68, \n-    0x3, 0x68, 0x3, 0x69, 0x3, 0x69, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6b, 0x3, \n-    0x6b, 0x5, 0x6b, 0x76f, 0xa, 0x6b, 0x3, 0x6c, 0x3, 0x6c, 0x3, 0x6c, \n-    0x5, 0x6c, 0x774, 0xa, 0x6c, 0x3, 0x6d, 0x3, 0x6d, 0x5, 0x6d, 0x778, \n-    0xa, 0x6d, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x2, \n-    0x5, 0x88, 0xb0, 0xbc, 0x6f, 0x2, 0x4, 0x6, 0x8, 0xa, 0xc, 0xe, 0x10, \n-    0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e, 0x20, 0x22, 0x24, 0x26, 0x28, \n-    0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e, 0x40, \n-    0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, \n-    0x5a, 0x5c, 0x5e, 0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, \n-    0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e, 0x80, 0x82, 0x84, 0x86, 0x88, \n-    0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e, 0xa0, \n-    0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, \n-    0xba, 0xbc, 0xbe, 0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, \n-    0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0x2, 0x1d, 0x8, 0x2, 0x5, 0x5, 0x1a, 0x1a, \n-    0x1d, 0x1d, 0x27, 0x27, 0x67, 0x67, 0xa8, 0xa8, 0x4, 0x2, 0x11, 0x11, \n-    0x1f, 0x1f, 0x5, 0x2, 0x5, 0x5, 0x27, 0x27, 0x67, 0x67, 0x4, 0x2, 0x2a, \n-    0x2a, 0x2c, 0x2c, 0x4, 0x2, 0x2d, 0x2d, 0x33, 0x33, 0x5, 0x2, 0x10, \n-    0x10, 0x97, 0x97, 0x9d, 0x9d, 0x4, 0x2, 0x21, 0x21, 0x8a, 0x8a, 0x4, \n-    0x2, 0x53, 0x53, 0x5f, 0x5f, 0x4, 0x2, 0x46, 0x46, 0x64, 0x64, 0x5, \n-    0x2, 0x6, 0x6, 0xa, 0xa, 0xe, 0xe, 0x6, 0x2, 0x6, 0x6, 0x9, 0xa, 0xe, \n-    0xe, 0x8e, 0x8e, 0x4, 0x2, 0x5f, 0x5f, 0x89, 0x89, 0x4, 0x2, 0x6, 0x6, \n-    0xa, 0xa, 0x4, 0x2, 0x75, 0x75, 0xc5, 0xc5, 0x4, 0x2, 0xd, 0xd, 0x2a, \n-    0x2b, 0x4, 0x2, 0x3e, 0x3e, 0x5c, 0x5c, 0x4, 0x2, 0x43, 0x43, 0x4f, \n-    0x4f, 0x3, 0x2, 0x94, 0x95, 0x5, 0x2, 0x13, 0x13, 0x5e, 0x5e, 0xa5, \n-    0xa5, 0x5, 0x2, 0xc1, 0xc1, 0xd3, 0xd3, 0xdc, 0xdc, 0x4, 0x2, 0xc6, \n-    0xc7, 0xd4, 0xd4, 0x4, 0x2, 0x4e, 0x4e, 0x61, 0x61, 0x3, 0x2, 0xbc, \n-    0xbd, 0x4, 0x2, 0xc7, 0xc7, 0xd4, 0xd4, 0xa, 0x2, 0x25, 0x25, 0x4b, \n-    0x4b, 0x6b, 0x6b, 0x6d, 0x6d, 0x81, 0x81, 0x8c, 0x8c, 0xb3, 0xb3, 0xb7, \n-    0xb7, 0xe, 0x2, 0x4, 0x24, 0x26, 0x4a, 0x4c, 0x50, 0x52, 0x6a, 0x6c, \n-    0x6c, 0x6e, 0x6f, 0x71, 0x72, 0x74, 0x7f, 0x82, 0x8b, 0x8d, 0xb2, 0xb4, \n-    0xb6, 0xb8, 0xb9, 0x6, 0x2, 0x24, 0x24, 0x3e, 0x3e, 0x4c, 0x4c, 0x5a, \n-    0x5a, 0x2, 0x88f, 0x2, 0xea, 0x3, 0x2, 0x2, 0x2, 0x4, 0xfe, 0x3, 0x2, \n-    0x2, 0x2, 0x6, 0x100, 0x3, 0x2, 0x2, 0x2, 0x8, 0x1e4, 0x3, 0x2, 0x2, \n-    0x2, 0xa, 0x1e6, 0x3, 0x2, 0x2, 0x2, 0xc, 0x1ee, 0x3, 0x2, 0x2, 0x2, \n-    0xe, 0x1f2, 0x3, 0x2, 0x2, 0x2, 0x10, 0x1f9, 0x3, 0x2, 0x2, 0x2, 0x12, \n-    0x1fb, 0x3, 0x2, 0x2, 0x2, 0x14, 0x201, 0x3, 0x2, 0x2, 0x2, 0x16, 0x290, \n-    0x3, 0x2, 0x2, 0x2, 0x18, 0x292, 0x3, 0x2, 0x2, 0x2, 0x1a, 0x29d, 0x3, \n-    0x2, 0x2, 0x2, 0x1c, 0x2b8, 0x3, 0x2, 0x2, 0x2, 0x1e, 0x2d3, 0x3, 0x2, \n-    0x2, 0x2, 0x20, 0x2d7, 0x3, 0x2, 0x2, 0x2, 0x22, 0x2e0, 0x3, 0x2, 0x2, \n-    0x2, 0x24, 0x2ed, 0x3, 0x2, 0x2, 0x2, 0x26, 0x2fc, 0x3, 0x2, 0x2, 0x2, \n-    0x28, 0x309, 0x3, 0x2, 0x2, 0x2, 0x2a, 0x319, 0x3, 0x2, 0x2, 0x2, 0x2c, \n-    0x31e, 0x3, 0x2, 0x2, 0x2, 0x2e, 0x324, 0x3, 0x2, 0x2, 0x2, 0x30, 0x327, \n-    0x3, 0x2, 0x2, 0x2, 0x32, 0x32a, 0x3, 0x2, 0x2, 0x2, 0x34, 0x33c, 0x3, \n-    0x2, 0x2, 0x2, 0x36, 0x33e, 0x3, 0x2, 0x2, 0x2, 0x38, 0x35c, 0x3, 0x2, \n-    0x2, 0x2, 0x3a, 0x360, 0x3, 0x2, 0x2, 0x2, 0x3c, 0x364, 0x3, 0x2, 0x2, \n-    0x2, 0x3e, 0x368, 0x3, 0x2, 0x2, 0x2, 0x40, 0x371, 0x3, 0x2, 0x2, 0x2, \n-    0x42, 0x387, 0x3, 0x2, 0x2, 0x2, 0x44, 0x3a9, 0x3, 0x2, 0x2, 0x2, 0x46, \n-    0x3ab, 0x3, 0x2, 0x2, 0x2, 0x48, 0x3ae, 0x3, 0x2, 0x2, 0x2, 0x4a, 0x3b5, \n-    0x3, 0x2, 0x2, 0x2, 0x4c, 0x3b8, 0x3, 0x2, 0x2, 0x2, 0x4e, 0x3c4, 0x3, \n-    0x2, 0x2, 0x2, 0x50, 0x3cc, 0x3, 0x2, 0x2, 0x2, 0x52, 0x3d6, 0x3, 0x2, \n-    0x2, 0x2, 0x54, 0x3fb, 0x3, 0x2, 0x2, 0x2, 0x56, 0x40a, 0x3, 0x2, 0x2, \n-    0x2, 0x58, 0x412, 0x3, 0x2, 0x2, 0x2, 0x5a, 0x414, 0x3, 0x2, 0x2, 0x2, \n-    0x5c, 0x423, 0x3, 0x2, 0x2, 0x2, 0x5e, 0x437, 0x3, 0x2, 0x2, 0x2, 0x60, \n-    0x439, 0x3, 0x2, 0x2, 0x2, 0x62, 0x442, 0x3, 0x2, 0x2, 0x2, 0x64, 0x451, \n-    0x3, 0x2, 0x2, 0x2, 0x66, 0x463, 0x3, 0x2, 0x2, 0x2, 0x68, 0x471, 0x3, \n-    0x2, 0x2, 0x2, 0x6a, 0x47f, 0x3, 0x2, 0x2, 0x2, 0x6c, 0x482, 0x3, 0x2, \n-    0x2, 0x2, 0x6e, 0x4b2, 0x3, 0x2, 0x2, 0x2, 0x70, 0x4b5, 0x3, 0x2, 0x2, \n-    0x2, 0x72, 0x4bb, 0x3, 0x2, 0x2, 0x2, 0x74, 0x4bf, 0x3, 0x2, 0x2, 0x2, \n-    0x76, 0x4c5, 0x3, 0x2, 0x2, 0x2, 0x78, 0x4c8, 0x3, 0x2, 0x2, 0x2, 0x7a, \n-    0x4cb, 0x3, 0x2, 0x2, 0x2, 0x7c, 0x4d5, 0x3, 0x2, 0x2, 0x2, 0x7e, 0x4d8, \n-    0x3, 0x2, 0x2, 0x2, 0x80, 0x4dc, 0x3, 0x2, 0x2, 0x2, 0x82, 0x4e0, 0x3, \n-    0x2, 0x2, 0x2, 0x84, 0x4e5, 0x3, 0x2, 0x2, 0x2, 0x86, 0x4eb, 0x3, 0x2, \n-    0x2, 0x2, 0x88, 0x4fa, 0x3, 0x2, 0x2, 0x2, 0x8a, 0x53b, 0x3, 0x2, 0x2, \n-    0x2, 0x8c, 0x543, 0x3, 0x2, 0x2, 0x2, 0x8e, 0x54e, 0x3, 0x2, 0x2, 0x2, \n-    0x90, 0x550, 0x3, 0x2, 0x2, 0x2, 0x92, 0x556, 0x3, 0x2, 0x2, 0x2, 0x94, \n-    0x55b, 0x3, 0x2, 0x2, 0x2, 0x96, 0x563, 0x3, 0x2, 0x2, 0x2, 0x98, 0x56f, \n-    0x3, 0x2, 0x2, 0x2, 0x9a, 0x574, 0x3, 0x2, 0x2, 0x2, 0x9c, 0x57c, 0x3, \n-    0x2, 0x2, 0x2, 0x9e, 0x580, 0x3, 0x2, 0x2, 0x2, 0xa0, 0x5ad, 0x3, 0x2, \n-    0x2, 0x2, 0xa2, 0x5d1, 0x3, 0x2, 0x2, 0x2, 0xa4, 0x5d3, 0x3, 0x2, 0x2, \n-    0x2, 0xa6, 0x5e2, 0x3, 0x2, 0x2, 0x2, 0xa8, 0x5e5, 0x3, 0x2, 0x2, 0x2, \n-    0xaa, 0x61d, 0x3, 0x2, 0x2, 0x2, 0xac, 0x61f, 0x3, 0x2, 0x2, 0x2, 0xae, \n-    0x632, 0x3, 0x2, 0x2, 0x2, 0xb0, 0x69f, 0x3, 0x2, 0x2, 0x2, 0xb2, 0x6eb, \n-    0x3, 0x2, 0x2, 0x2, 0xb4, 0x6f5, 0x3, 0x2, 0x2, 0x2, 0xb6, 0x70a, 0x3, \n-    0x2, 0x2, 0x2, 0xb8, 0x712, 0x3, 0x2, 0x2, 0x2, 0xba, 0x716, 0x3, 0x2, \n-    0x2, 0x2, 0xbc, 0x722, 0x3, 0x2, 0x2, 0x2, 0xbe, 0x72f, 0x3, 0x2, 0x2, \n-    0x2, 0xc0, 0x739, 0x3, 0x2, 0x2, 0x2, 0xc2, 0x73d, 0x3, 0x2, 0x2, 0x2, \n-    0xc4, 0x748, 0x3, 0x2, 0x2, 0x2, 0xc6, 0x74a, 0x3, 0x2, 0x2, 0x2, 0xc8, \n-    0x754, 0x3, 0x2, 0x2, 0x2, 0xca, 0x757, 0x3, 0x2, 0x2, 0x2, 0xcc, 0x764, \n-    0x3, 0x2, 0x2, 0x2, 0xce, 0x766, 0x3, 0x2, 0x2, 0x2, 0xd0, 0x768, 0x3, \n-    0x2, 0x2, 0x2, 0xd2, 0x76a, 0x3, 0x2, 0x2, 0x2, 0xd4, 0x76e, 0x3, 0x2, \n-    0x2, 0x2, 0xd6, 0x773, 0x3, 0x2, 0x2, 0x2, 0xd8, 0x777, 0x3, 0x2, 0x2, \n-    0x2, 0xda, 0x779, 0x3, 0x2, 0x2, 0x2, 0xdc, 0xe0, 0x5, 0x4, 0x3, 0x2, \n-    0xdd, 0xde, 0x7, 0x56, 0x2, 0x2, 0xde, 0xdf, 0x7, 0x7b, 0x2, 0x2, 0xdf, \n-    0xe1, 0x7, 0xbf, 0x2, 0x2, 0xe0, 0xdd, 0x3, 0x2, 0x2, 0x2, 0xe0, 0xe1, \n-    0x3, 0x2, 0x2, 0x2, 0xe1, 0xe4, 0x3, 0x2, 0x2, 0x2, 0xe2, 0xe3, 0x7, \n-    0x41, 0x2, 0x2, 0xe3, 0xe5, 0x5, 0xd8, 0x6d, 0x2, 0xe4, 0xe2, 0x3, 0x2, \n-    0x2, 0x2, 0xe4, 0xe5, 0x3, 0x2, 0x2, 0x2, 0xe5, 0xe7, 0x3, 0x2, 0x2, \n-    0x2, 0xe6, 0xe8, 0x7, 0xdb, 0x2, 0x2, 0xe7, 0xe6, 0x3, 0x2, 0x2, 0x2, \n-    0xe7, 0xe8, 0x3, 0x2, 0x2, 0x2, 0xe8, 0xeb, 0x3, 0x2, 0x2, 0x2, 0xe9, \n-    0xeb, 0x5, 0x5a, 0x2e, 0x2, 0xea, 0xdc, 0x3, 0x2, 0x2, 0x2, 0xea, 0xe9, \n-    0x3, 0x2, 0x2, 0x2, 0xeb, 0x3, 0x3, 0x2, 0x2, 0x2, 0xec, 0xff, 0x5, \n-    0x6, 0x4, 0x2, 0xed, 0xff, 0x5, 0x12, 0xa, 0x2, 0xee, 0xff, 0x5, 0x14, \n-    0xb, 0x2, 0xef, 0xff, 0x5, 0x16, 0xc, 0x2, 0xf0, 0xff, 0x5, 0x52, 0x2a, \n-    0x2, 0xf1, 0xff, 0x5, 0x54, 0x2b, 0x2, 0xf2, 0xff, 0x5, 0x56, 0x2c, \n-    0x2, 0xf3, 0xff, 0x5, 0x58, 0x2d, 0x2, 0xf4, 0xff, 0x5, 0x60, 0x31, \n-    0x2, 0xf5, 0xff, 0x5, 0x62, 0x32, 0x2, 0xf6, 0xff, 0x5, 0x64, 0x33, \n-    0x2, 0xf7, 0xff, 0x5, 0x68, 0x35, 0x2, 0xf8, 0xff, 0x5, 0x9e, 0x50, \n-    0x2, 0xf9, 0xff, 0x5, 0xa0, 0x51, 0x2, 0xfa, 0xff, 0x5, 0xa2, 0x52, \n-    0x2, 0xfb, 0xff, 0x5, 0xa4, 0x53, 0x2, 0xfc, 0xff, 0x5, 0xa6, 0x54, \n-    0x2, 0xfd, 0xff, 0x5, 0xa8, 0x55, 0x2, 0xfe, 0xec, 0x3, 0x2, 0x2, 0x2, \n-    0xfe, 0xed, 0x3, 0x2, 0x2, 0x2, 0xfe, 0xee, 0x3, 0x2, 0x2, 0x2, 0xfe, \n-    0xef, 0x3, 0x2, 0x2, 0x2, 0xfe, 0xf0, 0x3, 0x2, 0x2, 0x2, 0xfe, 0xf1, \n-    0x3, 0x2, 0x2, 0x2, 0xfe, 0xf2, 0x3, 0x2, 0x2, 0x2, 0xfe, 0xf3, 0x3, \n-    0x2, 0x2, 0x2, 0xfe, 0xf4, 0x3, 0x2, 0x2, 0x2, 0xfe, 0xf5, 0x3, 0x2, \n-    0x2, 0x2, 0xfe, 0xf6, 0x3, 0x2, 0x2, 0x2, 0xfe, 0xf7, 0x3, 0x2, 0x2, \n-    0x2, 0xfe, 0xf8, 0x3, 0x2, 0x2, 0x2, 0xfe, 0xf9, 0x3, 0x2, 0x2, 0x2, \n-    0xfe, 0xfa, 0x3, 0x2, 0x2, 0x2, 0xfe, 0xfb, 0x3, 0x2, 0x2, 0x2, 0xfe, \n-    0xfc, 0x3, 0x2, 0x2, 0x2, 0xfe, 0xfd, 0x3, 0x2, 0x2, 0x2, 0xff, 0x5, \n-    0x3, 0x2, 0x2, 0x2, 0x100, 0x101, 0x7, 0x7, 0x2, 0x2, 0x101, 0x102, \n-    0x7, 0x9a, 0x2, 0x2, 0x102, 0x104, 0x5, 0xc0, 0x61, 0x2, 0x103, 0x105, \n-    0x5, 0x2c, 0x17, 0x2, 0x104, 0x103, 0x3, 0x2, 0x2, 0x2, 0x104, 0x105, \n-    0x3, 0x2, 0x2, 0x2, 0x105, 0x106, 0x3, 0x2, 0x2, 0x2, 0x106, 0x10b, \n-    0x5, 0x8, 0x5, 0x2, 0x107, 0x108, 0x7, 0xc5, 0x2, 0x2, 0x108, 0x10a, \n-    0x5, 0x8, 0x5, 0x2, 0x109, 0x107, 0x3, 0x2, 0x2, 0x2, 0x10a, 0x10d, \n-    0x3, 0x2, 0x2, 0x2, 0x10b, 0x109, 0x3, 0x2, 0x2, 0x2, 0x10b, 0x10c, \n-    0x3, 0x2, 0x2, 0x2, 0x10c, 0x7, 0x3, 0x2, 0x2, 0x2, 0x10d, 0x10b, 0x3, \n-    0x2, 0x2, 0x2, 0x10e, 0x10f, 0x7, 0x3, 0x2, 0x2, 0x10f, 0x113, 0x7, \n-    0x1c, 0x2, 0x2, 0x110, 0x111, 0x7, 0x4d, 0x2, 0x2, 0x111, 0x112, 0x7, \n-    0x72, 0x2, 0x2, 0x112, 0x114, 0x7, 0x38, 0x2, 0x2, 0x113, 0x110, 0x3, \n-    0x2, 0x2, 0x2, 0x113, 0x114, 0x3, 0x2, 0x2, 0x2, 0x114, 0x115, 0x3, \n-    0x2, 0x2, 0x2, 0x115, 0x118, 0x5, 0x44, 0x23, 0x2, 0x116, 0x117, 0x7, \n-    0x4, 0x2, 0x2, 0x117, 0x119, 0x5, 0xba, 0x5e, 0x2, 0x118, 0x116, 0x3, \n-    0x2, 0x2, 0x2, 0x118, 0x119, 0x3, 0x2, 0x2, 0x2, 0x119, 0x1e5, 0x3, \n-    0x2, 0x2, 0x2, 0x11a, 0x11b, 0x7, 0x3, 0x2, 0x2, 0x11b, 0x11f, 0x7, \n-    0x50, 0x2, 0x2, 0x11c, 0x11d, 0x7, 0x4d, 0x2, 0x2, 0x11d, 0x11e, 0x7, \n-    0x72, 0x2, 0x2, 0x11e, 0x120, 0x7, 0x38, 0x2, 0x2, 0x11f, 0x11c, 0x3, \n-    0x2, 0x2, 0x2, 0x11f, 0x120, 0x3, 0x2, 0x2, 0x2, 0x120, 0x121, 0x3, \n-    0x2, 0x2, 0x2, 0x121, 0x124, 0x5, 0x48, 0x25, 0x2, 0x122, 0x123, 0x7, \n-    0x4, 0x2, 0x2, 0x123, 0x125, 0x5, 0xba, 0x5e, 0x2, 0x124, 0x122, 0x3, \n-    0x2, 0x2, 0x2, 0x124, 0x125, 0x3, 0x2, 0x2, 0x2, 0x125, 0x1e5, 0x3, \n-    0x2, 0x2, 0x2, 0x126, 0x127, 0x7, 0x3, 0x2, 0x2, 0x127, 0x12b, 0x7, \n-    0x80, 0x2, 0x2, 0x128, 0x129, 0x7, 0x4d, 0x2, 0x2, 0x129, 0x12a, 0x7, \n-    0x72, 0x2, 0x2, 0x12a, 0x12c, 0x7, 0x38, 0x2, 0x2, 0x12b, 0x128, 0x3, \n-    0x2, 0x2, 0x2, 0x12b, 0x12c, 0x3, 0x2, 0x2, 0x2, 0x12c, 0x12d, 0x3, \n-    0x2, 0x2, 0x2, 0x12d, 0x130, 0x5, 0x4a, 0x26, 0x2, 0x12e, 0x12f, 0x7, \n-    0x4, 0x2, 0x2, 0x12f, 0x131, 0x5, 0xba, 0x5e, 0x2, 0x130, 0x12e, 0x3, \n-    0x2, 0x2, 0x2, 0x130, 0x131, 0x3, 0x2, 0x2, 0x2, 0x131, 0x1e5, 0x3, \n-    0x2, 0x2, 0x2, 0x132, 0x133, 0x7, 0x11, 0x2, 0x2, 0x133, 0x136, 0x5, \n-    0x10, 0x9, 0x2, 0x134, 0x135, 0x7, 0x43, 0x2, 0x2, 0x135, 0x137, 0x5, \n-    0xc0, 0x61, 0x2, 0x136, 0x134, 0x3, 0x2, 0x2, 0x2, 0x136, 0x137, 0x3, \n-    0x2, 0x2, 0x2, 0x137, 0x1e5, 0x3, 0x2, 0x2, 0x2, 0x138, 0x139, 0x7, \n-    0x18, 0x2, 0x2, 0x139, 0x13c, 0x7, 0x1c, 0x2, 0x2, 0x13a, 0x13b, 0x7, \n-    0x4d, 0x2, 0x2, 0x13b, 0x13d, 0x7, 0x38, 0x2, 0x2, 0x13c, 0x13a, 0x3, \n-    0x2, 0x2, 0x2, 0x13c, 0x13d, 0x3, 0x2, 0x2, 0x2, 0x13d, 0x13e, 0x3, \n-    0x2, 0x2, 0x2, 0x13e, 0x141, 0x5, 0xba, 0x5e, 0x2, 0x13f, 0x140, 0x7, \n-    0x4f, 0x2, 0x2, 0x140, 0x142, 0x5, 0x10, 0x9, 0x2, 0x141, 0x13f, 0x3, \n-    0x2, 0x2, 0x2, 0x141, 0x142, 0x3, 0x2, 0x2, 0x2, 0x142, 0x1e5, 0x3, \n-    0x2, 0x2, 0x2, 0x143, 0x144, 0x7, 0x18, 0x2, 0x2, 0x144, 0x147, 0x7, \n-    0x50, 0x2, 0x2, 0x145, 0x146, 0x7, 0x4d, 0x2, 0x2, 0x146, 0x148, 0x7, \n-    0x38, 0x2, 0x2, 0x147, 0x145, 0x3, 0x2, 0x2, 0x2, 0x147, 0x148, 0x3, \n-    0x2, 0x2, 0x2, 0x148, 0x149, 0x3, 0x2, 0x2, 0x2, 0x149, 0x14c, 0x5, \n-    0xba, 0x5e, 0x2, 0x14a, 0x14b, 0x7, 0x4f, 0x2, 0x2, 0x14b, 0x14d, 0x5, \n-    0x10, 0x9, 0x2, 0x14c, 0x14a, 0x3, 0x2, 0x2, 0x2, 0x14c, 0x14d, 0x3, \n-    0x2, 0x2, 0x2, 0x14d, 0x1e5, 0x3, 0x2, 0x2, 0x2, 0x14e, 0x14f, 0x7, \n-    0x18, 0x2, 0x2, 0x14f, 0x152, 0x7, 0x80, 0x2, 0x2, 0x150, 0x151, 0x7, \n-    0x4d, 0x2, 0x2, 0x151, 0x153, 0x7, 0x38, 0x2, 0x2, 0x152, 0x150, 0x3, \n-    0x2, 0x2, 0x2, 0x152, 0x153, 0x3, 0x2, 0x2, 0x2, 0x153, 0x154, 0x3, \n-    0x2, 0x2, 0x2, 0x154, 0x157, 0x5, 0xba, 0x5e, 0x2, 0x155, 0x156, 0x7, \n-    0x4f, 0x2, 0x2, 0x156, 0x158, 0x5, 0x10, 0x9, 0x2, 0x157, 0x155, 0x3, \n-    0x2, 0x2, 0x2, 0x157, 0x158, 0x3, 0x2, 0x2, 0x2, 0x158, 0x1e5, 0x3, \n-    0x2, 0x2, 0x2, 0x159, 0x15a, 0x7, 0x1d, 0x2, 0x2, 0x15a, 0x15d, 0x7, \n-    0x1c, 0x2, 0x2, 0x15b, 0x15c, 0x7, 0x4d, 0x2, 0x2, 0x15c, 0x15e, 0x7, \n-    0x38, 0x2, 0x2, 0x15d, 0x15b, 0x3, 0x2, 0x2, 0x2, 0x15d, 0x15e, 0x3, \n-    0x2, 0x2, 0x2, 0x15e, 0x15f, 0x3, 0x2, 0x2, 0x2, 0x15f, 0x160, 0x5, \n-    0xba, 0x5e, 0x2, 0x160, 0x161, 0x7, 0xbf, 0x2, 0x2, 0x161, 0x1e5, 0x3, \n-    0x2, 0x2, 0x2, 0x162, 0x163, 0x7, 0x29, 0x2, 0x2, 0x163, 0x164, 0x7, \n-    0xb5, 0x2, 0x2, 0x164, 0x1e5, 0x5, 0xb0, 0x59, 0x2, 0x165, 0x166, 0x7, \n-    0x2d, 0x2, 0x2, 0x166, 0x1e5, 0x5, 0x10, 0x9, 0x2, 0x167, 0x168, 0x7, \n-    0x33, 0x2, 0x2, 0x168, 0x16b, 0x7, 0x1c, 0x2, 0x2, 0x169, 0x16a, 0x7, \n-    0x4d, 0x2, 0x2, 0x16a, 0x16c, 0x7, 0x38, 0x2, 0x2, 0x16b, 0x169, 0x3, \n-    0x2, 0x2, 0x2, 0x16b, 0x16c, 0x3, 0x2, 0x2, 0x2, 0x16c, 0x16d, 0x3, \n-    0x2, 0x2, 0x2, 0x16d, 0x1e5, 0x5, 0xba, 0x5e, 0x2, 0x16e, 0x16f, 0x7, \n-    0x33, 0x2, 0x2, 0x16f, 0x172, 0x7, 0x50, 0x2, 0x2, 0x170, 0x171, 0x7, \n-    0x4d, 0x2, 0x2, 0x171, 0x173, 0x7, 0x38, 0x2, 0x2, 0x172, 0x170, 0x3, \n-    0x2, 0x2, 0x2, 0x172, 0x173, 0x3, 0x2, 0x2, 0x2, 0x173, 0x174, 0x3, \n-    0x2, 0x2, 0x2, 0x174, 0x1e5, 0x5, 0xba, 0x5e, 0x2, 0x175, 0x176, 0x7, \n-    0x33, 0x2, 0x2, 0x176, 0x179, 0x7, 0x80, 0x2, 0x2, 0x177, 0x178, 0x7, \n-    0x4d, 0x2, 0x2, 0x178, 0x17a, 0x7, 0x38, 0x2, 0x2, 0x179, 0x177, 0x3, \n-    0x2, 0x2, 0x2, 0x179, 0x17a, 0x3, 0x2, 0x2, 0x2, 0x17a, 0x17b, 0x3, \n-    0x2, 0x2, 0x2, 0x17b, 0x1e5, 0x5, 0xba, 0x5e, 0x2, 0x17c, 0x17d, 0x7, \n-    0x33, 0x2, 0x2, 0x17d, 0x1e5, 0x5, 0x10, 0x9, 0x2, 0x17e, 0x180, 0x7, \n-    0x42, 0x2, 0x2, 0x17f, 0x181, 0x5, 0x10, 0x9, 0x2, 0x180, 0x17f, 0x3, \n-    0x2, 0x2, 0x2, 0x180, 0x181, 0x3, 0x2, 0x2, 0x2, 0x181, 0x1e5, 0x3, \n-    0x2, 0x2, 0x2, 0x182, 0x183, 0x7, 0x66, 0x2, 0x2, 0x183, 0x186, 0x7, \n-    0x50, 0x2, 0x2, 0x184, 0x185, 0x7, 0x4d, 0x2, 0x2, 0x185, 0x187, 0x7, \n-    0x38, 0x2, 0x2, 0x186, 0x184, 0x3, 0x2, 0x2, 0x2, 0x186, 0x187, 0x3, \n-    0x2, 0x2, 0x2, 0x187, 0x188, 0x3, 0x2, 0x2, 0x2, 0x188, 0x18b, 0x5, \n-    0xba, 0x5e, 0x2, 0x189, 0x18a, 0x7, 0x4f, 0x2, 0x2, 0x18a, 0x18c, 0x5, \n-    0x10, 0x9, 0x2, 0x18b, 0x189, 0x3, 0x2, 0x2, 0x2, 0x18b, 0x18c, 0x3, \n-    0x2, 0x2, 0x2, 0x18c, 0x1e5, 0x3, 0x2, 0x2, 0x2, 0x18d, 0x18e, 0x7, \n-    0x66, 0x2, 0x2, 0x18e, 0x191, 0x7, 0x80, 0x2, 0x2, 0x18f, 0x190, 0x7, \n-    0x4d, 0x2, 0x2, 0x190, 0x192, 0x7, 0x38, 0x2, 0x2, 0x191, 0x18f, 0x3, \n-    0x2, 0x2, 0x2, 0x191, 0x192, 0x3, 0x2, 0x2, 0x2, 0x192, 0x193, 0x3, \n-    0x2, 0x2, 0x2, 0x193, 0x196, 0x5, 0xba, 0x5e, 0x2, 0x194, 0x195, 0x7, \n-    0x4f, 0x2, 0x2, 0x195, 0x197, 0x5, 0x10, 0x9, 0x2, 0x196, 0x194, 0x3, \n-    0x2, 0x2, 0x2, 0x196, 0x197, 0x3, 0x2, 0x2, 0x2, 0x197, 0x1e5, 0x3, \n-    0x2, 0x2, 0x2, 0x198, 0x199, 0x7, 0x6c, 0x2, 0x2, 0x199, 0x19c, 0x7, \n-    0x1c, 0x2, 0x2, 0x19a, 0x19b, 0x7, 0x4d, 0x2, 0x2, 0x19b, 0x19d, 0x7, \n-    0x38, 0x2, 0x2, 0x19c, 0x19a, 0x3, 0x2, 0x2, 0x2, 0x19c, 0x19d, 0x3, \n-    0x2, 0x2, 0x2, 0x19d, 0x19e, 0x3, 0x2, 0x2, 0x2, 0x19e, 0x19f, 0x5, \n-    0xba, 0x5e, 0x2, 0x19f, 0x1a0, 0x5, 0x4c, 0x27, 0x2, 0x1a0, 0x1e5, 0x3, \n-    0x2, 0x2, 0x2, 0x1a1, 0x1a2, 0x7, 0x6c, 0x2, 0x2, 0x1a2, 0x1a5, 0x7, \n-    0x1c, 0x2, 0x2, 0x1a3, 0x1a4, 0x7, 0x4d, 0x2, 0x2, 0x1a4, 0x1a6, 0x7, \n-    0x38, 0x2, 0x2, 0x1a5, 0x1a3, 0x3, 0x2, 0x2, 0x2, 0x1a5, 0x1a6, 0x3, \n-    0x2, 0x2, 0x2, 0x1a6, 0x1a7, 0x3, 0x2, 0x2, 0x2, 0x1a7, 0x1a8, 0x5, \n-    0xba, 0x5e, 0x2, 0x1a8, 0x1a9, 0x7, 0x1d, 0x2, 0x2, 0x1a9, 0x1aa, 0x7, \n-    0xbf, 0x2, 0x2, 0x1aa, 0x1e5, 0x3, 0x2, 0x2, 0x2, 0x1ab, 0x1ac, 0x7, \n-    0x6c, 0x2, 0x2, 0x1ac, 0x1af, 0x7, 0x1c, 0x2, 0x2, 0x1ad, 0x1ae, 0x7, \n-    0x4d, 0x2, 0x2, 0x1ae, 0x1b0, 0x7, 0x38, 0x2, 0x2, 0x1af, 0x1ad, 0x3, \n-    0x2, 0x2, 0x2, 0x1af, 0x1b0, 0x3, 0x2, 0x2, 0x2, 0x1b0, 0x1b1, 0x3, \n-    0x2, 0x2, 0x2, 0x1b1, 0x1b2, 0x5, 0xba, 0x5e, 0x2, 0x1b2, 0x1b3, 0x7, \n-    0x84, 0x2, 0x2, 0x1b3, 0x1b4, 0x5, 0xe, 0x8, 0x2, 0x1b4, 0x1e5, 0x3, \n-    0x2, 0x2, 0x2, 0x1b5, 0x1b6, 0x7, 0x6c, 0x2, 0x2, 0x1b6, 0x1b9, 0x7, \n-    0x1c, 0x2, 0x2, 0x1b7, 0x1b8, 0x7, 0x4d, 0x2, 0x2, 0x1b8, 0x1ba, 0x7, \n-    0x38, 0x2, 0x2, 0x1b9, 0x1b7, 0x3, 0x2, 0x2, 0x2, 0x1b9, 0x1ba, 0x3, \n-    0x2, 0x2, 0x2, 0x1ba, 0x1bb, 0x3, 0x2, 0x2, 0x2, 0x1bb, 0x1e5, 0x5, \n-    0x44, 0x23, 0x2, 0x1bc, 0x1bd, 0x7, 0x6c, 0x2, 0x2, 0x1bd, 0x1be, 0x7, \n-    0x79, 0x2, 0x2, 0x1be, 0x1bf, 0x7, 0x14, 0x2, 0x2, 0x1bf, 0x1e5, 0x5, \n-    0xb0, 0x59, 0x2, 0x1c0, 0x1c1, 0x7, 0x6c, 0x2, 0x2, 0x1c1, 0x1e5, 0x5, \n-    0x3e, 0x20, 0x2, 0x1c2, 0x1c3, 0x7, 0x6e, 0x2, 0x2, 0x1c3, 0x1cd, 0x5, \n-    0x10, 0x9, 0x2, 0x1c4, 0x1c5, 0x7, 0xa2, 0x2, 0x2, 0x1c5, 0x1c6, 0x7, \n-    0x30, 0x2, 0x2, 0x1c6, 0x1ce, 0x7, 0xbf, 0x2, 0x2, 0x1c7, 0x1c8, 0x7, \n-    0xa2, 0x2, 0x2, 0x1c8, 0x1c9, 0x7, 0xb1, 0x2, 0x2, 0x1c9, 0x1ce, 0x7, \n-    0xbf, 0x2, 0x2, 0x1ca, 0x1cb, 0x7, 0xa2, 0x2, 0x2, 0x1cb, 0x1cc, 0x7, \n-    0x9a, 0x2, 0x2, 0x1cc, 0x1ce, 0x5, 0xc0, 0x61, 0x2, 0x1cd, 0x1c4, 0x3, \n-    0x2, 0x2, 0x2, 0x1cd, 0x1c7, 0x3, 0x2, 0x2, 0x2, 0x1cd, 0x1ca, 0x3, \n-    0x2, 0x2, 0x2, 0x1ce, 0x1e5, 0x3, 0x2, 0x2, 0x2, 0x1cf, 0x1d0, 0x7, \n-    0x84, 0x2, 0x2, 0x1d0, 0x1e5, 0x7, 0xa8, 0x2, 0x2, 0x1d1, 0x1d2, 0x7, \n-    0x85, 0x2, 0x2, 0x1d2, 0x1d5, 0x7, 0x1c, 0x2, 0x2, 0x1d3, 0x1d4, 0x7, \n-    0x4d, 0x2, 0x2, 0x1d4, 0x1d6, 0x7, 0x38, 0x2, 0x2, 0x1d5, 0x1d3, 0x3, \n-    0x2, 0x2, 0x2, 0x1d5, 0x1d6, 0x3, 0x2, 0x2, 0x2, 0x1d6, 0x1d7, 0x3, \n-    0x2, 0x2, 0x2, 0x1d7, 0x1d8, 0x5, 0xba, 0x5e, 0x2, 0x1d8, 0x1d9, 0x7, \n-    0xa2, 0x2, 0x2, 0x1d9, 0x1da, 0x5, 0xba, 0x5e, 0x2, 0x1da, 0x1e5, 0x3, \n-    0x2, 0x2, 0x2, 0x1db, 0x1dc, 0x7, 0x86, 0x2, 0x2, 0x1dc, 0x1dd, 0x5, \n-    0x10, 0x9, 0x2, 0x1dd, 0x1de, 0x7, 0x43, 0x2, 0x2, 0x1de, 0x1df, 0x5, \n-    0xc0, 0x61, 0x2, 0x1df, 0x1e5, 0x3, 0x2, 0x2, 0x2, 0x1e0, 0x1e1, 0x7, \n-    0xab, 0x2, 0x2, 0x1e1, 0x1e2, 0x5, 0xa, 0x6, 0x2, 0x1e2, 0x1e3, 0x5, \n-    0x78, 0x3d, 0x2, 0x1e3, 0x1e5, 0x3, 0x2, 0x2, 0x2, 0x1e4, 0x10e, 0x3, \n-    0x2, 0x2, 0x2, 0x1e4, 0x11a, 0x3, 0x2, 0x2, 0x2, 0x1e4, 0x126, 0x3, \n-    0x2, 0x2, 0x2, 0x1e4, 0x132, 0x3, 0x2, 0x2, 0x2, 0x1e4, 0x138, 0x3, \n-    0x2, 0x2, 0x2, 0x1e4, 0x143, 0x3, 0x2, 0x2, 0x2, 0x1e4, 0x14e, 0x3, \n-    0x2, 0x2, 0x2, 0x1e4, 0x159, 0x3, 0x2, 0x2, 0x2, 0x1e4, 0x162, 0x3, \n-    0x2, 0x2, 0x2, 0x1e4, 0x165, 0x3, 0x2, 0x2, 0x2, 0x1e4, 0x167, 0x3, \n-    0x2, 0x2, 0x2, 0x1e4, 0x16e, 0x3, 0x2, 0x2, 0x2, 0x1e4, 0x175, 0x3, \n-    0x2, 0x2, 0x2, 0x1e4, 0x17c, 0x3, 0x2, 0x2, 0x2, 0x1e4, 0x17e, 0x3, \n-    0x2, 0x2, 0x2, 0x1e4, 0x182, 0x3, 0x2, 0x2, 0x2, 0x1e4, 0x18d, 0x3, \n-    0x2, 0x2, 0x2, 0x1e4, 0x198, 0x3, 0x2, 0x2, 0x2, 0x1e4, 0x1a1, 0x3, \n-    0x2, 0x2, 0x2, 0x1e4, 0x1ab, 0x3, 0x2, 0x2, 0x2, 0x1e4, 0x1b5, 0x3, \n-    0x2, 0x2, 0x2, 0x1e4, 0x1bc, 0x3, 0x2, 0x2, 0x2, 0x1e4, 0x1c0, 0x3, \n-    0x2, 0x2, 0x2, 0x1e4, 0x1c2, 0x3, 0x2, 0x2, 0x2, 0x1e4, 0x1cf, 0x3, \n-    0x2, 0x2, 0x2, 0x1e4, 0x1d1, 0x3, 0x2, 0x2, 0x2, 0x1e4, 0x1db, 0x3, \n-    0x2, 0x2, 0x2, 0x1e4, 0x1e0, 0x3, 0x2, 0x2, 0x2, 0x1e5, 0x9, 0x3, 0x2, \n-    0x2, 0x2, 0x1e6, 0x1eb, 0x5, 0xc, 0x7, 0x2, 0x1e7, 0x1e8, 0x7, 0xc5, \n-    0x2, 0x2, 0x1e8, 0x1ea, 0x5, 0xc, 0x7, 0x2, 0x1e9, 0x1e7, 0x3, 0x2, \n-    0x2, 0x2, 0x1ea, 0x1ed, 0x3, 0x2, 0x2, 0x2, 0x1eb, 0x1e9, 0x3, 0x2, \n-    0x2, 0x2, 0x1eb, 0x1ec, 0x3, 0x2, 0x2, 0x2, 0x1ec, 0xb, 0x3, 0x2, 0x2, \n-    0x2, 0x1ed, 0x1eb, 0x3, 0x2, 0x2, 0x2, 0x1ee, 0x1ef, 0x5, 0xba, 0x5e, \n-    0x2, 0x1ef, 0x1f0, 0x7, 0xca, 0x2, 0x2, 0x1f0, 0x1f1, 0x5, 0xb0, 0x59, \n-    0x2, 0x1f1, 0xd, 0x3, 0x2, 0x2, 0x2, 0x1f2, 0x1f3, 0x9, 0x2, 0x2, 0x2, \n-    0x1f3, 0xf, 0x3, 0x2, 0x2, 0x2, 0x1f4, 0x1f5, 0x7, 0x7c, 0x2, 0x2, 0x1f5, \n-    0x1fa, 0x5, 0xb0, 0x59, 0x2, 0x1f6, 0x1f7, 0x7, 0x7c, 0x2, 0x2, 0x1f7, \n-    0x1f8, 0x7, 0x4c, 0x2, 0x2, 0x1f8, 0x1fa, 0x7, 0xbf, 0x2, 0x2, 0x1f9, \n-    0x1f4, 0x3, 0x2, 0x2, 0x2, 0x1f9, 0x1f6, 0x3, 0x2, 0x2, 0x2, 0x1fa, \n-    0x11, 0x3, 0x2, 0x2, 0x2, 0x1fb, 0x1fc, 0x7, 0x11, 0x2, 0x2, 0x1fc, \n-    0x1fd, 0x7, 0x2f, 0x2, 0x2, 0x1fd, 0x1ff, 0x5, 0xc0, 0x61, 0x2, 0x1fe, \n-    0x200, 0x5, 0x2c, 0x17, 0x2, 0x1ff, 0x1fe, 0x3, 0x2, 0x2, 0x2, 0x1ff, \n-    0x200, 0x3, 0x2, 0x2, 0x2, 0x200, 0x13, 0x3, 0x2, 0x2, 0x2, 0x201, 0x202, \n-    0x7, 0x17, 0x2, 0x2, 0x202, 0x203, 0x7, 0x9a, 0x2, 0x2, 0x203, 0x205, \n-    0x5, 0xc0, 0x61, 0x2, 0x204, 0x206, 0x5, 0x10, 0x9, 0x2, 0x205, 0x204, \n-    0x3, 0x2, 0x2, 0x2, 0x205, 0x206, 0x3, 0x2, 0x2, 0x2, 0x206, 0x15, 0x3, \n-    0x2, 0x2, 0x2, 0x207, 0x208, 0x9, 0x3, 0x2, 0x2, 0x208, 0x20c, 0x7, \n-    0x22, 0x2, 0x2, 0x209, 0x20a, 0x7, 0x4d, 0x2, 0x2, 0x20a, 0x20b, 0x7, \n-    0x72, 0x2, 0x2, 0x20b, 0x20d, 0x7, 0x38, 0x2, 0x2, 0x20c, 0x209, 0x3, \n-    0x2, 0x2, 0x2, 0x20c, 0x20d, 0x3, 0x2, 0x2, 0x2, 0x20d, 0x20e, 0x3, \n-    0x2, 0x2, 0x2, 0x20e, 0x210, 0x5, 0xc6, 0x64, 0x2, 0x20f, 0x211, 0x5, \n-    0x2c, 0x17, 0x2, 0x210, 0x20f, 0x3, 0x2, 0x2, 0x2, 0x210, 0x211, 0x3, \n-    0x2, 0x2, 0x2, 0x211, 0x213, 0x3, 0x2, 0x2, 0x2, 0x212, 0x214, 0x5, \n-    0x40, 0x21, 0x2, 0x213, 0x212, 0x3, 0x2, 0x2, 0x2, 0x213, 0x214, 0x3, \n-    0x2, 0x2, 0x2, 0x214, 0x291, 0x3, 0x2, 0x2, 0x2, 0x215, 0x216, 0x9, \n-    0x3, 0x2, 0x2, 0x216, 0x21a, 0x7, 0x2f, 0x2, 0x2, 0x217, 0x218, 0x7, \n-    0x4d, 0x2, 0x2, 0x218, 0x219, 0x7, 0x72, 0x2, 0x2, 0x219, 0x21b, 0x7, \n-    0x38, 0x2, 0x2, 0x21a, 0x217, 0x3, 0x2, 0x2, 0x2, 0x21a, 0x21b, 0x3, \n-    0x2, 0x2, 0x2, 0x21b, 0x21c, 0x3, 0x2, 0x2, 0x2, 0x21c, 0x21e, 0x5, \n-    0xc0, 0x61, 0x2, 0x21d, 0x21f, 0x5, 0x2e, 0x18, 0x2, 0x21e, 0x21d, 0x3, \n-    0x2, 0x2, 0x2, 0x21e, 0x21f, 0x3, 0x2, 0x2, 0x2, 0x21f, 0x221, 0x3, \n-    0x2, 0x2, 0x2, 0x220, 0x222, 0x5, 0x2c, 0x17, 0x2, 0x221, 0x220, 0x3, \n-    0x2, 0x2, 0x2, 0x221, 0x222, 0x3, 0x2, 0x2, 0x2, 0x222, 0x223, 0x3, \n-    0x2, 0x2, 0x2, 0x223, 0x224, 0x5, 0x18, 0xd, 0x2, 0x224, 0x225, 0x5, \n-    0x1c, 0xf, 0x2, 0x225, 0x291, 0x3, 0x2, 0x2, 0x2, 0x226, 0x227, 0x9, \n-    0x3, 0x2, 0x2, 0x227, 0x228, 0x7, 0x63, 0x2, 0x2, 0x228, 0x22c, 0x7, \n-    0xb0, 0x2, 0x2, 0x229, 0x22a, 0x7, 0x4d, 0x2, 0x2, 0x22a, 0x22b, 0x7, \n-    0x72, 0x2, 0x2, 0x22b, 0x22d, 0x7, 0x38, 0x2, 0x2, 0x22c, 0x229, 0x3, \n-    0x2, 0x2, 0x2, 0x22c, 0x22d, 0x3, 0x2, 0x2, 0x2, 0x22d, 0x22e, 0x3, \n-    0x2, 0x2, 0x2, 0x22e, 0x230, 0x5, 0xc0, 0x61, 0x2, 0x22f, 0x231, 0x5, \n-    0x2e, 0x18, 0x2, 0x230, 0x22f, 0x3, 0x2, 0x2, 0x2, 0x230, 0x231, 0x3, \n-    0x2, 0x2, 0x2, 0x231, 0x233, 0x3, 0x2, 0x2, 0x2, 0x232, 0x234, 0x5, \n-    0x2c, 0x17, 0x2, 0x233, 0x232, 0x3, 0x2, 0x2, 0x2, 0x233, 0x234, 0x3, \n-    0x2, 0x2, 0x2, 0x234, 0x23a, 0x3, 0x2, 0x2, 0x2, 0x235, 0x236, 0x7, \n-    0xb6, 0x2, 0x2, 0x236, 0x238, 0x7, 0xa0, 0x2, 0x2, 0x237, 0x239, 0x7, \n-    0xbd, 0x2, 0x2, 0x238, 0x237, 0x3, 0x2, 0x2, 0x2, 0x238, 0x239, 0x3, \n-    0x2, 0x2, 0x2, 0x239, 0x23b, 0x3, 0x2, 0x2, 0x2, 0x23a, 0x235, 0x3, \n-    0x2, 0x2, 0x2, 0x23a, 0x23b, 0x3, 0x2, 0x2, 0x2, 0x23b, 0x23d, 0x3, \n-    0x2, 0x2, 0x2, 0x23c, 0x23e, 0x5, 0x30, 0x19, 0x2, 0x23d, 0x23c, 0x3, \n-    0x2, 0x2, 0x2, 0x23d, 0x23e, 0x3, 0x2, 0x2, 0x2, 0x23e, 0x240, 0x3, \n-    0x2, 0x2, 0x2, 0x23f, 0x241, 0x5, 0x34, 0x1b, 0x2, 0x240, 0x23f, 0x3, \n-    0x2, 0x2, 0x2, 0x240, 0x241, 0x3, 0x2, 0x2, 0x2, 0x241, 0x242, 0x3, \n-    0x2, 0x2, 0x2, 0x242, 0x243, 0x5, 0x32, 0x1a, 0x2, 0x243, 0x291, 0x3, \n-    0x2, 0x2, 0x2, 0x244, 0x245, 0x9, 0x3, 0x2, 0x2, 0x245, 0x246, 0x7, \n-    0x67, 0x2, 0x2, 0x246, 0x24a, 0x7, 0xb0, 0x2, 0x2, 0x247, 0x248, 0x7, \n-    0x4d, 0x2, 0x2, 0x248, 0x249, 0x7, 0x72, 0x2, 0x2, 0x249, 0x24b, 0x7, \n-    0x38, 0x2, 0x2, 0x24a, 0x247, 0x3, 0x2, 0x2, 0x2, 0x24a, 0x24b, 0x3, \n-    0x2, 0x2, 0x2, 0x24b, 0x24c, 0x3, 0x2, 0x2, 0x2, 0x24c, 0x24e, 0x5, \n-    0xc0, 0x61, 0x2, 0x24d, 0x24f, 0x5, 0x2e, 0x18, 0x2, 0x24e, 0x24d, 0x3, \n-    0x2, 0x2, 0x2, 0x24e, 0x24f, 0x3, 0x2, 0x2, 0x2, 0x24f, 0x251, 0x3, \n-    0x2, 0x2, 0x2, 0x250, 0x252, 0x5, 0x2c, 0x17, 0x2, 0x251, 0x250, 0x3, \n-    0x2, 0x2, 0x2, 0x251, 0x252, 0x3, 0x2, 0x2, 0x2, 0x252, 0x254, 0x3, \n-    0x2, 0x2, 0x2, 0x253, 0x255, 0x5, 0x34, 0x1b, 0x2, 0x254, 0x253, 0x3, \n-    0x2, 0x2, 0x2, 0x254, 0x255, 0x3, 0x2, 0x2, 0x2, 0x255, 0x25b, 0x3, \n-    0x2, 0x2, 0x2, 0x256, 0x25c, 0x5, 0x30, 0x19, 0x2, 0x257, 0x259, 0x5, \n-    0x36, 0x1c, 0x2, 0x258, 0x25a, 0x7, 0x7d, 0x2, 0x2, 0x259, 0x258, 0x3, \n-    0x2, 0x2, 0x2, 0x259, 0x25a, 0x3, 0x2, 0x2, 0x2, 0x25a, 0x25c, 0x3, \n-    0x2, 0x2, 0x2, 0x25b, 0x256, 0x3, 0x2, 0x2, 0x2, 0x25b, 0x257, 0x3, \n-    0x2, 0x2, 0x2, 0x25c, 0x25d, 0x3, 0x2, 0x2, 0x2, 0x25d, 0x25e, 0x5, \n-    0x32, 0x1a, 0x2, 0x25e, 0x291, 0x3, 0x2, 0x2, 0x2, 0x25f, 0x261, 0x9, \n-    0x3, 0x2, 0x2, 0x260, 0x262, 0x7, 0x9c, 0x2, 0x2, 0x261, 0x260, 0x3, \n-    0x2, 0x2, 0x2, 0x261, 0x262, 0x3, 0x2, 0x2, 0x2, 0x262, 0x263, 0x3, \n-    0x2, 0x2, 0x2, 0x263, 0x267, 0x7, 0x9a, 0x2, 0x2, 0x264, 0x265, 0x7, \n-    0x4d, 0x2, 0x2, 0x265, 0x266, 0x7, 0x72, 0x2, 0x2, 0x266, 0x268, 0x7, \n-    0x38, 0x2, 0x2, 0x267, 0x264, 0x3, 0x2, 0x2, 0x2, 0x267, 0x268, 0x3, \n-    0x2, 0x2, 0x2, 0x268, 0x269, 0x3, 0x2, 0x2, 0x2, 0x269, 0x26b, 0x5, \n-    0xc0, 0x61, 0x2, 0x26a, 0x26c, 0x5, 0x2e, 0x18, 0x2, 0x26b, 0x26a, 0x3, \n-    0x2, 0x2, 0x2, 0x26b, 0x26c, 0x3, 0x2, 0x2, 0x2, 0x26c, 0x26e, 0x3, \n-    0x2, 0x2, 0x2, 0x26d, 0x26f, 0x5, 0x2c, 0x17, 0x2, 0x26e, 0x26d, 0x3, \n-    0x2, 0x2, 0x2, 0x26e, 0x26f, 0x3, 0x2, 0x2, 0x2, 0x26f, 0x271, 0x3, \n-    0x2, 0x2, 0x2, 0x270, 0x272, 0x5, 0x34, 0x1b, 0x2, 0x271, 0x270, 0x3, \n-    0x2, 0x2, 0x2, 0x271, 0x272, 0x3, 0x2, 0x2, 0x2, 0x272, 0x274, 0x3, \n-    0x2, 0x2, 0x2, 0x273, 0x275, 0x5, 0x36, 0x1c, 0x2, 0x274, 0x273, 0x3, \n-    0x2, 0x2, 0x2, 0x274, 0x275, 0x3, 0x2, 0x2, 0x2, 0x275, 0x277, 0x3, \n-    0x2, 0x2, 0x2, 0x276, 0x278, 0x5, 0x32, 0x1a, 0x2, 0x277, 0x276, 0x3, \n-    0x2, 0x2, 0x2, 0x277, 0x278, 0x3, 0x2, 0x2, 0x2, 0x278, 0x291, 0x3, \n-    0x2, 0x2, 0x2, 0x279, 0x27c, 0x9, 0x3, 0x2, 0x2, 0x27a, 0x27b, 0x7, \n-    0x78, 0x2, 0x2, 0x27b, 0x27d, 0x7, 0x86, 0x2, 0x2, 0x27c, 0x27a, 0x3, \n-    0x2, 0x2, 0x2, 0x27c, 0x27d, 0x3, 0x2, 0x2, 0x2, 0x27d, 0x27e, 0x3, \n-    0x2, 0x2, 0x2, 0x27e, 0x282, 0x7, 0xb0, 0x2, 0x2, 0x27f, 0x280, 0x7, \n-    0x4d, 0x2, 0x2, 0x280, 0x281, 0x7, 0x72, 0x2, 0x2, 0x281, 0x283, 0x7, \n-    0x38, 0x2, 0x2, 0x282, 0x27f, 0x3, 0x2, 0x2, 0x2, 0x282, 0x283, 0x3, \n-    0x2, 0x2, 0x2, 0x283, 0x284, 0x3, 0x2, 0x2, 0x2, 0x284, 0x286, 0x5, \n-    0xc0, 0x61, 0x2, 0x285, 0x287, 0x5, 0x2e, 0x18, 0x2, 0x286, 0x285, 0x3, \n-    0x2, 0x2, 0x2, 0x286, 0x287, 0x3, 0x2, 0x2, 0x2, 0x287, 0x289, 0x3, \n-    0x2, 0x2, 0x2, 0x288, 0x28a, 0x5, 0x2c, 0x17, 0x2, 0x289, 0x288, 0x3, \n-    0x2, 0x2, 0x2, 0x289, 0x28a, 0x3, 0x2, 0x2, 0x2, 0x28a, 0x28c, 0x3, \n-    0x2, 0x2, 0x2, 0x28b, 0x28d, 0x5, 0x34, 0x1b, 0x2, 0x28c, 0x28b, 0x3, \n-    0x2, 0x2, 0x2, 0x28c, 0x28d, 0x3, 0x2, 0x2, 0x2, 0x28d, 0x28e, 0x3, \n-    0x2, 0x2, 0x2, 0x28e, 0x28f, 0x5, 0x32, 0x1a, 0x2, 0x28f, 0x291, 0x3, \n-    0x2, 0x2, 0x2, 0x290, 0x207, 0x3, 0x2, 0x2, 0x2, 0x290, 0x215, 0x3, \n-    0x2, 0x2, 0x2, 0x290, 0x226, 0x3, 0x2, 0x2, 0x2, 0x290, 0x244, 0x3, \n-    0x2, 0x2, 0x2, 0x290, 0x25f, 0x3, 0x2, 0x2, 0x2, 0x290, 0x279, 0x3, \n-    0x2, 0x2, 0x2, 0x291, 0x17, 0x3, 0x2, 0x2, 0x2, 0x292, 0x293, 0x7, 0xd0, \n-    0x2, 0x2, 0x293, 0x298, 0x5, 0x1a, 0xe, 0x2, 0x294, 0x295, 0x7, 0xc5, \n-    0x2, 0x2, 0x295, 0x297, 0x5, 0x1a, 0xe, 0x2, 0x296, 0x294, 0x3, 0x2, \n-    0x2, 0x2, 0x297, 0x29a, 0x3, 0x2, 0x2, 0x2, 0x298, 0x296, 0x3, 0x2, \n-    0x2, 0x2, 0x298, 0x299, 0x3, 0x2, 0x2, 0x2, 0x299, 0x29b, 0x3, 0x2, \n-    0x2, 0x2, 0x29a, 0x298, 0x3, 0x2, 0x2, 0x2, 0x29b, 0x29c, 0x7, 0xda, \n-    0x2, 0x2, 0x29c, 0x19, 0x3, 0x2, 0x2, 0x2, 0x29d, 0x29e, 0x5, 0xd6, \n-    0x6c, 0x2, 0x29e, 0x2b4, 0x5, 0xaa, 0x56, 0x2, 0x29f, 0x2a0, 0x6, 0xe, \n-    0x2, 0x3, 0x2a0, 0x2a1, 0x7, 0x27, 0x2, 0x2, 0x2a1, 0x2a2, 0x5, 0xcc, \n-    0x67, 0x2, 0x2a2, 0x2a3, 0x8, 0xe, 0x1, 0x2, 0x2a3, 0x2b3, 0x3, 0x2, \n-    0x2, 0x2, 0x2a4, 0x2a5, 0x6, 0xe, 0x3, 0x3, 0x2a5, 0x2a6, 0x7, 0x3a, \n-    0x2, 0x2, 0x2a6, 0x2a7, 0x5, 0xb0, 0x59, 0x2, 0x2a7, 0x2a8, 0x8, 0xe, \n-    0x1, 0x2, 0x2a8, 0x2b3, 0x3, 0x2, 0x2, 0x2, 0x2a9, 0x2aa, 0x6, 0xe, \n-    0x4, 0x3, 0x2aa, 0x2ab, 0x7, 0x4a, 0x2, 0x2, 0x2ab, 0x2b3, 0x8, 0xe, \n-    0x1, 0x2, 0x2ac, 0x2ad, 0x6, 0xe, 0x5, 0x3, 0x2ad, 0x2ae, 0x7, 0x52, \n-    0x2, 0x2, 0x2ae, 0x2b3, 0x8, 0xe, 0x1, 0x2, 0x2af, 0x2b0, 0x6, 0xe, \n-    0x6, 0x3, 0x2b0, 0x2b1, 0x7, 0x58, 0x2, 0x2, 0x2b1, 0x2b3, 0x8, 0xe, \n-    0x1, 0x2, 0x2b2, 0x29f, 0x3, 0x2, 0x2, 0x2, 0x2b2, 0x2a4, 0x3, 0x2, \n-    0x2, 0x2, 0x2b2, 0x2a9, 0x3, 0x2, 0x2, 0x2, 0x2b2, 0x2ac, 0x3, 0x2, \n-    0x2, 0x2, 0x2b2, 0x2af, 0x3, 0x2, 0x2, 0x2, 0x2b3, 0x2b6, 0x3, 0x2, \n-    0x2, 0x2, 0x2b4, 0x2b2, 0x3, 0x2, 0x2, 0x2, 0x2b4, 0x2b5, 0x3, 0x2, \n-    0x2, 0x2, 0x2b5, 0x1b, 0x3, 0x2, 0x2, 0x2, 0x2b6, 0x2b4, 0x3, 0x2, 0x2, \n-    0x2, 0x2b7, 0x2b9, 0x5, 0x1e, 0x10, 0x2, 0x2b8, 0x2b7, 0x3, 0x2, 0x2, \n-    0x2, 0x2b8, 0x2b9, 0x3, 0x2, 0x2, 0x2, 0x2b9, 0x2d0, 0x3, 0x2, 0x2, \n-    0x2, 0x2ba, 0x2bb, 0x6, 0xf, 0x7, 0x3, 0x2bb, 0x2bc, 0x5, 0x22, 0x12, \n-    0x2, 0x2bc, 0x2bd, 0x8, 0xf, 0x1, 0x2, 0x2bd, 0x2cf, 0x3, 0x2, 0x2, \n-    0x2, 0x2be, 0x2bf, 0x6, 0xf, 0x8, 0x3, 0x2bf, 0x2c0, 0x5, 0x24, 0x13, \n-    0x2, 0x2c0, 0x2c1, 0x8, 0xf, 0x1, 0x2, 0x2c1, 0x2cf, 0x3, 0x2, 0x2, \n-    0x2, 0x2c2, 0x2c3, 0x6, 0xf, 0x9, 0x3, 0x2c3, 0x2c4, 0x5, 0x26, 0x14, \n-    0x2, 0x2c4, 0x2c5, 0x8, 0xf, 0x1, 0x2, 0x2c5, 0x2cf, 0x3, 0x2, 0x2, \n-    0x2, 0x2c6, 0x2c7, 0x6, 0xf, 0xa, 0x3, 0x2c7, 0x2c8, 0x5, 0x28, 0x15, \n-    0x2, 0x2c8, 0x2c9, 0x8, 0xf, 0x1, 0x2, 0x2c9, 0x2cf, 0x3, 0x2, 0x2, \n-    0x2, 0x2ca, 0x2cb, 0x6, 0xf, 0xb, 0x3, 0x2cb, 0x2cc, 0x5, 0x2a, 0x16, \n-    0x2, 0x2cc, 0x2cd, 0x8, 0xf, 0x1, 0x2, 0x2cd, 0x2cf, 0x3, 0x2, 0x2, \n-    0x2, 0x2ce, 0x2ba, 0x3, 0x2, 0x2, 0x2, 0x2ce, 0x2be, 0x3, 0x2, 0x2, \n-    0x2, 0x2ce, 0x2c2, 0x3, 0x2, 0x2, 0x2, 0x2ce, 0x2c6, 0x3, 0x2, 0x2, \n-    0x2, 0x2ce, 0x2ca, 0x3, 0x2, 0x2, 0x2, 0x2cf, 0x2d2, 0x3, 0x2, 0x2, \n-    0x2, 0x2d0, 0x2ce, 0x3, 0x2, 0x2, 0x2, 0x2d0, 0x2d1, 0x3, 0x2, 0x2, \n-    0x2, 0x2d1, 0x1d, 0x3, 0x2, 0x2, 0x2, 0x2d2, 0x2d0, 0x3, 0x2, 0x2, 0x2, \n-    0x2d3, 0x2d4, 0x7, 0x7f, 0x2, 0x2, 0x2d4, 0x2d5, 0x7, 0x5a, 0x2, 0x2, \n-    0x2d5, 0x2d6, 0x5, 0xac, 0x57, 0x2, 0x2d6, 0x1f, 0x3, 0x2, 0x2, 0x2, \n-    0x2d7, 0x2de, 0x5, 0xd6, 0x6c, 0x2, 0x2d8, 0x2db, 0x5, 0xd6, 0x6c, 0x2, \n-    0x2d9, 0x2da, 0x7, 0xd0, 0x2, 0x2, 0x2da, 0x2dc, 0x7, 0xda, 0x2, 0x2, \n-    0x2db, 0x2d9, 0x3, 0x2, 0x2, 0x2, 0x2db, 0x2dc, 0x3, 0x2, 0x2, 0x2, \n-    0x2dc, 0x2df, 0x3, 0x2, 0x2, 0x2, 0x2dd, 0x2df, 0x5, 0xcc, 0x67, 0x2, \n-    0x2de, 0x2d8, 0x3, 0x2, 0x2, 0x2, 0x2de, 0x2dd, 0x3, 0x2, 0x2, 0x2, \n-    0x2df, 0x21, 0x3, 0x2, 0x2, 0x2, 0x2e0, 0x2e1, 0x7, 0x93, 0x2, 0x2, \n-    0x2e1, 0x2e2, 0x7, 0xd0, 0x2, 0x2, 0x2e2, 0x2e3, 0x5, 0xd6, 0x6c, 0x2, \n-    0x2e3, 0x2e7, 0x7, 0xd0, 0x2, 0x2, 0x2e4, 0x2e6, 0x5, 0x20, 0x11, 0x2, \n-    0x2e5, 0x2e4, 0x3, 0x2, 0x2, 0x2, 0x2e6, 0x2e9, 0x3, 0x2, 0x2, 0x2, \n-    0x2e7, 0x2e5, 0x3, 0x2, 0x2, 0x2, 0x2e7, 0x2e8, 0x3, 0x2, 0x2, 0x2, \n-    0x2e8, 0x2ea, 0x3, 0x2, 0x2, 0x2, 0x2e9, 0x2e7, 0x3, 0x2, 0x2, 0x2, \n-    0x2ea, 0x2eb, 0x7, 0xda, 0x2, 0x2, 0x2eb, 0x2ec, 0x7, 0xda, 0x2, 0x2, \n-    0x2ec, 0x23, 0x3, 0x2, 0x2, 0x2, 0x2ed, 0x2ee, 0x7, 0x60, 0x2, 0x2, \n-    0x2ee, 0x2f8, 0x7, 0xd0, 0x2, 0x2, 0x2ef, 0x2f9, 0x7, 0xbd, 0x2, 0x2, \n-    0x2f0, 0x2f1, 0x7, 0x6a, 0x2, 0x2, 0x2f1, 0x2f2, 0x7, 0xbd, 0x2, 0x2, \n-    0x2f2, 0x2f3, 0x7, 0x68, 0x2, 0x2, 0x2f3, 0x2f9, 0x7, 0xbd, 0x2, 0x2, \n-    0x2f4, 0x2f5, 0x7, 0x68, 0x2, 0x2, 0x2f5, 0x2f6, 0x7, 0xbd, 0x2, 0x2, \n-    0x2f6, 0x2f7, 0x7, 0x6a, 0x2, 0x2, 0x2f7, 0x2f9, 0x7, 0xbd, 0x2, 0x2, \n-    0x2f8, 0x2ef, 0x3, 0x2, 0x2, 0x2, 0x2f8, 0x2f0, 0x3, 0x2, 0x2, 0x2, \n-    0x2f8, 0x2f4, 0x3, 0x2, 0x2, 0x2, 0x2f9, 0x2fa, 0x3, 0x2, 0x2, 0x2, \n-    0x2fa, 0x2fb, 0x7, 0xda, 0x2, 0x2, 0x2fb, 0x25, 0x3, 0x2, 0x2, 0x2, \n-    0x2fc, 0x2fd, 0x7, 0x5d, 0x2, 0x2, 0x2fd, 0x2fe, 0x7, 0xd0, 0x2, 0x2, \n-    0x2fe, 0x2ff, 0x5, 0xd6, 0x6c, 0x2, 0x2ff, 0x303, 0x7, 0xd0, 0x2, 0x2, \n-    0x300, 0x302, 0x5, 0x20, 0x11, 0x2, 0x301, 0x300, 0x3, 0x2, 0x2, 0x2, \n-    0x302, 0x305, 0x3, 0x2, 0x2, 0x2, 0x303, 0x301, 0x3, 0x2, 0x2, 0x2, \n-    0x303, 0x304, 0x3, 0x2, 0x2, 0x2, 0x304, 0x306, 0x3, 0x2, 0x2, 0x2, \n-    0x305, 0x303, 0x3, 0x2, 0x2, 0x2, 0x306, 0x307, 0x7, 0xda, 0x2, 0x2, \n-    0x307, 0x308, 0x7, 0xda, 0x2, 0x2, 0x308, 0x27, 0x3, 0x2, 0x2, 0x2, \n-    0x309, 0x30a, 0x7, 0x82, 0x2, 0x2, 0x30a, 0x315, 0x7, 0xd0, 0x2, 0x2, \n-    0x30b, 0x30c, 0x7, 0x6a, 0x2, 0x2, 0x30c, 0x30d, 0x5, 0xd6, 0x6c, 0x2, \n-    0x30d, 0x30e, 0x7, 0x68, 0x2, 0x2, 0x30e, 0x30f, 0x5, 0xd6, 0x6c, 0x2, \n-    0x30f, 0x316, 0x3, 0x2, 0x2, 0x2, 0x310, 0x311, 0x7, 0x68, 0x2, 0x2, \n-    0x311, 0x312, 0x5, 0xd6, 0x6c, 0x2, 0x312, 0x313, 0x7, 0x6a, 0x2, 0x2, \n-    0x313, 0x314, 0x5, 0xd6, 0x6c, 0x2, 0x314, 0x316, 0x3, 0x2, 0x2, 0x2, \n-    0x315, 0x30b, 0x3, 0x2, 0x2, 0x2, 0x315, 0x310, 0x3, 0x2, 0x2, 0x2, \n-    0x316, 0x317, 0x3, 0x2, 0x2, 0x2, 0x317, 0x318, 0x7, 0xda, 0x2, 0x2, \n-    0x318, 0x29, 0x3, 0x2, 0x2, 0x2, 0x319, 0x31a, 0x7, 0x91, 0x2, 0x2, \n-    0x31a, 0x31b, 0x7, 0xd0, 0x2, 0x2, 0x31b, 0x31c, 0x5, 0x9a, 0x4e, 0x2, \n-    0x31c, 0x31d, 0x7, 0xda, 0x2, 0x2, 0x31d, 0x2b, 0x3, 0x2, 0x2, 0x2, \n-    0x31e, 0x31f, 0x7, 0x76, 0x2, 0x2, 0x31f, 0x322, 0x7, 0x19, 0x2, 0x2, \n-    0x320, 0x323, 0x5, 0xd6, 0x6c, 0x2, 0x321, 0x323, 0x7, 0xbf, 0x2, 0x2, \n-    0x322, 0x320, 0x3, 0x2, 0x2, 0x2, 0x322, 0x321, 0x3, 0x2, 0x2, 0x2, \n-    0x323, 0x2d, 0x3, 0x2, 0x2, 0x2, 0x324, 0x325, 0x7, 0xae, 0x2, 0x2, \n-    0x325, 0x326, 0x7, 0xbf, 0x2, 0x2, 0x326, 0x2f, 0x3, 0x2, 0x2, 0x2, \n-    0x327, 0x328, 0x7, 0xa2, 0x2, 0x2, 0x328, 0x329, 0x5, 0xc0, 0x61, 0x2, \n-    0x329, 0x31, 0x3, 0x2, 0x2, 0x2, 0x32a, 0x32b, 0x7, 0xc, 0x2, 0x2, 0x32b, \n-    0x32c, 0x5, 0x68, 0x35, 0x2, 0x32c, 0x33, 0x3, 0x2, 0x2, 0x2, 0x32d, \n-    0x32e, 0x7, 0xd0, 0x2, 0x2, 0x32e, 0x333, 0x5, 0x42, 0x22, 0x2, 0x32f, \n-    0x330, 0x7, 0xc5, 0x2, 0x2, 0x330, 0x332, 0x5, 0x42, 0x22, 0x2, 0x331, \n-    0x32f, 0x3, 0x2, 0x2, 0x2, 0x332, 0x335, 0x3, 0x2, 0x2, 0x2, 0x333, \n-    0x331, 0x3, 0x2, 0x2, 0x2, 0x333, 0x334, 0x3, 0x2, 0x2, 0x2, 0x334, \n-    0x336, 0x3, 0x2, 0x2, 0x2, 0x335, 0x333, 0x3, 0x2, 0x2, 0x2, 0x336, \n-    0x337, 0x7, 0xda, 0x2, 0x2, 0x337, 0x33d, 0x3, 0x2, 0x2, 0x2, 0x338, \n-    0x339, 0x7, 0xc, 0x2, 0x2, 0x339, 0x33d, 0x5, 0xc0, 0x61, 0x2, 0x33a, \n-    0x33b, 0x7, 0xc, 0x2, 0x2, 0x33b, 0x33d, 0x5, 0xbe, 0x60, 0x2, 0x33c, \n-    0x32d, 0x3, 0x2, 0x2, 0x2, 0x33c, 0x338, 0x3, 0x2, 0x2, 0x2, 0x33c, \n-    0x33a, 0x3, 0x2, 0x2, 0x2, 0x33d, 0x35, 0x3, 0x2, 0x2, 0x2, 0x33e, 0x359, \n-    0x5, 0x40, 0x21, 0x2, 0x33f, 0x340, 0x6, 0x1c, 0xc, 0x3, 0x340, 0x341, \n-    0x5, 0x7e, 0x40, 0x2, 0x341, 0x342, 0x8, 0x1c, 0x1, 0x2, 0x342, 0x358, \n-    0x3, 0x2, 0x2, 0x2, 0x343, 0x344, 0x6, 0x1c, 0xd, 0x3, 0x344, 0x345, \n-    0x5, 0x38, 0x1d, 0x2, 0x345, 0x346, 0x8, 0x1c, 0x1, 0x2, 0x346, 0x358, \n-    0x3, 0x2, 0x2, 0x2, 0x347, 0x348, 0x6, 0x1c, 0xe, 0x3, 0x348, 0x349, \n-    0x5, 0x3a, 0x1e, 0x2, 0x349, 0x34a, 0x8, 0x1c, 0x1, 0x2, 0x34a, 0x358, \n-    0x3, 0x2, 0x2, 0x2, 0x34b, 0x34c, 0x6, 0x1c, 0xf, 0x3, 0x34c, 0x34d, \n-    0x5, 0x3c, 0x1f, 0x2, 0x34d, 0x34e, 0x8, 0x1c, 0x1, 0x2, 0x34e, 0x358, \n-    0x3, 0x2, 0x2, 0x2, 0x34f, 0x350, 0x6, 0x1c, 0x10, 0x3, 0x350, 0x351, \n-    0x5, 0x3e, 0x20, 0x2, 0x351, 0x352, 0x8, 0x1c, 0x1, 0x2, 0x352, 0x358, \n-    0x3, 0x2, 0x2, 0x2, 0x353, 0x354, 0x6, 0x1c, 0x11, 0x3, 0x354, 0x355, \n-    0x5, 0x86, 0x44, 0x2, 0x355, 0x356, 0x8, 0x1c, 0x1, 0x2, 0x356, 0x358, \n-    0x3, 0x2, 0x2, 0x2, 0x357, 0x33f, 0x3, 0x2, 0x2, 0x2, 0x357, 0x343, \n-    0x3, 0x2, 0x2, 0x2, 0x357, 0x347, 0x3, 0x2, 0x2, 0x2, 0x357, 0x34b, \n-    0x3, 0x2, 0x2, 0x2, 0x357, 0x34f, 0x3, 0x2, 0x2, 0x2, 0x357, 0x353, \n-    0x3, 0x2, 0x2, 0x2, 0x358, 0x35b, 0x3, 0x2, 0x2, 0x2, 0x359, 0x357, \n-    0x3, 0x2, 0x2, 0x2, 0x359, 0x35a, 0x3, 0x2, 0x2, 0x2, 0x35a, 0x37, 0x3, \n-    0x2, 0x2, 0x2, 0x35b, 0x359, 0x3, 0x2, 0x2, 0x2, 0x35c, 0x35d, 0x7, \n-    0x7c, 0x2, 0x2, 0x35d, 0x35e, 0x7, 0x14, 0x2, 0x2, 0x35e, 0x35f, 0x5, \n-    0xb0, 0x59, 0x2, 0x35f, 0x39, 0x3, 0x2, 0x2, 0x2, 0x360, 0x361, 0x7, \n-    0x7f, 0x2, 0x2, 0x361, 0x362, 0x7, 0x5a, 0x2, 0x2, 0x362, 0x363, 0x5, \n-    0xb0, 0x59, 0x2, 0x363, 0x3b, 0x3, 0x2, 0x2, 0x2, 0x364, 0x365, 0x7, \n-    0x8b, 0x2, 0x2, 0x365, 0x366, 0x7, 0x14, 0x2, 0x2, 0x366, 0x367, 0x5, \n-    0xb0, 0x59, 0x2, 0x367, 0x3d, 0x3, 0x2, 0x2, 0x2, 0x368, 0x369, 0x7, \n-    0xa8, 0x2, 0x2, 0x369, 0x36e, 0x5, 0x50, 0x29, 0x2, 0x36a, 0x36b, 0x7, \n-    0xc5, 0x2, 0x2, 0x36b, 0x36d, 0x5, 0x50, 0x29, 0x2, 0x36c, 0x36a, 0x3, \n-    0x2, 0x2, 0x2, 0x36d, 0x370, 0x3, 0x2, 0x2, 0x2, 0x36e, 0x36c, 0x3, \n-    0x2, 0x2, 0x2, 0x36e, 0x36f, 0x3, 0x2, 0x2, 0x2, 0x36f, 0x3f, 0x3, 0x2, \n-    0x2, 0x2, 0x370, 0x36e, 0x3, 0x2, 0x2, 0x2, 0x371, 0x373, 0x7, 0x36, \n-    0x2, 0x2, 0x372, 0x374, 0x7, 0xca, 0x2, 0x2, 0x373, 0x372, 0x3, 0x2, \n-    0x2, 0x2, 0x373, 0x374, 0x3, 0x2, 0x2, 0x2, 0x374, 0x375, 0x3, 0x2, \n-    0x2, 0x2, 0x375, 0x37b, 0x5, 0xd8, 0x6d, 0x2, 0x376, 0x378, 0x7, 0xd0, \n-    0x2, 0x2, 0x377, 0x379, 0x5, 0xac, 0x57, 0x2, 0x378, 0x377, 0x3, 0x2, \n-    0x2, 0x2, 0x378, 0x379, 0x3, 0x2, 0x2, 0x2, 0x379, 0x37a, 0x3, 0x2, \n-    0x2, 0x2, 0x37a, 0x37c, 0x7, 0xda, 0x2, 0x2, 0x37b, 0x376, 0x3, 0x2, \n-    0x2, 0x2, 0x37b, 0x37c, 0x3, 0x2, 0x2, 0x2, 0x37c, 0x41, 0x3, 0x2, 0x2, \n-    0x2, 0x37d, 0x388, 0x5, 0x44, 0x23, 0x2, 0x37e, 0x37f, 0x7, 0x1e, 0x2, \n-    0x2, 0x37f, 0x380, 0x5, 0xd6, 0x6c, 0x2, 0x380, 0x381, 0x7, 0x17, 0x2, \n-    0x2, 0x381, 0x382, 0x5, 0xb0, 0x59, 0x2, 0x382, 0x388, 0x3, 0x2, 0x2, \n-    0x2, 0x383, 0x384, 0x7, 0x50, 0x2, 0x2, 0x384, 0x388, 0x5, 0x48, 0x25, \n-    0x2, 0x385, 0x386, 0x7, 0x80, 0x2, 0x2, 0x386, 0x388, 0x5, 0x4a, 0x26, \n-    0x2, 0x387, 0x37d, 0x3, 0x2, 0x2, 0x2, 0x387, 0x37e, 0x3, 0x2, 0x2, \n-    0x2, 0x387, 0x383, 0x3, 0x2, 0x2, 0x2, 0x387, 0x385, 0x3, 0x2, 0x2, \n-    0x2, 0x388, 0x43, 0x3, 0x2, 0x2, 0x2, 0x389, 0x38a, 0x5, 0xba, 0x5e, \n-    0x2, 0x38a, 0x38c, 0x5, 0xaa, 0x56, 0x2, 0x38b, 0x38d, 0x5, 0x46, 0x24, \n-    0x2, 0x38c, 0x38b, 0x3, 0x2, 0x2, 0x2, 0x38c, 0x38d, 0x3, 0x2, 0x2, \n-    0x2, 0x38d, 0x390, 0x3, 0x2, 0x2, 0x2, 0x38e, 0x38f, 0x7, 0x1d, 0x2, \n-    0x2, 0x38f, 0x391, 0x7, 0xbf, 0x2, 0x2, 0x390, 0x38e, 0x3, 0x2, 0x2, \n-    0x2, 0x390, 0x391, 0x3, 0x2, 0x2, 0x2, 0x391, 0x393, 0x3, 0x2, 0x2, \n-    0x2, 0x392, 0x394, 0x5, 0x4c, 0x27, 0x2, 0x393, 0x392, 0x3, 0x2, 0x2, \n-    0x2, 0x393, 0x394, 0x3, 0x2, 0x2, 0x2, 0x394, 0x397, 0x3, 0x2, 0x2, \n-    0x2, 0x395, 0x396, 0x7, 0xa8, 0x2, 0x2, 0x396, 0x398, 0x5, 0xb0, 0x59, \n-    0x2, 0x397, 0x395, 0x3, 0x2, 0x2, 0x2, 0x397, 0x398, 0x3, 0x2, 0x2, \n-    0x2, 0x398, 0x3aa, 0x3, 0x2, 0x2, 0x2, 0x399, 0x39b, 0x5, 0xba, 0x5e, \n-    0x2, 0x39a, 0x39c, 0x5, 0xaa, 0x56, 0x2, 0x39b, 0x39a, 0x3, 0x2, 0x2, \n-    0x2, 0x39b, 0x39c, 0x3, 0x2, 0x2, 0x2, 0x39c, 0x39d, 0x3, 0x2, 0x2, \n-    0x2, 0x39d, 0x3a0, 0x5, 0x46, 0x24, 0x2, 0x39e, 0x39f, 0x7, 0x1d, 0x2, \n-    0x2, 0x39f, 0x3a1, 0x7, 0xbf, 0x2, 0x2, 0x3a0, 0x39e, 0x3, 0x2, 0x2, \n-    0x2, 0x3a0, 0x3a1, 0x3, 0x2, 0x2, 0x2, 0x3a1, 0x3a3, 0x3, 0x2, 0x2, \n-    0x2, 0x3a2, 0x3a4, 0x5, 0x4c, 0x27, 0x2, 0x3a3, 0x3a2, 0x3, 0x2, 0x2, \n-    0x2, 0x3a3, 0x3a4, 0x3, 0x2, 0x2, 0x2, 0x3a4, 0x3a7, 0x3, 0x2, 0x2, \n-    0x2, 0x3a5, 0x3a6, 0x7, 0xa8, 0x2, 0x2, 0x3a6, 0x3a8, 0x5, 0xb0, 0x59, \n-    0x2, 0x3a7, 0x3a5, 0x3, 0x2, 0x2, 0x2, 0x3a7, 0x3a8, 0x3, 0x2, 0x2, \n-    0x2, 0x3a8, 0x3aa, 0x3, 0x2, 0x2, 0x2, 0x3a9, 0x389, 0x3, 0x2, 0x2, \n-    0x2, 0x3a9, 0x399, 0x3, 0x2, 0x2, 0x2, 0x3aa, 0x45, 0x3, 0x2, 0x2, 0x2, \n-    0x3ab, 0x3ac, 0x9, 0x4, 0x2, 0x2, 0x3ac, 0x3ad, 0x5, 0xb0, 0x59, 0x2, \n-    0x3ad, 0x47, 0x3, 0x2, 0x2, 0x2, 0x3ae, 0x3af, 0x5, 0xba, 0x5e, 0x2, \n-    0x3af, 0x3b0, 0x5, 0xb0, 0x59, 0x2, 0x3b0, 0x3b1, 0x7, 0xa9, 0x2, 0x2, \n-    0x3b1, 0x3b2, 0x5, 0xaa, 0x56, 0x2, 0x3b2, 0x3b3, 0x7, 0x47, 0x2, 0x2, \n-    0x3b3, 0x3b4, 0x7, 0xbd, 0x2, 0x2, 0x3b4, 0x49, 0x3, 0x2, 0x2, 0x2, \n-    0x3b5, 0x3b6, 0x5, 0xba, 0x5e, 0x2, 0x3b6, 0x3b7, 0x5, 0x66, 0x34, 0x2, \n-    0x3b7, 0x4b, 0x3, 0x2, 0x2, 0x2, 0x3b8, 0x3b9, 0x7, 0x1a, 0x2, 0x2, \n-    0x3b9, 0x3ba, 0x7, 0xd0, 0x2, 0x2, 0x3ba, 0x3bf, 0x5, 0x4e, 0x28, 0x2, \n-    0x3bb, 0x3bc, 0x7, 0xc5, 0x2, 0x2, 0x3bc, 0x3be, 0x5, 0x4e, 0x28, 0x2, \n-    0x3bd, 0x3bb, 0x3, 0x2, 0x2, 0x2, 0x3be, 0x3c1, 0x3, 0x2, 0x2, 0x2, \n-    0x3bf, 0x3bd, 0x3, 0x2, 0x2, 0x2, 0x3bf, 0x3c0, 0x3, 0x2, 0x2, 0x2, \n-    0x3c0, 0x3c2, 0x3, 0x2, 0x2, 0x2, 0x3c1, 0x3bf, 0x3, 0x2, 0x2, 0x2, \n-    0x3c2, 0x3c3, 0x7, 0xda, 0x2, 0x2, 0x3c3, 0x4d, 0x3, 0x2, 0x2, 0x2, \n-    0x3c4, 0x3ca, 0x5, 0xd6, 0x6c, 0x2, 0x3c5, 0x3c7, 0x7, 0xd0, 0x2, 0x2, \n-    0x3c6, 0x3c8, 0x5, 0xac, 0x57, 0x2, 0x3c7, 0x3c6, 0x3, 0x2, 0x2, 0x2, \n-    0x3c7, 0x3c8, 0x3, 0x2, 0x2, 0x2, 0x3c8, 0x3c9, 0x3, 0x2, 0x2, 0x2, \n-    0x3c9, 0x3cb, 0x7, 0xda, 0x2, 0x2, 0x3ca, 0x3c5, 0x3, 0x2, 0x2, 0x2, \n-    0x3ca, 0x3cb, 0x3, 0x2, 0x2, 0x2, 0x3cb, 0x4f, 0x3, 0x2, 0x2, 0x2, 0x3cc, \n-    0x3d4, 0x5, 0xb0, 0x59, 0x2, 0x3cd, 0x3d5, 0x7, 0x29, 0x2, 0x2, 0x3ce, \n-    0x3cf, 0x7, 0xa2, 0x2, 0x2, 0x3cf, 0x3d0, 0x7, 0x30, 0x2, 0x2, 0x3d0, \n-    0x3d5, 0x7, 0xbf, 0x2, 0x2, 0x3d1, 0x3d2, 0x7, 0xa2, 0x2, 0x2, 0x3d2, \n-    0x3d3, 0x7, 0xb1, 0x2, 0x2, 0x3d3, 0x3d5, 0x7, 0xbf, 0x2, 0x2, 0x3d4, \n-    0x3cd, 0x3, 0x2, 0x2, 0x2, 0x3d4, 0x3ce, 0x3, 0x2, 0x2, 0x2, 0x3d4, \n-    0x3d1, 0x3, 0x2, 0x2, 0x2, 0x3d4, 0x3d5, 0x3, 0x2, 0x2, 0x2, 0x3d5, \n-    0x51, 0x3, 0x2, 0x2, 0x2, 0x3d6, 0x3d8, 0x9, 0x5, 0x2, 0x2, 0x3d7, 0x3d9, \n-    0x7, 0x9a, 0x2, 0x2, 0x3d8, 0x3d7, 0x3, 0x2, 0x2, 0x2, 0x3d8, 0x3d9, \n-    0x3, 0x2, 0x2, 0x2, 0x3d9, 0x3da, 0x3, 0x2, 0x2, 0x2, 0x3da, 0x3db, \n-    0x5, 0xbc, 0x5f, 0x2, 0x3db, 0x53, 0x3, 0x2, 0x2, 0x2, 0x3dc, 0x3dd, \n-    0x9, 0x6, 0x2, 0x2, 0x3dd, 0x3e0, 0x7, 0x22, 0x2, 0x2, 0x3de, 0x3df, \n-    0x7, 0x4d, 0x2, 0x2, 0x3df, 0x3e1, 0x7, 0x38, 0x2, 0x2, 0x3e0, 0x3de, \n-    0x3, 0x2, 0x2, 0x2, 0x3e0, 0x3e1, 0x3, 0x2, 0x2, 0x2, 0x3e1, 0x3e2, \n-    0x3, 0x2, 0x2, 0x2, 0x3e2, 0x3e4, 0x5, 0xc6, 0x64, 0x2, 0x3e3, 0x3e5, \n-    0x5, 0x2c, 0x17, 0x2, 0x3e4, 0x3e3, 0x3, 0x2, 0x2, 0x2, 0x3e4, 0x3e5, \n-    0x3, 0x2, 0x2, 0x2, 0x3e5, 0x3fc, 0x3, 0x2, 0x2, 0x2, 0x3e6, 0x3ed, \n-    0x9, 0x6, 0x2, 0x2, 0x3e7, 0x3ee, 0x7, 0x2f, 0x2, 0x2, 0x3e8, 0x3ea, \n-    0x7, 0x9c, 0x2, 0x2, 0x3e9, 0x3e8, 0x3, 0x2, 0x2, 0x2, 0x3e9, 0x3ea, \n-    0x3, 0x2, 0x2, 0x2, 0x3ea, 0x3eb, 0x3, 0x2, 0x2, 0x2, 0x3eb, 0x3ee, \n-    0x7, 0x9a, 0x2, 0x2, 0x3ec, 0x3ee, 0x7, 0xb0, 0x2, 0x2, 0x3ed, 0x3e7, \n-    0x3, 0x2, 0x2, 0x2, 0x3ed, 0x3e9, 0x3, 0x2, 0x2, 0x2, 0x3ed, 0x3ec, \n-    0x3, 0x2, 0x2, 0x2, 0x3ee, 0x3f1, 0x3, 0x2, 0x2, 0x2, 0x3ef, 0x3f0, \n-    0x7, 0x4d, 0x2, 0x2, 0x3f0, 0x3f2, 0x7, 0x38, 0x2, 0x2, 0x3f1, 0x3ef, \n-    0x3, 0x2, 0x2, 0x2, 0x3f1, 0x3f2, 0x3, 0x2, 0x2, 0x2, 0x3f2, 0x3f3, \n-    0x3, 0x2, 0x2, 0x2, 0x3f3, 0x3f5, 0x5, 0xc0, 0x61, 0x2, 0x3f4, 0x3f6, \n-    0x5, 0x2c, 0x17, 0x2, 0x3f5, 0x3f4, 0x3, 0x2, 0x2, 0x2, 0x3f5, 0x3f6, \n-    0x3, 0x2, 0x2, 0x2, 0x3f6, 0x3f9, 0x3, 0x2, 0x2, 0x2, 0x3f7, 0x3f8, \n-    0x7, 0x71, 0x2, 0x2, 0x3f8, 0x3fa, 0x7, 0x28, 0x2, 0x2, 0x3f9, 0x3f7, \n-    0x3, 0x2, 0x2, 0x2, 0x3f9, 0x3fa, 0x3, 0x2, 0x2, 0x2, 0x3fa, 0x3fc, \n-    0x3, 0x2, 0x2, 0x2, 0x3fb, 0x3dc, 0x3, 0x2, 0x2, 0x2, 0x3fb, 0x3e6, \n-    0x3, 0x2, 0x2, 0x2, 0x3fc, 0x55, 0x3, 0x2, 0x2, 0x2, 0x3fd, 0x3fe, 0x7, \n-    0x38, 0x2, 0x2, 0x3fe, 0x3ff, 0x7, 0x22, 0x2, 0x2, 0x3ff, 0x40b, 0x5, \n-    0xc6, 0x64, 0x2, 0x400, 0x407, 0x7, 0x38, 0x2, 0x2, 0x401, 0x408, 0x7, \n-    0x2f, 0x2, 0x2, 0x402, 0x404, 0x7, 0x9c, 0x2, 0x2, 0x403, 0x402, 0x3, \n-    0x2, 0x2, 0x2, 0x403, 0x404, 0x3, 0x2, 0x2, 0x2, 0x404, 0x405, 0x3, \n-    0x2, 0x2, 0x2, 0x405, 0x408, 0x7, 0x9a, 0x2, 0x2, 0x406, 0x408, 0x7, \n-    0xb0, 0x2, 0x2, 0x407, 0x401, 0x3, 0x2, 0x2, 0x2, 0x407, 0x403, 0x3, \n-    0x2, 0x2, 0x2, 0x407, 0x406, 0x3, 0x2, 0x2, 0x2, 0x407, 0x408, 0x3, \n-    0x2, 0x2, 0x2, 0x408, 0x409, 0x3, 0x2, 0x2, 0x2, 0x409, 0x40b, 0x5, \n-    0xc0, 0x61, 0x2, 0x40a, 0x3fd, 0x3, 0x2, 0x2, 0x2, 0x40a, 0x400, 0x3, \n-    0x2, 0x2, 0x2, 0x40b, 0x57, 0x3, 0x2, 0x2, 0x2, 0x40c, 0x40d, 0x7, 0x39, \n-    0x2, 0x2, 0x40d, 0x40e, 0x7, 0xf, 0x2, 0x2, 0x40e, 0x413, 0x5, 0x4, \n-    0x3, 0x2, 0x40f, 0x410, 0x7, 0x39, 0x2, 0x2, 0x410, 0x411, 0x7, 0x98, \n-    0x2, 0x2, 0x411, 0x413, 0x5, 0x4, 0x3, 0x2, 0x412, 0x40c, 0x3, 0x2, \n-    0x2, 0x2, 0x412, 0x40f, 0x3, 0x2, 0x2, 0x2, 0x413, 0x59, 0x3, 0x2, 0x2, \n-    0x2, 0x414, 0x415, 0x7, 0x54, 0x2, 0x2, 0x415, 0x417, 0x7, 0x56, 0x2, \n-    0x2, 0x416, 0x418, 0x7, 0x9a, 0x2, 0x2, 0x417, 0x416, 0x3, 0x2, 0x2, \n-    0x2, 0x417, 0x418, 0x3, 0x2, 0x2, 0x2, 0x418, 0x41c, 0x3, 0x2, 0x2, \n-    0x2, 0x419, 0x41d, 0x5, 0xc0, 0x61, 0x2, 0x41a, 0x41b, 0x7, 0x45, 0x2, \n-    0x2, 0x41b, 0x41d, 0x5, 0xbe, 0x60, 0x2, 0x41c, 0x419, 0x3, 0x2, 0x2, \n-    0x2, 0x41c, 0x41a, 0x3, 0x2, 0x2, 0x2, 0x41d, 0x41f, 0x3, 0x2, 0x2, \n-    0x2, 0x41e, 0x420, 0x5, 0x5c, 0x2f, 0x2, 0x41f, 0x41e, 0x3, 0x2, 0x2, \n-    0x2, 0x41f, 0x420, 0x3, 0x2, 0x2, 0x2, 0x420, 0x421, 0x3, 0x2, 0x2, \n-    0x2, 0x421, 0x422, 0x5, 0x5e, 0x30, 0x2, 0x422, 0x5b, 0x3, 0x2, 0x2, \n-    0x2, 0x423, 0x424, 0x7, 0xd0, 0x2, 0x2, 0x424, 0x429, 0x5, 0xba, 0x5e, \n-    0x2, 0x425, 0x426, 0x7, 0xc5, 0x2, 0x2, 0x426, 0x428, 0x5, 0xba, 0x5e, \n-    0x2, 0x427, 0x425, 0x3, 0x2, 0x2, 0x2, 0x428, 0x42b, 0x3, 0x2, 0x2, \n-    0x2, 0x429, 0x427, 0x3, 0x2, 0x2, 0x2, 0x429, 0x42a, 0x3, 0x2, 0x2, \n-    0x2, 0x42a, 0x42c, 0x3, 0x2, 0x2, 0x2, 0x42b, 0x429, 0x3, 0x2, 0x2, \n-    0x2, 0x42c, 0x42d, 0x7, 0xda, 0x2, 0x2, 0x42d, 0x5d, 0x3, 0x2, 0x2, \n-    0x2, 0x42e, 0x42f, 0x7, 0x41, 0x2, 0x2, 0x42f, 0x438, 0x5, 0xd6, 0x6c, \n-    0x2, 0x430, 0x438, 0x7, 0xaf, 0x2, 0x2, 0x431, 0x433, 0x5, 0x68, 0x35, \n-    0x2, 0x432, 0x434, 0x7, 0xdb, 0x2, 0x2, 0x433, 0x432, 0x3, 0x2, 0x2, \n-    0x2, 0x433, 0x434, 0x3, 0x2, 0x2, 0x2, 0x434, 0x435, 0x3, 0x2, 0x2, \n-    0x2, 0x435, 0x436, 0x7, 0x2, 0x2, 0x3, 0x436, 0x438, 0x3, 0x2, 0x2, \n-    0x2, 0x437, 0x42e, 0x3, 0x2, 0x2, 0x2, 0x437, 0x430, 0x3, 0x2, 0x2, \n-    0x2, 0x437, 0x431, 0x3, 0x2, 0x2, 0x2, 0x438, 0x5f, 0x3, 0x2, 0x2, 0x2, \n-    0x439, 0x43a, 0x7, 0x5b, 0x2, 0x2, 0x43a, 0x43c, 0x7, 0x6f, 0x2, 0x2, \n-    0x43b, 0x43d, 0x5, 0x2c, 0x17, 0x2, 0x43c, 0x43b, 0x3, 0x2, 0x2, 0x2, \n-    0x43c, 0x43d, 0x3, 0x2, 0x2, 0x2, 0x43d, 0x43e, 0x3, 0x2, 0x2, 0x2, \n-    0x43e, 0x440, 0x5, 0x78, 0x3d, 0x2, 0x43f, 0x441, 0x9, 0x7, 0x2, 0x2, \n-    0x440, 0x43f, 0x3, 0x2, 0x2, 0x2, 0x440, 0x441, 0x3, 0x2, 0x2, 0x2, \n-    0x441, 0x61, 0x3, 0x2, 0x2, 0x2, 0x442, 0x443, 0x7, 0x77, 0x2, 0x2, \n-    0x443, 0x444, 0x7, 0x9a, 0x2, 0x2, 0x444, 0x446, 0x5, 0xc0, 0x61, 0x2, \n-    0x445, 0x447, 0x5, 0x2c, 0x17, 0x2, 0x446, 0x445, 0x3, 0x2, 0x2, 0x2, \n-    0x446, 0x447, 0x3, 0x2, 0x2, 0x2, 0x447, 0x449, 0x3, 0x2, 0x2, 0x2, \n-    0x448, 0x44a, 0x5, 0x10, 0x9, 0x2, 0x449, 0x448, 0x3, 0x2, 0x2, 0x2, \n-    0x449, 0x44a, 0x3, 0x2, 0x2, 0x2, 0x44a, 0x44c, 0x3, 0x2, 0x2, 0x2, \n-    0x44b, 0x44d, 0x7, 0x3d, 0x2, 0x2, 0x44c, 0x44b, 0x3, 0x2, 0x2, 0x2, \n-    0x44c, 0x44d, 0x3, 0x2, 0x2, 0x2, 0x44d, 0x44f, 0x3, 0x2, 0x2, 0x2, \n-    0x44e, 0x450, 0x7, 0x26, 0x2, 0x2, 0x44f, 0x44e, 0x3, 0x2, 0x2, 0x2, \n-    0x44f, 0x450, 0x3, 0x2, 0x2, 0x2, 0x450, 0x63, 0x3, 0x2, 0x2, 0x2, 0x451, \n-    0x452, 0x7, 0x85, 0x2, 0x2, 0x452, 0x453, 0x7, 0x9a, 0x2, 0x2, 0x453, \n-    0x454, 0x5, 0xc0, 0x61, 0x2, 0x454, 0x455, 0x7, 0xa2, 0x2, 0x2, 0x455, \n-    0x45d, 0x5, 0xc0, 0x61, 0x2, 0x456, 0x457, 0x7, 0xc5, 0x2, 0x2, 0x457, \n-    0x458, 0x5, 0xc0, 0x61, 0x2, 0x458, 0x459, 0x7, 0xa2, 0x2, 0x2, 0x459, \n-    0x45a, 0x5, 0xc0, 0x61, 0x2, 0x45a, 0x45c, 0x3, 0x2, 0x2, 0x2, 0x45b, \n-    0x456, 0x3, 0x2, 0x2, 0x2, 0x45c, 0x45f, 0x3, 0x2, 0x2, 0x2, 0x45d, \n-    0x45b, 0x3, 0x2, 0x2, 0x2, 0x45d, 0x45e, 0x3, 0x2, 0x2, 0x2, 0x45e, \n-    0x461, 0x3, 0x2, 0x2, 0x2, 0x45f, 0x45d, 0x3, 0x2, 0x2, 0x2, 0x460, \n-    0x462, 0x5, 0x2c, 0x17, 0x2, 0x461, 0x460, 0x3, 0x2, 0x2, 0x2, 0x461, \n-    0x462, 0x3, 0x2, 0x2, 0x2, 0x462, 0x65, 0x3, 0x2, 0x2, 0x2, 0x463, 0x465, \n-    0x7, 0xd0, 0x2, 0x2, 0x464, 0x466, 0x5, 0x6e, 0x38, 0x2, 0x465, 0x464, \n-    0x3, 0x2, 0x2, 0x2, 0x465, 0x466, 0x3, 0x2, 0x2, 0x2, 0x466, 0x467, \n-    0x3, 0x2, 0x2, 0x2, 0x467, 0x468, 0x7, 0x8d, 0x2, 0x2, 0x468, 0x46a, \n-    0x5, 0xac, 0x57, 0x2, 0x469, 0x46b, 0x5, 0x7a, 0x3e, 0x2, 0x46a, 0x469, \n-    0x3, 0x2, 0x2, 0x2, 0x46a, 0x46b, 0x3, 0x2, 0x2, 0x2, 0x46b, 0x46d, \n-    0x3, 0x2, 0x2, 0x2, 0x46c, 0x46e, 0x5, 0x80, 0x41, 0x2, 0x46d, 0x46c, \n-    0x3, 0x2, 0x2, 0x2, 0x46d, 0x46e, 0x3, 0x2, 0x2, 0x2, 0x46e, 0x46f, \n-    0x3, 0x2, 0x2, 0x2, 0x46f, 0x470, 0x7, 0xda, 0x2, 0x2, 0x470, 0x67, \n-    0x3, 0x2, 0x2, 0x2, 0x471, 0x477, 0x5, 0x6a, 0x36, 0x2, 0x472, 0x473, \n-    0x7, 0xaa, 0x2, 0x2, 0x473, 0x474, 0x7, 0x6, 0x2, 0x2, 0x474, 0x476, \n-    0x5, 0x6a, 0x36, 0x2, 0x475, 0x472, 0x3, 0x2, 0x2, 0x2, 0x476, 0x479, \n-    0x3, 0x2, 0x2, 0x2, 0x477, 0x475, 0x3, 0x2, 0x2, 0x2, 0x477, 0x478, \n-    0x3, 0x2, 0x2, 0x2, 0x478, 0x69, 0x3, 0x2, 0x2, 0x2, 0x479, 0x477, 0x3, \n-    0x2, 0x2, 0x2, 0x47a, 0x480, 0x5, 0x6c, 0x37, 0x2, 0x47b, 0x47c, 0x7, \n-    0xd0, 0x2, 0x2, 0x47c, 0x47d, 0x5, 0x68, 0x35, 0x2, 0x47d, 0x47e, 0x7, \n-    0xda, 0x2, 0x2, 0x47e, 0x480, 0x3, 0x2, 0x2, 0x2, 0x47f, 0x47a, 0x3, \n-    0x2, 0x2, 0x2, 0x47f, 0x47b, 0x3, 0x2, 0x2, 0x2, 0x480, 0x6b, 0x3, 0x2, \n-    0x2, 0x2, 0x481, 0x483, 0x5, 0x6e, 0x38, 0x2, 0x482, 0x481, 0x3, 0x2, \n-    0x2, 0x2, 0x482, 0x483, 0x3, 0x2, 0x2, 0x2, 0x483, 0x484, 0x3, 0x2, \n-    0x2, 0x2, 0x484, 0x486, 0x7, 0x8d, 0x2, 0x2, 0x485, 0x487, 0x7, 0x31, \n-    0x2, 0x2, 0x486, 0x485, 0x3, 0x2, 0x2, 0x2, 0x486, 0x487, 0x3, 0x2, \n-    0x2, 0x2, 0x487, 0x489, 0x3, 0x2, 0x2, 0x2, 0x488, 0x48a, 0x5, 0x70, \n-    0x39, 0x2, 0x489, 0x488, 0x3, 0x2, 0x2, 0x2, 0x489, 0x48a, 0x3, 0x2, \n-    0x2, 0x2, 0x48a, 0x48b, 0x3, 0x2, 0x2, 0x2, 0x48b, 0x48d, 0x5, 0xac, \n-    0x57, 0x2, 0x48c, 0x48e, 0x5, 0x72, 0x3a, 0x2, 0x48d, 0x48c, 0x3, 0x2, \n-    0x2, 0x2, 0x48d, 0x48e, 0x3, 0x2, 0x2, 0x2, 0x48e, 0x490, 0x3, 0x2, \n-    0x2, 0x2, 0x48f, 0x491, 0x5, 0x74, 0x3b, 0x2, 0x490, 0x48f, 0x3, 0x2, \n-    0x2, 0x2, 0x490, 0x491, 0x3, 0x2, 0x2, 0x2, 0x491, 0x493, 0x3, 0x2, \n-    0x2, 0x2, 0x492, 0x494, 0x5, 0x76, 0x3c, 0x2, 0x493, 0x492, 0x3, 0x2, \n-    0x2, 0x2, 0x493, 0x494, 0x3, 0x2, 0x2, 0x2, 0x494, 0x496, 0x3, 0x2, \n-    0x2, 0x2, 0x495, 0x497, 0x5, 0x78, 0x3d, 0x2, 0x496, 0x495, 0x3, 0x2, \n-    0x2, 0x2, 0x496, 0x497, 0x3, 0x2, 0x2, 0x2, 0x497, 0x499, 0x3, 0x2, \n-    0x2, 0x2, 0x498, 0x49a, 0x5, 0x7a, 0x3e, 0x2, 0x499, 0x498, 0x3, 0x2, \n-    0x2, 0x2, 0x499, 0x49a, 0x3, 0x2, 0x2, 0x2, 0x49a, 0x49d, 0x3, 0x2, \n-    0x2, 0x2, 0x49b, 0x49c, 0x7, 0xb6, 0x2, 0x2, 0x49c, 0x49e, 0x9, 0x8, \n-    0x2, 0x2, 0x49d, 0x49b, 0x3, 0x2, 0x2, 0x2, 0x49d, 0x49e, 0x3, 0x2, \n-    0x2, 0x2, 0x49e, 0x4a1, 0x3, 0x2, 0x2, 0x2, 0x49f, 0x4a0, 0x7, 0xb6, \n-    0x2, 0x2, 0x4a0, 0x4a2, 0x7, 0xa4, 0x2, 0x2, 0x4a1, 0x49f, 0x3, 0x2, \n-    0x2, 0x2, 0x4a1, 0x4a2, 0x3, 0x2, 0x2, 0x2, 0x4a2, 0x4a4, 0x3, 0x2, \n-    0x2, 0x2, 0x4a3, 0x4a5, 0x5, 0x7c, 0x3f, 0x2, 0x4a4, 0x4a3, 0x3, 0x2, \n-    0x2, 0x2, 0x4a4, 0x4a5, 0x3, 0x2, 0x2, 0x2, 0x4a5, 0x4a7, 0x3, 0x2, \n-    0x2, 0x2, 0x4a6, 0x4a8, 0x5, 0x7e, 0x40, 0x2, 0x4a7, 0x4a6, 0x3, 0x2, \n-    0x2, 0x2, 0x4a7, 0x4a8, 0x3, 0x2, 0x2, 0x2, 0x4a8, 0x4aa, 0x3, 0x2, \n-    0x2, 0x2, 0x4a9, 0x4ab, 0x5, 0x82, 0x42, 0x2, 0x4aa, 0x4a9, 0x3, 0x2, \n-    0x2, 0x2, 0x4aa, 0x4ab, 0x3, 0x2, 0x2, 0x2, 0x4ab, 0x4ad, 0x3, 0x2, \n-    0x2, 0x2, 0x4ac, 0x4ae, 0x5, 0x84, 0x43, 0x2, 0x4ad, 0x4ac, 0x3, 0x2, \n-    0x2, 0x2, 0x4ad, 0x4ae, 0x3, 0x2, 0x2, 0x2, 0x4ae, 0x4b0, 0x3, 0x2, \n-    0x2, 0x2, 0x4af, 0x4b1, 0x5, 0x86, 0x44, 0x2, 0x4b0, 0x4af, 0x3, 0x2, \n-    0x2, 0x2, 0x4b0, 0x4b1, 0x3, 0x2, 0x2, 0x2, 0x4b1, 0x6d, 0x3, 0x2, 0x2, \n-    0x2, 0x4b2, 0x4b3, 0x7, 0xb6, 0x2, 0x2, 0x4b3, 0x4b4, 0x5, 0xac, 0x57, \n-    0x2, 0x4b4, 0x6f, 0x3, 0x2, 0x2, 0x2, 0x4b5, 0x4b6, 0x7, 0xa3, 0x2, \n-    0x2, 0x4b6, 0x4b9, 0x7, 0xbd, 0x2, 0x2, 0x4b7, 0x4b8, 0x7, 0xb6, 0x2, \n-    0x2, 0x4b8, 0x4ba, 0x7, 0x9f, 0x2, 0x2, 0x4b9, 0x4b7, 0x3, 0x2, 0x2, \n-    0x2, 0x4b9, 0x4ba, 0x3, 0x2, 0x2, 0x2, 0x4ba, 0x71, 0x3, 0x2, 0x2, 0x2, \n-    0x4bb, 0x4bc, 0x7, 0x43, 0x2, 0x2, 0x4bc, 0x4bd, 0x5, 0x88, 0x45, 0x2, \n-    0x4bd, 0x73, 0x3, 0x2, 0x2, 0x2, 0x4be, 0x4c0, 0x9, 0x9, 0x2, 0x2, 0x4bf, \n-    0x4be, 0x3, 0x2, 0x2, 0x2, 0x4bf, 0x4c0, 0x3, 0x2, 0x2, 0x2, 0x4c0, \n-    0x4c1, 0x3, 0x2, 0x2, 0x2, 0x4c1, 0x4c2, 0x7, 0xb, 0x2, 0x2, 0x4c2, \n-    0x4c3, 0x7, 0x59, 0x2, 0x2, 0x4c3, 0x4c4, 0x5, 0xac, 0x57, 0x2, 0x4c4, \n-    0x75, 0x3, 0x2, 0x2, 0x2, 0x4c5, 0x4c6, 0x7, 0x7e, 0x2, 0x2, 0x4c6, \n-    0x4c7, 0x5, 0xb0, 0x59, 0x2, 0x4c7, 0x77, 0x3, 0x2, 0x2, 0x2, 0x4c8, \n-    0x4c9, 0x7, 0xb5, 0x2, 0x2, 0x4c9, 0x4ca, 0x5, 0xb0, 0x59, 0x2, 0x4ca, \n-    0x79, 0x3, 0x2, 0x2, 0x2, 0x4cb, 0x4cc, 0x7, 0x48, 0x2, 0x2, 0x4cc, \n-    0x4d3, 0x7, 0x14, 0x2, 0x2, 0x4cd, 0x4ce, 0x9, 0x8, 0x2, 0x2, 0x4ce, \n-    0x4cf, 0x7, 0xd0, 0x2, 0x2, 0x4cf, 0x4d0, 0x5, 0xac, 0x57, 0x2, 0x4d0, \n-    0x4d1, 0x7, 0xda, 0x2, 0x2, 0x4d1, 0x4d4, 0x3, 0x2, 0x2, 0x2, 0x4d2, \n-    0x4d4, 0x5, 0xac, 0x57, 0x2, 0x4d3, 0x4cd, 0x3, 0x2, 0x2, 0x2, 0x4d3, \n-    0x4d2, 0x3, 0x2, 0x2, 0x2, 0x4d4, 0x7b, 0x3, 0x2, 0x2, 0x2, 0x4d5, 0x4d6, \n-    0x7, 0x49, 0x2, 0x2, 0x4d6, 0x4d7, 0x5, 0xb0, 0x59, 0x2, 0x4d7, 0x7d, \n-    0x3, 0x2, 0x2, 0x2, 0x4d8, 0x4d9, 0x7, 0x79, 0x2, 0x2, 0x4d9, 0x4da, \n-    0x7, 0x14, 0x2, 0x2, 0x4da, 0x4db, 0x5, 0x94, 0x4b, 0x2, 0x4db, 0x7f, \n-    0x3, 0x2, 0x2, 0x2, 0x4dc, 0x4dd, 0x7, 0x79, 0x2, 0x2, 0x4dd, 0x4de, \n-    0x7, 0x14, 0x2, 0x2, 0x4de, 0x4df, 0x5, 0xac, 0x57, 0x2, 0x4df, 0x81, \n-    0x3, 0x2, 0x2, 0x2, 0x4e0, 0x4e1, 0x7, 0x62, 0x2, 0x2, 0x4e1, 0x4e2, \n-    0x5, 0x92, 0x4a, 0x2, 0x4e2, 0x4e3, 0x7, 0x14, 0x2, 0x2, 0x4e3, 0x4e4, \n-    0x5, 0xac, 0x57, 0x2, 0x4e4, 0x83, 0x3, 0x2, 0x2, 0x2, 0x4e5, 0x4e6, \n-    0x7, 0x62, 0x2, 0x2, 0x4e6, 0x4e9, 0x5, 0x92, 0x4a, 0x2, 0x4e7, 0x4e8, \n-    0x7, 0xb6, 0x2, 0x2, 0x4e8, 0x4ea, 0x7, 0x9f, 0x2, 0x2, 0x4e9, 0x4e7, \n-    0x3, 0x2, 0x2, 0x2, 0x4e9, 0x4ea, 0x3, 0x2, 0x2, 0x2, 0x4ea, 0x85, 0x3, \n-    0x2, 0x2, 0x2, 0x4eb, 0x4ec, 0x7, 0x91, 0x2, 0x2, 0x4ec, 0x4ed, 0x5, \n-    0x9a, 0x4e, 0x2, 0x4ed, 0x87, 0x3, 0x2, 0x2, 0x2, 0x4ee, 0x4ef, 0x8, \n-    0x45, 0x1, 0x2, 0x4ef, 0x4f1, 0x5, 0xbc, 0x5f, 0x2, 0x4f0, 0x4f2, 0x7, \n-    0x3d, 0x2, 0x2, 0x4f1, 0x4f0, 0x3, 0x2, 0x2, 0x2, 0x4f1, 0x4f2, 0x3, \n-    0x2, 0x2, 0x2, 0x4f2, 0x4f4, 0x3, 0x2, 0x2, 0x2, 0x4f3, 0x4f5, 0x5, \n-    0x90, 0x49, 0x2, 0x4f4, 0x4f3, 0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4f5, 0x3, \n-    0x2, 0x2, 0x2, 0x4f5, 0x4fb, 0x3, 0x2, 0x2, 0x2, 0x4f6, 0x4f7, 0x7, \n-    0xd0, 0x2, 0x2, 0x4f7, 0x4f8, 0x5, 0x88, 0x45, 0x2, 0x4f8, 0x4f9, 0x7, \n-    0xda, 0x2, 0x2, 0x4f9, 0x4fb, 0x3, 0x2, 0x2, 0x2, 0x4fa, 0x4ee, 0x3, \n-    0x2, 0x2, 0x2, 0x4fa, 0x4f6, 0x3, 0x2, 0x2, 0x2, 0x4fb, 0x50d, 0x3, \n-    0x2, 0x2, 0x2, 0x4fc, 0x4fd, 0xc, 0x5, 0x2, 0x2, 0x4fd, 0x4fe, 0x5, \n-    0x8c, 0x47, 0x2, 0x4fe, 0x4ff, 0x5, 0x88, 0x45, 0x6, 0x4ff, 0x50c, 0x3, \n-    0x2, 0x2, 0x2, 0x500, 0x502, 0xc, 0x6, 0x2, 0x2, 0x501, 0x503, 0x9, \n-    0xa, 0x2, 0x2, 0x502, 0x501, 0x3, 0x2, 0x2, 0x2, 0x502, 0x503, 0x3, \n-    0x2, 0x2, 0x2, 0x503, 0x505, 0x3, 0x2, 0x2, 0x2, 0x504, 0x506, 0x5, \n-    0x8a, 0x46, 0x2, 0x505, 0x504, 0x3, 0x2, 0x2, 0x2, 0x505, 0x506, 0x3, \n-    0x2, 0x2, 0x2, 0x506, 0x507, 0x3, 0x2, 0x2, 0x2, 0x507, 0x508, 0x7, \n-    0x59, 0x2, 0x2, 0x508, 0x509, 0x5, 0x88, 0x45, 0x2, 0x509, 0x50a, 0x5, \n-    0x8e, 0x48, 0x2, 0x50a, 0x50c, 0x3, 0x2, 0x2, 0x2, 0x50b, 0x4fc, 0x3, \n-    0x2, 0x2, 0x2, 0x50b, 0x500, 0x3, 0x2, 0x2, 0x2, 0x50c, 0x50f, 0x3, \n-    0x2, 0x2, 0x2, 0x50d, 0x50b, 0x3, 0x2, 0x2, 0x2, 0x50d, 0x50e, 0x3, \n-    0x2, 0x2, 0x2, 0x50e, 0x89, 0x3, 0x2, 0x2, 0x2, 0x50f, 0x50d, 0x3, 0x2, \n-    0x2, 0x2, 0x510, 0x512, 0x9, 0xb, 0x2, 0x2, 0x511, 0x510, 0x3, 0x2, \n-    0x2, 0x2, 0x511, 0x512, 0x3, 0x2, 0x2, 0x2, 0x512, 0x513, 0x3, 0x2, \n-    0x2, 0x2, 0x513, 0x51a, 0x7, 0x53, 0x2, 0x2, 0x514, 0x516, 0x7, 0x53, \n-    0x2, 0x2, 0x515, 0x517, 0x9, 0xb, 0x2, 0x2, 0x516, 0x515, 0x3, 0x2, \n-    0x2, 0x2, 0x516, 0x517, 0x3, 0x2, 0x2, 0x2, 0x517, 0x51a, 0x3, 0x2, \n-    0x2, 0x2, 0x518, 0x51a, 0x9, 0xb, 0x2, 0x2, 0x519, 0x511, 0x3, 0x2, \n-    0x2, 0x2, 0x519, 0x514, 0x3, 0x2, 0x2, 0x2, 0x519, 0x518, 0x3, 0x2, \n-    0x2, 0x2, 0x51a, 0x53c, 0x3, 0x2, 0x2, 0x2, 0x51b, 0x51d, 0x9, 0xc, \n-    0x2, 0x2, 0x51c, 0x51b, 0x3, 0x2, 0x2, 0x2, 0x51c, 0x51d, 0x3, 0x2, \n-    0x2, 0x2, 0x51d, 0x51e, 0x3, 0x2, 0x2, 0x2, 0x51e, 0x520, 0x9, 0xd, \n-    0x2, 0x2, 0x51f, 0x521, 0x7, 0x7a, 0x2, 0x2, 0x520, 0x51f, 0x3, 0x2, \n-    0x2, 0x2, 0x520, 0x521, 0x3, 0x2, 0x2, 0x2, 0x521, 0x52a, 0x3, 0x2, \n-    0x2, 0x2, 0x522, 0x524, 0x9, 0xd, 0x2, 0x2, 0x523, 0x525, 0x7, 0x7a, \n-    0x2, 0x2, 0x524, 0x523, 0x3, 0x2, 0x2, 0x2, 0x524, 0x525, 0x3, 0x2, \n-    0x2, 0x2, 0x525, 0x527, 0x3, 0x2, 0x2, 0x2, 0x526, 0x528, 0x9, 0xc, \n-    0x2, 0x2, 0x527, 0x526, 0x3, 0x2, 0x2, 0x2, 0x527, 0x528, 0x3, 0x2, \n-    0x2, 0x2, 0x528, 0x52a, 0x3, 0x2, 0x2, 0x2, 0x529, 0x51c, 0x3, 0x2, \n-    0x2, 0x2, 0x529, 0x522, 0x3, 0x2, 0x2, 0x2, 0x52a, 0x53c, 0x3, 0x2, \n-    0x2, 0x2, 0x52b, 0x52d, 0x9, 0xe, 0x2, 0x2, 0x52c, 0x52b, 0x3, 0x2, \n-    0x2, 0x2, 0x52c, 0x52d, 0x3, 0x2, 0x2, 0x2, 0x52d, 0x52e, 0x3, 0x2, \n-    0x2, 0x2, 0x52e, 0x530, 0x7, 0x44, 0x2, 0x2, 0x52f, 0x531, 0x7, 0x7a, \n-    0x2, 0x2, 0x530, 0x52f, 0x3, 0x2, 0x2, 0x2, 0x530, 0x531, 0x3, 0x2, \n-    0x2, 0x2, 0x531, 0x53a, 0x3, 0x2, 0x2, 0x2, 0x532, 0x534, 0x7, 0x44, \n-    0x2, 0x2, 0x533, 0x535, 0x7, 0x7a, 0x2, 0x2, 0x534, 0x533, 0x3, 0x2, \n-    0x2, 0x2, 0x534, 0x535, 0x3, 0x2, 0x2, 0x2, 0x535, 0x537, 0x3, 0x2, \n-    0x2, 0x2, 0x536, 0x538, 0x9, 0xe, 0x2, 0x2, 0x537, 0x536, 0x3, 0x2, \n-    0x2, 0x2, 0x537, 0x538, 0x3, 0x2, 0x2, 0x2, 0x538, 0x53a, 0x3, 0x2, \n-    0x2, 0x2, 0x539, 0x52c, 0x3, 0x2, 0x2, 0x2, 0x539, 0x532, 0x3, 0x2, \n-    0x2, 0x2, 0x53a, 0x53c, 0x3, 0x2, 0x2, 0x2, 0x53b, 0x519, 0x3, 0x2, \n-    0x2, 0x2, 0x53b, 0x529, 0x3, 0x2, 0x2, 0x2, 0x53b, 0x539, 0x3, 0x2, \n-    0x2, 0x2, 0x53c, 0x8b, 0x3, 0x2, 0x2, 0x2, 0x53d, 0x53f, 0x9, 0xa, 0x2, \n-    0x2, 0x53e, 0x53d, 0x3, 0x2, 0x2, 0x2, 0x53e, 0x53f, 0x3, 0x2, 0x2, \n-    0x2, 0x53f, 0x540, 0x3, 0x2, 0x2, 0x2, 0x540, 0x541, 0x7, 0x20, 0x2, \n-    0x2, 0x541, 0x544, 0x7, 0x59, 0x2, 0x2, 0x542, 0x544, 0x7, 0xc5, 0x2, \n-    0x2, 0x543, 0x53e, 0x3, 0x2, 0x2, 0x2, 0x543, 0x542, 0x3, 0x2, 0x2, \n-    0x2, 0x544, 0x8d, 0x3, 0x2, 0x2, 0x2, 0x545, 0x546, 0x7, 0x76, 0x2, \n-    0x2, 0x546, 0x54f, 0x5, 0xac, 0x57, 0x2, 0x547, 0x548, 0x7, 0xad, 0x2, \n-    0x2, 0x548, 0x549, 0x7, 0xd0, 0x2, 0x2, 0x549, 0x54a, 0x5, 0xac, 0x57, \n-    0x2, 0x54a, 0x54b, 0x7, 0xda, 0x2, 0x2, 0x54b, 0x54f, 0x3, 0x2, 0x2, \n-    0x2, 0x54c, 0x54d, 0x7, 0xad, 0x2, 0x2, 0x54d, 0x54f, 0x5, 0xac, 0x57, \n-    0x2, 0x54e, 0x545, 0x3, 0x2, 0x2, 0x2, 0x54e, 0x547, 0x3, 0x2, 0x2, \n-    0x2, 0x54e, 0x54c, 0x3, 0x2, 0x2, 0x2, 0x54f, 0x8f, 0x3, 0x2, 0x2, 0x2, \n-    0x550, 0x551, 0x7, 0x8b, 0x2, 0x2, 0x551, 0x554, 0x5, 0x98, 0x4d, 0x2, \n-    0x552, 0x553, 0x7, 0x75, 0x2, 0x2, 0x553, 0x555, 0x5, 0x98, 0x4d, 0x2, \n-    0x554, 0x552, 0x3, 0x2, 0x2, 0x2, 0x554, 0x555, 0x3, 0x2, 0x2, 0x2, \n-    0x555, 0x91, 0x3, 0x2, 0x2, 0x2, 0x556, 0x559, 0x5, 0xb0, 0x59, 0x2, \n-    0x557, 0x558, 0x9, 0xf, 0x2, 0x2, 0x558, 0x55a, 0x5, 0xb0, 0x59, 0x2, \n-    0x559, 0x557, 0x3, 0x2, 0x2, 0x2, 0x559, 0x55a, 0x3, 0x2, 0x2, 0x2, \n-    0x55a, 0x93, 0x3, 0x2, 0x2, 0x2, 0x55b, 0x560, 0x5, 0x96, 0x4c, 0x2, \n-    0x55c, 0x55d, 0x7, 0xc5, 0x2, 0x2, 0x55d, 0x55f, 0x5, 0x96, 0x4c, 0x2, \n-    0x55e, 0x55c, 0x3, 0x2, 0x2, 0x2, 0x55f, 0x562, 0x3, 0x2, 0x2, 0x2, \n-    0x560, 0x55e, 0x3, 0x2, 0x2, 0x2, 0x560, 0x561, 0x3, 0x2, 0x2, 0x2, \n-    0x561, 0x95, 0x3, 0x2, 0x2, 0x2, 0x562, 0x560, 0x3, 0x2, 0x2, 0x2, 0x563, \n-    0x565, 0x5, 0xb0, 0x59, 0x2, 0x564, 0x566, 0x9, 0x10, 0x2, 0x2, 0x565, \n-    0x564, 0x3, 0x2, 0x2, 0x2, 0x565, 0x566, 0x3, 0x2, 0x2, 0x2, 0x566, \n-    0x569, 0x3, 0x2, 0x2, 0x2, 0x567, 0x568, 0x7, 0x74, 0x2, 0x2, 0x568, \n-    0x56a, 0x9, 0x11, 0x2, 0x2, 0x569, 0x567, 0x3, 0x2, 0x2, 0x2, 0x569, \n-    0x56a, 0x3, 0x2, 0x2, 0x2, 0x56a, 0x56d, 0x3, 0x2, 0x2, 0x2, 0x56b, \n-    0x56c, 0x7, 0x1b, 0x2, 0x2, 0x56c, 0x56e, 0x7, 0xbf, 0x2, 0x2, 0x56d, \n-    0x56b, 0x3, 0x2, 0x2, 0x2, 0x56d, 0x56e, 0x3, 0x2, 0x2, 0x2, 0x56e, \n-    0x97, 0x3, 0x2, 0x2, 0x2, 0x56f, 0x572, 0x5, 0xca, 0x66, 0x2, 0x570, \n-    0x571, 0x7, 0xdc, 0x2, 0x2, 0x571, 0x573, 0x5, 0xca, 0x66, 0x2, 0x572, \n-    0x570, 0x3, 0x2, 0x2, 0x2, 0x572, 0x573, 0x3, 0x2, 0x2, 0x2, 0x573, \n-    0x99, 0x3, 0x2, 0x2, 0x2, 0x574, 0x579, 0x5, 0x9c, 0x4f, 0x2, 0x575, \n-    0x576, 0x7, 0xc5, 0x2, 0x2, 0x576, 0x578, 0x5, 0x9c, 0x4f, 0x2, 0x577, \n-    0x575, 0x3, 0x2, 0x2, 0x2, 0x578, 0x57b, 0x3, 0x2, 0x2, 0x2, 0x579, \n-    0x577, 0x3, 0x2, 0x2, 0x2, 0x579, 0x57a, 0x3, 0x2, 0x2, 0x2, 0x57a, \n-    0x9b, 0x3, 0x2, 0x2, 0x2, 0x57b, 0x579, 0x3, 0x2, 0x2, 0x2, 0x57c, 0x57d, \n-    0x5, 0xd6, 0x6c, 0x2, 0x57d, 0x57e, 0x7, 0xca, 0x2, 0x2, 0x57e, 0x57f, \n-    0x5, 0xcc, 0x67, 0x2, 0x57f, 0x9d, 0x3, 0x2, 0x2, 0x2, 0x580, 0x581, \n-    0x7, 0x90, 0x2, 0x2, 0x581, 0x582, 0x5, 0x9a, 0x4e, 0x2, 0x582, 0x9f, \n-    0x3, 0x2, 0x2, 0x2, 0x583, 0x584, 0x7, 0x92, 0x2, 0x2, 0x584, 0x585, \n-    0x7, 0x1f, 0x2, 0x2, 0x585, 0x586, 0x7, 0x22, 0x2, 0x2, 0x586, 0x5ae, \n-    0x5, 0xc6, 0x64, 0x2, 0x587, 0x588, 0x7, 0x92, 0x2, 0x2, 0x588, 0x589, \n-    0x7, 0x1f, 0x2, 0x2, 0x589, 0x58a, 0x7, 0x2f, 0x2, 0x2, 0x58a, 0x5ae, \n-    0x5, 0xc0, 0x61, 0x2, 0x58b, 0x58c, 0x7, 0x92, 0x2, 0x2, 0x58c, 0x58e, \n-    0x7, 0x1f, 0x2, 0x2, 0x58d, 0x58f, 0x7, 0x9c, 0x2, 0x2, 0x58e, 0x58d, \n-    0x3, 0x2, 0x2, 0x2, 0x58e, 0x58f, 0x3, 0x2, 0x2, 0x2, 0x58f, 0x591, \n-    0x3, 0x2, 0x2, 0x2, 0x590, 0x592, 0x7, 0x9a, 0x2, 0x2, 0x591, 0x590, \n-    0x3, 0x2, 0x2, 0x2, 0x591, 0x592, 0x3, 0x2, 0x2, 0x2, 0x592, 0x593, \n-    0x3, 0x2, 0x2, 0x2, 0x593, 0x5ae, 0x5, 0xc0, 0x61, 0x2, 0x594, 0x595, \n-    0x7, 0x92, 0x2, 0x2, 0x595, 0x5ae, 0x7, 0x23, 0x2, 0x2, 0x596, 0x597, \n-    0x7, 0x92, 0x2, 0x2, 0x597, 0x59a, 0x7, 0x2e, 0x2, 0x2, 0x598, 0x599, \n-    0x7, 0x43, 0x2, 0x2, 0x599, 0x59b, 0x5, 0xc6, 0x64, 0x2, 0x59a, 0x598, \n-    0x3, 0x2, 0x2, 0x2, 0x59a, 0x59b, 0x3, 0x2, 0x2, 0x2, 0x59b, 0x5ae, \n-    0x3, 0x2, 0x2, 0x2, 0x59c, 0x59e, 0x7, 0x92, 0x2, 0x2, 0x59d, 0x59f, \n-    0x7, 0x9c, 0x2, 0x2, 0x59e, 0x59d, 0x3, 0x2, 0x2, 0x2, 0x59e, 0x59f, \n-    0x3, 0x2, 0x2, 0x2, 0x59f, 0x5a0, 0x3, 0x2, 0x2, 0x2, 0x5a0, 0x5a3, \n-    0x7, 0x9b, 0x2, 0x2, 0x5a1, 0x5a2, 0x9, 0x12, 0x2, 0x2, 0x5a2, 0x5a4, \n-    0x5, 0xc6, 0x64, 0x2, 0x5a3, 0x5a1, 0x3, 0x2, 0x2, 0x2, 0x5a3, 0x5a4, \n-    0x3, 0x2, 0x2, 0x2, 0x5a4, 0x5a8, 0x3, 0x2, 0x2, 0x2, 0x5a5, 0x5a6, \n-    0x7, 0x61, 0x2, 0x2, 0x5a6, 0x5a9, 0x7, 0xbf, 0x2, 0x2, 0x5a7, 0x5a9, \n-    0x5, 0x78, 0x3d, 0x2, 0x5a8, 0x5a5, 0x3, 0x2, 0x2, 0x2, 0x5a8, 0x5a7, \n-    0x3, 0x2, 0x2, 0x2, 0x5a8, 0x5a9, 0x3, 0x2, 0x2, 0x2, 0x5a9, 0x5ab, \n-    0x3, 0x2, 0x2, 0x2, 0x5aa, 0x5ac, 0x5, 0x84, 0x43, 0x2, 0x5ab, 0x5aa, \n-    0x3, 0x2, 0x2, 0x2, 0x5ab, 0x5ac, 0x3, 0x2, 0x2, 0x2, 0x5ac, 0x5ae, \n-    0x3, 0x2, 0x2, 0x2, 0x5ad, 0x583, 0x3, 0x2, 0x2, 0x2, 0x5ad, 0x587, \n-    0x3, 0x2, 0x2, 0x2, 0x5ad, 0x58b, 0x3, 0x2, 0x2, 0x2, 0x5ad, 0x594, \n-    0x3, 0x2, 0x2, 0x2, 0x5ad, 0x596, 0x3, 0x2, 0x2, 0x2, 0x5ad, 0x59c, \n-    0x3, 0x2, 0x2, 0x2, 0x5ae, 0xa1, 0x3, 0x2, 0x2, 0x2, 0x5af, 0x5b0, 0x7, \n-    0x99, 0x2, 0x2, 0x5b0, 0x5b1, 0x7, 0x3f, 0x2, 0x2, 0x5b1, 0x5b2, 0x7, \n-    0x32, 0x2, 0x2, 0x5b2, 0x5d2, 0x5, 0xc0, 0x61, 0x2, 0x5b3, 0x5b4, 0x7, \n-    0x99, 0x2, 0x2, 0x5b4, 0x5b5, 0x7, 0x3f, 0x2, 0x2, 0x5b5, 0x5d2, 0x7, \n-    0x65, 0x2, 0x2, 0x5b6, 0x5b7, 0x7, 0x99, 0x2, 0x2, 0x5b7, 0x5b8, 0x7, \n-    0x83, 0x2, 0x2, 0x5b8, 0x5d2, 0x7, 0x2e, 0x2, 0x2, 0x5b9, 0x5ba, 0x7, \n-    0x99, 0x2, 0x2, 0x5ba, 0x5bb, 0x7, 0x83, 0x2, 0x2, 0x5bb, 0x5bc, 0x7, \n-    0x2f, 0x2, 0x2, 0x5bc, 0x5d2, 0x5, 0xc0, 0x61, 0x2, 0x5bd, 0x5be, 0x7, \n-    0x99, 0x2, 0x2, 0x5be, 0x5c6, 0x9, 0x13, 0x2, 0x2, 0x5bf, 0x5c0, 0x7, \n-    0x32, 0x2, 0x2, 0x5c0, 0x5c7, 0x7, 0x8f, 0x2, 0x2, 0x5c1, 0x5c7, 0x7, \n-    0x3c, 0x2, 0x2, 0x5c2, 0x5c4, 0x7, 0xa8, 0x2, 0x2, 0x5c3, 0x5c2, 0x3, \n-    0x2, 0x2, 0x2, 0x5c3, 0x5c4, 0x3, 0x2, 0x2, 0x2, 0x5c4, 0x5c5, 0x3, \n-    0x2, 0x2, 0x2, 0x5c5, 0x5c7, 0x7, 0x69, 0x2, 0x2, 0x5c6, 0x5bf, 0x3, \n-    0x2, 0x2, 0x2, 0x5c6, 0x5c1, 0x3, 0x2, 0x2, 0x2, 0x5c6, 0x5c3, 0x3, \n-    0x2, 0x2, 0x2, 0x5c7, 0x5c8, 0x3, 0x2, 0x2, 0x2, 0x5c8, 0x5d2, 0x5, \n-    0xc0, 0x61, 0x2, 0x5c9, 0x5ca, 0x7, 0x99, 0x2, 0x2, 0x5ca, 0x5cb, 0x9, \n-    0x13, 0x2, 0x2, 0x5cb, 0x5cc, 0x7, 0x88, 0x2, 0x2, 0x5cc, 0x5d2, 0x7, \n-    0x8f, 0x2, 0x2, 0x5cd, 0x5ce, 0x7, 0x99, 0x2, 0x2, 0x5ce, 0x5cf, 0x7, \n-    0x97, 0x2, 0x2, 0x5cf, 0x5d0, 0x7, 0x87, 0x2, 0x2, 0x5d0, 0x5d2, 0x5, \n-    0xc0, 0x61, 0x2, 0x5d1, 0x5af, 0x3, 0x2, 0x2, 0x2, 0x5d1, 0x5b3, 0x3, \n-    0x2, 0x2, 0x2, 0x5d1, 0x5b6, 0x3, 0x2, 0x2, 0x2, 0x5d1, 0x5b9, 0x3, \n-    0x2, 0x2, 0x2, 0x5d1, 0x5bd, 0x3, 0x2, 0x2, 0x2, 0x5d1, 0x5c9, 0x3, \n-    0x2, 0x2, 0x2, 0x5d1, 0x5cd, 0x3, 0x2, 0x2, 0x2, 0x5d2, 0xa3, 0x3, 0x2, \n-    0x2, 0x2, 0x5d3, 0x5d5, 0x7, 0xa7, 0x2, 0x2, 0x5d4, 0x5d6, 0x7, 0x9c, \n-    0x2, 0x2, 0x5d5, 0x5d4, 0x3, 0x2, 0x2, 0x2, 0x5d5, 0x5d6, 0x3, 0x2, \n-    0x2, 0x2, 0x5d6, 0x5d8, 0x3, 0x2, 0x2, 0x2, 0x5d7, 0x5d9, 0x7, 0x9a, \n-    0x2, 0x2, 0x5d8, 0x5d7, 0x3, 0x2, 0x2, 0x2, 0x5d8, 0x5d9, 0x3, 0x2, \n-    0x2, 0x2, 0x5d9, 0x5dc, 0x3, 0x2, 0x2, 0x2, 0x5da, 0x5db, 0x7, 0x4d, \n-    0x2, 0x2, 0x5db, 0x5dd, 0x7, 0x38, 0x2, 0x2, 0x5dc, 0x5da, 0x3, 0x2, \n-    0x2, 0x2, 0x5dc, 0x5dd, 0x3, 0x2, 0x2, 0x2, 0x5dd, 0x5de, 0x3, 0x2, \n-    0x2, 0x2, 0x5de, 0x5e0, 0x5, 0xc0, 0x61, 0x2, 0x5df, 0x5e1, 0x5, 0x2c, \n-    0x17, 0x2, 0x5e0, 0x5df, 0x3, 0x2, 0x2, 0x2, 0x5e0, 0x5e1, 0x3, 0x2, \n-    0x2, 0x2, 0x5e1, 0xa5, 0x3, 0x2, 0x2, 0x2, 0x5e2, 0x5e3, 0x7, 0xac, \n-    0x2, 0x2, 0x5e3, 0x5e4, 0x5, 0xc6, 0x64, 0x2, 0x5e4, 0xa7, 0x3, 0x2, \n-    0x2, 0x2, 0x5e5, 0x5e6, 0x7, 0xb2, 0x2, 0x2, 0x5e6, 0x5e8, 0x5, 0xc0, \n-    0x61, 0x2, 0x5e7, 0x5e9, 0x7, 0x37, 0x2, 0x2, 0x5e8, 0x5e7, 0x3, 0x2, \n-    0x2, 0x2, 0x5e8, 0x5e9, 0x3, 0x2, 0x2, 0x2, 0x5e9, 0x5ec, 0x3, 0x2, \n-    0x2, 0x2, 0x5ea, 0x5eb, 0x7, 0x62, 0x2, 0x2, 0x5eb, 0x5ed, 0x7, 0xbd, \n-    0x2, 0x2, 0x5ec, 0x5ea, 0x3, 0x2, 0x2, 0x2, 0x5ec, 0x5ed, 0x3, 0x2, \n-    0x2, 0x2, 0x5ed, 0xa9, 0x3, 0x2, 0x2, 0x2, 0x5ee, 0x61e, 0x5, 0xd6, \n-    0x6c, 0x2, 0x5ef, 0x5f0, 0x5, 0xd6, 0x6c, 0x2, 0x5f0, 0x5f1, 0x7, 0xd0, \n-    0x2, 0x2, 0x5f1, 0x5f2, 0x5, 0xd6, 0x6c, 0x2, 0x5f2, 0x5f9, 0x5, 0xaa, \n-    0x56, 0x2, 0x5f3, 0x5f4, 0x7, 0xc5, 0x2, 0x2, 0x5f4, 0x5f5, 0x5, 0xd6, \n-    0x6c, 0x2, 0x5f5, 0x5f6, 0x5, 0xaa, 0x56, 0x2, 0x5f6, 0x5f8, 0x3, 0x2, \n-    0x2, 0x2, 0x5f7, 0x5f3, 0x3, 0x2, 0x2, 0x2, 0x5f8, 0x5fb, 0x3, 0x2, \n-    0x2, 0x2, 0x5f9, 0x5f7, 0x3, 0x2, 0x2, 0x2, 0x5f9, 0x5fa, 0x3, 0x2, \n-    0x2, 0x2, 0x5fa, 0x5fc, 0x3, 0x2, 0x2, 0x2, 0x5fb, 0x5f9, 0x3, 0x2, \n-    0x2, 0x2, 0x5fc, 0x5fd, 0x7, 0xda, 0x2, 0x2, 0x5fd, 0x61e, 0x3, 0x2, \n-    0x2, 0x2, 0x5fe, 0x5ff, 0x5, 0xd6, 0x6c, 0x2, 0x5ff, 0x600, 0x7, 0xd0, \n-    0x2, 0x2, 0x600, 0x605, 0x5, 0xda, 0x6e, 0x2, 0x601, 0x602, 0x7, 0xc5, \n-    0x2, 0x2, 0x602, 0x604, 0x5, 0xda, 0x6e, 0x2, 0x603, 0x601, 0x3, 0x2, \n-    0x2, 0x2, 0x604, 0x607, 0x3, 0x2, 0x2, 0x2, 0x605, 0x603, 0x3, 0x2, \n-    0x2, 0x2, 0x605, 0x606, 0x3, 0x2, 0x2, 0x2, 0x606, 0x608, 0x3, 0x2, \n-    0x2, 0x2, 0x607, 0x605, 0x3, 0x2, 0x2, 0x2, 0x608, 0x609, 0x7, 0xda, \n-    0x2, 0x2, 0x609, 0x61e, 0x3, 0x2, 0x2, 0x2, 0x60a, 0x60b, 0x5, 0xd6, \n-    0x6c, 0x2, 0x60b, 0x60c, 0x7, 0xd0, 0x2, 0x2, 0x60c, 0x611, 0x5, 0xaa, \n-    0x56, 0x2, 0x60d, 0x60e, 0x7, 0xc5, 0x2, 0x2, 0x60e, 0x610, 0x5, 0xaa, \n-    0x56, 0x2, 0x60f, 0x60d, 0x3, 0x2, 0x2, 0x2, 0x610, 0x613, 0x3, 0x2, \n-    0x2, 0x2, 0x611, 0x60f, 0x3, 0x2, 0x2, 0x2, 0x611, 0x612, 0x3, 0x2, \n-    0x2, 0x2, 0x612, 0x614, 0x3, 0x2, 0x2, 0x2, 0x613, 0x611, 0x3, 0x2, \n-    0x2, 0x2, 0x614, 0x615, 0x7, 0xda, 0x2, 0x2, 0x615, 0x61e, 0x3, 0x2, \n-    0x2, 0x2, 0x616, 0x617, 0x5, 0xd6, 0x6c, 0x2, 0x617, 0x619, 0x7, 0xd0, \n-    0x2, 0x2, 0x618, 0x61a, 0x5, 0xac, 0x57, 0x2, 0x619, 0x618, 0x3, 0x2, \n-    0x2, 0x2, 0x619, 0x61a, 0x3, 0x2, 0x2, 0x2, 0x61a, 0x61b, 0x3, 0x2, \n-    0x2, 0x2, 0x61b, 0x61c, 0x7, 0xda, 0x2, 0x2, 0x61c, 0x61e, 0x3, 0x2, \n-    0x2, 0x2, 0x61d, 0x5ee, 0x3, 0x2, 0x2, 0x2, 0x61d, 0x5ef, 0x3, 0x2, \n-    0x2, 0x2, 0x61d, 0x5fe, 0x3, 0x2, 0x2, 0x2, 0x61d, 0x60a, 0x3, 0x2, \n-    0x2, 0x2, 0x61d, 0x616, 0x3, 0x2, 0x2, 0x2, 0x61e, 0xab, 0x3, 0x2, 0x2, \n-    0x2, 0x61f, 0x624, 0x5, 0xae, 0x58, 0x2, 0x620, 0x621, 0x7, 0xc5, 0x2, \n-    0x2, 0x621, 0x623, 0x5, 0xae, 0x58, 0x2, 0x622, 0x620, 0x3, 0x2, 0x2, \n-    0x2, 0x623, 0x626, 0x3, 0x2, 0x2, 0x2, 0x624, 0x622, 0x3, 0x2, 0x2, \n-    0x2, 0x624, 0x625, 0x3, 0x2, 0x2, 0x2, 0x625, 0xad, 0x3, 0x2, 0x2, 0x2, \n-    0x626, 0x624, 0x3, 0x2, 0x2, 0x2, 0x627, 0x628, 0x5, 0xc0, 0x61, 0x2, \n-    0x628, 0x629, 0x7, 0xc8, 0x2, 0x2, 0x629, 0x62b, 0x3, 0x2, 0x2, 0x2, \n-    0x62a, 0x627, 0x3, 0x2, 0x2, 0x2, 0x62a, 0x62b, 0x3, 0x2, 0x2, 0x2, \n-    0x62b, 0x62c, 0x3, 0x2, 0x2, 0x2, 0x62c, 0x633, 0x7, 0xc1, 0x2, 0x2, \n-    0x62d, 0x62e, 0x7, 0xd0, 0x2, 0x2, 0x62e, 0x62f, 0x5, 0x68, 0x35, 0x2, \n-    0x62f, 0x630, 0x7, 0xda, 0x2, 0x2, 0x630, 0x633, 0x3, 0x2, 0x2, 0x2, \n-    0x631, 0x633, 0x5, 0xb0, 0x59, 0x2, 0x632, 0x62a, 0x3, 0x2, 0x2, 0x2, \n-    0x632, 0x62d, 0x3, 0x2, 0x2, 0x2, 0x632, 0x631, 0x3, 0x2, 0x2, 0x2, \n-    0x633, 0xaf, 0x3, 0x2, 0x2, 0x2, 0x634, 0x635, 0x8, 0x59, 0x1, 0x2, \n-    0x635, 0x637, 0x7, 0x15, 0x2, 0x2, 0x636, 0x638, 0x5, 0xb0, 0x59, 0x2, \n-    0x637, 0x636, 0x3, 0x2, 0x2, 0x2, 0x637, 0x638, 0x3, 0x2, 0x2, 0x2, \n-    0x638, 0x63e, 0x3, 0x2, 0x2, 0x2, 0x639, 0x63a, 0x7, 0xb4, 0x2, 0x2, \n-    0x63a, 0x63b, 0x5, 0xb0, 0x59, 0x2, 0x63b, 0x63c, 0x7, 0x9e, 0x2, 0x2, \n-    0x63c, 0x63d, 0x5, 0xb0, 0x59, 0x2, 0x63d, 0x63f, 0x3, 0x2, 0x2, 0x2, \n-    0x63e, 0x639, 0x3, 0x2, 0x2, 0x2, 0x63f, 0x640, 0x3, 0x2, 0x2, 0x2, \n-    0x640, 0x63e, 0x3, 0x2, 0x2, 0x2, 0x640, 0x641, 0x3, 0x2, 0x2, 0x2, \n-    0x641, 0x644, 0x3, 0x2, 0x2, 0x2, 0x642, 0x643, 0x7, 0x34, 0x2, 0x2, \n-    0x643, 0x645, 0x5, 0xb0, 0x59, 0x2, 0x644, 0x642, 0x3, 0x2, 0x2, 0x2, \n-    0x644, 0x645, 0x3, 0x2, 0x2, 0x2, 0x645, 0x646, 0x3, 0x2, 0x2, 0x2, \n-    0x646, 0x647, 0x7, 0x35, 0x2, 0x2, 0x647, 0x6a0, 0x3, 0x2, 0x2, 0x2, \n-    0x648, 0x649, 0x7, 0x16, 0x2, 0x2, 0x649, 0x64a, 0x7, 0xd0, 0x2, 0x2, \n-    0x64a, 0x64b, 0x5, 0xb0, 0x59, 0x2, 0x64b, 0x64c, 0x7, 0xc, 0x2, 0x2, \n-    0x64c, 0x64d, 0x5, 0xaa, 0x56, 0x2, 0x64d, 0x64e, 0x7, 0xda, 0x2, 0x2, \n-    0x64e, 0x6a0, 0x3, 0x2, 0x2, 0x2, 0x64f, 0x650, 0x7, 0x24, 0x2, 0x2, \n-    0x650, 0x6a0, 0x7, 0xbf, 0x2, 0x2, 0x651, 0x652, 0x7, 0x3b, 0x2, 0x2, \n-    0x652, 0x653, 0x7, 0xd0, 0x2, 0x2, 0x653, 0x654, 0x5, 0xce, 0x68, 0x2, \n-    0x654, 0x655, 0x7, 0x43, 0x2, 0x2, 0x655, 0x656, 0x5, 0xb0, 0x59, 0x2, \n-    0x656, 0x657, 0x7, 0xda, 0x2, 0x2, 0x657, 0x6a0, 0x3, 0x2, 0x2, 0x2, \n-    0x658, 0x659, 0x7, 0x55, 0x2, 0x2, 0x659, 0x65a, 0x5, 0xb0, 0x59, 0x2, \n-    0x65a, 0x65b, 0x5, 0xce, 0x68, 0x2, 0x65b, 0x6a0, 0x3, 0x2, 0x2, 0x2, \n-    0x65c, 0x65d, 0x7, 0x96, 0x2, 0x2, 0x65d, 0x65e, 0x7, 0xd0, 0x2, 0x2, \n-    0x65e, 0x65f, 0x5, 0xb0, 0x59, 0x2, 0x65f, 0x660, 0x7, 0x43, 0x2, 0x2, \n-    0x660, 0x663, 0x5, 0xb0, 0x59, 0x2, 0x661, 0x662, 0x7, 0x40, 0x2, 0x2, \n-    0x662, 0x664, 0x5, 0xb0, 0x59, 0x2, 0x663, 0x661, 0x3, 0x2, 0x2, 0x2, \n-    0x663, 0x664, 0x3, 0x2, 0x2, 0x2, 0x664, 0x665, 0x3, 0x2, 0x2, 0x2, \n-    0x665, 0x666, 0x7, 0xda, 0x2, 0x2, 0x666, 0x6a0, 0x3, 0x2, 0x2, 0x2, \n-    0x667, 0x668, 0x7, 0xa1, 0x2, 0x2, 0x668, 0x6a0, 0x7, 0xbf, 0x2, 0x2, \n-    0x669, 0x66a, 0x7, 0xa6, 0x2, 0x2, 0x66a, 0x66b, 0x7, 0xd0, 0x2, 0x2, \n-    0x66b, 0x66c, 0x9, 0x14, 0x2, 0x2, 0x66c, 0x66d, 0x7, 0xbf, 0x2, 0x2, \n-    0x66d, 0x66e, 0x7, 0x43, 0x2, 0x2, 0x66e, 0x66f, 0x5, 0xb0, 0x59, 0x2, \n-    0x66f, 0x670, 0x7, 0xda, 0x2, 0x2, 0x670, 0x6a0, 0x3, 0x2, 0x2, 0x2, \n-    0x671, 0x677, 0x5, 0xd6, 0x6c, 0x2, 0x672, 0x674, 0x7, 0xd0, 0x2, 0x2, \n-    0x673, 0x675, 0x5, 0xac, 0x57, 0x2, 0x674, 0x673, 0x3, 0x2, 0x2, 0x2, \n-    0x674, 0x675, 0x3, 0x2, 0x2, 0x2, 0x675, 0x676, 0x3, 0x2, 0x2, 0x2, \n-    0x676, 0x678, 0x7, 0xda, 0x2, 0x2, 0x677, 0x672, 0x3, 0x2, 0x2, 0x2, \n-    0x677, 0x678, 0x3, 0x2, 0x2, 0x2, 0x678, 0x679, 0x3, 0x2, 0x2, 0x2, \n-    0x679, 0x67b, 0x7, 0xd0, 0x2, 0x2, 0x67a, 0x67c, 0x7, 0x31, 0x2, 0x2, \n-    0x67b, 0x67a, 0x3, 0x2, 0x2, 0x2, 0x67b, 0x67c, 0x3, 0x2, 0x2, 0x2, \n-    0x67c, 0x67e, 0x3, 0x2, 0x2, 0x2, 0x67d, 0x67f, 0x5, 0xb2, 0x5a, 0x2, \n-    0x67e, 0x67d, 0x3, 0x2, 0x2, 0x2, 0x67e, 0x67f, 0x3, 0x2, 0x2, 0x2, \n-    0x67f, 0x680, 0x3, 0x2, 0x2, 0x2, 0x680, 0x681, 0x7, 0xda, 0x2, 0x2, \n-    0x681, 0x6a0, 0x3, 0x2, 0x2, 0x2, 0x682, 0x6a0, 0x5, 0xcc, 0x67, 0x2, \n-    0x683, 0x684, 0x7, 0xc7, 0x2, 0x2, 0x684, 0x6a0, 0x5, 0xb0, 0x59, 0x13, \n-    0x685, 0x686, 0x7, 0x72, 0x2, 0x2, 0x686, 0x6a0, 0x5, 0xb0, 0x59, 0xe, \n-    0x687, 0x688, 0x5, 0xc0, 0x61, 0x2, 0x688, 0x689, 0x7, 0xc8, 0x2, 0x2, \n-    0x689, 0x68b, 0x3, 0x2, 0x2, 0x2, 0x68a, 0x687, 0x3, 0x2, 0x2, 0x2, \n-    0x68a, 0x68b, 0x3, 0x2, 0x2, 0x2, 0x68b, 0x68c, 0x3, 0x2, 0x2, 0x2, \n-    0x68c, 0x6a0, 0x7, 0xc1, 0x2, 0x2, 0x68d, 0x68e, 0x7, 0xd0, 0x2, 0x2, \n-    0x68e, 0x68f, 0x5, 0x68, 0x35, 0x2, 0x68f, 0x690, 0x7, 0xda, 0x2, 0x2, \n-    0x690, 0x6a0, 0x3, 0x2, 0x2, 0x2, 0x691, 0x692, 0x7, 0xd0, 0x2, 0x2, \n-    0x692, 0x693, 0x5, 0xb0, 0x59, 0x2, 0x693, 0x694, 0x7, 0xda, 0x2, 0x2, \n-    0x694, 0x6a0, 0x3, 0x2, 0x2, 0x2, 0x695, 0x696, 0x7, 0xd0, 0x2, 0x2, \n-    0x696, 0x697, 0x5, 0xac, 0x57, 0x2, 0x697, 0x698, 0x7, 0xda, 0x2, 0x2, \n-    0x698, 0x6a0, 0x3, 0x2, 0x2, 0x2, 0x699, 0x69b, 0x7, 0xce, 0x2, 0x2, \n-    0x69a, 0x69c, 0x5, 0xac, 0x57, 0x2, 0x69b, 0x69a, 0x3, 0x2, 0x2, 0x2, \n-    0x69b, 0x69c, 0x3, 0x2, 0x2, 0x2, 0x69c, 0x69d, 0x3, 0x2, 0x2, 0x2, \n-    0x69d, 0x6a0, 0x7, 0xd9, 0x2, 0x2, 0x69e, 0x6a0, 0x5, 0xb8, 0x5d, 0x2, \n-    0x69f, 0x634, 0x3, 0x2, 0x2, 0x2, 0x69f, 0x648, 0x3, 0x2, 0x2, 0x2, \n-    0x69f, 0x64f, 0x3, 0x2, 0x2, 0x2, 0x69f, 0x651, 0x3, 0x2, 0x2, 0x2, \n-    0x69f, 0x658, 0x3, 0x2, 0x2, 0x2, 0x69f, 0x65c, 0x3, 0x2, 0x2, 0x2, \n-    0x69f, 0x667, 0x3, 0x2, 0x2, 0x2, 0x69f, 0x669, 0x3, 0x2, 0x2, 0x2, \n-    0x69f, 0x671, 0x3, 0x2, 0x2, 0x2, 0x69f, 0x682, 0x3, 0x2, 0x2, 0x2, \n-    0x69f, 0x683, 0x3, 0x2, 0x2, 0x2, 0x69f, 0x685, 0x3, 0x2, 0x2, 0x2, \n-    0x69f, 0x68a, 0x3, 0x2, 0x2, 0x2, 0x69f, 0x68d, 0x3, 0x2, 0x2, 0x2, \n-    0x69f, 0x691, 0x3, 0x2, 0x2, 0x2, 0x69f, 0x695, 0x3, 0x2, 0x2, 0x2, \n-    0x69f, 0x699, 0x3, 0x2, 0x2, 0x2, 0x69f, 0x69e, 0x3, 0x2, 0x2, 0x2, \n-    0x6a0, 0x6e8, 0x3, 0x2, 0x2, 0x2, 0x6a1, 0x6a2, 0xc, 0x12, 0x2, 0x2, \n-    0x6a2, 0x6a3, 0x9, 0x15, 0x2, 0x2, 0x6a3, 0x6e7, 0x5, 0xb0, 0x59, 0x13, \n-    0x6a4, 0x6a5, 0xc, 0x11, 0x2, 0x2, 0x6a5, 0x6a6, 0x9, 0x16, 0x2, 0x2, \n-    0x6a6, 0x6e7, 0x5, 0xb0, 0x59, 0x12, 0x6a7, 0x6ba, 0xc, 0x10, 0x2, 0x2, \n-    0x6a8, 0x6bb, 0x7, 0xc9, 0x2, 0x2, 0x6a9, 0x6bb, 0x7, 0xca, 0x2, 0x2, \n-    0x6aa, 0x6bb, 0x7, 0xd2, 0x2, 0x2, 0x6ab, 0x6bb, 0x7, 0xcf, 0x2, 0x2, \n-    0x6ac, 0x6bb, 0x7, 0xcb, 0x2, 0x2, 0x6ad, 0x6bb, 0x7, 0xd1, 0x2, 0x2, \n-    0x6ae, 0x6bb, 0x7, 0xcc, 0x2, 0x2, 0x6af, 0x6b1, 0x7, 0x46, 0x2, 0x2, \n-    0x6b0, 0x6af, 0x3, 0x2, 0x2, 0x2, 0x6b0, 0x6b1, 0x3, 0x2, 0x2, 0x2, \n-    0x6b1, 0x6b3, 0x3, 0x2, 0x2, 0x2, 0x6b2, 0x6b4, 0x7, 0x72, 0x2, 0x2, \n-    0x6b3, 0x6b2, 0x3, 0x2, 0x2, 0x2, 0x6b3, 0x6b4, 0x3, 0x2, 0x2, 0x2, \n-    0x6b4, 0x6b5, 0x3, 0x2, 0x2, 0x2, 0x6b5, 0x6bb, 0x7, 0x4f, 0x2, 0x2, \n-    0x6b6, 0x6b8, 0x7, 0x72, 0x2, 0x2, 0x6b7, 0x6b6, 0x3, 0x2, 0x2, 0x2, \n-    0x6b7, 0x6b8, 0x3, 0x2, 0x2, 0x2, 0x6b8, 0x6b9, 0x3, 0x2, 0x2, 0x2, \n-    0x6b9, 0x6bb, 0x9, 0x17, 0x2, 0x2, 0x6ba, 0x6a8, 0x3, 0x2, 0x2, 0x2, \n-    0x6ba, 0x6a9, 0x3, 0x2, 0x2, 0x2, 0x6ba, 0x6aa, 0x3, 0x2, 0x2, 0x2, \n-    0x6ba, 0x6ab, 0x3, 0x2, 0x2, 0x2, 0x6ba, 0x6ac, 0x3, 0x2, 0x2, 0x2, \n-    0x6ba, 0x6ad, 0x3, 0x2, 0x2, 0x2, 0x6ba, 0x6ae, 0x3, 0x2, 0x2, 0x2, \n-    0x6ba, 0x6b0, 0x3, 0x2, 0x2, 0x2, 0x6ba, 0x6b7, 0x3, 0x2, 0x2, 0x2, \n-    0x6bb, 0x6bc, 0x3, 0x2, 0x2, 0x2, 0x6bc, 0x6e7, 0x5, 0xb0, 0x59, 0x11, \n-    0x6bd, 0x6be, 0xc, 0xd, 0x2, 0x2, 0x6be, 0x6bf, 0x7, 0x8, 0x2, 0x2, \n-    0x6bf, 0x6e7, 0x5, 0xb0, 0x59, 0xe, 0x6c0, 0x6c1, 0xc, 0xc, 0x2, 0x2, \n-    0x6c1, 0x6c2, 0x7, 0x78, 0x2, 0x2, 0x6c2, 0x6e7, 0x5, 0xb0, 0x59, 0xd, \n-    0x6c3, 0x6c5, 0xc, 0xb, 0x2, 0x2, 0x6c4, 0x6c6, 0x7, 0x72, 0x2, 0x2, \n-    0x6c5, 0x6c4, 0x3, 0x2, 0x2, 0x2, 0x6c5, 0x6c6, 0x3, 0x2, 0x2, 0x2, \n-    0x6c6, 0x6c7, 0x3, 0x2, 0x2, 0x2, 0x6c7, 0x6c8, 0x7, 0x12, 0x2, 0x2, \n-    0x6c8, 0x6c9, 0x5, 0xb0, 0x59, 0x2, 0x6c9, 0x6ca, 0x7, 0x8, 0x2, 0x2, \n-    0x6ca, 0x6cb, 0x5, 0xb0, 0x59, 0xc, 0x6cb, 0x6e7, 0x3, 0x2, 0x2, 0x2, \n-    0x6cc, 0x6cd, 0xc, 0xa, 0x2, 0x2, 0x6cd, 0x6ce, 0x7, 0xd5, 0x2, 0x2, \n-    0x6ce, 0x6cf, 0x5, 0xb0, 0x59, 0x2, 0x6cf, 0x6d0, 0x7, 0xc4, 0x2, 0x2, \n-    0x6d0, 0x6d1, 0x5, 0xb0, 0x59, 0xa, 0x6d1, 0x6e7, 0x3, 0x2, 0x2, 0x2, \n-    0x6d2, 0x6d3, 0xc, 0x15, 0x2, 0x2, 0x6d3, 0x6d4, 0x7, 0xce, 0x2, 0x2, \n-    0x6d4, 0x6d5, 0x5, 0xb0, 0x59, 0x2, 0x6d5, 0x6d6, 0x7, 0xd9, 0x2, 0x2, \n-    0x6d6, 0x6e7, 0x3, 0x2, 0x2, 0x2, 0x6d7, 0x6d8, 0xc, 0x14, 0x2, 0x2, \n-    0x6d8, 0x6d9, 0x7, 0xc8, 0x2, 0x2, 0x6d9, 0x6e7, 0x7, 0xbd, 0x2, 0x2, \n-    0x6da, 0x6db, 0xc, 0xf, 0x2, 0x2, 0x6db, 0x6dd, 0x7, 0x57, 0x2, 0x2, \n-    0x6dc, 0x6de, 0x7, 0x72, 0x2, 0x2, 0x6dd, 0x6dc, 0x3, 0x2, 0x2, 0x2, \n-    0x6dd, 0x6de, 0x3, 0x2, 0x2, 0x2, 0x6de, 0x6df, 0x3, 0x2, 0x2, 0x2, \n-    0x6df, 0x6e7, 0x7, 0x73, 0x2, 0x2, 0x6e0, 0x6e4, 0xc, 0x9, 0x2, 0x2, \n-    0x6e1, 0x6e5, 0x5, 0xd4, 0x6b, 0x2, 0x6e2, 0x6e3, 0x7, 0xc, 0x2, 0x2, \n-    0x6e3, 0x6e5, 0x5, 0xd6, 0x6c, 0x2, 0x6e4, 0x6e1, 0x3, 0x2, 0x2, 0x2, \n-    0x6e4, 0x6e2, 0x3, 0x2, 0x2, 0x2, 0x6e5, 0x6e7, 0x3, 0x2, 0x2, 0x2, \n-    0x6e6, 0x6a1, 0x3, 0x2, 0x2, 0x2, 0x6e6, 0x6a4, 0x3, 0x2, 0x2, 0x2, \n-    0x6e6, 0x6a7, 0x3, 0x2, 0x2, 0x2, 0x6e6, 0x6bd, 0x3, 0x2, 0x2, 0x2, \n-    0x6e6, 0x6c0, 0x3, 0x2, 0x2, 0x2, 0x6e6, 0x6c3, 0x3, 0x2, 0x2, 0x2, \n-    0x6e6, 0x6cc, 0x3, 0x2, 0x2, 0x2, 0x6e6, 0x6d2, 0x3, 0x2, 0x2, 0x2, \n-    0x6e6, 0x6d7, 0x3, 0x2, 0x2, 0x2, 0x6e6, 0x6da, 0x3, 0x2, 0x2, 0x2, \n-    0x6e6, 0x6e0, 0x3, 0x2, 0x2, 0x2, 0x6e7, 0x6ea, 0x3, 0x2, 0x2, 0x2, \n-    0x6e8, 0x6e6, 0x3, 0x2, 0x2, 0x2, 0x6e8, 0x6e9, 0x3, 0x2, 0x2, 0x2, \n-    0x6e9, 0xb1, 0x3, 0x2, 0x2, 0x2, 0x6ea, 0x6e8, 0x3, 0x2, 0x2, 0x2, 0x6eb, \n-    0x6f0, 0x5, 0xb4, 0x5b, 0x2, 0x6ec, 0x6ed, 0x7, 0xc5, 0x2, 0x2, 0x6ed, \n-    0x6ef, 0x5, 0xb4, 0x5b, 0x2, 0x6ee, 0x6ec, 0x3, 0x2, 0x2, 0x2, 0x6ef, \n-    0x6f2, 0x3, 0x2, 0x2, 0x2, 0x6f0, 0x6ee, 0x3, 0x2, 0x2, 0x2, 0x6f0, \n-    0x6f1, 0x3, 0x2, 0x2, 0x2, 0x6f1, 0xb3, 0x3, 0x2, 0x2, 0x2, 0x6f2, 0x6f0, \n-    0x3, 0x2, 0x2, 0x2, 0x6f3, 0x6f6, 0x5, 0xb6, 0x5c, 0x2, 0x6f4, 0x6f6, \n-    0x5, 0xb0, 0x59, 0x2, 0x6f5, 0x6f3, 0x3, 0x2, 0x2, 0x2, 0x6f5, 0x6f4, \n-    0x3, 0x2, 0x2, 0x2, 0x6f6, 0xb5, 0x3, 0x2, 0x2, 0x2, 0x6f7, 0x6f8, 0x7, \n-    0xd0, 0x2, 0x2, 0x6f8, 0x6fd, 0x5, 0xd6, 0x6c, 0x2, 0x6f9, 0x6fa, 0x7, \n-    0xc5, 0x2, 0x2, 0x6fa, 0x6fc, 0x5, 0xd6, 0x6c, 0x2, 0x6fb, 0x6f9, 0x3, \n-    0x2, 0x2, 0x2, 0x6fc, 0x6ff, 0x3, 0x2, 0x2, 0x2, 0x6fd, 0x6fb, 0x3, \n-    0x2, 0x2, 0x2, 0x6fd, 0x6fe, 0x3, 0x2, 0x2, 0x2, 0x6fe, 0x700, 0x3, \n-    0x2, 0x2, 0x2, 0x6ff, 0x6fd, 0x3, 0x2, 0x2, 0x2, 0x700, 0x701, 0x7, \n-    0xda, 0x2, 0x2, 0x701, 0x70b, 0x3, 0x2, 0x2, 0x2, 0x702, 0x707, 0x5, \n-    0xd6, 0x6c, 0x2, 0x703, 0x704, 0x7, 0xc5, 0x2, 0x2, 0x704, 0x706, 0x5, \n-    0xd6, 0x6c, 0x2, 0x705, 0x703, 0x3, 0x2, 0x2, 0x2, 0x706, 0x709, 0x3, \n-    0x2, 0x2, 0x2, 0x707, 0x705, 0x3, 0x2, 0x2, 0x2, 0x707, 0x708, 0x3, \n-    0x2, 0x2, 0x2, 0x708, 0x70b, 0x3, 0x2, 0x2, 0x2, 0x709, 0x707, 0x3, \n-    0x2, 0x2, 0x2, 0x70a, 0x6f7, 0x3, 0x2, 0x2, 0x2, 0x70a, 0x702, 0x3, \n-    0x2, 0x2, 0x2, 0x70b, 0x70c, 0x3, 0x2, 0x2, 0x2, 0x70c, 0x70d, 0x7, \n-    0xc0, 0x2, 0x2, 0x70d, 0x70e, 0x5, 0xb0, 0x59, 0x2, 0x70e, 0xb7, 0x3, \n-    0x2, 0x2, 0x2, 0x70f, 0x710, 0x5, 0xc0, 0x61, 0x2, 0x710, 0x711, 0x7, \n-    0xc8, 0x2, 0x2, 0x711, 0x713, 0x3, 0x2, 0x2, 0x2, 0x712, 0x70f, 0x3, \n-    0x2, 0x2, 0x2, 0x712, 0x713, 0x3, 0x2, 0x2, 0x2, 0x713, 0x714, 0x3, \n-    0x2, 0x2, 0x2, 0x714, 0x715, 0x5, 0xba, 0x5e, 0x2, 0x715, 0xb9, 0x3, \n-    0x2, 0x2, 0x2, 0x716, 0x719, 0x5, 0xd6, 0x6c, 0x2, 0x717, 0x718, 0x7, \n-    0xc8, 0x2, 0x2, 0x718, 0x71a, 0x5, 0xd6, 0x6c, 0x2, 0x719, 0x717, 0x3, \n-    0x2, 0x2, 0x2, 0x719, 0x71a, 0x3, 0x2, 0x2, 0x2, 0x71a, 0xbb, 0x3, 0x2, \n-    0x2, 0x2, 0x71b, 0x71c, 0x8, 0x5f, 0x1, 0x2, 0x71c, 0x723, 0x5, 0xc0, \n-    0x61, 0x2, 0x71d, 0x723, 0x5, 0xbe, 0x60, 0x2, 0x71e, 0x71f, 0x7, 0xd0, \n-    0x2, 0x2, 0x71f, 0x720, 0x5, 0x68, 0x35, 0x2, 0x720, 0x721, 0x7, 0xda, \n-    0x2, 0x2, 0x721, 0x723, 0x3, 0x2, 0x2, 0x2, 0x722, 0x71b, 0x3, 0x2, \n-    0x2, 0x2, 0x722, 0x71d, 0x3, 0x2, 0x2, 0x2, 0x722, 0x71e, 0x3, 0x2, \n-    0x2, 0x2, 0x723, 0x72c, 0x3, 0x2, 0x2, 0x2, 0x724, 0x728, 0xc, 0x3, \n-    0x2, 0x2, 0x725, 0x729, 0x5, 0xd4, 0x6b, 0x2, 0x726, 0x727, 0x7, 0xc, \n-    0x2, 0x2, 0x727, 0x729, 0x5, 0xd6, 0x6c, 0x2, 0x728, 0x725, 0x3, 0x2, \n-    0x2, 0x2, 0x728, 0x726, 0x3, 0x2, 0x2, 0x2, 0x729, 0x72b, 0x3, 0x2, \n-    0x2, 0x2, 0x72a, 0x724, 0x3, 0x2, 0x2, 0x2, 0x72b, 0x72e, 0x3, 0x2, \n-    0x2, 0x2, 0x72c, 0x72a, 0x3, 0x2, 0x2, 0x2, 0x72c, 0x72d, 0x3, 0x2, \n-    0x2, 0x2, 0x72d, 0xbd, 0x3, 0x2, 0x2, 0x2, 0x72e, 0x72c, 0x3, 0x2, 0x2, \n-    0x2, 0x72f, 0x730, 0x5, 0xd6, 0x6c, 0x2, 0x730, 0x732, 0x7, 0xd0, 0x2, \n-    0x2, 0x731, 0x733, 0x5, 0xc2, 0x62, 0x2, 0x732, 0x731, 0x3, 0x2, 0x2, \n-    0x2, 0x732, 0x733, 0x3, 0x2, 0x2, 0x2, 0x733, 0x734, 0x3, 0x2, 0x2, \n-    0x2, 0x734, 0x735, 0x7, 0xda, 0x2, 0x2, 0x735, 0xbf, 0x3, 0x2, 0x2, \n-    0x2, 0x736, 0x737, 0x5, 0xc6, 0x64, 0x2, 0x737, 0x738, 0x7, 0xc8, 0x2, \n-    0x2, 0x738, 0x73a, 0x3, 0x2, 0x2, 0x2, 0x739, 0x736, 0x3, 0x2, 0x2, \n-    0x2, 0x739, 0x73a, 0x3, 0x2, 0x2, 0x2, 0x73a, 0x73b, 0x3, 0x2, 0x2, \n-    0x2, 0x73b, 0x73c, 0x5, 0xd6, 0x6c, 0x2, 0x73c, 0xc1, 0x3, 0x2, 0x2, \n-    0x2, 0x73d, 0x742, 0x5, 0xc4, 0x63, 0x2, 0x73e, 0x73f, 0x7, 0xc5, 0x2, \n-    0x2, 0x73f, 0x741, 0x5, 0xc4, 0x63, 0x2, 0x740, 0x73e, 0x3, 0x2, 0x2, \n-    0x2, 0x741, 0x744, 0x3, 0x2, 0x2, 0x2, 0x742, 0x740, 0x3, 0x2, 0x2, \n-    0x2, 0x742, 0x743, 0x3, 0x2, 0x2, 0x2, 0x743, 0xc3, 0x3, 0x2, 0x2, 0x2, \n-    0x744, 0x742, 0x3, 0x2, 0x2, 0x2, 0x745, 0x749, 0x5, 0xba, 0x5e, 0x2, \n-    0x746, 0x749, 0x5, 0xbe, 0x60, 0x2, 0x747, 0x749, 0x5, 0xcc, 0x67, 0x2, \n-    0x748, 0x745, 0x3, 0x2, 0x2, 0x2, 0x748, 0x746, 0x3, 0x2, 0x2, 0x2, \n-    0x748, 0x747, 0x3, 0x2, 0x2, 0x2, 0x749, 0xc5, 0x3, 0x2, 0x2, 0x2, 0x74a, \n-    0x74b, 0x5, 0xd6, 0x6c, 0x2, 0x74b, 0xc7, 0x3, 0x2, 0x2, 0x2, 0x74c, \n-    0x755, 0x7, 0xbb, 0x2, 0x2, 0x74d, 0x74e, 0x7, 0xc8, 0x2, 0x2, 0x74e, \n-    0x755, 0x9, 0x18, 0x2, 0x2, 0x74f, 0x750, 0x7, 0xbd, 0x2, 0x2, 0x750, \n-    0x752, 0x7, 0xc8, 0x2, 0x2, 0x751, 0x753, 0x9, 0x18, 0x2, 0x2, 0x752, \n-    0x751, 0x3, 0x2, 0x2, 0x2, 0x752, 0x753, 0x3, 0x2, 0x2, 0x2, 0x753, \n-    0x755, 0x3, 0x2, 0x2, 0x2, 0x754, 0x74c, 0x3, 0x2, 0x2, 0x2, 0x754, \n-    0x74d, 0x3, 0x2, 0x2, 0x2, 0x754, 0x74f, 0x3, 0x2, 0x2, 0x2, 0x755, \n-    0xc9, 0x3, 0x2, 0x2, 0x2, 0x756, 0x758, 0x9, 0x19, 0x2, 0x2, 0x757, \n-    0x756, 0x3, 0x2, 0x2, 0x2, 0x757, 0x758, 0x3, 0x2, 0x2, 0x2, 0x758, \n-    0x75f, 0x3, 0x2, 0x2, 0x2, 0x759, 0x760, 0x5, 0xc8, 0x65, 0x2, 0x75a, \n-    0x760, 0x7, 0xbc, 0x2, 0x2, 0x75b, 0x760, 0x7, 0xbd, 0x2, 0x2, 0x75c, \n-    0x760, 0x7, 0xbe, 0x2, 0x2, 0x75d, 0x760, 0x7, 0x51, 0x2, 0x2, 0x75e, \n-    0x760, 0x7, 0x70, 0x2, 0x2, 0x75f, 0x759, 0x3, 0x2, 0x2, 0x2, 0x75f, \n-    0x75a, 0x3, 0x2, 0x2, 0x2, 0x75f, 0x75b, 0x3, 0x2, 0x2, 0x2, 0x75f, \n-    0x75c, 0x3, 0x2, 0x2, 0x2, 0x75f, 0x75d, 0x3, 0x2, 0x2, 0x2, 0x75f, \n-    0x75e, 0x3, 0x2, 0x2, 0x2, 0x760, 0xcb, 0x3, 0x2, 0x2, 0x2, 0x761, 0x765, \n-    0x5, 0xca, 0x66, 0x2, 0x762, 0x765, 0x7, 0xbf, 0x2, 0x2, 0x763, 0x765, \n-    0x7, 0x73, 0x2, 0x2, 0x764, 0x761, 0x3, 0x2, 0x2, 0x2, 0x764, 0x762, \n-    0x3, 0x2, 0x2, 0x2, 0x764, 0x763, 0x3, 0x2, 0x2, 0x2, 0x765, 0xcd, 0x3, \n-    0x2, 0x2, 0x2, 0x766, 0x767, 0x9, 0x1a, 0x2, 0x2, 0x767, 0xcf, 0x3, \n-    0x2, 0x2, 0x2, 0x768, 0x769, 0x9, 0x1b, 0x2, 0x2, 0x769, 0xd1, 0x3, \n-    0x2, 0x2, 0x2, 0x76a, 0x76b, 0x9, 0x1c, 0x2, 0x2, 0x76b, 0xd3, 0x3, \n-    0x2, 0x2, 0x2, 0x76c, 0x76f, 0x7, 0xba, 0x2, 0x2, 0x76d, 0x76f, 0x5, \n-    0xd2, 0x6a, 0x2, 0x76e, 0x76c, 0x3, 0x2, 0x2, 0x2, 0x76e, 0x76d, 0x3, \n-    0x2, 0x2, 0x2, 0x76f, 0xd5, 0x3, 0x2, 0x2, 0x2, 0x770, 0x774, 0x7, 0xba, \n-    0x2, 0x2, 0x771, 0x774, 0x5, 0xce, 0x68, 0x2, 0x772, 0x774, 0x5, 0xd0, \n-    0x69, 0x2, 0x773, 0x770, 0x3, 0x2, 0x2, 0x2, 0x773, 0x771, 0x3, 0x2, \n-    0x2, 0x2, 0x773, 0x772, 0x3, 0x2, 0x2, 0x2, 0x774, 0xd7, 0x3, 0x2, 0x2, \n-    0x2, 0x775, 0x778, 0x5, 0xd6, 0x6c, 0x2, 0x776, 0x778, 0x7, 0x73, 0x2, \n-    0x2, 0x777, 0x775, 0x3, 0x2, 0x2, 0x2, 0x777, 0x776, 0x3, 0x2, 0x2, \n-    0x2, 0x778, 0xd9, 0x3, 0x2, 0x2, 0x2, 0x779, 0x77a, 0x7, 0xbf, 0x2, \n-    0x2, 0x77a, 0x77b, 0x7, 0xca, 0x2, 0x2, 0x77b, 0x77c, 0x5, 0xca, 0x66, \n-    0x2, 0x77c, 0xdb, 0x3, 0x2, 0x2, 0x2, 0x103, 0xe0, 0xe4, 0xe7, 0xea, \n-    0xfe, 0x104, 0x10b, 0x113, 0x118, 0x11f, 0x124, 0x12b, 0x130, 0x136, \n-    0x13c, 0x141, 0x147, 0x14c, 0x152, 0x157, 0x15d, 0x16b, 0x172, 0x179, \n-    0x180, 0x186, 0x18b, 0x191, 0x196, 0x19c, 0x1a5, 0x1af, 0x1b9, 0x1cd, \n-    0x1d5, 0x1e4, 0x1eb, 0x1f9, 0x1ff, 0x205, 0x20c, 0x210, 0x213, 0x21a, \n-    0x21e, 0x221, 0x22c, 0x230, 0x233, 0x238, 0x23a, 0x23d, 0x240, 0x24a, \n-    0x24e, 0x251, 0x254, 0x259, 0x25b, 0x261, 0x267, 0x26b, 0x26e, 0x271, \n-    0x274, 0x277, 0x27c, 0x282, 0x286, 0x289, 0x28c, 0x290, 0x298, 0x2b2, \n-    0x2b4, 0x2b8, 0x2ce, 0x2d0, 0x2db, 0x2de, 0x2e7, 0x2f8, 0x303, 0x315, \n-    0x322, 0x333, 0x33c, 0x357, 0x359, 0x36e, 0x373, 0x378, 0x37b, 0x387, \n-    0x38c, 0x390, 0x393, 0x397, 0x39b, 0x3a0, 0x3a3, 0x3a7, 0x3a9, 0x3bf, \n-    0x3c7, 0x3ca, 0x3d4, 0x3d8, 0x3e0, 0x3e4, 0x3e9, 0x3ed, 0x3f1, 0x3f5, \n-    0x3f9, 0x3fb, 0x403, 0x407, 0x40a, 0x412, 0x417, 0x41c, 0x41f, 0x429, \n-    0x433, 0x437, 0x43c, 0x440, 0x446, 0x449, 0x44c, 0x44f, 0x45d, 0x461, \n-    0x465, 0x46a, 0x46d, 0x477, 0x47f, 0x482, 0x486, 0x489, 0x48d, 0x490, \n-    0x493, 0x496, 0x499, 0x49d, 0x4a1, 0x4a4, 0x4a7, 0x4aa, 0x4ad, 0x4b0, \n-    0x4b9, 0x4bf, 0x4d3, 0x4e9, 0x4f1, 0x4f4, 0x4fa, 0x502, 0x505, 0x50b, \n-    0x50d, 0x511, 0x516, 0x519, 0x51c, 0x520, 0x524, 0x527, 0x529, 0x52c, \n-    0x530, 0x534, 0x537, 0x539, 0x53b, 0x53e, 0x543, 0x54e, 0x554, 0x559, \n-    0x560, 0x565, 0x569, 0x56d, 0x572, 0x579, 0x58e, 0x591, 0x59a, 0x59e, \n-    0x5a3, 0x5a8, 0x5ab, 0x5ad, 0x5c3, 0x5c6, 0x5d1, 0x5d5, 0x5d8, 0x5dc, \n-    0x5e0, 0x5e8, 0x5ec, 0x5f9, 0x605, 0x611, 0x619, 0x61d, 0x624, 0x62a, \n-    0x632, 0x637, 0x640, 0x644, 0x663, 0x674, 0x677, 0x67b, 0x67e, 0x68a, \n-    0x69b, 0x69f, 0x6b0, 0x6b3, 0x6b7, 0x6ba, 0x6c5, 0x6dd, 0x6e4, 0x6e6, \n-    0x6e8, 0x6f0, 0x6f5, 0x6fd, 0x707, 0x70a, 0x712, 0x719, 0x722, 0x728, \n-    0x72c, 0x732, 0x739, 0x742, 0x748, 0x752, 0x754, 0x757, 0x75f, 0x764, \n-    0x76e, 0x773, 0x777, \n-  };\n-\n-  atn::ATNDeserializer deserializer;\n-  _atn = deserializer.deserialize(_serializedATN);\n-\n-  size_t count = _atn.getNumberOfDecisions();\n-  _decisionToDFA.reserve(count);\n-  for (size_t i = 0; i < count; i++) { \n-    _decisionToDFA.emplace_back(_atn.getDecisionState(i), i);\n-  }\n-}\n-\n-ClickHouseParser::Initializer ClickHouseParser::_init;\ndiff --git a/src/Parsers/New/ClickHouseParser.h b/src/Parsers/New/ClickHouseParser.h\ndeleted file mode 100644\nindex c860932ba1ca..000000000000\n--- a/src/Parsers/New/ClickHouseParser.h\n+++ /dev/null\n@@ -1,3435 +0,0 @@\n-\n-// Generated from ClickHouseParser.g4 by ANTLR 4.7.2\n-\n-#pragma once\n-\n-\n-#include \"antlr4-runtime.h\"\n-\n-\n-namespace DB {\n-\n-\n-class  ClickHouseParser : public antlr4::Parser {\n-public:\n-  enum {\n-    ADD = 1, AFTER = 2, ALIAS = 3, ALL = 4, ALTER = 5, AND = 6, ANTI = 7, \n-    ANY = 8, ARRAY = 9, AS = 10, ASCENDING = 11, ASOF = 12, AST = 13, ASYNC = 14, \n-    ATTACH = 15, BETWEEN = 16, BOTH = 17, BY = 18, CASE = 19, CAST = 20, \n-    CHECK = 21, CLEAR = 22, CLUSTER = 23, CODEC = 24, COLLATE = 25, COLUMN = 26, \n-    COMMENT = 27, CONSTRAINT = 28, CREATE = 29, CROSS = 30, CUBE = 31, DATABASE = 32, \n-    DATABASES = 33, DATE = 34, DAY = 35, DEDUPLICATE = 36, DEFAULT = 37, \n-    DELAY = 38, DELETE = 39, DESC = 40, DESCENDING = 41, DESCRIBE = 42, \n-    DETACH = 43, DICTIONARIES = 44, DICTIONARY = 45, DISK = 46, DISTINCT = 47, \n-    DISTRIBUTED = 48, DROP = 49, ELSE = 50, END = 51, ENGINE = 52, EVENTS = 53, \n-    EXISTS = 54, EXPLAIN = 55, EXPRESSION = 56, EXTRACT = 57, FETCHES = 58, \n-    FINAL = 59, FIRST = 60, FLUSH = 61, FOR = 62, FORMAT = 63, FREEZE = 64, \n-    FROM = 65, FULL = 66, FUNCTION = 67, GLOBAL = 68, GRANULARITY = 69, \n-    GROUP = 70, HAVING = 71, HIERARCHICAL = 72, HOUR = 73, ID = 74, IF = 75, \n-    ILIKE = 76, IN = 77, INDEX = 78, INF = 79, INJECTIVE = 80, INNER = 81, \n-    INSERT = 82, INTERVAL = 83, INTO = 84, IS = 85, IS_OBJECT_ID = 86, JOIN = 87, \n-    KEY = 88, KILL = 89, LAST = 90, LAYOUT = 91, LEADING = 92, LEFT = 93, \n-    LIFETIME = 94, LIKE = 95, LIMIT = 96, LIVE = 97, LOCAL = 98, LOGS = 99, \n-    MATERIALIZE = 100, MATERIALIZED = 101, MAX = 102, MERGES = 103, MIN = 104, \n-    MINUTE = 105, MODIFY = 106, MONTH = 107, MOVE = 108, MUTATION = 109, \n-    NAN_SQL = 110, NO = 111, NOT = 112, NULL_SQL = 113, NULLS = 114, OFFSET = 115, \n-    ON = 116, OPTIMIZE = 117, OR = 118, ORDER = 119, OUTER = 120, OUTFILE = 121, \n-    PARTITION = 122, POPULATE = 123, PREWHERE = 124, PRIMARY = 125, PROJECTION = 126, \n-    QUARTER = 127, RANGE = 128, RELOAD = 129, REMOVE = 130, RENAME = 131, \n-    REPLACE = 132, REPLICA = 133, REPLICATED = 134, RIGHT = 135, ROLLUP = 136, \n-    SAMPLE = 137, SECOND = 138, SELECT = 139, SEMI = 140, SENDS = 141, SET = 142, \n-    SETTINGS = 143, SHOW = 144, SOURCE = 145, START = 146, STOP = 147, SUBSTRING = 148, \n-    SYNC = 149, SYNTAX = 150, SYSTEM = 151, TABLE = 152, TABLES = 153, TEMPORARY = 154, \n-    TEST = 155, THEN = 156, TIES = 157, TIMEOUT = 158, TIMESTAMP = 159, \n-    TO = 160, TOP = 161, TOTALS = 162, TRAILING = 163, TRIM = 164, TRUNCATE = 165, \n-    TTL = 166, TYPE = 167, UNION = 168, UPDATE = 169, USE = 170, USING = 171, \n-    UUID = 172, VALUES = 173, VIEW = 174, VOLUME = 175, WATCH = 176, WEEK = 177, \n-    WHEN = 178, WHERE = 179, WITH = 180, YEAR = 181, JSON_FALSE = 182, JSON_TRUE = 183, \n-    IDENTIFIER = 184, FLOATING_LITERAL = 185, OCTAL_LITERAL = 186, DECIMAL_LITERAL = 187, \n-    HEXADECIMAL_LITERAL = 188, STRING_LITERAL = 189, ARROW = 190, ASTERISK = 191, \n-    BACKQUOTE = 192, BACKSLASH = 193, COLON = 194, COMMA = 195, CONCAT = 196, \n-    DASH = 197, DOT = 198, EQ_DOUBLE = 199, EQ_SINGLE = 200, GE = 201, GT = 202, \n-    LBRACE = 203, LBRACKET = 204, LE = 205, LPAREN = 206, LT = 207, NOT_EQ = 208, \n-    PERCENT = 209, PLUS = 210, QUERY = 211, QUOTE_DOUBLE = 212, QUOTE_SINGLE = 213, \n-    RBRACE = 214, RBRACKET = 215, RPAREN = 216, SEMICOLON = 217, SLASH = 218, \n-    UNDERSCORE = 219, MULTI_LINE_COMMENT = 220, SINGLE_LINE_COMMENT = 221, \n-    WHITESPACE = 222\n-  };\n-\n-  enum {\n-    RuleQueryStmt = 0, RuleQuery = 1, RuleAlterStmt = 2, RuleAlterTableClause = 3, \n-    RuleAssignmentExprList = 4, RuleAssignmentExpr = 5, RuleTableColumnPropertyType = 6, \n-    RulePartitionClause = 7, RuleAttachStmt = 8, RuleCheckStmt = 9, RuleCreateStmt = 10, \n-    RuleDictionarySchemaClause = 11, RuleDictionaryAttrDfnt = 12, RuleDictionaryEngineClause = 13, \n-    RuleDictionaryPrimaryKeyClause = 14, RuleDictionaryArgExpr = 15, RuleSourceClause = 16, \n-    RuleLifetimeClause = 17, RuleLayoutClause = 18, RuleRangeClause = 19, \n-    RuleDictionarySettingsClause = 20, RuleClusterClause = 21, RuleUuidClause = 22, \n-    RuleDestinationClause = 23, RuleSubqueryClause = 24, RuleTableSchemaClause = 25, \n-    RuleEngineClause = 26, RulePartitionByClause = 27, RulePrimaryKeyClause = 28, \n-    RuleSampleByClause = 29, RuleTtlClause = 30, RuleEngineExpr = 31, RuleTableElementExpr = 32, \n-    RuleTableColumnDfnt = 33, RuleTableColumnPropertyExpr = 34, RuleTableIndexDfnt = 35, \n-    RuleTableProjectionDfnt = 36, RuleCodecExpr = 37, RuleCodecArgExpr = 38, \n-    RuleTtlExpr = 39, RuleDescribeStmt = 40, RuleDropStmt = 41, RuleExistsStmt = 42, \n-    RuleExplainStmt = 43, RuleInsertStmt = 44, RuleColumnsClause = 45, RuleDataClause = 46, \n-    RuleKillStmt = 47, RuleOptimizeStmt = 48, RuleRenameStmt = 49, RuleProjectionSelectStmt = 50, \n-    RuleSelectUnionStmt = 51, RuleSelectStmtWithParens = 52, RuleSelectStmt = 53, \n-    RuleWithClause = 54, RuleTopClause = 55, RuleFromClause = 56, RuleArrayJoinClause = 57, \n-    RulePrewhereClause = 58, RuleWhereClause = 59, RuleGroupByClause = 60, \n-    RuleHavingClause = 61, RuleOrderByClause = 62, RuleProjectionOrderByClause = 63, \n-    RuleLimitByClause = 64, RuleLimitClause = 65, RuleSettingsClause = 66, \n-    RuleJoinExpr = 67, RuleJoinOp = 68, RuleJoinOpCross = 69, RuleJoinConstraintClause = 70, \n-    RuleSampleClause = 71, RuleLimitExpr = 72, RuleOrderExprList = 73, RuleOrderExpr = 74, \n-    RuleRatioExpr = 75, RuleSettingExprList = 76, RuleSettingExpr = 77, \n-    RuleSetStmt = 78, RuleShowStmt = 79, RuleSystemStmt = 80, RuleTruncateStmt = 81, \n-    RuleUseStmt = 82, RuleWatchStmt = 83, RuleColumnTypeExpr = 84, RuleColumnExprList = 85, \n-    RuleColumnsExpr = 86, RuleColumnExpr = 87, RuleColumnArgList = 88, RuleColumnArgExpr = 89, \n-    RuleColumnLambdaExpr = 90, RuleColumnIdentifier = 91, RuleNestedIdentifier = 92, \n-    RuleTableExpr = 93, RuleTableFunctionExpr = 94, RuleTableIdentifier = 95, \n-    RuleTableArgList = 96, RuleTableArgExpr = 97, RuleDatabaseIdentifier = 98, \n-    RuleFloatingLiteral = 99, RuleNumberLiteral = 100, RuleLiteral = 101, \n-    RuleInterval = 102, RuleKeyword = 103, RuleKeywordForAlias = 104, RuleAlias = 105, \n-    RuleIdentifier = 106, RuleIdentifierOrNull = 107, RuleEnumValue = 108\n-  };\n-\n-  ClickHouseParser(antlr4::TokenStream *input);\n-  ~ClickHouseParser();\n-\n-  virtual std::string getGrammarFileName() const override;\n-  virtual const antlr4::atn::ATN& getATN() const override { return _atn; };\n-  virtual const std::vector<std::string>& getTokenNames() const override { return _tokenNames; }; // deprecated: use vocabulary instead.\n-  virtual const std::vector<std::string>& getRuleNames() const override;\n-  virtual antlr4::dfa::Vocabulary& getVocabulary() const override;\n-\n-\n-  class QueryStmtContext;\n-  class QueryContext;\n-  class AlterStmtContext;\n-  class AlterTableClauseContext;\n-  class AssignmentExprListContext;\n-  class AssignmentExprContext;\n-  class TableColumnPropertyTypeContext;\n-  class PartitionClauseContext;\n-  class AttachStmtContext;\n-  class CheckStmtContext;\n-  class CreateStmtContext;\n-  class DictionarySchemaClauseContext;\n-  class DictionaryAttrDfntContext;\n-  class DictionaryEngineClauseContext;\n-  class DictionaryPrimaryKeyClauseContext;\n-  class DictionaryArgExprContext;\n-  class SourceClauseContext;\n-  class LifetimeClauseContext;\n-  class LayoutClauseContext;\n-  class RangeClauseContext;\n-  class DictionarySettingsClauseContext;\n-  class ClusterClauseContext;\n-  class UuidClauseContext;\n-  class DestinationClauseContext;\n-  class SubqueryClauseContext;\n-  class TableSchemaClauseContext;\n-  class EngineClauseContext;\n-  class PartitionByClauseContext;\n-  class PrimaryKeyClauseContext;\n-  class SampleByClauseContext;\n-  class TtlClauseContext;\n-  class EngineExprContext;\n-  class TableElementExprContext;\n-  class TableColumnDfntContext;\n-  class TableColumnPropertyExprContext;\n-  class TableIndexDfntContext;\n-  class TableProjectionDfntContext;\n-  class CodecExprContext;\n-  class CodecArgExprContext;\n-  class TtlExprContext;\n-  class DescribeStmtContext;\n-  class DropStmtContext;\n-  class ExistsStmtContext;\n-  class ExplainStmtContext;\n-  class InsertStmtContext;\n-  class ColumnsClauseContext;\n-  class DataClauseContext;\n-  class KillStmtContext;\n-  class OptimizeStmtContext;\n-  class RenameStmtContext;\n-  class ProjectionSelectStmtContext;\n-  class SelectUnionStmtContext;\n-  class SelectStmtWithParensContext;\n-  class SelectStmtContext;\n-  class WithClauseContext;\n-  class TopClauseContext;\n-  class FromClauseContext;\n-  class ArrayJoinClauseContext;\n-  class PrewhereClauseContext;\n-  class WhereClauseContext;\n-  class GroupByClauseContext;\n-  class HavingClauseContext;\n-  class OrderByClauseContext;\n-  class ProjectionOrderByClauseContext;\n-  class LimitByClauseContext;\n-  class LimitClauseContext;\n-  class SettingsClauseContext;\n-  class JoinExprContext;\n-  class JoinOpContext;\n-  class JoinOpCrossContext;\n-  class JoinConstraintClauseContext;\n-  class SampleClauseContext;\n-  class LimitExprContext;\n-  class OrderExprListContext;\n-  class OrderExprContext;\n-  class RatioExprContext;\n-  class SettingExprListContext;\n-  class SettingExprContext;\n-  class SetStmtContext;\n-  class ShowStmtContext;\n-  class SystemStmtContext;\n-  class TruncateStmtContext;\n-  class UseStmtContext;\n-  class WatchStmtContext;\n-  class ColumnTypeExprContext;\n-  class ColumnExprListContext;\n-  class ColumnsExprContext;\n-  class ColumnExprContext;\n-  class ColumnArgListContext;\n-  class ColumnArgExprContext;\n-  class ColumnLambdaExprContext;\n-  class ColumnIdentifierContext;\n-  class NestedIdentifierContext;\n-  class TableExprContext;\n-  class TableFunctionExprContext;\n-  class TableIdentifierContext;\n-  class TableArgListContext;\n-  class TableArgExprContext;\n-  class DatabaseIdentifierContext;\n-  class FloatingLiteralContext;\n-  class NumberLiteralContext;\n-  class LiteralContext;\n-  class IntervalContext;\n-  class KeywordContext;\n-  class KeywordForAliasContext;\n-  class AliasContext;\n-  class IdentifierContext;\n-  class IdentifierOrNullContext;\n-  class EnumValueContext; \n-\n-  class  QueryStmtContext : public antlr4::ParserRuleContext {\n-  public:\n-    QueryStmtContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    QueryContext *query();\n-    antlr4::tree::TerminalNode *INTO();\n-    antlr4::tree::TerminalNode *OUTFILE();\n-    antlr4::tree::TerminalNode *STRING_LITERAL();\n-    antlr4::tree::TerminalNode *FORMAT();\n-    IdentifierOrNullContext *identifierOrNull();\n-    antlr4::tree::TerminalNode *SEMICOLON();\n-    InsertStmtContext *insertStmt();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  QueryStmtContext* queryStmt();\n-\n-  class  QueryContext : public antlr4::ParserRuleContext {\n-  public:\n-    QueryContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    AlterStmtContext *alterStmt();\n-    AttachStmtContext *attachStmt();\n-    CheckStmtContext *checkStmt();\n-    CreateStmtContext *createStmt();\n-    DescribeStmtContext *describeStmt();\n-    DropStmtContext *dropStmt();\n-    ExistsStmtContext *existsStmt();\n-    ExplainStmtContext *explainStmt();\n-    KillStmtContext *killStmt();\n-    OptimizeStmtContext *optimizeStmt();\n-    RenameStmtContext *renameStmt();\n-    SelectUnionStmtContext *selectUnionStmt();\n-    SetStmtContext *setStmt();\n-    ShowStmtContext *showStmt();\n-    SystemStmtContext *systemStmt();\n-    TruncateStmtContext *truncateStmt();\n-    UseStmtContext *useStmt();\n-    WatchStmtContext *watchStmt();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  QueryContext* query();\n-\n-  class  AlterStmtContext : public antlr4::ParserRuleContext {\n-  public:\n-    AlterStmtContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-   \n-    AlterStmtContext() = default;\n-    void copyFrom(AlterStmtContext *context);\n-    using antlr4::ParserRuleContext::copyFrom;\n-\n-    virtual size_t getRuleIndex() const override;\n-\n-   \n-  };\n-\n-  class  AlterTableStmtContext : public AlterStmtContext {\n-  public:\n-    AlterTableStmtContext(AlterStmtContext *ctx);\n-\n-    antlr4::tree::TerminalNode *ALTER();\n-    antlr4::tree::TerminalNode *TABLE();\n-    TableIdentifierContext *tableIdentifier();\n-    std::vector<AlterTableClauseContext *> alterTableClause();\n-    AlterTableClauseContext* alterTableClause(size_t i);\n-    ClusterClauseContext *clusterClause();\n-    std::vector<antlr4::tree::TerminalNode *> COMMA();\n-    antlr4::tree::TerminalNode* COMMA(size_t i);\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  AlterStmtContext* alterStmt();\n-\n-  class  AlterTableClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    AlterTableClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-   \n-    AlterTableClauseContext() = default;\n-    void copyFrom(AlterTableClauseContext *context);\n-    using antlr4::ParserRuleContext::copyFrom;\n-\n-    virtual size_t getRuleIndex() const override;\n-\n-   \n-  };\n-\n-  class  AlterTableClauseReplaceContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseReplaceContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *REPLACE();\n-    PartitionClauseContext *partitionClause();\n-    antlr4::tree::TerminalNode *FROM();\n-    TableIdentifierContext *tableIdentifier();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseModifyOrderByContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseModifyOrderByContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *MODIFY();\n-    antlr4::tree::TerminalNode *ORDER();\n-    antlr4::tree::TerminalNode *BY();\n-    ColumnExprContext *columnExpr();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseUpdateContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseUpdateContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *UPDATE();\n-    AssignmentExprListContext *assignmentExprList();\n-    WhereClauseContext *whereClause();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseClearProjectionContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseClearProjectionContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *CLEAR();\n-    antlr4::tree::TerminalNode *PROJECTION();\n-    NestedIdentifierContext *nestedIdentifier();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    antlr4::tree::TerminalNode *IN();\n-    PartitionClauseContext *partitionClause();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseModifyRemoveContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseModifyRemoveContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *MODIFY();\n-    antlr4::tree::TerminalNode *COLUMN();\n-    NestedIdentifierContext *nestedIdentifier();\n-    antlr4::tree::TerminalNode *REMOVE();\n-    TableColumnPropertyTypeContext *tableColumnPropertyType();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseDeleteContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseDeleteContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *DELETE();\n-    antlr4::tree::TerminalNode *WHERE();\n-    ColumnExprContext *columnExpr();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseCommentContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseCommentContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *COMMENT();\n-    antlr4::tree::TerminalNode *COLUMN();\n-    NestedIdentifierContext *nestedIdentifier();\n-    antlr4::tree::TerminalNode *STRING_LITERAL();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseDropColumnContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseDropColumnContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *DROP();\n-    antlr4::tree::TerminalNode *COLUMN();\n-    NestedIdentifierContext *nestedIdentifier();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseDetachContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseDetachContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *DETACH();\n-    PartitionClauseContext *partitionClause();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseAddIndexContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseAddIndexContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *ADD();\n-    antlr4::tree::TerminalNode *INDEX();\n-    TableIndexDfntContext *tableIndexDfnt();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *NOT();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    antlr4::tree::TerminalNode *AFTER();\n-    NestedIdentifierContext *nestedIdentifier();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseDropPartitionContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseDropPartitionContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *DROP();\n-    PartitionClauseContext *partitionClause();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseMaterializeIndexContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseMaterializeIndexContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *MATERIALIZE();\n-    antlr4::tree::TerminalNode *INDEX();\n-    NestedIdentifierContext *nestedIdentifier();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    antlr4::tree::TerminalNode *IN();\n-    PartitionClauseContext *partitionClause();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseMaterializeProjectionContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseMaterializeProjectionContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *MATERIALIZE();\n-    antlr4::tree::TerminalNode *PROJECTION();\n-    NestedIdentifierContext *nestedIdentifier();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    antlr4::tree::TerminalNode *IN();\n-    PartitionClauseContext *partitionClause();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseMovePartitionContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseMovePartitionContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *MOVE();\n-    PartitionClauseContext *partitionClause();\n-    antlr4::tree::TerminalNode *TO();\n-    antlr4::tree::TerminalNode *DISK();\n-    antlr4::tree::TerminalNode *STRING_LITERAL();\n-    antlr4::tree::TerminalNode *VOLUME();\n-    antlr4::tree::TerminalNode *TABLE();\n-    TableIdentifierContext *tableIdentifier();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseRenameContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseRenameContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *RENAME();\n-    antlr4::tree::TerminalNode *COLUMN();\n-    std::vector<NestedIdentifierContext *> nestedIdentifier();\n-    NestedIdentifierContext* nestedIdentifier(size_t i);\n-    antlr4::tree::TerminalNode *TO();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseFreezePartitionContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseFreezePartitionContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *FREEZE();\n-    PartitionClauseContext *partitionClause();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseClearColumnContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseClearColumnContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *CLEAR();\n-    antlr4::tree::TerminalNode *COLUMN();\n-    NestedIdentifierContext *nestedIdentifier();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    antlr4::tree::TerminalNode *IN();\n-    PartitionClauseContext *partitionClause();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseModifyContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseModifyContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *MODIFY();\n-    antlr4::tree::TerminalNode *COLUMN();\n-    TableColumnDfntContext *tableColumnDfnt();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseClearIndexContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseClearIndexContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *CLEAR();\n-    antlr4::tree::TerminalNode *INDEX();\n-    NestedIdentifierContext *nestedIdentifier();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    antlr4::tree::TerminalNode *IN();\n-    PartitionClauseContext *partitionClause();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseRemoveTTLContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseRemoveTTLContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *REMOVE();\n-    antlr4::tree::TerminalNode *TTL();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseModifyCodecContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseModifyCodecContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *MODIFY();\n-    antlr4::tree::TerminalNode *COLUMN();\n-    NestedIdentifierContext *nestedIdentifier();\n-    CodecExprContext *codecExpr();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseAttachContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseAttachContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *ATTACH();\n-    PartitionClauseContext *partitionClause();\n-    antlr4::tree::TerminalNode *FROM();\n-    TableIdentifierContext *tableIdentifier();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseDropProjectionContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseDropProjectionContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *DROP();\n-    antlr4::tree::TerminalNode *PROJECTION();\n-    NestedIdentifierContext *nestedIdentifier();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseDropIndexContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseDropIndexContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *DROP();\n-    antlr4::tree::TerminalNode *INDEX();\n-    NestedIdentifierContext *nestedIdentifier();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseModifyCommentContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseModifyCommentContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *MODIFY();\n-    antlr4::tree::TerminalNode *COLUMN();\n-    NestedIdentifierContext *nestedIdentifier();\n-    antlr4::tree::TerminalNode *COMMENT();\n-    antlr4::tree::TerminalNode *STRING_LITERAL();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseModifyTTLContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseModifyTTLContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *MODIFY();\n-    TtlClauseContext *ttlClause();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseAddProjectionContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseAddProjectionContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *ADD();\n-    antlr4::tree::TerminalNode *PROJECTION();\n-    TableProjectionDfntContext *tableProjectionDfnt();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *NOT();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    antlr4::tree::TerminalNode *AFTER();\n-    NestedIdentifierContext *nestedIdentifier();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  AlterTableClauseAddColumnContext : public AlterTableClauseContext {\n-  public:\n-    AlterTableClauseAddColumnContext(AlterTableClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *ADD();\n-    antlr4::tree::TerminalNode *COLUMN();\n-    TableColumnDfntContext *tableColumnDfnt();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *NOT();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    antlr4::tree::TerminalNode *AFTER();\n-    NestedIdentifierContext *nestedIdentifier();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  AlterTableClauseContext* alterTableClause();\n-\n-  class  AssignmentExprListContext : public antlr4::ParserRuleContext {\n-  public:\n-    AssignmentExprListContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    std::vector<AssignmentExprContext *> assignmentExpr();\n-    AssignmentExprContext* assignmentExpr(size_t i);\n-    std::vector<antlr4::tree::TerminalNode *> COMMA();\n-    antlr4::tree::TerminalNode* COMMA(size_t i);\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  AssignmentExprListContext* assignmentExprList();\n-\n-  class  AssignmentExprContext : public antlr4::ParserRuleContext {\n-  public:\n-    AssignmentExprContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    NestedIdentifierContext *nestedIdentifier();\n-    antlr4::tree::TerminalNode *EQ_SINGLE();\n-    ColumnExprContext *columnExpr();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  AssignmentExprContext* assignmentExpr();\n-\n-  class  TableColumnPropertyTypeContext : public antlr4::ParserRuleContext {\n-  public:\n-    TableColumnPropertyTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *ALIAS();\n-    antlr4::tree::TerminalNode *CODEC();\n-    antlr4::tree::TerminalNode *COMMENT();\n-    antlr4::tree::TerminalNode *DEFAULT();\n-    antlr4::tree::TerminalNode *MATERIALIZED();\n-    antlr4::tree::TerminalNode *TTL();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  TableColumnPropertyTypeContext* tableColumnPropertyType();\n-\n-  class  PartitionClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    PartitionClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *PARTITION();\n-    ColumnExprContext *columnExpr();\n-    antlr4::tree::TerminalNode *ID();\n-    antlr4::tree::TerminalNode *STRING_LITERAL();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  PartitionClauseContext* partitionClause();\n-\n-  class  AttachStmtContext : public antlr4::ParserRuleContext {\n-  public:\n-    AttachStmtContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-   \n-    AttachStmtContext() = default;\n-    void copyFrom(AttachStmtContext *context);\n-    using antlr4::ParserRuleContext::copyFrom;\n-\n-    virtual size_t getRuleIndex() const override;\n-\n-   \n-  };\n-\n-  class  AttachDictionaryStmtContext : public AttachStmtContext {\n-  public:\n-    AttachDictionaryStmtContext(AttachStmtContext *ctx);\n-\n-    antlr4::tree::TerminalNode *ATTACH();\n-    antlr4::tree::TerminalNode *DICTIONARY();\n-    TableIdentifierContext *tableIdentifier();\n-    ClusterClauseContext *clusterClause();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  AttachStmtContext* attachStmt();\n-\n-  class  CheckStmtContext : public antlr4::ParserRuleContext {\n-  public:\n-    CheckStmtContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *CHECK();\n-    antlr4::tree::TerminalNode *TABLE();\n-    TableIdentifierContext *tableIdentifier();\n-    PartitionClauseContext *partitionClause();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  CheckStmtContext* checkStmt();\n-\n-  class  CreateStmtContext : public antlr4::ParserRuleContext {\n-  public:\n-    CreateStmtContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-   \n-    CreateStmtContext() = default;\n-    void copyFrom(CreateStmtContext *context);\n-    using antlr4::ParserRuleContext::copyFrom;\n-\n-    virtual size_t getRuleIndex() const override;\n-\n-   \n-  };\n-\n-  class  CreateViewStmtContext : public CreateStmtContext {\n-  public:\n-    CreateViewStmtContext(CreateStmtContext *ctx);\n-\n-    antlr4::tree::TerminalNode *VIEW();\n-    TableIdentifierContext *tableIdentifier();\n-    SubqueryClauseContext *subqueryClause();\n-    antlr4::tree::TerminalNode *ATTACH();\n-    antlr4::tree::TerminalNode *CREATE();\n-    antlr4::tree::TerminalNode *OR();\n-    antlr4::tree::TerminalNode *REPLACE();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *NOT();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    UuidClauseContext *uuidClause();\n-    ClusterClauseContext *clusterClause();\n-    TableSchemaClauseContext *tableSchemaClause();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  CreateDictionaryStmtContext : public CreateStmtContext {\n-  public:\n-    CreateDictionaryStmtContext(CreateStmtContext *ctx);\n-\n-    antlr4::tree::TerminalNode *DICTIONARY();\n-    TableIdentifierContext *tableIdentifier();\n-    DictionarySchemaClauseContext *dictionarySchemaClause();\n-    DictionaryEngineClauseContext *dictionaryEngineClause();\n-    antlr4::tree::TerminalNode *ATTACH();\n-    antlr4::tree::TerminalNode *CREATE();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *NOT();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    UuidClauseContext *uuidClause();\n-    ClusterClauseContext *clusterClause();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  CreateDatabaseStmtContext : public CreateStmtContext {\n-  public:\n-    CreateDatabaseStmtContext(CreateStmtContext *ctx);\n-\n-    antlr4::tree::TerminalNode *DATABASE();\n-    DatabaseIdentifierContext *databaseIdentifier();\n-    antlr4::tree::TerminalNode *ATTACH();\n-    antlr4::tree::TerminalNode *CREATE();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *NOT();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    ClusterClauseContext *clusterClause();\n-    EngineExprContext *engineExpr();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  CreateLiveViewStmtContext : public CreateStmtContext {\n-  public:\n-    CreateLiveViewStmtContext(CreateStmtContext *ctx);\n-\n-    antlr4::tree::TerminalNode *LIVE();\n-    antlr4::tree::TerminalNode *VIEW();\n-    TableIdentifierContext *tableIdentifier();\n-    SubqueryClauseContext *subqueryClause();\n-    antlr4::tree::TerminalNode *ATTACH();\n-    antlr4::tree::TerminalNode *CREATE();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *NOT();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    UuidClauseContext *uuidClause();\n-    ClusterClauseContext *clusterClause();\n-    antlr4::tree::TerminalNode *WITH();\n-    antlr4::tree::TerminalNode *TIMEOUT();\n-    DestinationClauseContext *destinationClause();\n-    TableSchemaClauseContext *tableSchemaClause();\n-    antlr4::tree::TerminalNode *DECIMAL_LITERAL();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  CreateMaterializedViewStmtContext : public CreateStmtContext {\n-  public:\n-    CreateMaterializedViewStmtContext(CreateStmtContext *ctx);\n-\n-    antlr4::tree::TerminalNode *MATERIALIZED();\n-    antlr4::tree::TerminalNode *VIEW();\n-    TableIdentifierContext *tableIdentifier();\n-    SubqueryClauseContext *subqueryClause();\n-    antlr4::tree::TerminalNode *ATTACH();\n-    antlr4::tree::TerminalNode *CREATE();\n-    DestinationClauseContext *destinationClause();\n-    EngineClauseContext *engineClause();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *NOT();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    UuidClauseContext *uuidClause();\n-    ClusterClauseContext *clusterClause();\n-    TableSchemaClauseContext *tableSchemaClause();\n-    antlr4::tree::TerminalNode *POPULATE();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  CreateTableStmtContext : public CreateStmtContext {\n-  public:\n-    CreateTableStmtContext(CreateStmtContext *ctx);\n-\n-    antlr4::tree::TerminalNode *TABLE();\n-    TableIdentifierContext *tableIdentifier();\n-    antlr4::tree::TerminalNode *ATTACH();\n-    antlr4::tree::TerminalNode *CREATE();\n-    antlr4::tree::TerminalNode *TEMPORARY();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *NOT();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    UuidClauseContext *uuidClause();\n-    ClusterClauseContext *clusterClause();\n-    TableSchemaClauseContext *tableSchemaClause();\n-    EngineClauseContext *engineClause();\n-    SubqueryClauseContext *subqueryClause();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  CreateStmtContext* createStmt();\n-\n-  class  DictionarySchemaClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    DictionarySchemaClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *LPAREN();\n-    std::vector<DictionaryAttrDfntContext *> dictionaryAttrDfnt();\n-    DictionaryAttrDfntContext* dictionaryAttrDfnt(size_t i);\n-    antlr4::tree::TerminalNode *RPAREN();\n-    std::vector<antlr4::tree::TerminalNode *> COMMA();\n-    antlr4::tree::TerminalNode* COMMA(size_t i);\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  DictionarySchemaClauseContext* dictionarySchemaClause();\n-\n-  class  DictionaryAttrDfntContext : public antlr4::ParserRuleContext {\n-  public:\n-    std::set<std::string> attrs;\n-    DictionaryAttrDfntContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    IdentifierContext *identifier();\n-    ColumnTypeExprContext *columnTypeExpr();\n-    std::vector<antlr4::tree::TerminalNode *> DEFAULT();\n-    antlr4::tree::TerminalNode* DEFAULT(size_t i);\n-    std::vector<LiteralContext *> literal();\n-    LiteralContext* literal(size_t i);\n-    std::vector<antlr4::tree::TerminalNode *> EXPRESSION();\n-    antlr4::tree::TerminalNode* EXPRESSION(size_t i);\n-    std::vector<ColumnExprContext *> columnExpr();\n-    ColumnExprContext* columnExpr(size_t i);\n-    std::vector<antlr4::tree::TerminalNode *> HIERARCHICAL();\n-    antlr4::tree::TerminalNode* HIERARCHICAL(size_t i);\n-    std::vector<antlr4::tree::TerminalNode *> INJECTIVE();\n-    antlr4::tree::TerminalNode* INJECTIVE(size_t i);\n-    std::vector<antlr4::tree::TerminalNode *> IS_OBJECT_ID();\n-    antlr4::tree::TerminalNode* IS_OBJECT_ID(size_t i);\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  DictionaryAttrDfntContext* dictionaryAttrDfnt();\n-\n-  class  DictionaryEngineClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    std::set<std::string> clauses;\n-    DictionaryEngineClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    DictionaryPrimaryKeyClauseContext *dictionaryPrimaryKeyClause();\n-    std::vector<SourceClauseContext *> sourceClause();\n-    SourceClauseContext* sourceClause(size_t i);\n-    std::vector<LifetimeClauseContext *> lifetimeClause();\n-    LifetimeClauseContext* lifetimeClause(size_t i);\n-    std::vector<LayoutClauseContext *> layoutClause();\n-    LayoutClauseContext* layoutClause(size_t i);\n-    std::vector<RangeClauseContext *> rangeClause();\n-    RangeClauseContext* rangeClause(size_t i);\n-    std::vector<DictionarySettingsClauseContext *> dictionarySettingsClause();\n-    DictionarySettingsClauseContext* dictionarySettingsClause(size_t i);\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  DictionaryEngineClauseContext* dictionaryEngineClause();\n-\n-  class  DictionaryPrimaryKeyClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    DictionaryPrimaryKeyClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *PRIMARY();\n-    antlr4::tree::TerminalNode *KEY();\n-    ColumnExprListContext *columnExprList();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  DictionaryPrimaryKeyClauseContext* dictionaryPrimaryKeyClause();\n-\n-  class  DictionaryArgExprContext : public antlr4::ParserRuleContext {\n-  public:\n-    DictionaryArgExprContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    std::vector<IdentifierContext *> identifier();\n-    IdentifierContext* identifier(size_t i);\n-    LiteralContext *literal();\n-    antlr4::tree::TerminalNode *LPAREN();\n-    antlr4::tree::TerminalNode *RPAREN();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  DictionaryArgExprContext* dictionaryArgExpr();\n-\n-  class  SourceClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    SourceClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *SOURCE();\n-    std::vector<antlr4::tree::TerminalNode *> LPAREN();\n-    antlr4::tree::TerminalNode* LPAREN(size_t i);\n-    IdentifierContext *identifier();\n-    std::vector<antlr4::tree::TerminalNode *> RPAREN();\n-    antlr4::tree::TerminalNode* RPAREN(size_t i);\n-    std::vector<DictionaryArgExprContext *> dictionaryArgExpr();\n-    DictionaryArgExprContext* dictionaryArgExpr(size_t i);\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  SourceClauseContext* sourceClause();\n-\n-  class  LifetimeClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    LifetimeClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *LIFETIME();\n-    antlr4::tree::TerminalNode *LPAREN();\n-    antlr4::tree::TerminalNode *RPAREN();\n-    std::vector<antlr4::tree::TerminalNode *> DECIMAL_LITERAL();\n-    antlr4::tree::TerminalNode* DECIMAL_LITERAL(size_t i);\n-    antlr4::tree::TerminalNode *MIN();\n-    antlr4::tree::TerminalNode *MAX();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  LifetimeClauseContext* lifetimeClause();\n-\n-  class  LayoutClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    LayoutClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *LAYOUT();\n-    std::vector<antlr4::tree::TerminalNode *> LPAREN();\n-    antlr4::tree::TerminalNode* LPAREN(size_t i);\n-    IdentifierContext *identifier();\n-    std::vector<antlr4::tree::TerminalNode *> RPAREN();\n-    antlr4::tree::TerminalNode* RPAREN(size_t i);\n-    std::vector<DictionaryArgExprContext *> dictionaryArgExpr();\n-    DictionaryArgExprContext* dictionaryArgExpr(size_t i);\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  LayoutClauseContext* layoutClause();\n-\n-  class  RangeClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    RangeClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *RANGE();\n-    antlr4::tree::TerminalNode *LPAREN();\n-    antlr4::tree::TerminalNode *RPAREN();\n-    antlr4::tree::TerminalNode *MIN();\n-    std::vector<IdentifierContext *> identifier();\n-    IdentifierContext* identifier(size_t i);\n-    antlr4::tree::TerminalNode *MAX();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  RangeClauseContext* rangeClause();\n-\n-  class  DictionarySettingsClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    DictionarySettingsClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *SETTINGS();\n-    antlr4::tree::TerminalNode *LPAREN();\n-    SettingExprListContext *settingExprList();\n-    antlr4::tree::TerminalNode *RPAREN();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  DictionarySettingsClauseContext* dictionarySettingsClause();\n-\n-  class  ClusterClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    ClusterClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *ON();\n-    antlr4::tree::TerminalNode *CLUSTER();\n-    IdentifierContext *identifier();\n-    antlr4::tree::TerminalNode *STRING_LITERAL();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  ClusterClauseContext* clusterClause();\n-\n-  class  UuidClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    UuidClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *UUID();\n-    antlr4::tree::TerminalNode *STRING_LITERAL();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  UuidClauseContext* uuidClause();\n-\n-  class  DestinationClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    DestinationClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *TO();\n-    TableIdentifierContext *tableIdentifier();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  DestinationClauseContext* destinationClause();\n-\n-  class  SubqueryClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    SubqueryClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *AS();\n-    SelectUnionStmtContext *selectUnionStmt();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  SubqueryClauseContext* subqueryClause();\n-\n-  class  TableSchemaClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    TableSchemaClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-   \n-    TableSchemaClauseContext() = default;\n-    void copyFrom(TableSchemaClauseContext *context);\n-    using antlr4::ParserRuleContext::copyFrom;\n-\n-    virtual size_t getRuleIndex() const override;\n-\n-   \n-  };\n-\n-  class  SchemaAsTableClauseContext : public TableSchemaClauseContext {\n-  public:\n-    SchemaAsTableClauseContext(TableSchemaClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *AS();\n-    TableIdentifierContext *tableIdentifier();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  SchemaAsFunctionClauseContext : public TableSchemaClauseContext {\n-  public:\n-    SchemaAsFunctionClauseContext(TableSchemaClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *AS();\n-    TableFunctionExprContext *tableFunctionExpr();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  SchemaDescriptionClauseContext : public TableSchemaClauseContext {\n-  public:\n-    SchemaDescriptionClauseContext(TableSchemaClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *LPAREN();\n-    std::vector<TableElementExprContext *> tableElementExpr();\n-    TableElementExprContext* tableElementExpr(size_t i);\n-    antlr4::tree::TerminalNode *RPAREN();\n-    std::vector<antlr4::tree::TerminalNode *> COMMA();\n-    antlr4::tree::TerminalNode* COMMA(size_t i);\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  TableSchemaClauseContext* tableSchemaClause();\n-\n-  class  EngineClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    std::set<std::string> clauses;\n-    EngineClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    EngineExprContext *engineExpr();\n-    std::vector<OrderByClauseContext *> orderByClause();\n-    OrderByClauseContext* orderByClause(size_t i);\n-    std::vector<PartitionByClauseContext *> partitionByClause();\n-    PartitionByClauseContext* partitionByClause(size_t i);\n-    std::vector<PrimaryKeyClauseContext *> primaryKeyClause();\n-    PrimaryKeyClauseContext* primaryKeyClause(size_t i);\n-    std::vector<SampleByClauseContext *> sampleByClause();\n-    SampleByClauseContext* sampleByClause(size_t i);\n-    std::vector<TtlClauseContext *> ttlClause();\n-    TtlClauseContext* ttlClause(size_t i);\n-    std::vector<SettingsClauseContext *> settingsClause();\n-    SettingsClauseContext* settingsClause(size_t i);\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  EngineClauseContext* engineClause();\n-\n-  class  PartitionByClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    PartitionByClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *PARTITION();\n-    antlr4::tree::TerminalNode *BY();\n-    ColumnExprContext *columnExpr();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  PartitionByClauseContext* partitionByClause();\n-\n-  class  PrimaryKeyClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    PrimaryKeyClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *PRIMARY();\n-    antlr4::tree::TerminalNode *KEY();\n-    ColumnExprContext *columnExpr();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  PrimaryKeyClauseContext* primaryKeyClause();\n-\n-  class  SampleByClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    SampleByClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *SAMPLE();\n-    antlr4::tree::TerminalNode *BY();\n-    ColumnExprContext *columnExpr();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  SampleByClauseContext* sampleByClause();\n-\n-  class  TtlClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    TtlClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *TTL();\n-    std::vector<TtlExprContext *> ttlExpr();\n-    TtlExprContext* ttlExpr(size_t i);\n-    std::vector<antlr4::tree::TerminalNode *> COMMA();\n-    antlr4::tree::TerminalNode* COMMA(size_t i);\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  TtlClauseContext* ttlClause();\n-\n-  class  EngineExprContext : public antlr4::ParserRuleContext {\n-  public:\n-    EngineExprContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *ENGINE();\n-    IdentifierOrNullContext *identifierOrNull();\n-    antlr4::tree::TerminalNode *EQ_SINGLE();\n-    antlr4::tree::TerminalNode *LPAREN();\n-    antlr4::tree::TerminalNode *RPAREN();\n-    ColumnExprListContext *columnExprList();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  EngineExprContext* engineExpr();\n-\n-  class  TableElementExprContext : public antlr4::ParserRuleContext {\n-  public:\n-    TableElementExprContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-   \n-    TableElementExprContext() = default;\n-    void copyFrom(TableElementExprContext *context);\n-    using antlr4::ParserRuleContext::copyFrom;\n-\n-    virtual size_t getRuleIndex() const override;\n-\n-   \n-  };\n-\n-  class  TableElementExprProjectionContext : public TableElementExprContext {\n-  public:\n-    TableElementExprProjectionContext(TableElementExprContext *ctx);\n-\n-    antlr4::tree::TerminalNode *PROJECTION();\n-    TableProjectionDfntContext *tableProjectionDfnt();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  TableElementExprConstraintContext : public TableElementExprContext {\n-  public:\n-    TableElementExprConstraintContext(TableElementExprContext *ctx);\n-\n-    antlr4::tree::TerminalNode *CONSTRAINT();\n-    IdentifierContext *identifier();\n-    antlr4::tree::TerminalNode *CHECK();\n-    ColumnExprContext *columnExpr();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  TableElementExprColumnContext : public TableElementExprContext {\n-  public:\n-    TableElementExprColumnContext(TableElementExprContext *ctx);\n-\n-    TableColumnDfntContext *tableColumnDfnt();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  TableElementExprIndexContext : public TableElementExprContext {\n-  public:\n-    TableElementExprIndexContext(TableElementExprContext *ctx);\n-\n-    antlr4::tree::TerminalNode *INDEX();\n-    TableIndexDfntContext *tableIndexDfnt();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  TableElementExprContext* tableElementExpr();\n-\n-  class  TableColumnDfntContext : public antlr4::ParserRuleContext {\n-  public:\n-    TableColumnDfntContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    NestedIdentifierContext *nestedIdentifier();\n-    ColumnTypeExprContext *columnTypeExpr();\n-    TableColumnPropertyExprContext *tableColumnPropertyExpr();\n-    antlr4::tree::TerminalNode *COMMENT();\n-    antlr4::tree::TerminalNode *STRING_LITERAL();\n-    CodecExprContext *codecExpr();\n-    antlr4::tree::TerminalNode *TTL();\n-    ColumnExprContext *columnExpr();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  TableColumnDfntContext* tableColumnDfnt();\n-\n-  class  TableColumnPropertyExprContext : public antlr4::ParserRuleContext {\n-  public:\n-    TableColumnPropertyExprContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    ColumnExprContext *columnExpr();\n-    antlr4::tree::TerminalNode *DEFAULT();\n-    antlr4::tree::TerminalNode *MATERIALIZED();\n-    antlr4::tree::TerminalNode *ALIAS();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  TableColumnPropertyExprContext* tableColumnPropertyExpr();\n-\n-  class  TableIndexDfntContext : public antlr4::ParserRuleContext {\n-  public:\n-    TableIndexDfntContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    NestedIdentifierContext *nestedIdentifier();\n-    ColumnExprContext *columnExpr();\n-    antlr4::tree::TerminalNode *TYPE();\n-    ColumnTypeExprContext *columnTypeExpr();\n-    antlr4::tree::TerminalNode *GRANULARITY();\n-    antlr4::tree::TerminalNode *DECIMAL_LITERAL();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  TableIndexDfntContext* tableIndexDfnt();\n-\n-  class  TableProjectionDfntContext : public antlr4::ParserRuleContext {\n-  public:\n-    TableProjectionDfntContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    NestedIdentifierContext *nestedIdentifier();\n-    ProjectionSelectStmtContext *projectionSelectStmt();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  TableProjectionDfntContext* tableProjectionDfnt();\n-\n-  class  CodecExprContext : public antlr4::ParserRuleContext {\n-  public:\n-    CodecExprContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *CODEC();\n-    antlr4::tree::TerminalNode *LPAREN();\n-    std::vector<CodecArgExprContext *> codecArgExpr();\n-    CodecArgExprContext* codecArgExpr(size_t i);\n-    antlr4::tree::TerminalNode *RPAREN();\n-    std::vector<antlr4::tree::TerminalNode *> COMMA();\n-    antlr4::tree::TerminalNode* COMMA(size_t i);\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  CodecExprContext* codecExpr();\n-\n-  class  CodecArgExprContext : public antlr4::ParserRuleContext {\n-  public:\n-    CodecArgExprContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    IdentifierContext *identifier();\n-    antlr4::tree::TerminalNode *LPAREN();\n-    antlr4::tree::TerminalNode *RPAREN();\n-    ColumnExprListContext *columnExprList();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  CodecArgExprContext* codecArgExpr();\n-\n-  class  TtlExprContext : public antlr4::ParserRuleContext {\n-  public:\n-    TtlExprContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    ColumnExprContext *columnExpr();\n-    antlr4::tree::TerminalNode *DELETE();\n-    antlr4::tree::TerminalNode *TO();\n-    antlr4::tree::TerminalNode *DISK();\n-    antlr4::tree::TerminalNode *STRING_LITERAL();\n-    antlr4::tree::TerminalNode *VOLUME();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  TtlExprContext* ttlExpr();\n-\n-  class  DescribeStmtContext : public antlr4::ParserRuleContext {\n-  public:\n-    DescribeStmtContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    TableExprContext *tableExpr();\n-    antlr4::tree::TerminalNode *DESCRIBE();\n-    antlr4::tree::TerminalNode *DESC();\n-    antlr4::tree::TerminalNode *TABLE();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  DescribeStmtContext* describeStmt();\n-\n-  class  DropStmtContext : public antlr4::ParserRuleContext {\n-  public:\n-    DropStmtContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-   \n-    DropStmtContext() = default;\n-    void copyFrom(DropStmtContext *context);\n-    using antlr4::ParserRuleContext::copyFrom;\n-\n-    virtual size_t getRuleIndex() const override;\n-\n-   \n-  };\n-\n-  class  DropDatabaseStmtContext : public DropStmtContext {\n-  public:\n-    DropDatabaseStmtContext(DropStmtContext *ctx);\n-\n-    antlr4::tree::TerminalNode *DATABASE();\n-    DatabaseIdentifierContext *databaseIdentifier();\n-    antlr4::tree::TerminalNode *DETACH();\n-    antlr4::tree::TerminalNode *DROP();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    ClusterClauseContext *clusterClause();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  DropTableStmtContext : public DropStmtContext {\n-  public:\n-    DropTableStmtContext(DropStmtContext *ctx);\n-\n-    TableIdentifierContext *tableIdentifier();\n-    antlr4::tree::TerminalNode *DETACH();\n-    antlr4::tree::TerminalNode *DROP();\n-    antlr4::tree::TerminalNode *DICTIONARY();\n-    antlr4::tree::TerminalNode *TABLE();\n-    antlr4::tree::TerminalNode *VIEW();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    ClusterClauseContext *clusterClause();\n-    antlr4::tree::TerminalNode *NO();\n-    antlr4::tree::TerminalNode *DELAY();\n-    antlr4::tree::TerminalNode *TEMPORARY();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  DropStmtContext* dropStmt();\n-\n-  class  ExistsStmtContext : public antlr4::ParserRuleContext {\n-  public:\n-    ExistsStmtContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-   \n-    ExistsStmtContext() = default;\n-    void copyFrom(ExistsStmtContext *context);\n-    using antlr4::ParserRuleContext::copyFrom;\n-\n-    virtual size_t getRuleIndex() const override;\n-\n-   \n-  };\n-\n-  class  ExistsTableStmtContext : public ExistsStmtContext {\n-  public:\n-    ExistsTableStmtContext(ExistsStmtContext *ctx);\n-\n-    antlr4::tree::TerminalNode *EXISTS();\n-    TableIdentifierContext *tableIdentifier();\n-    antlr4::tree::TerminalNode *DICTIONARY();\n-    antlr4::tree::TerminalNode *TABLE();\n-    antlr4::tree::TerminalNode *VIEW();\n-    antlr4::tree::TerminalNode *TEMPORARY();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ExistsDatabaseStmtContext : public ExistsStmtContext {\n-  public:\n-    ExistsDatabaseStmtContext(ExistsStmtContext *ctx);\n-\n-    antlr4::tree::TerminalNode *EXISTS();\n-    antlr4::tree::TerminalNode *DATABASE();\n-    DatabaseIdentifierContext *databaseIdentifier();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  ExistsStmtContext* existsStmt();\n-\n-  class  ExplainStmtContext : public antlr4::ParserRuleContext {\n-  public:\n-    ExplainStmtContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-   \n-    ExplainStmtContext() = default;\n-    void copyFrom(ExplainStmtContext *context);\n-    using antlr4::ParserRuleContext::copyFrom;\n-\n-    virtual size_t getRuleIndex() const override;\n-\n-   \n-  };\n-\n-  class  ExplainSyntaxStmtContext : public ExplainStmtContext {\n-  public:\n-    ExplainSyntaxStmtContext(ExplainStmtContext *ctx);\n-\n-    antlr4::tree::TerminalNode *EXPLAIN();\n-    antlr4::tree::TerminalNode *SYNTAX();\n-    QueryContext *query();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ExplainASTStmtContext : public ExplainStmtContext {\n-  public:\n-    ExplainASTStmtContext(ExplainStmtContext *ctx);\n-\n-    antlr4::tree::TerminalNode *EXPLAIN();\n-    antlr4::tree::TerminalNode *AST();\n-    QueryContext *query();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  ExplainStmtContext* explainStmt();\n-\n-  class  InsertStmtContext : public antlr4::ParserRuleContext {\n-  public:\n-    InsertStmtContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *INSERT();\n-    antlr4::tree::TerminalNode *INTO();\n-    DataClauseContext *dataClause();\n-    TableIdentifierContext *tableIdentifier();\n-    antlr4::tree::TerminalNode *FUNCTION();\n-    TableFunctionExprContext *tableFunctionExpr();\n-    antlr4::tree::TerminalNode *TABLE();\n-    ColumnsClauseContext *columnsClause();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  InsertStmtContext* insertStmt();\n-\n-  class  ColumnsClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    ColumnsClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *LPAREN();\n-    std::vector<NestedIdentifierContext *> nestedIdentifier();\n-    NestedIdentifierContext* nestedIdentifier(size_t i);\n-    antlr4::tree::TerminalNode *RPAREN();\n-    std::vector<antlr4::tree::TerminalNode *> COMMA();\n-    antlr4::tree::TerminalNode* COMMA(size_t i);\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  ColumnsClauseContext* columnsClause();\n-\n-  class  DataClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    DataClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-   \n-    DataClauseContext() = default;\n-    void copyFrom(DataClauseContext *context);\n-    using antlr4::ParserRuleContext::copyFrom;\n-\n-    virtual size_t getRuleIndex() const override;\n-\n-   \n-  };\n-\n-  class  DataClauseValuesContext : public DataClauseContext {\n-  public:\n-    DataClauseValuesContext(DataClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *VALUES();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  DataClauseFormatContext : public DataClauseContext {\n-  public:\n-    DataClauseFormatContext(DataClauseContext *ctx);\n-\n-    antlr4::tree::TerminalNode *FORMAT();\n-    IdentifierContext *identifier();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  DataClauseSelectContext : public DataClauseContext {\n-  public:\n-    DataClauseSelectContext(DataClauseContext *ctx);\n-\n-    SelectUnionStmtContext *selectUnionStmt();\n-    antlr4::tree::TerminalNode *EOF();\n-    antlr4::tree::TerminalNode *SEMICOLON();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  DataClauseContext* dataClause();\n-\n-  class  KillStmtContext : public antlr4::ParserRuleContext {\n-  public:\n-    KillStmtContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-   \n-    KillStmtContext() = default;\n-    void copyFrom(KillStmtContext *context);\n-    using antlr4::ParserRuleContext::copyFrom;\n-\n-    virtual size_t getRuleIndex() const override;\n-\n-   \n-  };\n-\n-  class  KillMutationStmtContext : public KillStmtContext {\n-  public:\n-    KillMutationStmtContext(KillStmtContext *ctx);\n-\n-    antlr4::tree::TerminalNode *KILL();\n-    antlr4::tree::TerminalNode *MUTATION();\n-    WhereClauseContext *whereClause();\n-    ClusterClauseContext *clusterClause();\n-    antlr4::tree::TerminalNode *SYNC();\n-    antlr4::tree::TerminalNode *ASYNC();\n-    antlr4::tree::TerminalNode *TEST();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  KillStmtContext* killStmt();\n-\n-  class  OptimizeStmtContext : public antlr4::ParserRuleContext {\n-  public:\n-    OptimizeStmtContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *OPTIMIZE();\n-    antlr4::tree::TerminalNode *TABLE();\n-    TableIdentifierContext *tableIdentifier();\n-    ClusterClauseContext *clusterClause();\n-    PartitionClauseContext *partitionClause();\n-    antlr4::tree::TerminalNode *FINAL();\n-    antlr4::tree::TerminalNode *DEDUPLICATE();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  OptimizeStmtContext* optimizeStmt();\n-\n-  class  RenameStmtContext : public antlr4::ParserRuleContext {\n-  public:\n-    RenameStmtContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *RENAME();\n-    antlr4::tree::TerminalNode *TABLE();\n-    std::vector<TableIdentifierContext *> tableIdentifier();\n-    TableIdentifierContext* tableIdentifier(size_t i);\n-    std::vector<antlr4::tree::TerminalNode *> TO();\n-    antlr4::tree::TerminalNode* TO(size_t i);\n-    std::vector<antlr4::tree::TerminalNode *> COMMA();\n-    antlr4::tree::TerminalNode* COMMA(size_t i);\n-    ClusterClauseContext *clusterClause();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  RenameStmtContext* renameStmt();\n-\n-  class  ProjectionSelectStmtContext : public antlr4::ParserRuleContext {\n-  public:\n-    ProjectionSelectStmtContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *LPAREN();\n-    antlr4::tree::TerminalNode *SELECT();\n-    ColumnExprListContext *columnExprList();\n-    antlr4::tree::TerminalNode *RPAREN();\n-    WithClauseContext *withClause();\n-    GroupByClauseContext *groupByClause();\n-    ProjectionOrderByClauseContext *projectionOrderByClause();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  ProjectionSelectStmtContext* projectionSelectStmt();\n-\n-  class  SelectUnionStmtContext : public antlr4::ParserRuleContext {\n-  public:\n-    SelectUnionStmtContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    std::vector<SelectStmtWithParensContext *> selectStmtWithParens();\n-    SelectStmtWithParensContext* selectStmtWithParens(size_t i);\n-    std::vector<antlr4::tree::TerminalNode *> UNION();\n-    antlr4::tree::TerminalNode* UNION(size_t i);\n-    std::vector<antlr4::tree::TerminalNode *> ALL();\n-    antlr4::tree::TerminalNode* ALL(size_t i);\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  SelectUnionStmtContext* selectUnionStmt();\n-\n-  class  SelectStmtWithParensContext : public antlr4::ParserRuleContext {\n-  public:\n-    SelectStmtWithParensContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    SelectStmtContext *selectStmt();\n-    antlr4::tree::TerminalNode *LPAREN();\n-    SelectUnionStmtContext *selectUnionStmt();\n-    antlr4::tree::TerminalNode *RPAREN();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  SelectStmtWithParensContext* selectStmtWithParens();\n-\n-  class  SelectStmtContext : public antlr4::ParserRuleContext {\n-  public:\n-    SelectStmtContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *SELECT();\n-    ColumnExprListContext *columnExprList();\n-    WithClauseContext *withClause();\n-    antlr4::tree::TerminalNode *DISTINCT();\n-    TopClauseContext *topClause();\n-    FromClauseContext *fromClause();\n-    ArrayJoinClauseContext *arrayJoinClause();\n-    PrewhereClauseContext *prewhereClause();\n-    WhereClauseContext *whereClause();\n-    GroupByClauseContext *groupByClause();\n-    std::vector<antlr4::tree::TerminalNode *> WITH();\n-    antlr4::tree::TerminalNode* WITH(size_t i);\n-    antlr4::tree::TerminalNode *TOTALS();\n-    HavingClauseContext *havingClause();\n-    OrderByClauseContext *orderByClause();\n-    LimitByClauseContext *limitByClause();\n-    LimitClauseContext *limitClause();\n-    SettingsClauseContext *settingsClause();\n-    antlr4::tree::TerminalNode *CUBE();\n-    antlr4::tree::TerminalNode *ROLLUP();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  SelectStmtContext* selectStmt();\n-\n-  class  WithClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    WithClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *WITH();\n-    ColumnExprListContext *columnExprList();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  WithClauseContext* withClause();\n-\n-  class  TopClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    TopClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *TOP();\n-    antlr4::tree::TerminalNode *DECIMAL_LITERAL();\n-    antlr4::tree::TerminalNode *WITH();\n-    antlr4::tree::TerminalNode *TIES();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  TopClauseContext* topClause();\n-\n-  class  FromClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    FromClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *FROM();\n-    JoinExprContext *joinExpr();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  FromClauseContext* fromClause();\n-\n-  class  ArrayJoinClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    ArrayJoinClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *ARRAY();\n-    antlr4::tree::TerminalNode *JOIN();\n-    ColumnExprListContext *columnExprList();\n-    antlr4::tree::TerminalNode *LEFT();\n-    antlr4::tree::TerminalNode *INNER();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  ArrayJoinClauseContext* arrayJoinClause();\n-\n-  class  PrewhereClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    PrewhereClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *PREWHERE();\n-    ColumnExprContext *columnExpr();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  PrewhereClauseContext* prewhereClause();\n-\n-  class  WhereClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    WhereClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *WHERE();\n-    ColumnExprContext *columnExpr();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  WhereClauseContext* whereClause();\n-\n-  class  GroupByClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    GroupByClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *GROUP();\n-    antlr4::tree::TerminalNode *BY();\n-    antlr4::tree::TerminalNode *LPAREN();\n-    ColumnExprListContext *columnExprList();\n-    antlr4::tree::TerminalNode *RPAREN();\n-    antlr4::tree::TerminalNode *CUBE();\n-    antlr4::tree::TerminalNode *ROLLUP();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  GroupByClauseContext* groupByClause();\n-\n-  class  HavingClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    HavingClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *HAVING();\n-    ColumnExprContext *columnExpr();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  HavingClauseContext* havingClause();\n-\n-  class  OrderByClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    OrderByClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *ORDER();\n-    antlr4::tree::TerminalNode *BY();\n-    OrderExprListContext *orderExprList();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  OrderByClauseContext* orderByClause();\n-\n-  class  ProjectionOrderByClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    ProjectionOrderByClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *ORDER();\n-    antlr4::tree::TerminalNode *BY();\n-    ColumnExprListContext *columnExprList();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  ProjectionOrderByClauseContext* projectionOrderByClause();\n-\n-  class  LimitByClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    LimitByClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *LIMIT();\n-    LimitExprContext *limitExpr();\n-    antlr4::tree::TerminalNode *BY();\n-    ColumnExprListContext *columnExprList();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  LimitByClauseContext* limitByClause();\n-\n-  class  LimitClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    LimitClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *LIMIT();\n-    LimitExprContext *limitExpr();\n-    antlr4::tree::TerminalNode *WITH();\n-    antlr4::tree::TerminalNode *TIES();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  LimitClauseContext* limitClause();\n-\n-  class  SettingsClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    SettingsClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *SETTINGS();\n-    SettingExprListContext *settingExprList();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  SettingsClauseContext* settingsClause();\n-\n-  class  JoinExprContext : public antlr4::ParserRuleContext {\n-  public:\n-    JoinExprContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-   \n-    JoinExprContext() = default;\n-    void copyFrom(JoinExprContext *context);\n-    using antlr4::ParserRuleContext::copyFrom;\n-\n-    virtual size_t getRuleIndex() const override;\n-\n-   \n-  };\n-\n-  class  JoinExprOpContext : public JoinExprContext {\n-  public:\n-    JoinExprOpContext(JoinExprContext *ctx);\n-\n-    std::vector<JoinExprContext *> joinExpr();\n-    JoinExprContext* joinExpr(size_t i);\n-    antlr4::tree::TerminalNode *JOIN();\n-    JoinConstraintClauseContext *joinConstraintClause();\n-    JoinOpContext *joinOp();\n-    antlr4::tree::TerminalNode *GLOBAL();\n-    antlr4::tree::TerminalNode *LOCAL();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  JoinExprTableContext : public JoinExprContext {\n-  public:\n-    JoinExprTableContext(JoinExprContext *ctx);\n-\n-    TableExprContext *tableExpr();\n-    antlr4::tree::TerminalNode *FINAL();\n-    SampleClauseContext *sampleClause();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  JoinExprParensContext : public JoinExprContext {\n-  public:\n-    JoinExprParensContext(JoinExprContext *ctx);\n-\n-    antlr4::tree::TerminalNode *LPAREN();\n-    JoinExprContext *joinExpr();\n-    antlr4::tree::TerminalNode *RPAREN();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  JoinExprCrossOpContext : public JoinExprContext {\n-  public:\n-    JoinExprCrossOpContext(JoinExprContext *ctx);\n-\n-    std::vector<JoinExprContext *> joinExpr();\n-    JoinExprContext* joinExpr(size_t i);\n-    JoinOpCrossContext *joinOpCross();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  JoinExprContext* joinExpr();\n-  JoinExprContext* joinExpr(int precedence);\n-  class  JoinOpContext : public antlr4::ParserRuleContext {\n-  public:\n-    JoinOpContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-   \n-    JoinOpContext() = default;\n-    void copyFrom(JoinOpContext *context);\n-    using antlr4::ParserRuleContext::copyFrom;\n-\n-    virtual size_t getRuleIndex() const override;\n-\n-   \n-  };\n-\n-  class  JoinOpFullContext : public JoinOpContext {\n-  public:\n-    JoinOpFullContext(JoinOpContext *ctx);\n-\n-    antlr4::tree::TerminalNode *FULL();\n-    antlr4::tree::TerminalNode *OUTER();\n-    antlr4::tree::TerminalNode *ALL();\n-    antlr4::tree::TerminalNode *ANY();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  JoinOpInnerContext : public JoinOpContext {\n-  public:\n-    JoinOpInnerContext(JoinOpContext *ctx);\n-\n-    antlr4::tree::TerminalNode *INNER();\n-    antlr4::tree::TerminalNode *ALL();\n-    antlr4::tree::TerminalNode *ANY();\n-    antlr4::tree::TerminalNode *ASOF();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  JoinOpLeftRightContext : public JoinOpContext {\n-  public:\n-    JoinOpLeftRightContext(JoinOpContext *ctx);\n-\n-    antlr4::tree::TerminalNode *LEFT();\n-    antlr4::tree::TerminalNode *RIGHT();\n-    antlr4::tree::TerminalNode *OUTER();\n-    antlr4::tree::TerminalNode *SEMI();\n-    antlr4::tree::TerminalNode *ALL();\n-    antlr4::tree::TerminalNode *ANTI();\n-    antlr4::tree::TerminalNode *ANY();\n-    antlr4::tree::TerminalNode *ASOF();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  JoinOpContext* joinOp();\n-\n-  class  JoinOpCrossContext : public antlr4::ParserRuleContext {\n-  public:\n-    JoinOpCrossContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *CROSS();\n-    antlr4::tree::TerminalNode *JOIN();\n-    antlr4::tree::TerminalNode *GLOBAL();\n-    antlr4::tree::TerminalNode *LOCAL();\n-    antlr4::tree::TerminalNode *COMMA();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  JoinOpCrossContext* joinOpCross();\n-\n-  class  JoinConstraintClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    JoinConstraintClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *ON();\n-    ColumnExprListContext *columnExprList();\n-    antlr4::tree::TerminalNode *USING();\n-    antlr4::tree::TerminalNode *LPAREN();\n-    antlr4::tree::TerminalNode *RPAREN();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  JoinConstraintClauseContext* joinConstraintClause();\n-\n-  class  SampleClauseContext : public antlr4::ParserRuleContext {\n-  public:\n-    SampleClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *SAMPLE();\n-    std::vector<RatioExprContext *> ratioExpr();\n-    RatioExprContext* ratioExpr(size_t i);\n-    antlr4::tree::TerminalNode *OFFSET();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  SampleClauseContext* sampleClause();\n-\n-  class  LimitExprContext : public antlr4::ParserRuleContext {\n-  public:\n-    LimitExprContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    std::vector<ColumnExprContext *> columnExpr();\n-    ColumnExprContext* columnExpr(size_t i);\n-    antlr4::tree::TerminalNode *COMMA();\n-    antlr4::tree::TerminalNode *OFFSET();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  LimitExprContext* limitExpr();\n-\n-  class  OrderExprListContext : public antlr4::ParserRuleContext {\n-  public:\n-    OrderExprListContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    std::vector<OrderExprContext *> orderExpr();\n-    OrderExprContext* orderExpr(size_t i);\n-    std::vector<antlr4::tree::TerminalNode *> COMMA();\n-    antlr4::tree::TerminalNode* COMMA(size_t i);\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  OrderExprListContext* orderExprList();\n-\n-  class  OrderExprContext : public antlr4::ParserRuleContext {\n-  public:\n-    OrderExprContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    ColumnExprContext *columnExpr();\n-    antlr4::tree::TerminalNode *NULLS();\n-    antlr4::tree::TerminalNode *COLLATE();\n-    antlr4::tree::TerminalNode *STRING_LITERAL();\n-    antlr4::tree::TerminalNode *ASCENDING();\n-    antlr4::tree::TerminalNode *DESCENDING();\n-    antlr4::tree::TerminalNode *DESC();\n-    antlr4::tree::TerminalNode *FIRST();\n-    antlr4::tree::TerminalNode *LAST();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  OrderExprContext* orderExpr();\n-\n-  class  RatioExprContext : public antlr4::ParserRuleContext {\n-  public:\n-    RatioExprContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    std::vector<NumberLiteralContext *> numberLiteral();\n-    NumberLiteralContext* numberLiteral(size_t i);\n-    antlr4::tree::TerminalNode *SLASH();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  RatioExprContext* ratioExpr();\n-\n-  class  SettingExprListContext : public antlr4::ParserRuleContext {\n-  public:\n-    SettingExprListContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    std::vector<SettingExprContext *> settingExpr();\n-    SettingExprContext* settingExpr(size_t i);\n-    std::vector<antlr4::tree::TerminalNode *> COMMA();\n-    antlr4::tree::TerminalNode* COMMA(size_t i);\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  SettingExprListContext* settingExprList();\n-\n-  class  SettingExprContext : public antlr4::ParserRuleContext {\n-  public:\n-    SettingExprContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    IdentifierContext *identifier();\n-    antlr4::tree::TerminalNode *EQ_SINGLE();\n-    LiteralContext *literal();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  SettingExprContext* settingExpr();\n-\n-  class  SetStmtContext : public antlr4::ParserRuleContext {\n-  public:\n-    SetStmtContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *SET();\n-    SettingExprListContext *settingExprList();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  SetStmtContext* setStmt();\n-\n-  class  ShowStmtContext : public antlr4::ParserRuleContext {\n-  public:\n-    ShowStmtContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-   \n-    ShowStmtContext() = default;\n-    void copyFrom(ShowStmtContext *context);\n-    using antlr4::ParserRuleContext::copyFrom;\n-\n-    virtual size_t getRuleIndex() const override;\n-\n-   \n-  };\n-\n-  class  ShowCreateDatabaseStmtContext : public ShowStmtContext {\n-  public:\n-    ShowCreateDatabaseStmtContext(ShowStmtContext *ctx);\n-\n-    antlr4::tree::TerminalNode *SHOW();\n-    antlr4::tree::TerminalNode *CREATE();\n-    antlr4::tree::TerminalNode *DATABASE();\n-    DatabaseIdentifierContext *databaseIdentifier();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ShowDatabasesStmtContext : public ShowStmtContext {\n-  public:\n-    ShowDatabasesStmtContext(ShowStmtContext *ctx);\n-\n-    antlr4::tree::TerminalNode *SHOW();\n-    antlr4::tree::TerminalNode *DATABASES();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ShowCreateTableStmtContext : public ShowStmtContext {\n-  public:\n-    ShowCreateTableStmtContext(ShowStmtContext *ctx);\n-\n-    antlr4::tree::TerminalNode *SHOW();\n-    antlr4::tree::TerminalNode *CREATE();\n-    TableIdentifierContext *tableIdentifier();\n-    antlr4::tree::TerminalNode *TEMPORARY();\n-    antlr4::tree::TerminalNode *TABLE();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ShowTablesStmtContext : public ShowStmtContext {\n-  public:\n-    ShowTablesStmtContext(ShowStmtContext *ctx);\n-\n-    antlr4::tree::TerminalNode *SHOW();\n-    antlr4::tree::TerminalNode *TABLES();\n-    antlr4::tree::TerminalNode *TEMPORARY();\n-    DatabaseIdentifierContext *databaseIdentifier();\n-    antlr4::tree::TerminalNode *LIKE();\n-    antlr4::tree::TerminalNode *STRING_LITERAL();\n-    WhereClauseContext *whereClause();\n-    LimitClauseContext *limitClause();\n-    antlr4::tree::TerminalNode *FROM();\n-    antlr4::tree::TerminalNode *IN();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ShowDictionariesStmtContext : public ShowStmtContext {\n-  public:\n-    ShowDictionariesStmtContext(ShowStmtContext *ctx);\n-\n-    antlr4::tree::TerminalNode *SHOW();\n-    antlr4::tree::TerminalNode *DICTIONARIES();\n-    antlr4::tree::TerminalNode *FROM();\n-    DatabaseIdentifierContext *databaseIdentifier();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ShowCreateDictionaryStmtContext : public ShowStmtContext {\n-  public:\n-    ShowCreateDictionaryStmtContext(ShowStmtContext *ctx);\n-\n-    antlr4::tree::TerminalNode *SHOW();\n-    antlr4::tree::TerminalNode *CREATE();\n-    antlr4::tree::TerminalNode *DICTIONARY();\n-    TableIdentifierContext *tableIdentifier();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  ShowStmtContext* showStmt();\n-\n-  class  SystemStmtContext : public antlr4::ParserRuleContext {\n-  public:\n-    SystemStmtContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *SYSTEM();\n-    antlr4::tree::TerminalNode *FLUSH();\n-    antlr4::tree::TerminalNode *DISTRIBUTED();\n-    TableIdentifierContext *tableIdentifier();\n-    antlr4::tree::TerminalNode *LOGS();\n-    antlr4::tree::TerminalNode *RELOAD();\n-    antlr4::tree::TerminalNode *DICTIONARIES();\n-    antlr4::tree::TerminalNode *DICTIONARY();\n-    antlr4::tree::TerminalNode *START();\n-    antlr4::tree::TerminalNode *STOP();\n-    antlr4::tree::TerminalNode *SENDS();\n-    antlr4::tree::TerminalNode *FETCHES();\n-    antlr4::tree::TerminalNode *MERGES();\n-    antlr4::tree::TerminalNode *TTL();\n-    antlr4::tree::TerminalNode *REPLICATED();\n-    antlr4::tree::TerminalNode *SYNC();\n-    antlr4::tree::TerminalNode *REPLICA();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  SystemStmtContext* systemStmt();\n-\n-  class  TruncateStmtContext : public antlr4::ParserRuleContext {\n-  public:\n-    TruncateStmtContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *TRUNCATE();\n-    TableIdentifierContext *tableIdentifier();\n-    antlr4::tree::TerminalNode *TEMPORARY();\n-    antlr4::tree::TerminalNode *TABLE();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    ClusterClauseContext *clusterClause();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  TruncateStmtContext* truncateStmt();\n-\n-  class  UseStmtContext : public antlr4::ParserRuleContext {\n-  public:\n-    UseStmtContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *USE();\n-    DatabaseIdentifierContext *databaseIdentifier();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  UseStmtContext* useStmt();\n-\n-  class  WatchStmtContext : public antlr4::ParserRuleContext {\n-  public:\n-    WatchStmtContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *WATCH();\n-    TableIdentifierContext *tableIdentifier();\n-    antlr4::tree::TerminalNode *EVENTS();\n-    antlr4::tree::TerminalNode *LIMIT();\n-    antlr4::tree::TerminalNode *DECIMAL_LITERAL();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  WatchStmtContext* watchStmt();\n-\n-  class  ColumnTypeExprContext : public antlr4::ParserRuleContext {\n-  public:\n-    ColumnTypeExprContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-   \n-    ColumnTypeExprContext() = default;\n-    void copyFrom(ColumnTypeExprContext *context);\n-    using antlr4::ParserRuleContext::copyFrom;\n-\n-    virtual size_t getRuleIndex() const override;\n-\n-   \n-  };\n-\n-  class  ColumnTypeExprNestedContext : public ColumnTypeExprContext {\n-  public:\n-    ColumnTypeExprNestedContext(ColumnTypeExprContext *ctx);\n-\n-    std::vector<IdentifierContext *> identifier();\n-    IdentifierContext* identifier(size_t i);\n-    antlr4::tree::TerminalNode *LPAREN();\n-    std::vector<ColumnTypeExprContext *> columnTypeExpr();\n-    ColumnTypeExprContext* columnTypeExpr(size_t i);\n-    antlr4::tree::TerminalNode *RPAREN();\n-    std::vector<antlr4::tree::TerminalNode *> COMMA();\n-    antlr4::tree::TerminalNode* COMMA(size_t i);\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnTypeExprParamContext : public ColumnTypeExprContext {\n-  public:\n-    ColumnTypeExprParamContext(ColumnTypeExprContext *ctx);\n-\n-    IdentifierContext *identifier();\n-    antlr4::tree::TerminalNode *LPAREN();\n-    antlr4::tree::TerminalNode *RPAREN();\n-    ColumnExprListContext *columnExprList();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnTypeExprSimpleContext : public ColumnTypeExprContext {\n-  public:\n-    ColumnTypeExprSimpleContext(ColumnTypeExprContext *ctx);\n-\n-    IdentifierContext *identifier();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnTypeExprComplexContext : public ColumnTypeExprContext {\n-  public:\n-    ColumnTypeExprComplexContext(ColumnTypeExprContext *ctx);\n-\n-    IdentifierContext *identifier();\n-    antlr4::tree::TerminalNode *LPAREN();\n-    std::vector<ColumnTypeExprContext *> columnTypeExpr();\n-    ColumnTypeExprContext* columnTypeExpr(size_t i);\n-    antlr4::tree::TerminalNode *RPAREN();\n-    std::vector<antlr4::tree::TerminalNode *> COMMA();\n-    antlr4::tree::TerminalNode* COMMA(size_t i);\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnTypeExprEnumContext : public ColumnTypeExprContext {\n-  public:\n-    ColumnTypeExprEnumContext(ColumnTypeExprContext *ctx);\n-\n-    IdentifierContext *identifier();\n-    antlr4::tree::TerminalNode *LPAREN();\n-    std::vector<EnumValueContext *> enumValue();\n-    EnumValueContext* enumValue(size_t i);\n-    antlr4::tree::TerminalNode *RPAREN();\n-    std::vector<antlr4::tree::TerminalNode *> COMMA();\n-    antlr4::tree::TerminalNode* COMMA(size_t i);\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  ColumnTypeExprContext* columnTypeExpr();\n-\n-  class  ColumnExprListContext : public antlr4::ParserRuleContext {\n-  public:\n-    ColumnExprListContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    std::vector<ColumnsExprContext *> columnsExpr();\n-    ColumnsExprContext* columnsExpr(size_t i);\n-    std::vector<antlr4::tree::TerminalNode *> COMMA();\n-    antlr4::tree::TerminalNode* COMMA(size_t i);\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  ColumnExprListContext* columnExprList();\n-\n-  class  ColumnsExprContext : public antlr4::ParserRuleContext {\n-  public:\n-    ColumnsExprContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-   \n-    ColumnsExprContext() = default;\n-    void copyFrom(ColumnsExprContext *context);\n-    using antlr4::ParserRuleContext::copyFrom;\n-\n-    virtual size_t getRuleIndex() const override;\n-\n-   \n-  };\n-\n-  class  ColumnsExprColumnContext : public ColumnsExprContext {\n-  public:\n-    ColumnsExprColumnContext(ColumnsExprContext *ctx);\n-\n-    ColumnExprContext *columnExpr();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnsExprAsteriskContext : public ColumnsExprContext {\n-  public:\n-    ColumnsExprAsteriskContext(ColumnsExprContext *ctx);\n-\n-    antlr4::tree::TerminalNode *ASTERISK();\n-    TableIdentifierContext *tableIdentifier();\n-    antlr4::tree::TerminalNode *DOT();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnsExprSubqueryContext : public ColumnsExprContext {\n-  public:\n-    ColumnsExprSubqueryContext(ColumnsExprContext *ctx);\n-\n-    antlr4::tree::TerminalNode *LPAREN();\n-    SelectUnionStmtContext *selectUnionStmt();\n-    antlr4::tree::TerminalNode *RPAREN();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  ColumnsExprContext* columnsExpr();\n-\n-  class  ColumnExprContext : public antlr4::ParserRuleContext {\n-  public:\n-    ColumnExprContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-   \n-    ColumnExprContext() = default;\n-    void copyFrom(ColumnExprContext *context);\n-    using antlr4::ParserRuleContext::copyFrom;\n-\n-    virtual size_t getRuleIndex() const override;\n-\n-   \n-  };\n-\n-  class  ColumnExprTernaryOpContext : public ColumnExprContext {\n-  public:\n-    ColumnExprTernaryOpContext(ColumnExprContext *ctx);\n-\n-    std::vector<ColumnExprContext *> columnExpr();\n-    ColumnExprContext* columnExpr(size_t i);\n-    antlr4::tree::TerminalNode *QUERY();\n-    antlr4::tree::TerminalNode *COLON();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprAliasContext : public ColumnExprContext {\n-  public:\n-    ColumnExprAliasContext(ColumnExprContext *ctx);\n-\n-    ColumnExprContext *columnExpr();\n-    AliasContext *alias();\n-    antlr4::tree::TerminalNode *AS();\n-    IdentifierContext *identifier();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprExtractContext : public ColumnExprContext {\n-  public:\n-    ColumnExprExtractContext(ColumnExprContext *ctx);\n-\n-    antlr4::tree::TerminalNode *EXTRACT();\n-    antlr4::tree::TerminalNode *LPAREN();\n-    IntervalContext *interval();\n-    antlr4::tree::TerminalNode *FROM();\n-    ColumnExprContext *columnExpr();\n-    antlr4::tree::TerminalNode *RPAREN();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprNegateContext : public ColumnExprContext {\n-  public:\n-    ColumnExprNegateContext(ColumnExprContext *ctx);\n-\n-    antlr4::tree::TerminalNode *DASH();\n-    ColumnExprContext *columnExpr();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprSubqueryContext : public ColumnExprContext {\n-  public:\n-    ColumnExprSubqueryContext(ColumnExprContext *ctx);\n-\n-    antlr4::tree::TerminalNode *LPAREN();\n-    SelectUnionStmtContext *selectUnionStmt();\n-    antlr4::tree::TerminalNode *RPAREN();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprLiteralContext : public ColumnExprContext {\n-  public:\n-    ColumnExprLiteralContext(ColumnExprContext *ctx);\n-\n-    LiteralContext *literal();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprArrayContext : public ColumnExprContext {\n-  public:\n-    ColumnExprArrayContext(ColumnExprContext *ctx);\n-\n-    antlr4::tree::TerminalNode *LBRACKET();\n-    antlr4::tree::TerminalNode *RBRACKET();\n-    ColumnExprListContext *columnExprList();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprSubstringContext : public ColumnExprContext {\n-  public:\n-    ColumnExprSubstringContext(ColumnExprContext *ctx);\n-\n-    antlr4::tree::TerminalNode *SUBSTRING();\n-    antlr4::tree::TerminalNode *LPAREN();\n-    std::vector<ColumnExprContext *> columnExpr();\n-    ColumnExprContext* columnExpr(size_t i);\n-    antlr4::tree::TerminalNode *FROM();\n-    antlr4::tree::TerminalNode *RPAREN();\n-    antlr4::tree::TerminalNode *FOR();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprCastContext : public ColumnExprContext {\n-  public:\n-    ColumnExprCastContext(ColumnExprContext *ctx);\n-\n-    antlr4::tree::TerminalNode *CAST();\n-    antlr4::tree::TerminalNode *LPAREN();\n-    ColumnExprContext *columnExpr();\n-    antlr4::tree::TerminalNode *AS();\n-    ColumnTypeExprContext *columnTypeExpr();\n-    antlr4::tree::TerminalNode *RPAREN();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprOrContext : public ColumnExprContext {\n-  public:\n-    ColumnExprOrContext(ColumnExprContext *ctx);\n-\n-    std::vector<ColumnExprContext *> columnExpr();\n-    ColumnExprContext* columnExpr(size_t i);\n-    antlr4::tree::TerminalNode *OR();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprPrecedence1Context : public ColumnExprContext {\n-  public:\n-    ColumnExprPrecedence1Context(ColumnExprContext *ctx);\n-\n-    std::vector<ColumnExprContext *> columnExpr();\n-    ColumnExprContext* columnExpr(size_t i);\n-    antlr4::tree::TerminalNode *ASTERISK();\n-    antlr4::tree::TerminalNode *SLASH();\n-    antlr4::tree::TerminalNode *PERCENT();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprPrecedence2Context : public ColumnExprContext {\n-  public:\n-    ColumnExprPrecedence2Context(ColumnExprContext *ctx);\n-\n-    std::vector<ColumnExprContext *> columnExpr();\n-    ColumnExprContext* columnExpr(size_t i);\n-    antlr4::tree::TerminalNode *PLUS();\n-    antlr4::tree::TerminalNode *DASH();\n-    antlr4::tree::TerminalNode *CONCAT();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprPrecedence3Context : public ColumnExprContext {\n-  public:\n-    ColumnExprPrecedence3Context(ColumnExprContext *ctx);\n-\n-    std::vector<ColumnExprContext *> columnExpr();\n-    ColumnExprContext* columnExpr(size_t i);\n-    antlr4::tree::TerminalNode *EQ_DOUBLE();\n-    antlr4::tree::TerminalNode *EQ_SINGLE();\n-    antlr4::tree::TerminalNode *NOT_EQ();\n-    antlr4::tree::TerminalNode *LE();\n-    antlr4::tree::TerminalNode *GE();\n-    antlr4::tree::TerminalNode *LT();\n-    antlr4::tree::TerminalNode *GT();\n-    antlr4::tree::TerminalNode *IN();\n-    antlr4::tree::TerminalNode *LIKE();\n-    antlr4::tree::TerminalNode *ILIKE();\n-    antlr4::tree::TerminalNode *GLOBAL();\n-    antlr4::tree::TerminalNode *NOT();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprIntervalContext : public ColumnExprContext {\n-  public:\n-    ColumnExprIntervalContext(ColumnExprContext *ctx);\n-\n-    antlr4::tree::TerminalNode *INTERVAL();\n-    ColumnExprContext *columnExpr();\n-    IntervalContext *interval();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprIsNullContext : public ColumnExprContext {\n-  public:\n-    ColumnExprIsNullContext(ColumnExprContext *ctx);\n-\n-    ColumnExprContext *columnExpr();\n-    antlr4::tree::TerminalNode *IS();\n-    antlr4::tree::TerminalNode *NULL_SQL();\n-    antlr4::tree::TerminalNode *NOT();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprTrimContext : public ColumnExprContext {\n-  public:\n-    ColumnExprTrimContext(ColumnExprContext *ctx);\n-\n-    antlr4::tree::TerminalNode *TRIM();\n-    antlr4::tree::TerminalNode *LPAREN();\n-    antlr4::tree::TerminalNode *STRING_LITERAL();\n-    antlr4::tree::TerminalNode *FROM();\n-    ColumnExprContext *columnExpr();\n-    antlr4::tree::TerminalNode *RPAREN();\n-    antlr4::tree::TerminalNode *BOTH();\n-    antlr4::tree::TerminalNode *LEADING();\n-    antlr4::tree::TerminalNode *TRAILING();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprTupleContext : public ColumnExprContext {\n-  public:\n-    ColumnExprTupleContext(ColumnExprContext *ctx);\n-\n-    antlr4::tree::TerminalNode *LPAREN();\n-    ColumnExprListContext *columnExprList();\n-    antlr4::tree::TerminalNode *RPAREN();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprArrayAccessContext : public ColumnExprContext {\n-  public:\n-    ColumnExprArrayAccessContext(ColumnExprContext *ctx);\n-\n-    std::vector<ColumnExprContext *> columnExpr();\n-    ColumnExprContext* columnExpr(size_t i);\n-    antlr4::tree::TerminalNode *LBRACKET();\n-    antlr4::tree::TerminalNode *RBRACKET();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprBetweenContext : public ColumnExprContext {\n-  public:\n-    ColumnExprBetweenContext(ColumnExprContext *ctx);\n-\n-    std::vector<ColumnExprContext *> columnExpr();\n-    ColumnExprContext* columnExpr(size_t i);\n-    antlr4::tree::TerminalNode *BETWEEN();\n-    antlr4::tree::TerminalNode *AND();\n-    antlr4::tree::TerminalNode *NOT();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprParensContext : public ColumnExprContext {\n-  public:\n-    ColumnExprParensContext(ColumnExprContext *ctx);\n-\n-    antlr4::tree::TerminalNode *LPAREN();\n-    ColumnExprContext *columnExpr();\n-    antlr4::tree::TerminalNode *RPAREN();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprTimestampContext : public ColumnExprContext {\n-  public:\n-    ColumnExprTimestampContext(ColumnExprContext *ctx);\n-\n-    antlr4::tree::TerminalNode *TIMESTAMP();\n-    antlr4::tree::TerminalNode *STRING_LITERAL();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprAndContext : public ColumnExprContext {\n-  public:\n-    ColumnExprAndContext(ColumnExprContext *ctx);\n-\n-    std::vector<ColumnExprContext *> columnExpr();\n-    ColumnExprContext* columnExpr(size_t i);\n-    antlr4::tree::TerminalNode *AND();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprTupleAccessContext : public ColumnExprContext {\n-  public:\n-    ColumnExprTupleAccessContext(ColumnExprContext *ctx);\n-\n-    ColumnExprContext *columnExpr();\n-    antlr4::tree::TerminalNode *DOT();\n-    antlr4::tree::TerminalNode *DECIMAL_LITERAL();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprCaseContext : public ColumnExprContext {\n-  public:\n-    ColumnExprCaseContext(ColumnExprContext *ctx);\n-\n-    antlr4::tree::TerminalNode *CASE();\n-    antlr4::tree::TerminalNode *END();\n-    std::vector<ColumnExprContext *> columnExpr();\n-    ColumnExprContext* columnExpr(size_t i);\n-    std::vector<antlr4::tree::TerminalNode *> WHEN();\n-    antlr4::tree::TerminalNode* WHEN(size_t i);\n-    std::vector<antlr4::tree::TerminalNode *> THEN();\n-    antlr4::tree::TerminalNode* THEN(size_t i);\n-    antlr4::tree::TerminalNode *ELSE();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprDateContext : public ColumnExprContext {\n-  public:\n-    ColumnExprDateContext(ColumnExprContext *ctx);\n-\n-    antlr4::tree::TerminalNode *DATE();\n-    antlr4::tree::TerminalNode *STRING_LITERAL();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprNotContext : public ColumnExprContext {\n-  public:\n-    ColumnExprNotContext(ColumnExprContext *ctx);\n-\n-    antlr4::tree::TerminalNode *NOT();\n-    ColumnExprContext *columnExpr();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprIdentifierContext : public ColumnExprContext {\n-  public:\n-    ColumnExprIdentifierContext(ColumnExprContext *ctx);\n-\n-    ColumnIdentifierContext *columnIdentifier();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprFunctionContext : public ColumnExprContext {\n-  public:\n-    ColumnExprFunctionContext(ColumnExprContext *ctx);\n-\n-    IdentifierContext *identifier();\n-    std::vector<antlr4::tree::TerminalNode *> LPAREN();\n-    antlr4::tree::TerminalNode* LPAREN(size_t i);\n-    std::vector<antlr4::tree::TerminalNode *> RPAREN();\n-    antlr4::tree::TerminalNode* RPAREN(size_t i);\n-    antlr4::tree::TerminalNode *DISTINCT();\n-    ColumnArgListContext *columnArgList();\n-    ColumnExprListContext *columnExprList();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  ColumnExprAsteriskContext : public ColumnExprContext {\n-  public:\n-    ColumnExprAsteriskContext(ColumnExprContext *ctx);\n-\n-    antlr4::tree::TerminalNode *ASTERISK();\n-    TableIdentifierContext *tableIdentifier();\n-    antlr4::tree::TerminalNode *DOT();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  ColumnExprContext* columnExpr();\n-  ColumnExprContext* columnExpr(int precedence);\n-  class  ColumnArgListContext : public antlr4::ParserRuleContext {\n-  public:\n-    ColumnArgListContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    std::vector<ColumnArgExprContext *> columnArgExpr();\n-    ColumnArgExprContext* columnArgExpr(size_t i);\n-    std::vector<antlr4::tree::TerminalNode *> COMMA();\n-    antlr4::tree::TerminalNode* COMMA(size_t i);\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  ColumnArgListContext* columnArgList();\n-\n-  class  ColumnArgExprContext : public antlr4::ParserRuleContext {\n-  public:\n-    ColumnArgExprContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    ColumnLambdaExprContext *columnLambdaExpr();\n-    ColumnExprContext *columnExpr();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  ColumnArgExprContext* columnArgExpr();\n-\n-  class  ColumnLambdaExprContext : public antlr4::ParserRuleContext {\n-  public:\n-    ColumnLambdaExprContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *ARROW();\n-    ColumnExprContext *columnExpr();\n-    antlr4::tree::TerminalNode *LPAREN();\n-    std::vector<IdentifierContext *> identifier();\n-    IdentifierContext* identifier(size_t i);\n-    antlr4::tree::TerminalNode *RPAREN();\n-    std::vector<antlr4::tree::TerminalNode *> COMMA();\n-    antlr4::tree::TerminalNode* COMMA(size_t i);\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  ColumnLambdaExprContext* columnLambdaExpr();\n-\n-  class  ColumnIdentifierContext : public antlr4::ParserRuleContext {\n-  public:\n-    ColumnIdentifierContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    NestedIdentifierContext *nestedIdentifier();\n-    TableIdentifierContext *tableIdentifier();\n-    antlr4::tree::TerminalNode *DOT();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  ColumnIdentifierContext* columnIdentifier();\n-\n-  class  NestedIdentifierContext : public antlr4::ParserRuleContext {\n-  public:\n-    NestedIdentifierContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    std::vector<IdentifierContext *> identifier();\n-    IdentifierContext* identifier(size_t i);\n-    antlr4::tree::TerminalNode *DOT();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  NestedIdentifierContext* nestedIdentifier();\n-\n-  class  TableExprContext : public antlr4::ParserRuleContext {\n-  public:\n-    TableExprContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-   \n-    TableExprContext() = default;\n-    void copyFrom(TableExprContext *context);\n-    using antlr4::ParserRuleContext::copyFrom;\n-\n-    virtual size_t getRuleIndex() const override;\n-\n-   \n-  };\n-\n-  class  TableExprIdentifierContext : public TableExprContext {\n-  public:\n-    TableExprIdentifierContext(TableExprContext *ctx);\n-\n-    TableIdentifierContext *tableIdentifier();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  TableExprSubqueryContext : public TableExprContext {\n-  public:\n-    TableExprSubqueryContext(TableExprContext *ctx);\n-\n-    antlr4::tree::TerminalNode *LPAREN();\n-    SelectUnionStmtContext *selectUnionStmt();\n-    antlr4::tree::TerminalNode *RPAREN();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  TableExprAliasContext : public TableExprContext {\n-  public:\n-    TableExprAliasContext(TableExprContext *ctx);\n-\n-    TableExprContext *tableExpr();\n-    AliasContext *alias();\n-    antlr4::tree::TerminalNode *AS();\n-    IdentifierContext *identifier();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  class  TableExprFunctionContext : public TableExprContext {\n-  public:\n-    TableExprFunctionContext(TableExprContext *ctx);\n-\n-    TableFunctionExprContext *tableFunctionExpr();\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-  };\n-\n-  TableExprContext* tableExpr();\n-  TableExprContext* tableExpr(int precedence);\n-  class  TableFunctionExprContext : public antlr4::ParserRuleContext {\n-  public:\n-    TableFunctionExprContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    IdentifierContext *identifier();\n-    antlr4::tree::TerminalNode *LPAREN();\n-    antlr4::tree::TerminalNode *RPAREN();\n-    TableArgListContext *tableArgList();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  TableFunctionExprContext* tableFunctionExpr();\n-\n-  class  TableIdentifierContext : public antlr4::ParserRuleContext {\n-  public:\n-    TableIdentifierContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    IdentifierContext *identifier();\n-    DatabaseIdentifierContext *databaseIdentifier();\n-    antlr4::tree::TerminalNode *DOT();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  TableIdentifierContext* tableIdentifier();\n-\n-  class  TableArgListContext : public antlr4::ParserRuleContext {\n-  public:\n-    TableArgListContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    std::vector<TableArgExprContext *> tableArgExpr();\n-    TableArgExprContext* tableArgExpr(size_t i);\n-    std::vector<antlr4::tree::TerminalNode *> COMMA();\n-    antlr4::tree::TerminalNode* COMMA(size_t i);\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  TableArgListContext* tableArgList();\n-\n-  class  TableArgExprContext : public antlr4::ParserRuleContext {\n-  public:\n-    TableArgExprContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    NestedIdentifierContext *nestedIdentifier();\n-    TableFunctionExprContext *tableFunctionExpr();\n-    LiteralContext *literal();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  TableArgExprContext* tableArgExpr();\n-\n-  class  DatabaseIdentifierContext : public antlr4::ParserRuleContext {\n-  public:\n-    DatabaseIdentifierContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    IdentifierContext *identifier();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  DatabaseIdentifierContext* databaseIdentifier();\n-\n-  class  FloatingLiteralContext : public antlr4::ParserRuleContext {\n-  public:\n-    FloatingLiteralContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *FLOATING_LITERAL();\n-    antlr4::tree::TerminalNode *DOT();\n-    std::vector<antlr4::tree::TerminalNode *> DECIMAL_LITERAL();\n-    antlr4::tree::TerminalNode* DECIMAL_LITERAL(size_t i);\n-    antlr4::tree::TerminalNode *OCTAL_LITERAL();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  FloatingLiteralContext* floatingLiteral();\n-\n-  class  NumberLiteralContext : public antlr4::ParserRuleContext {\n-  public:\n-    NumberLiteralContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    FloatingLiteralContext *floatingLiteral();\n-    antlr4::tree::TerminalNode *OCTAL_LITERAL();\n-    antlr4::tree::TerminalNode *DECIMAL_LITERAL();\n-    antlr4::tree::TerminalNode *HEXADECIMAL_LITERAL();\n-    antlr4::tree::TerminalNode *INF();\n-    antlr4::tree::TerminalNode *NAN_SQL();\n-    antlr4::tree::TerminalNode *PLUS();\n-    antlr4::tree::TerminalNode *DASH();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  NumberLiteralContext* numberLiteral();\n-\n-  class  LiteralContext : public antlr4::ParserRuleContext {\n-  public:\n-    LiteralContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    NumberLiteralContext *numberLiteral();\n-    antlr4::tree::TerminalNode *STRING_LITERAL();\n-    antlr4::tree::TerminalNode *NULL_SQL();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  LiteralContext* literal();\n-\n-  class  IntervalContext : public antlr4::ParserRuleContext {\n-  public:\n-    IntervalContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *SECOND();\n-    antlr4::tree::TerminalNode *MINUTE();\n-    antlr4::tree::TerminalNode *HOUR();\n-    antlr4::tree::TerminalNode *DAY();\n-    antlr4::tree::TerminalNode *WEEK();\n-    antlr4::tree::TerminalNode *MONTH();\n-    antlr4::tree::TerminalNode *QUARTER();\n-    antlr4::tree::TerminalNode *YEAR();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  IntervalContext* interval();\n-\n-  class  KeywordContext : public antlr4::ParserRuleContext {\n-  public:\n-    KeywordContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *AFTER();\n-    antlr4::tree::TerminalNode *ALIAS();\n-    antlr4::tree::TerminalNode *ALL();\n-    antlr4::tree::TerminalNode *ALTER();\n-    antlr4::tree::TerminalNode *AND();\n-    antlr4::tree::TerminalNode *ANTI();\n-    antlr4::tree::TerminalNode *ANY();\n-    antlr4::tree::TerminalNode *ARRAY();\n-    antlr4::tree::TerminalNode *AS();\n-    antlr4::tree::TerminalNode *ASCENDING();\n-    antlr4::tree::TerminalNode *ASOF();\n-    antlr4::tree::TerminalNode *AST();\n-    antlr4::tree::TerminalNode *ASYNC();\n-    antlr4::tree::TerminalNode *ATTACH();\n-    antlr4::tree::TerminalNode *BETWEEN();\n-    antlr4::tree::TerminalNode *BOTH();\n-    antlr4::tree::TerminalNode *BY();\n-    antlr4::tree::TerminalNode *CASE();\n-    antlr4::tree::TerminalNode *CAST();\n-    antlr4::tree::TerminalNode *CHECK();\n-    antlr4::tree::TerminalNode *CLEAR();\n-    antlr4::tree::TerminalNode *CLUSTER();\n-    antlr4::tree::TerminalNode *CODEC();\n-    antlr4::tree::TerminalNode *COLLATE();\n-    antlr4::tree::TerminalNode *COLUMN();\n-    antlr4::tree::TerminalNode *COMMENT();\n-    antlr4::tree::TerminalNode *CONSTRAINT();\n-    antlr4::tree::TerminalNode *CREATE();\n-    antlr4::tree::TerminalNode *CROSS();\n-    antlr4::tree::TerminalNode *CUBE();\n-    antlr4::tree::TerminalNode *DATABASE();\n-    antlr4::tree::TerminalNode *DATABASES();\n-    antlr4::tree::TerminalNode *DATE();\n-    antlr4::tree::TerminalNode *DEDUPLICATE();\n-    antlr4::tree::TerminalNode *DEFAULT();\n-    antlr4::tree::TerminalNode *DELAY();\n-    antlr4::tree::TerminalNode *DELETE();\n-    antlr4::tree::TerminalNode *DESCRIBE();\n-    antlr4::tree::TerminalNode *DESC();\n-    antlr4::tree::TerminalNode *DESCENDING();\n-    antlr4::tree::TerminalNode *DETACH();\n-    antlr4::tree::TerminalNode *DICTIONARIES();\n-    antlr4::tree::TerminalNode *DICTIONARY();\n-    antlr4::tree::TerminalNode *DISK();\n-    antlr4::tree::TerminalNode *DISTINCT();\n-    antlr4::tree::TerminalNode *DISTRIBUTED();\n-    antlr4::tree::TerminalNode *DROP();\n-    antlr4::tree::TerminalNode *ELSE();\n-    antlr4::tree::TerminalNode *END();\n-    antlr4::tree::TerminalNode *ENGINE();\n-    antlr4::tree::TerminalNode *EVENTS();\n-    antlr4::tree::TerminalNode *EXISTS();\n-    antlr4::tree::TerminalNode *EXPLAIN();\n-    antlr4::tree::TerminalNode *EXPRESSION();\n-    antlr4::tree::TerminalNode *EXTRACT();\n-    antlr4::tree::TerminalNode *FETCHES();\n-    antlr4::tree::TerminalNode *FINAL();\n-    antlr4::tree::TerminalNode *FIRST();\n-    antlr4::tree::TerminalNode *FLUSH();\n-    antlr4::tree::TerminalNode *FOR();\n-    antlr4::tree::TerminalNode *FORMAT();\n-    antlr4::tree::TerminalNode *FREEZE();\n-    antlr4::tree::TerminalNode *FROM();\n-    antlr4::tree::TerminalNode *FULL();\n-    antlr4::tree::TerminalNode *FUNCTION();\n-    antlr4::tree::TerminalNode *GLOBAL();\n-    antlr4::tree::TerminalNode *GRANULARITY();\n-    antlr4::tree::TerminalNode *GROUP();\n-    antlr4::tree::TerminalNode *HAVING();\n-    antlr4::tree::TerminalNode *HIERARCHICAL();\n-    antlr4::tree::TerminalNode *ID();\n-    antlr4::tree::TerminalNode *IF();\n-    antlr4::tree::TerminalNode *ILIKE();\n-    antlr4::tree::TerminalNode *IN();\n-    antlr4::tree::TerminalNode *INDEX();\n-    antlr4::tree::TerminalNode *INJECTIVE();\n-    antlr4::tree::TerminalNode *INNER();\n-    antlr4::tree::TerminalNode *INSERT();\n-    antlr4::tree::TerminalNode *INTERVAL();\n-    antlr4::tree::TerminalNode *INTO();\n-    antlr4::tree::TerminalNode *IS();\n-    antlr4::tree::TerminalNode *IS_OBJECT_ID();\n-    antlr4::tree::TerminalNode *JOIN();\n-    antlr4::tree::TerminalNode *JSON_FALSE();\n-    antlr4::tree::TerminalNode *JSON_TRUE();\n-    antlr4::tree::TerminalNode *KEY();\n-    antlr4::tree::TerminalNode *KILL();\n-    antlr4::tree::TerminalNode *LAST();\n-    antlr4::tree::TerminalNode *LAYOUT();\n-    antlr4::tree::TerminalNode *LEADING();\n-    antlr4::tree::TerminalNode *LEFT();\n-    antlr4::tree::TerminalNode *LIFETIME();\n-    antlr4::tree::TerminalNode *LIKE();\n-    antlr4::tree::TerminalNode *LIMIT();\n-    antlr4::tree::TerminalNode *LIVE();\n-    antlr4::tree::TerminalNode *LOCAL();\n-    antlr4::tree::TerminalNode *LOGS();\n-    antlr4::tree::TerminalNode *MATERIALIZE();\n-    antlr4::tree::TerminalNode *MATERIALIZED();\n-    antlr4::tree::TerminalNode *MAX();\n-    antlr4::tree::TerminalNode *MERGES();\n-    antlr4::tree::TerminalNode *MIN();\n-    antlr4::tree::TerminalNode *MODIFY();\n-    antlr4::tree::TerminalNode *MOVE();\n-    antlr4::tree::TerminalNode *MUTATION();\n-    antlr4::tree::TerminalNode *NO();\n-    antlr4::tree::TerminalNode *NOT();\n-    antlr4::tree::TerminalNode *NULLS();\n-    antlr4::tree::TerminalNode *OFFSET();\n-    antlr4::tree::TerminalNode *ON();\n-    antlr4::tree::TerminalNode *OPTIMIZE();\n-    antlr4::tree::TerminalNode *OR();\n-    antlr4::tree::TerminalNode *ORDER();\n-    antlr4::tree::TerminalNode *OUTER();\n-    antlr4::tree::TerminalNode *OUTFILE();\n-    antlr4::tree::TerminalNode *PARTITION();\n-    antlr4::tree::TerminalNode *POPULATE();\n-    antlr4::tree::TerminalNode *PREWHERE();\n-    antlr4::tree::TerminalNode *PRIMARY();\n-    antlr4::tree::TerminalNode *RANGE();\n-    antlr4::tree::TerminalNode *RELOAD();\n-    antlr4::tree::TerminalNode *REMOVE();\n-    antlr4::tree::TerminalNode *RENAME();\n-    antlr4::tree::TerminalNode *REPLACE();\n-    antlr4::tree::TerminalNode *REPLICA();\n-    antlr4::tree::TerminalNode *REPLICATED();\n-    antlr4::tree::TerminalNode *RIGHT();\n-    antlr4::tree::TerminalNode *ROLLUP();\n-    antlr4::tree::TerminalNode *SAMPLE();\n-    antlr4::tree::TerminalNode *SELECT();\n-    antlr4::tree::TerminalNode *SEMI();\n-    antlr4::tree::TerminalNode *SENDS();\n-    antlr4::tree::TerminalNode *SET();\n-    antlr4::tree::TerminalNode *SETTINGS();\n-    antlr4::tree::TerminalNode *SHOW();\n-    antlr4::tree::TerminalNode *SOURCE();\n-    antlr4::tree::TerminalNode *START();\n-    antlr4::tree::TerminalNode *STOP();\n-    antlr4::tree::TerminalNode *SUBSTRING();\n-    antlr4::tree::TerminalNode *SYNC();\n-    antlr4::tree::TerminalNode *SYNTAX();\n-    antlr4::tree::TerminalNode *SYSTEM();\n-    antlr4::tree::TerminalNode *TABLE();\n-    antlr4::tree::TerminalNode *TABLES();\n-    antlr4::tree::TerminalNode *TEMPORARY();\n-    antlr4::tree::TerminalNode *TEST();\n-    antlr4::tree::TerminalNode *THEN();\n-    antlr4::tree::TerminalNode *TIES();\n-    antlr4::tree::TerminalNode *TIMEOUT();\n-    antlr4::tree::TerminalNode *TIMESTAMP();\n-    antlr4::tree::TerminalNode *TOTALS();\n-    antlr4::tree::TerminalNode *TRAILING();\n-    antlr4::tree::TerminalNode *TRIM();\n-    antlr4::tree::TerminalNode *TRUNCATE();\n-    antlr4::tree::TerminalNode *TO();\n-    antlr4::tree::TerminalNode *TOP();\n-    antlr4::tree::TerminalNode *TTL();\n-    antlr4::tree::TerminalNode *TYPE();\n-    antlr4::tree::TerminalNode *UNION();\n-    antlr4::tree::TerminalNode *UPDATE();\n-    antlr4::tree::TerminalNode *USE();\n-    antlr4::tree::TerminalNode *USING();\n-    antlr4::tree::TerminalNode *UUID();\n-    antlr4::tree::TerminalNode *VALUES();\n-    antlr4::tree::TerminalNode *VIEW();\n-    antlr4::tree::TerminalNode *VOLUME();\n-    antlr4::tree::TerminalNode *WATCH();\n-    antlr4::tree::TerminalNode *WHEN();\n-    antlr4::tree::TerminalNode *WHERE();\n-    antlr4::tree::TerminalNode *WITH();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  KeywordContext* keyword();\n-\n-  class  KeywordForAliasContext : public antlr4::ParserRuleContext {\n-  public:\n-    KeywordForAliasContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *DATE();\n-    antlr4::tree::TerminalNode *FIRST();\n-    antlr4::tree::TerminalNode *ID();\n-    antlr4::tree::TerminalNode *KEY();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  KeywordForAliasContext* keywordForAlias();\n-\n-  class  AliasContext : public antlr4::ParserRuleContext {\n-  public:\n-    AliasContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *IDENTIFIER();\n-    KeywordForAliasContext *keywordForAlias();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  AliasContext* alias();\n-\n-  class  IdentifierContext : public antlr4::ParserRuleContext {\n-  public:\n-    IdentifierContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *IDENTIFIER();\n-    IntervalContext *interval();\n-    KeywordContext *keyword();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  IdentifierContext* identifier();\n-\n-  class  IdentifierOrNullContext : public antlr4::ParserRuleContext {\n-  public:\n-    IdentifierOrNullContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    IdentifierContext *identifier();\n-    antlr4::tree::TerminalNode *NULL_SQL();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  IdentifierOrNullContext* identifierOrNull();\n-\n-  class  EnumValueContext : public antlr4::ParserRuleContext {\n-  public:\n-    EnumValueContext(antlr4::ParserRuleContext *parent, size_t invokingState);\n-    virtual size_t getRuleIndex() const override;\n-    antlr4::tree::TerminalNode *STRING_LITERAL();\n-    antlr4::tree::TerminalNode *EQ_SINGLE();\n-    NumberLiteralContext *numberLiteral();\n-\n-    virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;\n-   \n-  };\n-\n-  EnumValueContext* enumValue();\n-\n-\n-  virtual bool sempred(antlr4::RuleContext *_localctx, size_t ruleIndex, size_t predicateIndex) override;\n-  bool dictionaryAttrDfntSempred(DictionaryAttrDfntContext *_localctx, size_t predicateIndex);\n-  bool dictionaryEngineClauseSempred(DictionaryEngineClauseContext *_localctx, size_t predicateIndex);\n-  bool engineClauseSempred(EngineClauseContext *_localctx, size_t predicateIndex);\n-  bool joinExprSempred(JoinExprContext *_localctx, size_t predicateIndex);\n-  bool columnExprSempred(ColumnExprContext *_localctx, size_t predicateIndex);\n-  bool tableExprSempred(TableExprContext *_localctx, size_t predicateIndex);\n-\n-private:\n-  static std::vector<antlr4::dfa::DFA> _decisionToDFA;\n-  static antlr4::atn::PredictionContextCache _sharedContextCache;\n-  static std::vector<std::string> _ruleNames;\n-  static std::vector<std::string> _tokenNames;\n-\n-  static std::vector<std::string> _literalNames;\n-  static std::vector<std::string> _symbolicNames;\n-  static antlr4::dfa::Vocabulary _vocabulary;\n-  static antlr4::atn::ATN _atn;\n-  static std::vector<uint16_t> _serializedATN;\n-\n-\n-  struct Initializer {\n-    Initializer();\n-  };\n-  static Initializer _init;\n-};\n-\n-}  // namespace DB\ndiff --git a/src/Parsers/New/ClickHouseParserVisitor.cpp b/src/Parsers/New/ClickHouseParserVisitor.cpp\ndeleted file mode 100644\nindex ad0990faef9e..000000000000\n--- a/src/Parsers/New/ClickHouseParserVisitor.cpp\n+++ /dev/null\n@@ -1,9 +0,0 @@\n-\n-// Generated from ClickHouseParser.g4 by ANTLR 4.7.2\n-\n-\n-#include \"ClickHouseParserVisitor.h\"\n-\n-\n-using namespace DB;\n-\ndiff --git a/src/Parsers/New/ClickHouseParserVisitor.h b/src/Parsers/New/ClickHouseParserVisitor.h\ndeleted file mode 100644\nindex 088fdd7f0cac..000000000000\n--- a/src/Parsers/New/ClickHouseParserVisitor.h\n+++ /dev/null\n@@ -1,422 +0,0 @@\n-\n-// Generated from ClickHouseParser.g4 by ANTLR 4.7.2\n-\n-#pragma once\n-\n-\n-#include \"antlr4-runtime.h\"\n-#include \"ClickHouseParser.h\"\n-\n-\n-namespace DB {\n-\n-/**\n- * This class defines an abstract visitor for a parse tree\n- * produced by ClickHouseParser.\n- */\n-class  ClickHouseParserVisitor : public antlr4::tree::AbstractParseTreeVisitor {\n-public:\n-\n-  /**\n-   * Visit parse trees produced by ClickHouseParser.\n-   */\n-    virtual antlrcpp::Any visitQueryStmt(ClickHouseParser::QueryStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitQuery(ClickHouseParser::QueryContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableStmt(ClickHouseParser::AlterTableStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseAddColumn(ClickHouseParser::AlterTableClauseAddColumnContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseAddIndex(ClickHouseParser::AlterTableClauseAddIndexContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseAddProjection(ClickHouseParser::AlterTableClauseAddProjectionContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseAttach(ClickHouseParser::AlterTableClauseAttachContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseClearColumn(ClickHouseParser::AlterTableClauseClearColumnContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseClearIndex(ClickHouseParser::AlterTableClauseClearIndexContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseClearProjection(ClickHouseParser::AlterTableClauseClearProjectionContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseComment(ClickHouseParser::AlterTableClauseCommentContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseDelete(ClickHouseParser::AlterTableClauseDeleteContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseDetach(ClickHouseParser::AlterTableClauseDetachContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseDropColumn(ClickHouseParser::AlterTableClauseDropColumnContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseDropIndex(ClickHouseParser::AlterTableClauseDropIndexContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseDropProjection(ClickHouseParser::AlterTableClauseDropProjectionContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseDropPartition(ClickHouseParser::AlterTableClauseDropPartitionContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseFreezePartition(ClickHouseParser::AlterTableClauseFreezePartitionContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseMaterializeIndex(ClickHouseParser::AlterTableClauseMaterializeIndexContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseMaterializeProjection(ClickHouseParser::AlterTableClauseMaterializeProjectionContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseModifyCodec(ClickHouseParser::AlterTableClauseModifyCodecContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseModifyComment(ClickHouseParser::AlterTableClauseModifyCommentContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseModifyRemove(ClickHouseParser::AlterTableClauseModifyRemoveContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseModify(ClickHouseParser::AlterTableClauseModifyContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseModifyOrderBy(ClickHouseParser::AlterTableClauseModifyOrderByContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseModifyTTL(ClickHouseParser::AlterTableClauseModifyTTLContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseMovePartition(ClickHouseParser::AlterTableClauseMovePartitionContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseRemoveTTL(ClickHouseParser::AlterTableClauseRemoveTTLContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseRename(ClickHouseParser::AlterTableClauseRenameContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseReplace(ClickHouseParser::AlterTableClauseReplaceContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlterTableClauseUpdate(ClickHouseParser::AlterTableClauseUpdateContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAssignmentExprList(ClickHouseParser::AssignmentExprListContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAssignmentExpr(ClickHouseParser::AssignmentExprContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitTableColumnPropertyType(ClickHouseParser::TableColumnPropertyTypeContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitPartitionClause(ClickHouseParser::PartitionClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAttachDictionaryStmt(ClickHouseParser::AttachDictionaryStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitCheckStmt(ClickHouseParser::CheckStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitCreateDatabaseStmt(ClickHouseParser::CreateDatabaseStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitCreateDictionaryStmt(ClickHouseParser::CreateDictionaryStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitCreateLiveViewStmt(ClickHouseParser::CreateLiveViewStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitCreateMaterializedViewStmt(ClickHouseParser::CreateMaterializedViewStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitCreateTableStmt(ClickHouseParser::CreateTableStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitCreateViewStmt(ClickHouseParser::CreateViewStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitDictionarySchemaClause(ClickHouseParser::DictionarySchemaClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitDictionaryAttrDfnt(ClickHouseParser::DictionaryAttrDfntContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitDictionaryEngineClause(ClickHouseParser::DictionaryEngineClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitDictionaryPrimaryKeyClause(ClickHouseParser::DictionaryPrimaryKeyClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitDictionaryArgExpr(ClickHouseParser::DictionaryArgExprContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitSourceClause(ClickHouseParser::SourceClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitLifetimeClause(ClickHouseParser::LifetimeClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitLayoutClause(ClickHouseParser::LayoutClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitRangeClause(ClickHouseParser::RangeClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitDictionarySettingsClause(ClickHouseParser::DictionarySettingsClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitClusterClause(ClickHouseParser::ClusterClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitUuidClause(ClickHouseParser::UuidClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitDestinationClause(ClickHouseParser::DestinationClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitSubqueryClause(ClickHouseParser::SubqueryClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitSchemaDescriptionClause(ClickHouseParser::SchemaDescriptionClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitSchemaAsTableClause(ClickHouseParser::SchemaAsTableClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitSchemaAsFunctionClause(ClickHouseParser::SchemaAsFunctionClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitEngineClause(ClickHouseParser::EngineClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitPartitionByClause(ClickHouseParser::PartitionByClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitPrimaryKeyClause(ClickHouseParser::PrimaryKeyClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitSampleByClause(ClickHouseParser::SampleByClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitTtlClause(ClickHouseParser::TtlClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitEngineExpr(ClickHouseParser::EngineExprContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitTableElementExprColumn(ClickHouseParser::TableElementExprColumnContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitTableElementExprConstraint(ClickHouseParser::TableElementExprConstraintContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitTableElementExprIndex(ClickHouseParser::TableElementExprIndexContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitTableElementExprProjection(ClickHouseParser::TableElementExprProjectionContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitTableColumnDfnt(ClickHouseParser::TableColumnDfntContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitTableColumnPropertyExpr(ClickHouseParser::TableColumnPropertyExprContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitTableIndexDfnt(ClickHouseParser::TableIndexDfntContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitTableProjectionDfnt(ClickHouseParser::TableProjectionDfntContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitCodecExpr(ClickHouseParser::CodecExprContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitCodecArgExpr(ClickHouseParser::CodecArgExprContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitTtlExpr(ClickHouseParser::TtlExprContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitDescribeStmt(ClickHouseParser::DescribeStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitDropDatabaseStmt(ClickHouseParser::DropDatabaseStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitDropTableStmt(ClickHouseParser::DropTableStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitExistsDatabaseStmt(ClickHouseParser::ExistsDatabaseStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitExistsTableStmt(ClickHouseParser::ExistsTableStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitExplainASTStmt(ClickHouseParser::ExplainASTStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitExplainSyntaxStmt(ClickHouseParser::ExplainSyntaxStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitInsertStmt(ClickHouseParser::InsertStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnsClause(ClickHouseParser::ColumnsClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitDataClauseFormat(ClickHouseParser::DataClauseFormatContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitDataClauseValues(ClickHouseParser::DataClauseValuesContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitDataClauseSelect(ClickHouseParser::DataClauseSelectContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitKillMutationStmt(ClickHouseParser::KillMutationStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitOptimizeStmt(ClickHouseParser::OptimizeStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitRenameStmt(ClickHouseParser::RenameStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitProjectionSelectStmt(ClickHouseParser::ProjectionSelectStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitSelectUnionStmt(ClickHouseParser::SelectUnionStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitSelectStmtWithParens(ClickHouseParser::SelectStmtWithParensContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitSelectStmt(ClickHouseParser::SelectStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitWithClause(ClickHouseParser::WithClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitTopClause(ClickHouseParser::TopClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitFromClause(ClickHouseParser::FromClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitArrayJoinClause(ClickHouseParser::ArrayJoinClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitPrewhereClause(ClickHouseParser::PrewhereClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitWhereClause(ClickHouseParser::WhereClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitGroupByClause(ClickHouseParser::GroupByClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitHavingClause(ClickHouseParser::HavingClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitOrderByClause(ClickHouseParser::OrderByClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitProjectionOrderByClause(ClickHouseParser::ProjectionOrderByClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitLimitByClause(ClickHouseParser::LimitByClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitLimitClause(ClickHouseParser::LimitClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitSettingsClause(ClickHouseParser::SettingsClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitJoinExprOp(ClickHouseParser::JoinExprOpContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitJoinExprTable(ClickHouseParser::JoinExprTableContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitJoinExprParens(ClickHouseParser::JoinExprParensContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitJoinExprCrossOp(ClickHouseParser::JoinExprCrossOpContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitJoinOpInner(ClickHouseParser::JoinOpInnerContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitJoinOpLeftRight(ClickHouseParser::JoinOpLeftRightContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitJoinOpFull(ClickHouseParser::JoinOpFullContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitJoinOpCross(ClickHouseParser::JoinOpCrossContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitJoinConstraintClause(ClickHouseParser::JoinConstraintClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitSampleClause(ClickHouseParser::SampleClauseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitLimitExpr(ClickHouseParser::LimitExprContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitOrderExprList(ClickHouseParser::OrderExprListContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitOrderExpr(ClickHouseParser::OrderExprContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitRatioExpr(ClickHouseParser::RatioExprContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitSettingExprList(ClickHouseParser::SettingExprListContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitSettingExpr(ClickHouseParser::SettingExprContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitSetStmt(ClickHouseParser::SetStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitShowCreateDatabaseStmt(ClickHouseParser::ShowCreateDatabaseStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitShowCreateDictionaryStmt(ClickHouseParser::ShowCreateDictionaryStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitShowCreateTableStmt(ClickHouseParser::ShowCreateTableStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitShowDatabasesStmt(ClickHouseParser::ShowDatabasesStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitShowDictionariesStmt(ClickHouseParser::ShowDictionariesStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitShowTablesStmt(ClickHouseParser::ShowTablesStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitSystemStmt(ClickHouseParser::SystemStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitTruncateStmt(ClickHouseParser::TruncateStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitUseStmt(ClickHouseParser::UseStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitWatchStmt(ClickHouseParser::WatchStmtContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnTypeExprSimple(ClickHouseParser::ColumnTypeExprSimpleContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnTypeExprNested(ClickHouseParser::ColumnTypeExprNestedContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnTypeExprEnum(ClickHouseParser::ColumnTypeExprEnumContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnTypeExprComplex(ClickHouseParser::ColumnTypeExprComplexContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnTypeExprParam(ClickHouseParser::ColumnTypeExprParamContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprList(ClickHouseParser::ColumnExprListContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnsExprAsterisk(ClickHouseParser::ColumnsExprAsteriskContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnsExprSubquery(ClickHouseParser::ColumnsExprSubqueryContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnsExprColumn(ClickHouseParser::ColumnsExprColumnContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprTernaryOp(ClickHouseParser::ColumnExprTernaryOpContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprAlias(ClickHouseParser::ColumnExprAliasContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprExtract(ClickHouseParser::ColumnExprExtractContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprNegate(ClickHouseParser::ColumnExprNegateContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprSubquery(ClickHouseParser::ColumnExprSubqueryContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprLiteral(ClickHouseParser::ColumnExprLiteralContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprArray(ClickHouseParser::ColumnExprArrayContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprSubstring(ClickHouseParser::ColumnExprSubstringContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprCast(ClickHouseParser::ColumnExprCastContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprOr(ClickHouseParser::ColumnExprOrContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprPrecedence1(ClickHouseParser::ColumnExprPrecedence1Context *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprPrecedence2(ClickHouseParser::ColumnExprPrecedence2Context *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprPrecedence3(ClickHouseParser::ColumnExprPrecedence3Context *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprInterval(ClickHouseParser::ColumnExprIntervalContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprIsNull(ClickHouseParser::ColumnExprIsNullContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprTrim(ClickHouseParser::ColumnExprTrimContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprTuple(ClickHouseParser::ColumnExprTupleContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprArrayAccess(ClickHouseParser::ColumnExprArrayAccessContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprBetween(ClickHouseParser::ColumnExprBetweenContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprParens(ClickHouseParser::ColumnExprParensContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprTimestamp(ClickHouseParser::ColumnExprTimestampContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprAnd(ClickHouseParser::ColumnExprAndContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprTupleAccess(ClickHouseParser::ColumnExprTupleAccessContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprCase(ClickHouseParser::ColumnExprCaseContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprDate(ClickHouseParser::ColumnExprDateContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprNot(ClickHouseParser::ColumnExprNotContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprIdentifier(ClickHouseParser::ColumnExprIdentifierContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprFunction(ClickHouseParser::ColumnExprFunctionContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnExprAsterisk(ClickHouseParser::ColumnExprAsteriskContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnArgList(ClickHouseParser::ColumnArgListContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnArgExpr(ClickHouseParser::ColumnArgExprContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnLambdaExpr(ClickHouseParser::ColumnLambdaExprContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitColumnIdentifier(ClickHouseParser::ColumnIdentifierContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitNestedIdentifier(ClickHouseParser::NestedIdentifierContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitTableExprIdentifier(ClickHouseParser::TableExprIdentifierContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitTableExprSubquery(ClickHouseParser::TableExprSubqueryContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitTableExprAlias(ClickHouseParser::TableExprAliasContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitTableExprFunction(ClickHouseParser::TableExprFunctionContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitTableFunctionExpr(ClickHouseParser::TableFunctionExprContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitTableIdentifier(ClickHouseParser::TableIdentifierContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitTableArgList(ClickHouseParser::TableArgListContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitTableArgExpr(ClickHouseParser::TableArgExprContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitDatabaseIdentifier(ClickHouseParser::DatabaseIdentifierContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitFloatingLiteral(ClickHouseParser::FloatingLiteralContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitNumberLiteral(ClickHouseParser::NumberLiteralContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitLiteral(ClickHouseParser::LiteralContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitInterval(ClickHouseParser::IntervalContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitKeyword(ClickHouseParser::KeywordContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitKeywordForAlias(ClickHouseParser::KeywordForAliasContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitAlias(ClickHouseParser::AliasContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitIdentifier(ClickHouseParser::IdentifierContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitIdentifierOrNull(ClickHouseParser::IdentifierOrNullContext *context) = 0;\n-\n-    virtual antlrcpp::Any visitEnumValue(ClickHouseParser::EnumValueContext *context) = 0;\n-\n-\n-};\n-\n-}  // namespace DB\ndiff --git a/src/Parsers/New/LexerErrorListener.cpp b/src/Parsers/New/LexerErrorListener.cpp\ndeleted file mode 100644\nindex ed6dc358c529..000000000000\n--- a/src/Parsers/New/LexerErrorListener.cpp\n+++ /dev/null\n@@ -1,26 +0,0 @@\n-#include <Common/Exception.h>\n-#include <common/logger_useful.h>\n-\n-#include <Parsers/New/LexerErrorListener.h>\n-\n-\n-using namespace antlr4;\n-\n-namespace DB\n-{\n-\n-namespace ErrorCodes\n-{\n-\n-extern int SYNTAX_ERROR;\n-\n-}\n-\n-void LexerErrorListener::syntaxError(Recognizer *, Token *, size_t, size_t, const std::string & message, std::exception_ptr)\n-{\n-    LOG_ERROR(&Poco::Logger::get(\"ClickHouseLexer\"), \"Lexer error: {}\", message);\n-\n-    throw DB::Exception(\"Can't recognize input: \" + message, ErrorCodes::SYNTAX_ERROR);\n-}\n-\n-}\ndiff --git a/src/Parsers/New/LexerErrorListener.h b/src/Parsers/New/LexerErrorListener.h\ndeleted file mode 100644\nindex 62445ffb1667..000000000000\n--- a/src/Parsers/New/LexerErrorListener.h\n+++ /dev/null\n@@ -1,21 +0,0 @@\n-#pragma once\n-\n-#include <BaseErrorListener.h>\n-\n-\n-namespace DB\n-{\n-\n-class LexerErrorListener : public antlr4::BaseErrorListener\n-{\n-public:\n-    void syntaxError(\n-        antlr4::Recognizer * recognizer,\n-        antlr4::Token * offending_symbol,\n-        size_t line,\n-        size_t pos,\n-        const std::string & message,\n-        std::exception_ptr e) override;\n-};\n-\n-}\ndiff --git a/src/Parsers/New/ParseTreeVisitor.cpp b/src/Parsers/New/ParseTreeVisitor.cpp\ndeleted file mode 100644\nindex a7c7a2758eb3..000000000000\n--- a/src/Parsers/New/ParseTreeVisitor.cpp\n+++ /dev/null\n@@ -1,150 +0,0 @@\n-#include <Parsers/New/AST/AlterTableQuery.h>\n-#include <Parsers/New/AST/AttachQuery.h>\n-#include <Parsers/New/AST/CheckQuery.h>\n-#include <Parsers/New/AST/ColumnExpr.h>\n-#include <Parsers/New/AST/CreateDatabaseQuery.h>\n-#include <Parsers/New/AST/CreateDictionaryQuery.h>\n-#include <Parsers/New/AST/CreateLiveViewQuery.h>\n-#include <Parsers/New/AST/CreateMaterializedViewQuery.h>\n-#include <Parsers/New/AST/CreateTableQuery.h>\n-#include <Parsers/New/AST/CreateViewQuery.h>\n-#include <Parsers/New/AST/DDLQuery.h>\n-#include <Parsers/New/AST/DescribeQuery.h>\n-#include <Parsers/New/AST/DropQuery.h>\n-#include <Parsers/New/AST/EngineExpr.h>\n-#include <Parsers/New/AST/ExistsQuery.h>\n-#include <Parsers/New/AST/ExplainQuery.h>\n-#include <Parsers/New/AST/Identifier.h>\n-#include <Parsers/New/AST/InsertQuery.h>\n-#include <Parsers/New/AST/JoinExpr.h>\n-#include <Parsers/New/AST/Literal.h>\n-#include <Parsers/New/AST/KillQuery.h>\n-#include <Parsers/New/AST/OptimizeQuery.h>\n-#include <Parsers/New/AST/RenameQuery.h>\n-#include <Parsers/New/AST/SelectUnionQuery.h>\n-#include <Parsers/New/AST/SetQuery.h>\n-#include <Parsers/New/AST/ShowQuery.h>\n-#include <Parsers/New/AST/ShowCreateQuery.h>\n-#include <Parsers/New/AST/SystemQuery.h>\n-#include <Parsers/New/AST/TableExpr.h>\n-#include <Parsers/New/AST/TruncateQuery.h>\n-#include <Parsers/New/AST/UseQuery.h>\n-#include <Parsers/New/AST/WatchQuery.h>\n-\n-// Include last, because antlr-runtime undefines EOF macros, which is required in boost multiprecision numbers.\n-#include <Parsers/New/ParseTreeVisitor.h>\n-\n-namespace DB\n-{\n-\n-using namespace AST;\n-\n-antlrcpp::Any ParseTreeVisitor::visitQueryStmt(ClickHouseParser::QueryStmtContext *ctx)\n-{\n-    if (ctx->insertStmt()) return std::static_pointer_cast<Query>(visit(ctx->insertStmt()).as<PtrTo<InsertQuery>>());\n-\n-    auto query = visit(ctx->query()).as<PtrTo<Query>>();\n-\n-    if (ctx->OUTFILE()) query->setOutFile(Literal::createString(ctx->STRING_LITERAL()));\n-    if (ctx->FORMAT()) query->setFormat(visit(ctx->identifierOrNull()));\n-\n-    return query;\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitQuery(ClickHouseParser::QueryContext *ctx)\n-{\n-    auto query = visit(ctx->children[0]);\n-\n-#define TRY_POINTER_CAST(TYPE) if (query.is<PtrTo<TYPE>>()) return std::static_pointer_cast<Query>(query.as<PtrTo<TYPE>>());\n-    TRY_POINTER_CAST(AlterTableQuery)\n-    TRY_POINTER_CAST(AttachQuery)\n-    TRY_POINTER_CAST(CheckQuery)\n-    TRY_POINTER_CAST(CreateDatabaseQuery)\n-    TRY_POINTER_CAST(CreateDictionaryQuery)\n-    TRY_POINTER_CAST(CreateLiveViewQuery)\n-    TRY_POINTER_CAST(CreateMaterializedViewQuery)\n-    TRY_POINTER_CAST(CreateTableQuery)\n-    TRY_POINTER_CAST(CreateViewQuery)\n-    TRY_POINTER_CAST(DescribeQuery)\n-    TRY_POINTER_CAST(DropQuery)\n-    TRY_POINTER_CAST(ExistsQuery)\n-    TRY_POINTER_CAST(ExplainQuery)\n-    TRY_POINTER_CAST(KillQuery)\n-    TRY_POINTER_CAST(OptimizeQuery)\n-    TRY_POINTER_CAST(RenameQuery)\n-    TRY_POINTER_CAST(SelectUnionQuery)\n-    TRY_POINTER_CAST(SetQuery)\n-    TRY_POINTER_CAST(ShowQuery)\n-    TRY_POINTER_CAST(ShowCreateQuery)\n-    TRY_POINTER_CAST(SystemQuery)\n-    TRY_POINTER_CAST(TruncateQuery)\n-    TRY_POINTER_CAST(UseQuery)\n-    TRY_POINTER_CAST(WatchQuery)\n-#undef TRY_POINTER_CAST\n-\n-    throw std::runtime_error(\"Query is unknown: \" + ctx->children[0]->getText());\n-\n-    __builtin_unreachable();\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitShowDatabasesStmt(ClickHouseParser::ShowDatabasesStmtContext *)\n-{\n-    auto database_name = std::make_shared<ColumnIdentifier>(nullptr, std::make_shared<Identifier>(\"name\"));\n-    auto expr_list = PtrTo<ColumnExprList>(new ColumnExprList{ColumnExpr::createIdentifier(database_name)});\n-    auto select_stmt = std::make_shared<SelectStmt>(false, SelectStmt::ModifierType::NONE, false, expr_list);\n-\n-    auto system = std::make_shared<DatabaseIdentifier>(std::make_shared<Identifier>(\"system\"));\n-    auto databases = std::make_shared<TableIdentifier>(system, std::make_shared<Identifier>(\"databases\"));\n-    auto system_tables = JoinExpr::createTableExpr(TableExpr::createIdentifier(databases), nullptr, false);\n-\n-    select_stmt->setFromClause(std::make_shared<FromClause>(system_tables));\n-\n-    return PtrTo<SelectUnionQuery>(\n-        new SelectUnionQuery(std::make_shared<List<SelectStmt>>(std::initializer_list<PtrTo<SelectStmt>>{select_stmt})));\n-}\n-\n-antlrcpp::Any ParseTreeVisitor::visitShowTablesStmt(ClickHouseParser::ShowTablesStmtContext *ctx)\n-{\n-    // TODO: don't forget to convert TEMPORARY into 'is_temporary=1' condition.\n-\n-    auto table_name = std::make_shared<ColumnIdentifier>(nullptr, std::make_shared<Identifier>(\"name\"));\n-    auto expr_list = PtrTo<ColumnExprList>(new ColumnExprList{ColumnExpr::createIdentifier(table_name)});\n-    auto select_stmt = std::make_shared<SelectStmt>(false, SelectStmt::ModifierType::NONE, false, expr_list);\n-\n-    auto and_args = PtrTo<ColumnExprList>(new ColumnExprList{ColumnExpr::createLiteral(Literal::createNumber(\"1\"))});\n-\n-    auto current_database = ColumnExpr::createLiteral(Literal::createString(current_database_name));\n-    if (ctx->databaseIdentifier())\n-    {\n-        current_database = ColumnExpr::createLiteral(Literal::createString(visit(ctx->databaseIdentifier()).as<PtrTo<DatabaseIdentifier>>()->getName()));\n-    }\n-    auto database = std::make_shared<ColumnIdentifier>(nullptr, std::make_shared<Identifier>(\"database\"));\n-    auto equals_args = PtrTo<ColumnExprList>(new ColumnExprList{\n-        ColumnExpr::createIdentifier(database),\n-        current_database\n-    });\n-    and_args->push(ColumnExpr::createFunction(std::make_shared<Identifier>(\"equals\"), nullptr, equals_args));\n-\n-    if (ctx->LIKE())\n-    {\n-        auto args = PtrTo<ColumnExprList>(new ColumnExprList{\n-            ColumnExpr::createIdentifier(table_name), ColumnExpr::createLiteral(Literal::createString(ctx->STRING_LITERAL()))});\n-        and_args->push(ColumnExpr::createFunction(std::make_shared<Identifier>(\"like\"), nullptr, args));\n-    }\n-    else if (ctx->whereClause())\n-        and_args->push(visit(ctx->whereClause()->columnExpr()));\n-\n-    auto system = std::make_shared<DatabaseIdentifier>(std::make_shared<Identifier>(\"system\"));\n-    auto tables = std::make_shared<TableIdentifier>(system, std::make_shared<Identifier>(\"tables\"));\n-    auto system_tables = JoinExpr::createTableExpr(TableExpr::createIdentifier(tables), nullptr, false);\n-\n-    select_stmt->setFromClause(std::make_shared<FromClause>(system_tables));\n-    select_stmt->setWhereClause(\n-        std::make_shared<WhereClause>(ColumnExpr::createFunction(std::make_shared<Identifier>(\"and\"), nullptr, and_args)));\n-    select_stmt->setLimitClause(ctx->limitClause() ? visit(ctx->limitClause()).as<PtrTo<LimitClause>>() : nullptr);\n-\n-    return PtrTo<SelectUnionQuery>(\n-        new SelectUnionQuery(std::make_shared<List<SelectStmt>>(std::initializer_list<PtrTo<SelectStmt>>{select_stmt})));\n-}\n-\n-}\ndiff --git a/src/Parsers/New/ParseTreeVisitor.h b/src/Parsers/New/ParseTreeVisitor.h\ndeleted file mode 100644\nindex 35d5ae9b12eb..000000000000\n--- a/src/Parsers/New/ParseTreeVisitor.h\n+++ /dev/null\n@@ -1,304 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/New/ClickHouseParserVisitor.h>\n-\n-\n-namespace DB {\n-\n-class ParseTreeVisitor : public ClickHouseParserVisitor\n-{\n-    const String & current_database_name;\n-public:\n-    explicit ParseTreeVisitor(const String & database_name) : ClickHouseParserVisitor(), current_database_name(database_name) {}\n-    virtual ~ParseTreeVisitor() override = default;\n-\n-    // Top-level statements\n-    antlrcpp::Any visitQueryStmt(ClickHouseParser::QueryStmtContext * ctx) override;\n-    antlrcpp::Any visitQuery(ClickHouseParser::QueryContext * ctx) override;\n-\n-    // AlterTableQuery\n-    antlrcpp::Any visitAlterTableClauseAddColumn(ClickHouseParser::AlterTableClauseAddColumnContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseAddIndex(ClickHouseParser::AlterTableClauseAddIndexContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseAddProjection(ClickHouseParser::AlterTableClauseAddProjectionContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseAttach(ClickHouseParser::AlterTableClauseAttachContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseClearColumn(ClickHouseParser::AlterTableClauseClearColumnContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseClearIndex(ClickHouseParser::AlterTableClauseClearIndexContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseClearProjection(ClickHouseParser::AlterTableClauseClearProjectionContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseComment(ClickHouseParser::AlterTableClauseCommentContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseDelete(ClickHouseParser::AlterTableClauseDeleteContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseDetach(ClickHouseParser::AlterTableClauseDetachContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseDropColumn(ClickHouseParser::AlterTableClauseDropColumnContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseDropIndex(ClickHouseParser::AlterTableClauseDropIndexContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseDropProjection(ClickHouseParser::AlterTableClauseDropProjectionContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseDropPartition(ClickHouseParser::AlterTableClauseDropPartitionContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseFreezePartition(ClickHouseParser::AlterTableClauseFreezePartitionContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseMaterializeIndex(ClickHouseParser::AlterTableClauseMaterializeIndexContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseMaterializeProjection(ClickHouseParser::AlterTableClauseMaterializeProjectionContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseModify(ClickHouseParser::AlterTableClauseModifyContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseModifyCodec(ClickHouseParser::AlterTableClauseModifyCodecContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseModifyComment(ClickHouseParser::AlterTableClauseModifyCommentContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseModifyOrderBy(ClickHouseParser::AlterTableClauseModifyOrderByContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseModifyRemove(ClickHouseParser::AlterTableClauseModifyRemoveContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseModifyTTL(ClickHouseParser::AlterTableClauseModifyTTLContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseMovePartition(ClickHouseParser::AlterTableClauseMovePartitionContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseRemoveTTL(ClickHouseParser::AlterTableClauseRemoveTTLContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseRename(ClickHouseParser::AlterTableClauseRenameContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseReplace(ClickHouseParser::AlterTableClauseReplaceContext * ctx) override;\n-    antlrcpp::Any visitAlterTableClauseUpdate(ClickHouseParser::AlterTableClauseUpdateContext * ctx) override;\n-    antlrcpp::Any visitAlterTableStmt(ClickHouseParser::AlterTableStmtContext * ctx) override;\n-    antlrcpp::Any visitAssignmentExpr(ClickHouseParser::AssignmentExprContext * ctx) override;\n-    antlrcpp::Any visitAssignmentExprList(ClickHouseParser::AssignmentExprListContext * ctx) override;\n-    antlrcpp::Any visitTableColumnPropertyType(ClickHouseParser::TableColumnPropertyTypeContext * ctx) override;\n-\n-    // AttachQuery\n-    antlrcpp::Any visitAttachDictionaryStmt(ClickHouseParser::AttachDictionaryStmtContext * ctx) override;\n-\n-    // CheckQuery\n-    antlrcpp::Any visitCheckStmt(ClickHouseParser::CheckStmtContext * ctx) override;\n-\n-    // ColumnExpr\n-    antlrcpp::Any visitColumnExprAlias(ClickHouseParser::ColumnExprAliasContext * ctx) override;\n-    antlrcpp::Any visitColumnExprAnd(ClickHouseParser::ColumnExprAndContext * ctx) override;\n-    antlrcpp::Any visitColumnExprArray(ClickHouseParser::ColumnExprArrayContext * ctx) override;\n-    antlrcpp::Any visitColumnExprArrayAccess(ClickHouseParser::ColumnExprArrayAccessContext * ctx) override;\n-    antlrcpp::Any visitColumnExprAsterisk(ClickHouseParser::ColumnExprAsteriskContext * ctx) override;\n-    antlrcpp::Any visitColumnExprBetween(ClickHouseParser::ColumnExprBetweenContext * ctx) override;\n-    antlrcpp::Any visitColumnExprCase(ClickHouseParser::ColumnExprCaseContext * ctx) override;\n-    antlrcpp::Any visitColumnExprCast(ClickHouseParser::ColumnExprCastContext * ctx) override;\n-    antlrcpp::Any visitColumnExprDate(ClickHouseParser::ColumnExprDateContext * ctx) override;\n-    antlrcpp::Any visitColumnExprExtract(ClickHouseParser::ColumnExprExtractContext * ctx) override;\n-    antlrcpp::Any visitColumnExprFunction(ClickHouseParser::ColumnExprFunctionContext * ctx) override;\n-    antlrcpp::Any visitColumnExprIdentifier(ClickHouseParser::ColumnExprIdentifierContext * ctx) override;\n-    antlrcpp::Any visitColumnExprInterval(ClickHouseParser::ColumnExprIntervalContext * ctx) override;\n-    antlrcpp::Any visitColumnExprIsNull(ClickHouseParser::ColumnExprIsNullContext * ctx) override;\n-    antlrcpp::Any visitColumnExprList(ClickHouseParser::ColumnExprListContext * ctx) override;\n-    antlrcpp::Any visitColumnExprLiteral(ClickHouseParser::ColumnExprLiteralContext * ctx) override;\n-    antlrcpp::Any visitColumnExprNegate(ClickHouseParser::ColumnExprNegateContext * ctx) override;\n-    antlrcpp::Any visitColumnExprNot(ClickHouseParser::ColumnExprNotContext * ctx) override;\n-    antlrcpp::Any visitColumnExprOr(ClickHouseParser::ColumnExprOrContext * ctx) override;\n-    antlrcpp::Any visitColumnExprParens(ClickHouseParser::ColumnExprParensContext * ctx) override;\n-    antlrcpp::Any visitColumnExprPrecedence1(ClickHouseParser::ColumnExprPrecedence1Context * ctx) override;\n-    antlrcpp::Any visitColumnExprPrecedence2(ClickHouseParser::ColumnExprPrecedence2Context * ctx) override;\n-    antlrcpp::Any visitColumnExprPrecedence3(ClickHouseParser::ColumnExprPrecedence3Context * ctx) override;\n-    antlrcpp::Any visitColumnExprSubquery(ClickHouseParser::ColumnExprSubqueryContext * ctx) override;\n-    antlrcpp::Any visitColumnExprSubstring(ClickHouseParser::ColumnExprSubstringContext * ctx) override;\n-    antlrcpp::Any visitColumnExprTernaryOp(ClickHouseParser::ColumnExprTernaryOpContext * ctx) override;\n-    antlrcpp::Any visitColumnExprTimestamp(ClickHouseParser::ColumnExprTimestampContext * ctx) override;\n-    antlrcpp::Any visitColumnExprTrim(ClickHouseParser::ColumnExprTrimContext * ctx) override;\n-    antlrcpp::Any visitColumnExprTuple(ClickHouseParser::ColumnExprTupleContext * ctx) override;\n-    antlrcpp::Any visitColumnExprTupleAccess(ClickHouseParser::ColumnExprTupleAccessContext * ctx) override;\n-\n-    // ColumnTypeExpr\n-    antlrcpp::Any visitColumnTypeExprSimple(ClickHouseParser::ColumnTypeExprSimpleContext * ctx) override;\n-    antlrcpp::Any visitColumnTypeExprParam(ClickHouseParser::ColumnTypeExprParamContext * ctx) override;\n-    antlrcpp::Any visitColumnTypeExprEnum(ClickHouseParser::ColumnTypeExprEnumContext * ctx) override;\n-    antlrcpp::Any visitColumnTypeExprComplex(ClickHouseParser::ColumnTypeExprComplexContext * ctx) override;\n-    antlrcpp::Any visitColumnTypeExprNested(ClickHouseParser::ColumnTypeExprNestedContext * ctx) override;\n-\n-    // CreateDatabaseQuery\n-    antlrcpp::Any visitCreateDatabaseStmt(ClickHouseParser::CreateDatabaseStmtContext * ctx) override;\n-\n-    // CreateDictionaryQuery\n-    antlrcpp::Any visitCreateDictionaryStmt(ClickHouseParser::CreateDictionaryStmtContext * ctx) override;\n-    antlrcpp::Any visitDictionaryArgExpr(ClickHouseParser::DictionaryArgExprContext * ctx) override;\n-    antlrcpp::Any visitDictionaryAttrDfnt(ClickHouseParser::DictionaryAttrDfntContext * ctx) override;\n-    antlrcpp::Any visitDictionaryEngineClause(ClickHouseParser::DictionaryEngineClauseContext * ctx) override;\n-    antlrcpp::Any visitDictionaryPrimaryKeyClause(ClickHouseParser::DictionaryPrimaryKeyClauseContext * ctx) override;\n-    antlrcpp::Any visitDictionarySchemaClause(ClickHouseParser::DictionarySchemaClauseContext * ctx) override;\n-    antlrcpp::Any visitDictionarySettingsClause(ClickHouseParser::DictionarySettingsClauseContext * ctx) override;\n-    antlrcpp::Any visitLayoutClause(ClickHouseParser::LayoutClauseContext * ctx) override;\n-    antlrcpp::Any visitLifetimeClause(ClickHouseParser::LifetimeClauseContext * ctx) override;\n-    antlrcpp::Any visitRangeClause(ClickHouseParser::RangeClauseContext * ctx) override;\n-    antlrcpp::Any visitSourceClause(ClickHouseParser::SourceClauseContext * ctx) override;\n-\n-    // CreateLiveViewQuery\n-    antlrcpp::Any visitCreateLiveViewStmt(ClickHouseParser::CreateLiveViewStmtContext * ctx) override;\n-\n-    // CreateMaterializedViewQuery\n-    antlrcpp::Any visitCreateMaterializedViewStmt(ClickHouseParser::CreateMaterializedViewStmtContext * ctx) override;\n-\n-    // CreateTableQuery\n-    antlrcpp::Any visitClusterClause(ClickHouseParser::ClusterClauseContext * ctx) override;\n-    antlrcpp::Any visitCreateTableStmt(ClickHouseParser::CreateTableStmtContext * ctx) override;\n-    antlrcpp::Any visitUuidClause(ClickHouseParser::UuidClauseContext * ctx) override;\n-\n-    // CreateViewQuery\n-    antlrcpp::Any visitCreateViewStmt(ClickHouseParser::CreateViewStmtContext * ctx) override;\n-\n-    // DescribeQuery\n-    antlrcpp::Any visitDescribeStmt(ClickHouseParser::DescribeStmtContext * ctx) override;\n-\n-    // DropQuery\n-    antlrcpp::Any visitDropDatabaseStmt(ClickHouseParser::DropDatabaseStmtContext * ctx) override;\n-    antlrcpp::Any visitDropTableStmt(ClickHouseParser::DropTableStmtContext * ctx) override;\n-\n-    // EngineExpr\n-    antlrcpp::Any visitEngineClause(ClickHouseParser::EngineClauseContext * ctx) override;\n-    antlrcpp::Any visitEngineExpr(ClickHouseParser::EngineExprContext * ctx) override;\n-    antlrcpp::Any visitPartitionByClause(ClickHouseParser::PartitionByClauseContext * ctx) override;\n-    antlrcpp::Any visitPrimaryKeyClause(ClickHouseParser::PrimaryKeyClauseContext * ctx) override;\n-    antlrcpp::Any visitSampleByClause(ClickHouseParser::SampleByClauseContext * ctx) override;\n-    antlrcpp::Any visitTtlClause(ClickHouseParser::TtlClauseContext * ctx) override;\n-    antlrcpp::Any visitTtlExpr(ClickHouseParser::TtlExprContext * ctx) override;\n-\n-    // ExistsQuery\n-    antlrcpp::Any visitExistsTableStmt(ClickHouseParser::ExistsTableStmtContext * ctx) override;\n-    antlrcpp::Any visitExistsDatabaseStmt(ClickHouseParser::ExistsDatabaseStmtContext * ctx) override;\n-\n-    // ExplainQuery\n-    antlrcpp::Any visitExplainASTStmt(ClickHouseParser::ExplainASTStmtContext * ctx) override;\n-    antlrcpp::Any visitExplainSyntaxStmt(ClickHouseParser::ExplainSyntaxStmtContext * ctx) override;\n-\n-    // Identifier\n-    antlrcpp::Any visitTableIdentifier(ClickHouseParser::TableIdentifierContext * ctx) override;\n-\n-    // InsertQuery\n-    antlrcpp::Any visitColumnsClause(ClickHouseParser::ColumnsClauseContext * ctx) override;\n-    antlrcpp::Any visitDataClauseFormat(ClickHouseParser::DataClauseFormatContext * ctx) override;\n-    antlrcpp::Any visitDataClauseSelect(ClickHouseParser::DataClauseSelectContext * ctx) override;\n-    antlrcpp::Any visitDataClauseValues(ClickHouseParser::DataClauseValuesContext * ctx) override;\n-    antlrcpp::Any visitInsertStmt(ClickHouseParser::InsertStmtContext * ctx) override;\n-\n-    // KillQuery\n-    antlrcpp::Any visitKillMutationStmt(ClickHouseParser::KillMutationStmtContext * ctx) override;\n-\n-    // OptimizeQuery\n-    antlrcpp::Any visitOptimizeStmt(ClickHouseParser::OptimizeStmtContext * ctx) override;\n-\n-    // RenameQuery\n-    antlrcpp::Any visitRenameStmt(ClickHouseParser::RenameStmtContext * ctx) override;\n-\n-    // SelectUnionQuery\n-    antlrcpp::Any visitProjectionSelectStmt(ClickHouseParser::ProjectionSelectStmtContext * ctx) override;\n-    antlrcpp::Any visitSelectStmt(ClickHouseParser::SelectStmtContext * ctx) override;\n-    antlrcpp::Any visitSelectStmtWithParens(ClickHouseParser::SelectStmtWithParensContext * ctx) override;\n-    antlrcpp::Any visitSelectUnionStmt(ClickHouseParser::SelectUnionStmtContext * ctx) override;\n-\n-    // SetQuery\n-    antlrcpp::Any visitSetStmt(ClickHouseParser::SetStmtContext * ctx) override;\n-\n-    // ShowCreateQuery\n-    antlrcpp::Any visitShowCreateDatabaseStmt(ClickHouseParser::ShowCreateDatabaseStmtContext * ctx) override;\n-    antlrcpp::Any visitShowCreateDictionaryStmt(ClickHouseParser::ShowCreateDictionaryStmtContext * ctx) override;\n-    antlrcpp::Any visitShowCreateTableStmt(ClickHouseParser::ShowCreateTableStmtContext * ctx) override;\n-\n-    // ShowQuery\n-    antlrcpp::Any visitShowDatabasesStmt(ClickHouseParser::ShowDatabasesStmtContext * ctx) override;\n-    antlrcpp::Any visitShowDictionariesStmt(ClickHouseParser::ShowDictionariesStmtContext * ctx) override;\n-    antlrcpp::Any visitShowTablesStmt(ClickHouseParser::ShowTablesStmtContext * ctx) override;\n-\n-    // SystemQuery\n-    antlrcpp::Any visitSystemStmt(ClickHouseParser::SystemStmtContext * ctx) override;\n-\n-    // TableElementExpr\n-    antlrcpp::Any visitCodecArgExpr(ClickHouseParser::CodecArgExprContext * ctx) override;\n-    antlrcpp::Any visitCodecExpr(ClickHouseParser::CodecExprContext * ctx) override;\n-    antlrcpp::Any visitTableColumnDfnt(ClickHouseParser::TableColumnDfntContext * ctx) override;\n-    antlrcpp::Any visitTableColumnPropertyExpr(ClickHouseParser::TableColumnPropertyExprContext * ctx) override;\n-    antlrcpp::Any visitTableElementExprColumn(ClickHouseParser::TableElementExprColumnContext * ctx) override;\n-    antlrcpp::Any visitTableElementExprConstraint(ClickHouseParser::TableElementExprConstraintContext * ctx) override;\n-    antlrcpp::Any visitTableElementExprIndex(ClickHouseParser::TableElementExprIndexContext * ctx) override;\n-    antlrcpp::Any visitTableElementExprProjection(ClickHouseParser::TableElementExprProjectionContext * ctx) override;\n-    antlrcpp::Any visitTableIndexDfnt(ClickHouseParser::TableIndexDfntContext * ctx) override;\n-    antlrcpp::Any visitTableProjectionDfnt(ClickHouseParser::TableProjectionDfntContext * ctx) override;\n-\n-    // TableExpr\n-    antlrcpp::Any visitTableArgExpr(ClickHouseParser::TableArgExprContext * ctx) override;\n-    antlrcpp::Any visitTableArgList(ClickHouseParser::TableArgListContext * ctx) override;\n-    antlrcpp::Any visitTableExprAlias(ClickHouseParser::TableExprAliasContext * ctx) override;\n-    antlrcpp::Any visitTableExprFunction(ClickHouseParser::TableExprFunctionContext * ctx) override;\n-    antlrcpp::Any visitTableExprIdentifier(ClickHouseParser::TableExprIdentifierContext * ctx) override;\n-    antlrcpp::Any visitTableExprSubquery(ClickHouseParser::TableExprSubqueryContext * ctx) override;\n-    antlrcpp::Any visitTableFunctionExpr(ClickHouseParser::TableFunctionExprContext * ctx) override;\n-\n-    // TruncateQuery\n-    antlrcpp::Any visitTruncateStmt(ClickHouseParser::TruncateStmtContext * ctx) override;\n-\n-    // UseQuery\n-    antlrcpp::Any visitUseStmt(ClickHouseParser::UseStmtContext * ctx) override;\n-\n-    // WatchQuery\n-    antlrcpp::Any visitWatchStmt(ClickHouseParser::WatchStmtContext * ctx) override;\n-\n-    // TODO: sort methods below this comment.\n-\n-    // CREATE clauses\n-\n-    antlrcpp::Any visitDestinationClause(ClickHouseParser::DestinationClauseContext *ctx) override;\n-    antlrcpp::Any visitSchemaDescriptionClause(ClickHouseParser::SchemaDescriptionClauseContext *ctx) override;\n-    antlrcpp::Any visitSchemaAsTableClause(ClickHouseParser::SchemaAsTableClauseContext *ctx) override;\n-    antlrcpp::Any visitSchemaAsFunctionClause(ClickHouseParser::SchemaAsFunctionClauseContext *ctx) override;\n-    antlrcpp::Any visitSubqueryClause(ClickHouseParser::SubqueryClauseContext *ctx) override;\n-\n-    // OPTIMIZE clauses\n-\n-    antlrcpp::Any visitPartitionClause(ClickHouseParser::PartitionClauseContext *ctx) override;  // returns |PtrTo<PartitionExprList>|\n-\n-    // SELECT clauses\n-\n-    antlrcpp::Any visitWithClause(ClickHouseParser::WithClauseContext *ctx) override;\n-    antlrcpp::Any visitTopClause(ClickHouseParser::TopClauseContext * ctx) override;\n-    antlrcpp::Any visitFromClause(ClickHouseParser::FromClauseContext *ctx) override;\n-    antlrcpp::Any visitSampleClause(ClickHouseParser::SampleClauseContext *ctx) override;\n-    antlrcpp::Any visitArrayJoinClause(ClickHouseParser::ArrayJoinClauseContext *ctx) override;\n-    antlrcpp::Any visitPrewhereClause(ClickHouseParser::PrewhereClauseContext *ctx) override;\n-    antlrcpp::Any visitWhereClause(ClickHouseParser::WhereClauseContext *ctx) override;\n-    antlrcpp::Any visitGroupByClause(ClickHouseParser::GroupByClauseContext *ctx) override;\n-    antlrcpp::Any visitHavingClause(ClickHouseParser::HavingClauseContext *ctx) override;\n-    antlrcpp::Any visitOrderByClause(ClickHouseParser::OrderByClauseContext *ctx) override;\n-    antlrcpp::Any visitProjectionOrderByClause(ClickHouseParser::ProjectionOrderByClauseContext *ctx) override;\n-    antlrcpp::Any visitLimitByClause(ClickHouseParser::LimitByClauseContext *ctx) override;\n-    antlrcpp::Any visitLimitClause(ClickHouseParser::LimitClauseContext *ctx) override;\n-    antlrcpp::Any visitSettingsClause(ClickHouseParser::SettingsClauseContext *ctx) override;\n-\n-    // SELECT expressions\n-\n-    antlrcpp::Any visitRatioExpr(ClickHouseParser::RatioExprContext *ctx) override;\n-    antlrcpp::Any visitOrderExprList(ClickHouseParser::OrderExprListContext *ctx) override;\n-    antlrcpp::Any visitOrderExpr(ClickHouseParser::OrderExprContext *ctx) override;\n-    antlrcpp::Any visitLimitExpr(ClickHouseParser::LimitExprContext *ctx) override;\n-    antlrcpp::Any visitSettingExprList(ClickHouseParser::SettingExprListContext *ctx) override;\n-    antlrcpp::Any visitSettingExpr(ClickHouseParser::SettingExprContext *ctx) override;\n-\n-    // Join expressions (alphabetically)\n-\n-    antlrcpp::Any visitJoinConstraintClause(ClickHouseParser::JoinConstraintClauseContext *ctx) override;\n-    antlrcpp::Any visitJoinExprCrossOp(ClickHouseParser::JoinExprCrossOpContext *ctx) override;\n-    antlrcpp::Any visitJoinExprOp(ClickHouseParser::JoinExprOpContext *ctx) override;\n-    antlrcpp::Any visitJoinExprParens(ClickHouseParser::JoinExprParensContext *ctx) override;\n-    antlrcpp::Any visitJoinExprTable(ClickHouseParser::JoinExprTableContext *ctx) override;\n-    antlrcpp::Any visitJoinOpCross(ClickHouseParser::JoinOpCrossContext *ctx) override;\n-    antlrcpp::Any visitJoinOpFull(ClickHouseParser::JoinOpFullContext *ctx) override;\n-    antlrcpp::Any visitJoinOpInner(ClickHouseParser::JoinOpInnerContext *ctx) override;\n-    antlrcpp::Any visitJoinOpLeftRight(ClickHouseParser::JoinOpLeftRightContext *ctx) override;\n-\n-    // Column expressions (alphabetically)\n-\n-    antlrcpp::Any visitColumnArgExpr(ClickHouseParser::ColumnArgExprContext *ctx) override;\n-    antlrcpp::Any visitColumnArgList(ClickHouseParser::ColumnArgListContext *ctx) override;\n-    antlrcpp::Any visitColumnIdentifier(ClickHouseParser::ColumnIdentifierContext *ctx) override;\n-    antlrcpp::Any visitColumnLambdaExpr(ClickHouseParser::ColumnLambdaExprContext *ctx) override;\n-    antlrcpp::Any visitColumnsExprAsterisk(ClickHouseParser::ColumnsExprAsteriskContext *ctx) override;\n-    antlrcpp::Any visitColumnsExprColumn(ClickHouseParser::ColumnsExprColumnContext *ctx) override;\n-    antlrcpp::Any visitColumnsExprSubquery(ClickHouseParser::ColumnsExprSubqueryContext *ctx) override;\n-    antlrcpp::Any visitNestedIdentifier(ClickHouseParser::NestedIdentifierContext *ctx) override;\n-\n-    // Database expressions\n-\n-    antlrcpp::Any visitDatabaseIdentifier(ClickHouseParser::DatabaseIdentifierContext *ctx) override;\n-\n-    // Basic expressions (alphabetically)\n-\n-    antlrcpp::Any visitAlias(ClickHouseParser::AliasContext * ctx) override;\n-    antlrcpp::Any visitEnumValue(ClickHouseParser::EnumValueContext *ctx) override;\n-    antlrcpp::Any visitFloatingLiteral(ClickHouseParser::FloatingLiteralContext *ctx) override;\n-    antlrcpp::Any visitIdentifier(ClickHouseParser::IdentifierContext *ctx) override;\n-    antlrcpp::Any visitIdentifierOrNull(ClickHouseParser::IdentifierOrNullContext *ctx) override;\n-    antlrcpp::Any visitInterval(ClickHouseParser::IntervalContext * ctx) override;\n-    antlrcpp::Any visitKeyword(ClickHouseParser::KeywordContext *ctx) override;\n-    antlrcpp::Any visitKeywordForAlias(ClickHouseParser::KeywordForAliasContext * ctx) override;\n-    antlrcpp::Any visitLiteral(ClickHouseParser::LiteralContext *ctx) override;\n-    antlrcpp::Any visitNumberLiteral(ClickHouseParser::NumberLiteralContext *ctx) override;\n-};\n-\n-}\ndiff --git a/src/Parsers/New/ParserErrorListener.cpp b/src/Parsers/New/ParserErrorListener.cpp\ndeleted file mode 100644\nindex f6ac0f0c451a..000000000000\n--- a/src/Parsers/New/ParserErrorListener.cpp\n+++ /dev/null\n@@ -1,37 +0,0 @@\n-#include <Common/Exception.h>\n-#include <common/logger_useful.h>\n-\n-#include <Parsers/New/ParserErrorListener.h>\n-\n-#include <Parsers/New/ClickHouseParser.h>\n-\n-#include <Token.h>\n-\n-\n-using namespace antlr4;\n-\n-namespace DB\n-{\n-\n-namespace ErrorCodes\n-{\n-\n-extern int SYNTAX_ERROR;\n-\n-}\n-\n-void ParserErrorListener::syntaxError(\n-    Recognizer * recognizer, Token * token, size_t, size_t, const std::string & message, std::exception_ptr)\n-{\n-    auto * parser = dynamic_cast<ClickHouseParser *>(recognizer);\n-    assert(parser);\n-\n-    LOG_ERROR(&Poco::Logger::get(\"ClickHouseParser\"), //-V522\n-              \"Last element parsed so far:\\n\"\n-              \"{}\\n\"\n-              \"Parser error: (pos {}) {}\", parser->getRuleContext()->toStringTree(parser, true), token->getStartIndex(), message);\n-\n-    throw DB::Exception(\"Can't parse input: \" + message, ErrorCodes::SYNTAX_ERROR);\n-}\n-\n-}\ndiff --git a/src/Parsers/New/ParserErrorListener.h b/src/Parsers/New/ParserErrorListener.h\ndeleted file mode 100644\nindex 1a02ff01abe4..000000000000\n--- a/src/Parsers/New/ParserErrorListener.h\n+++ /dev/null\n@@ -1,21 +0,0 @@\n-#pragma once\n-\n-#include <BaseErrorListener.h>\n-\n-\n-namespace DB\n-{\n-\n-class ParserErrorListener : public antlr4::BaseErrorListener\n-{\n-public:\n-    void syntaxError(\n-        antlr4::Recognizer * recognizer,\n-        antlr4::Token * token,\n-        size_t line,\n-        size_t pos,\n-        const std::string & message,\n-        std::exception_ptr e) override;\n-};\n-\n-}\ndiff --git a/src/Parsers/New/parseQuery.cpp b/src/Parsers/New/parseQuery.cpp\ndeleted file mode 100644\nindex c66772385ca0..000000000000\n--- a/src/Parsers/New/parseQuery.cpp\n+++ /dev/null\n@@ -1,89 +0,0 @@\n-#include <strstream>\n-\n-#include <Parsers/New/parseQuery.h>\n-\n-#include <Parsers/ASTInsertQuery.h>\n-#include <Parsers/New/AST/InsertQuery.h>\n-#include <Parsers/New/ClickHouseLexer.h>\n-#include <Parsers/New/ClickHouseParser.h>\n-#include <Parsers/New/LexerErrorListener.h>\n-#include <Parsers/New/ParseTreeVisitor.h>\n-#include <Parsers/New/ParserErrorListener.h>\n-\n-#include <CommonTokenStream.h>\n-\n-namespace DB\n-{\n-\n-using namespace antlr4;\n-using namespace AST;\n-\n-// For testing only\n-PtrTo<Query> parseQuery(const String & query, const String & current_database)\n-{\n-    ANTLRInputStream input(query);\n-    ClickHouseLexer lexer(&input);\n-    CommonTokenStream tokens(&lexer);\n-    ClickHouseParser parser(&tokens);\n-    LexerErrorListener lexer_error_listener;\n-    ParserErrorListener parser_error_listener;\n-\n-    lexer.removeErrorListeners();\n-    parser.removeErrorListeners();\n-    lexer.addErrorListener(&lexer_error_listener);\n-    parser.addErrorListener(&parser_error_listener);\n-\n-    ParseTreeVisitor visitor { current_database };\n-\n-    return visitor.visit(parser.queryStmt());\n-}\n-\n-ASTPtr parseQuery(const char * begin, const char * end, size_t, size_t, const String & current_database)\n-{\n-    // TODO: do not ignore |max_parser_depth|.\n-\n-    size_t size = end - begin;\n-    std::strstreambuf buffer(begin, size);\n-    std::wbuffer_convert<std::codecvt_utf8<wchar_t>> converter(&buffer);\n-    std::wistream stream(&converter);\n-\n-    UnbufferedCharStream input(stream, size);\n-    ClickHouseLexer lexer(&input);\n-    CommonTokenStream tokens(&lexer);\n-    ClickHouseParser parser(&tokens);\n-    LexerErrorListener lexer_error_listener;\n-    ParserErrorListener parser_error_listener;\n-\n-    lexer.removeErrorListeners();\n-    parser.removeErrorListeners();\n-    lexer.addErrorListener(&lexer_error_listener);\n-    parser.addErrorListener(&parser_error_listener);\n-\n-    ParseTreeVisitor visitor { current_database };\n-\n-    PtrTo<Query> new_ast = visitor.visit(parser.queryStmt());\n-    auto old_ast = new_ast->convertToOld();\n-\n-    if (const auto * insert = new_ast->as<InsertQuery>())\n-    {\n-        auto * old_insert = old_ast->as<ASTInsertQuery>();\n-\n-        old_insert->end = end;\n-        if (insert->hasData())\n-        {\n-            old_insert->data = begin + insert->getDataOffset();\n-\n-            // Data starts after the first newline, if there is one, or after all the whitespace characters, otherwise.\n-            auto & data = old_insert->data;\n-            while (data < end && (*data == ' ' || *data == '\\t' || *data == '\\f')) ++data;\n-            if (data < end && *data == '\\r') ++data;\n-            if (data < end && *data == '\\n') ++data;\n-        }\n-\n-        old_insert->data = (old_insert->data != end) ? old_insert->data : nullptr;\n-    }\n-\n-    return old_ast;\n-}\n-\n-}\ndiff --git a/src/Parsers/New/parseQuery.h b/src/Parsers/New/parseQuery.h\ndeleted file mode 100644\nindex 8d9c8efd3370..000000000000\n--- a/src/Parsers/New/parseQuery.h\n+++ /dev/null\n@@ -1,14 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/IAST_fwd.h>\n-#include <Parsers/New/AST/fwd_decl.h>\n-#include <common/types.h>\n-\n-namespace DB\n-{\n-\n-// Compatibility interface\n-AST::PtrTo<AST::Query> parseQuery(const std::string & query, const String & current_database);\n-ASTPtr parseQuery(const char * begin, const char * end, size_t max_query_size, size_t max_parser_depth, const String & current_database);\n-\n-}\ndiff --git a/utils/CMakeLists.txt b/utils/CMakeLists.txt\nindex bd6453e406b5..a6bf2843e9a7 100644\n--- a/utils/CMakeLists.txt\n+++ b/utils/CMakeLists.txt\n@@ -12,7 +12,6 @@ include(../cmake/limit_jobs.cmake)\n # Utils used in package\n add_subdirectory (config-processor)\n add_subdirectory (report)\n-add_subdirectory (syntax-analyzer)\n \n # Not used in package\n if (NOT DEFINED ENABLE_UTILS OR ENABLE_UTILS)\ndiff --git a/src/Parsers/New/ClickHouseLexer.g4 b/utils/antlr/ClickHouseLexer.g4\nsimilarity index 100%\nrename from src/Parsers/New/ClickHouseLexer.g4\nrename to utils/antlr/ClickHouseLexer.g4\ndiff --git a/src/Parsers/New/ClickHouseParser.g4 b/utils/antlr/ClickHouseParser.g4\nsimilarity index 100%\nrename from src/Parsers/New/ClickHouseParser.g4\nrename to utils/antlr/ClickHouseParser.g4\ndiff --git a/src/Parsers/New/README.md b/utils/antlr/README.md\nsimilarity index 100%\nrename from src/Parsers/New/README.md\nrename to utils/antlr/README.md\ndiff --git a/utils/syntax-analyzer/CMakeLists.txt b/utils/syntax-analyzer/CMakeLists.txt\ndeleted file mode 100644\nindex 77068f528bea..000000000000\n--- a/utils/syntax-analyzer/CMakeLists.txt\n+++ /dev/null\n@@ -1,3 +0,0 @@\n-add_executable(syntax-analyzer main.cpp)\n-\n-target_link_libraries(syntax-analyzer PRIVATE clickhouse_parsers_new dbms)\ndiff --git a/utils/syntax-analyzer/main.cpp b/utils/syntax-analyzer/main.cpp\ndeleted file mode 100644\nindex cf2641604070..000000000000\n--- a/utils/syntax-analyzer/main.cpp\n+++ /dev/null\n@@ -1,63 +0,0 @@\n-#include <IO/WriteBufferFromOStream.h>\n-#include <Parsers/IAST.h>\n-#include <Parsers/New/AST/Query.h>\n-#include <Parsers/New/parseQuery.h>\n-#include <Parsers/parseQuery.h>\n-#include <Parsers/ParserQuery.h>\n-\n-#include <support/Any.h>\n-\n-#include <iostream>\n-#include <iterator>\n-#include <string>\n-\n-using namespace DB;\n-\n-int main(int argc, const char **)\n-{\n-    if (argc > 1)\n-    {\n-        std::cerr << \"No arguments needed. Reads query from input until EOF\" << std::endl;\n-        return 1;\n-    }\n-\n-    std::istreambuf_iterator<char> begin(std::cin), end;\n-    std::string query(begin, end);\n-\n-    {\n-        std::vector<String> queries;\n-        splitMultipartQuery(query, queries, 10000000, 10000);\n-        for (const auto & q : queries)\n-        {\n-            std::cout << std::endl << \"Query:\" << std::endl;\n-            std::cout << q << std::endl;\n-\n-            ParserQuery parser(q.data() + q.size());\n-            ASTPtr orig_ast = parseQuery(parser, q, 10000000, 10000);\n-\n-            std::cout << std::endl << \"New AST:\" << std::endl;\n-            auto new_ast = parseQuery(q, \"\");\n-            new_ast->dump();\n-\n-            auto old_ast = new_ast->convertToOld();\n-            if (orig_ast)\n-            {\n-                std::cout << std::endl << \"Original AST:\" << std::endl;\n-                WriteBufferFromOStream buf(std::cout, 1);\n-                orig_ast->dumpTree(buf);\n-                std::cout << std::endl << \"Original query:\" << std::endl;\n-                orig_ast->format({buf, false});\n-                std::cout << std::endl;\n-            }\n-            if (old_ast)\n-            {\n-                std::cout << std::endl << \"Converted AST:\" << std::endl;\n-                WriteBufferFromOStream buf(std::cout, 1);\n-                old_ast->dumpTree(buf);\n-                std::cout << std::endl << \"Converted query:\" << std::endl;\n-                old_ast->format({buf, false});\n-                std::cout << std::endl;\n-            }\n-        }\n-    }\n-}\n",
  "test_patch": "diff --git a/docker/test/fasttest/run.sh b/docker/test/fasttest/run.sh\nindex 6efdbf6178c3..71c430bdbb55 100755\n--- a/docker/test/fasttest/run.sh\n+++ b/docker/test/fasttest/run.sh\n@@ -160,7 +160,6 @@ function clone_submodules\n \n         SUBMODULES_TO_UPDATE=(\n             contrib/abseil-cpp\n-            contrib/antlr4-runtime\n             contrib/boost\n             contrib/zlib-ng\n             contrib/libxml2\ndiff --git a/tests/ci/ci_config.json b/tests/ci/ci_config.json\nindex 2efa6ec6feff..52a101728eaa 100644\n--- a/tests/ci/ci_config.json\n+++ b/tests/ci/ci_config.json\n@@ -393,18 +393,6 @@\n                 \"with_coverage\": false\n             }\n         },\n-        \"Functional stateless tests (ANTLR debug)\": {\n-            \"required_build_properties\": {\n-                \"compiler\": \"clang-11\",\n-                \"package_type\": \"deb\",\n-                \"build_type\": \"debug\",\n-                \"sanitizer\": \"none\",\n-                \"bundled\": \"bundled\",\n-                \"splitted\": \"unsplitted\",\n-                \"clang-tidy\": \"disable\",\n-                \"with_coverage\": false\n-            }\n-        },\n         \"Stress test (address)\": {\n             \"required_build_properties\": {\n                 \"compiler\": \"clang-11\",\ndiff --git a/tests/clickhouse-test b/tests/clickhouse-test\nindex 924e40176708..63624246190e 100755\n--- a/tests/clickhouse-test\n+++ b/tests/clickhouse-test\n@@ -647,7 +647,6 @@ class BuildFlags():\n     RELEASE = 'release-build'\n     DATABASE_ORDINARY = 'database-ordinary'\n     POLYMORPHIC_PARTS = 'polymorphic-parts'\n-    ANTLR = 'antlr'\n     DATABASE_REPLICATED = 'database-replicated'\n \n \n@@ -770,8 +769,6 @@ def main(args):\n             Note: if you are using split build, you may have to specify -c option.\")\n \n     build_flags = collect_build_flags(args.client)\n-    if args.antlr:\n-        build_flags.append(BuildFlags.ANTLR)\n     if args.replicated_database:\n         build_flags.append(BuildFlags.DATABASE_REPLICATED)\n \n@@ -1086,8 +1083,6 @@ if __name__ == '__main__':\n     parser.add_argument('--use-skip-list', action='store_true', default=False, help=\"Use skip list to skip tests if found\")\n     parser.add_argument('--db-engine', help='Database engine name')\n     parser.add_argument('--replicated-database', action='store_true', default=False, help='Run tests with Replicated database engine')\n-\n-    parser.add_argument('--antlr', action='store_true', default=False, dest='antlr', help='Use new ANTLR parser in tests')\n     parser.add_argument('--no-stateless', action='store_true', help='Disable all stateless tests')\n     parser.add_argument('--no-stateful', action='store_true', help='Disable all stateful tests')\n     parser.add_argument('--skip', nargs='+', help=\"Skip these tests\")\n@@ -1180,13 +1175,6 @@ if __name__ == '__main__':\n \n         os.environ['CLICKHOUSE_URL_PARAMS'] += get_additional_client_options_url(args)\n \n-    if args.antlr:\n-        if 'CLICKHOUSE_CLIENT_OPT' in os.environ:\n-            os.environ['CLICKHOUSE_CLIENT_OPT'] += ' --use_antlr_parser=1'\n-        else:\n-            os.environ['CLICKHOUSE_CLIENT_OPT'] = '--use_antlr_parser=1'\n-        args.client += ' --use_antlr_parser=1'\n-\n     if args.extract_from_config is None:\n         if os.access(args.binary + '-extract-from-config', os.X_OK):\n             args.extract_from_config = args.binary + '-extract-from-config'\ndiff --git a/tests/queries/skip_list.json b/tests/queries/skip_list.json\nindex 8fb95741bab0..829eb8dd547c 100644\n--- a/tests/queries/skip_list.json\n+++ b/tests/queries/skip_list.json\n@@ -181,351 +181,6 @@\n         \"01508_partition_pruning_long\", /// bug, shoud be fixed\n         \"01482_move_to_prewhere_and_cast\" /// bug, shoud be fixed\n     ],\n-    \"antlr\": [\n-        \"00011_array_join_alias\",\n-        \"00186_very_long_arrays\",\n-        \"00233_position_function_sql_comparibilty\",\n-        \"00417_kill_query\",\n-        \"00534_functions_bad_arguments12\",\n-        \"00534_functions_bad_arguments2\",\n-        \"00534_functions_bad_arguments4\",\n-        \"00534_functions_bad_arguments9\",\n-        \"00564_temporary_table_management\",\n-        \"00600_replace_running_query\",\n-        \"00626_replace_partition_from_table_zookeeper\",\n-        \"00652_replicated_mutations_zookeeper\",\n-        \"00687_top_and_offset\",\n-        \"00746_sql_fuzzy\",\n-        \"00763_create_query_as_table_engine_bug\",\n-        \"00765_sql_compatibility_aliases\",\n-        \"00825_protobuf_format_array_3dim\",\n-        \"00825_protobuf_format_array_of_arrays\",\n-        \"00825_protobuf_format_enum_mapping\",\n-        \"00825_protobuf_format_map\",\n-        \"00825_protobuf_format_nested_in_nested\",\n-        \"00825_protobuf_format_nested_optional\",\n-        \"00825_protobuf_format_no_length_delimiter\",\n-        \"00825_protobuf_format_persons\",\n-        \"00825_protobuf_format_splitted_nested\",\n-        \"00825_protobuf_format_squares\",\n-        \"00825_protobuf_format_table_default\",\n-        \"00826_cross_to_inner_join\",\n-        \"00834_not_between\",\n-        \"00855_join_with_array_join\",\n-        \"00909_kill_not_initialized_query\",\n-        \"00938_template_input_format\",\n-        \"00939_limit_by_offset\",\n-        \"00943_materialize_index\",\n-        \"00944_clear_index_in_partition\",\n-        \"00952_input_function\",\n-        \"00953_constraints_operations\",\n-        \"00954_client_prepared_statements\",\n-        \"00956_sensitive_data_masking\",\n-        \"00969_columns_clause\",\n-        \"00975_indices_mutation_replicated_zookeeper_long\",\n-        \"00975_values_list\",\n-        \"00976_system_stop_ttl_merges\",\n-        \"00977_int_div\",\n-        \"00978_table_function_values_alias\",\n-        \"00980_merge_alter_settings\",\n-        \"00980_zookeeper_merge_tree_alter_settings\",\n-        \"00982_array_enumerate_uniq_ranked\",\n-        \"00984_materialized_view_to_columns\",\n-        \"00988_constraints_replication_zookeeper\",\n-        \"00995_order_by_with_fill\",\n-        \"01001_enums_in_in_section\",\n-        \"01011_group_uniq_array_memsan\",\n-        \"01011_test_create_as_skip_indices\",\n-        \"01014_format_custom_separated\",\n-        \"01015_attach_part\",\n-        \"01015_database_bad_tables\",\n-        \"01017_uniqCombined_memory_usage\",\n-        \"01018_ddl_dictionaries_concurrent_requrests\",  /// Cannot parse ATTACH DICTIONARY IF NOT EXISTS\n-        \"01019_alter_materialized_view_atomic\",\n-        \"01019_alter_materialized_view_consistent\",\n-        \"01019_alter_materialized_view_query\",\n-        \"01021_tuple_parser\",\n-        \"01025_array_compact_generic\",\n-        \"01030_limit_by_with_ties_error\",\n-        \"01033_quota_dcl\",\n-        \"01034_with_fill_and_push_down_predicate\",\n-        \"01035_avg_weighted_long\",\n-        \"01039_row_policy_dcl\",\n-        \"01039_test_setting_parse\",\n-        \"01042_system_reload_dictionary_reloads_completely\",\n-        \"01045_dictionaries_restrictions\",\n-        \"01053_ssd_dictionary\",\n-        \"01055_compact_parts_1\",\n-        \"01056_create_table_as\",\n-        \"01066_bit_count\",\n-        \"01070_materialize_ttl\",\n-        \"01070_mutations_with_dependencies\",\n-        \"01073_grant_and_revoke\",\n-        \"01073_show_tables_not_like\",\n-        \"01074_partial_revokes\",\n-        \"01075_allowed_client_hosts\",\n-        \"01083_expressions_in_engine_arguments\",\n-        \"01085_regexp_input_format\",\n-        \"01086_regexp_input_format_skip_unmatched\",\n-        \"01089_alter_settings_old_format\",\n-        \"01095_tpch_like_smoke\",\n-        \"01107_atomic_db_detach_attach\",\n-        \"01109_exchange_tables\",\n-        \"01109_sc0rp10_string_hash_map_zero_bytes\",\n-        \"01110_dictionary_layout_without_arguments\",\n-        \"01114_database_atomic\",\n-        \"01114_materialize_clear_index_compact_parts\",\n-        \"01115_join_with_dictionary\",\n-        \"01117_comma_and_others_join_mix\",\n-        \"01125_dict_ddl_cannot_add_column\",\n-        \"01130_in_memory_parts\",\n-        \"01144_multiple_joins_rewriter_v2_and_lambdas\",\n-        \"01144_multiword_data_types\",\n-        \"01145_with_fill_const\",\n-        \"01149_zookeeper_mutation_stuck_after_replace_partition\",\n-        \"01150_ddl_guard_rwr\",\n-        \"01153_attach_mv_uuid\",\n-        \"01155_old_mutation_parts_to_do\",\n-        \"01155_rename_move_materialized_view\",\n-        \"01182_materialized_view_different_structure\",\n-        \"01185_create_or_replace_table\",\n-        \"01187_set_profile_as_setting\",\n-        \"01188_attach_table_from_path\",\n-        \"01190_full_attach_syntax\",\n-        \"01191_rename_dictionary\",\n-        \"01192_rename_database_zookeeper\",\n-        \"01213_alter_rename_column\",\n-        \"01232_untuple\",\n-        \"01240_join_get_or_null\",\n-        \"01244_optimize_distributed_group_by_sharding_key\",\n-        \"01254_dict_load_after_detach_attach\",\n-        \"01256_misspell_layout_name_podshumok\",\n-        \"01257_dictionary_mismatch_types\",\n-        \"01267_alter_default_key_columns_zookeeper\",\n-        \"01268_mv_scalars\",\n-        \"01269_create_with_null\",\n-        \"01271_show_privileges\",\n-        \"01272_offset_without_limit\",\n-        \"01277_alter_rename_column_constraint_zookeeper\",\n-        \"01278_min_insert_block_size_rows_for_materialized_views\",\n-        \"01280_min_map_max_map\",\n-        \"01280_null_in\",\n-        \"01280_ssd_complex_key_dictionary\",\n-        \"01280_ttl_where_group_by_negative\",\n-        \"01280_ttl_where_group_by\",\n-        \"01280_unicode_whitespaces_lexer\",\n-        \"01292_create_user\",\n-        \"01293_create_role\",\n-        \"01293_pretty_max_value_width\",\n-        \"01293_show_clusters\",\n-        \"01293_show_settings\",\n-        \"01294_create_settings_profile\",\n-        \"01294_lazy_database_concurrent_recreate_reattach_and_show_tables_long\",\n-        \"01294_system_distributed_on_cluster\",\n-        \"01295_create_row_policy\",\n-        \"01296_create_row_policy_in_current_database\",\n-        \"01297_create_quota\",\n-        \"01308_row_policy_and_trivial_count_query\",\n-        \"01317_no_password_in_command_line\",\n-        \"01318_map_add_map_subtract\",\n-        \"01322_any_input_optimize\",\n-        \"01324_if_transform_strings_to_enum\",\n-        \"01337_mysql_global_variables\",\n-        \"01355_alter_column_with_order\",\n-        \"01355_ilike\",\n-        \"01373_is_zero_or_null\",\n-        \"01374_if_nullable_filimonov\",\n-        \"01378_alter_rename_with_ttl_zookeeper\",\n-        \"01379_with_fill_several_columns\",\n-        \"01397_in_bad_arguments\",\n-        \"01412_mod_float\",\n-        \"01415_table_function_view\",\n-        \"01417_freeze_partition_verbose_zookeeper\",\n-        \"01417_freeze_partition_verbose\",\n-        \"01418_custom_settings\",\n-        \"01419_merge_tree_settings_sanity_check\",\n-        \"01430_modify_sample_by_zookeeper\",\n-        \"01447_json_strings\",\n-        \"01449_json_compact_strings\",\n-        \"01451_detach_drop_part\",\n-        \"01451_replicated_detach_drop_and_quorum\",\n-        \"01451_replicated_detach_drop_part\",\n-        \"01457_create_as_table_function_structure\",\n-        \"01460_allow_dollar_and_number_in_identifier\",\n-        \"01463_test_alter_live_view_refresh\",\n-        \"01465_ttl_recompression\",\n-        \"01470_columns_transformers\",\n-        \"01470_columns_transformers2\",\n-        \"01470_explain\",\n-        \"01470_show_databases_like\",\n-        \"01470_test_insert_select_asterisk\",\n-        \"01475_read_subcolumns_2\",\n-        \"01475_read_subcolumns_3\",\n-        \"01475_read_subcolumns_storages\",\n-        \"01475_read_subcolumns\",\n-        \"01480_binary_operator_monotonicity\",\n-        \"01491_nested_multiline_comments\",\n-        \"01493_table_function_null\",\n-        \"01495_subqueries_in_with_statement_2\",\n-        \"01495_subqueries_in_with_statement_3\",\n-        \"01495_subqueries_in_with_statement\",\n-        \"01501_clickhouse_client_INSERT_exception\",\n-        \"01504_compression_multiple_streams\",\n-        \"01504_rocksdb\",\n-        \"01506_ttl_same_with_order_by\",\n-        \"01508_explain_header\",\n-        \"01508_partition_pruning_long\",\n-        \"01509_check_parallel_quorum_inserts_long\",\n-        \"01509_dictionary_preallocate\",\n-        \"01509_parallel_quorum_and_merge_long\",\n-        \"01515_mv_and_array_join_optimisation_bag\",\n-        \"01515_with_global_and_with_propagation\",\n-        \"01516_create_table_primary_key\",\n-        \"01517_drop_mv_with_inner_table\",\n-        \"01523_client_local_queries_file_parameter\",\n-        \"01523_interval_operator_support_string_literal\",\n-        \"01525_select_with_offset_fetch_clause\",\n-        \"01526_client_start_and_exit\",\n-        \"01527_dist_sharding_key_dictGet_reload\",\n-        \"01529_union_distinct_and_setting_union_default_mode\",\n-        \"01530_drop_database_atomic_sync\",\n-        \"01532_execute_merges_on_single_replica\",\n-        \"01532_primary_key_without_order_by_zookeeper\",\n-        \"01533_multiple_nested\",\n-        \"01541_max_memory_usage_for_user_long\",\n-        \"01551_mergetree_read_in_order_spread\",\n-        \"01552_dict_fixedstring\",\n-        \"01554_bloom_filter_index_big_integer_uuid\",\n-        \"01556_explain_select_with_union_query\",\n-        \"01561_aggregate_functions_of_key_with_join\",\n-        \"01562_optimize_monotonous_functions_in_order_by\",\n-        \"01568_window_functions_distributed\",\n-        \"01571_window_functions\",\n-        \"01576_alias_column_rewrite\",\n-        \"01581_deduplicate_by_columns_local\",\n-        \"01581_deduplicate_by_columns_replicated\",\n-        \"01582_any_join_supertype\",\n-        \"01582_distinct_optimization\",\n-        \"01590_countSubstrings\",\n-        \"01591_window_functions\",\n-        \"01592_long_window_functions1\",\n-        \"01592_window_functions\",\n-        \"01593_insert_settings\",\n-        \"01594_too_low_memory_limits\",\n-        \"01596_setting_limit_offset\",\n-        \"01600_log_queries_with_extensive_info\",\n-        \"01600_quota_by_forwarded_ip\",\n-        \"01601_detach_permanently\",\n-        \"01602_show_create_view\",\n-        \"01603_read_with_backoff_bug\",\n-        \"01604_explain_ast_of_nonselect_query\",\n-        \"01605_drop_settings_profile_while_assigned\",\n-        \"01605_skip_idx_compact_parts\",\n-        \"01606_git_import\",\n-        \"01606_merge_from_wide_to_compact\",\n-        \"01614_with_fill_with_limit\",\n-        \"01622_multiple_ttls\",\n-        \"01630_disallow_floating_point_as_partition_key\",\n-        \"01632_max_partitions_to_read\",\n-        \"01632_select_all_syntax\",\n-        \"01638_div_mod_ambiguities\",\n-        \"01642_if_nullable_regression\",\n-        \"01643_system_suspend\",\n-        \"01646_system_restart_replicas_smoke\",\n-        \"01650_drop_part_and_deduplication_zookeeper\",\n-        \"01650_fetch_patition_with_macro_in_zk_path\",\n-        \"01651_lc_insert_tiny_log\",\n-        \"01655_plan_optimizations\",\n-        \"01656_test_query_log_factories_info\",\n-        \"01658_values_ubsan\",\n-        \"01663_quantile_weighted_overflow\",\n-        \"01666_blns\",\n-        \"01666_merge_tree_max_query_limit\",\n-        \"01666_merge_tree_max_query_limit\",\n-        \"01674_clickhouse_client_query_param_cte\",\n-        \"01674_unicode_asan\",\n-        \"01676_dictget_in_default_expression\",\n-        \"01680_predicate_pushdown_union_distinct_subquery\",\n-        \"01681_cache_dictionary_simple_key\",\n-        \"01682_cache_dictionary_complex_key\",\n-        \"01683_flat_dictionary\",\n-        \"01684_ssd_cache_dictionary_simple_key\",\n-        \"01685_ssd_cache_dictionary_complex_key\",\n-        \"01686_rocksdb\",\n-        \"01699_timezoneOffset\",\n-        \"01702_bitmap_native_integers\",\n-        \"01702_system_query_log\",\n-        \"01710_projections\",\n-        \"01711_cte_subquery_fix\",\n-        \"01712_no_adaptive_granularity_vertical_merge\",\n-        \"01715_table_function_view_fix\",\n-        \"01720_dictionary_create_source_with_functions\",\n-        \"01720_union_distinct_with_limit\",\n-        \"01721_dictionary_decimal_p_s\",\n-        \"01721_engine_file_truncate_on_insert\",\n-        \"01730_distributed_group_by_no_merge_order_by_long\",\n-        \"01732_explain_syntax_union_query\",\n-        \"01732_union_and_union_all\",\n-        \"01747_join_view_filter_dictionary\",\n-        \"01748_dictionary_table_dot\",\n-        \"01753_direct_dictionary_simple_key\",\n-        \"01754_direct_dictionary_complex_key\",\n-        \"01756_optimize_skip_unused_shards_rewrite_in\",\n-        \"01757_optimize_skip_unused_shards_limit\",\n-        \"01759_dictionary_unique_attribute_names\",\n-        \"01760_polygon_dictionaries\",\n-        \"01760_system_dictionaries\",\n-        \"01763_long_ttl_group_by\",\n-        \"01765_hashed_dictionary_simple_key\",\n-        \"01766_hashed_dictionary_complex_key\",\n-        \"01774_tuple_null_in\",\n-        \"01778_hierarchical_dictionaries\",\n-        \"01778_mmap_cache_infra\",\n-        \"01780_clickhouse_dictionary_source_loop\",\n-        \"01781_merge_tree_deduplication\",\n-        \"01785_dictionary_element_count\",\n-        \"01786_explain_merge_tree\",\n-        \"01801_distinct_group_by_shard\",\n-        \"01802_rank_corr_mann_whitney_over_window\",\n-        \"01802_test_postgresql_protocol_with_row_policy\", /// It cannot parse DROP ROW POLICY\n-        \"01818_move_partition_simple\",\n-        \"01821_table_comment\",\n-        \"01823_explain_json\",\n-        \"01837_database_memory_ddl_dictionaries\",\n-        \"01839_join_to_subqueries_rewriter_columns_matcher\",\n-        \"01840_tupleElement_formatting_fuzzer\",\n-        \"01851_fix_row_policy_empty_result\",\n-        \"01851_hedged_connections_external_tables\",\n-        \"01852_cast_operator_bad_cases\",\n-        \"01852_cast_operator\",\n-        \"01861_explain_pipeline\",\n-        \"01868_order_by_fill_with_datetime64\",\n-        \"01870_buffer_flush\",\n-        \"01871_merge_tree_compile_expressions\",\n-        \"01872_functions_to_subcolumns\",\n-        \"01881_union_header_mismatch_bug\",\n-        \"01883_subcolumns_distributed\",\n-        \"01889_postgresql_protocol_null_fields\",\n-        \"01889_check_row_policy_defined_using_user_function\",\n-        \"01892_setting_limit_offset_distributed\",\n-        \"01902_dictionary_array_type\",\n-        \"01903_ssd_cache_dictionary_array_type\",\n-        \"01905_to_json_string\",\n-        \"01913_fix_column_transformer_replace_format\",\n-        \"01913_if_int_decimal\",\n-        \"01913_join_push_down_bug\",\n-        \"01921_with_fill_with_totals\",\n-        \"01924_argmax_bitmap_state\",\n-        \"01913_replace_dictionary\",\n-        \"01914_exchange_dictionaries\",\n-        \"01915_create_or_replace_dictionary\",\n-        \"01913_names_of_tuple_literal\",\n-        \"01925_merge_prewhere_table\",\n-        \"01932_null_valid_identifier\",\n-        \"01934_constexpr_aggregate_function_parameters\",\n-        \"01932_alter_index_with_order\",\n-        \"01936_quantiles_cannot_return_null\"\n-    ],\n     \"parallel\":\n     [\n         /// Pessimistic list of tests which work badly in parallel.\n",
  "problem_statement": "ANTLR parser: Missing column when casting with Postgresql style cast\n**Describe the bug**\r\n\r\nWhen using the antrl parser, using CAST on a column works:\r\n\r\n```\r\nSELECT CAST(type, 'String')\r\n:-] FROM system.query_log\r\n:-] ORDER BY event_time_microseconds DESC\r\n:-] LIMIT 1\r\n\r\nSELECT CAST(type, 'String')\r\nFROM system.query_log\r\nORDER BY event_time_microseconds DESC\r\nLIMIT 1\r\n\r\nQuery id: 2248ed6f-15b0-40b5-800d-5e49b7043c6a\r\n\r\n\u250c\u2500CAST(type, 'String')\u2500\u2510\r\n\u2502 ExceptionBeforeStart \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.041 sec. Processed 2.54 thousand rows, 22.83 KB (61.54 thousand rows/s., 553.90 KB/s.)\r\n```\r\n\r\nBut using `::` doesn't:\r\n\r\n```\r\nSELECT type::String\r\n:-] FROM system.query_log\r\n:-] ORDER BY event_time_microseconds DESC LIMIT 1;\r\n\r\nSELECT CAST(type, 'String')\r\nFROM system.query_log\r\nORDER BY event_time_microseconds DESC\r\nLIMIT 1\r\n\r\nQuery id: ecbf836d-7e3d-4694-8e2f-9eb56ea839ec\r\n\r\n\r\n0 rows in set. Elapsed: 0.007 sec. \r\n\r\nReceived exception from server (version 21.8.1):\r\nCode: 47. DB::Exception: Received from localhost:9000. DB::Exception: Missing columns: 'type' while processing query: 'SELECT type', required columns: 'type'.\r\n```\r\n\r\nAlthough the queries reported back by the backend are the same, the second one throws an exception.\r\n\r\n\r\n**Does it reproduce on recent release?**\r\n\r\n* master/HEAD: KO\r\n* v21.7.1.7020-testing: KO\r\n* v21.6.5.37-stable: KO\r\n\r\n**Expected behavior**\r\n\r\nBoth queries should work the same way (same as the production parser).\r\n\r\n**Additional context**\r\n\r\nThe production parser works fine in all tested releases (21.6, 21.7 and master).\r\n\n",
  "hints_text": "@Algunenano I'm wondering why do you use ANTLR parser? What are the benefits?\r\nDo you mind if ANTLR parser will be removed, say on Dec 31th, instead of being supported?\nI don't use it. I only discovered this because the CI complained about this while working on other things (https://github.com/ClickHouse/ClickHouse/pull/25714). To be honest I did try the Antrl parser + conversion from new to old for a different project and saw that it was ~10x slower so I wouldn't mind if it was removed tomorrow.",
  "created_at": "2021-07-03T15:56:48Z"
}