{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 70332,
  "instance_id": "ClickHouse__ClickHouse-70332",
  "issue_numbers": [
    "34130"
  ],
  "base_commit": "0f4990d2e79870970834fd30ce963d49ab502e73",
  "patch": "diff --git a/docs/ru/operations/settings/settings.md b/docs/ru/operations/settings/settings.md\nindex bbe1f0713819..222acc7aa4cc 100644\n--- a/docs/ru/operations/settings/settings.md\n+++ b/docs/ru/operations/settings/settings.md\n@@ -4215,3 +4215,9 @@ SELECT toFloat64('1.7091'), toFloat64('1.5008753E7') SETTINGS precise_float_pars\n \u2502              1.7091 \u2502                 15008753 \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n+\n+## push_external_roles_in_interserver_queries\n+\n+\u041f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0442\u044c \u0440\u043e\u043b\u0438 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u043e\u0442 \u0438\u043d\u0438\u0446\u0438\u0430\u0442\u043e\u0440\u0430 \u0437\u0430\u043f\u0440\u043e\u0441\u0430 \u0434\u0440\u0443\u0433\u0438\u043c \u043d\u043e\u0434\u0430\u043c \u043f\u0440\u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0438 \u0437\u0430\u043f\u0440\u043e\u0441\u0430.\n+\n+\u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e: `true`.\ndiff --git a/programs/client/Client.cpp b/programs/client/Client.cpp\nindex 05e1e61be7be..f78071b1278d 100644\n--- a/programs/client/Client.cpp\n+++ b/programs/client/Client.cpp\n@@ -220,7 +220,7 @@ std::vector<String> Client::loadWarningMessages()\n                           \"\" /* query_id */,\n                           QueryProcessingStage::Complete,\n                           &client_context->getSettingsRef(),\n-                          &client_context->getClientInfo(), false, {});\n+                          &client_context->getClientInfo(), false, {}, {});\n     while (true)\n     {\n         Packet packet = connection->receivePacket();\ndiff --git a/src/Access/ContextAccess.cpp b/src/Access/ContextAccess.cpp\nindex 06e89d783399..fd7803f1d27b 100644\n--- a/src/Access/ContextAccess.cpp\n+++ b/src/Access/ContextAccess.cpp\n@@ -366,6 +366,13 @@ void ContextAccess::setUser(const UserPtr & user_) const\n         current_roles_with_admin_option = user->granted_roles.findGrantedWithAdminOption(*params.current_roles);\n     }\n \n+    if (params.external_roles && !params.external_roles->empty())\n+    {\n+        current_roles.insert(current_roles.end(), params.external_roles->begin(), params.external_roles->end());\n+        auto new_granted_with_admin_option = user->granted_roles.findGrantedWithAdminOption(*params.external_roles);\n+        current_roles_with_admin_option.insert(current_roles_with_admin_option.end(), new_granted_with_admin_option.begin(), new_granted_with_admin_option.end());\n+    }\n+\n     subscription_for_roles_changes.reset();\n     enabled_roles = access_control->getEnabledRoles(current_roles, current_roles_with_admin_option);\n     subscription_for_roles_changes = enabled_roles->subscribeForChanges([weak_ptr = weak_from_this()](const std::shared_ptr<const EnabledRolesInfo> & roles_info_)\n@@ -516,7 +523,6 @@ std::optional<QuotaUsage> ContextAccess::getQuotaUsage() const\n     return getQuota()->getUsage();\n }\n \n-\n SettingsChanges ContextAccess::getDefaultSettings() const\n {\n     std::lock_guard lock{mutex};\ndiff --git a/src/Access/ContextAccessParams.cpp b/src/Access/ContextAccessParams.cpp\nindex f5a405c7bc13..4d86940b8422 100644\n--- a/src/Access/ContextAccessParams.cpp\n+++ b/src/Access/ContextAccessParams.cpp\n@@ -18,6 +18,7 @@ ContextAccessParams::ContextAccessParams(\n     bool full_access_,\n     bool use_default_roles_,\n     const std::shared_ptr<const std::vector<UUID>> & current_roles_,\n+    const std::shared_ptr<const std::vector<UUID>> & external_roles_,\n     const Settings & settings_,\n     const String & current_database_,\n     const ClientInfo & client_info_)\n@@ -25,6 +26,7 @@ ContextAccessParams::ContextAccessParams(\n     , full_access(full_access_)\n     , use_default_roles(use_default_roles_)\n     , current_roles(current_roles_)\n+    , external_roles(external_roles_)\n     , readonly(settings_[Setting::readonly])\n     , allow_ddl(settings_[Setting::allow_ddl])\n     , allow_introspection(settings_[Setting::allow_introspection_functions])\n@@ -59,6 +61,17 @@ String ContextAccessParams::toString() const\n         }\n         out << \"]\";\n     }\n+    if (external_roles && !external_roles->empty())\n+    {\n+        out << separator() << \"external_roles = [\";\n+        for (size_t i = 0; i != external_roles->size(); ++i)\n+        {\n+            if (i)\n+                out << \", \";\n+            out << (*external_roles)[i];\n+        }\n+        out << \"]\";\n+    }\n     if (readonly)\n         out << separator() << \"readonly = \" << readonly;\n     if (allow_ddl)\n@@ -107,6 +120,7 @@ bool operator ==(const ContextAccessParams & left, const ContextAccessParams & r\n     CONTEXT_ACCESS_PARAMS_EQUALS(full_access)\n     CONTEXT_ACCESS_PARAMS_EQUALS(use_default_roles)\n     CONTEXT_ACCESS_PARAMS_EQUALS(current_roles)\n+    CONTEXT_ACCESS_PARAMS_EQUALS(external_roles)\n     CONTEXT_ACCESS_PARAMS_EQUALS(readonly)\n     CONTEXT_ACCESS_PARAMS_EQUALS(allow_ddl)\n     CONTEXT_ACCESS_PARAMS_EQUALS(allow_introspection)\n@@ -157,6 +171,7 @@ bool operator <(const ContextAccessParams & left, const ContextAccessParams & ri\n     CONTEXT_ACCESS_PARAMS_LESS(full_access)\n     CONTEXT_ACCESS_PARAMS_LESS(use_default_roles)\n     CONTEXT_ACCESS_PARAMS_LESS(current_roles)\n+    CONTEXT_ACCESS_PARAMS_LESS(external_roles)\n     CONTEXT_ACCESS_PARAMS_LESS(readonly)\n     CONTEXT_ACCESS_PARAMS_LESS(allow_ddl)\n     CONTEXT_ACCESS_PARAMS_LESS(allow_introspection)\ndiff --git a/src/Access/ContextAccessParams.h b/src/Access/ContextAccessParams.h\nindex 07503a3af6de..82592d630dd2 100644\n--- a/src/Access/ContextAccessParams.h\n+++ b/src/Access/ContextAccessParams.h\n@@ -19,6 +19,7 @@ class ContextAccessParams\n         bool full_access_,\n         bool use_default_roles_,\n         const std::shared_ptr<const std::vector<UUID>> & current_roles_,\n+        const std::shared_ptr<const std::vector<UUID>> & external_roles_,\n         const Settings & settings_,\n         const String & current_database_,\n         const ClientInfo & client_info_);\n@@ -31,6 +32,7 @@ class ContextAccessParams\n \n     const bool use_default_roles;\n     const std::shared_ptr<const std::vector<UUID>> current_roles;\n+    const std::shared_ptr<const std::vector<UUID>> external_roles;\n \n     const UInt64 readonly;\n     const bool allow_ddl;\ndiff --git a/src/Access/LDAPAccessStorage.cpp b/src/Access/LDAPAccessStorage.cpp\nindex 2636a3cffbb7..97b7b1ac52e4 100644\n--- a/src/Access/LDAPAccessStorage.cpp\n+++ b/src/Access/LDAPAccessStorage.cpp\n@@ -26,7 +26,6 @@ namespace ErrorCodes\n     extern const int BAD_ARGUMENTS;\n }\n \n-\n LDAPAccessStorage::LDAPAccessStorage(const String & storage_name_, AccessControl & access_control_, const Poco::Util::AbstractConfiguration & config, const String & prefix)\n     : IAccessStorage(storage_name_), access_control(access_control_), memory_storage(storage_name_, access_control.getChangesNotifier(), false)\n {\n@@ -320,6 +319,10 @@ std::set<String> LDAPAccessStorage::mapExternalRolesNoLock(const LDAPClient::Sea\n {\n     std::set<String> role_names;\n \n+    // If this node can't access LDAP server (or has not privileges to fetch roles) and gets empty list of external roles\n+    if (external_roles.empty())\n+        return role_names;\n+\n     if (external_roles.size() != role_search_params.size())\n         throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Unable to map external roles\");\n \ndiff --git a/src/Client/ClientBase.cpp b/src/Client/ClientBase.cpp\nindex 5a6f05ac98e8..c0f5744a4d5a 100644\n--- a/src/Client/ClientBase.cpp\n+++ b/src/Client/ClientBase.cpp\n@@ -1121,6 +1121,7 @@ void ClientBase::processOrdinaryQuery(const String & query_to_execute, ASTPtr pa\n                     &client_context->getSettingsRef(),\n                     &client_context->getClientInfo(),\n                     true,\n+                    {},\n                     [&](const Progress & progress) { onProgress(progress); });\n \n                 if (send_external_tables)\n@@ -1624,6 +1625,7 @@ void ClientBase::processInsertQuery(const String & query_to_execute, ASTPtr pars\n         &client_context->getSettingsRef(),\n         &client_context->getClientInfo(),\n         true,\n+        {},\n         [&](const Progress & progress) { onProgress(progress); });\n \n     if (send_external_tables)\ndiff --git a/src/Client/Connection.cpp b/src/Client/Connection.cpp\nindex 8301eda93349..ace3c2fe9afb 100644\n--- a/src/Client/Connection.cpp\n+++ b/src/Client/Connection.cpp\n@@ -14,6 +14,7 @@\n #include <Client/ClientBase.h>\n #include <Client/Connection.h>\n #include <Client/ConnectionParameters.h>\n+#include \"Common/logger_useful.h\"\n #include <Common/ClickHouseRevision.h>\n #include <Common/Exception.h>\n #include <Common/NetException.h>\n@@ -22,8 +23,8 @@\n #include <Common/StringUtils.h>\n #include <Common/OpenSSLHelpers.h>\n #include <Common/randomSeed.h>\n-#include <Common/logger_useful.h>\n #include <Core/Block.h>\n+#include <Core/ProtocolDefines.h>\n #include <Interpreters/ClientInfo.h>\n #include <Interpreters/OpenTelemetrySpanLog.h>\n #include <Compression/CompressionFactory.h>\n@@ -752,6 +753,7 @@ void Connection::sendQuery(\n     const Settings * settings,\n     const ClientInfo * client_info,\n     bool with_pending_data,\n+    const std::vector<String> & external_roles,\n     std::function<void(const Progress &)>)\n {\n     OpenTelemetry::SpanHolder span(\"Connection::sendQuery()\", OpenTelemetry::SpanKind::CLIENT);\n@@ -824,6 +826,18 @@ void Connection::sendQuery(\n     else\n         writeStringBinary(\"\" /* empty string is a marker of the end of settings */, *out);\n \n+    String external_roles_str;\n+    if (server_revision >= DBMS_MIN_PROTOCOL_VERSION_WITH_INTERSERVER_EXTERNALLY_GRANTED_ROLES)\n+    {\n+        WriteBufferFromString buffer(external_roles_str);\n+        writeVectorBinary(external_roles, buffer);\n+        buffer.finalize();\n+\n+        LOG_TRACE(log_wrapper.get(), \"Sending external_roles with query: [{}] ({})\", fmt::join(external_roles, \", \"), external_roles.size());\n+\n+        writeStringBinary(external_roles_str, *out);\n+    }\n+\n     /// Interserver secret\n     if (server_revision >= DBMS_MIN_REVISION_WITH_INTERSERVER_SECRET)\n     {\n@@ -844,6 +858,9 @@ void Connection::sendQuery(\n             data += query;\n             data += query_id;\n             data += client_info->initial_user;\n+            // Also for backwards compatibility\n+            if (server_revision >= DBMS_MIN_PROTOCOL_VERSION_WITH_INTERSERVER_EXTERNALLY_GRANTED_ROLES)\n+                data += external_roles_str;\n             /// TODO: add source/target host/ip-address\n \n             std::string hash = encodeSHA256(data);\ndiff --git a/src/Client/Connection.h b/src/Client/Connection.h\nindex 5ecafe59faf2..ad43a7105759 100644\n--- a/src/Client/Connection.h\n+++ b/src/Client/Connection.h\n@@ -108,6 +108,7 @@ class Connection : public IServerConnection\n         const Settings * settings/* = nullptr */,\n         const ClientInfo * client_info/* = nullptr */,\n         bool with_pending_data/* = false */,\n+        const std::vector<String> & external_roles,\n         std::function<void(const Progress &)> process_progress_callback) override;\n \n     void sendCancel() override;\ndiff --git a/src/Client/HedgedConnections.cpp b/src/Client/HedgedConnections.cpp\nindex c30ca0eb9d49..6c2a1a88ee42 100644\n--- a/src/Client/HedgedConnections.cpp\n+++ b/src/Client/HedgedConnections.cpp\n@@ -161,7 +161,8 @@ void HedgedConnections::sendQuery(\n     const String & query_id,\n     UInt64 stage,\n     ClientInfo & client_info,\n-    bool with_pending_data)\n+    bool with_pending_data,\n+    const std::vector<String> & external_roles)\n {\n     std::lock_guard lock(cancel_mutex);\n \n@@ -188,7 +189,7 @@ void HedgedConnections::sendQuery(\n         hedged_connections_factory.skipReplicasWithTwoLevelAggregationIncompatibility();\n     }\n \n-    auto send_query = [this, timeouts, query, query_id, stage, client_info, with_pending_data](ReplicaState & replica)\n+    auto send_query = [this, timeouts, query, query_id, stage, client_info, with_pending_data, external_roles](ReplicaState & replica)\n     {\n         Settings modified_settings = settings;\n \n@@ -218,7 +219,8 @@ void HedgedConnections::sendQuery(\n         modified_settings.set(\"allow_experimental_analyzer\", static_cast<bool>(modified_settings[Setting::allow_experimental_analyzer]));\n \n         replica.connection->sendQuery(\n-            timeouts, query, /* query_parameters */ {}, query_id, stage, &modified_settings, &client_info, with_pending_data, {});\n+            timeouts, query, /* query_parameters */ {}, query_id, stage, &modified_settings, &client_info, with_pending_data, external_roles, {});\n+\n         replica.change_replica_timeout.setRelative(timeouts.receive_data_timeout);\n         replica.packet_receiver->setTimeout(hedged_connections_factory.getConnectionTimeouts().receive_timeout);\n     };\ndiff --git a/src/Client/HedgedConnections.h b/src/Client/HedgedConnections.h\nindex 7f538804e5a6..e64f17658d8b 100644\n--- a/src/Client/HedgedConnections.h\n+++ b/src/Client/HedgedConnections.h\n@@ -90,7 +90,8 @@ class HedgedConnections : public IConnections\n         const String & query_id,\n         UInt64 stage,\n         ClientInfo & client_info,\n-        bool with_pending_data) override;\n+        bool with_pending_data,\n+        const std::vector<String> & external_roles) override;\n \n     void sendReadTaskResponse(const String &) override\n     {\ndiff --git a/src/Client/IConnections.h b/src/Client/IConnections.h\nindex 09211de53b0a..a521fdd8b004 100644\n--- a/src/Client/IConnections.h\n+++ b/src/Client/IConnections.h\n@@ -23,7 +23,8 @@ class IConnections : boost::noncopyable\n         const String & query_id,\n         UInt64 stage,\n         ClientInfo & client_info,\n-        bool with_pending_data) = 0;\n+        bool with_pending_data,\n+        const std::vector<String> & external_roles) = 0;\n \n     virtual void sendReadTaskResponse(const String &) = 0;\n     virtual void sendMergeTreeReadTaskResponse(const ParallelReadResponse & response) = 0;\ndiff --git a/src/Client/IServerConnection.h b/src/Client/IServerConnection.h\nindex 98cb820f6ada..332481d27010 100644\n--- a/src/Client/IServerConnection.h\n+++ b/src/Client/IServerConnection.h\n@@ -100,6 +100,7 @@ class IServerConnection : boost::noncopyable\n         const Settings * settings,\n         const ClientInfo * client_info,\n         bool with_pending_data,\n+        const std::vector<String> & external_roles,\n         std::function<void(const Progress &)> process_progress_callback) = 0;\n \n     virtual void sendCancel() = 0;\ndiff --git a/src/Client/LocalConnection.cpp b/src/Client/LocalConnection.cpp\nindex 6e703a595308..bb36d0bbf39c 100644\n--- a/src/Client/LocalConnection.cpp\n+++ b/src/Client/LocalConnection.cpp\n@@ -106,6 +106,7 @@ void LocalConnection::sendQuery(\n     const Settings *,\n     const ClientInfo * client_info,\n     bool,\n+    const std::vector<String> & /*external_roles*/,\n     std::function<void(const Progress &)> process_progress_callback)\n {\n     /// Last query may not have been finished or cancelled due to exception on client side.\ndiff --git a/src/Client/LocalConnection.h b/src/Client/LocalConnection.h\nindex a70ed6ffa7ec..c605b37b075f 100644\n--- a/src/Client/LocalConnection.h\n+++ b/src/Client/LocalConnection.h\n@@ -114,6 +114,7 @@ class LocalConnection : public IServerConnection, WithContext\n         const Settings * settings/* = nullptr */,\n         const ClientInfo * client_info/* = nullptr */,\n         bool with_pending_data/* = false */,\n+        const std::vector<String> & external_roles,\n         std::function<void(const Progress &)> process_progress_callback) override;\n \n     void sendCancel() override;\ndiff --git a/src/Client/MultiplexedConnections.cpp b/src/Client/MultiplexedConnections.cpp\nindex 1cc6ec537c8f..c17a31b2d1c7 100644\n--- a/src/Client/MultiplexedConnections.cpp\n+++ b/src/Client/MultiplexedConnections.cpp\n@@ -128,7 +128,8 @@ void MultiplexedConnections::sendQuery(\n     const String & query_id,\n     UInt64 stage,\n     ClientInfo & client_info,\n-    bool with_pending_data)\n+    bool with_pending_data,\n+    const std::vector<String> & external_roles)\n {\n     std::lock_guard lock(cancel_mutex);\n \n@@ -181,14 +182,14 @@ void MultiplexedConnections::sendQuery(\n                 modified_settings[Setting::parallel_replica_offset] = i;\n \n             replica_states[i].connection->sendQuery(\n-                timeouts, query, /* query_parameters */ {}, query_id, stage, &modified_settings, &client_info, with_pending_data, {});\n+                timeouts, query, /* query_parameters */ {}, query_id, stage, &modified_settings, &client_info, with_pending_data, external_roles, {});\n         }\n     }\n     else\n     {\n         /// Use single replica.\n         replica_states[0].connection->sendQuery(\n-            timeouts, query, /* query_parameters */ {}, query_id, stage, &modified_settings, &client_info, with_pending_data, {});\n+            timeouts, query, /* query_parameters */ {}, query_id, stage, &modified_settings, &client_info, with_pending_data, external_roles, {});\n     }\n \n     sent_query = true;\ndiff --git a/src/Client/MultiplexedConnections.h b/src/Client/MultiplexedConnections.h\nindex dec32e52d4f8..4b308dca02e9 100644\n--- a/src/Client/MultiplexedConnections.h\n+++ b/src/Client/MultiplexedConnections.h\n@@ -36,7 +36,8 @@ class MultiplexedConnections final : public IConnections\n         const String & query_id,\n         UInt64 stage,\n         ClientInfo & client_info,\n-        bool with_pending_data) override;\n+        bool with_pending_data,\n+        const std::vector<String> & external_roles) override;\n \n     void sendReadTaskResponse(const String &) override;\n     void sendMergeTreeReadTaskResponse(const ParallelReadResponse & response) override;\ndiff --git a/src/Client/Suggest.cpp b/src/Client/Suggest.cpp\nindex 4f68ceecc37d..e8f5409a009c 100644\n--- a/src/Client/Suggest.cpp\n+++ b/src/Client/Suggest.cpp\n@@ -163,7 +163,7 @@ void Suggest::load(IServerConnection & connection,\n void Suggest::fetch(IServerConnection & connection, const ConnectionTimeouts & timeouts, const std::string & query, const ClientInfo & client_info)\n {\n     connection.sendQuery(\n-        timeouts, query, {} /* query_parameters */, \"\" /* query_id */, QueryProcessingStage::Complete, nullptr, &client_info, false, {});\n+        timeouts, query, {} /* query_parameters */, \"\" /* query_id */, QueryProcessingStage::Complete, nullptr, &client_info, false, {} /* external_roles*/, {});\n \n     while (true)\n     {\ndiff --git a/src/Core/ProtocolDefines.h b/src/Core/ProtocolDefines.h\nindex b68eff0aa5a1..cd89ca013eea 100644\n--- a/src/Core/ProtocolDefines.h\n+++ b/src/Core/ProtocolDefines.h\n@@ -90,6 +90,9 @@ static constexpr auto DBMS_MIN_PROTOCOL_VERSION_WITH_CHUNKED_PACKETS = 54470;\n \n static constexpr auto DBMS_MIN_REVISION_WITH_VERSIONED_PARALLEL_REPLICAS_PROTOCOL = 54471;\n \n+/// Push externally granted roles to other nodes\n+static constexpr auto DBMS_MIN_PROTOCOL_VERSION_WITH_INTERSERVER_EXTERNALLY_GRANTED_ROLES = 54472;\n+\n /// Version of ClickHouse TCP protocol.\n ///\n /// Should be incremented manually on protocol changes.\n@@ -97,6 +100,6 @@ static constexpr auto DBMS_MIN_REVISION_WITH_VERSIONED_PARALLEL_REPLICAS_PROTOCO\n /// NOTE: DBMS_TCP_PROTOCOL_VERSION has nothing common with VERSION_REVISION,\n /// later is just a number for server version (one number instead of commit SHA)\n /// for simplicity (sometimes it may be more convenient in some use cases).\n-static constexpr auto DBMS_TCP_PROTOCOL_VERSION = 54471;\n+static constexpr auto DBMS_TCP_PROTOCOL_VERSION = 54472;\n \n }\ndiff --git a/src/Core/Settings.cpp b/src/Core/Settings.cpp\nindex 0a34d1684133..c73d1861ca5b 100644\n--- a/src/Core/Settings.cpp\n+++ b/src/Core/Settings.cpp\n@@ -5727,6 +5727,9 @@ If enabled, MongoDB tables will return an error when a MongoDB query cannot be b\n Allow writing simple SELECT queries without the leading SELECT keyword, which makes it simple for calculator-style usage, e.g. `1 + 2` becomes a valid query.\n \n In `clickhouse-local` it is enabled by default and can be explicitly disabled.\n+)\", 0) \\\n+    DECLARE(Bool, push_external_roles_in_interserver_queries, true, R\"(\n+Enable pushing user roles from originator to other nodes while performing a query.\n )\", 0) \\\n     \\\n     \\\ndiff --git a/src/Core/SettingsChangesHistory.cpp b/src/Core/SettingsChangesHistory.cpp\nindex 5944de54142f..34a85eb5fafc 100644\n--- a/src/Core/SettingsChangesHistory.cpp\n+++ b/src/Core/SettingsChangesHistory.cpp\n@@ -86,6 +86,7 @@ static std::initializer_list<std::pair<ClickHouseVersion, SettingsChangesHistory\n             {\"filesystem_cache_prefer_bigger_buffer_size\", true, true, \"New setting\"},\n             {\"read_in_order_use_virtual_row\", false, false, \"Use virtual row while reading in order of primary key or its monotonic function fashion. It is useful when searching over multiple parts as only relevant ones are touched.\"},\n             {\"filesystem_cache_boundary_alignment\", 0, 0, \"New setting\"},\n+            {\"push_external_roles_in_interserver_queries\", false, false, \"New setting.\"},\n         }\n     },\n     {\"24.10\",\ndiff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp\nindex 15b4ca29996b..ce788842e3e4 100644\n--- a/src/Interpreters/Context.cpp\n+++ b/src/Interpreters/Context.cpp\n@@ -1493,7 +1493,7 @@ ConfigurationPtr Context::getUsersConfig()\n     return shared->users_config;\n }\n \n-void Context::setUser(const UUID & user_id_)\n+void Context::setUser(const UUID & user_id_, const std::vector<UUID> & external_roles_)\n {\n     /// Prepare lists of user's profiles, constraints, settings, roles.\n     /// NOTE: AccessControl::read<User>() and other AccessControl's functions may require some IO work,\n@@ -1508,7 +1508,6 @@ void Context::setUser(const UUID & user_id_)\n     const auto & database = user->default_database;\n \n     /// Apply user's profiles, constraints, settings, roles.\n-\n     std::lock_guard lock(mutex);\n \n     setUserIDWithLock(user_id_, lock);\n@@ -1518,6 +1517,7 @@ void Context::setUser(const UUID & user_id_)\n     setCurrentProfilesWithLock(*enabled_profiles, /* check_constraints= */ false, lock);\n \n     setCurrentRolesWithLock(default_roles, lock);\n+    setExternalRolesWithLock(external_roles_, lock);\n \n     /// It's optional to specify the DEFAULT DATABASE in the user's definition.\n     if (!database.empty())\n@@ -1561,6 +1561,18 @@ void Context::setCurrentRolesWithLock(const std::vector<UUID> & new_current_role\n     need_recalculate_access = true;\n }\n \n+void Context::setExternalRolesWithLock(const std::vector<UUID> & new_external_roles, const std::lock_guard<ContextSharedMutex> &)\n+{\n+    if (!new_external_roles.empty())\n+    {\n+        if (current_roles)\n+            current_roles->insert(current_roles->end(), new_external_roles.begin(), new_external_roles.end());\n+        else\n+            current_roles = std::make_shared<std::vector<UUID>>(new_external_roles);\n+        need_recalculate_access = true;\n+    }\n+}\n+\n void Context::setCurrentRolesImpl(const std::vector<UUID> & new_current_roles, bool throw_if_not_granted, bool skip_if_not_granted, const std::shared_ptr<const User> & user)\n {\n     if (skip_if_not_granted)\n@@ -1675,7 +1687,7 @@ std::shared_ptr<const ContextAccessWrapper> Context::getAccess() const\n         bool full_access = !user_id;\n \n         return ContextAccessParams{\n-            user_id, full_access, /* use_default_roles= */ false, current_roles, *settings, current_database, client_info};\n+            user_id, full_access, /* use_default_roles= */ false, current_roles, external_roles, *settings, current_database, client_info};\n     };\n \n     /// Check if the current access rights are still valid, otherwise get parameters for recalculating access rights.\ndiff --git a/src/Interpreters/Context.h b/src/Interpreters/Context.h\nindex e8ccc31f597c..327ac0af5fd3 100644\n--- a/src/Interpreters/Context.h\n+++ b/src/Interpreters/Context.h\n@@ -289,6 +289,7 @@ class ContextData\n \n     std::optional<UUID> user_id;\n     std::shared_ptr<std::vector<UUID>> current_roles;\n+    std::shared_ptr<std::vector<UUID>> external_roles;\n     std::shared_ptr<const SettingsConstraintsAndProfileIDs> settings_constraints_and_current_profiles;\n     mutable std::shared_ptr<const ContextAccess> access;\n     mutable bool need_recalculate_access = true;\n@@ -634,7 +635,7 @@ class Context: public ContextData, public std::enable_shared_from_this<Context>\n \n     /// Sets the current user assuming that he/she is already authenticated.\n     /// WARNING: This function doesn't check password!\n-    void setUser(const UUID & user_id_);\n+    void setUser(const UUID & user_id_, const std::vector<UUID> & external_roles_ = {});\n     UserPtr getUser() const;\n \n     std::optional<UUID> getUserID() const;\n@@ -1398,6 +1399,8 @@ class Context: public ContextData, public std::enable_shared_from_this<Context>\n \n     void setCurrentRolesWithLock(const std::vector<UUID> & new_current_roles, const std::lock_guard<ContextSharedMutex> & lock);\n \n+    void setExternalRolesWithLock(const std::vector<UUID> & new_external_roles, const std::lock_guard<ContextSharedMutex> & lock);\n+\n     void setSettingWithLock(std::string_view name, const String & value, const std::lock_guard<ContextSharedMutex> & lock);\n \n     void setSettingWithLock(std::string_view name, const Field & value, const std::lock_guard<ContextSharedMutex> & lock);\ndiff --git a/src/Interpreters/Session.cpp b/src/Interpreters/Session.cpp\nindex bc6555af5957..60a5b0a850f1 100644\n--- a/src/Interpreters/Session.cpp\n+++ b/src/Interpreters/Session.cpp\n@@ -6,6 +6,8 @@\n #include <Access/ContextAccess.h>\n #include <Access/SettingsProfilesInfo.h>\n #include <Access/User.h>\n+#include <Access/Role.h>\n+#include <Common/typeid_cast.h>\n #include <Common/logger_useful.h>\n #include <Common/Exception.h>\n #include <Common/ThreadPool.h>\n@@ -25,12 +27,12 @@\n #include <unordered_map>\n #include <vector>\n \n-\n namespace DB\n {\n namespace Setting\n {\n     extern const SettingsUInt64 max_sessions_for_user;\n+    extern const SettingsBool push_external_roles_in_interserver_queries;\n }\n \n namespace ErrorCodes\n@@ -288,7 +290,7 @@ void Session::shutdownNamedSessions()\n Session::Session(const ContextPtr & global_context_, ClientInfo::Interface interface_, bool is_secure, const std::string & certificate)\n     : auth_id(UUIDHelpers::generateV4()),\n       global_context(global_context_),\n-      log(getLogger(String{magic_enum::enum_name(interface_)} + \"-Session\"))\n+      log(getLogger(String{magic_enum::enum_name(interface_)} + \"-Session-\" + toString(auth_id)))\n {\n     prepared_client_info.emplace();\n     prepared_client_info->interface = interface_;\n@@ -342,12 +344,12 @@ std::unordered_set<AuthenticationType> Session::getAuthenticationTypesOrLogInFai\n     }\n }\n \n-void Session::authenticate(const String & user_name, const String & password, const Poco::Net::SocketAddress & address)\n+void Session::authenticate(const String & user_name, const String & password, const Poco::Net::SocketAddress & address, const Strings & external_roles_)\n {\n-    authenticate(BasicCredentials{user_name, password}, address);\n+    authenticate(BasicCredentials{user_name, password}, address, external_roles_);\n }\n \n-void Session::authenticate(const Credentials & credentials_, const Poco::Net::SocketAddress & address_)\n+void Session::authenticate(const Credentials & credentials_, const Poco::Net::SocketAddress & address_, const Strings & external_roles_)\n {\n     if (session_context)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"If there is a session context it must be created after authentication\");\n@@ -359,8 +361,8 @@ void Session::authenticate(const Credentials & credentials_, const Poco::Net::So\n     if ((address == Poco::Net::SocketAddress{}) && (prepared_client_info->interface == ClientInfo::Interface::LOCAL))\n         address = Poco::Net::SocketAddress{\"127.0.0.1\", 0};\n \n-    LOG_DEBUG(log, \"{} Authenticating user '{}' from {}\",\n-            toString(auth_id), credentials_.getUserName(), address.toString());\n+    LOG_DEBUG(log, \"Authenticating user '{}' from {}\",\n+            credentials_.getUserName(), address.toString());\n \n     try\n     {\n@@ -370,6 +372,14 @@ void Session::authenticate(const Credentials & credentials_, const Poco::Net::So\n         settings_from_auth_server = auth_result.settings;\n         LOG_DEBUG(log, \"{} Authenticated with global context as user {}\",\n                 toString(auth_id), toString(*user_id));\n+\n+        if (!external_roles_.empty() && global_context->getSettingsRef()[Setting::push_external_roles_in_interserver_queries])\n+        {\n+            external_roles = global_context->getAccessControl().find<Role>(external_roles_);\n+\n+            LOG_DEBUG(log, \"User {} has external_roles applied: [{}] ({})\",\n+                      toString(*user_id), fmt::join(external_roles_, \", \"), external_roles_.size());\n+        }\n     }\n     catch (const Exception & e)\n     {\n@@ -394,7 +404,7 @@ void Session::checkIfUserIsStillValid()\n \n void Session::onAuthenticationFailure(const std::optional<String> & user_name, const Poco::Net::SocketAddress & address_, const Exception & e)\n {\n-    LOG_DEBUG(log, \"{} Authentication failed with error: {}\", toString(auth_id), e.what());\n+    LOG_DEBUG(log, \"Authentication failed with error: {}\", e.what());\n     if (auto session_log = getSessionLog())\n     {\n         /// Add source address to the log\n@@ -520,8 +530,8 @@ ContextMutablePtr Session::makeSessionContext()\n     if (session_tracker_handle)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Session tracker handle was created before making session\");\n \n-    LOG_DEBUG(log, \"{} Creating session context with user_id: {}\",\n-            toString(auth_id), toString(*user_id));\n+    LOG_DEBUG(log, \"Creating session context with user_id: {}\",\n+            toString(*user_id));\n     /// Make a new session context.\n     ContextMutablePtr new_session_context;\n     new_session_context = Context::createCopy(global_context);\n@@ -532,7 +542,7 @@ ContextMutablePtr Session::makeSessionContext()\n     prepared_client_info.reset();\n \n     /// Set user information for the new context: current profiles, roles, access rights.\n-    new_session_context->setUser(*user_id);\n+    new_session_context->setUser(*user_id, external_roles);\n \n     /// Session context is ready.\n     session_context = new_session_context;\n@@ -563,8 +573,8 @@ ContextMutablePtr Session::makeSessionContext(const String & session_name_, std:\n     if (session_tracker_handle)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Session tracker handle was created before making session\");\n \n-    LOG_DEBUG(log, \"{} Creating named session context with name: {}, user_id: {}\",\n-            toString(auth_id), session_name_, toString(*user_id));\n+    LOG_DEBUG(log, \"Creating named session context with name: {}, user_id: {}\",\n+            session_name_, toString(*user_id));\n \n     /// Make a new session context OR\n     /// if the `session_id` and `user_id` were used before then just get a previously created session context.\n@@ -587,7 +597,7 @@ ContextMutablePtr Session::makeSessionContext(const String & session_name_, std:\n     /// Set user information for the new context: current profiles, roles, access rights.\n     if (!access->tryGetUser())\n     {\n-        new_session_context->setUser(*user_id);\n+        new_session_context->setUser(*user_id, external_roles);\n         max_sessions_for_user = new_session_context->getSettingsRef()[Setting::max_sessions_for_user];\n     }\n     else\n@@ -639,7 +649,7 @@ ContextMutablePtr Session::makeQueryContextImpl(const ClientInfo * client_info_t\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Query context must be created after authentication\");\n \n     /// We can create a query context either from a session context or from a global context.\n-    bool from_session_context = static_cast<bool>(session_context);\n+    const bool from_session_context = static_cast<bool>(session_context);\n \n     /// Create a new query context.\n     ContextMutablePtr query_context = Context::createCopy(from_session_context ? session_context : global_context);\n@@ -679,7 +689,7 @@ ContextMutablePtr Session::makeQueryContextImpl(const ClientInfo * client_info_t\n \n     /// Set user information for the new context: current profiles, roles, access rights.\n     if (user_id && !query_context->getAccess()->tryGetUser())\n-        query_context->setUser(*user_id);\n+        query_context->setUser(*user_id, external_roles);\n \n     /// Query context is ready.\n     query_context_created = true;\ndiff --git a/src/Interpreters/Session.h b/src/Interpreters/Session.h\nindex 0a20dd896a96..d29579649259 100644\n--- a/src/Interpreters/Session.h\n+++ b/src/Interpreters/Session.h\n@@ -10,6 +10,7 @@\n #include <memory>\n #include <mutex>\n #include <optional>\n+#include <vector>\n \n namespace Poco::Net { class SocketAddress; }\n \n@@ -50,8 +51,11 @@ class Session\n \n     /// Sets the current user, checks the credentials and that the specified address is allowed to connect from.\n     /// The function throws an exception if there is no such user or password is wrong.\n-    void authenticate(const String & user_name, const String & password, const Poco::Net::SocketAddress & address);\n-    void authenticate(const Credentials & credentials_, const Poco::Net::SocketAddress & address_);\n+    void authenticate(const String & user_name, const String & password, const Poco::Net::SocketAddress & address, const Strings & external_roles_ = {});\n+\n+    /// `external_roles_` names of the additional roles (over what is granted via local access control mechanisms) that would be granted to user during this session.\n+    /// Role is not granted if it can't be found by name via AccessControl (i.e. doesn't exist on this instance).\n+    void authenticate(const Credentials & credentials_, const Poco::Net::SocketAddress & address_, const Strings & external_roles_ = {});\n \n     // Verifies whether the user's validity extends beyond the current time.\n     // Throws an exception if the user's validity has expired.\n@@ -112,6 +116,7 @@ class Session\n \n     mutable UserPtr user;\n     std::optional<UUID> user_id;\n+    std::vector<UUID> external_roles;\n     AuthenticationData user_authenticated_with;\n \n     ContextMutablePtr session_context;\ndiff --git a/src/QueryPipeline/RemoteInserter.cpp b/src/QueryPipeline/RemoteInserter.cpp\nindex b958924f0085..d0c42a068af5 100644\n--- a/src/QueryPipeline/RemoteInserter.cpp\n+++ b/src/QueryPipeline/RemoteInserter.cpp\n@@ -56,8 +56,9 @@ RemoteInserter::RemoteInserter(\n     /** Send query and receive \"header\", that describes table structure.\n       * Header is needed to know, what structure is required for blocks to be passed to 'write' method.\n       */\n+    /// TODO (vnemkov): figure out should we pass additional roles in this case or not.\n     connection.sendQuery(\n-        timeouts, query, /* query_parameters */ {}, \"\", QueryProcessingStage::Complete, &settings, &modified_client_info, false, {});\n+        timeouts, query, /* query_parameters */ {}, \"\", QueryProcessingStage::Complete, &settings, &modified_client_info, false, /* external_roles */ {}, {});\n \n     while (true)\n     {\ndiff --git a/src/QueryPipeline/RemoteQueryExecutor.cpp b/src/QueryPipeline/RemoteQueryExecutor.cpp\nindex 5faae03bc8fd..41ab87e1a18b 100644\n--- a/src/QueryPipeline/RemoteQueryExecutor.cpp\n+++ b/src/QueryPipeline/RemoteQueryExecutor.cpp\n@@ -22,8 +22,12 @@\n #include <Client/MultiplexedConnections.h>\n #include <Client/HedgedConnections.h>\n #include <Storages/MergeTree/MergeTreeDataPartUUID.h>\n-#include <Storages/StorageMemory.h>\n #include <Storages/MergeTree/ParallelReplicasReadingCoordinator.h>\n+#include <Storages/StorageMemory.h>\n+\n+#include <Access/AccessControl.h>\n+#include <Access/User.h>\n+#include <Access/Role.h>\n \n namespace ProfileEvents\n {\n@@ -43,6 +47,7 @@ namespace Setting\n     extern const SettingsBool skip_unavailable_shards;\n     extern const SettingsOverflowMode timeout_overflow_mode;\n     extern const SettingsBool use_hedged_requests;\n+    extern const SettingsBool push_external_roles_in_interserver_queries;\n }\n \n namespace ErrorCodes\n@@ -398,7 +403,25 @@ void RemoteQueryExecutor::sendQueryUnlocked(ClientInfo::QueryKind query_kind, As\n     if (!duplicated_part_uuids.empty())\n         connections->sendIgnoredPartUUIDs(duplicated_part_uuids);\n \n-    connections->sendQuery(timeouts, query, query_id, stage, modified_client_info, true);\n+    // Collect all roles granted on this node and pass those to the remote node\n+    std::vector<String> local_granted_roles;\n+    if (context->getSettingsRef()[Setting::push_external_roles_in_interserver_queries] && !modified_client_info.initial_user.empty())\n+    {\n+        auto user = context->getAccessControl().read<User>(modified_client_info.initial_user, true);\n+        boost::container::flat_set<String> granted_roles;\n+        if (user)\n+        {\n+            const auto & access_control = context->getAccessControl();\n+            for (const auto & e : user->granted_roles.getElements())\n+            {\n+                auto names = access_control.readNames(e.ids);\n+                granted_roles.insert(names.begin(), names.end());\n+            }\n+        }\n+        local_granted_roles.insert(local_granted_roles.end(), granted_roles.begin(), granted_roles.end());\n+    }\n+\n+    connections->sendQuery(timeouts, query, query_id, stage, modified_client_info, true, local_granted_roles);\n \n     established = false;\n     sent_query = true;\ndiff --git a/src/Server/TCPHandler.cpp b/src/Server/TCPHandler.cpp\nindex d23449aced13..01f6af348c5d 100644\n--- a/src/Server/TCPHandler.cpp\n+++ b/src/Server/TCPHandler.cpp\n@@ -63,12 +63,17 @@\n \n #include <Core/Protocol.h>\n #include <Storages/MergeTree/RequestResponse.h>\n+#include <Interpreters/ClientInfo.h>\n+\n #include \"TCPHandler.h\"\n \n #include <Common/config_version.h>\n \n #include <fmt/format.h>\n \n+#include <fmt/ostream.h>\n+#include <Common/StringUtils.h>\n+\n using namespace std::literals;\n using namespace DB;\n \n@@ -1960,6 +1965,13 @@ void TCPHandler::processQuery(std::optional<QueryState> & state)\n     Settings passed_settings;\n     passed_settings.read(*in, settings_format);\n \n+    std::string received_extra_roles;\n+    // TODO: check if having `is_interserver_mode` doesn't break interoperability with the CH-client.\n+    if (client_tcp_protocol_version >= DBMS_MIN_PROTOCOL_VERSION_WITH_INTERSERVER_EXTERNALLY_GRANTED_ROLES)\n+    {\n+        readStringBinary(received_extra_roles, *in);\n+    }\n+\n     /// Interserver secret.\n     std::string received_hash;\n     if (client_tcp_protocol_version >= DBMS_MIN_REVISION_WITH_INTERSERVER_SECRET)\n@@ -2019,6 +2031,7 @@ void TCPHandler::processQuery(std::optional<QueryState> & state)\n         data += state->query;\n         data += state->query_id;\n         data += client_info.initial_user;\n+        data += received_extra_roles;\n \n         std::string calculated_hash = encodeSHA256(data);\n         assert(calculated_hash.size() == 32);\n@@ -2039,13 +2052,25 @@ void TCPHandler::processQuery(std::optional<QueryState> & state)\n         }\n         else\n         {\n+            // In a cluster, query originator may have an access to the external auth provider (like LDAP server),\n+            // that grants specific roles to the user. We want these roles to be granted to the user on other nodes of cluster when\n+            // query is executed.\n+            Strings external_roles;\n+            if (!received_extra_roles.empty())\n+            {\n+                ReadBufferFromString buffer(received_extra_roles);\n+\n+                readVectorBinary(external_roles, buffer);\n+                LOG_DEBUG(log, \"Parsed extra roles [{}]\", fmt::join(external_roles, \", \"));\n+            }\n+\n             LOG_DEBUG(log, \"User (initial, interserver mode): {} (client: {})\", client_info.initial_user, getClientAddress(client_info).toString());\n             /// In case of inter-server mode authorization is done with the\n             /// initial address of the client, not the real address from which\n             /// the query was come, since the real address is the address of\n             /// the initiator server, while we are interested in client's\n             /// address.\n-            session->authenticate(AlwaysAllowCredentials{client_info.initial_user}, client_info.initial_address);\n+            session->authenticate(AlwaysAllowCredentials{client_info.initial_user}, client_info.initial_address, external_roles);\n         }\n \n         is_interserver_authenticated = true;\n",
  "test_patch": "diff --git a/tests/integration/test_ldap_external_user_directory/configs/remote_servers.xml b/tests/integration/test_ldap_external_user_directory/configs/remote_servers.xml\nnew file mode 100644\nindex 000000000000..cf1bdf9dcb19\n--- /dev/null\n+++ b/tests/integration/test_ldap_external_user_directory/configs/remote_servers.xml\n@@ -0,0 +1,18 @@\n+<clickhouse>\n+    <remote_servers>\n+        <test_ldap_cluster>\n+            <shard>\n+                <replica>\n+                    <host>instance1</host>\n+                    <port>9000</port>\n+                </replica>\n+            </shard>\n+            <shard>\n+                <replica>\n+                    <host>instance2</host>\n+                    <port>9000</port>\n+                </replica>\n+            </shard>\n+        </test_ldap_cluster>\n+    </remote_servers>\n+</clickhouse>\n\\ No newline at end of file\ndiff --git a/tests/integration/test_ldap_external_user_directory/test.py b/tests/integration/test_ldap_external_user_directory/test.py\nindex 6c25c0ac7895..ce16d7ad2862 100644\n--- a/tests/integration/test_ldap_external_user_directory/test.py\n+++ b/tests/integration/test_ldap_external_user_directory/test.py\n@@ -9,8 +9,22 @@\n LDAP_ADMIN_PASSWORD = \"clickhouse\"\n \n cluster = ClickHouseCluster(__file__)\n-instance = cluster.add_instance(\n-    \"instance\", main_configs=[\"configs/ldap_with_role_mapping.xml\"], with_ldap=True\n+\n+instance1 = cluster.add_instance(\n+    \"instance1\",\n+    main_configs=[\"configs/ldap_with_role_mapping.xml\", \"configs/remote_servers.xml\"],\n+    macros={\"shard\": 1, \"replica\": \"instance1\"},\n+    stay_alive=True,\n+    with_ldap=True,\n+    with_zookeeper=True,\n+)\n+\n+instance2 = cluster.add_instance(\n+    \"instance2\",\n+    main_configs=[\"configs/remote_servers.xml\"],\n+    macros={\"shard\": 1, \"replica\": \"instance2\"},\n+    stay_alive=True,\n+    with_zookeeper=True,\n )\n \n \n@@ -74,59 +88,98 @@ def delete_ldap_group(ldap_cluster, group_cn):\n \n \n def test_authentication_pass():\n-    assert instance.query(\n+    assert instance1.query(\n         \"SELECT currentUser()\", user=\"janedoe\", password=\"qwerty\"\n     ) == TSV([[\"janedoe\"]])\n \n \n def test_authentication_fail():\n     # User doesn't exist.\n-    assert \"doesnotexist: Authentication failed\" in instance.query_and_get_error(\n+    assert \"doesnotexist: Authentication failed\" in instance1.query_and_get_error(\n         \"SELECT currentUser()\", user=\"doesnotexist\"\n     )\n \n     # Wrong password.\n-    assert \"janedoe: Authentication failed\" in instance.query_and_get_error(\n+    assert \"janedoe: Authentication failed\" in instance1.query_and_get_error(\n         \"SELECT currentUser()\", user=\"janedoe\", password=\"123\"\n     )\n \n \n def test_role_mapping(ldap_cluster):\n-    instance.query(\"DROP ROLE IF EXISTS role_1\")\n-    instance.query(\"DROP ROLE IF EXISTS role_2\")\n-    instance.query(\"DROP ROLE IF EXISTS role_3\")\n-    instance.query(\"CREATE ROLE role_1\")\n-    instance.query(\"CREATE ROLE role_2\")\n+    instance1.query(\"DROP ROLE IF EXISTS role_1\")\n+    instance1.query(\"DROP ROLE IF EXISTS role_2\")\n+    instance1.query(\"DROP ROLE IF EXISTS role_3\")\n+    instance1.query(\"CREATE ROLE role_1\")\n+    instance1.query(\"CREATE ROLE role_2\")\n     add_ldap_group(ldap_cluster, group_cn=\"clickhouse-role_1\", member_cn=\"johndoe\")\n     add_ldap_group(ldap_cluster, group_cn=\"clickhouse-role_2\", member_cn=\"johndoe\")\n \n-    assert instance.query(\n+    assert instance1.query(\n         \"select currentUser()\", user=\"johndoe\", password=\"qwertz\"\n     ) == TSV([[\"johndoe\"]])\n \n-    assert instance.query(\n+    assert instance1.query(\n         \"select role_name from system.current_roles ORDER BY role_name\",\n         user=\"johndoe\",\n         password=\"qwertz\",\n     ) == TSV([[\"role_1\"], [\"role_2\"]])\n \n-    instance.query(\"CREATE ROLE role_3\")\n+    instance1.query(\"CREATE ROLE role_3\")\n     add_ldap_group(ldap_cluster, group_cn=\"clickhouse-role_3\", member_cn=\"johndoe\")\n     # Check that non-existing role in ClickHouse is ignored during role update\n     # See https://github.com/ClickHouse/ClickHouse/issues/54318\n     add_ldap_group(ldap_cluster, group_cn=\"clickhouse-role_4\", member_cn=\"johndoe\")\n \n-    assert instance.query(\n+    assert instance1.query(\n         \"select role_name from system.current_roles ORDER BY role_name\",\n         user=\"johndoe\",\n         password=\"qwertz\",\n     ) == TSV([[\"role_1\"], [\"role_2\"], [\"role_3\"]])\n \n-    instance.query(\"DROP ROLE role_1\")\n-    instance.query(\"DROP ROLE role_2\")\n-    instance.query(\"DROP ROLE role_3\")\n+    instance1.query(\"DROP ROLE role_1\")\n+    instance1.query(\"DROP ROLE role_2\")\n+    instance1.query(\"DROP ROLE role_3\")\n \n     delete_ldap_group(ldap_cluster, group_cn=\"clickhouse-role_1\")\n     delete_ldap_group(ldap_cluster, group_cn=\"clickhouse-role_2\")\n     delete_ldap_group(ldap_cluster, group_cn=\"clickhouse-role_3\")\n     delete_ldap_group(ldap_cluster, group_cn=\"clickhouse-role_4\")\n+\n+\n+def test_push_role_to_other_nodes(ldap_cluster):\n+    instance1.query(\"DROP TABLE IF EXISTS distributed_table SYNC\")\n+    instance1.query(\"DROP TABLE IF EXISTS local_table SYNC\")\n+    instance2.query(\"DROP TABLE IF EXISTS local_table SYNC\")\n+    instance1.query(\"DROP ROLE IF EXISTS role_read\")\n+\n+    instance1.query(\"CREATE ROLE role_read\")\n+    instance1.query(\"GRANT SELECT ON *.* TO role_read\")\n+\n+    add_ldap_group(ldap_cluster, group_cn=\"clickhouse-role_read\", member_cn=\"johndoe\")\n+\n+    assert instance1.query(\n+        \"select currentUser()\", user=\"johndoe\", password=\"qwertz\"\n+    ) == TSV([[\"johndoe\"]])\n+\n+    instance1.query(\n+        \"CREATE TABLE IF NOT EXISTS local_table (id UInt32) ENGINE = MergeTree() ORDER BY id\"\n+    )\n+    instance2.query(\n+        \"CREATE TABLE IF NOT EXISTS local_table (id UInt32) ENGINE = MergeTree() ORDER BY id\"\n+    )\n+    instance2.query(\"INSERT INTO local_table VALUES (1), (2), (3)\")\n+    instance1.query(\n+        \"CREATE TABLE IF NOT EXISTS distributed_table AS local_table ENGINE = Distributed(test_ldap_cluster, default, local_table)\"\n+    )\n+\n+    result = instance1.query(\n+        \"SELECT sum(id) FROM distributed_table\", user=\"johndoe\", password=\"qwertz\"\n+    )\n+    assert result.strip() == \"6\"\n+\n+    instance1.query(\"DROP TABLE IF EXISTS distributed_table SYNC\")\n+    instance1.query(\"DROP TABLE IF EXISTS local_table SYNC\")\n+    instance2.query(\"DROP TABLE IF EXISTS local_table SYNC\")\n+    instance2.query(\"DROP ROLE IF EXISTS role_read\")\n+\n+    delete_ldap_group(ldap_cluster, group_cn=\"clickhouse-role_read\")\n",
  "problem_statement": "LDAP: authentication with configured role mapping fails on a cluster with a secret\nWhen ClickHouse server is configured as a part of a cluster with a secret, and there is an LDAP user directory with a role mapping, authentications for users from that directory fails.\r\n\r\nIf the `<secret>` is removed from the cluster config, or role mapping is disabled for LDAP user directory, users are authenticated successfully.\n",
  "hints_text": "@azat is the author of the `<secret>` feature.\n@traceon can you write an integration test please? It will help a lot.\n@azat Yes, that's the plan.\r\n\r\n@vzakaznikov can we write a test for this case upfront, in TestFlows? This will really help to debug/implement this issue.\r\n\r\nRelated: #13156\nYes, I'm working on developing extra tests that combine LDAP + secret.\n@traceon, tests have been added per your request in (https://github.com/ClickHouse/ClickHouse/pull/34513). \n@azat have you had a chance to reproduce using the tests above?\n@traceon the issue is clear, but I haven't had a chance to look into it yet, if this is urgent for you and you want to fix this by yourself, please go ahead!\nstarted working on it\n> started working on it\r\n\r\nNot finished working on it.\n> Not finished working on it.\r\n\r\nStarted finishing working on this in #70332",
  "created_at": "2024-10-03T16:13:49Z",
  "modified_files": [
    "docs/ru/operations/settings/settings.md",
    "programs/client/Client.cpp",
    "src/Access/ContextAccess.cpp",
    "src/Access/ContextAccessParams.cpp",
    "src/Access/ContextAccessParams.h",
    "src/Access/LDAPAccessStorage.cpp",
    "src/Client/ClientBase.cpp",
    "src/Client/Connection.cpp",
    "src/Client/Connection.h",
    "src/Client/HedgedConnections.cpp",
    "src/Client/HedgedConnections.h",
    "src/Client/IConnections.h",
    "src/Client/IServerConnection.h",
    "src/Client/LocalConnection.cpp",
    "src/Client/LocalConnection.h",
    "src/Client/MultiplexedConnections.cpp",
    "src/Client/MultiplexedConnections.h",
    "src/Client/Suggest.cpp",
    "src/Core/ProtocolDefines.h",
    "src/Core/Settings.cpp",
    "src/Core/SettingsChangesHistory.cpp",
    "src/Interpreters/Context.cpp",
    "src/Interpreters/Context.h",
    "src/Interpreters/Session.cpp",
    "src/Interpreters/Session.h",
    "src/QueryPipeline/RemoteInserter.cpp",
    "src/QueryPipeline/RemoteQueryExecutor.cpp",
    "src/Server/TCPHandler.cpp"
  ],
  "modified_test_files": [
    "b/tests/integration/test_ldap_external_user_directory/configs/remote_servers.xml",
    "tests/integration/test_ldap_external_user_directory/test.py"
  ]
}