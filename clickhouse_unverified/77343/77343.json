{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 77343,
  "instance_id": "ClickHouse__ClickHouse-77343",
  "issue_numbers": [
    "76976"
  ],
  "base_commit": "efc02d7ab262cf5d29da6fc93277738a3e92b71a",
  "patch": "diff --git a/src/Planner/Planner.cpp b/src/Planner/Planner.cpp\nindex d24aebafa181..f165cb1b28e7 100644\n--- a/src/Planner/Planner.cpp\n+++ b/src/Planner/Planner.cpp\n@@ -743,15 +743,17 @@ void addWithFillStepIfNeeded(QueryPlan & query_plan,\n     const PlannerContextPtr & planner_context,\n     const QueryNode & query_node)\n {\n-    const auto & sort_description = query_analysis_result.sort_description;\n-\n     NameSet column_names_with_fill;\n     SortDescription fill_description;\n \n-    for (const auto & description : sort_description)\n+    const auto & header = query_plan.getCurrentHeader();\n+\n+    for (const auto & description : query_analysis_result.sort_description)\n     {\n         if (description.with_fill)\n         {\n+            if (!header.findByName(description.column_name))\n+                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Filling column {} is not present in the block {}\", description.column_name, header.dumpNames());\n             fill_description.push_back(description);\n             column_names_with_fill.insert(description.column_name);\n         }\n@@ -765,7 +767,7 @@ void addWithFillStepIfNeeded(QueryPlan & query_plan,\n     if (query_node.hasInterpolate())\n     {\n         ActionsDAG interpolate_actions_dag;\n-        auto query_plan_columns = query_plan.getCurrentHeader().getColumnsWithTypeAndName();\n+        auto query_plan_columns = header.getColumnsWithTypeAndName();\n         for (auto & query_plan_column : query_plan_columns)\n         {\n             /// INTERPOLATE actions dag input columns must be non constant\n@@ -831,9 +833,15 @@ void addWithFillStepIfNeeded(QueryPlan & query_plan,\n                 /// To fix this, we prepend a rename : 'Hello'_String -> s\n                 if (const auto * /*constant_node*/ _ = interpolate_node_typed.getExpression()->as<const ConstantNode>())\n                 {\n+                    const auto & name = interpolate_node_typed.getExpressionName();\n                     const auto * node = &rename_dag.addInput(alias_node->result_name, alias_node->result_type);\n-                    node = &rename_dag.addAlias(*node, interpolate_node_typed.getExpressionName());\n+                    node = &rename_dag.addAlias(*node, name);\n                     rename_dag.getOutputs().push_back(node);\n+\n+                    /// Interpolate DAG should contain INPUT with same name to ensure a proper merging\n+                    const auto & inputs = interpolate_actions_dag.getInputs();\n+                    if (std::ranges::find_if(inputs, [&name](const auto & input){ return input->result_name == name; }) == inputs.end())\n+                        interpolate_actions_dag.addInput(name, interpolate_node_typed.getExpression()->getResultType());\n                 }\n             }\n \n@@ -850,8 +858,8 @@ void addWithFillStepIfNeeded(QueryPlan & query_plan,\n     const auto & query_context = planner_context->getQueryContext();\n     const Settings & settings = query_context->getSettingsRef();\n     auto filling_step = std::make_unique<FillingStep>(\n-        query_plan.getCurrentHeader(),\n-        sort_description,\n+        header,\n+        query_analysis_result.sort_description,\n         std::move(fill_description),\n         interpolate_description,\n         settings[Setting::use_with_fill_by_sorting_prefix]);\ndiff --git a/src/Processors/Transforms/FillingTransform.cpp b/src/Processors/Transforms/FillingTransform.cpp\nindex 82e5f9b7844a..fd5865dae880 100644\n--- a/src/Processors/Transforms/FillingTransform.cpp\n+++ b/src/Processors/Transforms/FillingTransform.cpp\n@@ -206,12 +206,14 @@ static bool tryConvertFields(FillColumnDescription & descr, const DataTypePtr &\n     return true;\n }\n \n-SortDescription duduplicateSortDescription(const SortDescription & sort_description)\n+SortDescription deduplicateSortDescription(const SortDescription & sort_description, const Block & header)\n {\n     SortDescription result;\n     std::unordered_set<std::string> unique_columns;\n     for (const auto & desc : sort_description)\n     {\n+        if (header.findByName(desc.column_name) == nullptr)\n+            continue;\n         const auto & [_, inserted] = unique_columns.insert(desc.column_name);\n         if (!inserted)\n             continue;\n@@ -227,7 +229,7 @@ FillingTransform::FillingTransform(\n     InterpolateDescriptionPtr interpolate_description_,\n     const bool use_with_fill_by_sorting_prefix_)\n     : ISimpleTransform(header_, transformHeader(header_, fill_description_), true)\n-    , sort_description(duduplicateSortDescription(sort_description_))\n+    , sort_description(deduplicateSortDescription(sort_description_, header_))\n     , fill_description(fill_description_)\n     , interpolate_description(interpolate_description_)\n     , filling_row(fill_description_)\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03366_with_fill_dag.reference b/tests/queries/0_stateless/03366_with_fill_dag.reference\nnew file mode 100644\nindex 000000000000..a1c69bb348dc\n--- /dev/null\n+++ b/tests/queries/0_stateless/03366_with_fill_dag.reference\n@@ -0,0 +1,14 @@\n+0\n+1\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+9\n+0\t1\n+1\t1\n+2\t1\n+3\t1\ndiff --git a/tests/queries/0_stateless/03366_with_fill_dag.sql b/tests/queries/0_stateless/03366_with_fill_dag.sql\nnew file mode 100644\nindex 000000000000..32f7e92f5ce3\n--- /dev/null\n+++ b/tests/queries/0_stateless/03366_with_fill_dag.sql\n@@ -0,0 +1,16 @@\n+SELECT number\n+FROM numbers(10)\n+ORDER BY\n+    number ASC WITH FILL STEP 1,\n+    'aaa' ASC\n+LIMIT 1 BY number;\n+\n+WITH 1 AS one\n+SELECT\n+    number AS num,\n+    one\n+FROM numbers(4)\n+ORDER BY\n+    num ASC WITH FILL STEP 1,\n+    one ASC\n+INTERPOLATE ( one AS 42 );\n",
  "problem_statement": "NOT_FOUND_COLUMN_IN_BLOCK error with new analyzer\n### Company or project name\n\ncogniteev\n\n### Describe what's wrong\n\nNew query analyzer (enabled  by default) fails to execute a query.\n\n### Does it reproduce on the most recent release?\n\nYes\n\n### How to reproduce\n\nTested with `24.8.4.13` (version I'm using in production) and `25.1.5.31` (latest release at this time).\n\n\nThe following query:\n```sql\nWITH\n    count(1) AS rows_count\nSELECT\n    toDate(parseDateTimeBestEffortUSOrZero(toString(fetch_date))) AS fetch_date\nFROM\n    s3('https://clickhouse-public-datasets.s3.amazonaws.com/youtube/original/files/*.zst', 'JSONLines')\nGROUP BY\n    fetch_date\nORDER BY\n    fetch_date WITH FILL STEP INTERVAL 1 DAY,\n    rows_count DESC\nLIMIT 1 BY fetch_date\n```\n\nFails with:\n\n```\nReceived exception from server (version 25.1.5):\nCode: 10. DB::Exception: Received from localhost:9000. DB::Exception: Not found column count() in block. There are only columns: toDate(parseDateTimeBestEffortUSOrZero(toString(__table1.fetch_date))). (NOT_FOUND_COLUMN_IN_BLOCK)\n```\n\n\n### Expected behavior\n\nExpect the query to work.\n\n### Error message and/or stacktrace\n\n_No response_\n\n### Additional context\n\nAny one of those actions will \"resolve\" the error by itself:\n\n- set `allow_experimental_analyzer=0`\n- remove `BY fetch_date` in `LIMIT` clause\n- remove `WITH FILL STEP` clause\n- move `rows_count` in `SELECT` clause\n\n\nMaybe the cause is related to either https://github.com/ClickHouse/ClickHouse/issues/70356 or https://github.com/ClickHouse/ClickHouse/issues/76121 but I created a new issue because I can reproduce it without distributed table or parallel reading from replicas (although I do use it in my original use case)\n\n\n\n",
  "hints_text": "simplified:\n```\nWITH 1 AS one\nSELECT number FROM numbers(10)\nORDER BY\n    number WITH FILL STEP 1,\n    one\nLIMIT 1 BY number;\n\nReceived exception:\nCode: 10. DB::Exception: Not found column 1_UInt8 in block. There are only columns: __table1.number. (NOT_FOUND_COLUMN_IN_BLOCK)\n```",
  "created_at": "2025-03-08T18:17:05Z"
}