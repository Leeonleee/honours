{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 78176,
  "instance_id": "ClickHouse__ClickHouse-78176",
  "issue_numbers": [
    "65694"
  ],
  "base_commit": "c2d4808e8c766679a150c7c7c8bcd5b10f2f3607",
  "patch": "diff --git a/ci/jobs/scripts/check_style/aspell-ignore/en/aspell-dict.txt b/ci/jobs/scripts/check_style/aspell-ignore/en/aspell-dict.txt\nindex 76025bdbe300..fcb7d45c00fd 100644\n--- a/ci/jobs/scripts/check_style/aspell-ignore/en/aspell-dict.txt\n+++ b/ci/jobs/scripts/check_style/aspell-ignore/en/aspell-dict.txt\n@@ -2768,6 +2768,10 @@ socketcache\n soundex\n sparkBar\n sparkbar\n+sparseGrams\n+sparseGramsHashes\n+sparseGramsHashesUTF\n+sparseGramsUTF\n sparsehash\n speedscope\n splitBy\ndiff --git a/docs/en/sql-reference/functions/string-functions.md b/docs/en/sql-reference/functions/string-functions.md\nindex c413f59ae9a3..207e551da385 100644\n--- a/docs/en/sql-reference/functions/string-functions.md\n+++ b/docs/en/sql-reference/functions/string-functions.md\n@@ -2497,3 +2497,143 @@ Result:\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## sparseGrams {#sparsegrams}\n+\n+Finds all substrings of a given string that have a length of at least `n`, \n+where the hashes of the (n-1)-grams at the borders of the substring\n+are strictly greater than those of any (n-1)-gram inside the substring.\n+Uses [crc32](./string-functions.md#crc32) as a hash function.\n+\n+**Syntax**\n+\n+```sql\n+sparseGrams(s[, min_ngram_length]);\n+```\n+\n+**Arguments**\n+\n+- `s` \u2014 An input string. [String](../data-types/string.md)\n+- `min_ngram_length` \u2014 The minimum length of extracted ngram. The default and minimal value is 3.\n+- `max_ngram_length` \u2014 The maximum length of extracted ngram. The default value is 100. Should be not less than 'min_ngram_length'\n+\n+**Returned value**\n+\n+- An array of selected substrings. [Array](../data-types/array.md)([String](../data-types/string.md)).\n+\n+**Example**\n+\n+```sql\n+SELECT sparseGrams('alice', 3) AS result\n+```\n+Result:\n+```result\n+   \u250c\u2500result\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+1. \u2502 ['ali','lic','lice','ice'] \u2502\n+   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## sparseGramsUTF8 {#sparsegramsutf8}\n+\n+Finds all substrings of a given string that have a length of at least `n`,\n+where the hashes of the (n-1)-grams at the borders of the substring\n+are strictly greater than those of any (n-1)-gram inside the substring.\n+Uses [crc32](./string-functions.md#crc32) as a hash function.\n+Expects UTF-8 string, throws an exception in case of invalid UTF-8 sequence.\n+\n+**Syntax**\n+\n+```sql\n+sparseGramsUTF8(s[, min_ngram_length]);\n+```\n+\n+**Arguments**\n+\n+- `s` \u2014 An input string. [String](../data-types/string.md)\n+- `min_ngram_length` \u2014 The minimum length of extracted ngram. The default and minimal value is 3.\n+- `max_ngram_length` \u2014 The maximum length of extracted ngram. The default value is 100. Should be not less than 'min_ngram_length'\n+\n+**Returned value**\n+\n+- An array of selected substrings. [Array](../data-types/array.md)([String](../data-types/string.md)).\n+\n+**Example**\n+\n+```sql\n+SELECT sparseGramsUTF8('\u0430\u043b\u0438\u0441\u0430', 3) AS result\n+```\n+Result:\n+```result\n+   \u250c\u2500result\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+1. \u2502 ['\u0430\u043b\u0438','\u043b\u0438\u0441','\u0438\u0441\u0430'] \u2502\n+   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+## sparseGramsHashes {#sparsegramshashes}\n+\n+Finds hashes of all substrings of a given string that have a length of at least `n`,\n+where the hashes of the (n-1)-grams at the borders of the substring\n+are strictly greater than those of any (n-1)-gram inside the substring.\n+Uses [crc32](./string-functions.md#crc32) as a hash function.\n+\n+**Syntax**\n+\n+```sql\n+sparseGramsHashes(s[, min_ngram_length]);\n+```\n+\n+**Arguments**\n+\n+- `s` \u2014 An input string. [String](../data-types/string.md)\n+- `min_ngram_length` \u2014 The minimum length of extracted ngram. The default and minimal value is 3.\n+- `max_ngram_length` \u2014 The maximum length of extracted ngram. The default value is 100. Should be not less than 'min_ngram_length'\n+\n+**Returned value**\n+\n+- An array of selected substrings crc32-c hashes. [Array](../data-types/array.md)([UInt32](../data-types/int-uint.md)).\n+\n+**Example**\n+\n+```sql\n+SELECT sparseGramsHashes('alice', 3) AS result\n+```\n+Result:\n+```result\n+   \u250c\u2500result\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+1. \u2502 [1265796434,3725069146,1689963195,3410985998] \u2502\n+   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## sparseGramsHashesUTF8 {#sparsegramshashesutf8}\n+\n+Finds hashes of all substrings of a given string that have a length of at least `n`,\n+where the hashes of the (n-1)-grams at the borders of the substring\n+are strictly greater than those of any (n-1)-gram inside the substring.\n+Uses [crc32](./string-functions.md#crc32) as a hash function.\n+Expects UTF-8 string, throws an exception in case of invalid UTF-8 sequence.\n+\n+**Syntax**\n+\n+```sql\n+sparseGramsUTF8(s[, min_ngram_length]);\n+```\n+\n+**Arguments**\n+\n+- `s` \u2014 An input string. [String](../data-types/string.md)\n+- `min_ngram_length` \u2014 The minimum length of extracted ngram. The default and minimal value is 3.\n+- `max_ngram_length` \u2014 The maximum length of extracted ngram. The default value is 100. Should be not less than 'min_ngram_length'\n+\n+**Returned value**\n+\n+- An array of selected substrings crc32-c hashes. [Array](../data-types/array.md)([UInt32](../data-types/int-uint.md)).\n+\n+**Example**\n+\n+```sql\n+SELECT sparseGramsHashesUTF8('\u0430\u043b\u0438\u0441\u0430', 3) AS result\n+```\n+Result:\n+```result\n+   \u250c\u2500result\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+1. \u2502 [417784657,728683856,3071092609] \u2502\n+   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\ndiff --git a/src/Functions/FunctionTokens.h b/src/Functions/FunctionTokens.h\nindex 38e76c8f8672..83e006b8e2bc 100644\n--- a/src/Functions/FunctionTokens.h\n+++ b/src/Functions/FunctionTokens.h\n@@ -48,6 +48,7 @@ namespace ErrorCodes\n   * - otherwise, an empty array\n   *\n   * alphaTokens(s[, max_substrings])            - select from the string subsequence `[a-zA-Z]+`.\n+  * sparseGrams(s[, min_length])                - find all substrings where border ngrams hashes are bigger than internal.\n   *\n   * URL functions are located separately.\n   */\ndiff --git a/src/Functions/sparseGrams.cpp b/src/Functions/sparseGrams.cpp\nnew file mode 100644\nindex 000000000000..e686a7aac0ae\n--- /dev/null\n+++ b/src/Functions/sparseGrams.cpp\n@@ -0,0 +1,287 @@\n+#include <optional>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <Functions/FunctionTokens.h>\n+#include <Common/Exception.h>\n+\n+#include <zlib.h>\n+#include <Poco/UTF8Encoding.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+extern const int BAD_ARGUMENTS;\n+extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+}\n+\n+/** Functions that finds all substrings win minimal length n\n+  * such their border (n-1)-grams' hashes are more than hashes of every (n-1)-grams' in substring.\n+  * As a hash function use zlib crc32, which is crc32-ieee with 0xffffffff as initial value\n+  *\n+  * sparseGrams(s)\n+  */\n+namespace\n+{\n+\n+using Pos = const char *;\n+\n+template <bool is_utf8>\n+class SparseGramsImpl\n+{\n+private:\n+    Pos pos;\n+    Pos end;\n+    std::vector<UInt32> ngram_hashes;\n+    std::vector<size_t> utf8_offsets;\n+    size_t left;\n+    size_t right;\n+    UInt64 min_ngram_length = 3;\n+    UInt64 max_ngram_length = 100;\n+\n+    void buildNgramHashes()\n+    {\n+        if constexpr (is_utf8)\n+        {\n+            Poco::UTF8Encoding encoder{};\n+            size_t byte_offset = 0;\n+            while (pos + byte_offset < end)\n+            {\n+                utf8_offsets.push_back(byte_offset);\n+                auto len = encoder.sequenceLength(reinterpret_cast<const unsigned char *>(pos + byte_offset), end - pos - byte_offset);\n+                if (len < 1)\n+                    throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Incorrect utf8 symbol\");\n+                byte_offset += len;\n+            }\n+            if (pos + byte_offset != end)\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Incorrect utf8 symbol\");\n+\n+            utf8_offsets.push_back(byte_offset);\n+\n+            if (utf8_offsets.size() >= min_ngram_length)\n+                ngram_hashes.reserve(utf8_offsets.size() - min_ngram_length + 1);\n+            for (size_t i = 0; i + min_ngram_length - 1 < utf8_offsets.size(); ++i)\n+                ngram_hashes.push_back(crc32_z(\n+                    0UL,\n+                    reinterpret_cast<const unsigned char *>(pos + utf8_offsets[i]),\n+                    utf8_offsets[i + min_ngram_length - 1] - utf8_offsets[i]));\n+        }\n+        else\n+        {\n+            if (pos + min_ngram_length <= end)\n+                ngram_hashes.reserve(end - pos - min_ngram_length + 1);\n+            for (size_t i = 0; pos + i + min_ngram_length - 2 < end; ++i)\n+                ngram_hashes.push_back(crc32_z(0L, reinterpret_cast<const unsigned char *>(pos + i), min_ngram_length - 1));\n+        }\n+    }\n+\n+    std::optional<std::pair<size_t, size_t>> getNextIndices()\n+    {\n+        chassert(right > left);\n+        while (left < ngram_hashes.size())\n+        {\n+            while (right < ngram_hashes.size() && right <= left + max_ngram_length - min_ngram_length + 1)\n+            {\n+                if (right > left + 1)\n+                {\n+                    if (ngram_hashes[left] < ngram_hashes[right - 1])\n+                        break;\n+\n+                    if (ngram_hashes[right] < ngram_hashes[right - 1])\n+                    {\n+                        ++right;\n+                        continue;\n+                    }\n+                }\n+\n+                return {{left, right++}};\n+            }\n+            ++left;\n+            right = left + 1;\n+        }\n+\n+        return std::nullopt;\n+    }\n+\n+public:\n+    static constexpr auto name = is_utf8 ? \"sparseGramsUTF8\" : \"sparseGrams\";\n+    static constexpr auto strings_argument_position = 0uz;\n+    static bool isVariadic() { return true; }\n+    static size_t getNumberOfArguments() { return 0; }\n+    static ColumnNumbers getArgumentsThatAreAlwaysConstant() { return {1}; }\n+\n+    static void checkArguments(const IFunction & func, const ColumnsWithTypeAndName & arguments)\n+    {\n+        FunctionArgumentDescriptors mandatory_args{\n+            {\"s\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isString), nullptr, \"String\"},\n+        };\n+\n+        FunctionArgumentDescriptors optional_args{\n+            {\"min_ngram_length\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isNativeInteger), isColumnConst, \"const Number\"},\n+            {\"max_ngram_length\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isNativeInteger), isColumnConst, \"const Number\"},\n+        };\n+\n+        validateFunctionArguments(func, arguments, mandatory_args, optional_args);\n+    }\n+\n+    void init(const ColumnsWithTypeAndName & arguments, bool /*max_substrings_includes_remaining_string*/)\n+    {\n+        if (arguments.size() > 3)\n+            throw Exception(\n+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+                \"Number of arguments for function {} doesn't match: passed {}, must be from 1 to 3\",\n+                name,\n+                arguments.size());\n+\n+        if (arguments.size() >= 2)\n+            min_ngram_length = arguments[1].column->getUInt(0);\n+\n+        if (min_ngram_length < 3)\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Argument 'min_ngram_length' must be greater or equal to 3\");\n+\n+        if (arguments.size() == 3)\n+            max_ngram_length = arguments[2].column->getUInt(0);\n+\n+        if (max_ngram_length < min_ngram_length)\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Argument 'max_ngram_length' must be greater or equal to 'min_ngram_length'\");\n+    }\n+\n+    /// Called for each next string.\n+    void set(Pos pos_, Pos end_)\n+    {\n+        pos = pos_;\n+        end = end_;\n+        left = 0;\n+        right = 1;\n+\n+        ngram_hashes.clear();\n+        if constexpr (is_utf8)\n+            utf8_offsets.clear();\n+\n+        buildNgramHashes();\n+    }\n+\n+    /// Get the next token, if any, or return false.\n+    bool get(Pos & token_begin, Pos & token_end)\n+    {\n+        auto result = getNextIndices();\n+        if (!result)\n+            return false;\n+\n+        auto [iter_left, iter_right] = *result;\n+\n+        if constexpr (is_utf8)\n+        {\n+            token_begin = pos + utf8_offsets[iter_left];\n+            token_end = pos + utf8_offsets[iter_right + min_ngram_length - 1];\n+        }\n+        else\n+        {\n+            token_begin = pos + iter_left;\n+            token_end = pos + iter_right + min_ngram_length - 1;\n+        }\n+        return true;\n+    }\n+};\n+\n+template <bool is_utf8>\n+class SparseGramsHashes : public IFunction\n+{\n+public:\n+    static constexpr auto name = is_utf8 ? \"sparseGramsHashesUTF8\" : \"sparseGramsHashes\";\n+    String getName() const override { return name; }\n+    bool isVariadic() const override { return true; }\n+    size_t getNumberOfArguments() const override { return 0; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<SparseGramsHashes>(); }\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & args) const override\n+    {\n+        SparseGramsImpl<is_utf8>::checkArguments(*this, args);\n+        return std::make_shared<DataTypeArray>(std::make_shared<DataTypeUInt32>());\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        SparseGramsImpl<is_utf8> impl;\n+        impl.init(arguments, false);\n+\n+        auto col_res = ColumnUInt32::create();\n+        auto & res_data = col_res->getData();\n+\n+        auto col_res_offsets = ColumnArray::ColumnOffsets::create();\n+        auto & res_offsets_data = col_res_offsets->getData();\n+\n+        auto string_arg = arguments[impl.strings_argument_position].column.get();\n+\n+        if (const auto * col_string = checkAndGetColumn<ColumnString>(string_arg))\n+        {\n+            const auto & src_data = col_string->getChars();\n+            const auto & src_offsets = col_string->getOffsets();\n+\n+            res_offsets_data.reserve(input_rows_count);\n+            res_data.reserve(src_data.size());\n+\n+            ColumnString::Offset current_src_offset = 0;\n+            Pos start{};\n+            Pos end{};\n+\n+            for (size_t i = 0; i < input_rows_count; ++i)\n+            {\n+                start = reinterpret_cast<Pos>(&src_data[current_src_offset]);\n+                current_src_offset = src_offsets[i];\n+                end = reinterpret_cast<Pos>(&src_data[current_src_offset]) - 1;\n+                impl.set(start, end);\n+                while (impl.get(start, end))\n+                    res_data.push_back(crc32_z(0UL, reinterpret_cast<const unsigned char *>(start), end - start));\n+\n+                res_offsets_data.push_back(res_data.size());\n+            }\n+\n+            return ColumnArray::create(std::move(col_res), std::move(col_res_offsets));\n+        }\n+\n+        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal argument for function {}\", name);\n+    }\n+};\n+\n+using FunctionSparseGrams = FunctionTokens<SparseGramsImpl<false>>;\n+using FunctionSparseGramsUTF8 = FunctionTokens<SparseGramsImpl<true>>;\n+\n+}\n+\n+REGISTER_FUNCTION(SparseGrams)\n+{\n+    const FunctionDocumentation description = {\n+        .description=R\"(Finds all substrings of a given string that have a length of at least `n`,\n+where the hashes of the (n-1)-grams at the borders of the substring\n+are strictly greater than those of any (n-1)-gram inside the substring.)\",\n+        .arguments={\n+            {\"s\", \"An input string\"},\n+            {\"min_ngram_length\", \"The minimum length of extracted ngram. The default and minimal value is 3\"},\n+            {\"max_ngram_length\", \"The maximum length of extracted ngram. The default value is 100. Should be not less than 'min_ngram_length'\"},\n+        },\n+        .returned_value{\"An array of selected substrings\"},\n+        .category{\"String\"}\n+    };\n+    const FunctionDocumentation hashes_description{\n+        .description = R\"(Finds hashes of all substrings of a given string that have a length of at least `n`,\n+where the hashes of the (n-1)-grams at the borders of the substring\n+are strictly greater than those of any (n-1)-gram inside the substring.)\",\n+        .arguments = description.arguments,\n+        .returned_value = \"An array of selected substrings hashes\",\n+        .category = description.category};\n+\n+    factory.registerFunction<FunctionSparseGrams>(description);\n+    factory.registerFunction<FunctionSparseGramsUTF8>(description);\n+\n+    factory.registerFunction<SparseGramsHashes<false>>(hashes_description);\n+    factory.registerFunction<SparseGramsHashes<true>>(hashes_description);\n+}\n+\n+}\n",
  "test_patch": "diff --git a/tests/performance/sparse_grams.xml b/tests/performance/sparse_grams.xml\nnew file mode 100644\nindex 000000000000..9e0516f36b24\n--- /dev/null\n+++ b/tests/performance/sparse_grams.xml\n@@ -0,0 +1,9 @@\n+<test>\n+    <query>SELECT sparseGrams(repeat('a', 2000))</query>\n+    <query>sparseGrams(randomString(20)) FROM numbers(10000000)</query>\n+    <query>sparseGramsHashes(randomString(20)) FROM numbers(10000000)</query>\n+\n+    <query>SELECT sparseGramsUTF8(repeat('\u044b', 2000))</query>\n+    <query>sparseGramsUTF8(randomStringUTF8(20)) FROM numbers(10000000)</query>\n+    <query>sparseGramsHashes(randomStringUTF8(20)) FROM numbers(10000000)</query>\n+</test>\ndiff --git a/tests/queries/0_stateless/03399_sparse_grams.reference b/tests/queries/0_stateless/03399_sparse_grams.reference\nnew file mode 100644\nindex 000000000000..1c3fbc844fbc\n--- /dev/null\n+++ b/tests/queries/0_stateless/03399_sparse_grams.reference\n@@ -0,0 +1,50 @@\n+--- Regular calls\n+[]\n+[]\n+['bce']\n+['abc','bcd','bcde','bcdef','cde','def']\n+['hel','hell','hello ','hello wo','ell','llo','llo ','llo wo','lo ','o w','o wo',' wo','wor','world','orl','orld','rld']\n+['hel','hell','hello ','hello wo','ell','llo','llo ','llo wo','lo ','o w','o wo',' wo','wor','world','world h','world he','world hell','world hello ','world hello wo','world hello world','orl','orld','rld','ld ','ld h','ld he','d h',' he','hel','hell','hello ','hello wo','ell','llo','llo ','llo wo','lo ','o w','o wo',' wo','wor','world','orl','orld','rld']\n+['hel','hell','hello ','hello 0','ell','llo','llo ','llo 0','lo ','o 0',' 0 ',' 0 wo','0 w','0 wo',' wo','wor','world','orl','orld','rld']\n+['hel','hell','hello ','hello 1 ','hello 1 wo','ell','llo','llo ','llo 1 ','llo 1 wo','lo ','o 1','o 1 ',' 1 ','1 w','1 wo',' wo','wor','world','orl','orld','rld']\n+['hel','hell','hello ','hello 2 ','hello 2 wo','ell','llo','llo ','llo 2 ','llo 2 wo','lo ','o 2','o 2 ','o 2 wo',' 2 ','2 w','2 wo',' wo','wor','world','orl','orld','rld']\n+--- Minimal ngram length\n+[]\n+['hello','ello ','llo w','llo wo','llo worl','lo wo','o wor','o worl',' worl','world']\n+['hello worl','ello world','ello world he','ello world hello ','ello world hello w','ello world hello worl','llo world ','llo world he','lo world h','lo world he','o world he',' world hel',' world hello ',' world hello w','world hell','world hello ','world hello w','orld hello','orld hello ','orld hello w','rld hello ','ld hello w','d hello wo','d hello worl',' hello wor',' hello worl','hello worl','ello world']\n+--- With UTF-8 chars\n+[]\n+['a\ud83d\ude0a\u03a9','a\ud83d\ude0a\u03a9\ud800\udf48','\ud83d\ude0a\u03a9\ud800\udf48','\u03a9\ud800\udf48\u754c','\u03a9\ud800\udf48\u754c\ud834\udd1eb','\u03a9\ud800\udf48\u754c\ud834\udd1eb\u0426\u26c4','\ud800\udf48\u754c\ud834\udd1e','\ud800\udf48\u754c\ud834\udd1eb','\ud800\udf48\u754c\ud834\udd1eb\u0426\u26c4','\u754c\ud834\udd1eb','\ud834\udd1eb\u0426','\ud834\udd1eb\u0426\u26c4','b\u0426\u26c4']\n+['A\u03a9\u0416\u4e2d','A\u03a9\u0416\u4e2d\ud83d\ude0a','A\u03a9\u0416\u4e2d\ud83d\ude0a\ud83d\ude80','\u03a9\u0416\u4e2d\ud83d\ude0a','\u0416\u4e2d\ud83d\ude0a\ud83d\ude80','\u4e2d\ud83d\ude0a\ud83d\ude80\ud834\udd1e','\u4e2d\ud83d\ude0a\ud83d\ude80\ud834\udd1e\u2728','\ud83d\ude0a\ud83d\ude80\ud834\udd1e\u2728','\ud83d\ude80\ud834\udd1e\u2728\ud83c\udfb5','\ud83d\ude80\ud834\udd1e\u2728\ud83c\udfb5\ud83e\udd84','\ud834\udd1e\u2728\ud83c\udfb5\ud83e\udd84','\u2728\ud83c\udfb5\ud83e\udd84\ud83d\udca1','\u2728\ud83c\udfb5\ud83e\udd84\ud83d\udca1\u2744','\ud83c\udfb5\ud83e\udd84\ud83d\udca1\u2744','\ud83e\udd84\ud83d\udca1\u2744\ufe0f']\n+['a\ud83d\ude0a\u03a9','a\ud83d\ude0a\u03a9\ud800\udf48','\ud83d\ude0a\u03a9\ud800\udf48','\u03a9\ud800\udf480','\u03a9\ud800\udf480\ud83e\udd84\ud834\udd1e','\u03a9\ud800\udf480\ud83e\udd84\ud834\udd1eb','\u03a9\ud800\udf480\ud83e\udd84\ud834\udd1eb\u0426\u26c4','\ud800\udf480\ud83e\udd84','\ud800\udf480\ud83e\udd84\ud834\udd1e','0\ud83e\udd84\ud834\udd1e','\ud83e\udd84\ud834\udd1eb','\ud834\udd1eb\u0426','\ud834\udd1eb\u0426\u26c4','b\u0426\u26c4','\u0426\u26c44']\n+['a\ud83d\ude0a\u03a9','a\ud83d\ude0a\u03a9\ud800\udf48','\ud83d\ude0a\u03a9\ud800\udf48','\u03a9\ud800\udf481','\u03a9\ud800\udf481\ud83e\udd84\ud834\udd1eb','\u03a9\ud800\udf481\ud83e\udd84\ud834\udd1eb\u0426\u26c4','\ud800\udf481\ud83e\udd84','\ud800\udf481\ud83e\udd84\ud834\udd1eb','\ud800\udf481\ud83e\udd84\ud834\udd1eb\u0426\u26c4','1\ud83e\udd84\ud834\udd1e','1\ud83e\udd84\ud834\udd1eb','\ud83e\udd84\ud834\udd1eb','\ud834\udd1eb\u0426','\ud834\udd1eb\u0426\u26c4','b\u0426\u26c4','\u0426\u26c44']\n+['a\ud83d\ude0a\u03a9','a\ud83d\ude0a\u03a9\ud800\udf48','\ud83d\ude0a\u03a9\ud800\udf48','\u03a9\ud800\udf482','\u03a9\ud800\udf482\ud83e\udd84\ud834\udd1eb','\u03a9\ud800\udf482\ud83e\udd84\ud834\udd1eb\u0426\u26c4','\ud800\udf482\ud83e\udd84','\ud800\udf482\ud83e\udd84\ud834\udd1eb','\ud800\udf482\ud83e\udd84\ud834\udd1eb\u0426\u26c4','2\ud83e\udd84\ud834\udd1e','2\ud83e\udd84\ud834\udd1eb','2\ud83e\udd84\ud834\udd1eb\u0426\u26c4','\ud83e\udd84\ud834\udd1eb','\ud834\udd1eb\u0426','\ud834\udd1eb\u0426\u26c4','b\u0426\u26c4','\u0426\u26c44']\n+--- Regular hashes\n+[]\n+[]\n+[3340397551]\n+[891568578,2954713977,3333664409,4291212206,2308544287,214229345]\n+[3842765083,478544099,3984718326,2049794053,1007802625,2865345332,3362976323,1951254147,1736948982,3878655282,3342855505,2055146506,4069638335,980881731,3855049480,2531460509,732161222]\n+[3842765083,478544099,3984718326,2049794053,1007802625,2865345332,3362976323,1951254147,1736948982,3878655282,3342855505,2055146506,4069638335,980881731,651221364,3096715174,3116414249,1738482807,2698505592,2183534424,3855049480,2531460509,732161222,2222155069,3381082515,2249539485,1718777638,1475406730,3842765083,478544099,3984718326,2049794053,1007802625,2865345332,3362976323,1951254147,1736948982,3878655282,3342855505,2055146506,4069638335,980881731,3855049480,2531460509,732161222]\n+[3842765083,478544099,3984718326,2699561457,1007802625,2865345332,3362976323,466009593,1736948982,261570817,589597129,1928787360,2161114303,1414656677,2055146506,4069638335,980881731,3855049480,2531460509,732161222]\n+[3842765083,478544099,3984718326,980276359,165061419,1007802625,2865345332,3362976323,873296385,1538954331,1736948982,2022732183,2273270227,977254536,2165151368,3974993344,2055146506,4069638335,980881731,3855049480,2531460509,732161222]\n+[3842765083,478544099,3984718326,289441604,459476165,1007802625,2865345332,3362976323,522199490,1225735093,1736948982,3784908845,2891057680,1455281690,286452555,2202740945,4267194926,2055146506,4069638335,980881731,3855049480,2531460509,732161222]\n+--- Hashes with minimal ngram length\n+[]\n+[907060870,2126914175,4085148106,1951254147,2055077048,2090557212,1889706258,1708069143,3951950374,980881731]\n+[907060870,2126914175,4085148106,3928576800,881564383,2738041986,3207950968,1153105077,2015750893,934245482,2863928579,2527885035,2980432641,3808414399,1558534924,296648895,3021306567,2740957833,3294177615,1846321578,2802204848,876714809,1051285752,626921864,3430309234,1470867720,763922455,975243238,1180497166,244498103,907060870,2126914175,4085148106,3928576800,881564383,2738041986,3808414399,1558534924,296648895,3021306567,3294177615]\n+--- Hashes with UTF-8 strings\n+[]\n+[2555152230,1867522810,1980215960,2132312527,4014781216,2612104012,4033133548,3639747857,3223115564,2515076017,3033382003,3595911216,3339527764]\n+[426441554,3329502383,129658036,2111873203,3979214273,2781192203,1260040353,785131011,3590941201,2690449204,2844181491,2654764797,2071031776,3898165372,1956098339,825470570,2983467909]\n+[2555152230,1867522810,1980215960,4131872843,427293224,1142042873,3412715817,2279437304,1218331780,2651192394,2321136747,3033382003,3595911216,3339527764,2951782626]\n+[2555152230,1867522810,1980215960,2168475869,2882558919,1922183873,3132971592,1960926650,1974607636,2306795529,149629365,2321136747,3033382003,3595911216,3339527764,2951782626]\n+[2555152230,1867522810,1980215960,407437671,1088938180,1676630200,4246544536,2681661113,1691317613,2968769740,3822883510,2363450971,2321136747,3033382003,3595911216,3339527764,2951782626]\n+--- Check equal hashes\n+1\n+1\n+--- Maximal ngram length\n+['hel','hell','ell','llo','llo ','lo ','o w','o wo',' wo','wor','orl','orld','rld','ld ','ld h','d h',' he','hel','hell','ell','llo','llo ','lo ','o w','o wo',' wo','wor','orl','orld','rld']\n+[3842765083,478544099,1007802625,2865345332,3362976323,1736948982,3878655282,3342855505,2055146506,4069638335,3855049480,2531460509,732161222,2222155069,3381082515,1718777638,1475406730,3842765083,478544099,1007802625,2865345332,3362976323,1736948982,3878655282,3342855505,2055146506,4069638335,3855049480,2531460509,732161222]\n+['a\ud83d\ude0a\u03a9','a\ud83d\ude0a\u03a9\ud800\udf48','\ud83d\ude0a\u03a9\ud800\udf48','\u03a9\ud800\udf48\u754c','\ud800\udf48\u754c\ud834\udd1e','\ud800\udf48\u754c\ud834\udd1eb','\u754c\ud834\udd1eb','\ud834\udd1eb\u0426','\ud834\udd1eb\u0426\u26c4','b\u0426\u26c4']\n+[2555152230,1867522810,1980215960,2132312527,4033133548,3639747857,2515076017,3033382003,3595911216,3339527764]\ndiff --git a/tests/queries/0_stateless/03399_sparse_grams.sql b/tests/queries/0_stateless/03399_sparse_grams.sql\nnew file mode 100644\nindex 000000000000..92446d5cfa62\n--- /dev/null\n+++ b/tests/queries/0_stateless/03399_sparse_grams.sql\n@@ -0,0 +1,51 @@\n+SELECT '--- Regular calls';\n+SELECT sparseGrams('');\n+SELECT sparseGrams('ab');\n+SELECT sparseGrams('bce');\n+SELECT sparseGrams('abcdef');\n+SELECT sparseGrams('hello world');\n+SELECT sparseGrams('hello world hello world');\n+SELECT sparseGrams(concat('hello ', number, ' world')) FROM numbers(3);\n+\n+SELECT '--- Minimal ngram length';\n+SELECT sparseGrams('', 5);\n+SELECT sparseGrams('hello world', 5);\n+SELECT sparseGrams('hello world hello world', 10);\n+\n+SELECT '--- With UTF-8 chars';\n+SELECT sparseGramsUTF8('');\n+SELECT sparseGramsUTF8('a\ud83d\ude0a\u03a9\ud800\udf48\u754c\ud834\udd1eb\u0426\u26c4');\n+SELECT sparseGramsUTF8('A\u03a9\u0416\u4e2d\ud83d\ude0a\ud83d\ude80\ud834\udd1e\u2728\ud83c\udfb5\ud83e\udd84\ud83d\udca1\u2744\ufe0f', 4);\n+SELECT sparseGramsUTF8(concat('a\ud83d\ude0a\u03a9\ud800\udf48', number, '\ud83e\udd84\ud834\udd1eb\u0426\u26c4', 4)) FROM numbers(3);\n+\n+SELECT '--- Regular hashes';\n+SELECT sparseGramsHashes('');\n+SELECT sparseGramsHashes('ab');\n+SELECT sparseGramsHashes('bce');\n+SELECT sparseGramsHashes('abcdef');\n+SELECT sparseGramsHashes('hello world');\n+SELECT sparseGramsHashes('hello world hello world');\n+SELECT sparseGramsHashes(concat('hello ', number, ' world')) FROM numbers(3);\n+\n+SELECT '--- Hashes with minimal ngram length';\n+SELECT sparseGramsHashes('', 5);\n+SELECT sparseGramsHashes('hello world', 5);\n+SELECT sparseGramsHashes('hello whole hello whole', 5);\n+\n+SELECT '--- Hashes with UTF-8 strings';\n+SELECT sparseGramsHashesUTF8('');\n+SELECT sparseGramsHashesUTF8('a\ud83d\ude0a\u03a9\ud800\udf48\u754c\ud834\udd1eb\u0426\u26c4');\n+SELECT sparseGramsHashesUTF8('A\u03a9\u0416\u4e2d\ud83d\ude0a\ud834\udd1e\u2728\ud83c\udf0d\ud83c\udfb5\ud83e\udd84\ud83d\udca1\u2744\ufe0f', 4);\n+SELECT sparseGramsHashesUTF8(concat('a\ud83d\ude0a\u03a9\ud800\udf48', number, '\ud83e\udd84\ud834\udd1eb\u0426\u26c4', 4)) FROM numbers(3);\n+\n+SELECT '--- Check equal hashes';\n+WITH 'hello world hello world hello' as source\n+    SELECT sparseGramsHashes(source, 4) = arrayMap(v -> CRC32(v), sparseGrams(source, 4));\n+WITH 'A\u03a9\u0416\u4e2d\ud83d\ude0a\ud834\udd1e\u2728\ud83c\udf0d\ud83c\udfb5\ud83e\udd84\ud83d\udca1\u2744\ufe0f' as source\n+    SELECT sparseGramsHashesUTF8(source, 4) = arrayMap(v -> CRC32(v), sparseGramsUTF8(source, 4));\n+\n+SELECT '--- Maximal ngram length';\n+SELECT sparseGrams('hello world hello world', 3, 4);\n+SELECT sparseGramsHashes('hello world hello world', 3, 4);\n+SELECT sparseGramsUTF8('a\ud83d\ude0a\u03a9\ud800\udf48\u754c\ud834\udd1eb\u0426\u26c4', 3, 4);\n+SELECT sparseGramsHashesUTF8('a\ud83d\ude0a\u03a9\ud800\udf48\u754c\ud834\udd1eb\u0426\u26c4', 3, 4);\n",
  "problem_statement": "A new function `sparseGrams`\nThe function accepts a `String` and returns an `Array(String)`.\r\n\r\nIt works as follows: iterates over bigrams of UTF-8 code points in a string and calculates a fast hash of them (e.g., CRC32-C). Then, it extracts every substring from the string so that the hashes of boundary bigrams are greater than every hash of the bigrams in between.\r\n\r\nIt means that it will extract every trigram, and in addition, some subsets of larger n-grams, that are consistently selected by the hashing, with the exponentially decaying probability to the length of the n-gram.\r\n\r\n**Additional context**\r\n\r\nAdditionally, we can provide a function that will return an array of hashes instead of substrings.\r\n\r\nWe should provide the parameter of min returned ngram size (N, which is 3 in this example), so we will hash (N-1)-grams (bigrams in this example). Values larger than 3 will be useful for searching in small-alphabet strings, such as DNA.\r\n\r\nRead the last footnote here: https://github.blog/2023-02-06-the-technology-behind-githubs-new-code-search/\r\n\n",
  "hints_text": "",
  "created_at": "2025-03-24T14:27:49Z",
  "modified_files": [
    "ci/jobs/scripts/check_style/aspell-ignore/en/aspell-dict.txt",
    "docs/en/sql-reference/functions/string-functions.md",
    "src/Functions/FunctionTokens.h",
    "b/src/Functions/sparseGrams.cpp"
  ],
  "modified_test_files": [
    "b/tests/performance/sparse_grams.xml",
    "b/tests/queries/0_stateless/03399_sparse_grams.reference",
    "b/tests/queries/0_stateless/03399_sparse_grams.sql"
  ]
}