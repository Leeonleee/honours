diff --git a/docs/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md b/docs/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md
index a49ddf62eb9c..05c418b1f151 100644
--- a/docs/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md
+++ b/docs/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md
@@ -406,6 +406,14 @@ Example:
             <null_value>??</null_value>
     </attribute>
     ...
+</structure>
+<layout>
+    <ip_trie>
+        <!-- Key attribute `prefix` can be retrieved via dictGetString. -->
+        <!-- This option increases memory usage. -->
+        <access_to_key_from_attributes>true</access_to_key_from_attributes>
+    </ip_trie>
+</layout>
 ```
 
 or
@@ -435,6 +443,6 @@ dictGetString('prefix', 'asn', tuple(IPv6StringToNum('2001:db8::1')))
 
 Other types are not supported yet. The function returns the attribute for the prefix that corresponds to this IP address. If there are overlapping prefixes, the most specific one is returned.
 
-Data is stored in a `trie`. It must completely fit into RAM.
+Data must completely fit into RAM.
 
 [Original article](https://clickhouse.tech/docs/en/query_language/dicts/external_dicts_dict_layout/) <!--hide-->
diff --git a/docs/fr/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md b/docs/fr/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md
index 3bdc8d37d60d..2569329fefd7 100644
--- a/docs/fr/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md
+++ b/docs/fr/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md
@@ -367,6 +367,12 @@ Exemple:
             <null_value>??</null_value>
     </attribute>
     ...
+</structure>
+<layout>
+    <ip_trie>
+        <access_to_key_from_attributes>true</access_to_key_from_attributes>
+    </ip_trie>
+</layout>
 ```
 
 ou
@@ -396,6 +402,6 @@ dictGetString('prefix', 'asn', tuple(IPv6StringToNum('2001:db8::1')))
 
 Les autres types ne sont pas encore pris en charge. La fonction renvoie l'attribut du préfixe correspondant à cette adresse IP. S'il y a chevauchement des préfixes, le plus spécifique est retourné.
 
-Les données sont stockées dans une `trie`. Il doit complètement s'intégrer dans la RAM.
+Les données doit complètement s'intégrer dans la RAM.
 
 [Article Original](https://clickhouse.tech/docs/en/query_language/dicts/external_dicts_dict_layout/) <!--hide-->
diff --git a/docs/ja/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md b/docs/ja/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md
index 167e0f1f5d14..ac632b99332a 100644
--- a/docs/ja/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md
+++ b/docs/ja/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md
@@ -362,6 +362,12 @@ LAYOUT(DIRECT())
             <null_value>??</null_value>
     </attribute>
     ...
+</structure>
+<layout>
+    <ip_trie>
+        <access_to_key_from_attributes>true</access_to_key_from_attributes>
+    </ip_trie>
+</layout>
 ```
 
 または
diff --git a/docs/ru/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md b/docs/ru/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md
index e97b1e421a4f..fc4a3ac72856 100644
--- a/docs/ru/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md
+++ b/docs/ru/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md
@@ -404,6 +404,14 @@ LAYOUT(DIRECT())
             <null_value>??</null_value>
     </attribute>
     ...
+</structure>
+<layout>
+    <ip_trie>
+        <!-- Ключевой аттрибут `prefix` будет доступен через dictGetString -->
+        <!-- Эта опция увеличивает потреблямую память -->
+        <access_to_key_from_attributes>true</access_to_key_from_attributes>
+    </ip_trie>
+</layout>
 ```
 
 или
@@ -433,6 +441,6 @@ dictGetString('prefix', 'asn', tuple(IPv6StringToNum('2001:db8::1')))
 
 Никакие другие типы не поддерживаются. Функция возвращает атрибут для префикса, соответствующего данному IP-адресу. Если есть перекрывающиеся префиксы, возвращается наиболее специфический.
 
-Данные хранятся в побитовом дереве (`trie`), он должен полностью помещаться в оперативной памяти.
+Данные должны полностью помещаться в оперативной памяти.
 
 [Оригинальная статья](https://clickhouse.tech/docs/ru/query_language/dicts/external_dicts_dict_layout/) <!--hide-->
diff --git a/docs/zh/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md b/docs/zh/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md
index 176859d36332..190fd74d7052 100644
--- a/docs/zh/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md
+++ b/docs/zh/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md
@@ -362,6 +362,12 @@ LAYOUT(DIRECT())
             <null_value>??</null_value>
     </attribute>
     ...
+</structure>
+<layout>
+    <ip_trie>
+        <access_to_key_from_attributes>true</access_to_key_from_attributes>
+    </ip_trie>
+</layout>
 ```
 
 或
diff --git a/src/Dictionaries/IPAddressDictionary.cpp b/src/Dictionaries/IPAddressDictionary.cpp
index e04b9111ff14..a69e038c1e49 100644
--- a/src/Dictionaries/IPAddressDictionary.cpp
+++ b/src/Dictionaries/IPAddressDictionary.cpp
@@ -107,6 +107,18 @@ static std::pair<Poco::Net::IPAddress, UInt8> parseIPFromString(const std::strin
     }
 }
 
+static size_t formatIPWithPrefix(const unsigned char * src, UInt8 prefix_len, bool isv4, char * dst)
+{
+    char * ptr = dst;
+    if (isv4)
+        formatIPv4(src, ptr);
+    else
+        formatIPv6(src, ptr);
+    *(ptr - 1) = '/';
+    ptr = itoa(prefix_len, ptr);
+    return ptr - dst;
+}
+
 static void validateKeyTypes(const DataTypes & key_types)
 {
     if (key_types.empty() || key_types.size() > 2)
@@ -231,14 +243,21 @@ IPAddressDictionary::IPAddressDictionary(
     const DictionaryStructure & dict_struct_,
     DictionarySourcePtr source_ptr_,
     const DictionaryLifetime dict_lifetime_,
-    bool require_nonempty_)
+    bool require_nonempty_,
+    bool access_to_key_from_attributes_)
     : IDictionaryBase(dict_id_)
     , dict_struct(dict_struct_)
     , source_ptr{std::move(source_ptr_)}
     , dict_lifetime(dict_lifetime_)
     , require_nonempty(require_nonempty_)
+    , access_to_key_from_attributes(access_to_key_from_attributes_)
     , logger(&Poco::Logger::get("IPAddressDictionary"))
 {
+    if (access_to_key_from_attributes)
+    {
+        dict_struct.attributes.emplace_back(dict_struct.key->front());
+    }
+
     createAttributes();
 
     loadData();
@@ -453,8 +472,6 @@ void IPAddressDictionary::loadData()
     auto stream = source_ptr->loadAll();
     stream->readPrefix();
 
-    const auto attributes_size = attributes.size();
-
     std::vector<IPRecord> ip_records;
 
     bool has_ipv6 = false;
@@ -465,14 +482,19 @@ void IPAddressDictionary::loadData()
         element_count += rows;
 
         const ColumnPtr key_column_ptr = block.safeGetByPosition(0).column;
-        const auto attribute_column_ptrs = ext::map<Columns>(ext::range(0, attributes_size), [&](const size_t attribute_idx)
+
+        size_t attributes_size = dict_struct.attributes.size();
+        if (access_to_key_from_attributes)
         {
-            return block.safeGetByPosition(attribute_idx + 1).column;
-        });
+            /// last attribute contains key and will be filled in code below
+            attributes_size--;
+        }
+        const auto attribute_column_ptrs = ext::map<Columns>(ext::range(0, attributes_size),
+            [&](const size_t attribute_idx) { return block.safeGetByPosition(attribute_idx + 1).column; });
 
         for (const auto row : ext::range(0, rows))
         {
-            for (const auto attribute_idx : ext::range(0, attributes_size))
+            for (const auto attribute_idx : ext::range(0, attribute_column_ptrs.size()))
             {
                 const auto & attribute_column = *attribute_column_ptrs[attribute_idx];
                 auto & attribute = attributes[attribute_idx];
@@ -490,6 +512,33 @@ void IPAddressDictionary::loadData()
 
     stream->readSuffix();
 
+    if (access_to_key_from_attributes)
+    {
+        /// We format key attribute values here instead of filling with data from key_column
+        /// because string representation can be normalized if bits beyond mask are set.
+        /// Also all IPv4 will be displayed as mapped IPv6 if threre are any IPv6.
+        /// It's consistent with representation in table created with `ENGINE = Dictionary` from this dictionary.
+        char str_buffer[48];
+        if (has_ipv6)
+        {
+            uint8_t ip_buffer[IPV6_BINARY_LENGTH];
+            for (const auto & record : ip_records)
+            {
+                size_t str_len = formatIPWithPrefix(record.asIPv6Binary(ip_buffer), record.prefixIPv6(), false, str_buffer);
+                setAttributeValue(attributes.back(), String(str_buffer, str_len));
+            }
+        }
+        else
+        {
+            for (const auto & record : ip_records)
+            {
+                UInt32 addr = IPv4AsUInt32(record.addr.addr());
+                size_t str_len = formatIPWithPrefix(reinterpret_cast<const unsigned char *>(&addr), record.prefix, true, str_buffer);
+                setAttributeValue(attributes.back(), String(str_buffer, str_len));
+            }
+        }
+    }
+
     row_idx.reserve(ip_records.size());
     mask_column.reserve(ip_records.size());
 
@@ -679,7 +728,7 @@ void IPAddressDictionary::calculateBytesAllocated()
 template <typename T>
 void IPAddressDictionary::createAttributeImpl(Attribute & attribute, const Field & null_value)
 {
-    attribute.null_values = T(null_value.get<NearestFieldType<T>>());
+    attribute.null_values = null_value.isNull() ? T{} : T(null_value.get<NearestFieldType<T>>());
     attribute.maps.emplace<ContainerType<T>>();
 }
 
@@ -735,7 +784,8 @@ IPAddressDictionary::Attribute IPAddressDictionary::createAttributeWithType(cons
 
         case AttributeUnderlyingType::utString:
         {
-            attr.null_values = null_value.get<String>();
+
+            attr.null_values = null_value.isNull() ? String() : null_value.get<String>();
             attr.maps.emplace<ContainerType<StringRef>>();
             attr.string_arena = std::make_unique<Arena>();
             break;
@@ -979,14 +1029,12 @@ static auto keyViewGetter()
         for (size_t row : ext::range(0, key_ip_column.size()))
         {
             UInt8 mask = key_mask_column.getElement(row);
-            char * ptr = buffer;
+            size_t str_len;
             if constexpr (IsIPv4)
-                formatIPv4(reinterpret_cast<const unsigned char *>(&key_ip_column.getElement(row)), ptr);
+                str_len = formatIPWithPrefix(reinterpret_cast<const unsigned char *>(&key_ip_column.getElement(row)), mask, true, buffer);
             else
-                formatIPv6(reinterpret_cast<const unsigned char *>(key_ip_column.getDataAt(row).data), ptr);
-            *(ptr - 1) = '/';
-            ptr = itoa(mask, ptr);
-            column->insertData(buffer, ptr - buffer);
+                str_len = formatIPWithPrefix(reinterpret_cast<const unsigned char *>(key_ip_column.getDataAt(row).data), mask, false, buffer);
+            column->insertData(buffer, str_len);
         }
         return ColumnsWithTypeAndName{
             ColumnWithTypeAndName(std::move(column), std::make_shared<DataTypeString>(), dict_attributes.front().name)};
@@ -1120,8 +1168,12 @@ void registerDictionaryTrie(DictionaryFactory & factory)
         const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);
         const DictionaryLifetime dict_lifetime{config, config_prefix + ".lifetime"};
         const bool require_nonempty = config.getBool(config_prefix + ".require_nonempty", false);
+
+        const auto & layout_prefix = config_prefix + ".layout.ip_trie";
+        const bool access_to_key_from_attributes = config.getBool(layout_prefix + ".access_to_key_from_attributes", false);
         // This is specialised dictionary for storing IPv4 and IPv6 prefixes.
-        return std::make_unique<IPAddressDictionary>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty);
+        return std::make_unique<IPAddressDictionary>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime,
+                                                     require_nonempty, access_to_key_from_attributes);
     };
     factory.registerLayout("ip_trie", create_layout, true);
 }
diff --git a/src/Dictionaries/IPAddressDictionary.h b/src/Dictionaries/IPAddressDictionary.h
index c63e6b01adff..2009141ebcc9 100644
--- a/src/Dictionaries/IPAddressDictionary.h
+++ b/src/Dictionaries/IPAddressDictionary.h
@@ -27,7 +27,8 @@ class IPAddressDictionary final : public IDictionaryBase
         const DictionaryStructure & dict_struct_,
         DictionarySourcePtr source_ptr_,
         const DictionaryLifetime dict_lifetime_,
-        bool require_nonempty_);
+        bool require_nonempty_,
+        bool access_to_key_from_attributes_);
 
     std::string getKeyDescription() const { return key_description; }
 
@@ -45,7 +46,8 @@ class IPAddressDictionary final : public IDictionaryBase
 
     std::shared_ptr<const IExternalLoadable> clone() const override
     {
-        return std::make_shared<IPAddressDictionary>(getDictionaryID(), dict_struct, source_ptr->clone(), dict_lifetime, require_nonempty);
+        return std::make_shared<IPAddressDictionary>(getDictionaryID(), dict_struct, source_ptr->clone(), dict_lifetime,
+                                                     require_nonempty, access_to_key_from_attributes);
     }
 
     const IDictionarySource * getSource() const override { return source_ptr.get(); }
@@ -238,10 +240,11 @@ class IPAddressDictionary final : public IDictionaryBase
 
     static const uint8_t * getIPv6FromOffset(const IPv6Container & ipv6_col, size_t i);
 
-    const DictionaryStructure dict_struct;
+    DictionaryStructure dict_struct;
     const DictionarySourcePtr source_ptr;
     const DictionaryLifetime dict_lifetime;
     const bool require_nonempty;
+    const bool access_to_key_from_attributes;
     const std::string key_description{dict_struct.getKeyDescription()};
 
     /// Contains sorted IP subnetworks. If some addresses equals, subnet with lower mask is placed first.
