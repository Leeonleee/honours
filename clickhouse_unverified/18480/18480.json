{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 18480,
  "instance_id": "ClickHouse__ClickHouse-18480",
  "issue_numbers": [
    "18241"
  ],
  "base_commit": "30e39002351b0e5f08ac7ddf1e5f3fd6beb5dbae",
  "patch": "diff --git a/docs/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md b/docs/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md\nindex a49ddf62eb9c..05c418b1f151 100644\n--- a/docs/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md\n+++ b/docs/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md\n@@ -406,6 +406,14 @@ Example:\n             <null_value>??</null_value>\n     </attribute>\n     ...\n+</structure>\n+<layout>\n+    <ip_trie>\n+        <!-- Key attribute `prefix` can be retrieved via dictGetString. -->\n+        <!-- This option increases memory usage. -->\n+        <access_to_key_from_attributes>true</access_to_key_from_attributes>\n+    </ip_trie>\n+</layout>\n ```\n \n or\n@@ -435,6 +443,6 @@ dictGetString('prefix', 'asn', tuple(IPv6StringToNum('2001:db8::1')))\n \n Other types are not supported yet. The function returns the attribute for the prefix that corresponds to this IP address. If there are overlapping prefixes, the most specific one is returned.\n \n-Data is stored in a `trie`. It must completely fit into RAM.\n+Data must completely fit into RAM.\n \n [Original article](https://clickhouse.tech/docs/en/query_language/dicts/external_dicts_dict_layout/) <!--hide-->\ndiff --git a/docs/fr/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md b/docs/fr/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md\nindex 3bdc8d37d60d..2569329fefd7 100644\n--- a/docs/fr/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md\n+++ b/docs/fr/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md\n@@ -367,6 +367,12 @@ Exemple:\n             <null_value>??</null_value>\n     </attribute>\n     ...\n+</structure>\n+<layout>\n+    <ip_trie>\n+        <access_to_key_from_attributes>true</access_to_key_from_attributes>\n+    </ip_trie>\n+</layout>\n ```\n \n ou\n@@ -396,6 +402,6 @@ dictGetString('prefix', 'asn', tuple(IPv6StringToNum('2001:db8::1')))\n \n Les autres types ne sont pas encore pris en charge. La fonction renvoie l'attribut du pr\u00e9fixe correspondant \u00e0 cette adresse IP. S'il y a chevauchement des pr\u00e9fixes, le plus sp\u00e9cifique est retourn\u00e9.\n \n-Les donn\u00e9es sont stock\u00e9es dans une `trie`. Il doit compl\u00e8tement s'int\u00e9grer dans la RAM.\n+Les donn\u00e9es doit compl\u00e8tement s'int\u00e9grer dans la RAM.\n \n [Article Original](https://clickhouse.tech/docs/en/query_language/dicts/external_dicts_dict_layout/) <!--hide-->\ndiff --git a/docs/ja/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md b/docs/ja/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md\nindex 167e0f1f5d14..ac632b99332a 100644\n--- a/docs/ja/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md\n+++ b/docs/ja/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md\n@@ -362,6 +362,12 @@ LAYOUT(DIRECT())\n             <null_value>??</null_value>\n     </attribute>\n     ...\n+</structure>\n+<layout>\n+    <ip_trie>\n+        <access_to_key_from_attributes>true</access_to_key_from_attributes>\n+    </ip_trie>\n+</layout>\n ```\n \n \u307e\u305f\u306f\ndiff --git a/docs/ru/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md b/docs/ru/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md\nindex e97b1e421a4f..fc4a3ac72856 100644\n--- a/docs/ru/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md\n+++ b/docs/ru/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md\n@@ -404,6 +404,14 @@ LAYOUT(DIRECT())\n             <null_value>??</null_value>\n     </attribute>\n     ...\n+</structure>\n+<layout>\n+    <ip_trie>\n+        <!-- \u041a\u043b\u044e\u0447\u0435\u0432\u043e\u0439 \u0430\u0442\u0442\u0440\u0438\u0431\u0443\u0442 `prefix` \u0431\u0443\u0434\u0435\u0442 \u0434\u043e\u0441\u0442\u0443\u043f\u0435\u043d \u0447\u0435\u0440\u0435\u0437 dictGetString -->\n+        <!-- \u042d\u0442\u0430 \u043e\u043f\u0446\u0438\u044f \u0443\u0432\u0435\u043b\u0438\u0447\u0438\u0432\u0430\u0435\u0442 \u043f\u043e\u0442\u0440\u0435\u0431\u043b\u044f\u043c\u0443\u044e \u043f\u0430\u043c\u044f\u0442\u044c -->\n+        <access_to_key_from_attributes>true</access_to_key_from_attributes>\n+    </ip_trie>\n+</layout>\n ```\n \n \u0438\u043b\u0438\n@@ -433,6 +441,6 @@ dictGetString('prefix', 'asn', tuple(IPv6StringToNum('2001:db8::1')))\n \n \u041d\u0438\u043a\u0430\u043a\u0438\u0435 \u0434\u0440\u0443\u0433\u0438\u0435 \u0442\u0438\u043f\u044b \u043d\u0435 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u044e\u0442\u0441\u044f. \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 \u0434\u043b\u044f \u043f\u0440\u0435\u0444\u0438\u043a\u0441\u0430, \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0433\u043e \u0434\u0430\u043d\u043d\u043e\u043c\u0443 IP-\u0430\u0434\u0440\u0435\u0441\u0443. \u0415\u0441\u043b\u0438 \u0435\u0441\u0442\u044c \u043f\u0435\u0440\u0435\u043a\u0440\u044b\u0432\u0430\u044e\u0449\u0438\u0435\u0441\u044f \u043f\u0440\u0435\u0444\u0438\u043a\u0441\u044b, \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442\u0441\u044f \u043d\u0430\u0438\u0431\u043e\u043b\u0435\u0435 \u0441\u043f\u0435\u0446\u0438\u0444\u0438\u0447\u0435\u0441\u043a\u0438\u0439.\n \n-\u0414\u0430\u043d\u043d\u044b\u0435 \u0445\u0440\u0430\u043d\u044f\u0442\u0441\u044f \u0432 \u043f\u043e\u0431\u0438\u0442\u043e\u0432\u043e\u043c \u0434\u0435\u0440\u0435\u0432\u0435 (`trie`), \u043e\u043d \u0434\u043e\u043b\u0436\u0435\u043d \u043f\u043e\u043b\u043d\u043e\u0441\u0442\u044c\u044e \u043f\u043e\u043c\u0435\u0449\u0430\u0442\u044c\u0441\u044f \u0432 \u043e\u043f\u0435\u0440\u0430\u0442\u0438\u0432\u043d\u043e\u0439 \u043f\u0430\u043c\u044f\u0442\u0438.\n+\u0414\u0430\u043d\u043d\u044b\u0435 \u0434\u043e\u043b\u0436\u043d\u044b \u043f\u043e\u043b\u043d\u043e\u0441\u0442\u044c\u044e \u043f\u043e\u043c\u0435\u0449\u0430\u0442\u044c\u0441\u044f \u0432 \u043e\u043f\u0435\u0440\u0430\u0442\u0438\u0432\u043d\u043e\u0439 \u043f\u0430\u043c\u044f\u0442\u0438.\n \n [\u041e\u0440\u0438\u0433\u0438\u043d\u0430\u043b\u044c\u043d\u0430\u044f \u0441\u0442\u0430\u0442\u044c\u044f](https://clickhouse.tech/docs/ru/query_language/dicts/external_dicts_dict_layout/) <!--hide-->\ndiff --git a/docs/zh/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md b/docs/zh/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md\nindex 176859d36332..190fd74d7052 100644\n--- a/docs/zh/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md\n+++ b/docs/zh/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-layout.md\n@@ -362,6 +362,12 @@ LAYOUT(DIRECT())\n             <null_value>??</null_value>\n     </attribute>\n     ...\n+</structure>\n+<layout>\n+    <ip_trie>\n+        <access_to_key_from_attributes>true</access_to_key_from_attributes>\n+    </ip_trie>\n+</layout>\n ```\n \n \u6216\ndiff --git a/src/Dictionaries/IPAddressDictionary.cpp b/src/Dictionaries/IPAddressDictionary.cpp\nindex e04b9111ff14..a69e038c1e49 100644\n--- a/src/Dictionaries/IPAddressDictionary.cpp\n+++ b/src/Dictionaries/IPAddressDictionary.cpp\n@@ -107,6 +107,18 @@ static std::pair<Poco::Net::IPAddress, UInt8> parseIPFromString(const std::strin\n     }\n }\n \n+static size_t formatIPWithPrefix(const unsigned char * src, UInt8 prefix_len, bool isv4, char * dst)\n+{\n+    char * ptr = dst;\n+    if (isv4)\n+        formatIPv4(src, ptr);\n+    else\n+        formatIPv6(src, ptr);\n+    *(ptr - 1) = '/';\n+    ptr = itoa(prefix_len, ptr);\n+    return ptr - dst;\n+}\n+\n static void validateKeyTypes(const DataTypes & key_types)\n {\n     if (key_types.empty() || key_types.size() > 2)\n@@ -231,14 +243,21 @@ IPAddressDictionary::IPAddressDictionary(\n     const DictionaryStructure & dict_struct_,\n     DictionarySourcePtr source_ptr_,\n     const DictionaryLifetime dict_lifetime_,\n-    bool require_nonempty_)\n+    bool require_nonempty_,\n+    bool access_to_key_from_attributes_)\n     : IDictionaryBase(dict_id_)\n     , dict_struct(dict_struct_)\n     , source_ptr{std::move(source_ptr_)}\n     , dict_lifetime(dict_lifetime_)\n     , require_nonempty(require_nonempty_)\n+    , access_to_key_from_attributes(access_to_key_from_attributes_)\n     , logger(&Poco::Logger::get(\"IPAddressDictionary\"))\n {\n+    if (access_to_key_from_attributes)\n+    {\n+        dict_struct.attributes.emplace_back(dict_struct.key->front());\n+    }\n+\n     createAttributes();\n \n     loadData();\n@@ -453,8 +472,6 @@ void IPAddressDictionary::loadData()\n     auto stream = source_ptr->loadAll();\n     stream->readPrefix();\n \n-    const auto attributes_size = attributes.size();\n-\n     std::vector<IPRecord> ip_records;\n \n     bool has_ipv6 = false;\n@@ -465,14 +482,19 @@ void IPAddressDictionary::loadData()\n         element_count += rows;\n \n         const ColumnPtr key_column_ptr = block.safeGetByPosition(0).column;\n-        const auto attribute_column_ptrs = ext::map<Columns>(ext::range(0, attributes_size), [&](const size_t attribute_idx)\n+\n+        size_t attributes_size = dict_struct.attributes.size();\n+        if (access_to_key_from_attributes)\n         {\n-            return block.safeGetByPosition(attribute_idx + 1).column;\n-        });\n+            /// last attribute contains key and will be filled in code below\n+            attributes_size--;\n+        }\n+        const auto attribute_column_ptrs = ext::map<Columns>(ext::range(0, attributes_size),\n+            [&](const size_t attribute_idx) { return block.safeGetByPosition(attribute_idx + 1).column; });\n \n         for (const auto row : ext::range(0, rows))\n         {\n-            for (const auto attribute_idx : ext::range(0, attributes_size))\n+            for (const auto attribute_idx : ext::range(0, attribute_column_ptrs.size()))\n             {\n                 const auto & attribute_column = *attribute_column_ptrs[attribute_idx];\n                 auto & attribute = attributes[attribute_idx];\n@@ -490,6 +512,33 @@ void IPAddressDictionary::loadData()\n \n     stream->readSuffix();\n \n+    if (access_to_key_from_attributes)\n+    {\n+        /// We format key attribute values here instead of filling with data from key_column\n+        /// because string representation can be normalized if bits beyond mask are set.\n+        /// Also all IPv4 will be displayed as mapped IPv6 if threre are any IPv6.\n+        /// It's consistent with representation in table created with `ENGINE = Dictionary` from this dictionary.\n+        char str_buffer[48];\n+        if (has_ipv6)\n+        {\n+            uint8_t ip_buffer[IPV6_BINARY_LENGTH];\n+            for (const auto & record : ip_records)\n+            {\n+                size_t str_len = formatIPWithPrefix(record.asIPv6Binary(ip_buffer), record.prefixIPv6(), false, str_buffer);\n+                setAttributeValue(attributes.back(), String(str_buffer, str_len));\n+            }\n+        }\n+        else\n+        {\n+            for (const auto & record : ip_records)\n+            {\n+                UInt32 addr = IPv4AsUInt32(record.addr.addr());\n+                size_t str_len = formatIPWithPrefix(reinterpret_cast<const unsigned char *>(&addr), record.prefix, true, str_buffer);\n+                setAttributeValue(attributes.back(), String(str_buffer, str_len));\n+            }\n+        }\n+    }\n+\n     row_idx.reserve(ip_records.size());\n     mask_column.reserve(ip_records.size());\n \n@@ -679,7 +728,7 @@ void IPAddressDictionary::calculateBytesAllocated()\n template <typename T>\n void IPAddressDictionary::createAttributeImpl(Attribute & attribute, const Field & null_value)\n {\n-    attribute.null_values = T(null_value.get<NearestFieldType<T>>());\n+    attribute.null_values = null_value.isNull() ? T{} : T(null_value.get<NearestFieldType<T>>());\n     attribute.maps.emplace<ContainerType<T>>();\n }\n \n@@ -735,7 +784,8 @@ IPAddressDictionary::Attribute IPAddressDictionary::createAttributeWithType(cons\n \n         case AttributeUnderlyingType::utString:\n         {\n-            attr.null_values = null_value.get<String>();\n+\n+            attr.null_values = null_value.isNull() ? String() : null_value.get<String>();\n             attr.maps.emplace<ContainerType<StringRef>>();\n             attr.string_arena = std::make_unique<Arena>();\n             break;\n@@ -979,14 +1029,12 @@ static auto keyViewGetter()\n         for (size_t row : ext::range(0, key_ip_column.size()))\n         {\n             UInt8 mask = key_mask_column.getElement(row);\n-            char * ptr = buffer;\n+            size_t str_len;\n             if constexpr (IsIPv4)\n-                formatIPv4(reinterpret_cast<const unsigned char *>(&key_ip_column.getElement(row)), ptr);\n+                str_len = formatIPWithPrefix(reinterpret_cast<const unsigned char *>(&key_ip_column.getElement(row)), mask, true, buffer);\n             else\n-                formatIPv6(reinterpret_cast<const unsigned char *>(key_ip_column.getDataAt(row).data), ptr);\n-            *(ptr - 1) = '/';\n-            ptr = itoa(mask, ptr);\n-            column->insertData(buffer, ptr - buffer);\n+                str_len = formatIPWithPrefix(reinterpret_cast<const unsigned char *>(key_ip_column.getDataAt(row).data), mask, false, buffer);\n+            column->insertData(buffer, str_len);\n         }\n         return ColumnsWithTypeAndName{\n             ColumnWithTypeAndName(std::move(column), std::make_shared<DataTypeString>(), dict_attributes.front().name)};\n@@ -1120,8 +1168,12 @@ void registerDictionaryTrie(DictionaryFactory & factory)\n         const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);\n         const DictionaryLifetime dict_lifetime{config, config_prefix + \".lifetime\"};\n         const bool require_nonempty = config.getBool(config_prefix + \".require_nonempty\", false);\n+\n+        const auto & layout_prefix = config_prefix + \".layout.ip_trie\";\n+        const bool access_to_key_from_attributes = config.getBool(layout_prefix + \".access_to_key_from_attributes\", false);\n         // This is specialised dictionary for storing IPv4 and IPv6 prefixes.\n-        return std::make_unique<IPAddressDictionary>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty);\n+        return std::make_unique<IPAddressDictionary>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime,\n+                                                     require_nonempty, access_to_key_from_attributes);\n     };\n     factory.registerLayout(\"ip_trie\", create_layout, true);\n }\ndiff --git a/src/Dictionaries/IPAddressDictionary.h b/src/Dictionaries/IPAddressDictionary.h\nindex c63e6b01adff..2009141ebcc9 100644\n--- a/src/Dictionaries/IPAddressDictionary.h\n+++ b/src/Dictionaries/IPAddressDictionary.h\n@@ -27,7 +27,8 @@ class IPAddressDictionary final : public IDictionaryBase\n         const DictionaryStructure & dict_struct_,\n         DictionarySourcePtr source_ptr_,\n         const DictionaryLifetime dict_lifetime_,\n-        bool require_nonempty_);\n+        bool require_nonempty_,\n+        bool access_to_key_from_attributes_);\n \n     std::string getKeyDescription() const { return key_description; }\n \n@@ -45,7 +46,8 @@ class IPAddressDictionary final : public IDictionaryBase\n \n     std::shared_ptr<const IExternalLoadable> clone() const override\n     {\n-        return std::make_shared<IPAddressDictionary>(getDictionaryID(), dict_struct, source_ptr->clone(), dict_lifetime, require_nonempty);\n+        return std::make_shared<IPAddressDictionary>(getDictionaryID(), dict_struct, source_ptr->clone(), dict_lifetime,\n+                                                     require_nonempty, access_to_key_from_attributes);\n     }\n \n     const IDictionarySource * getSource() const override { return source_ptr.get(); }\n@@ -238,10 +240,11 @@ class IPAddressDictionary final : public IDictionaryBase\n \n     static const uint8_t * getIPv6FromOffset(const IPv6Container & ipv6_col, size_t i);\n \n-    const DictionaryStructure dict_struct;\n+    DictionaryStructure dict_struct;\n     const DictionarySourcePtr source_ptr;\n     const DictionaryLifetime dict_lifetime;\n     const bool require_nonempty;\n+    const bool access_to_key_from_attributes;\n     const std::string key_description{dict_struct.getKeyDescription()};\n \n     /// Contains sorted IP subnetworks. If some addresses equals, subnet with lower mask is placed first.\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01018_ip_dictionary.reference b/tests/queries/0_stateless/01018_ip_dictionary.reference\nindex becd2951be72..f11628001dd2 100644\n--- a/tests/queries/0_stateless/01018_ip_dictionary.reference\n+++ b/tests/queries/0_stateless/01018_ip_dictionary.reference\n@@ -123,6 +123,16 @@\n 1\n 1\n 1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n ***ipv6 trie dict***\n 1\n 1\n@@ -273,6 +283,11 @@\n 1\n 1\n 1\n+1\n+1\n+1\n+1\n+1\n ***ipv6 trie dict mask***\n 1\n 1\ndiff --git a/tests/queries/0_stateless/01018_ip_dictionary.sql b/tests/queries/0_stateless/01018_ip_dictionary.sql\nindex 4cb56b77180b..5df1afcd5599 100644\n--- a/tests/queries/0_stateless/01018_ip_dictionary.sql\n+++ b/tests/queries/0_stateless/01018_ip_dictionary.sql\n@@ -207,9 +207,20 @@ INSERT INTO database_for_dict.table_ipv4_trie VALUES ('127.255.255.255/32', 21);\n CREATE DICTIONARY database_for_dict.dict_ipv4_trie ( prefix String, val UInt32 )\n PRIMARY KEY prefix\n SOURCE(CLICKHOUSE(host 'localhost' port 9000 user 'default' db 'database_for_dict' table 'table_ipv4_trie'))\n-LAYOUT(IP_TRIE())\n+LAYOUT(IP_TRIE(ACCESS_TO_KEY_FROM_ATTRIBUTES 1))\n LIFETIME(MIN 10 MAX 100);\n \n+SELECT '127.0.0.0/24' == dictGetString('database_for_dict.dict_ipv4_trie', 'prefix', tuple(IPv4StringToNum('127.0.0.0')));\n+SELECT '127.0.0.1/32' == dictGetString('database_for_dict.dict_ipv4_trie', 'prefix', tuple(IPv4StringToNum('127.0.0.1')));\n+SELECT '127.0.0.0/24' == dictGetString('database_for_dict.dict_ipv4_trie', 'prefix', tuple(IPv4StringToNum('127.0.0.127')));\n+SELECT '127.0.0.0/16' == dictGetString('database_for_dict.dict_ipv4_trie', 'prefix', tuple(IPv4StringToNum('127.0.255.127')));\n+SELECT '127.255.0.0/16' == dictGetString('database_for_dict.dict_ipv4_trie', 'prefix', tuple(IPv4StringToNum('127.255.127.127')));\n+SELECT '127.255.128.0/24' == dictGetString('database_for_dict.dict_ipv4_trie', 'prefix', tuple(IPv4StringToNum('127.255.128.9')));\n+SELECT '127.255.128.0/24' == dictGetString('database_for_dict.dict_ipv4_trie', 'prefix', tuple(IPv4StringToNum('127.255.128.127')));\n+SELECT '127.255.128.10/32' == dictGetString('database_for_dict.dict_ipv4_trie', 'prefix', tuple(IPv4StringToNum('127.255.128.10')));\n+SELECT '127.255.128.128/25' == dictGetString('database_for_dict.dict_ipv4_trie', 'prefix', tuple(IPv4StringToNum('127.255.128.255')));\n+SELECT '127.255.255.128/32' == dictGetString('database_for_dict.dict_ipv4_trie', 'prefix', tuple(IPv4StringToNum('127.255.255.128')));\n+\n SELECT 3 == dictGetUInt32('database_for_dict.dict_ipv4_trie', 'val', tuple(IPv4StringToNum('127.0.0.0')));\n SELECT 4 == dictGetUInt32('database_for_dict.dict_ipv4_trie', 'val', tuple(IPv4StringToNum('127.0.0.1')));\n SELECT 3 == dictGetUInt32('database_for_dict.dict_ipv4_trie', 'val', tuple(IPv4StringToNum('127.0.0.127')));\n@@ -274,7 +285,7 @@ CREATE DICTIONARY database_for_dict.dict_ip_trie\n )\n PRIMARY KEY prefix\n SOURCE(CLICKHOUSE(host 'localhost' port 9000 user 'default' db 'database_for_dict' table 'table_ip_trie'))\n-LAYOUT(IP_TRIE())\n+LAYOUT(IP_TRIE(ACCESS_TO_KEY_FROM_ATTRIBUTES 1))\n LIFETIME(MIN 10 MAX 100);\n \n SELECT 'US' == dictGetString('database_for_dict.dict_ip_trie', 'val', tuple(IPv6StringToNum('2620:0:870::')));\n@@ -294,6 +305,12 @@ SELECT 'JA' == dictGetString('database_for_dict.dict_ip_trie', 'val', tuple(IPv4\n SELECT 1 == dictHas('database_for_dict.dict_ip_trie', tuple(IPv4StringToNum('127.0.0.1')));\n SELECT 1 == dictHas('database_for_dict.dict_ip_trie', tuple(IPv6StringToNum('::ffff:127.0.0.1')));\n \n+SELECT '2620:0:870::/48' == dictGetString('database_for_dict.dict_ip_trie', 'prefix', tuple(IPv6StringToNum('2620:0:870::')));\n+SELECT '2a02:6b8:1::/48' == dictGetString('database_for_dict.dict_ip_trie', 'prefix', tuple(IPv6StringToNum('2a02:6b8:1::1')));\n+SELECT '2001:db8::/32' == dictGetString('database_for_dict.dict_ip_trie', 'prefix', tuple(IPv6StringToNum('2001:db8::1')));\n+SELECT '::ffff:101.79.55.22/128' == dictGetString('database_for_dict.dict_ip_trie', 'prefix', tuple(IPv6StringToNum('::ffff:654f:3716')));\n+SELECT '::ffff:101.79.55.22/128' == dictGetString('database_for_dict.dict_ip_trie', 'prefix', tuple(IPv6StringToNum('::ffff:101.79.55.22')));\n+\n SELECT '0' == dictGetString('database_for_dict.dict_ip_trie', 'val', tuple(IPv6StringToNum('::0')));\n SELECT '1' == dictGetString('database_for_dict.dict_ip_trie', 'val', tuple(IPv6StringToNum('8000::')));\n SELECT '2' == dictGetString('database_for_dict.dict_ip_trie', 'val', tuple(IPv6StringToNum('c000::')));\n",
  "problem_statement": "Fetch key from dictionary\n**Use case**\r\nI'm using `ip_trie` on maxmind geoip databases. Given an IP address I want to find out what key was used (ie what network the IP comes under). But it seems it is not possible to look up the key field when using `dictGet`?\r\n\r\n```\r\n        <layout>\r\n            <ip_trie/>\r\n        </layout>\r\n        <structure>\r\n            <key>\r\n                <attribute>\r\n                    <name>network</name>\r\n                    <type>String</type>\r\n                </attribute>\r\n            </key>\r\n            <attribute>\r\n                <name>geoname_id</name>\r\n                <type>UInt32</type>\r\n                <null_value>0</null_value>\r\n            </attribute>\r\n...\r\n```\r\n\r\n```\r\nclickhouse :) select dictGet('geoip_city_blocks_ipv4', 'geoname_id', tuple(toUInt32(toIPv4('1.1.1.1')))) ;\r\n\r\n\u250c\u2500dictGet('geoip_city_blocks_ipv4', 'geoname_id', tuple(toUInt32(toIPv4('1.1.1.1'))))\u2500\u2510\r\n\u2502                                                                             2077456 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nclickhouse :) select dictGet('geoip_city_blocks_ipv4', 'network', tuple(toUInt32(toIPv4('1.1.1.1')))) ;\r\n\r\nReceived exception from server (version 20.11.3):\r\nCode: 36. DB::Exception: Received from localhost:9000. DB::Exception: No such attribute 'network': While processing dictGet('geoip_city_blocks_ipv4', 'network', tuple(toUInt32(toIPv4('1.1.1.1')))). \r\n```\r\n\n",
  "hints_text": "Workaround: duplicate network in another attribute.\r\n\r\nI'm not sure if it's possible to implement this feature for free, because networks may be split in parts in internal data structure.\nYeah I figured we could duplicate. I don't know the code, but one way to work around easily may be allow the `<key>` attributes to also be specified as `<attribute>` so effectively the same as the duplicating workaround but without having to do it in the base data?\nThat's a good idea!\n`dictHas` doesn't help? \nno because it would say that `a.b.c.d` existed in the dict (which i already know) but not what subnet matched eg `a.b.c.0/24`\nYou don't have to duplicate in the base data if you use `expression`\r\n```\r\n        <structure>\r\n            <key>\r\n                <attribute>\r\n                    <name>network</name>\r\n                    <type>String</type>\r\n                </attribute>\r\n            </key>\r\n            <attribute>\r\n                <name>network_desc</name>\r\n                <expression>network</expression>\r\n                <type>String</type>\r\n                <null_value></null_value>\r\n            </attribute>\r\n```\n> You don't have to duplicate in the base data if you use `expression`\r\n\r\nSeems now it doesn't work with `file` source (one of common usecase)\r\nhttps://github.com/ClickHouse/ClickHouse/blob/51481c9c5fa5235d2afcfdc98470dfc3fdb86cae/src/Dictionaries/FileDictionarySource.cpp#L85\r\n\r\nBut it works with `clickhouse` source.\r\n\r\n\n(also a note; i don't believe there is any documentation around `<expression>`)\n> (also a note; i don't believe there is any documentation around <expression>)\r\n\r\nThere is https://clickhouse.tech/docs/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-structure/#ext_dict_structure-attributes",
  "created_at": "2020-12-24T15:57:00Z"
}