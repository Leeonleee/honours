diff --git a/src/Storages/StorageMergeTree.cpp b/src/Storages/StorageMergeTree.cpp
index c6af41cc1632..983508e77eb1 100644
--- a/src/Storages/StorageMergeTree.cpp
+++ b/src/Storages/StorageMergeTree.cpp
@@ -365,6 +365,8 @@ struct CurrentlyMergingPartsTagger
                 entry.latest_fail_reason = exception_message;
             }
         }
+
+        storage.currently_processing_in_background_condition.notify_all();
     }
 };
 
@@ -566,7 +568,7 @@ bool StorageMergeTree::merge(
     std::optional<CurrentlyMergingPartsTagger> merging_tagger;
 
     {
-        std::lock_guard lock(currently_processing_in_background_mutex);
+        std::unique_lock lock(currently_processing_in_background_mutex);
 
         auto can_merge = [this, &lock] (const DataPartPtr & left, const DataPartPtr & right, String *) -> bool
         {
@@ -590,8 +592,33 @@ bool StorageMergeTree::merge(
         }
         else
         {
-            UInt64 disk_space = getStoragePolicy()->getMaxUnreservedFreeSpace();
-            selected = merger_mutator.selectAllPartsToMergeWithinPartition(future_part, disk_space, can_merge, partition_id, final, out_disable_reason);
+            while (true)
+            {
+                UInt64 disk_space = getStoragePolicy()->getMaxUnreservedFreeSpace();
+                selected = merger_mutator.selectAllPartsToMergeWithinPartition(
+                    future_part, disk_space, can_merge, partition_id, final, out_disable_reason);
+
+                /// If final - we will wait for currently processing merges to finish and continue.
+                /// TODO Respect query settings for timeout
+                if (final
+                    && !selected
+                    && !currently_merging_mutating_parts.empty()
+                    && out_disable_reason
+                    && out_disable_reason->empty())
+                {
+                    LOG_DEBUG(log, "Waiting for currently running merges ({} parts are merging right now) to perform OPTIMIZE FINAL",
+                        currently_merging_mutating_parts.size());
+
+                    if (std::cv_status::timeout == currently_processing_in_background_condition.wait_for(
+                        lock, std::chrono::seconds(DBMS_DEFAULT_LOCK_ACQUIRE_TIMEOUT_SEC)))
+                    {
+                        *out_disable_reason = "Timeout while waiting for already running merges before running OPTIMIZE with FINAL";
+                        break;
+                    }
+                }
+                else
+                    break;
+            }
         }
 
         if (!selected)
@@ -847,7 +874,7 @@ BackgroundProcessingPoolTaskResult StorageMergeTree::mergeMutateTask()
 
 Int64 StorageMergeTree::getCurrentMutationVersion(
     const DataPartPtr & part,
-    std::lock_guard<std::mutex> & /* currently_processing_in_background_mutex_lock */) const
+    std::unique_lock<std::mutex> & /* currently_processing_in_background_mutex_lock */) const
 {
     auto it = current_mutations_by_version.upper_bound(part->info.getDataVersion());
     if (it == current_mutations_by_version.begin())
diff --git a/src/Storages/StorageMergeTree.h b/src/Storages/StorageMergeTree.h
index 473177abf1e7..c6c8f99a62a3 100644
--- a/src/Storages/StorageMergeTree.h
+++ b/src/Storages/StorageMergeTree.h
@@ -95,6 +95,7 @@ class StorageMergeTree final : public ext::shared_ptr_helper<StorageMergeTree>,
     /// Mutex for parts currently processing in background
     /// merging (also with TTL), mutating or moving.
     mutable std::mutex currently_processing_in_background_mutex;
+    mutable std::condition_variable currently_processing_in_background_condition;
 
     /// Parts that currently participate in merge or mutation.
     /// This set have to be used with `currently_processing_in_background_mutex`.
@@ -133,7 +134,7 @@ class StorageMergeTree final : public ext::shared_ptr_helper<StorageMergeTree>,
 
     Int64 getCurrentMutationVersion(
         const DataPartPtr & part,
-        std::lock_guard<std::mutex> & /* currently_processing_in_background_mutex_lock */) const;
+        std::unique_lock<std::mutex> & /* currently_processing_in_background_mutex_lock */) const;
 
     void clearOldMutations(bool truncate = false);
 
