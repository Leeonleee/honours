diff --git a/base/base/bit_cast.h b/base/base/bit_cast.h
index 5373ead36e80..4783a84586b0 100644
--- a/base/base/bit_cast.h
+++ b/base/base/bit_cast.h
@@ -7,7 +7,13 @@
 
 /** Returns value `from` converted to type `To` while retaining bit representation.
   * `To` and `From` must satisfy `CopyConstructible`.
+  *
   * In contrast to std::bit_cast can cast types of different width.
+  *
+  * Note: for signed types of narrower size, the casted result is zero-extended
+  * instead of sign-extended as with regular static_cast.
+  * For example, -1 Int8 (represented as 0xFF) bit_casted to UInt64
+  * gives 255 (represented as 0x00000000000000FF) instead of 0xFFFFFFFFFFFFFFFF
   */
 template <typename To, typename From>
 std::decay_t<To> bit_cast(const From & from)
diff --git a/src/Functions/transform.cpp b/src/Functions/transform.cpp
index 9970012ef4a7..3e4ca4124912 100644
--- a/src/Functions/transform.cpp
+++ b/src/Functions/transform.cpp
@@ -5,6 +5,7 @@
 #include <Columns/ColumnConst.h>
 #include <Columns/ColumnDecimal.h>
 #include <Columns/ColumnString.h>
+#include <Columns/ColumnNullable.h>
 #include <Core/DecimalFunctions.h>
 #include <DataTypes/DataTypeArray.h>
 #include <DataTypes/getLeastSupertype.h>
@@ -13,10 +14,10 @@
 #include <Functions/IFunction.h>
 #include <Interpreters/castColumn.h>
 #include <Interpreters/convertFieldToType.h>
-#include <Common/Arena.h>
 #include <Common/HashTable/HashMap.h>
 #include <Common/typeid_cast.h>
 
+
 namespace DB
 {
 namespace ErrorCodes
@@ -25,32 +26,31 @@ namespace ErrorCodes
     extern const int BAD_ARGUMENTS;
     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
     extern const int ILLEGAL_COLUMN;
+    extern const int LOGICAL_ERROR;
 }
 
 namespace
 {
-    /** transform(x, from_array, to_array[, default]) - convert x according to an explicitly passed match.
-  */
     /** transform(x, [from...], [to...], default)
-  * - converts the values according to the explicitly specified mapping.
-  *
-  * x - what to transform.
-  * from - a constant array of values for the transformation.
-  * to - a constant array of values into which values from `from` must be transformed.
-  * default - what value to use if x is not equal to any of the values in `from`.
-  * `from` and `to` - arrays of the same size.
-  *
-  * Types:
-  * transform(T, Array(T), Array(U), U) -> U
-  *
-  * transform(x, [from...], [to...])
-  * - if `default` is not specified, then for values of `x` for which there is no corresponding element in `from`, the unchanged value of `x` is returned.
-  *
-  * Types:
-  * transform(T, Array(T), Array(T)) -> T
-  *
-  * Note: the implementation is rather cumbersome.
-  */
+      * - converts the values according to the explicitly specified mapping.
+      *
+      * x - what to transform.
+      * from - a constant array of values for the transformation.
+      * to - a constant array of values into which values from `from` must be transformed.
+      * default - what value to use if x is not equal to any of the values in `from`.
+      * `from` and `to` - arrays of the same size.
+      *
+      * Types:
+      * transform(T, Array(T), Array(U), U) -> U
+      *
+      * transform(x, [from...], [to...])
+      * - if `default` is not specified, then for values of `x` for which there is no corresponding element in `from`, the unchanged value of `x` is returned.
+      *
+      * Types:
+      * transform(T, Array(T), Array(T)) -> T
+      *
+      * Note: the implementation is rather cumbersome.
+      */
     class FunctionTransform : public IFunction
     {
     public:
@@ -236,7 +236,7 @@ namespace
                 {
                     const auto * it = table.find(bit_cast<UInt64>(pod[i]));
                     if (it)
-                        column_result.insertFrom(*cache.to_columns, it->getMapped());
+                        column_result.insertFrom(*cache.to_column, it->getMapped());
                     else if (cache.default_column)
                         column_result.insertFrom(*cache.default_column, 0);
                     else if (default_non_const)
@@ -259,14 +259,14 @@ namespace
             out_offs.resize(size);
             auto & out_chars = out->getChars();
 
-            const auto * to_col = reinterpret_cast<const ColumnString *>(cache.to_columns.get());
+            const auto * to_col = assert_cast<const ColumnString *>(cache.to_column.get());
             const auto & to_chars = to_col->getChars();
             const auto & to_offs = to_col->getOffsets();
             const auto & table = *cache.table_num_to_idx;
 
             if (cache.default_column)
             {
-                const auto * def = reinterpret_cast<const ColumnString *>(cache.default_column.get());
+                const auto * def = assert_cast<const ColumnString *>(cache.default_column.get());
                 const auto & def_chars = def->getChars();
                 const auto & def_offs = def->getOffsets();
                 const auto * def_data = def_chars.data();
@@ -275,7 +275,7 @@ namespace
             }
             else
             {
-                const auto * def = reinterpret_cast<const ColumnString *>(default_non_const.get());
+                const auto * def = assert_cast<const ColumnString *>(default_non_const.get());
                 const auto & def_chars = def->getChars();
                 const auto & def_offs = def->getOffsets();
                 executeNumToStringHelper(table, pod, out_chars, out_offs, to_chars, to_offs, def_chars, def_offs, size);
@@ -340,16 +340,16 @@ namespace
             if constexpr (std::is_same_v<ColumnDecimal<Decimal32>, T> || std::is_same_v<ColumnDecimal<Decimal64>, T>)
                 out_scale = out->getScale();
 
-            const auto & to_pod = reinterpret_cast<const T *>(cache.to_columns.get())->getData();
+            const auto & to_pod = assert_cast<const T *>(cache.to_column.get())->getData();
             const auto & table = *cache.table_num_to_idx;
             if (cache.default_column)
             {
-                const auto const_def = reinterpret_cast<const T *>(cache.default_column.get())->getData()[0];
+                const auto const_def = assert_cast<const T *>(cache.default_column.get())->getData()[0];
                 executeNumToNumHelper(table, pod, out_pod, to_pod, const_def, size, out_scale, out_scale);
             }
             else if (default_non_const)
             {
-                const auto & nconst_def = reinterpret_cast<const T *>(default_non_const.get())->getData();
+                const auto & nconst_def = assert_cast<const T *>(default_non_const.get())->getData();
                 executeNumToNumHelper(table, pod, out_pod, to_pod, nconst_def, size, out_scale, out_scale);
             }
             else
@@ -423,11 +423,11 @@ namespace
                 ColumnString::Offset current_offset = 0;
                 for (size_t i = 0; i < size; ++i)
                 {
-                    const StringRef ref{&data[current_offset], offsets[i] - current_offset};
+                    const StringRef ref{&data[current_offset], offsets[i] - current_offset - 1};
                     current_offset = offsets[i];
                     const auto * it = table.find(ref);
                     if (it)
-                        column_result.insertFrom(*cache.to_columns, it->getMapped());
+                        column_result.insertFrom(*cache.to_column, it->getMapped());
                     else if (cache.default_column)
                         column_result.insertFrom(*cache.default_column, 0);
                     else if (default_non_const)
@@ -453,14 +453,14 @@ namespace
             out_offs.resize(size);
             auto & out_chars = out->getChars();
 
-            const auto * to_col = reinterpret_cast<const ColumnString *>(cache.to_columns.get());
+            const auto * to_col = assert_cast<const ColumnString *>(cache.to_column.get());
             const auto & to_chars = to_col->getChars();
             const auto & to_offs = to_col->getOffsets();
 
             const auto & table = *cache.table_string_to_idx;
             if (cache.default_column)
             {
-                const auto * def = reinterpret_cast<const ColumnString *>(cache.default_column.get());
+                const auto * def = assert_cast<const ColumnString *>(cache.default_column.get());
                 const auto & def_chars = def->getChars();
                 const auto & def_offs = def->getOffsets();
                 const auto * def_data = def_chars.data();
@@ -469,7 +469,7 @@ namespace
             }
             else if (default_non_const)
             {
-                const auto * def = reinterpret_cast<const ColumnString *>(default_non_const.get());
+                const auto * def = assert_cast<const ColumnString *>(default_non_const.get());
                 const auto & def_chars = def->getChars();
                 const auto & def_offs = def->getOffsets();
                 executeStringToStringHelper(table, data, offsets, out_chars, out_offs, to_chars, to_offs, def_chars, def_offs, size);
@@ -500,7 +500,7 @@ namespace
             {
                 const char8_t * to = nullptr;
                 size_t to_size = 0;
-                const StringRef ref{&data[current_offset], offsets[i] - current_offset};
+                const StringRef ref{&data[current_offset], offsets[i] - current_offset - 1};
                 current_offset = offsets[i];
                 const auto * it = table.find(ref);
                 if (it)
@@ -542,16 +542,16 @@ namespace
             const size_t size = offsets.size();
             out_pod.resize(size);
 
-            const auto & to_pod = reinterpret_cast<const T *>(cache.to_columns.get())->getData();
+            const auto & to_pod = assert_cast<const T *>(cache.to_column.get())->getData();
             const auto & table = *cache.table_string_to_idx;
             if (cache.default_column)
             {
-                const auto const_def = reinterpret_cast<const T *>(cache.default_column.get())->getData()[0];
+                const auto const_def = assert_cast<const T *>(cache.default_column.get())->getData()[0];
                 executeStringToNumHelper(table, data, offsets, out_pod, to_pod, const_def, size);
             }
             else
             {
-                const auto & nconst_def = reinterpret_cast<const T *>(default_non_const.get())->getData();
+                const auto & nconst_def = assert_cast<const T *>(default_non_const.get())->getData();
                 executeStringToNumHelper(table, data, offsets, out_pod, to_pod, nconst_def, size);
             }
             return true;
@@ -570,7 +570,7 @@ namespace
             ColumnString::Offset current_offset = 0;
             for (size_t i = 0; i < size; ++i)
             {
-                const StringRef ref{&data[current_offset], offsets[i] - current_offset};
+                const StringRef ref{&data[current_offset], offsets[i] - current_offset - 1};
                 current_offset = offsets[i];
                 const auto * it = table.find(ref);
                 if (it)
@@ -597,11 +597,10 @@ namespace
             std::unique_ptr<NumToIdx> table_num_to_idx;
             std::unique_ptr<StringToIdx> table_string_to_idx;
 
-            ColumnPtr to_columns;
+            ColumnPtr from_column;
+            ColumnPtr to_column;
             ColumnPtr default_column;
 
-            Arena string_pool;
-
             std::atomic<bool> initialized{false};
             std::mutex mutex;
         };
@@ -609,27 +608,6 @@ namespace
         mutable Cache cache;
 
 
-        static UInt64 bitCastToUInt64(const Field & x)
-        {
-            switch (x.getType())
-            {
-                case Field::Types::UInt64:
-                    return x.get<UInt64>();
-                case Field::Types::Int64:
-                    return x.get<Int64>();
-                case Field::Types::Float64:
-                    return std::bit_cast<UInt64>(x.get<Float64>());
-                case Field::Types::Bool:
-                    return x.get<bool>();
-                case Field::Types::Decimal32:
-                    return x.get<DecimalField<Decimal32>>().getValue();
-                case Field::Types::Decimal64:
-                    return x.get<DecimalField<Decimal64>>().getValue();
-                default:
-                    throw Exception(ErrorCodes::BAD_ARGUMENTS, "Unexpected type in function 'transform'");
-            }
-        }
-
         static void checkAllowedType(const DataTypePtr & type)
         {
             if (type->isNullable())
@@ -656,33 +634,49 @@ namespace
         /// Can be called from different threads. It works only on the first call.
         void initialize(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type) const
         {
-            const ColumnConst * array_from = checkAndGetColumnConst<ColumnArray>(arguments[1].column.get());
-            const ColumnConst * array_to = checkAndGetColumnConst<ColumnArray>(arguments[2].column.get());
+            if (cache.initialized)
+                return;
+
+            const DataTypePtr & from_type = arguments[0].type;
+
+            const ColumnArray * array_from = checkAndGetColumnConstData<ColumnArray>(arguments[1].column.get());
+            const ColumnArray * array_to = checkAndGetColumnConstData<ColumnArray>(arguments[2].column.get());
 
             if (!array_from || !array_to)
                 throw Exception(
                     ErrorCodes::ILLEGAL_COLUMN, "Second and third arguments of function {} must be constant arrays.", getName());
 
-            if (cache.initialized)
-                return;
+            std::lock_guard lock(cache.mutex);
 
-            const auto & from = array_from->getValue<Array>();
-            const size_t size = from.size();
-            if (0 == size)
-                throw Exception(ErrorCodes::BAD_ARGUMENTS, "Empty arrays are illegal in function {}", getName());
+            ColumnPtr from_column_or_null_ptr = castColumnAccurateOrNull(
+                {
+                    array_from->getDataPtr(),
+                    typeid_cast<const DataTypeArray &>(*arguments[1].type).getNestedType(),
+                    arguments[1].name
+                },
+                from_type);
 
-            std::lock_guard lock(cache.mutex);
+            const ColumnNullable & from_column_or_null = assert_cast<const ColumnNullable &>(*from_column_or_null_ptr);
 
-            if (cache.initialized)
-                return;
+            cache.from_column = from_column_or_null.getNestedColumnPtr();
+
+            cache.to_column = castColumn(
+                {
+                    array_to->getDataPtr(),
+                    typeid_cast<const DataTypeArray &>(*arguments[2].type).getNestedType(),
+                    arguments[2].name
+                },
+                result_type);
+
+            const size_t size = cache.from_column->size();
+            if (0 == size)
+                throw Exception(ErrorCodes::BAD_ARGUMENTS, "Empty arrays are illegal in function {}", getName());
 
-            const auto & to = array_to->getValue<Array>();
-            if (size != to.size())
+            if (cache.to_column->size() != size)
                 throw Exception(
                     ErrorCodes::BAD_ARGUMENTS, "Second and third arguments of function {} must be arrays of same size", getName());
 
             /// Whether the default value is set.
-
             if (arguments.size() == 4)
             {
                 const IColumn * default_col = arguments[3].column.get();
@@ -702,45 +696,41 @@ namespace
 
             /// Note: Doesn't check the duplicates in the `from` array.
 
-            const IDataType & from_type = *arguments[0].type;
-
-            if (from[0].getType() != Field::Types::String)
+            if (from_type->isValueRepresentedByNumber())
             {
                 cache.table_num_to_idx = std::make_unique<Cache::NumToIdx>();
                 auto & table = *cache.table_num_to_idx;
                 for (size_t i = 0; i < size; ++i)
                 {
-                    Field key = convertFieldToType(from[i], from_type);
-                    if (key.isNull())
-                        continue;
-
-                    /// Field may be of Float type, but for the purpose of bitwise equality we can treat them as UInt64
-                    table[bitCastToUInt64(key)] = i;
+                    if (!from_column_or_null.isNullAt(i))
+                    {
+                        /// Field may be of Float type, but for the purpose of bitwise equality we can treat them as UInt64
+                        StringRef ref = cache.from_column->getDataAt(i);
+                        UInt64 key = 0;
+                        memcpy(&key, ref.data, ref.size);
+                        table[key] = i;
+                    }
                 }
             }
-            else
+            else if (from_type->isValueUnambiguouslyRepresentedInContiguousMemoryRegion())
             {
                 cache.table_string_to_idx = std::make_unique<Cache::StringToIdx>();
                 auto & table = *cache.table_string_to_idx;
                 for (size_t i = 0; i < size; ++i)
                 {
-                    const String & str_from = from[i].get<const String &>();
-                    StringRef ref{cache.string_pool.insert(str_from.data(), str_from.size() + 1), str_from.size() + 1};
-                    table[ref] = i;
+                    if (!from_column_or_null.isNullAt(i))
+                    {
+                        StringRef ref = cache.from_column->getDataAt(i);
+                        table[ref] = i;
+                    }
                 }
             }
-
-            auto to_columns = result_type->createColumn();
-            for (size_t i = 0; i < size; ++i)
-            {
-                Field to_value = convertFieldToType(to[i], *result_type);
-                to_columns->insert(to_value);
-            }
-            cache.to_columns = std::move(to_columns);
+            else
+                throw Exception(ErrorCodes::LOGICAL_ERROR, "Unexpected data type {} as the first argument in function `transform`", from_type->getName());
 
             cache.initialized = true;
         }
-};
+    };
 
 }
 
