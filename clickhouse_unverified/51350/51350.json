{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 51350,
  "instance_id": "ClickHouse__ClickHouse-51350",
  "issue_numbers": [
    "51322"
  ],
  "base_commit": "50f0cd48c6c07aa0bbc0134e116c2dc2baf3b9ef",
  "patch": "diff --git a/base/base/bit_cast.h b/base/base/bit_cast.h\nindex 5373ead36e80..4783a84586b0 100644\n--- a/base/base/bit_cast.h\n+++ b/base/base/bit_cast.h\n@@ -7,7 +7,13 @@\n \n /** Returns value `from` converted to type `To` while retaining bit representation.\n   * `To` and `From` must satisfy `CopyConstructible`.\n+  *\n   * In contrast to std::bit_cast can cast types of different width.\n+  *\n+  * Note: for signed types of narrower size, the casted result is zero-extended\n+  * instead of sign-extended as with regular static_cast.\n+  * For example, -1 Int8 (represented as 0xFF) bit_casted to UInt64\n+  * gives 255 (represented as 0x00000000000000FF) instead of 0xFFFFFFFFFFFFFFFF\n   */\n template <typename To, typename From>\n std::decay_t<To> bit_cast(const From & from)\ndiff --git a/src/Functions/transform.cpp b/src/Functions/transform.cpp\nindex 9970012ef4a7..3e4ca4124912 100644\n--- a/src/Functions/transform.cpp\n+++ b/src/Functions/transform.cpp\n@@ -5,6 +5,7 @@\n #include <Columns/ColumnConst.h>\n #include <Columns/ColumnDecimal.h>\n #include <Columns/ColumnString.h>\n+#include <Columns/ColumnNullable.h>\n #include <Core/DecimalFunctions.h>\n #include <DataTypes/DataTypeArray.h>\n #include <DataTypes/getLeastSupertype.h>\n@@ -13,10 +14,10 @@\n #include <Functions/IFunction.h>\n #include <Interpreters/castColumn.h>\n #include <Interpreters/convertFieldToType.h>\n-#include <Common/Arena.h>\n #include <Common/HashTable/HashMap.h>\n #include <Common/typeid_cast.h>\n \n+\n namespace DB\n {\n namespace ErrorCodes\n@@ -25,32 +26,31 @@ namespace ErrorCodes\n     extern const int BAD_ARGUMENTS;\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n     extern const int ILLEGAL_COLUMN;\n+    extern const int LOGICAL_ERROR;\n }\n \n namespace\n {\n-    /** transform(x, from_array, to_array[, default]) - convert x according to an explicitly passed match.\n-  */\n     /** transform(x, [from...], [to...], default)\n-  * - converts the values according to the explicitly specified mapping.\n-  *\n-  * x - what to transform.\n-  * from - a constant array of values for the transformation.\n-  * to - a constant array of values into which values from `from` must be transformed.\n-  * default - what value to use if x is not equal to any of the values in `from`.\n-  * `from` and `to` - arrays of the same size.\n-  *\n-  * Types:\n-  * transform(T, Array(T), Array(U), U) -> U\n-  *\n-  * transform(x, [from...], [to...])\n-  * - if `default` is not specified, then for values of `x` for which there is no corresponding element in `from`, the unchanged value of `x` is returned.\n-  *\n-  * Types:\n-  * transform(T, Array(T), Array(T)) -> T\n-  *\n-  * Note: the implementation is rather cumbersome.\n-  */\n+      * - converts the values according to the explicitly specified mapping.\n+      *\n+      * x - what to transform.\n+      * from - a constant array of values for the transformation.\n+      * to - a constant array of values into which values from `from` must be transformed.\n+      * default - what value to use if x is not equal to any of the values in `from`.\n+      * `from` and `to` - arrays of the same size.\n+      *\n+      * Types:\n+      * transform(T, Array(T), Array(U), U) -> U\n+      *\n+      * transform(x, [from...], [to...])\n+      * - if `default` is not specified, then for values of `x` for which there is no corresponding element in `from`, the unchanged value of `x` is returned.\n+      *\n+      * Types:\n+      * transform(T, Array(T), Array(T)) -> T\n+      *\n+      * Note: the implementation is rather cumbersome.\n+      */\n     class FunctionTransform : public IFunction\n     {\n     public:\n@@ -236,7 +236,7 @@ namespace\n                 {\n                     const auto * it = table.find(bit_cast<UInt64>(pod[i]));\n                     if (it)\n-                        column_result.insertFrom(*cache.to_columns, it->getMapped());\n+                        column_result.insertFrom(*cache.to_column, it->getMapped());\n                     else if (cache.default_column)\n                         column_result.insertFrom(*cache.default_column, 0);\n                     else if (default_non_const)\n@@ -259,14 +259,14 @@ namespace\n             out_offs.resize(size);\n             auto & out_chars = out->getChars();\n \n-            const auto * to_col = reinterpret_cast<const ColumnString *>(cache.to_columns.get());\n+            const auto * to_col = assert_cast<const ColumnString *>(cache.to_column.get());\n             const auto & to_chars = to_col->getChars();\n             const auto & to_offs = to_col->getOffsets();\n             const auto & table = *cache.table_num_to_idx;\n \n             if (cache.default_column)\n             {\n-                const auto * def = reinterpret_cast<const ColumnString *>(cache.default_column.get());\n+                const auto * def = assert_cast<const ColumnString *>(cache.default_column.get());\n                 const auto & def_chars = def->getChars();\n                 const auto & def_offs = def->getOffsets();\n                 const auto * def_data = def_chars.data();\n@@ -275,7 +275,7 @@ namespace\n             }\n             else\n             {\n-                const auto * def = reinterpret_cast<const ColumnString *>(default_non_const.get());\n+                const auto * def = assert_cast<const ColumnString *>(default_non_const.get());\n                 const auto & def_chars = def->getChars();\n                 const auto & def_offs = def->getOffsets();\n                 executeNumToStringHelper(table, pod, out_chars, out_offs, to_chars, to_offs, def_chars, def_offs, size);\n@@ -340,16 +340,16 @@ namespace\n             if constexpr (std::is_same_v<ColumnDecimal<Decimal32>, T> || std::is_same_v<ColumnDecimal<Decimal64>, T>)\n                 out_scale = out->getScale();\n \n-            const auto & to_pod = reinterpret_cast<const T *>(cache.to_columns.get())->getData();\n+            const auto & to_pod = assert_cast<const T *>(cache.to_column.get())->getData();\n             const auto & table = *cache.table_num_to_idx;\n             if (cache.default_column)\n             {\n-                const auto const_def = reinterpret_cast<const T *>(cache.default_column.get())->getData()[0];\n+                const auto const_def = assert_cast<const T *>(cache.default_column.get())->getData()[0];\n                 executeNumToNumHelper(table, pod, out_pod, to_pod, const_def, size, out_scale, out_scale);\n             }\n             else if (default_non_const)\n             {\n-                const auto & nconst_def = reinterpret_cast<const T *>(default_non_const.get())->getData();\n+                const auto & nconst_def = assert_cast<const T *>(default_non_const.get())->getData();\n                 executeNumToNumHelper(table, pod, out_pod, to_pod, nconst_def, size, out_scale, out_scale);\n             }\n             else\n@@ -423,11 +423,11 @@ namespace\n                 ColumnString::Offset current_offset = 0;\n                 for (size_t i = 0; i < size; ++i)\n                 {\n-                    const StringRef ref{&data[current_offset], offsets[i] - current_offset};\n+                    const StringRef ref{&data[current_offset], offsets[i] - current_offset - 1};\n                     current_offset = offsets[i];\n                     const auto * it = table.find(ref);\n                     if (it)\n-                        column_result.insertFrom(*cache.to_columns, it->getMapped());\n+                        column_result.insertFrom(*cache.to_column, it->getMapped());\n                     else if (cache.default_column)\n                         column_result.insertFrom(*cache.default_column, 0);\n                     else if (default_non_const)\n@@ -453,14 +453,14 @@ namespace\n             out_offs.resize(size);\n             auto & out_chars = out->getChars();\n \n-            const auto * to_col = reinterpret_cast<const ColumnString *>(cache.to_columns.get());\n+            const auto * to_col = assert_cast<const ColumnString *>(cache.to_column.get());\n             const auto & to_chars = to_col->getChars();\n             const auto & to_offs = to_col->getOffsets();\n \n             const auto & table = *cache.table_string_to_idx;\n             if (cache.default_column)\n             {\n-                const auto * def = reinterpret_cast<const ColumnString *>(cache.default_column.get());\n+                const auto * def = assert_cast<const ColumnString *>(cache.default_column.get());\n                 const auto & def_chars = def->getChars();\n                 const auto & def_offs = def->getOffsets();\n                 const auto * def_data = def_chars.data();\n@@ -469,7 +469,7 @@ namespace\n             }\n             else if (default_non_const)\n             {\n-                const auto * def = reinterpret_cast<const ColumnString *>(default_non_const.get());\n+                const auto * def = assert_cast<const ColumnString *>(default_non_const.get());\n                 const auto & def_chars = def->getChars();\n                 const auto & def_offs = def->getOffsets();\n                 executeStringToStringHelper(table, data, offsets, out_chars, out_offs, to_chars, to_offs, def_chars, def_offs, size);\n@@ -500,7 +500,7 @@ namespace\n             {\n                 const char8_t * to = nullptr;\n                 size_t to_size = 0;\n-                const StringRef ref{&data[current_offset], offsets[i] - current_offset};\n+                const StringRef ref{&data[current_offset], offsets[i] - current_offset - 1};\n                 current_offset = offsets[i];\n                 const auto * it = table.find(ref);\n                 if (it)\n@@ -542,16 +542,16 @@ namespace\n             const size_t size = offsets.size();\n             out_pod.resize(size);\n \n-            const auto & to_pod = reinterpret_cast<const T *>(cache.to_columns.get())->getData();\n+            const auto & to_pod = assert_cast<const T *>(cache.to_column.get())->getData();\n             const auto & table = *cache.table_string_to_idx;\n             if (cache.default_column)\n             {\n-                const auto const_def = reinterpret_cast<const T *>(cache.default_column.get())->getData()[0];\n+                const auto const_def = assert_cast<const T *>(cache.default_column.get())->getData()[0];\n                 executeStringToNumHelper(table, data, offsets, out_pod, to_pod, const_def, size);\n             }\n             else\n             {\n-                const auto & nconst_def = reinterpret_cast<const T *>(default_non_const.get())->getData();\n+                const auto & nconst_def = assert_cast<const T *>(default_non_const.get())->getData();\n                 executeStringToNumHelper(table, data, offsets, out_pod, to_pod, nconst_def, size);\n             }\n             return true;\n@@ -570,7 +570,7 @@ namespace\n             ColumnString::Offset current_offset = 0;\n             for (size_t i = 0; i < size; ++i)\n             {\n-                const StringRef ref{&data[current_offset], offsets[i] - current_offset};\n+                const StringRef ref{&data[current_offset], offsets[i] - current_offset - 1};\n                 current_offset = offsets[i];\n                 const auto * it = table.find(ref);\n                 if (it)\n@@ -597,11 +597,10 @@ namespace\n             std::unique_ptr<NumToIdx> table_num_to_idx;\n             std::unique_ptr<StringToIdx> table_string_to_idx;\n \n-            ColumnPtr to_columns;\n+            ColumnPtr from_column;\n+            ColumnPtr to_column;\n             ColumnPtr default_column;\n \n-            Arena string_pool;\n-\n             std::atomic<bool> initialized{false};\n             std::mutex mutex;\n         };\n@@ -609,27 +608,6 @@ namespace\n         mutable Cache cache;\n \n \n-        static UInt64 bitCastToUInt64(const Field & x)\n-        {\n-            switch (x.getType())\n-            {\n-                case Field::Types::UInt64:\n-                    return x.get<UInt64>();\n-                case Field::Types::Int64:\n-                    return x.get<Int64>();\n-                case Field::Types::Float64:\n-                    return std::bit_cast<UInt64>(x.get<Float64>());\n-                case Field::Types::Bool:\n-                    return x.get<bool>();\n-                case Field::Types::Decimal32:\n-                    return x.get<DecimalField<Decimal32>>().getValue();\n-                case Field::Types::Decimal64:\n-                    return x.get<DecimalField<Decimal64>>().getValue();\n-                default:\n-                    throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Unexpected type in function 'transform'\");\n-            }\n-        }\n-\n         static void checkAllowedType(const DataTypePtr & type)\n         {\n             if (type->isNullable())\n@@ -656,33 +634,49 @@ namespace\n         /// Can be called from different threads. It works only on the first call.\n         void initialize(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type) const\n         {\n-            const ColumnConst * array_from = checkAndGetColumnConst<ColumnArray>(arguments[1].column.get());\n-            const ColumnConst * array_to = checkAndGetColumnConst<ColumnArray>(arguments[2].column.get());\n+            if (cache.initialized)\n+                return;\n+\n+            const DataTypePtr & from_type = arguments[0].type;\n+\n+            const ColumnArray * array_from = checkAndGetColumnConstData<ColumnArray>(arguments[1].column.get());\n+            const ColumnArray * array_to = checkAndGetColumnConstData<ColumnArray>(arguments[2].column.get());\n \n             if (!array_from || !array_to)\n                 throw Exception(\n                     ErrorCodes::ILLEGAL_COLUMN, \"Second and third arguments of function {} must be constant arrays.\", getName());\n \n-            if (cache.initialized)\n-                return;\n+            std::lock_guard lock(cache.mutex);\n \n-            const auto & from = array_from->getValue<Array>();\n-            const size_t size = from.size();\n-            if (0 == size)\n-                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Empty arrays are illegal in function {}\", getName());\n+            ColumnPtr from_column_or_null_ptr = castColumnAccurateOrNull(\n+                {\n+                    array_from->getDataPtr(),\n+                    typeid_cast<const DataTypeArray &>(*arguments[1].type).getNestedType(),\n+                    arguments[1].name\n+                },\n+                from_type);\n \n-            std::lock_guard lock(cache.mutex);\n+            const ColumnNullable & from_column_or_null = assert_cast<const ColumnNullable &>(*from_column_or_null_ptr);\n \n-            if (cache.initialized)\n-                return;\n+            cache.from_column = from_column_or_null.getNestedColumnPtr();\n+\n+            cache.to_column = castColumn(\n+                {\n+                    array_to->getDataPtr(),\n+                    typeid_cast<const DataTypeArray &>(*arguments[2].type).getNestedType(),\n+                    arguments[2].name\n+                },\n+                result_type);\n+\n+            const size_t size = cache.from_column->size();\n+            if (0 == size)\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Empty arrays are illegal in function {}\", getName());\n \n-            const auto & to = array_to->getValue<Array>();\n-            if (size != to.size())\n+            if (cache.to_column->size() != size)\n                 throw Exception(\n                     ErrorCodes::BAD_ARGUMENTS, \"Second and third arguments of function {} must be arrays of same size\", getName());\n \n             /// Whether the default value is set.\n-\n             if (arguments.size() == 4)\n             {\n                 const IColumn * default_col = arguments[3].column.get();\n@@ -702,45 +696,41 @@ namespace\n \n             /// Note: Doesn't check the duplicates in the `from` array.\n \n-            const IDataType & from_type = *arguments[0].type;\n-\n-            if (from[0].getType() != Field::Types::String)\n+            if (from_type->isValueRepresentedByNumber())\n             {\n                 cache.table_num_to_idx = std::make_unique<Cache::NumToIdx>();\n                 auto & table = *cache.table_num_to_idx;\n                 for (size_t i = 0; i < size; ++i)\n                 {\n-                    Field key = convertFieldToType(from[i], from_type);\n-                    if (key.isNull())\n-                        continue;\n-\n-                    /// Field may be of Float type, but for the purpose of bitwise equality we can treat them as UInt64\n-                    table[bitCastToUInt64(key)] = i;\n+                    if (!from_column_or_null.isNullAt(i))\n+                    {\n+                        /// Field may be of Float type, but for the purpose of bitwise equality we can treat them as UInt64\n+                        StringRef ref = cache.from_column->getDataAt(i);\n+                        UInt64 key = 0;\n+                        memcpy(&key, ref.data, ref.size);\n+                        table[key] = i;\n+                    }\n                 }\n             }\n-            else\n+            else if (from_type->isValueUnambiguouslyRepresentedInContiguousMemoryRegion())\n             {\n                 cache.table_string_to_idx = std::make_unique<Cache::StringToIdx>();\n                 auto & table = *cache.table_string_to_idx;\n                 for (size_t i = 0; i < size; ++i)\n                 {\n-                    const String & str_from = from[i].get<const String &>();\n-                    StringRef ref{cache.string_pool.insert(str_from.data(), str_from.size() + 1), str_from.size() + 1};\n-                    table[ref] = i;\n+                    if (!from_column_or_null.isNullAt(i))\n+                    {\n+                        StringRef ref = cache.from_column->getDataAt(i);\n+                        table[ref] = i;\n+                    }\n                 }\n             }\n-\n-            auto to_columns = result_type->createColumn();\n-            for (size_t i = 0; i < size; ++i)\n-            {\n-                Field to_value = convertFieldToType(to[i], *result_type);\n-                to_columns->insert(to_value);\n-            }\n-            cache.to_columns = std::move(to_columns);\n+            else\n+                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected data type {} as the first argument in function `transform`\", from_type->getName());\n \n             cache.initialized = true;\n         }\n-};\n+    };\n \n }\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02797_transform_narrow_types.reference b/tests/queries/0_stateless/02797_transform_narrow_types.reference\nnew file mode 100644\nindex 000000000000..5a2bd60ca833\n--- /dev/null\n+++ b/tests/queries/0_stateless/02797_transform_narrow_types.reference\n@@ -0,0 +1,6 @@\n+f\n+s\n+11\n+11\n+33\n+3\ndiff --git a/tests/queries/0_stateless/02797_transform_narrow_types.sql b/tests/queries/0_stateless/02797_transform_narrow_types.sql\nnew file mode 100644\nindex 000000000000..56a02fb8af7a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02797_transform_narrow_types.sql\n@@ -0,0 +1,6 @@\n+SELECT transform(-1, [-1, 2], ['f', 's'], 'g');\n+SELECT transform(2, [-1, 2], ['f', 's'], 'g');\n+SELECT transform(-1, [-1, 2], [11, 22], 33);\n+SELECT transform(-1, [-1, 2], [11, 22]);\n+SELECT transform(3, [-1, 2], [11, 22], 33);\n+SELECT transform(3, [-1, 2], [11, 22]);\n",
  "problem_statement": "Wrong result of function `transform`\n**Describe what's wrong**\r\n\r\n```sql\r\nSELECT transform(-1, [-1, 2], ['f', 's'], 'g')\r\n```\r\n\r\n```\r\n\u250c\u2500transform(-1, [-1, 2], ['f', 's'], 'g')\u2500\u2510\r\n\u2502 g                                       \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nThe expected result is `f`.\r\n\r\n**Additional context**\r\n\r\nThose cases work correctly:\r\n\r\n```sql\r\nSELECT transform(2, [-1, 2], ['f', 's'], 'g')\r\n```\r\n\r\n```\r\n\u250c\u2500transform(2, [-1, 2], ['f', 's'], 'g')\u2500\u2510\r\n\u2502 s                                      \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n```sql\r\nSELECT transform(-1::Int64, [-1, 2]::Array(Int64), ['f', 's'], 'g') AS res\r\n```\r\n\r\n```\r\n\u250c\u2500res\u2500\u2510\r\n\u2502 f   \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\n",
  "hints_text": "Broken between 22.6 (https://fiddle.clickhouse.com/c3f16e42-605d-42f7-8cfa-390617864e26) and 22.7 (https://fiddle.clickhouse.com/86955dac-51bc-41e9-a9e5-d9804e14fde7)\r\n\r\n\nHm, no, it was broken by a backported bugfix:\r\n22.7.6 - g - https://fiddle.clickhouse.com/636ebb2b-aa4f-44b2-b175-cffbe17b6520\r\n22.7.5 - f - https://fiddle.clickhouse.com/ed0cc60e-0e47-4357-a6b6-05c026bab17a\nThe most suspicious patch is https://github.com/ClickHouse/ClickHouse/pull/41457\r\nShould we add the trash to Field back?",
  "created_at": "2023-06-24T03:49:21Z"
}