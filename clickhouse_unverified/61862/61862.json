{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 61862,
  "instance_id": "ClickHouse__ClickHouse-61862",
  "issue_numbers": [
    "61686"
  ],
  "base_commit": "0d1751fd55c2f14a626dba19b68c35a1a611e239",
  "patch": "diff --git a/docs/en/sql-reference/statements/truncate.md b/docs/en/sql-reference/statements/truncate.md\nindex 029815a43922..8cd5a6a14246 100644\n--- a/docs/en/sql-reference/statements/truncate.md\n+++ b/docs/en/sql-reference/statements/truncate.md\n@@ -23,9 +23,16 @@ You can specify how long (in seconds) to wait for inactive replicas to execute `\n If the `alter_sync` is set to `2` and some replicas are not active for more than the time, specified by the `replication_wait_for_inactive_replica_timeout` setting, then an exception `UNFINISHED` is thrown.\n :::\n \n+## TRUNCATE ALL TABLES\n+``` sql\n+TRUNCATE ALL TABLES [IF EXISTS] db [ON CLUSTER cluster]\n+```\n+\n+Removes all data from all tables in a database.\n+\n ## TRUNCATE DATABASE\n ``` sql\n-TRUNCATE DATABASE [IF EXISTS] [db.]name [ON CLUSTER cluster]\n+TRUNCATE DATABASE [IF EXISTS] db [ON CLUSTER cluster]\n ```\n \n Removes all tables from a database but keeps the database itself. When the clause `IF EXISTS` is omitted, the query returns an error if the database does not exist.\ndiff --git a/src/Interpreters/InterpreterDropQuery.cpp b/src/Interpreters/InterpreterDropQuery.cpp\nindex a70407090348..c6df401c5550 100644\n--- a/src/Interpreters/InterpreterDropQuery.cpp\n+++ b/src/Interpreters/InterpreterDropQuery.cpp\n@@ -388,7 +388,7 @@ BlockIO InterpreterDropQuery::executeToDatabaseImpl(const ASTDropQuery & query,\n                 query_for_table.kind = query.kind;\n                 // For truncate operation on database, drop the tables\n                 if (truncate)\n-                    query_for_table.kind = ASTDropQuery::Kind::Drop;\n+                    query_for_table.kind = query.has_all_tables ? ASTDropQuery::Kind::Truncate : ASTDropQuery::Kind::Drop;\n                 query_for_table.if_exists = true;\n                 query_for_table.if_empty = false;\n                 query_for_table.setDatabase(database_name);\ndiff --git a/src/Parsers/ASTDropQuery.cpp b/src/Parsers/ASTDropQuery.cpp\nindex ca47ceccb856..b491be1ea2c0 100644\n--- a/src/Parsers/ASTDropQuery.cpp\n+++ b/src/Parsers/ASTDropQuery.cpp\n@@ -47,7 +47,9 @@ void ASTDropQuery::formatQueryImpl(const FormatSettings & settings, FormatState\n     if (temporary)\n         settings.ostr << \"TEMPORARY \";\n \n-    if (!table && database)\n+    if (has_all_tables)\n+        settings.ostr << \"ALL TABLES \";\n+    else if (!table && database)\n         settings.ostr << \"DATABASE \";\n     else if (is_dictionary)\n         settings.ostr << \"DICTIONARY \";\ndiff --git a/src/Parsers/ASTDropQuery.h b/src/Parsers/ASTDropQuery.h\nindex a732b3542605..fe79bdf8bf12 100644\n--- a/src/Parsers/ASTDropQuery.h\n+++ b/src/Parsers/ASTDropQuery.h\n@@ -26,6 +26,9 @@ class ASTDropQuery : public ASTQueryWithTableAndOutput, public ASTQueryWithOnClu\n     /// Useful if we already have a DDL lock\n     bool no_ddl_lock{false};\n \n+    /// For `TRUNCATE ALL TABLES` query\n+    bool has_all_tables{false};\n+\n     /// We dropping dictionary, so print correct word\n     bool is_dictionary{false};\n \ndiff --git a/src/Parsers/ParserDropQuery.cpp b/src/Parsers/ParserDropQuery.cpp\nindex fab9938d0b0c..75ea5fc89e1c 100644\n--- a/src/Parsers/ParserDropQuery.cpp\n+++ b/src/Parsers/ParserDropQuery.cpp\n@@ -17,6 +17,8 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, cons\n     ParserKeyword s_dictionary(Keyword::DICTIONARY);\n     ParserKeyword s_view(Keyword::VIEW);\n     ParserKeyword s_database(Keyword::DATABASE);\n+    ParserKeyword s_all(Keyword::ALL);\n+    ParserKeyword s_tables(Keyword::TABLES);\n     ParserToken s_dot(TokenType::Dot);\n     ParserKeyword s_if_exists(Keyword::IF_EXISTS);\n     ParserKeyword s_if_empty(Keyword::IF_EMPTY);\n@@ -30,6 +32,7 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, cons\n     String cluster_str;\n     bool if_exists = false;\n     bool if_empty = false;\n+    bool has_all_tables = false;\n     bool temporary = false;\n     bool is_dictionary = false;\n     bool is_view = false;\n@@ -47,6 +50,16 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, cons\n         if (!name_p.parse(pos, database, expected))\n             return false;\n     }\n+    else if (s_all.ignore(pos, expected) && s_tables.ignore(pos, expected) && kind == ASTDropQuery::Kind::Truncate)\n+    {\n+        has_all_tables = true;\n+\n+        if (s_if_exists.ignore(pos, expected))\n+            if_exists = true;\n+\n+        if (!name_p.parse(pos, database, expected))\n+            return false;\n+    }\n     else\n     {\n         if (s_view.ignore(pos, expected))\n@@ -99,6 +112,7 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, cons\n     query->kind = kind;\n     query->if_exists = if_exists;\n     query->if_empty = if_empty;\n+    query->has_all_tables = has_all_tables;\n     query->temporary = temporary;\n     query->is_dictionary = is_dictionary;\n     query->is_view = is_view;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00623_truncate_all_tables.reference b/tests/queries/0_stateless/00623_truncate_all_tables.reference\nnew file mode 100644\nindex 000000000000..b1df4c9107d3\n--- /dev/null\n+++ b/tests/queries/0_stateless/00623_truncate_all_tables.reference\n@@ -0,0 +1,16 @@\n+======Before Truncate======\n+1\n+1\n+1\n+1\n+1\n+2000-01-01\t1\n+======After Truncate And Empty======\n+0\n+======After Truncate And Insert Data======\n+1\n+1\n+1\n+1\n+1\n+2000-01-01\t1\ndiff --git a/tests/queries/0_stateless/00623_truncate_all_tables.sql b/tests/queries/0_stateless/00623_truncate_all_tables.sql\nnew file mode 100644\nindex 000000000000..3a6f94d2907d\n--- /dev/null\n+++ b/tests/queries/0_stateless/00623_truncate_all_tables.sql\n@@ -0,0 +1,50 @@\n+-- Tags: no-parallel\n+\n+DROP DATABASE IF EXISTS truncate_test;\n+\n+CREATE DATABASE IF NOT EXISTS truncate_test;\n+CREATE TABLE IF NOT EXISTS truncate_test.truncate_test_set(id UInt64) ENGINE = Set;\n+CREATE TABLE IF NOT EXISTS truncate_test.truncate_test_log(id UInt64) ENGINE = Log;\n+CREATE TABLE IF NOT EXISTS truncate_test.truncate_test_memory(id UInt64) ENGINE = Memory;\n+CREATE TABLE IF NOT EXISTS truncate_test.truncate_test_tiny_log(id UInt64) ENGINE = TinyLog;\n+CREATE TABLE IF NOT EXISTS truncate_test.truncate_test_stripe_log(id UInt64) ENGINE = StripeLog;\n+CREATE TABLE IF NOT EXISTS truncate_test.truncate_test_merge_tree(p Date, k UInt64) ENGINE = MergeTree ORDER BY p;\n+\n+SELECT '======Before Truncate======';\n+INSERT INTO truncate_test.truncate_test_set VALUES(0);\n+INSERT INTO truncate_test.truncate_test_log VALUES(1);\n+INSERT INTO truncate_test.truncate_test_memory VALUES(1);\n+INSERT INTO truncate_test.truncate_test_tiny_log VALUES(1);\n+INSERT INTO truncate_test.truncate_test_stripe_log VALUES(1);\n+INSERT INTO truncate_test.truncate_test_merge_tree VALUES('2000-01-01', 1);\n+SELECT * FROM system.numbers WHERE number NOT IN truncate_test.truncate_test_set LIMIT 1;\n+SELECT * FROM truncate_test.truncate_test_log;\n+SELECT * FROM truncate_test.truncate_test_memory;\n+SELECT * FROM truncate_test.truncate_test_tiny_log;\n+SELECT * FROM truncate_test.truncate_test_stripe_log;\n+SELECT * FROM truncate_test.truncate_test_merge_tree;\n+\n+SELECT '======After Truncate And Empty======';\n+TRUNCATE ALL TABLES IF EXISTS truncate_test;\n+SELECT * FROM system.numbers WHERE number NOT IN truncate_test.truncate_test_set LIMIT 1;\n+SELECT * FROM truncate_test.truncate_test_log;\n+SELECT * FROM truncate_test.truncate_test_memory;\n+SELECT * FROM truncate_test.truncate_test_tiny_log;\n+SELECT * FROM truncate_test.truncate_test_stripe_log;\n+SELECT * FROM truncate_test.truncate_test_merge_tree;\n+\n+SELECT '======After Truncate And Insert Data======';\n+INSERT INTO truncate_test.truncate_test_set VALUES(0);\n+INSERT INTO truncate_test.truncate_test_log VALUES(1);\n+INSERT INTO truncate_test.truncate_test_memory VALUES(1);\n+INSERT INTO truncate_test.truncate_test_tiny_log VALUES(1);\n+INSERT INTO truncate_test.truncate_test_stripe_log VALUES(1);\n+INSERT INTO truncate_test.truncate_test_merge_tree VALUES('2000-01-01', 1);\n+SELECT * FROM system.numbers WHERE number NOT IN truncate_test.truncate_test_set LIMIT 1;\n+SELECT * FROM truncate_test.truncate_test_log;\n+SELECT * FROM truncate_test.truncate_test_memory;\n+SELECT * FROM truncate_test.truncate_test_tiny_log;\n+SELECT * FROM truncate_test.truncate_test_stripe_log;\n+SELECT * FROM truncate_test.truncate_test_merge_tree;\n+\n+DROP DATABASE IF EXISTS truncate_test;\n",
  "problem_statement": "Add ability to truncate all tables in the DB\nCurrently, it's possible to truncate a single table with command:\r\n\r\n`TRUNCATE TABLE {table_name}`\r\n\r\nIt's also, possible to remove all tables from the DB with:\r\n\r\n`TRUNCATE DATABASE {db_name}`\r\n\r\nHowever, there is no option to truncate all tables in the DB (without table removal). It would be very convenient to use something like:\r\n\r\n`TRUNCATE ALL TABLES {db_name}`\r\n\r\nor something similar.\r\n\n",
  "hints_text": "",
  "created_at": "2024-03-25T08:02:43Z",
  "modified_files": [
    "docs/en/sql-reference/statements/truncate.md",
    "src/Interpreters/InterpreterDropQuery.cpp",
    "src/Parsers/ASTDropQuery.cpp",
    "src/Parsers/ASTDropQuery.h",
    "src/Parsers/ParserDropQuery.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/00623_truncate_all_tables.reference",
    "b/tests/queries/0_stateless/00623_truncate_all_tables.sql"
  ]
}