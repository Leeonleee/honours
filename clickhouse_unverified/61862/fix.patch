diff --git a/docs/en/sql-reference/statements/truncate.md b/docs/en/sql-reference/statements/truncate.md
index 029815a43922..8cd5a6a14246 100644
--- a/docs/en/sql-reference/statements/truncate.md
+++ b/docs/en/sql-reference/statements/truncate.md
@@ -23,9 +23,16 @@ You can specify how long (in seconds) to wait for inactive replicas to execute `
 If the `alter_sync` is set to `2` and some replicas are not active for more than the time, specified by the `replication_wait_for_inactive_replica_timeout` setting, then an exception `UNFINISHED` is thrown.
 :::
 
+## TRUNCATE ALL TABLES
+``` sql
+TRUNCATE ALL TABLES [IF EXISTS] db [ON CLUSTER cluster]
+```
+
+Removes all data from all tables in a database.
+
 ## TRUNCATE DATABASE
 ``` sql
-TRUNCATE DATABASE [IF EXISTS] [db.]name [ON CLUSTER cluster]
+TRUNCATE DATABASE [IF EXISTS] db [ON CLUSTER cluster]
 ```
 
 Removes all tables from a database but keeps the database itself. When the clause `IF EXISTS` is omitted, the query returns an error if the database does not exist.
diff --git a/src/Interpreters/InterpreterDropQuery.cpp b/src/Interpreters/InterpreterDropQuery.cpp
index a70407090348..c6df401c5550 100644
--- a/src/Interpreters/InterpreterDropQuery.cpp
+++ b/src/Interpreters/InterpreterDropQuery.cpp
@@ -388,7 +388,7 @@ BlockIO InterpreterDropQuery::executeToDatabaseImpl(const ASTDropQuery & query,
                 query_for_table.kind = query.kind;
                 // For truncate operation on database, drop the tables
                 if (truncate)
-                    query_for_table.kind = ASTDropQuery::Kind::Drop;
+                    query_for_table.kind = query.has_all_tables ? ASTDropQuery::Kind::Truncate : ASTDropQuery::Kind::Drop;
                 query_for_table.if_exists = true;
                 query_for_table.if_empty = false;
                 query_for_table.setDatabase(database_name);
diff --git a/src/Parsers/ASTDropQuery.cpp b/src/Parsers/ASTDropQuery.cpp
index ca47ceccb856..b491be1ea2c0 100644
--- a/src/Parsers/ASTDropQuery.cpp
+++ b/src/Parsers/ASTDropQuery.cpp
@@ -47,7 +47,9 @@ void ASTDropQuery::formatQueryImpl(const FormatSettings & settings, FormatState
     if (temporary)
         settings.ostr << "TEMPORARY ";
 
-    if (!table && database)
+    if (has_all_tables)
+        settings.ostr << "ALL TABLES ";
+    else if (!table && database)
         settings.ostr << "DATABASE ";
     else if (is_dictionary)
         settings.ostr << "DICTIONARY ";
diff --git a/src/Parsers/ASTDropQuery.h b/src/Parsers/ASTDropQuery.h
index a732b3542605..fe79bdf8bf12 100644
--- a/src/Parsers/ASTDropQuery.h
+++ b/src/Parsers/ASTDropQuery.h
@@ -26,6 +26,9 @@ class ASTDropQuery : public ASTQueryWithTableAndOutput, public ASTQueryWithOnClu
     /// Useful if we already have a DDL lock
     bool no_ddl_lock{false};
 
+    /// For `TRUNCATE ALL TABLES` query
+    bool has_all_tables{false};
+
     /// We dropping dictionary, so print correct word
     bool is_dictionary{false};
 
diff --git a/src/Parsers/ParserDropQuery.cpp b/src/Parsers/ParserDropQuery.cpp
index fab9938d0b0c..75ea5fc89e1c 100644
--- a/src/Parsers/ParserDropQuery.cpp
+++ b/src/Parsers/ParserDropQuery.cpp
@@ -17,6 +17,8 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, cons
     ParserKeyword s_dictionary(Keyword::DICTIONARY);
     ParserKeyword s_view(Keyword::VIEW);
     ParserKeyword s_database(Keyword::DATABASE);
+    ParserKeyword s_all(Keyword::ALL);
+    ParserKeyword s_tables(Keyword::TABLES);
     ParserToken s_dot(TokenType::Dot);
     ParserKeyword s_if_exists(Keyword::IF_EXISTS);
     ParserKeyword s_if_empty(Keyword::IF_EMPTY);
@@ -30,6 +32,7 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, cons
     String cluster_str;
     bool if_exists = false;
     bool if_empty = false;
+    bool has_all_tables = false;
     bool temporary = false;
     bool is_dictionary = false;
     bool is_view = false;
@@ -47,6 +50,16 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, cons
         if (!name_p.parse(pos, database, expected))
             return false;
     }
+    else if (s_all.ignore(pos, expected) && s_tables.ignore(pos, expected) && kind == ASTDropQuery::Kind::Truncate)
+    {
+        has_all_tables = true;
+
+        if (s_if_exists.ignore(pos, expected))
+            if_exists = true;
+
+        if (!name_p.parse(pos, database, expected))
+            return false;
+    }
     else
     {
         if (s_view.ignore(pos, expected))
@@ -99,6 +112,7 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, cons
     query->kind = kind;
     query->if_exists = if_exists;
     query->if_empty = if_empty;
+    query->has_all_tables = has_all_tables;
     query->temporary = temporary;
     query->is_dictionary = is_dictionary;
     query->is_view = is_view;
