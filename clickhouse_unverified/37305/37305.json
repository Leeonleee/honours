{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 37305,
  "instance_id": "ClickHouse__ClickHouse-37305",
  "issue_numbers": [
    "37089"
  ],
  "base_commit": "b368026d5167e395583d2220c0e55b3c4ec314ba",
  "patch": "diff --git a/src/Columns/ColumnObject.cpp b/src/Columns/ColumnObject.cpp\nindex 0913f6b8da9f..d3e68273d03f 100644\n--- a/src/Columns/ColumnObject.cpp\n+++ b/src/Columns/ColumnObject.cpp\n@@ -22,8 +22,8 @@ namespace ErrorCodes\n     extern const int ILLEGAL_COLUMN;\n     extern const int DUPLICATE_COLUMN;\n     extern const int NUMBER_OF_DIMENSIONS_MISMATHED;\n-    extern const int NOT_IMPLEMENTED;\n     extern const int SIZES_OF_COLUMNS_DOESNT_MATCH;\n+    extern const int ARGUMENT_OUT_OF_BOUND;\n }\n \n namespace\n@@ -179,7 +179,7 @@ ColumnObject::Subcolumn::Subcolumn(\n {\n }\n \n-size_t ColumnObject::Subcolumn::Subcolumn::size() const\n+size_t ColumnObject::Subcolumn::size() const\n {\n     size_t res = num_of_defaults_in_prefix;\n     for (const auto & part : data)\n@@ -187,7 +187,7 @@ size_t ColumnObject::Subcolumn::Subcolumn::size() const\n     return res;\n }\n \n-size_t ColumnObject::Subcolumn::Subcolumn::byteSize() const\n+size_t ColumnObject::Subcolumn::byteSize() const\n {\n     size_t res = 0;\n     for (const auto & part : data)\n@@ -195,7 +195,7 @@ size_t ColumnObject::Subcolumn::Subcolumn::byteSize() const\n     return res;\n }\n \n-size_t ColumnObject::Subcolumn::Subcolumn::allocatedBytes() const\n+size_t ColumnObject::Subcolumn::allocatedBytes() const\n {\n     size_t res = 0;\n     for (const auto & part : data)\n@@ -203,6 +203,37 @@ size_t ColumnObject::Subcolumn::Subcolumn::allocatedBytes() const\n     return res;\n }\n \n+void ColumnObject::Subcolumn::get(size_t n, Field & res) const\n+{\n+    if (isFinalized())\n+    {\n+        getFinalizedColumn().get(n, res);\n+        return;\n+    }\n+\n+    size_t ind = n;\n+    if (ind < num_of_defaults_in_prefix)\n+    {\n+        res = least_common_type.get()->getDefault();\n+        return;\n+    }\n+\n+    ind -= num_of_defaults_in_prefix;\n+    for (const auto & part : data)\n+    {\n+        if (ind < part->size())\n+        {\n+            part->get(ind, res);\n+            res = convertFieldToTypeOrThrow(res, *least_common_type.get());\n+            return;\n+        }\n+\n+        ind -= part->size();\n+    }\n+\n+    throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, \"Index ({}) for getting field is out of range\", n);\n+}\n+\n void ColumnObject::Subcolumn::checkTypes() const\n {\n     DataTypes prefix_types;\n@@ -221,7 +252,7 @@ void ColumnObject::Subcolumn::checkTypes() const\n \n void ColumnObject::Subcolumn::insert(Field field)\n {\n-    auto info = getFieldInfo(field);\n+    auto info = DB::getFieldInfo(field);\n     insert(std::move(field), std::move(info));\n }\n \n@@ -244,8 +275,8 @@ static bool isConversionRequiredBetweenIntegers(const IDataType & lhs, const IDa\n     bool is_native_int = which_lhs.isNativeInt() && which_rhs.isNativeInt();\n     bool is_native_uint = which_lhs.isNativeUInt() && which_rhs.isNativeUInt();\n \n-    return (is_native_int || is_native_uint)\n-        && lhs.getSizeOfValueInMemory() <= rhs.getSizeOfValueInMemory();\n+    return (!is_native_int && !is_native_uint)\n+        || lhs.getSizeOfValueInMemory() > rhs.getSizeOfValueInMemory();\n }\n \n void ColumnObject::Subcolumn::insert(Field field, FieldInfo info)\n@@ -288,7 +319,7 @@ void ColumnObject::Subcolumn::insert(Field field, FieldInfo info)\n     }\n     else if (!least_common_base_type->equals(*base_type) && !isNothing(base_type))\n     {\n-        if (!isConversionRequiredBetweenIntegers(*base_type, *least_common_base_type))\n+        if (isConversionRequiredBetweenIntegers(*base_type, *least_common_base_type))\n         {\n             base_type = getLeastSupertype(DataTypes{std::move(base_type), least_common_base_type}, true);\n             type_changed = true;\n@@ -305,35 +336,96 @@ void ColumnObject::Subcolumn::insert(Field field, FieldInfo info)\n \n void ColumnObject::Subcolumn::insertRangeFrom(const Subcolumn & src, size_t start, size_t length)\n {\n-    assert(src.isFinalized());\n-    const auto & src_column = src.data.back();\n-    const auto & src_type = src.least_common_type.get();\n+    assert(start + length <= src.size());\n+    size_t end = start + length;\n \n     if (data.empty())\n     {\n-        addNewColumnPart(src.least_common_type.get());\n-        data.back()->insertRangeFrom(*src_column, start, length);\n+        addNewColumnPart(src.getLeastCommonType());\n     }\n-    else if (least_common_type.get()->equals(*src_type))\n+    else if (!least_common_type.get()->equals(*src.getLeastCommonType()))\n     {\n-        data.back()->insertRangeFrom(*src_column, start, length);\n+        auto new_least_common_type = getLeastSupertype(DataTypes{least_common_type.get(), src.getLeastCommonType()}, true);\n+        if (!new_least_common_type->equals(*least_common_type.get()))\n+            addNewColumnPart(std::move(new_least_common_type));\n     }\n-    else\n+\n+    if (end <= src.num_of_defaults_in_prefix)\n     {\n-        auto new_least_common_type = getLeastSupertype(DataTypes{least_common_type.get(), src_type}, true);\n-        auto casted_column = castColumn({src_column, src_type, \"\"}, new_least_common_type);\n+        data.back()->insertManyDefaults(length);\n+        return;\n+    }\n \n-        if (!least_common_type.get()->equals(*new_least_common_type))\n-            addNewColumnPart(std::move(new_least_common_type));\n+    if (start < src.num_of_defaults_in_prefix)\n+        data.back()->insertManyDefaults(src.num_of_defaults_in_prefix - start);\n+\n+    auto insert_from_part = [&](const auto & column, size_t from, size_t n)\n+    {\n+        assert(from + n <= column->size());\n+        auto column_type = getDataTypeByColumn(*column);\n+\n+        if (column_type->equals(*least_common_type.get()))\n+        {\n+            data.back()->insertRangeFrom(*column, from, n);\n+            return;\n+        }\n+\n+        /// If we need to insert large range, there is no sense to cut part of column and cast it.\n+        /// Casting of all column and inserting from it can be faster.\n+        /// Threshold is just a guess.\n+\n+        if (n * 3 >= column->size())\n+        {\n+            auto casted_column = castColumn({column, column_type, \"\"}, least_common_type.get());\n+            data.back()->insertRangeFrom(*casted_column, from, n);\n+            return;\n+        }\n+\n+        auto casted_column = column->cut(from, n);\n+        casted_column = castColumn({casted_column, column_type, \"\"}, least_common_type.get());\n+        data.back()->insertRangeFrom(*casted_column, 0, n);\n+    };\n+\n+    size_t pos = 0;\n+    size_t processed_rows = src.num_of_defaults_in_prefix;\n+\n+    /// Find the first part of the column that intersects the range.\n+    while (pos < src.data.size() && processed_rows + src.data[pos]->size() < start)\n+    {\n+        processed_rows += src.data[pos]->size();\n+        ++pos;\n+    }\n+\n+    /// Insert from the first part of column.\n+    if (pos < src.data.size() && processed_rows < start)\n+    {\n+        size_t part_start = start - processed_rows;\n+        size_t part_length = std::min(src.data[pos]->size() - part_start, end - start);\n+        insert_from_part(src.data[pos], part_start, part_length);\n+        processed_rows += src.data[pos]->size();\n+        ++pos;\n+    }\n+\n+    /// Insert from the parts of column in the middle of range.\n+    while (pos < src.data.size() && processed_rows + src.data[pos]->size() < end)\n+    {\n+        insert_from_part(src.data[pos], 0, src.data[pos]->size());\n+        processed_rows += src.data[pos]->size();\n+        ++pos;\n+    }\n \n-        data.back()->insertRangeFrom(*casted_column, start, length);\n+    /// Insert from the last part of column if needed.\n+    if (pos < src.data.size() && processed_rows < end)\n+    {\n+        size_t part_end = end - processed_rows;\n+        insert_from_part(src.data[pos], 0, part_end);\n     }\n }\n \n bool ColumnObject::Subcolumn::isFinalized() const\n {\n-    return data.empty() ||\n-        (data.size() == 1 && !data[0]->isSparse() && num_of_defaults_in_prefix == 0);\n+    return num_of_defaults_in_prefix == 0 &&\n+        (data.empty() || (data.size() == 1 && !data[0]->isSparse()));\n }\n \n void ColumnObject::Subcolumn::finalize()\n@@ -432,6 +524,13 @@ void ColumnObject::Subcolumn::popBack(size_t n)\n     num_of_defaults_in_prefix -= n;\n }\n \n+ColumnObject::Subcolumn ColumnObject::Subcolumn::cut(size_t start, size_t length) const\n+{\n+    Subcolumn new_subcolumn(0, is_nullable);\n+    new_subcolumn.insertRangeFrom(*this, start, length);\n+    return new_subcolumn;\n+}\n+\n Field ColumnObject::Subcolumn::getLastField() const\n {\n     if (data.empty())\n@@ -442,6 +541,18 @@ Field ColumnObject::Subcolumn::getLastField() const\n     return (*last_part)[last_part->size() - 1];\n }\n \n+FieldInfo ColumnObject::Subcolumn::getFieldInfo() const\n+{\n+    const auto & base_type = least_common_type.getBase();\n+    return FieldInfo\n+    {\n+        .scalar_type = base_type,\n+        .have_nulls = base_type->isNullable(),\n+        .need_convert = false,\n+        .num_dimensions = least_common_type.getNumberOfDimensions(),\n+    };\n+}\n+\n ColumnObject::Subcolumn ColumnObject::Subcolumn::recreateWithDefaultValues(const FieldInfo & field_info) const\n {\n     auto scalar_type = field_info.scalar_type;\n@@ -479,6 +590,13 @@ const ColumnPtr & ColumnObject::Subcolumn::getFinalizedColumnPtr() const\n     return data[0];\n }\n \n+ColumnObject::Subcolumn::LeastCommonType::LeastCommonType()\n+    : type(std::make_shared<DataTypeNothing>())\n+    , base_type(type)\n+    , num_dimensions(0)\n+{\n+}\n+\n ColumnObject::Subcolumn::LeastCommonType::LeastCommonType(DataTypePtr type_)\n     : type(std::move(type_))\n     , base_type(getBaseTypeOfArray(type))\n@@ -525,16 +643,6 @@ size_t ColumnObject::size() const\n     return num_rows;\n }\n \n-MutableColumnPtr ColumnObject::cloneResized(size_t new_size) const\n-{\n-    /// cloneResized with new_size == 0 is used for cloneEmpty().\n-    if (new_size != 0)\n-        throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n-            \"ColumnObject doesn't support resize to non-zero length\");\n-\n-    return ColumnObject::create(is_nullable);\n-}\n-\n size_t ColumnObject::byteSize() const\n {\n     size_t res = 0;\n@@ -553,23 +661,21 @@ size_t ColumnObject::allocatedBytes() const\n \n void ColumnObject::forEachSubcolumn(ColumnCallback callback)\n {\n-    if (!isFinalized())\n-        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cannot iterate over non-finalized ColumnObject\");\n-\n     for (auto & entry : subcolumns)\n-        callback(entry->data.data.back());\n+        for (auto & part : entry->data.data)\n+            callback(part);\n }\n \n void ColumnObject::insert(const Field & field)\n {\n     const auto & object = field.get<const Object &>();\n \n-    HashSet<StringRef, StringRefHash> inserted;\n+    HashSet<StringRef, StringRefHash> inserted_paths;\n     size_t old_size = size();\n     for (const auto & [key_str, value] : object)\n     {\n         PathInData key(key_str);\n-        inserted.insert(key_str);\n+        inserted_paths.insert(key_str);\n         if (!hasSubcolumn(key))\n             addSubcolumn(key, old_size);\n \n@@ -578,8 +684,14 @@ void ColumnObject::insert(const Field & field)\n     }\n \n     for (auto & entry : subcolumns)\n-        if (!inserted.has(entry->path.getPath()))\n-            entry->data.insertDefault();\n+    {\n+        if (!inserted_paths.has(entry->path.getPath()))\n+        {\n+            bool inserted = tryInsertDefaultFromNested(entry);\n+            if (!inserted)\n+                entry->data.insertDefault();\n+        }\n+    }\n \n     ++num_rows;\n }\n@@ -594,26 +706,21 @@ void ColumnObject::insertDefault()\n \n Field ColumnObject::operator[](size_t n) const\n {\n-    if (!isFinalized())\n-        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cannot get Field from non-finalized ColumnObject\");\n-\n-    Object object;\n-    for (const auto & entry : subcolumns)\n-        object[entry->path.getPath()] = (*entry->data.data.back())[n];\n-\n+    Field object;\n+    get(n, object);\n     return object;\n }\n \n void ColumnObject::get(size_t n, Field & res) const\n {\n-    if (!isFinalized())\n-        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cannot get Field from non-finalized ColumnObject\");\n+    assert(n < size());\n+    res = Object();\n \n     auto & object = res.get<Object &>();\n     for (const auto & entry : subcolumns)\n     {\n         auto it = object.try_emplace(entry->path.getPath()).first;\n-        entry->data.data.back()->get(n, it->second);\n+        entry->data.get(n, it->second);\n     }\n }\n \n@@ -626,61 +733,33 @@ void ColumnObject::insertFrom(const IColumn & src, size_t n)\n void ColumnObject::insertRangeFrom(const IColumn & src, size_t start, size_t length)\n {\n     const auto & src_object = assert_cast<const ColumnObject &>(src);\n-    if (!src_object.isFinalized())\n-        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cannot insertRangeFrom non-finalized ColumnObject\");\n-\n-    for (auto & entry : subcolumns)\n-    {\n-        if (src_object.hasSubcolumn(entry->path))\n-            entry->data.insertRangeFrom(src_object.getSubcolumn(entry->path), start, length);\n-        else\n-            entry->data.insertManyDefaults(length);\n-    }\n \n     for (const auto & entry : src_object.subcolumns)\n     {\n         if (!hasSubcolumn(entry->path))\n         {\n             if (entry->path.hasNested())\n-            {\n-                const auto & base_type = entry->data.getLeastCommonTypeBase();\n-                FieldInfo field_info\n-                {\n-                    .scalar_type = base_type,\n-                    .have_nulls = base_type->isNullable(),\n-                    .need_convert = false,\n-                    .num_dimensions = entry->data.getNumberOfDimensions(),\n-                };\n-\n-                addNestedSubcolumn(entry->path, field_info, num_rows);\n-            }\n+                addNestedSubcolumn(entry->path, entry->data.getFieldInfo(), num_rows);\n             else\n-            {\n                 addSubcolumn(entry->path, num_rows);\n-            }\n-\n-            auto & subcolumn = getSubcolumn(entry->path);\n-            subcolumn.insertRangeFrom(entry->data, start, length);\n         }\n-    }\n-\n-    num_rows += length;\n-    finalize();\n-}\n \n-ColumnPtr ColumnObject::replicate(const Offsets & offsets) const\n-{\n-    if (!isFinalized())\n-        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cannot replicate non-finalized ColumnObject\");\n+        auto & subcolumn = getSubcolumn(entry->path);\n+        subcolumn.insertRangeFrom(entry->data, start, length);\n+    }\n \n-    auto res_column = ColumnObject::create(is_nullable);\n-    for (const auto & entry : subcolumns)\n+    for (auto & entry : subcolumns)\n     {\n-        auto replicated_data = entry->data.data.back()->replicate(offsets)->assumeMutable();\n-        res_column->addSubcolumn(entry->path, std::move(replicated_data));\n+        if (!src_object.hasSubcolumn(entry->path))\n+        {\n+            bool inserted = tryInsertManyDefaultsFromNested(entry);\n+            if (!inserted)\n+                entry->data.insertManyDefaults(length);\n+        }\n     }\n \n-    return res_column;\n+    num_rows += length;\n+    finalize();\n }\n \n void ColumnObject::popBack(size_t length)\n@@ -692,10 +771,15 @@ void ColumnObject::popBack(size_t length)\n }\n \n template <typename Func>\n-ColumnPtr ColumnObject::applyForSubcolumns(Func && func, std::string_view func_name) const\n+MutableColumnPtr ColumnObject::applyForSubcolumns(Func && func) const\n {\n     if (!isFinalized())\n-        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cannot {} non-finalized ColumnObject\", func_name);\n+    {\n+        auto finalized = IColumn::mutate(getPtr());\n+        auto & finalized_object = assert_cast<ColumnObject &>(*finalized);\n+        finalized_object.finalize();\n+        return finalized_object.applyForSubcolumns(std::forward<Func>(func));\n+    }\n \n     auto res = ColumnObject::create(is_nullable);\n     for (const auto & subcolumn : subcolumns)\n@@ -703,22 +787,36 @@ ColumnPtr ColumnObject::applyForSubcolumns(Func && func, std::string_view func_n\n         auto new_subcolumn = func(subcolumn->data.getFinalizedColumn());\n         res->addSubcolumn(subcolumn->path, new_subcolumn->assumeMutable());\n     }\n+\n     return res;\n }\n \n ColumnPtr ColumnObject::permute(const Permutation & perm, size_t limit) const\n {\n-    return applyForSubcolumns([&](const auto & subcolumn) { return subcolumn.permute(perm, limit); }, \"permute\");\n+    return applyForSubcolumns([&](const auto & subcolumn) { return subcolumn.permute(perm, limit); });\n }\n \n ColumnPtr ColumnObject::filter(const Filter & filter, ssize_t result_size_hint) const\n {\n-    return applyForSubcolumns([&](const auto & subcolumn) { return subcolumn.filter(filter, result_size_hint); }, \"filter\");\n+    return applyForSubcolumns([&](const auto & subcolumn) { return subcolumn.filter(filter, result_size_hint); });\n }\n \n ColumnPtr ColumnObject::index(const IColumn & indexes, size_t limit) const\n {\n-    return applyForSubcolumns([&](const auto & subcolumn) { return subcolumn.index(indexes, limit); }, \"index\");\n+    return applyForSubcolumns([&](const auto & subcolumn) { return subcolumn.index(indexes, limit); });\n+}\n+\n+ColumnPtr ColumnObject::replicate(const Offsets & offsets) const\n+{\n+    return applyForSubcolumns([&](const auto & subcolumn) { return subcolumn.replicate(offsets); });\n+}\n+\n+MutableColumnPtr ColumnObject::cloneResized(size_t new_size) const\n+{\n+    if (new_size == 0)\n+        return ColumnObject::create(is_nullable);\n+\n+    return applyForSubcolumns([&](const auto & subcolumn) { return subcolumn.cloneResized(new_size); });\n }\n \n const ColumnObject::Subcolumn & ColumnObject::getSubcolumn(const PathInData & key) const\n@@ -810,6 +908,92 @@ void ColumnObject::addNestedSubcolumn(const PathInData & key, const FieldInfo &\n \n     if (num_rows == 0)\n         num_rows = new_size;\n+    else if (new_size != num_rows)\n+        throw Exception(ErrorCodes::SIZES_OF_COLUMNS_DOESNT_MATCH,\n+            \"Required size of subcolumn {} ({}) is inconsistent with column size ({})\",\n+            key.getPath(), new_size, num_rows);\n+}\n+\n+const ColumnObject::Subcolumns::Node * ColumnObject::getLeafOfTheSameNested(const Subcolumns::NodePtr & entry) const\n+{\n+    if (!entry->path.hasNested())\n+        return nullptr;\n+\n+    size_t old_size = entry->data.size();\n+    const auto * current_node = subcolumns.findLeaf(entry->path);\n+    const Subcolumns::Node * leaf = nullptr;\n+\n+    while (current_node)\n+    {\n+        /// Try to find the first Nested up to the current node.\n+        const auto * node_nested = subcolumns.findParent(current_node,\n+            [](const auto & candidate) { return candidate.isNested(); });\n+\n+        if (!node_nested)\n+            break;\n+\n+        /// Find the leaf with subcolumn that contains values\n+        /// for the last rows.\n+        /// If there are no leaves, skip current node and find\n+        /// the next node up to the current.\n+        leaf = subcolumns.findLeaf(node_nested,\n+            [&](const auto & candidate)\n+            {\n+                return candidate.data.size() > old_size;\n+            });\n+\n+        if (leaf)\n+            break;\n+\n+        current_node = node_nested->parent;\n+    }\n+\n+    if (leaf && isNothing(leaf->data.getLeastCommonTypeBase()))\n+        return nullptr;\n+\n+    return leaf;\n+}\n+\n+bool ColumnObject::tryInsertManyDefaultsFromNested(const Subcolumns::NodePtr & entry) const\n+{\n+    const auto * leaf = getLeafOfTheSameNested(entry);\n+    if (!leaf)\n+        return false;\n+\n+    size_t old_size = entry->data.size();\n+    auto field_info = entry->data.getFieldInfo();\n+\n+    /// Cut the needed range from the found leaf\n+    /// and replace scalar values to the correct\n+    /// default values for given entry.\n+    auto new_subcolumn = leaf->data\n+        .cut(old_size, leaf->data.size() - old_size)\n+        .recreateWithDefaultValues(field_info);\n+\n+    entry->data.insertRangeFrom(new_subcolumn, 0, new_subcolumn.size());\n+    return true;\n+}\n+\n+bool ColumnObject::tryInsertDefaultFromNested(const Subcolumns::NodePtr & entry) const\n+{\n+    const auto * leaf = getLeafOfTheSameNested(entry);\n+    if (!leaf)\n+        return false;\n+\n+    auto last_field = leaf->data.getLastField();\n+    if (last_field.isNull())\n+        return false;\n+\n+    size_t leaf_num_dimensions = leaf->data.getNumberOfDimensions();\n+    size_t entry_num_dimensions = entry->data.getNumberOfDimensions();\n+\n+    auto default_scalar = entry_num_dimensions > leaf_num_dimensions\n+        ? createEmptyArrayField(entry_num_dimensions - leaf_num_dimensions)\n+        : entry->data.getLeastCommonTypeBase()->getDefault();\n+\n+    auto default_field = applyVisitor(FieldVisitorReplaceScalars(default_scalar, leaf_num_dimensions), last_field);\n+    entry->data.insert(std::move(default_field));\n+    return true;\n }\n \n PathsInData ColumnObject::getKeys() const\n@@ -835,7 +1019,7 @@ void ColumnObject::finalize()\n     {\n         const auto & least_common_type = entry->data.getLeastCommonType();\n \n-        /// Do not add subcolumns, which consists only from NULLs.\n+        /// Do not add subcolumns, which consist only from NULLs.\n         if (isNothing(getBaseTypeOfArray(least_common_type)))\n             continue;\n \ndiff --git a/src/Columns/ColumnObject.h b/src/Columns/ColumnObject.h\nindex 73fc738cb8d4..89e42183ea01 100644\n--- a/src/Columns/ColumnObject.h\n+++ b/src/Columns/ColumnObject.h\n@@ -65,6 +65,7 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>\n         size_t size() const;\n         size_t byteSize() const;\n         size_t allocatedBytes() const;\n+        void get(size_t n, Field & res) const;\n \n         bool isFinalized() const;\n         const DataTypePtr & getLeastCommonType() const { return least_common_type.get(); }\n@@ -84,6 +85,8 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>\n         void insertRangeFrom(const Subcolumn & src, size_t start, size_t length);\n         void popBack(size_t n);\n \n+        Subcolumn cut(size_t start, size_t length) const;\n+\n         /// Converts all column's parts to the common type and\n         /// creates a single column that stores all values.\n         void finalize();\n@@ -91,6 +94,8 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>\n         /// Returns last inserted field.\n         Field getLastField() const;\n \n+        FieldInfo getFieldInfo() const;\n+\n         /// Recreates subcolumn with default scalar values and keeps sizes of arrays.\n         /// Used to create columns of type Nested with consistent array sizes.\n         Subcolumn recreateWithDefaultValues(const FieldInfo & field_info) const;\n@@ -101,13 +106,16 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>\n         const IColumn & getFinalizedColumn() const;\n         const ColumnPtr & getFinalizedColumnPtr() const;\n \n+        const std::vector<WrappedPtr> & getData() const { return data; }\n+        size_t getNumberOfDefaultsInPrefix() const { return num_of_defaults_in_prefix; }\n+\n         friend class ColumnObject;\n \n     private:\n         class LeastCommonType\n         {\n         public:\n-            LeastCommonType() = default;\n+            LeastCommonType();\n             explicit LeastCommonType(DataTypePtr type_);\n \n             const DataTypePtr & get() const { return type; }\n@@ -175,6 +183,11 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>\n     /// It cares about consistency of sizes of Nested arrays.\n     void addNestedSubcolumn(const PathInData & key, const FieldInfo & field_info, size_t new_size);\n \n+    /// Finds a subcolumn from the same Nested type as @entry and inserts\n+    /// an array with default values with consistent sizes as in Nested type.\n+    bool tryInsertDefaultFromNested(const Subcolumns::NodePtr & entry) const;\n+    bool tryInsertManyDefaultsFromNested(const Subcolumns::NodePtr & entry) const;\n+\n     const Subcolumns & getSubcolumns() const { return subcolumns; }\n     Subcolumns & getSubcolumns() { return subcolumns; }\n     PathsInData getKeys() const;\n@@ -189,7 +202,6 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>\n     TypeIndex getDataType() const override { return TypeIndex::Object; }\n \n     size_t size() const override;\n-    MutableColumnPtr cloneResized(size_t new_size) const override;\n     size_t byteSize() const override;\n     size_t allocatedBytes() const override;\n     void forEachSubcolumn(ColumnCallback callback) override;\n@@ -197,13 +209,14 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>\n     void insertDefault() override;\n     void insertFrom(const IColumn & src, size_t n) override;\n     void insertRangeFrom(const IColumn & src, size_t start, size_t length) override;\n-    ColumnPtr replicate(const Offsets & offsets) const override;\n     void popBack(size_t length) override;\n     Field operator[](size_t n) const override;\n     void get(size_t n, Field & res) const override;\n     ColumnPtr permute(const Permutation & perm, size_t limit) const override;\n     ColumnPtr filter(const Filter & filter, ssize_t result_size_hint) const override;\n     ColumnPtr index(const IColumn & indexes, size_t limit) const override;\n+    ColumnPtr replicate(const Offsets & offsets) const override;\n+    MutableColumnPtr cloneResized(size_t new_size) const override;\n \n     /// All other methods throw exception.\n \n@@ -236,7 +249,11 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>\n     }\n \n     template <typename Func>\n-    ColumnPtr applyForSubcolumns(Func && func, std::string_view func_name) const;\n+    MutableColumnPtr applyForSubcolumns(Func && func) const;\n+\n+    /// For given subcolumn return subcolumn from the same Nested type.\n+    /// It's used to get shared sized of Nested to insert correct default values.\n+    const Subcolumns::Node * getLeafOfTheSameNested(const Subcolumns::NodePtr & entry) const;\n };\n \n }\ndiff --git a/src/DataTypes/ObjectUtils.cpp b/src/DataTypes/ObjectUtils.cpp\nindex 8f4daddc9e8e..0858c2c254eb 100644\n--- a/src/DataTypes/ObjectUtils.cpp\n+++ b/src/DataTypes/ObjectUtils.cpp\n@@ -718,9 +718,9 @@ void replaceMissedSubcolumnsByConstants(\n             addConstantToWithClause(query, name, type);\n }\n \n-void finalizeObjectColumns(MutableColumns & columns)\n+void finalizeObjectColumns(const MutableColumns & columns)\n {\n-    for (auto & column : columns)\n+    for (const auto & column : columns)\n         if (auto * column_object = typeid_cast<ColumnObject *>(column.get()))\n             column_object->finalize();\n }\ndiff --git a/src/DataTypes/ObjectUtils.h b/src/DataTypes/ObjectUtils.h\nindex 7ec7f6c9f389..602d40cef6ad 100644\n--- a/src/DataTypes/ObjectUtils.h\n+++ b/src/DataTypes/ObjectUtils.h\n@@ -51,7 +51,7 @@ void extendObjectColumns(NamesAndTypesList & columns_list, const ColumnsDescript\n \n NameSet getNamesOfObjectColumns(const NamesAndTypesList & columns_list);\n bool hasObjectColumns(const ColumnsDescription & columns);\n-void finalizeObjectColumns(MutableColumns & columns);\n+void finalizeObjectColumns(const MutableColumns & columns);\n \n /// Updates types of objects in @object_columns inplace\n /// according to types in new_columns.\ndiff --git a/src/DataTypes/Serializations/SerializationObject.cpp b/src/DataTypes/Serializations/SerializationObject.cpp\nindex 8b5f37d342b8..85831df271a3 100644\n--- a/src/DataTypes/Serializations/SerializationObject.cpp\n+++ b/src/DataTypes/Serializations/SerializationObject.cpp\n@@ -33,71 +33,6 @@ namespace ErrorCodes\n     extern const int LOGICAL_ERROR;\n }\n \n-namespace\n-{\n-\n-using Node = typename ColumnObject::Subcolumns::Node;\n-\n-/// Finds a subcolumn from the same Nested type as @entry and inserts\n-/// an array with default values with consistent sizes as in Nested type.\n-bool tryInsertDefaultFromNested(\n-    const std::shared_ptr<Node> & entry, const ColumnObject::Subcolumns & subcolumns)\n-{\n-    if (!entry->path.hasNested())\n-        return false;\n-\n-    const Node * current_node = subcolumns.findLeaf(entry->path);\n-    const Node * leaf = nullptr;\n-    size_t num_skipped_nested = 0;\n-\n-    while (current_node)\n-    {\n-        /// Try to find the first Nested up to the current node.\n-        const auto * node_nested = subcolumns.findParent(current_node,\n-            [](const auto & candidate) { return candidate.isNested(); });\n-\n-        if (!node_nested)\n-            break;\n-\n-        /// If there are no leaves, skip current node and find\n-        /// the next node up to the current.\n-        leaf = subcolumns.findLeaf(node_nested,\n-            [&](const auto & candidate)\n-            {\n-                return candidate.data.size() == entry->data.size() + 1;\n-            });\n-\n-        if (leaf)\n-            break;\n-\n-        current_node = node_nested->parent;\n-        ++num_skipped_nested;\n-    }\n-\n-    if (!leaf)\n-        return false;\n-\n-    auto last_field = leaf->data.getLastField();\n-    if (last_field.isNull())\n-        return false;\n-\n-    const auto & least_common_type = entry->data.getLeastCommonType();\n-    size_t num_dimensions = getNumberOfDimensions(*least_common_type);\n-    assert(num_skipped_nested < num_dimensions);\n-\n-    /// Replace scalars to default values with consistent array sizes.\n-    size_t num_dimensions_to_keep = num_dimensions - num_skipped_nested;\n-    auto default_scalar = num_skipped_nested\n-        ? createEmptyArrayField(num_skipped_nested)\n-        : getBaseTypeOfArray(least_common_type)->getDefault();\n-\n-    auto default_field = applyVisitor(FieldVisitorReplaceScalars(default_scalar, num_dimensions_to_keep), last_field);\n-    entry->data.insert(std::move(default_field));\n-    return true;\n-}\n-\n-}\n-\n template <typename Parser>\n template <typename Reader>\n void SerializationObject<Parser>::deserializeTextImpl(IColumn & column, Reader && reader) const\n@@ -159,7 +94,7 @@ void SerializationObject<Parser>::deserializeTextImpl(IColumn & column, Reader &\n     {\n         if (!paths_set.has(entry->path.getPath()))\n         {\n-            bool inserted = tryInsertDefaultFromNested(entry, subcolumns);\n+            bool inserted = column_object.tryInsertDefaultFromNested(entry);\n             if (!inserted)\n                 entry->data.insertDefault();\n         }\n",
  "test_patch": "diff --git a/src/Columns/tests/gtest_column_object.cpp b/src/Columns/tests/gtest_column_object.cpp\nnew file mode 100644\nindex 000000000000..d5e58e5fce24\n--- /dev/null\n+++ b/src/Columns/tests/gtest_column_object.cpp\n@@ -0,0 +1,120 @@\n+#include <Common/FieldVisitorsAccurateComparison.h>\n+#include <DataTypes/getLeastSupertype.h>\n+#include <Interpreters/castColumn.h>\n+#include <Interpreters/convertFieldToType.h>\n+#include <Columns/ColumnObject.h>\n+#include <Common/FieldVisitorToString.h>\n+\n+#include <Common/randomSeed.h>\n+#include <fmt/core.h>\n+#include <pcg_random.hpp>\n+#include <gtest/gtest.h>\n+#include <random>\n+\n+using namespace DB;\n+\n+static pcg64 rng(randomSeed());\n+\n+Field getRandomField(size_t type)\n+{\n+    switch (type)\n+    {\n+        case 0:\n+            return rng();\n+        case 1:\n+            return std::uniform_real_distribution<>(0.0, 1.0)(rng);\n+        case 2:\n+            return std::string(rng() % 10, 'a' + rng() % 26);\n+        default:\n+            return Field();\n+    }\n+}\n+\n+std::pair<ColumnObject::Subcolumn, std::vector<Field>> generate(size_t size)\n+{\n+    bool has_defaults = rng() % 3 == 0;\n+    size_t num_defaults = has_defaults ? rng() % size : 0;\n+\n+    ColumnObject::Subcolumn subcolumn(num_defaults, false);\n+    std::vector<Field> fields;\n+\n+    while (subcolumn.size() < size)\n+    {\n+        size_t part_size = rng() % (size - subcolumn.size()) + 1;\n+        size_t field_type = rng() % 3;\n+\n+        for (size_t i = 0; i < part_size; ++i)\n+        {\n+            fields.push_back(getRandomField(field_type));\n+            subcolumn.insert(fields.back());\n+        }\n+    }\n+\n+    std::vector<Field> result_fields;\n+    for (size_t i = 0; i < num_defaults; ++i)\n+        result_fields.emplace_back();\n+\n+    result_fields.insert(result_fields.end(), fields.begin(), fields.end());\n+    return {std::move(subcolumn), std::move(result_fields)};\n+}\n+\n+void checkFieldsAreEqual(ColumnObject::Subcolumn subcolumn, const std::vector<Field> & fields)\n+{\n+    ASSERT_EQ(subcolumn.size(), fields.size());\n+    for (size_t i = 0; i < subcolumn.size(); ++i)\n+    {\n+        Field field;\n+        subcolumn.get(i, field); // Also check 'get' method.\n+        if (!applyVisitor(FieldVisitorAccurateEquals(), field, fields[i]))\n+        {\n+            std::cerr << fmt::format(\"Wrong value at position {}, expected {}, got {}\",\n+                i, applyVisitor(FieldVisitorToString(), fields[i]), applyVisitor(FieldVisitorToString(), field));\n+            ASSERT_TRUE(false);\n+        }\n+    }\n+}\n+\n+constexpr size_t T = 1000;\n+constexpr size_t N = 1000;\n+\n+TEST(ColumnObject, InsertRangeFrom)\n+{\n+    for (size_t t = 0; t < T; ++t)\n+    {\n+        auto [subcolumn_dst, fields_dst] = generate(N);\n+        auto [subcolumn_src, fields_src] = generate(N);\n+\n+        ASSERT_EQ(subcolumn_dst.size(), fields_dst.size());\n+        ASSERT_EQ(subcolumn_src.size(), fields_src.size());\n+\n+        const auto & type_dst = subcolumn_dst.getLeastCommonType();\n+        const auto & type_src = subcolumn_src.getLeastCommonType();\n+        auto type_res = getLeastSupertype(DataTypes{type_dst, type_src}, true);\n+\n+        size_t from = rng() % subcolumn_src.size();\n+        size_t to = rng() % subcolumn_src.size();\n+        if (from > to)\n+            std::swap(from, to);\n+        ++to;\n+\n+        for (auto & field : fields_dst)\n+        {\n+            if (field.isNull())\n+                field = type_res->getDefault();\n+            else\n+                field = convertFieldToTypeOrThrow(field, *type_res);\n+        }\n+\n+        for (size_t i = from; i < to; ++i)\n+        {\n+            if (fields_src[i].isNull())\n+                fields_dst.push_back(type_res->getDefault());\n+            else\n+                fields_dst.push_back(convertFieldToTypeOrThrow(fields_src[i], *type_res));\n+\n+        }\n+\n+        subcolumn_dst.insertRangeFrom(subcolumn_src, from, to - from);\n+        checkFieldsAreEqual(subcolumn_dst, fields_dst);\n+    }\n+}\ndiff --git a/src/Columns/tests/gtest_column_sparse.cpp b/src/Columns/tests/gtest_column_sparse.cpp\nindex 35ac68b4e2ee..b5b226c6862b 100644\n--- a/src/Columns/tests/gtest_column_sparse.cpp\n+++ b/src/Columns/tests/gtest_column_sparse.cpp\n@@ -11,7 +11,7 @@\n #include <Common/FieldVisitors.h>\n \n using namespace DB;\n-pcg64 rng(randomSeed());\n+static pcg64 rng(randomSeed());\n \n std::pair<MutableColumnPtr, MutableColumnPtr> createColumns(size_t n, size_t k)\n {\ndiff --git a/tests/queries/0_stateless/01825_type_json_insert_select.reference b/tests/queries/0_stateless/01825_type_json_insert_select.reference\nindex 6e50983f5eef..6778da508f25 100644\n--- a/tests/queries/0_stateless/01825_type_json_insert_select.reference\n+++ b/tests/queries/0_stateless/01825_type_json_insert_select.reference\n@@ -13,3 +13,6 @@ Tuple(arr Nested(k11 Int8, k22 String, k33 Int8), k1 Int8, k2 String, k3 String)\n {\"data\":{\"k1\":1,\"k10\":[{\"a\":\"1\",\"b\":\"2\",\"c\":{\"k11\":\"\"}},{\"a\":\"2\",\"b\":\"3\",\"c\":{\"k11\":\"\"}}]}}\n {\"data\":{\"k1\":2,\"k10\":[{\"a\":\"1\",\"b\":\"2\",\"c\":{\"k11\":\"haha\"}}]}}\n Tuple(k1 Int8, k10 Nested(a String, b String, c Tuple(k11 String)))\n+{\"data\":{\"k1\":1,\"k10\":[{\"a\":\"1\",\"b\":\"2\",\"c\":{\"k11\":\"\"}},{\"a\":\"2\",\"b\":\"3\",\"c\":{\"k11\":\"\"}}]}}\n+{\"data\":{\"k1\":2,\"k10\":[{\"a\":\"1\",\"b\":\"2\",\"c\":{\"k11\":\"haha\"}}]}}\n+Tuple(k1 Int8, k10 Nested(a String, b String, c Tuple(k11 String)))\ndiff --git a/tests/queries/0_stateless/01825_type_json_insert_select.sql b/tests/queries/0_stateless/01825_type_json_insert_select.sql\nindex a54c2c4a709d..cd0b280c3609 100644\n--- a/tests/queries/0_stateless/01825_type_json_insert_select.sql\n+++ b/tests/queries/0_stateless/01825_type_json_insert_select.sql\n@@ -38,18 +38,29 @@ DROP TABLE type_json_dst;\n CREATE TABLE type_json_dst (data JSON) ENGINE = MergeTree ORDER BY tuple();\n CREATE TABLE type_json_src (data String) ENGINE = MergeTree ORDER BY tuple();\n \n+SYSTEM STOP MERGES type_json_src;\n+\n+SET max_threads = 1;\n+SET max_insert_threads = 1;\n+SET output_format_json_named_tuples_as_objects = 1;\n+\n INSERT INTO type_json_src FORMAT JSONAsString {\"k1\": 1, \"k10\": [{\"a\": \"1\", \"b\": \"2\"}, {\"a\": \"2\", \"b\": \"3\"}]};\n INSERT INTO type_json_src FORMAT JSONAsString  {\"k1\": 2, \"k10\": [{\"a\": \"1\", \"b\": \"2\", \"c\": {\"k11\": \"haha\"}}]};\n \n--- Temporarily fix test by optimizing data to one part.\n--- If order of insertion of above two lines will be changed,\n--- which can happen during insertion with multiple threads,\n--- this test will fail. TODO: fix this.\n-OPTIMIZE TABLE type_json_src FINAL;\n+INSERT INTO type_json_dst SELECT data FROM type_json_src;\n+\n+SELECT * FROM type_json_dst ORDER BY data.k1 FORMAT JSONEachRow;\n+SELECT toTypeName(data) FROM type_json_dst LIMIT 1;\n+\n+TRUNCATE TABLE type_json_src;\n+TRUNCATE TABLE type_json_dst;\n+\n+-- Insert in another order. Order is important, because a way how defaults are filled differs.\n+INSERT INTO type_json_src FORMAT JSONAsString  {\"k1\": 2, \"k10\": [{\"a\": \"1\", \"b\": \"2\", \"c\": {\"k11\": \"haha\"}}]};\n+INSERT INTO type_json_src FORMAT JSONAsString {\"k1\": 1, \"k10\": [{\"a\": \"1\", \"b\": \"2\"}, {\"a\": \"2\", \"b\": \"3\"}]};\n \n INSERT INTO type_json_dst SELECT data FROM type_json_src;\n \n-SET output_format_json_named_tuples_as_objects = 1;\n SELECT * FROM type_json_dst ORDER BY data.k1 FORMAT JSONEachRow;\n SELECT toTypeName(data) FROM type_json_dst LIMIT 1;\n \n",
  "problem_statement": "Logical error: 'offsets_column has data inconsistent with nested_column'\nhttps://s3.amazonaws.com/clickhouse-test-reports/0/cdfd16174c704d664f965007e684841dc34a55ff/stateless_tests__address__actions__[2/2].html\r\n\r\n```\r\n2022.05.10 10:26:56.111254 [ 16098 ] {16bb88ef-6940-436b-b750-9733fcaa16fd} <Fatal> : Logical error: 'offsets_column has data inconsistent with nested_column'.\r\n2022.05.10 10:26:56.111952 [ 22486 ] {} <Fatal> BaseDaemon: ########################################\r\n2022.05.10 10:26:56.112113 [ 22486 ] {} <Fatal> BaseDaemon: (version 22.5.1.1 (official build), build id: 89CC279EBFD389A6) (from thread 16098) (query_id: 16bb88ef-6940-436b-b750-9733fcaa16fd) (query: INSERT INTO type_json_dst SELECT data FROM type_json_src;) Received signal Aborted (6)\r\n2022.05.10 10:26:56.112222 [ 22486 ] {} <Fatal> BaseDaemon: \r\n2022.05.10 10:26:56.112360 [ 22486 ] {} <Fatal> BaseDaemon: Stack trace: 0x7f31c5c7b03b 0x7f31c5c5a859 0xd24900f 0xd24966e 0x2be2b39c 0x13b870ce 0x29a727a5 0x29a7b44f 0x29a71a17 0x29a674ba 0x29a5fd85 0x2d6416db 0x2d8d37e0 0x2e37287c 0x2e23d2d3 0x2e23cd92 0x2e23bd02 0x2dd31d1f 0x2dd121e7 0x2dd14eb7 0xd394a07 0xd39cd97 0x7f31c5e32609 0x7f31c5d57163\r\n2022.05.10 10:26:56.112539 [ 22486 ] {} <Fatal> BaseDaemon: 3. gsignal @ 0x7f31c5c7b03b in ?\r\n2022.05.10 10:26:56.112651 [ 22486 ] {} <Fatal> BaseDaemon: 4. abort @ 0x7f31c5c5a859 in ?\r\n2022.05.10 10:26:56.231553 [ 22486 ] {} <Fatal> BaseDaemon: 5. ./build_docker/../src/Common/Exception.cpp:0: DB::handle_error_code(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int, bool, std::__1::vector<void*, std::__1::allocator<void*> > const&) @ 0xd24900f in /usr/bin/clickhouse\r\n2022.05.10 10:26:56.329756 [ 22486 ] {} <Fatal> BaseDaemon: 6.1. inlined from ./build_docker/../contrib/libcxx/include/vector:547: std::__1::vector<void*, std::__1::allocator<void*> >::data() const\r\n2022.05.10 10:26:56.329858 [ 22486 ] {} <Fatal> BaseDaemon: 6.2. inlined from ../contrib/libcxx/include/vector:731: std::__1::vector<void*, std::__1::allocator<void*> >::__annotate_delete() const\r\n2022.05.10 10:26:56.329923 [ 22486 ] {} <Fatal> BaseDaemon: 6.3. inlined from ../contrib/libcxx/include/vector:394: ~vector\r\n2022.05.10 10:26:56.329990 [ 22486 ] {} <Fatal> BaseDaemon: 6. ../src/Common/Exception.cpp:59: DB::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int, bool) @ 0xd24966e in /usr/bin/clickhouse\r\n2022.05.10 10:26:56.500955 [ 22486 ] {} <Fatal> BaseDaemon: 7. ./build_docker/../src/Columns/ColumnArray.cpp:59: DB::ColumnArray::ColumnArray(COW<DB::IColumn>::mutable_ptr<DB::IColumn>&&, COW<DB::IColumn>::mutable_ptr<DB::IColumn>&&) @ 0x2be2b39c in /usr/bin/clickhouse\r\n2022.05.10 10:27:01.303925 [ 22486 ] {} <Fatal> BaseDaemon: 8. DB::ColumnArray::create(COW<DB::IColumn>::immutable_ptr<DB::IColumn> const&, COW<DB::IColumn>::immutable_ptr<DB::IColumn> const&) @ 0x13b870ce in /usr/bin/clickhouse\r\n2022.05.10 10:27:01.484729 [ 22486 ] {} <Fatal> BaseDaemon: 9.1. inlined from ./build_docker/../contrib/boost/boost/smart_ptr/intrusive_ptr.hpp:98: ~intrusive_ptr\r\n2022.05.10 10:27:01.484840 [ 22486 ] {} <Fatal> BaseDaemon: 9. ../src/DataTypes/ObjectUtils.cpp:520: DB::(anonymous namespace)::createTypeFromNode(DB::SubcolumnsTree<DB::(anonymous namespace)::ColumnWithTypeAndDimensions>::Node const*) @ 0x29a727a5 in /usr/bin/clickhouse\r\n2022.05.10 10:27:01.633051 [ 22486 ] {} <Fatal> BaseDaemon: 10.1. inlined from ./build_docker/../contrib/libcxx/include/vector:1575: std::__1::tuple<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, DB::(anonymous namespace)::ColumnWithTypeAndDimensions>& std::__1::vector<std::__1::tuple<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, DB::(anonymous namespace)::ColumnWithTypeAndDimensions>, std::__1::allocator<std::__1::tuple<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, DB::(anonymous namespace)::ColumnWithTypeAndDimensions> > >::emplace_back<StringRef const&, DB::(anonymous namespace)::ColumnWithTypeAndDimensions>(StringRef const&, DB::(anonymous namespace)::ColumnWithTypeAndDimensions&&)\r\n2022.05.10 10:27:01.633155 [ 22486 ] {} <Fatal> BaseDaemon: 10. ../src/DataTypes/ObjectUtils.cpp:467: auto DB::(anonymous namespace)::createTypeFromNode(DB::SubcolumnsTree<DB::(anonymous namespace)::ColumnWithTypeAndDimensions>::Node const*)::$_1::operator()<HashMapTable<StringRef, HashMapCellWithSavedHash<StringRef, std::__1::shared_ptr<DB::SubcolumnsTree<DB::(anonymous namespace)::ColumnWithTypeAndDimensions>::Node>, StringRefHash, HashTableNoState>, StringRefHash, HashTableGrower<4ul>, AllocatorWithStackMemory<Allocator<true, true>, 640ul, 1ul> > >(HashMapTable<StringRef, HashMapCellWithSavedHash<StringRef, std::__1::shared_ptr<DB::SubcolumnsTree<DB::(anonymous namespace)::ColumnWithTypeAndDimensions>::Node>, StringRefHash, HashTableNoState>, StringRefHash, HashTableGrower<4ul>, AllocatorWithStackMemory<Allocator<true, true>, 640ul, 1ul> > const&) const @ 0x29a7b44f in /usr/bin/clickhouse\r\n2022.05.10 10:27:01.906838 [ 22486 ] {} <Fatal> BaseDaemon: 11.1. inlined from ./build_docker/../contrib/libcxx/include/tuple:297: std::__1::__tuple_leaf<1ul, std::__1::vector<DB::(anonymous namespace)::ColumnWithTypeAndDimensions, std::__1::allocator<DB::(anonymous namespace)::ColumnWithTypeAndDimensions> >, false>::get()\r\n2022.05.10 10:27:01.906944 [ 22486 ] {} <Fatal> BaseDaemon: 11.2. inlined from ../contrib/libcxx/include/tuple:1184: std::__1::tuple_element<1ul, std::__1::tuple<std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > >, std::__1::vector<DB::(anonymous namespace)::ColumnWithTypeAndDimensions, std::__1::allocator<DB::(anonymous namespace)::ColumnWithTypeAndDimensions> > > >::type&& std::__1::get<1ul, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > >, std::__1::vector<DB::(anonymous namespace)::ColumnWithTypeAndDimensions, std::__1::allocator<DB::(anonymous namespace)::ColumnWithTypeAndDimensions> > >(std::__1::tuple<std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > >, std::__1::vector<DB::(anonymous namespace)::ColumnWithTypeAndDimensions, std::__1::allocator<DB::(anonymous namespace)::ColumnWithTypeAndDimensions> > >&&)\r\n2022.05.10 10:27:01.906999 [ 22486 ] {} <Fatal> BaseDaemon: 11. ../src/DataTypes/ObjectUtils.cpp:534: DB::(anonymous namespace)::createTypeFromNode(DB::SubcolumnsTree<DB::(anonymous namespace)::ColumnWithTypeAndDimensions>::Node const*) @ 0x29a71a17 in /usr/bin/clickhouse\r\n2022.05.10 10:27:02.082064 [ 22486 ] {} <Fatal> BaseDaemon: 12. ./build_docker/../src/DataTypes/ObjectUtils.cpp:0: DB::unflattenTuple(std::__1::vector<DB::PathInData, std::__1::allocator<DB::PathInData> > const&, std::__1::vector<std::__1::shared_ptr<DB::IDataType const>, std::__1::allocator<std::__1::shared_ptr<DB::IDataType const> > > const&, std::__1::vector<COW<DB::IColumn>::immutable_ptr<DB::IColumn>, std::__1::allocator<COW<DB::IColumn>::immutable_ptr<DB::IColumn> > > const&) @ 0x29a674ba in /usr/bin/clickhouse\r\n2022.05.10 10:27:02.278990 [ 22486 ] {} <Fatal> BaseDaemon: 13.1. inlined from ./build_docker/../contrib/boost/boost/smart_ptr/intrusive_ptr.hpp:115: intrusive_ptr\r\n2022.05.10 10:27:02.279118 [ 22486 ] {} <Fatal> BaseDaemon: 13.2. inlined from ../contrib/boost/boost/smart_ptr/intrusive_ptr.hpp:122: boost::intrusive_ptr<DB::IColumn const>::operator=(boost::intrusive_ptr<DB::IColumn const>&&)\r\n2022.05.10 10:27:02.279217 [ 22486 ] {} <Fatal> BaseDaemon: 13.3. inlined from ../src/Common/COW.h:136: COW<DB::IColumn>::immutable_ptr<DB::IColumn>::operator=(COW<DB::IColumn>::immutable_ptr<DB::IColumn>&&)\r\n2022.05.10 10:27:02.279311 [ 22486 ] {} <Fatal> BaseDaemon: 13.4. inlined from ../contrib/libcxx/include/tuple:1053: std::__1::tuple<COW<DB::IColumn>::immutable_ptr<DB::IColumn>&, std::__1::shared_ptr<DB::IDataType const>&>& std::__1::tuple<COW<DB::IColumn>::immutable_ptr<DB::IColumn>&, std::__1::shared_ptr<DB::IDataType const>&>::operator=<COW<DB::IColumn>::immutable_ptr<DB::IColumn>, std::__1::shared_ptr<DB::IDataType const>, std::__1::integral_constant<bool, true>, 0>(std::__1::pair<COW<DB::IColumn>::immutable_ptr<DB::IColumn>, std::__1::shared_ptr<DB::IDataType const> >&&)\r\n2022.05.10 10:27:02.279380 [ 22486 ] {} <Fatal> BaseDaemon: 13. ../src/DataTypes/ObjectUtils.cpp:168: DB::convertObjectsToTuples(DB::Block&, DB::NamesAndTypesList const&) @ 0x29a5fd85 in /usr/bin/clickhouse\r\n2022.05.10 10:27:02.429090 [ 22486 ] {} <Fatal> BaseDaemon: 14. ./build_docker/../src/Storages/MergeTree/MergeTreeDataWriter.cpp:479: DB::MergeTreeDataWriter::deduceTypesOfObjectColumns(std::__1::shared_ptr<DB::StorageSnapshot const> const&, DB::Block&) @ 0x2d6416db in /usr/bin/clickhouse\r\n2022.05.10 10:27:02.460966 [ 22486 ] {} <Fatal> BaseDaemon: 15. ./build_docker/../src/Storages/MergeTree/MergeTreeSink.cpp:56: DB::MergeTreeSink::consume(DB::Chunk) @ 0x2d8d37e0 in /usr/bin/clickhouse\r\n2022.05.10 10:27:02.474836 [ 22486 ] {} <Fatal> BaseDaemon: 16.1. inlined from ./build_docker/../contrib/libcxx/include/__memory/shared_ptr.h:702: ~shared_ptr\r\n2022.05.10 10:27:02.474918 [ 22486 ] {} <Fatal> BaseDaemon: 16.2. inlined from ../src/Processors/Chunk.h:32: ~Chunk\r\n2022.05.10 10:27:02.474958 [ 22486 ] {} <Fatal> BaseDaemon: 16. ../src/Processors/Sinks/SinkToStorage.cpp:18: DB::SinkToStorage::onConsume(DB::Chunk) @ 0x2e37287c in /usr/bin/clickhouse\r\n2022.05.10 10:27:02.512254 [ 22486 ] {} <Fatal> BaseDaemon: 17.1. inlined from ./build_docker/../contrib/libcxx/include/__memory/shared_ptr.h:702: ~shared_ptr\r\n2022.05.10 10:27:02.512348 [ 22486 ] {} <Fatal> BaseDaemon: 17.2. inlined from ../src/Processors/Chunk.h:32: ~Chunk\r\n2022.05.10 10:27:02.512389 [ 22486 ] {} <Fatal> BaseDaemon: 17.3. inlined from ../src/Processors/Transforms/ExceptionKeepingTransform.cpp:151: operator()\r\n2022.05.10 10:27:02.512469 [ 22486 ] {} <Fatal> BaseDaemon: 17.4. inlined from ../contrib/libcxx/include/type_traits:3640: decltype(static_cast<DB::ExceptionKeepingTransform::work()::$_1&>(fp)()) std::__1::__invoke<DB::ExceptionKeepingTransform::work()::$_1&>(DB::ExceptionKeepingTransform::work()::$_1&)\r\n2022.05.10 10:27:02.512528 [ 22486 ] {} <Fatal> BaseDaemon: 17.5. inlined from ../contrib/libcxx/include/__functional/invoke.h:61: void std::__1::__invoke_void_return_wrapper<void, true>::__call<DB::ExceptionKeepingTransform::work()::$_1&>(DB::ExceptionKeepingTransform::work()::$_1&)\r\n2022.05.10 10:27:02.512591 [ 22486 ] {} <Fatal> BaseDaemon: 17.6. inlined from ../contrib/libcxx/include/__functional/function.h:230: std::__1::__function::__default_alloc_func<DB::ExceptionKeepingTransform::work()::$_1, void ()>::operator()()\r\n2022.05.10 10:27:02.512633 [ 22486 ] {} <Fatal> BaseDaemon: 17. ../contrib/libcxx/include/__functional/function.h:711: void std::__1::__function::__policy_invoker<void ()>::__call_impl<std::__1::__function::__default_alloc_func<DB::ExceptionKeepingTransform::work()::$_1, void ()> >(std::__1::__function::__policy_storage const*) @ 0x2e23d2d3 in /usr/bin/clickhouse\r\n2022.05.10 10:27:02.574747 [ 22486 ] {} <Fatal> BaseDaemon: 18. ./build_docker/../src/Processors/Transforms/ExceptionKeepingTransform.cpp:103: DB::runStep(std::__1::function<void ()>, DB::ThreadStatus*, std::__1::atomic<unsigned long>*) @ 0x2e23cd92 in /usr/bin/clickhouse\r\n2022.05.10 10:27:02.615633 [ 22486 ] {} <Fatal> BaseDaemon: 19.1. inlined from ./build_docker/../contrib/libcxx/include/__functional/function.h:813: ~__policy_func\r\n2022.05.10 10:27:02.615753 [ 22486 ] {} <Fatal> BaseDaemon: 19.2. inlined from ../contrib/libcxx/include/__functional/function.h:1171: ~function\r\n2022.05.10 10:27:02.615840 [ 22486 ] {} <Fatal> BaseDaemon: 19. ../src/Processors/Transforms/ExceptionKeepingTransform.cpp:151: DB::ExceptionKeepingTransform::work() @ 0x2e23bd02 in /usr/bin/clickhouse\r\n2022.05.10 10:27:02.634189 [ 22486 ] {} <Fatal> BaseDaemon: 20. ./build_docker/../src/Processors/Executors/ExecutionThreadContext.cpp:0: DB::ExecutionThreadContext::executeTask() @ 0x2dd31d1f in /usr/bin/clickhouse\r\n2022.05.10 10:27:02.698610 [ 22486 ] {} <Fatal> BaseDaemon: 21. ./build_docker/../src/Processors/Executors/PipelineExecutor.cpp:217: DB::PipelineExecutor::executeStepImpl(unsigned long, std::__1::atomic<bool>*) @ 0x2dd121e7 in /usr/bin/clickhouse\r\n2022.05.10 10:27:02.764280 [ 22486 ] {} <Fatal> BaseDaemon: 22.1. inlined from ./build_docker/../src/Processors/Executors/PipelineExecutor.cpp:0: operator()\r\n2022.05.10 10:27:02.764417 [ 22486 ] {} <Fatal> BaseDaemon: 22.2. inlined from ../contrib/libcxx/include/type_traits:3648: decltype(static_cast<DB::PipelineExecutor::executeImpl(unsigned long)::$_1&>(fp)()) std::__1::__invoke_constexpr<DB::PipelineExecutor::executeImpl(unsigned long)::$_1&>(DB::PipelineExecutor::executeImpl(unsigned long)::$_1&)\r\n2022.05.10 10:27:02.764518 [ 22486 ] {} <Fatal> BaseDaemon: 22.3. inlined from ../contrib/libcxx/include/tuple:1595: decltype(auto) std::__1::__apply_tuple_impl<DB::PipelineExecutor::executeImpl(unsigned long)::$_1&, std::__1::tuple<>&>(DB::PipelineExecutor::executeImpl(unsigned long)::$_1&, std::__1::tuple<>&, std::__1::__tuple_indices<>)\r\n2022.05.10 10:27:02.764592 [ 22486 ] {} <Fatal> BaseDaemon: 22.4. inlined from ../contrib/libcxx/include/tuple:1604: decltype(auto) std::__1::apply<DB::PipelineExecutor::executeImpl(unsigned long)::$_1&, std::__1::tuple<>&>(DB::PipelineExecutor::executeImpl(unsigned long)::$_1&, std::__1::tuple<>&)\r\n2022.05.10 10:27:02.764655 [ 22486 ] {} <Fatal> BaseDaemon: 22.5. inlined from ../src/Common/ThreadPool.h:188: operator()\r\n2022.05.10 10:27:02.764731 [ 22486 ] {} <Fatal> BaseDaemon: 22.6. inlined from ../contrib/libcxx/include/type_traits:3640: decltype(static_cast<DB::PipelineExecutor::executeImpl(unsigned long)::$_1>(fp)()) std::__1::__invoke<ThreadFromGlobalPool::ThreadFromGlobalPool<DB::PipelineExecutor::executeImpl(unsigned long)::$_1>(DB::PipelineExecutor::executeImpl(unsigned long)::$_1&&)::'lambda'()&>(DB::PipelineExecutor::executeImpl(unsigned long)::$_1&&)\r\n2022.05.10 10:27:02.764811 [ 22486 ] {} <Fatal> BaseDaemon: 22.7. inlined from ../contrib/libcxx/include/__functional/invoke.h:61: void std::__1::__invoke_void_return_wrapper<void, true>::__call<ThreadFromGlobalPool::ThreadFromGlobalPool<DB::PipelineExecutor::executeImpl(unsigned long)::$_1>(DB::PipelineExecutor::executeImpl(unsigned long)::$_1&&)::'lambda'()&>(ThreadFromGlobalPool::ThreadFromGlobalPool<DB::PipelineExecutor::executeImpl(unsigned long)::$_1>(DB::PipelineExecutor::executeImpl(unsigned long)::$_1&&)::'lambda'()&)\r\n2022.05.10 10:27:02.764904 [ 22486 ] {} <Fatal> BaseDaemon: 22.8. inlined from ../contrib/libcxx/include/__functional/function.h:230: std::__1::__function::__default_alloc_func<ThreadFromGlobalPool::ThreadFromGlobalPool<DB::PipelineExecutor::executeImpl(unsigned long)::$_1>(DB::PipelineExecutor::executeImpl(unsigned long)::$_1&&)::'lambda'(), void ()>::operator()()\r\n2022.05.10 10:27:02.764968 [ 22486 ] {} <Fatal> BaseDaemon: 22. ../contrib/libcxx/include/__functional/function.h:711: void std::__1::__function::__policy_invoker<void ()>::__call_impl<std::__1::__function::__default_alloc_func<ThreadFromGlobalPool::ThreadFromGlobalPool<DB::PipelineExecutor::executeImpl(unsigned long)::$_1>(DB::PipelineExecutor::executeImpl(unsigned long)::$_1&&)::'lambda'(), void ()> >(std::__1::__function::__policy_storage const*) @ 0x2dd14eb7 in /usr/bin/clickhouse\r\n2022.05.10 10:27:02.805632 [ 22486 ] {} <Fatal> BaseDaemon: 23. ./build_docker/../contrib/libcxx/include/__functional/function.h:0: ThreadPoolImpl<std::__1::thread>::worker(std::__1::__list_iterator<std::__1::thread, void*>) @ 0xd394a07 in /usr/bin/clickhouse\r\n2022.05.10 10:27:02.847822 [ 22486 ] {} <Fatal> BaseDaemon: 24.1. inlined from ./build_docker/../contrib/libcxx/include/__memory/unique_ptr.h:312: std::__1::unique_ptr<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct> >, void ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, int, std::__1::optional<unsigned long>)::'lambda0'()>, std::__1::default_delete<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct> >, void ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, int, std::__1::optional<unsigned long>)::'lambda0'()> > >::reset(std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct> >, void ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, int, std::__1::optional<unsigned long>)::'lambda0'()>*)\r\n2022.05.10 10:27:02.847930 [ 22486 ] {} <Fatal> BaseDaemon: 24.2. inlined from ../contrib/libcxx/include/__memory/unique_ptr.h:269: ~unique_ptr\r\n2022.05.10 10:27:02.847995 [ 22486 ] {} <Fatal> BaseDaemon: 24. ../contrib/libcxx/include/thread:295: void* std::__1::__thread_proxy<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct> >, void ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, int, std::__1::optional<unsigned long>)::'lambda0'()> >(void*) @ 0xd39cd97 in /usr/bin/clickhouse\r\n2022.05.10 10:27:02.848083 [ 22486 ] {} <Fatal> BaseDaemon: 25. ? @ 0x7f31c5e32609 in ?\r\n2022.05.10 10:27:02.848139 [ 22486 ] {} <Fatal> BaseDaemon: 26. __clone @ 0x7f31c5d57163 in ?\r\n2022.05.10 10:27:04.350486 [ 22486 ] {} <Fatal> BaseDaemon: Checksum of the binary: D0C642E90A58A4CA4FF40B17388829D2, integrity check passed.\r\n2022.05.10 10:27:16.474222 [ 391 ] {} <Fatal> Application: Child process was terminated by signal 6.\r\n```\r\n\r\ncc: @CurtizJ \n",
  "hints_text": "",
  "created_at": "2022-05-17T23:01:58Z"
}