{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 11682,
  "instance_id": "ClickHouse__ClickHouse-11682",
  "issue_numbers": [
    "11636"
  ],
  "base_commit": "6dfb0dd5bb36a903c67378d9dc76bb7a2163144d",
  "patch": "diff --git a/src/Processors/Merges/Algorithms/AggregatingSortedAlgorithm.cpp b/src/Processors/Merges/Algorithms/AggregatingSortedAlgorithm.cpp\nindex be9bf3e354ce..34e32cdfe3ac 100644\n--- a/src/Processors/Merges/Algorithms/AggregatingSortedAlgorithm.cpp\n+++ b/src/Processors/Merges/Algorithms/AggregatingSortedAlgorithm.cpp\n@@ -280,19 +280,19 @@ AggregatingSortedAlgorithm::AggregatingSortedAlgorithm(\n {\n }\n \n-void AggregatingSortedAlgorithm::initialize(Chunks chunks)\n+void AggregatingSortedAlgorithm::initialize(Inputs inputs)\n {\n-    for (auto & chunk : chunks)\n-        if (chunk)\n-            preprocessChunk(chunk, columns_definition);\n+    for (auto & input : inputs)\n+        if (input.chunk)\n+            preprocessChunk(input.chunk, columns_definition);\n \n-    initializeQueue(std::move(chunks));\n+    initializeQueue(std::move(inputs));\n }\n \n-void AggregatingSortedAlgorithm::consume(Chunk & chunk, size_t source_num)\n+void AggregatingSortedAlgorithm::consume(Input & input, size_t source_num)\n {\n-    preprocessChunk(chunk, columns_definition);\n-    updateCursor(chunk, source_num);\n+    preprocessChunk(input.chunk, columns_definition);\n+    updateCursor(input, source_num);\n }\n \n IMergingAlgorithm::Status AggregatingSortedAlgorithm::merge()\n@@ -303,6 +303,15 @@ IMergingAlgorithm::Status AggregatingSortedAlgorithm::merge()\n         bool key_differs;\n         SortCursor current = queue.current();\n \n+        if (current->isLast() && skipLastRowFor(current->order))\n+        {\n+            /// If we skip this row, it's not equals with any key we process.\n+            last_key.reset();\n+            /// Get the next block from the corresponding source, if there is one.\n+            queue.removeTop();\n+            return Status(current.impl->order);\n+        }\n+\n         {\n             detail::RowRef current_key;\n             current_key.set(current);\ndiff --git a/src/Processors/Merges/Algorithms/AggregatingSortedAlgorithm.h b/src/Processors/Merges/Algorithms/AggregatingSortedAlgorithm.h\nindex fe1710adc8b6..da4ec876b695 100644\n--- a/src/Processors/Merges/Algorithms/AggregatingSortedAlgorithm.h\n+++ b/src/Processors/Merges/Algorithms/AggregatingSortedAlgorithm.h\n@@ -19,8 +19,8 @@ class AggregatingSortedAlgorithm final : public IMergingAlgorithmWithDelayedChun\n         const Block & header, size_t num_inputs,\n         SortDescription description_, size_t max_block_size);\n \n-    void initialize(Chunks chunks) override;\n-    void consume(Chunk & chunk, size_t source_num) override;\n+    void initialize(Inputs inputs) override;\n+    void consume(Input & input, size_t source_num) override;\n     Status merge() override;\n \n     struct SimpleAggregateDescription;\ndiff --git a/src/Processors/Merges/Algorithms/CollapsingSortedAlgorithm.cpp b/src/Processors/Merges/Algorithms/CollapsingSortedAlgorithm.cpp\nindex 49a3d0180983..697ac9496b5b 100644\n--- a/src/Processors/Merges/Algorithms/CollapsingSortedAlgorithm.cpp\n+++ b/src/Processors/Merges/Algorithms/CollapsingSortedAlgorithm.cpp\n@@ -114,6 +114,14 @@ IMergingAlgorithm::Status CollapsingSortedAlgorithm::merge()\n     while (queue.isValid())\n     {\n         auto current = queue.current();\n+\n+        if (current->isLast() && skipLastRowFor(current->order))\n+        {\n+            /// Get the next block from the corresponding source, if there is one.\n+            queue.removeTop();\n+            return Status(current.impl->order);\n+        }\n+\n         Int8 sign = assert_cast<const ColumnInt8 &>(*current->all_columns[sign_column_number]).getData()[current->pos];\n \n         RowRef current_row;\ndiff --git a/src/Processors/Merges/Algorithms/GraphiteRollupSortedAlgorithm.cpp b/src/Processors/Merges/Algorithms/GraphiteRollupSortedAlgorithm.cpp\nindex f26fe96876fe..e364a452797f 100644\n--- a/src/Processors/Merges/Algorithms/GraphiteRollupSortedAlgorithm.cpp\n+++ b/src/Processors/Merges/Algorithms/GraphiteRollupSortedAlgorithm.cpp\n@@ -157,6 +157,13 @@ IMergingAlgorithm::Status GraphiteRollupSortedAlgorithm::merge()\n     {\n         SortCursor current = queue.current();\n \n+        if (current->isLast() && skipLastRowFor(current->order))\n+        {\n+            /// Get the next block from the corresponding source, if there is one.\n+            queue.removeTop();\n+            return Status(current.impl->order);\n+        }\n+\n         StringRef next_path = current->all_columns[columns_definition.path_column_num]->getDataAt(current->pos);\n         bool new_path = is_first || next_path != current_group_path;\n \n@@ -224,7 +231,7 @@ IMergingAlgorithm::Status GraphiteRollupSortedAlgorithm::merge()\n                 *(*current_subgroup_newest_row.all_columns)[columns_definition.version_column_num],\n                 /* nan_direction_hint = */ 1) >= 0)\n         {\n-            current_subgroup_newest_row.set(current, source_chunks[current.impl->order]);\n+            current_subgroup_newest_row.set(current, sources[current.impl->order].chunk);\n \n             /// Small hack: group and subgroups have the same path, so we can set current_group_path here instead of startNextGroup\n             /// But since we keep in memory current_subgroup_newest_row's block, we could use StringRef for current_group_path and don't\ndiff --git a/src/Processors/Merges/Algorithms/IMergingAlgorithm.h b/src/Processors/Merges/Algorithms/IMergingAlgorithm.h\nindex b49209e462e3..f86be2a7d1ba 100644\n--- a/src/Processors/Merges/Algorithms/IMergingAlgorithm.h\n+++ b/src/Processors/Merges/Algorithms/IMergingAlgorithm.h\n@@ -20,8 +20,32 @@ class IMergingAlgorithm\n         explicit Status(size_t source) : required_source(source) {}\n     };\n \n-    virtual void initialize(Chunks chunks) = 0;\n-    virtual void consume(Chunk & chunk, size_t source_num) = 0;\n+    struct Input\n+    {\n+        Chunk chunk;\n+\n+        /// It is a flag which says that last row from chunk should be ignored in result.\n+        /// This row is not ignored in sorting and is needed to synchronize required source\n+        /// between different algorithm objects in parallel FINAL.\n+        bool skip_last_row = false;\n+\n+        void swap(Input & other)\n+        {\n+            chunk.swap(other.chunk);\n+            std::swap(skip_last_row, other.skip_last_row);\n+        }\n+\n+        void set(Chunk chunk_)\n+        {\n+            chunk = std::move(chunk_);\n+            skip_last_row = false;\n+        }\n+    };\n+\n+    using Inputs = std::vector<Input>;\n+\n+    virtual void initialize(Inputs inputs) = 0;\n+    virtual void consume(Input & input, size_t source_num) = 0;\n     virtual Status merge() = 0;\n \n     IMergingAlgorithm() = default;\ndiff --git a/src/Processors/Merges/Algorithms/IMergingAlgorithmWithDelayedChunk.cpp b/src/Processors/Merges/Algorithms/IMergingAlgorithmWithDelayedChunk.cpp\nindex 751a08ce69f6..0b13d689636f 100644\n--- a/src/Processors/Merges/Algorithms/IMergingAlgorithmWithDelayedChunk.cpp\n+++ b/src/Processors/Merges/Algorithms/IMergingAlgorithmWithDelayedChunk.cpp\n@@ -8,36 +8,36 @@ IMergingAlgorithmWithDelayedChunk::IMergingAlgorithmWithDelayedChunk(\n     size_t num_inputs,\n     SortDescription description_)\n     : description(std::move(description_))\n-    , source_chunks(num_inputs)\n+    , current_inputs(num_inputs)\n     , cursors(num_inputs)\n {\n }\n \n-void IMergingAlgorithmWithDelayedChunk::initializeQueue(Chunks chunks)\n+void IMergingAlgorithmWithDelayedChunk::initializeQueue(Inputs inputs)\n {\n-    source_chunks = std::move(chunks);\n+    current_inputs = std::move(inputs);\n \n-    for (size_t source_num = 0; source_num < source_chunks.size(); ++source_num)\n+    for (size_t source_num = 0; source_num < current_inputs.size(); ++source_num)\n     {\n-        if (!source_chunks[source_num])\n+        if (!current_inputs[source_num].chunk)\n             continue;\n \n-        cursors[source_num] = SortCursorImpl(source_chunks[source_num].getColumns(), description, source_num);\n+        cursors[source_num] = SortCursorImpl(current_inputs[source_num].chunk.getColumns(), description, source_num);\n     }\n \n     queue = SortingHeap<SortCursor>(cursors);\n }\n \n-void IMergingAlgorithmWithDelayedChunk::updateCursor(Chunk & chunk, size_t source_num)\n+void IMergingAlgorithmWithDelayedChunk::updateCursor(Input & input, size_t source_num)\n {\n-    auto & source_chunk = source_chunks[source_num];\n+    auto & current_input = current_inputs[source_num];\n \n     /// Extend lifetime of last chunk.\n-    last_chunk.swap(source_chunk);\n+    last_chunk.swap(current_input.chunk);\n     last_chunk_sort_columns = std::move(cursors[source_num].sort_columns);\n \n-    source_chunk.swap(chunk);\n-    cursors[source_num].reset(source_chunk.getColumns(), {});\n+    current_input.swap(input);\n+    cursors[source_num].reset(current_input.chunk.getColumns(), {});\n \n     queue.push(cursors[source_num]);\n }\ndiff --git a/src/Processors/Merges/Algorithms/IMergingAlgorithmWithDelayedChunk.h b/src/Processors/Merges/Algorithms/IMergingAlgorithmWithDelayedChunk.h\nindex f7d5f6302388..69530a707c28 100644\n--- a/src/Processors/Merges/Algorithms/IMergingAlgorithmWithDelayedChunk.h\n+++ b/src/Processors/Merges/Algorithms/IMergingAlgorithmWithDelayedChunk.h\n@@ -23,12 +23,13 @@ class IMergingAlgorithmWithDelayedChunk : public IMergingAlgorithm\n \n     ColumnRawPtrs last_chunk_sort_columns; /// Point to last_chunk if valid.\n \n-    void initializeQueue(Chunks chunks);\n-    void updateCursor(Chunk & chunk, size_t source_num);\n+    void initializeQueue(Inputs inputs);\n+    void updateCursor(Input & input, size_t source_num);\n+    bool skipLastRowFor(size_t input_number) const { return current_inputs[input_number].skip_last_row; }\n \n private:\n-    /// Chunks currently being merged.\n-    std::vector<Chunk> source_chunks;\n+    /// Inputs currently being merged.\n+    Inputs current_inputs;\n     SortCursorImpls cursors;\n \n     /// In merging algorithm, we need to compare current sort key with the last one.\ndiff --git a/src/Processors/Merges/Algorithms/IMergingAlgorithmWithSharedChunks.cpp b/src/Processors/Merges/Algorithms/IMergingAlgorithmWithSharedChunks.cpp\nindex 1fe61653ecc2..39abe5c0ec79 100644\n--- a/src/Processors/Merges/Algorithms/IMergingAlgorithmWithSharedChunks.cpp\n+++ b/src/Processors/Merges/Algorithms/IMergingAlgorithmWithSharedChunks.cpp\n@@ -11,7 +11,7 @@ IMergingAlgorithmWithSharedChunks::IMergingAlgorithmWithSharedChunks(\n     : description(std::move(description_))\n     , chunk_allocator(num_inputs + max_row_refs)\n     , cursors(num_inputs)\n-    , source_chunks(num_inputs)\n+    , sources(num_inputs)\n     , out_row_sources_buf(out_row_sources_buf_)\n {\n }\n@@ -26,39 +26,39 @@ static void prepareChunk(Chunk & chunk)\n     chunk.setColumns(std::move(columns), num_rows);\n }\n \n-void IMergingAlgorithmWithSharedChunks::initialize(Chunks chunks)\n+void IMergingAlgorithmWithSharedChunks::initialize(Inputs inputs)\n {\n-    source_chunks.resize(chunks.size());\n-\n-    for (size_t source_num = 0; source_num < source_chunks.size(); ++source_num)\n+    for (size_t source_num = 0; source_num < inputs.size(); ++source_num)\n     {\n-        if (!chunks[source_num])\n+        if (!inputs[source_num].chunk)\n             continue;\n \n-        prepareChunk(chunks[source_num]);\n+        prepareChunk(inputs[source_num].chunk);\n \n-        auto & source_chunk = source_chunks[source_num];\n+        auto & source = sources[source_num];\n \n-        source_chunk = chunk_allocator.alloc(chunks[source_num]);\n-        cursors[source_num] = SortCursorImpl(source_chunk->getColumns(), description, source_num);\n+        source.skip_last_row = inputs[source_num].skip_last_row;\n+        source.chunk = chunk_allocator.alloc(inputs[source_num].chunk);\n+        cursors[source_num] = SortCursorImpl(source.chunk->getColumns(), description, source_num);\n \n-        source_chunk->all_columns = cursors[source_num].all_columns;\n-        source_chunk->sort_columns = cursors[source_num].sort_columns;\n+        source.chunk->all_columns = cursors[source_num].all_columns;\n+        source.chunk->sort_columns = cursors[source_num].sort_columns;\n     }\n \n     queue = SortingHeap<SortCursor>(cursors);\n }\n \n-void IMergingAlgorithmWithSharedChunks::consume(Chunk & chunk, size_t source_num)\n+void IMergingAlgorithmWithSharedChunks::consume(Input & input, size_t source_num)\n {\n-    prepareChunk(chunk);\n+    prepareChunk(input.chunk);\n \n-    auto & source_chunk = source_chunks[source_num];\n-    source_chunk = chunk_allocator.alloc(chunk);\n-    cursors[source_num].reset(source_chunk->getColumns(), {});\n+    auto & source = sources[source_num];\n+    source.skip_last_row = input.skip_last_row;\n+    source.chunk = chunk_allocator.alloc(input.chunk);\n+    cursors[source_num].reset(source.chunk->getColumns(), {});\n \n-    source_chunk->all_columns = cursors[source_num].all_columns;\n-    source_chunk->sort_columns = cursors[source_num].sort_columns;\n+    source.chunk->all_columns = cursors[source_num].all_columns;\n+    source.chunk->sort_columns = cursors[source_num].sort_columns;\n \n     queue.push(cursors[source_num]);\n }\ndiff --git a/src/Processors/Merges/Algorithms/IMergingAlgorithmWithSharedChunks.h b/src/Processors/Merges/Algorithms/IMergingAlgorithmWithSharedChunks.h\nindex a3dbadc458df..65c456ea44c1 100644\n--- a/src/Processors/Merges/Algorithms/IMergingAlgorithmWithSharedChunks.h\n+++ b/src/Processors/Merges/Algorithms/IMergingAlgorithmWithSharedChunks.h\n@@ -15,8 +15,8 @@ class IMergingAlgorithmWithSharedChunks : public IMergingAlgorithm\n         WriteBuffer * out_row_sources_buf_,\n         size_t max_row_refs);\n \n-    void initialize(Chunks chunks) override;\n-    void consume(Chunk & chunk, size_t source_num) override;\n+    void initialize(Inputs inputs) override;\n+    void consume(Input & input, size_t source_num) override;\n \n private:\n     SortDescription description;\n@@ -27,9 +27,16 @@ class IMergingAlgorithmWithSharedChunks : public IMergingAlgorithm\n     SortCursorImpls cursors;\n \n protected:\n-    /// Chunks currently being merged.\n-    using SourceChunks = std::vector<detail::SharedChunkPtr>;\n-    SourceChunks source_chunks;\n+\n+    struct Source\n+    {\n+        detail::SharedChunkPtr chunk;\n+        bool skip_last_row;\n+    };\n+\n+    /// Sources currently being merged.\n+    using Sources = std::vector<Source>;\n+    Sources sources;\n \n     SortingHeap<SortCursor> queue;\n \n@@ -38,7 +45,8 @@ class IMergingAlgorithmWithSharedChunks : public IMergingAlgorithm\n     WriteBuffer * out_row_sources_buf = nullptr;\n \n     using RowRef = detail::RowRefWithOwnedChunk;\n-    void setRowRef(RowRef & row, SortCursor & cursor) { row.set(cursor, source_chunks[cursor.impl->order]); }\n+    void setRowRef(RowRef & row, SortCursor & cursor) { row.set(cursor, sources[cursor.impl->order].chunk); }\n+    bool skipLastRowFor(size_t input_number) const { return sources[input_number].skip_last_row; }\n };\n \n }\ndiff --git a/src/Processors/Merges/Algorithms/MergingSortedAlgorithm.cpp b/src/Processors/Merges/Algorithms/MergingSortedAlgorithm.cpp\nindex f1d6c56809d1..ee13ef702030 100644\n--- a/src/Processors/Merges/Algorithms/MergingSortedAlgorithm.cpp\n+++ b/src/Processors/Merges/Algorithms/MergingSortedAlgorithm.cpp\n@@ -22,7 +22,7 @@ MergingSortedAlgorithm::MergingSortedAlgorithm(\n     , description(std::move(description_))\n     , limit(limit_)\n     , out_row_sources_buf(out_row_sources_buf_)\n-    , source_chunks(num_inputs)\n+    , current_inputs(num_inputs)\n     , cursors(num_inputs)\n {\n     /// Replace column names in description to positions.\n@@ -39,7 +39,7 @@ MergingSortedAlgorithm::MergingSortedAlgorithm(\n \n void MergingSortedAlgorithm::addInput()\n {\n-    source_chunks.emplace_back();\n+    current_inputs.emplace_back();\n     cursors.emplace_back();\n }\n \n@@ -53,13 +53,13 @@ static void prepareChunk(Chunk & chunk)\n     chunk.setColumns(std::move(columns), num_rows);\n }\n \n-void MergingSortedAlgorithm::initialize(Chunks chunks)\n+void MergingSortedAlgorithm::initialize(Inputs inputs)\n {\n-    source_chunks = std::move(chunks);\n+    current_inputs = std::move(inputs);\n \n-    for (size_t source_num = 0; source_num < source_chunks.size(); ++source_num)\n+    for (size_t source_num = 0; source_num < current_inputs.size(); ++source_num)\n     {\n-        auto & chunk = source_chunks[source_num];\n+        auto & chunk = current_inputs[source_num].chunk;\n \n         if (!chunk)\n             continue;\n@@ -74,11 +74,11 @@ void MergingSortedAlgorithm::initialize(Chunks chunks)\n         queue_without_collation = SortingHeap<SortCursor>(cursors);\n }\n \n-void MergingSortedAlgorithm::consume(Chunk & chunk, size_t source_num)\n+void MergingSortedAlgorithm::consume(Input & input, size_t source_num)\n {\n-    prepareChunk(chunk);\n-    source_chunks[source_num].swap(chunk);\n-    cursors[source_num].reset(source_chunks[source_num].getColumns(), {});\n+    prepareChunk(input.chunk);\n+    current_inputs[source_num].swap(input);\n+    cursors[source_num].reset(current_inputs[source_num].chunk.getColumns(), {});\n \n     if (has_collation)\n         queue_with_collation.push(cursors[source_num]);\n@@ -105,10 +105,18 @@ IMergingAlgorithm::Status MergingSortedAlgorithm::mergeImpl(TSortingHeap & queue\n \n         auto current = queue.current();\n \n+        if (current.impl->isLast() && current_inputs[current.impl->order].skip_last_row)\n+        {\n+            /// Get the next block from the corresponding source, if there is one.\n+            queue.removeTop();\n+            return Status(current.impl->order);\n+        }\n+\n         /** And what if the block is totally less or equal than the rest for the current cursor?\n             * Or is there only one data source left in the queue? Then you can take the entire block on current cursor.\n             */\n         if (current.impl->isFirst()\n+            && !current_inputs[current.impl->order].skip_last_row /// Ignore optimization if last row should be skipped.\n             && (queue.size() == 1\n                 || (queue.size() >= 2 && current.totallyLessOrEquals(queue.nextChild()))))\n         {\n@@ -167,7 +175,7 @@ IMergingAlgorithm::Status MergingSortedAlgorithm::insertFromChunk(size_t source_\n \n     //std::cerr << \"copied columns\\n\";\n \n-    auto num_rows = source_chunks[source_num].getNumRows();\n+    auto num_rows = current_inputs[source_num].chunk.getNumRows();\n \n     UInt64 total_merged_rows_after_insertion = merged_data.mergedRows() + num_rows;\n     bool is_finished = limit && total_merged_rows_after_insertion >= limit;\n@@ -175,12 +183,12 @@ IMergingAlgorithm::Status MergingSortedAlgorithm::insertFromChunk(size_t source_\n     if (limit && total_merged_rows_after_insertion > limit)\n     {\n         num_rows -= total_merged_rows_after_insertion - limit;\n-        merged_data.insertFromChunk(std::move(source_chunks[source_num]), num_rows);\n+        merged_data.insertFromChunk(std::move(current_inputs[source_num].chunk), num_rows);\n     }\n     else\n-        merged_data.insertFromChunk(std::move(source_chunks[source_num]), 0);\n+        merged_data.insertFromChunk(std::move(current_inputs[source_num].chunk), 0);\n \n-    source_chunks[source_num] = Chunk();\n+    current_inputs[source_num].chunk = Chunk();\n \n     /// Write order of rows for other columns\n     /// this data will be used in gather stream\ndiff --git a/src/Processors/Merges/Algorithms/MergingSortedAlgorithm.h b/src/Processors/Merges/Algorithms/MergingSortedAlgorithm.h\nindex 5b361c1000e8..054aec94464a 100644\n--- a/src/Processors/Merges/Algorithms/MergingSortedAlgorithm.h\n+++ b/src/Processors/Merges/Algorithms/MergingSortedAlgorithm.h\n@@ -22,8 +22,8 @@ class MergingSortedAlgorithm final : public IMergingAlgorithm\n \n     void addInput();\n \n-    void initialize(Chunks chunks) override;\n-    void consume(Chunk & chunk, size_t source_num) override;\n+    void initialize(Inputs inputs) override;\n+    void consume(Input & input, size_t source_num) override;\n     Status merge() override;\n \n     const MergedData & getMergedData() const { return merged_data; }\n@@ -41,7 +41,7 @@ class MergingSortedAlgorithm final : public IMergingAlgorithm\n     WriteBuffer * out_row_sources_buf = nullptr;\n \n     /// Chunks currently being merged.\n-    std::vector<Chunk> source_chunks;\n+    Inputs current_inputs;\n \n     SortCursorImpls cursors;\n \ndiff --git a/src/Processors/Merges/Algorithms/ReplacingSortedAlgorithm.cpp b/src/Processors/Merges/Algorithms/ReplacingSortedAlgorithm.cpp\nindex 4a0f74936374..3ee0df0efd8f 100644\n--- a/src/Processors/Merges/Algorithms/ReplacingSortedAlgorithm.cpp\n+++ b/src/Processors/Merges/Algorithms/ReplacingSortedAlgorithm.cpp\n@@ -40,6 +40,13 @@ IMergingAlgorithm::Status ReplacingSortedAlgorithm::merge()\n     {\n         SortCursor current = queue.current();\n \n+        if (current->isLast() && skipLastRowFor(current->order))\n+        {\n+            /// Get the next block from the corresponding source, if there is one.\n+            queue.removeTop();\n+            return Status(current.impl->order);\n+        }\n+\n         RowRef current_row;\n         setRowRef(current_row, current);\n \ndiff --git a/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp b/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp\nindex 8be4aac40671..78ee848c3770 100644\n--- a/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp\n+++ b/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp\n@@ -624,19 +624,19 @@ SummingSortedAlgorithm::SummingSortedAlgorithm(\n {\n }\n \n-void SummingSortedAlgorithm::initialize(Chunks chunks)\n+void SummingSortedAlgorithm::initialize(Inputs inputs)\n {\n-    for (auto & chunk : chunks)\n-        if (chunk)\n-            preprocessChunk(chunk);\n+    for (auto & input : inputs)\n+        if (input.chunk)\n+            preprocessChunk(input.chunk);\n \n-    initializeQueue(std::move(chunks));\n+    initializeQueue(std::move(inputs));\n }\n \n-void SummingSortedAlgorithm::consume(Chunk & chunk, size_t source_num)\n+void SummingSortedAlgorithm::consume(Input & input, size_t source_num)\n {\n-    preprocessChunk(chunk);\n-    updateCursor(chunk, source_num);\n+    preprocessChunk(input.chunk);\n+    updateCursor(input, source_num);\n }\n \n IMergingAlgorithm::Status SummingSortedAlgorithm::merge()\n@@ -648,6 +648,15 @@ IMergingAlgorithm::Status SummingSortedAlgorithm::merge()\n \n         SortCursor current = queue.current();\n \n+        if (current->isLast() && skipLastRowFor(current->order))\n+        {\n+            /// If we skip this row, it's not equals with any key we process.\n+            last_key.reset();\n+            /// Get the next block from the corresponding source, if there is one.\n+            queue.removeTop();\n+            return Status(current.impl->order);\n+        }\n+\n         {\n             detail::RowRef current_key;\n             current_key.set(current);\ndiff --git a/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.h b/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.h\nindex fc5431f1a080..a188a5fb538a 100644\n--- a/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.h\n+++ b/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.h\n@@ -22,8 +22,8 @@ class SummingSortedAlgorithm final : public IMergingAlgorithmWithDelayedChunk\n         const Names & column_names_to_sum,\n         size_t max_block_size);\n \n-    void initialize(Chunks chunks) override;\n-    void consume(Chunk & chunk, size_t source_num) override;\n+    void initialize(Inputs inputs) override;\n+    void consume(Input & input, size_t source_num) override;\n     Status merge() override;\n \n     struct AggregateDescription;\ndiff --git a/src/Processors/Merges/Algorithms/VersionedCollapsingAlgorithm.cpp b/src/Processors/Merges/Algorithms/VersionedCollapsingAlgorithm.cpp\nindex e039c383995c..5e94415fae99 100644\n--- a/src/Processors/Merges/Algorithms/VersionedCollapsingAlgorithm.cpp\n+++ b/src/Processors/Merges/Algorithms/VersionedCollapsingAlgorithm.cpp\n@@ -64,6 +64,13 @@ IMergingAlgorithm::Status VersionedCollapsingAlgorithm::merge()\n     {\n         SortCursor current = queue.current();\n \n+        if (current->isLast() && skipLastRowFor(current->order))\n+        {\n+            /// Get the next block from the corresponding source, if there is one.\n+            queue.removeTop();\n+            return Status(current.impl->order);\n+        }\n+\n         RowRef current_row;\n \n         Int8 sign = assert_cast<const ColumnInt8 &>(*current->all_columns[sign_column_number]).getData()[current->pos];\ndiff --git a/src/Processors/Merges/IMergingTransform.cpp b/src/Processors/Merges/IMergingTransform.cpp\nindex 2037a88733a4..eff786b150f2 100644\n--- a/src/Processors/Merges/IMergingTransform.cpp\n+++ b/src/Processors/Merges/IMergingTransform.cpp\n@@ -87,7 +87,7 @@ IProcessor::Status IMergingTransformBase::prepareInitializeInputs()\n             continue;\n         }\n \n-        state.init_chunks[i] = std::move(chunk);\n+        state.init_chunks[i].set(std::move(chunk));\n         input_states[i].is_initialized = true;\n     }\n \n@@ -158,8 +158,8 @@ IProcessor::Status IMergingTransformBase::prepare()\n             if (!input.hasData())\n                 return Status::NeedData;\n \n-            state.input_chunk = input.pull();\n-            if (!state.input_chunk.hasRows() && !input.isFinished())\n+            state.input_chunk.set(input.pull());\n+            if (!state.input_chunk.chunk.hasRows() && !input.isFinished())\n                 return Status::NeedData;\n \n             state.has_input = true;\n@@ -174,12 +174,12 @@ IProcessor::Status IMergingTransformBase::prepare()\n     return Status::Ready;\n }\n \n-static void filterChunk(Chunk & chunk, size_t selector_position)\n+static void filterChunk(IMergingAlgorithm::Input & input, size_t selector_position)\n {\n-    if (!chunk.getChunkInfo())\n+    if (!input.chunk.getChunkInfo())\n         throw Exception(\"IMergingTransformBase expected ChunkInfo for input chunk\", ErrorCodes::LOGICAL_ERROR);\n \n-    const auto * chunk_info = typeid_cast<const SelectorInfo *>(chunk.getChunkInfo().get());\n+    const auto * chunk_info = typeid_cast<const SelectorInfo *>(input.chunk.getChunkInfo().get());\n     if (!chunk_info)\n         throw Exception(\"IMergingTransformBase expected SelectorInfo for input chunk\", ErrorCodes::LOGICAL_ERROR);\n \n@@ -188,8 +188,8 @@ static void filterChunk(Chunk & chunk, size_t selector_position)\n     IColumn::Filter filter;\n     filter.resize_fill(selector.size());\n \n-    size_t num_rows = chunk.getNumRows();\n-    auto columns = chunk.detachColumns();\n+    size_t num_rows = input.chunk.getNumRows();\n+    auto columns = input.chunk.detachColumns();\n \n     size_t num_result_rows = 0;\n \n@@ -202,54 +202,39 @@ static void filterChunk(Chunk & chunk, size_t selector_position)\n         }\n     }\n \n+    if (!filter.empty() && filter.back() == 0)\n+    {\n+        filter.back() = 1;\n+        ++num_result_rows;\n+        input.skip_last_row = true;\n+    }\n+\n     for (auto & column : columns)\n         column = column->filter(filter, num_result_rows);\n \n-    chunk.clear();\n-    chunk.setColumns(std::move(columns), num_result_rows);\n+    input.chunk.clear();\n+    input.chunk.setColumns(std::move(columns), num_result_rows);\n }\n \n-bool IMergingTransformBase::filterChunks()\n+void IMergingTransformBase::filterChunks()\n {\n     if (state.selector_position < 0)\n-        return true;\n-\n-    bool has_empty_chunk = false;\n+        return;\n \n     if (!state.init_chunks.empty())\n     {\n         for (size_t i = 0; i < input_states.size(); ++i)\n         {\n-            auto & chunk = state.init_chunks[i];\n-            if (!chunk || input_states[i].is_filtered)\n+            auto & input = state.init_chunks[i];\n+            if (!input.chunk)\n                 continue;\n \n-            filterChunk(chunk, state.selector_position);\n-\n-            if (!chunk.hasRows())\n-            {\n-                chunk.clear();\n-                has_empty_chunk = true;\n-                input_states[i].is_initialized = false;\n-                is_initialized = false;\n-            }\n-            else\n-                input_states[i].is_filtered = true;\n+            filterChunk(input, state.selector_position);\n         }\n     }\n \n     if (state.has_input)\n-    {\n         filterChunk(state.input_chunk, state.selector_position);\n-        if (!state.input_chunk.hasRows())\n-        {\n-            state.has_input = false;\n-            state.need_data = true;\n-            has_empty_chunk = true;\n-        }\n-    }\n-\n-    return !has_empty_chunk;\n }\n \n \ndiff --git a/src/Processors/Merges/IMergingTransform.h b/src/Processors/Merges/IMergingTransform.h\nindex 12a366bf21bf..ce673131ab6f 100644\n--- a/src/Processors/Merges/IMergingTransform.h\n+++ b/src/Processors/Merges/IMergingTransform.h\n@@ -36,19 +36,19 @@ class IMergingTransformBase : public IProcessor\n     virtual void onNewInput(); /// Is called when new input is added. Only if have_all_inputs = false.\n     virtual void onFinish() {} /// Is called when all data is processed.\n \n-    bool filterChunks(); /// Filter chunks if selector position was set. For parallel final.\n+    void filterChunks(); /// Filter chunks if selector position was set. For parallel final.\n \n     /// Processor state.\n     struct State\n     {\n         Chunk output_chunk;\n-        Chunk input_chunk;\n+        IMergingAlgorithm::Input input_chunk;\n         bool has_input = false;\n         bool is_finished = false;\n         bool need_data = false;\n         size_t next_input_to_read = 0;\n \n-        Chunks init_chunks;\n+        IMergingAlgorithm::Inputs init_chunks;\n         ssize_t selector_position = -1;\n     };\n \n@@ -61,7 +61,6 @@ class IMergingTransformBase : public IProcessor\n \n         InputPort & port;\n         bool is_initialized = false;\n-        bool is_filtered = false;\n     };\n \n     std::vector<InputState> input_states;\n@@ -90,8 +89,7 @@ class IMergingTransform : public IMergingTransformBase\n \n     void work() override\n     {\n-        if (!filterChunks())\n-            return;\n+        filterChunks();\n \n         if (!state.init_chunks.empty())\n             algorithm.initialize(std::move(state.init_chunks));\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01318_parallel_final_stuck.reference b/tests/queries/0_stateless/01318_parallel_final_stuck.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/01318_parallel_final_stuck.sql b/tests/queries/0_stateless/01318_parallel_final_stuck.sql\nnew file mode 100644\nindex 000000000000..1a54a9e0ae50\n--- /dev/null\n+++ b/tests/queries/0_stateless/01318_parallel_final_stuck.sql\n@@ -0,0 +1,6 @@\n+drop table if exists final_bug;\n+create table final_bug (x UInt64, y UInt8) engine = ReplacingMergeTree(y) order by x settings index_granularity = 8;\n+insert into final_bug select number % 10, 1 from numbers(1000);\n+insert into final_bug select number % 10, 1 from numbers(1000);\n+select x from final_bug final order by x settings max_threads=2, max_final_threads=2, max_block_size=8 format Null;\n+drop table if exists final_bug;\n\\ No newline at end of file\n",
  "problem_statement": "Master: pipeline stuck\n```\r\nCREATE TABLE pipeline_stuck ( `id` String, `val` SimpleAggregateFunction(anyLast, String), INDEX ind val TYPE bloom_filter() GRANULARITY 1 ) ENGINE = AggregatingMergeTree() ORDER BY id ;\r\ninsert into pipeline_stuck select toString(number%100), toString(number) from numbers(10000000);\r\nselect * from pipeline_stuck final limit 10;\r\nselect * from pipeline_stuck final where val = '9999900';\r\nalter table pipeline_stuck drop index ind;\r\nselect * from pipeline_stuck final where val = '9999900';\r\n```\n",
  "hints_text": "Simplified test:\r\n```\r\ndrop table if exists final_bug;\r\ncreate table final_bug (x UInt64, y UInt8) engine = ReplacingMergeTree(y) order by x settings index_granularity = 8;\r\ninsert into final_bug select number % 10, 1 from numbers(1000);\r\ninsert into final_bug select number % 10, 1 from numbers(1000);\r\nselect x from final_bug final order by x settings max_threads=2, max_final_threads=2, max_block_size=8;\r\n```",
  "created_at": "2020-06-15T14:03:33Z",
  "modified_files": [
    "src/Processors/Merges/Algorithms/AggregatingSortedAlgorithm.cpp",
    "src/Processors/Merges/Algorithms/AggregatingSortedAlgorithm.h",
    "src/Processors/Merges/Algorithms/CollapsingSortedAlgorithm.cpp",
    "src/Processors/Merges/Algorithms/GraphiteRollupSortedAlgorithm.cpp",
    "src/Processors/Merges/Algorithms/IMergingAlgorithm.h",
    "src/Processors/Merges/Algorithms/IMergingAlgorithmWithDelayedChunk.cpp",
    "src/Processors/Merges/Algorithms/IMergingAlgorithmWithDelayedChunk.h",
    "src/Processors/Merges/Algorithms/IMergingAlgorithmWithSharedChunks.cpp",
    "src/Processors/Merges/Algorithms/IMergingAlgorithmWithSharedChunks.h",
    "src/Processors/Merges/Algorithms/MergingSortedAlgorithm.cpp",
    "src/Processors/Merges/Algorithms/MergingSortedAlgorithm.h",
    "src/Processors/Merges/Algorithms/ReplacingSortedAlgorithm.cpp",
    "src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp",
    "src/Processors/Merges/Algorithms/SummingSortedAlgorithm.h",
    "src/Processors/Merges/Algorithms/VersionedCollapsingAlgorithm.cpp",
    "src/Processors/Merges/IMergingTransform.cpp",
    "src/Processors/Merges/IMergingTransform.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01318_parallel_final_stuck.sql"
  ]
}