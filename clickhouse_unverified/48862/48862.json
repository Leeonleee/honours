{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 48862,
  "instance_id": "ClickHouse__ClickHouse-48862",
  "issue_numbers": [
    "48746"
  ],
  "base_commit": "8bc0a3a899f69133497cf2db5cbd876d93bbde08",
  "patch": "diff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp\nindex 5cd02c33d554..be9cb887b036 100644\n--- a/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -14,37 +14,40 @@\n #include <Common/thread_local_rng.h>\n #include <Common/typeid_cast.h>\n #include <Common/ThreadFuzzer.h>\n-#include <Storages/MergeTree/DataPartStorageOnDiskFull.h>\n \n #include <Disks/ObjectStorages/IMetadataStorage.h>\n \n #include <base/sort.h>\n \n #include <Storages/AlterCommands.h>\n-#include <Storages/PartitionCommands.h>\n #include <Storages/ColumnsDescription.h>\n-#include <Storages/StorageReplicatedMergeTree.h>\n+#include <Storages/Freeze.h>\n+#include <Storages/MergeTree/AsyncBlockIDsCache.h>\n+#include <Storages/MergeTree/DataPartStorageOnDiskFull.h>\n+#include <Storages/MergeTree/extractZkPathFromCreateQuery.h>\n #include <Storages/MergeTree/IMergeTreeDataPart.h>\n+#include <Storages/MergeTree/LeaderElection.h>\n+#include <Storages/MergeTree/MergedBlockOutputStream.h>\n+#include <Storages/MergeTree/MergeFromLogEntryTask.h>\n #include <Storages/MergeTree/MergeList.h>\n #include <Storages/MergeTree/MergeTreeBackgroundExecutor.h>\n-#include <Storages/MergeTree/MergedBlockOutputStream.h>\n+#include <Storages/MergeTree/MergeTreeDataFormatVersion.h>\n+#include <Storages/MergeTree/MergeTreePartInfo.h>\n+#include <Storages/MergeTree/MergeTreeReaderCompact.h>\n+#include <Storages/MergeTree/MutateFromLogEntryTask.h>\n #include <Storages/MergeTree/PinnedPartUUIDs.h>\n+#include <Storages/MergeTree/ReplicatedMergeTreeAddress.h>\n #include <Storages/MergeTree/ReplicatedMergeTreeAttachThread.h>\n-#include <Storages/MergeTree/ReplicatedMergeTreeTableMetadata.h>\n-#include <Storages/MergeTree/ReplicatedMergeTreeSink.h>\n-#include <Storages/MergeTree/ReplicatedMergeTreeQuorumEntry.h>\n #include <Storages/MergeTree/ReplicatedMergeTreeMutationEntry.h>\n-#include <Storages/MergeTree/ReplicatedMergeTreeAddress.h>\n-#include <Storages/MergeTree/ReplicatedMergeTreeQuorumAddedParts.h>\n #include <Storages/MergeTree/ReplicatedMergeTreePartHeader.h>\n-#include <Storages/MergeTree/MergeFromLogEntryTask.h>\n-#include <Storages/MergeTree/MutateFromLogEntryTask.h>\n-#include <Storages/VirtualColumnUtils.h>\n-#include <Storages/MergeTree/MergeTreeReaderCompact.h>\n-#include <Storages/MergeTree/LeaderElection.h>\n+#include <Storages/MergeTree/ReplicatedMergeTreeQuorumAddedParts.h>\n+#include <Storages/MergeTree/ReplicatedMergeTreeQuorumEntry.h>\n+#include <Storages/MergeTree/ReplicatedMergeTreeSink.h>\n+#include <Storages/MergeTree/ReplicatedMergeTreeTableMetadata.h>\n #include <Storages/MergeTree/ZeroCopyLock.h>\n-#include <Storages/MergeTree/extractZkPathFromCreateQuery.h>\n-#include <Storages/Freeze.h>\n+#include <Storages/PartitionCommands.h>\n+#include <Storages/StorageReplicatedMergeTree.h>\n+#include <Storages/VirtualColumnUtils.h>\n \n #include <Databases/DatabaseOnDisk.h>\n #include <Databases/DatabaseReplicated.h>\n@@ -96,7 +99,6 @@\n \n #include <base/scope_guard.h>\n #include <Common/scope_guard_safe.h>\n-#include <Storages/MergeTree/AsyncBlockIDsCache.h>\n \n #include <boost/algorithm/string/join.hpp>\n #include <boost/algorithm/string/replace.hpp>\n@@ -149,6 +151,7 @@ namespace ErrorCodes\n     extern const int REPLICA_IS_NOT_IN_QUORUM;\n     extern const int TABLE_IS_READ_ONLY;\n     extern const int NOT_FOUND_NODE;\n+    extern const int BAD_DATA_PART_NAME;\n     extern const int NO_ACTIVE_REPLICAS;\n     extern const int NOT_A_LEADER;\n     extern const int TABLE_WAS_NOT_DROPPED;\n@@ -8281,7 +8284,7 @@ StorageReplicatedMergeTree::unlockSharedData(const IMergeTreeDataPart & part, co\n         return std::make_pair(true, NameSet{});\n \n     return unlockSharedDataByID(\n-        part.getUniqueId(), shared_id, part.name, replica_name,\n+        part.getUniqueId(), shared_id, part.info, replica_name,\n         part.getDataPartStorage().getDiskType(), zookeeper, *getSettings(), log, zookeeper_path, format_version);\n }\n \n@@ -8298,11 +8301,10 @@ namespace\n /// But sometimes we need an opposite. When we deleting all_0_0_0_1 it can be non replicated to other replicas, so we are the only owner of this part.\n /// In this case when we will drop all_0_0_0_1 we will drop blobs for all_0_0_0. But it will lead to dataloss. For such case we need to check that other replicas\n /// still need parent part.\n-std::pair<bool, NameSet> getParentLockedBlobs(const ZooKeeperWithFaultInjectionPtr & zookeeper_ptr, const std::string & zero_copy_part_path_prefix, const std::string & part_info_str, MergeTreeDataFormatVersion format_version, Poco::Logger * log)\n+std::pair<bool, NameSet> getParentLockedBlobs(const ZooKeeperWithFaultInjectionPtr & zookeeper_ptr, const std::string & zero_copy_part_path_prefix, const MergeTreePartInfo & part_info, MergeTreeDataFormatVersion format_version, Poco::Logger * log)\n {\n     NameSet files_not_to_remove;\n \n-    MergeTreePartInfo part_info = MergeTreePartInfo::fromPartName(part_info_str, format_version);\n     /// No mutations -- no hardlinks -- no issues\n     if (part_info.mutation == 0)\n         return {false, files_not_to_remove};\n@@ -8336,7 +8338,7 @@ std::pair<bool, NameSet> getParentLockedBlobs(const ZooKeeperWithFaultInjectionP\n         /// We are mutation child of this parent\n         if (part_info.isMutationChildOf(parent_candidate_info))\n         {\n-            LOG_TRACE(log, \"Found mutation parent {} for part {}\", part_candidate_info_str, part_info_str);\n+            LOG_TRACE(log, \"Found mutation parent {} for part {}\", part_candidate_info_str, part_info.getPartNameV1());\n             /// Get hardlinked files\n             String files_not_to_remove_str;\n             Coordination::Error code;\n@@ -8359,12 +8361,14 @@ std::pair<bool, NameSet> getParentLockedBlobs(const ZooKeeperWithFaultInjectionP\n }\n \n std::pair<bool, NameSet> StorageReplicatedMergeTree::unlockSharedDataByID(\n-        String part_id, const String & table_uuid, const String & part_name,\n+        String part_id, const String & table_uuid, const MergeTreePartInfo & part_info,\n         const String & replica_name_, const std::string & disk_type, const ZooKeeperWithFaultInjectionPtr & zookeeper_ptr, const MergeTreeSettings & settings,\n         Poco::Logger * logger, const String & zookeeper_path_old, MergeTreeDataFormatVersion data_format_version)\n {\n     boost::replace_all(part_id, \"/\", \"_\");\n \n+    auto part_name = part_info.getPartNameV1();\n+\n     Strings zc_zookeeper_paths = getZeroCopyPartPath(settings, disk_type, table_uuid, part_name, zookeeper_path_old);\n \n     bool part_has_no_more_locks = true;\n@@ -8380,7 +8384,7 @@ std::pair<bool, NameSet> StorageReplicatedMergeTree::unlockSharedDataByID(\n             boost::split(files_not_to_remove, files_not_to_remove_str, boost::is_any_of(\"\\n \"));\n \n         auto [has_parent, parent_not_to_remove] = getParentLockedBlobs(\n-            zookeeper_ptr, fs::path(zc_zookeeper_path).parent_path(), part_name, data_format_version, logger);\n+            zookeeper_ptr, fs::path(zc_zookeeper_path).parent_path(), part_info, data_format_version, logger);\n         files_not_to_remove.insert(parent_not_to_remove.begin(), parent_not_to_remove.end());\n \n         String zookeeper_part_uniq_node = fs::path(zc_zookeeper_path) / part_id;\n@@ -9035,6 +9039,11 @@ bool StorageReplicatedMergeTree::removeSharedDetachedPart(DiskPtr disk, const St\n \n     NameSet files_not_to_remove;\n \n+    // zero copy replication is only available since format version 1 so we can safely use it here\n+    auto part_info = DetachedPartInfo::parseDetachedPartName(disk, part_name, MERGE_TREE_DATA_MIN_FORMAT_VERSION_WITH_CUSTOM_PARTITIONING);\n+    if (!part_info.valid_name)\n+        throw Exception(ErrorCodes::BAD_DATA_PART_NAME, \"Invalid detached part name {} on disk {}\", path, disk->getName());\n+\n     fs::path checksums = fs::path(path) / IMergeTreeDataPart::FILE_FOR_REFERENCES_CHECK;\n     if (disk->exists(checksums))\n     {\n@@ -9043,7 +9052,7 @@ bool StorageReplicatedMergeTree::removeSharedDetachedPart(DiskPtr disk, const St\n             String id = disk->getUniqueId(checksums);\n             bool can_remove = false;\n             std::tie(can_remove, files_not_to_remove) = StorageReplicatedMergeTree::unlockSharedDataByID(\n-                id, table_uuid, part_name,\n+                id, table_uuid, part_info,\n                 detached_replica_name,\n                 toString(disk->getDataSourceDescription().type),\n                 std::make_shared<ZooKeeperWithFaultInjection>(zookeeper), local_context->getReplicatedMergeTreeSettings(),\ndiff --git a/src/Storages/StorageReplicatedMergeTree.h b/src/Storages/StorageReplicatedMergeTree.h\nindex e99af135133e..ade4e4f0b4bc 100644\n--- a/src/Storages/StorageReplicatedMergeTree.h\n+++ b/src/Storages/StorageReplicatedMergeTree.h\n@@ -267,7 +267,7 @@ class StorageReplicatedMergeTree final : public MergeTreeData\n     static std::pair<bool, NameSet> unlockSharedDataByID(\n         String part_id,\n         const String & table_uuid,\n-        const String & part_name,\n+        const MergeTreePartInfo & part_info,\n         const String & replica_name_,\n         const std::string & disk_type,\n         const ZooKeeperWithFaultInjectionPtr & zookeeper_,\n",
  "test_patch": "diff --git a/tests/integration/test_zero_copy_replication_drop_detached_part/__init__.py b/tests/integration/test_zero_copy_replication_drop_detached_part/__init__.py\nnew file mode 100644\nindex 000000000000..e5a0d9b4834e\n--- /dev/null\n+++ b/tests/integration/test_zero_copy_replication_drop_detached_part/__init__.py\n@@ -0,0 +1,1 @@\n+#!/usr/bin/env python3\ndiff --git a/tests/integration/test_zero_copy_replication_drop_detached_part/configs/storage_conf.xml b/tests/integration/test_zero_copy_replication_drop_detached_part/configs/storage_conf.xml\nnew file mode 100644\nindex 000000000000..b08721c44e23\n--- /dev/null\n+++ b/tests/integration/test_zero_copy_replication_drop_detached_part/configs/storage_conf.xml\n@@ -0,0 +1,30 @@\n+<clickhouse>\n+    <logger>\n+        <level>test</level>\n+    </logger>\n+\n+    <storage_configuration>\n+        <disks>\n+            <s3>\n+                <type>s3</type>\n+                <endpoint>http://minio1:9001/root/data/</endpoint>\n+                <access_key_id>minio</access_key_id>\n+                <secret_access_key>minio123</secret_access_key>\n+            </s3>\n+        </disks>\n+        <policies>\n+            <s3>\n+                <volumes>\n+                    <main>\n+                        <disk>s3</disk>\n+                    </main>\n+                </volumes>\n+            </s3>\n+        </policies>\n+    </storage_configuration>\n+\n+    <merge_tree>\n+        <storage_policy>s3</storage_policy>\n+        <allow_remote_fs_zero_copy_replication>true</allow_remote_fs_zero_copy_replication>\n+    </merge_tree>\n+</clickhouse>\ndiff --git a/tests/integration/test_zero_copy_replication_drop_detached_part/test.py b/tests/integration/test_zero_copy_replication_drop_detached_part/test.py\nnew file mode 100644\nindex 000000000000..2ecf026d9fb9\n--- /dev/null\n+++ b/tests/integration/test_zero_copy_replication_drop_detached_part/test.py\n@@ -0,0 +1,90 @@\n+#!/usr/bin/env python3\n+\n+import logging\n+import random\n+import string\n+import time\n+import os\n+\n+from multiprocessing.dummy import Pool\n+import pytest\n+from helpers.cluster import ClickHouseCluster\n+\n+\n+cluster = ClickHouseCluster(__file__)\n+\n+\n+@pytest.fixture(scope=\"module\")\n+def started_cluster():\n+    try:\n+        cluster.add_instance(\n+            \"node1\",\n+            main_configs=[\"configs/storage_conf.xml\"],\n+            with_minio=True,\n+            with_zookeeper=True,\n+        )\n+        cluster.start()\n+\n+        yield cluster\n+    finally:\n+        cluster.shutdown()\n+\n+\n+def test_drop_detached_part(started_cluster):\n+    node1 = cluster.instances[\"node1\"]\n+\n+    node1.query(\n+        \"\"\"\n+CREATE TABLE test1 (EventDate Date, CounterID UInt32)\n+ENGINE = ReplicatedMergeTree('/clickhouse-tables/test1', 'r1')\n+ORDER BY (CounterID, EventDate)\"\"\"\n+    )\n+\n+    node1.query(\n+        \"INSERT INTO test1 SELECT toDate('2023-01-01') + toIntervalDay(number), number + 1000 from system.numbers limit 20\"\n+    )\n+    node1.query(\"ALTER TABLE test1 DETACH PART 'all_0_0_0'\")\n+\n+    def get_path_to_detached_part(query_result):\n+        part_to_disk = {}\n+        for row in query_result.strip().split(\"\\n\"):\n+            print(row)\n+            return row\n+\n+    path_to_detached_part = get_path_to_detached_part(\n+        node1.query(\"SELECT path FROM system.detached_parts where table = 'test1'\")\n+    )\n+\n+    new_part_name = \"ignored_\" + os.path.basename(path_to_detached_part)\n+    new_path_to_detached_part_name = (\n+        os.path.dirname(path_to_detached_part) + os.sep + new_part_name\n+    )\n+\n+    node1.exec_in_container(\n+        [\n+            \"bash\",\n+            \"-c\",\n+            f\"mv {path_to_detached_part} {new_path_to_detached_part_name}\",\n+        ],\n+        privileged=True,\n+        user=\"root\",\n+    )\n+\n+    assert (\n+        node1.query(\n+            \"SELECT path FROM system.detached_parts where table = 'test1'\"\n+        ).strip()\n+        == new_path_to_detached_part_name\n+    )\n+\n+    node1.query(\n+        f\"ALTER TABLE test1 DROP DETACHED PART '{new_part_name}'\",\n+        settings={\"allow_drop_detached\": 1},\n+    )\n+\n+    assert (\n+        node1.query(\n+            \"SELECT path FROM system.detached_parts where table = 'test1'\"\n+        ).strip()\n+        == \"\"\n+    )\n",
  "problem_statement": "Broken detached parts cleanup does not work with zero-copy replication\n```\r\nInitialization failed, table will remain readonly. Error: Code: 233. DB::Exception: Unexpected part name: ignored_all_58400_58417_3 for format version: 1. (BAD_DATA_PART_NAME), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0xe0c66f5 in /usr/bin/clickhouse\r\n1. ? @ 0x1451d6ac in /usr/bin/clickhouse\r\n2. DB::MergeTreePartInfo::fromPartName(String const&, StrongTypedef<unsigned int, DB::MergeTreeDataFormatVersionTag>) @ 0x1451d183 in /usr/bin/clickhouse\r\n3. DB::StorageReplicatedMergeTree::unlockSharedDataByID(String, String const&, String const&, String const&, String const&, std::shared_ptr<DB::ZooKeeperWithFaultInjection> const&, DB::MergeTreeSettings const&, Poco::Logger*, String const&, StrongTypedef<unsigned int, DB::MergeTreeDataFormatVersionTag>) @ 0x14018e28 in /usr/bin/clickhouse\r\n4. DB::StorageReplicatedMergeTree::removeSharedDetachedPart(std::shared_ptr<DB::IDisk>, String const&, String const&, String const&, String const&, String const&, std::shared_ptr<DB::Context const> const&, std::shared_ptr<zkutil::ZooKeeper> const&) @ 0x1402f87f in /usr/bin/clickhouse\r\n5. DB::StorageReplicatedMergeTree::removeDetachedPart(std::shared_ptr<DB::IDisk>, String const&, String const&) @ 0x1402f017 in /usr/bin/clickhouse\r\n6. DB::MergeTreeData::clearOldBrokenPartsFromDetachedDirectory() @ 0x143c0d4d in /usr/bin/clickhouse\r\n7. DB::ReplicatedMergeTreeAttachThread::runImpl() @ 0x146344fa in /usr/bin/clickhouse\r\n8. DB::ReplicatedMergeTreeAttachThread::run() @ 0x14631b56 in /usr/bin/clickhouse\r\n9. DB::BackgroundSchedulePoolTaskInfo::execute() @ 0x12586586 in /usr/bin/clickhouse\r\n10. DB::BackgroundSchedulePool::threadFunction() @ 0x1258960a in /usr/bin/clickhouse\r\n11. ? @ 0x1258a44e in /usr/bin/clickhouse\r\n12. ThreadPoolImpl<std::thread>::worker(std::__list_iterator<std::thread, void*>) @ 0xe19a46a in /usr/bin/clickhouse\r\n13. ? @ 0xe19fb21 in /usr/bin/clickhouse\r\n14. ? @ 0x7fe7a20c4b43 in ?\r\n15. ? @ 0x7fe7a2156a00 in ?\r\n```\r\n\r\n(this particular issue was worked around by https://github.com/ClickHouse/ClickHouse/pull/48730, but we still need to make the background cleanup work)\r\n\n",
  "hints_text": "As I understand it, the problem is, that when we try to remove detached parts on a zero-copy-replication disk, we call  `unlockSharedDataByID` with argument part_name like `ignored_all_58400_58417_3` (or generally `<prefix>_....` where `<prefix>` is one of the predefined prefixes for detached parts (`broken` , `unexpected`, `ignored`, ...).\r\n\r\nInside `unlockSharedDataByID` we call `getParentLockedBlobs` which then calls `MergeTreePartInfo::fromPartName` with that part name. But `MergeTreePartInfo::fromPartName` doesn't know about the prefix. Further up in the stack another method `DetachedPartInfo::parseDetachedPartName` is called, which does know about the prefix - perhaps we can use that instead? Anyway, `fromPartName` throws an exception because the the \"part name is unexpected\". This exception causes the whole `removeSharedDetachedPart` method to fail. And no detached parts are cleaned up. And the table remains readonly until server restart.\r\n\r\nI didn't fully understand, why the Initialization failed... Unexpected part name error doesn't re-appear after server restart. Seems like something changes ctime of the detached part directory. Not sure what. Maybe it gets updated when we try to remove a broken detached part and rename it to something like `deleting_..., but then `unlockSharedDataByID` fails and we rename it back. The first part (rename to `deleting_...`) [happens just before the](https://github.com/ClickHouse/clickhouse-private/blob/master/src/Storages/MergeTree/MergeTreeData.cpp#L2448-L2453) `Will clean up {} detached parts log message`. I couldn't find the place where we rename it back to the original ignored_... though.\r\n",
  "created_at": "2023-04-17T15:59:31Z",
  "modified_files": [
    "src/Storages/StorageReplicatedMergeTree.cpp",
    "src/Storages/StorageReplicatedMergeTree.h"
  ],
  "modified_test_files": [
    "b/tests/integration/test_zero_copy_replication_drop_detached_part/__init__.py",
    "b/tests/integration/test_zero_copy_replication_drop_detached_part/configs/storage_conf.xml",
    "b/tests/integration/test_zero_copy_replication_drop_detached_part/test.py"
  ]
}