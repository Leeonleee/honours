{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 55211,
  "instance_id": "ClickHouse__ClickHouse-55211",
  "issue_numbers": [
    "54734"
  ],
  "base_commit": "14767fd4ac081cea93bae725c25d8f775f1e7d55",
  "patch": "diff --git a/docs/en/sql-reference/functions/arithmetic-functions.md b/docs/en/sql-reference/functions/arithmetic-functions.md\nindex 69f1816b7dfa..1aa9c982f33f 100644\n--- a/docs/en/sql-reference/functions/arithmetic-functions.md\n+++ b/docs/en/sql-reference/functions/arithmetic-functions.md\n@@ -441,3 +441,40 @@ DB::Exception: Decimal result's scale is less than argument's one: While process\n \u2502 -12 \u2502 2.1 \u2502                                                       -5.7 \u2502                                                   -5.71428 \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n+\n+## byteSwap\n+\n+Reverses the bytes of an integer, i.e. changes its [endianness](https://en.wikipedia.org/wiki/Endianness). Currently, integers of up to 64 bit are supported.\n+\n+**Syntax**\n+\n+```sql\n+byteSwap(a)\n+```\n+\n+**Example**\n+\n+```sql\n+byteSwap(3351772109)\n+```\n+\n+Result:\n+\n+```result\n+\u250c\u2500byteSwap(3351772109)\u2500\u2510\n+\u2502           3455829959 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+The above example can be worked out in the following manner:\n+1. Convert the base-10 integer to its equivalent hexadecimal format in big-endian format, i.e. 3351772109 -> C7 C7 FB CD (4 bytes)\n+2. Reverse the bytes, i.e. C7 C7 FB CD -> CD FB C7 C7\n+3. Convert the result back to an integer assuming big-endian, i.e. CD FB C7 C7  -> 3455829959\n+\n+One use case of this function is reversing IPv4s:\n+\n+```result\n+\u250c\u2500toIPv4(byteSwap(toUInt32(toIPv4('205.251.199.199'))))\u2500\u2510\n+\u2502 199.199.251.205                                       \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\ndiff --git a/src/Functions/byteSwap.cpp b/src/Functions/byteSwap.cpp\nnew file mode 100644\nindex 000000000000..bdc6eb6c3864\n--- /dev/null\n+++ b/src/Functions/byteSwap.cpp\n@@ -0,0 +1,97 @@\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionUnaryArithmetic.h>\n+\n+namespace DB\n+{\n+namespace ErrorCodes\n+{\n+extern const int NOT_IMPLEMENTED;\n+}\n+\n+namespace\n+{\n+template <typename T>\n+requires std::is_integral_v<T>\n+T byteSwap(T x)\n+{\n+    return std::byteswap(x);\n+}\n+\n+template <typename T>\n+T byteSwap(T)\n+{\n+    throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"byteSwap() is not implemented for {} datatype\", demangle(typeid(T).name()));\n+}\n+\n+template <typename T>\n+struct ByteSwapImpl\n+{\n+    using ResultType = T;\n+    static constexpr const bool allow_string_or_fixed_string = false;\n+    static T apply(T x) { return byteSwap<T>(x); }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = false;\n+#endif\n+};\n+\n+struct NameByteSwap\n+{\n+    static constexpr auto name = \"byteSwap\";\n+};\n+using FunctionByteSwap = FunctionUnaryArithmetic<ByteSwapImpl, NameByteSwap, true>;\n+\n+}\n+\n+template <>\n+struct FunctionUnaryArithmeticMonotonicity<NameByteSwap>\n+{\n+    static bool has() { return false; }\n+    static IFunction::Monotonicity get(const Field &, const Field &) { return {}; }\n+};\n+\n+REGISTER_FUNCTION(ByteSwap)\n+{\n+    factory.registerFunction<FunctionByteSwap>(\n+        FunctionDocumentation{\n+            .description = R\"(\n+Reverses the bytes of an integer, i.e. changes its [endianness](https://en.wikipedia.org/wiki/Endianness). Currently, integers of up to 64 bit are supported.\n+\n+**Example**\n+\n+```sql\n+byteSwap(3351772109)\n+```\n+\n+Result:\n+\n+```result\n+\u250c\u2500byteSwap(3351772109)\u2500\u2510\n+\u2502           3455829959 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+The above example can be worked out in the following manner:\n+1. Convert the base-10 integer to its equivalent hexadecimal format in big-endian format, i.e. 3351772109 -> C7 C7 FB CD (4 bytes)\n+2. Reverse the bytes, i.e. C7 C7 FB CD -> CD FB C7 C7\n+3. Convert the result back to an integer assuming big-endian, i.e. CD FB C7 C7  -> 3455829959\n+\n+One use-case of this function is reversing IPv4s:\n+\n+```result\n+\u250c\u2500toIPv4(byteSwap(toUInt32(toIPv4('205.251.199.199'))))\u2500\u2510\n+\u2502 199.199.251.205                                       \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+)\",\n+            .examples{\n+                {\"8-bit\", \"SELECT byteSwap(54)\", \"54\"},\n+                {\"16-bit\", \"SELECT byteSwap(4135)\", \"10000\"},\n+                {\"32-bit\", \"SELECT byteSwap(3351772109)\", \"3455829959\"},\n+                {\"64-bit\", \"SELECT byteSwap(123294967295)\", \"18439412204227788800\"},\n+            },\n+            .categories{\"Mathematical\", \"Arithmetic\"}},\n+        FunctionFactory::CaseInsensitive);\n+}\n+\n+}\ndiff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt\nindex e5a031dabe3e..d4a307c15da2 100644\n--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt\n+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt\n@@ -1176,6 +1176,7 @@ buildId\n buildable\n builtins\n byteSize\n+byteSwap\n bytebase\n bytesToCutForIPv\n cLoki\n@@ -1414,6 +1415,7 @@ encodeXMLComponent\n encodings\n encryptions\n endian\n+endianness\n endsWith\n endsWithUTF\n enum\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02887_byteswap.reference b/tests/queries/0_stateless/02887_byteswap.reference\nnew file mode 100644\nindex 000000000000..b55b6f9cd6b0\n--- /dev/null\n+++ b/tests/queries/0_stateless/02887_byteswap.reference\n@@ -0,0 +1,29 @@\n+0\n+1\n+255\n+1\n+10000\n+4135\n+65535\n+256\n+3455829959\n+3351772109\n+4294967295\n+16777216\n+18439412204227788800\n+123294967295\n+18446744073709551615\n+0\n+-1\n+-128\n+32767\n+-9745\n+128\n+-8388609\n+855914552\n+128\n+-549755813889\n+4039370097989451775\n+128\n+0\n+1\ndiff --git a/tests/queries/0_stateless/02887_byteswap.sql b/tests/queries/0_stateless/02887_byteswap.sql\nnew file mode 100644\nindex 000000000000..297132c7e7d7\n--- /dev/null\n+++ b/tests/queries/0_stateless/02887_byteswap.sql\n@@ -0,0 +1,57 @@\n+SELECT byteSwap(0::UInt8);\n+SELECT byteSwap(1::UInt8);\n+SELECT byteSwap(255::UInt8);\n+\n+SELECT byteSwap(256::UInt16);\n+SELECT byteSwap(4135::UInt16);\n+SELECT byteSwap(10000::UInt16);\n+SELECT byteSwap(65535::UInt16);\n+\n+SELECT byteSwap(65536::UInt32);\n+SELECT byteSwap(3351772109::UInt32);\n+SELECT byteSwap(3455829959::UInt32);\n+SELECT byteSwap(4294967295::UInt32);\n+\n+SELECT byteSwap(4294967296::UInt64);\n+SELECT byteSwap(123294967295::UInt64);\n+SELECT byteSwap(18439412204227788800::UInt64);\n+SELECT byteSwap(18446744073709551615::UInt64);\n+\n+SELECT byteSwap(-0::Int8);\n+SELECT byteSwap(-1::Int8);\n+SELECT byteSwap(-128::Int8);\n+\n+SELECT byteSwap(-129::Int16);\n+SELECT byteSwap(-4135::Int16);\n+SELECT byteSwap(-32768::Int16);\n+\n+SELECT byteSwap(-32769::Int32);\n+SELECT byteSwap(-3351772109::Int32);\n+SELECT byteSwap(-2147483648::Int32);\n+\n+SELECT byteSwap(-2147483649::Int64);\n+SELECT byteSwap(-1242525266376::Int64);\n+SELECT byteSwap(-9223372036854775808::Int64);\n+\n+-- Booleans are interpreted as UInt8\n+SELECT byteSwap(false);\n+SELECT byteSwap(true);\n+\n+-- Number of arguments should equal 1\n+SELECT byteSwap();  -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT byteSwap(128, 129);  -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+\n+-- Input should be integral\n+SELECT byteSwap('abc');  -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT byteSwap(toFixedString('abc', 3));  -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT byteSwap(toDate('2019-01-01'));  -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT byteSwap(toDate32('2019-01-01'));  -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT byteSwap(toDateTime32(1546300800));  -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT byteSwap(toDateTime64(1546300800, 3));  -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT byteSwap(generateUUIDv4()); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT byteSwap(toDecimal32(2, 4));  -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT byteSwap(toFloat32(123.456));  -- { serverError NOT_IMPLEMENTED }\n+SELECT byteSwap(toFloat64(123.456));  -- { serverError NOT_IMPLEMENTED }\n+SELECT byteSwap(18446744073709551616::UInt128);  -- { serverError NOT_IMPLEMENTED }\n+SELECT byteSwap(-9223372036854775809::Int128);  -- { serverError NOT_IMPLEMENTED }\n+\n",
  "problem_statement": "Function `byteSwap`\n**Use case**\r\n\r\nIf a number was in big-endian instead of little-endian, or vice versa, convert it back.\r\n\r\nExample:\r\n\r\nInstead of writing:\r\n```\r\nSELECT toIPv4(reinterpretAsUInt32(reverse(reinterpretAsFixedString(3351772109))))\r\n```\r\n\r\nI want to write:\r\n```\r\nSELECT toIPv4(byteSwap(3351772109))\r\n```\r\n\r\n**Describe the solution you'd like**\r\n\r\nImplement this function for integer types.\n",
  "hints_text": "/assign\r\n\r\nHello, I'd like to work on this feature.\n@Priyansh121096 Thank you, this is very welcomed!",
  "created_at": "2023-10-02T22:38:32Z"
}