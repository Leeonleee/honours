{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 12382,
  "instance_id": "ClickHouse__ClickHouse-12382",
  "issue_numbers": [
    "7941"
  ],
  "base_commit": "a5ced8325f604a5cc1d4f79bb396ed2dc1630e1a",
  "patch": "diff --git a/src/Interpreters/InterpreterAlterQuery.cpp b/src/Interpreters/InterpreterAlterQuery.cpp\nindex 61277b8160ce..cd35e619d373 100644\n--- a/src/Interpreters/InterpreterAlterQuery.cpp\n+++ b/src/Interpreters/InterpreterAlterQuery.cpp\n@@ -23,7 +23,6 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n-    extern const int SUPPORT_IS_DISABLED;\n     extern const int INCORRECT_QUERY;\n }\n \n@@ -62,10 +61,6 @@ BlockIO InterpreterAlterQuery::execute()\n             alter_commands.emplace_back(std::move(*alter_command));\n         else if (auto partition_command = PartitionCommand::parse(command_ast))\n         {\n-            if (partition_command->type == PartitionCommand::DROP_DETACHED_PARTITION\n-                && !context.getSettingsRef().allow_drop_detached)\n-                throw DB::Exception(\"Cannot execute query: DROP DETACHED PART is disabled \"\n-                                    \"(see allow_drop_detached setting)\", ErrorCodes::SUPPORT_IS_DISABLED);\n             partition_commands.emplace_back(std::move(*partition_command));\n         }\n         else if (auto mut_command = MutationCommand::parse(command_ast))\n@@ -90,6 +85,7 @@ BlockIO InterpreterAlterQuery::execute()\n \n     if (!partition_commands.empty())\n     {\n+        table->checkAlterPartitionIsPossible(partition_commands, metadata_snapshot, context.getSettingsRef());\n         table->alterPartition(query_ptr, metadata_snapshot, partition_commands, context);\n     }\n \ndiff --git a/src/Storages/AlterCommands.cpp b/src/Storages/AlterCommands.cpp\nindex ea78d4122751..ca2a0aed108f 100644\n--- a/src/Storages/AlterCommands.cpp\n+++ b/src/Storages/AlterCommands.cpp\n@@ -1003,6 +1003,9 @@ void AlterCommands::validate(const StorageInMemoryMetadata & metadata, const Con\n         }\n     }\n \n+    if (all_columns.empty())\n+        throw Exception{\"Cannot DROP or CLEAR all columns\", ErrorCodes::BAD_ARGUMENTS};\n+\n     validateColumnsDefaultsAndGetSampleBlock(default_expr_list, all_columns.getAll(), context);\n }\n \ndiff --git a/src/Storages/ColumnsDescription.h b/src/Storages/ColumnsDescription.h\nindex 1d6d04f303fb..a95705d79f4b 100644\n--- a/src/Storages/ColumnsDescription.h\n+++ b/src/Storages/ColumnsDescription.h\n@@ -121,6 +121,11 @@ class ColumnsDescription\n         return columns.size();\n     }\n \n+    bool empty() const\n+    {\n+        return columns.empty();\n+    }\n+\n     /// Keep the sequence of columns and allow to lookup by name.\n     using Container = boost::multi_index_container<\n         ColumnDescription,\ndiff --git a/src/Storages/IStorage.cpp b/src/Storages/IStorage.cpp\nindex 919464a6a5de..4513394cada7 100644\n--- a/src/Storages/IStorage.cpp\n+++ b/src/Storages/IStorage.cpp\n@@ -102,6 +102,10 @@ void IStorage::checkAlterIsPossible(const AlterCommands & commands, const Settin\n     }\n }\n \n+void IStorage::checkAlterPartitionIsPossible(const PartitionCommands & /*commands*/, const StorageMetadataPtr & /*metadata_snapshot*/, const Settings & /*settings*/) const\n+{\n+    throw Exception(\"Table engine \" + getName() + \" doesn't support partitioning\", ErrorCodes::NOT_IMPLEMENTED);\n+}\n \n StorageID IStorage::getStorageID() const\n {\ndiff --git a/src/Storages/IStorage.h b/src/Storages/IStorage.h\nindex 3022a234625d..e6a1a8e12989 100644\n--- a/src/Storages/IStorage.h\n+++ b/src/Storages/IStorage.h\n@@ -360,6 +360,9 @@ class IStorage : public std::enable_shared_from_this<IStorage>, public TypePromo\n         throw Exception(\"Partition operations are not supported by storage \" + getName(), ErrorCodes::NOT_IMPLEMENTED);\n     }\n \n+    /// Checks that partition commands can be applied to storage.\n+    virtual void checkAlterPartitionIsPossible(const PartitionCommands & commands, const StorageMetadataPtr & metadata_snapshot, const Settings & settings) const;\n+\n     /** Perform any background work. For example, combining parts in a MergeTree type table.\n       * Returns whether any work has been done.\n       */\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex 89e7cf95d508..8c7b5321c820 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -110,6 +110,7 @@ namespace ErrorCodes\n     extern const int UNKNOWN_DISK;\n     extern const int NOT_ENOUGH_SPACE;\n     extern const int ALTER_OF_COLUMN_IS_FORBIDDEN;\n+    extern const int SUPPORT_IS_DISABLED;\n }\n \n \n@@ -1421,12 +1422,20 @@ void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, const S\n     columns_in_keys.insert(columns_alter_type_metadata_only.begin(), columns_alter_type_metadata_only.end());\n     columns_in_keys.insert(columns_alter_type_check_safe_for_partition.begin(), columns_alter_type_check_safe_for_partition.end());\n \n+    NameSet dropped_columns;\n+\n     std::map<String, const IDataType *> old_types;\n     for (const auto & column : old_metadata.getColumns().getAllPhysical())\n         old_types.emplace(column.name, column.type.get());\n \n     for (const AlterCommand & command : commands)\n     {\n+        /// Just validate partition expression\n+        if (command.partition)\n+        {\n+            getPartitionIDFromQuery(command.partition, global_context);\n+        }\n+\n         if (command.type == AlterCommand::MODIFY_ORDER_BY && !is_custom_partitioned)\n         {\n             throw Exception(\n@@ -1456,6 +1465,7 @@ void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, const S\n                     \"Trying to ALTER DROP key \" + backQuoteIfNeed(command.column_name) + \" column which is a part of key expression\",\n                     ErrorCodes::ALTER_OF_COLUMN_IS_FORBIDDEN);\n             }\n+            dropped_columns.emplace(command.column_name);\n         }\n         else if (command.isModifyingData(getInMemoryMetadata()))\n         {\n@@ -1530,6 +1540,27 @@ void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, const S\n                 checkStoragePolicy(global_context.getStoragePolicy(changed_setting.value.safeGet<String>()));\n         }\n     }\n+\n+    for (const auto & part : getDataPartsVector())\n+    {\n+        bool at_least_one_column_rest = false;\n+        for (const auto & column : part->getColumns())\n+        {\n+            if (!dropped_columns.count(column.name))\n+            {\n+                at_least_one_column_rest = true;\n+                break;\n+            }\n+        }\n+        if (!at_least_one_column_rest)\n+        {\n+            std::string postfix;\n+            if (dropped_columns.size() > 1)\n+                postfix = \"s\";\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                \"Cannot drop or clear column{} '{}', because all columns in part '{}' will be removed from disk. Empty parts are not allowed\", postfix, boost::algorithm::join(dropped_columns, \", \"), part->name);\n+        }\n+    }\n }\n \n MergeTreeDataPartType MergeTreeData::choosePartType(size_t bytes_uncompressed, size_t rows_count) const\n@@ -2525,6 +2556,45 @@ void MergeTreeData::freezePartition(const ASTPtr & partition_ast, const StorageM\n         context);\n }\n \n+void MergeTreeData::checkAlterPartitionIsPossible(const PartitionCommands & commands, const StorageMetadataPtr & /*metadata_snapshot*/, const Settings & settings) const\n+{\n+    for (const auto & command : commands)\n+    {\n+        if (command.type == PartitionCommand::DROP_DETACHED_PARTITION\n+            && !settings.allow_drop_detached)\n+            throw DB::Exception(\"Cannot execute query: DROP DETACHED PART is disabled \"\n+                                \"(see allow_drop_detached setting)\", ErrorCodes::SUPPORT_IS_DISABLED);\n+\n+        if (command.partition && command.type != PartitionCommand::DROP_DETACHED_PARTITION)\n+        {\n+            if (command.part)\n+            {\n+                auto part_name = command.partition->as<ASTLiteral &>().value.safeGet<String>();\n+                /// We able to parse it\n+                MergeTreePartInfo::fromPartName(part_name, format_version);\n+            }\n+            else\n+            {\n+                /// We able to parse it\n+                getPartitionIDFromQuery(command.partition, global_context);\n+            }\n+        }\n+    }\n+}\n+\n+void MergeTreeData::checkPartitionCanBeDropped(const ASTPtr & partition)\n+{\n+    const String partition_id = getPartitionIDFromQuery(partition, global_context);\n+    auto parts_to_remove = getDataPartsVectorInPartition(MergeTreeDataPartState::Committed, partition_id);\n+\n+    UInt64 partition_size = 0;\n+\n+    for (const auto & part : parts_to_remove)\n+        partition_size += part->getBytesOnDisk();\n+\n+    auto table_id = getStorageID();\n+    global_context.checkPartitionCanBeDropped(table_id.database_name, table_id.table_name, partition_size);\n+}\n \n void MergeTreeData::movePartitionToDisk(const ASTPtr & partition, const String & name, bool moving_part, const Context & context)\n {\n@@ -2626,7 +2696,7 @@ void MergeTreeData::movePartitionToVolume(const ASTPtr & partition, const String\n }\n \n \n-String MergeTreeData::getPartitionIDFromQuery(const ASTPtr & ast, const Context & context)\n+String MergeTreeData::getPartitionIDFromQuery(const ASTPtr & ast, const Context & context) const\n {\n     const auto & partition_ast = ast->as<ASTPartition &>();\n \n@@ -3045,7 +3115,7 @@ MergeTreeData::DataPartsVector MergeTreeData::getDataPartsVector() const\n }\n \n MergeTreeData::DataPartPtr MergeTreeData::getAnyPartInPartition(\n-    const String & partition_id, DataPartsLock & /*data_parts_lock*/)\n+    const String & partition_id, DataPartsLock & /*data_parts_lock*/) const\n {\n     auto it = data_parts_by_state_and_info.lower_bound(DataPartStateAndPartitionID{DataPartState::Committed, partition_id});\n \ndiff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h\nindex af511b481396..2c53b3287cd1 100644\n--- a/src/Storages/MergeTree/MergeTreeData.h\n+++ b/src/Storages/MergeTree/MergeTreeData.h\n@@ -24,6 +24,7 @@\n #include <Disks/StoragePolicy.h>\n #include <Interpreters/Aggregator.h>\n #include <Storages/extractKeyExpressionList.h>\n+#include <Storages/PartitionCommands.h>\n \n #include <boost/multi_index_container.hpp>\n #include <boost/multi_index/ordered_index.hpp>\n@@ -505,6 +506,9 @@ class MergeTreeData : public IStorage\n     /// If something is wrong, throws an exception.\n     void checkAlterIsPossible(const AlterCommands & commands, const Settings & settings) const override;\n \n+    /// Checks that partition name in all commands is valid\n+    void checkAlterPartitionIsPossible(const PartitionCommands & commands, const StorageMetadataPtr & metadata_snapshot, const Settings & settings) const override;\n+\n     /// Change MergeTreeSettings\n     void changeSettings(\n         const ASTPtr & new_settings,\n@@ -547,6 +551,8 @@ class MergeTreeData : public IStorage\n     /// Moves partition to specified Volume\n     void movePartitionToVolume(const ASTPtr & partition, const String & name, bool moving_part, const Context & context);\n \n+    void checkPartitionCanBeDropped(const ASTPtr & partition) override;\n+\n     size_t getColumnCompressedSize(const std::string & name) const\n     {\n         auto lock = lockParts();\n@@ -561,7 +567,7 @@ class MergeTreeData : public IStorage\n     }\n \n     /// For ATTACH/DETACH/DROP PARTITION.\n-    String getPartitionIDFromQuery(const ASTPtr & ast, const Context & context);\n+    String getPartitionIDFromQuery(const ASTPtr & ast, const Context & context) const;\n \n     /// Extracts MergeTreeData of other *MergeTree* storage\n     ///  and checks that their structure suitable for ALTER TABLE ATTACH PARTITION FROM\n@@ -815,7 +821,7 @@ class MergeTreeData : public IStorage\n     void removePartContributionToColumnSizes(const DataPartPtr & part);\n \n     /// If there is no part in the partition with ID `partition_id`, returns empty ptr. Should be called under the lock.\n-    DataPartPtr getAnyPartInPartition(const String & partition_id, DataPartsLock & data_parts_lock);\n+    DataPartPtr getAnyPartInPartition(const String & partition_id, DataPartsLock & data_parts_lock) const;\n \n     /// Return parts in the Committed set that are covered by the new_part_info or the part that covers it.\n     /// Will check that the new part doesn't already exist and that it doesn't intersect existing part.\ndiff --git a/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp b/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp\nindex 63d4bdf1aa5c..3deb61bf8db9 100644\n--- a/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp\n+++ b/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp\n@@ -1068,20 +1068,6 @@ bool ReplicatedMergeTreeQueue::shouldExecuteLogEntry(\n         }\n     }\n \n-    /// TODO: it makes sense to check DROP_RANGE also\n-    if (entry.type == LogEntry::CLEAR_COLUMN || entry.type == LogEntry::REPLACE_RANGE)\n-    {\n-        String conflicts_description;\n-        String range_name = (entry.type == LogEntry::REPLACE_RANGE) ? entry.replace_range_entry->drop_range_part_name : entry.new_part_name;\n-        auto range = MergeTreePartInfo::fromPartName(range_name, format_version);\n-\n-        if (0 != getConflictsCountForRange(range, entry, &conflicts_description, state_lock))\n-        {\n-            LOG_DEBUG(log, conflicts_description);\n-            return false;\n-        }\n-    }\n-\n     /// Alters must be executed one by one. First metadata change, and after that data alter (MUTATE_PART entries with).\n     /// corresponding alter_version.\n     if (entry.type == LogEntry::ALTER_METADATA)\ndiff --git a/src/Storages/StorageMaterializedView.cpp b/src/Storages/StorageMaterializedView.cpp\nindex 9e6245c3ced1..9cbe06a37015 100644\n--- a/src/Storages/StorageMaterializedView.cpp\n+++ b/src/Storages/StorageMaterializedView.cpp\n@@ -257,6 +257,13 @@ void StorageMaterializedView::alterPartition(\n     getTargetTable()->alterPartition(query, metadata_snapshot, commands, context);\n }\n \n+void StorageMaterializedView::checkAlterPartitionIsPossible(\n+    const PartitionCommands & commands, const StorageMetadataPtr & metadata_snapshot, const Settings & settings) const\n+{\n+    checkStatementCanBeForwarded();\n+    getTargetTable()->checkAlterPartitionIsPossible(commands, metadata_snapshot, settings);\n+}\n+\n void StorageMaterializedView::mutate(const MutationCommands & commands, const Context & context)\n {\n     checkStatementCanBeForwarded();\ndiff --git a/src/Storages/StorageMaterializedView.h b/src/Storages/StorageMaterializedView.h\nindex f45d9203badf..2692880eb2c2 100644\n--- a/src/Storages/StorageMaterializedView.h\n+++ b/src/Storages/StorageMaterializedView.h\n@@ -53,6 +53,8 @@ class StorageMaterializedView final : public ext::shared_ptr_helper<StorageMater\n \n     void alterPartition(const ASTPtr & query, const StorageMetadataPtr & metadata_snapshot, const PartitionCommands & commands, const Context & context) override;\n \n+    void checkAlterPartitionIsPossible(const PartitionCommands & commands, const StorageMetadataPtr & metadata_snapshot, const Settings & settings) const override;\n+\n     void mutate(const MutationCommands & commands, const Context & context) override;\n \n     void renameInMemory(const StorageID & new_table_id) override;\ndiff --git a/src/Storages/StorageMergeTree.cpp b/src/Storages/StorageMergeTree.cpp\nindex 13db64f7758d..eecde28b7bbe 100644\n--- a/src/Storages/StorageMergeTree.cpp\n+++ b/src/Storages/StorageMergeTree.cpp\n@@ -209,22 +209,6 @@ void StorageMergeTree::checkTableCanBeDropped() const\n     global_context.checkTableCanBeDropped(table_id.database_name, table_id.table_name, getTotalActiveSizeInBytes());\n }\n \n-void StorageMergeTree::checkPartitionCanBeDropped(const ASTPtr & partition)\n-{\n-    auto table_id = getStorageID();\n-\n-    const String partition_id = getPartitionIDFromQuery(partition, global_context);\n-    auto parts_to_remove = getDataPartsVectorInPartition(MergeTreeDataPartState::Committed, partition_id);\n-\n-    UInt64 partition_size = 0;\n-\n-    for (const auto & part : parts_to_remove)\n-    {\n-        partition_size += part->getBytesOnDisk();\n-    }\n-    global_context.checkPartitionCanBeDropped(table_id.database_name, table_id.table_name, partition_size);\n-}\n-\n void StorageMergeTree::drop()\n {\n     shutdown();\ndiff --git a/src/Storages/StorageMergeTree.h b/src/Storages/StorageMergeTree.h\nindex 9418f1a073c5..c80c9f443778 100644\n--- a/src/Storages/StorageMergeTree.h\n+++ b/src/Storages/StorageMergeTree.h\n@@ -81,8 +81,6 @@ class StorageMergeTree final : public ext::shared_ptr_helper<StorageMergeTree>,\n \n     void checkTableCanBeDropped() const override;\n \n-    void checkPartitionCanBeDropped(const ASTPtr & partition) override;\n-\n     ActionLock getActionLock(StorageActionBlockType action_type) override;\n \n     CheckResults checkData(const ASTPtr & query, const Context & context) override;\ndiff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp\nindex 5fa8bb82ea1c..cd7a8f3d39dc 100644\n--- a/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -4054,22 +4054,6 @@ void StorageReplicatedMergeTree::checkTableCanBeDropped() const\n     global_context.checkTableCanBeDropped(table_id.database_name, table_id.table_name, getTotalActiveSizeInBytes());\n }\n \n-\n-void StorageReplicatedMergeTree::checkPartitionCanBeDropped(const ASTPtr & partition)\n-{\n-    const String partition_id = getPartitionIDFromQuery(partition, global_context);\n-    auto parts_to_remove = getDataPartsVectorInPartition(MergeTreeDataPartState::Committed, partition_id);\n-\n-    UInt64 partition_size = 0;\n-\n-    for (const auto & part : parts_to_remove)\n-        partition_size += part->getBytesOnDisk();\n-\n-    auto table_id = getStorageID();\n-    global_context.checkPartitionCanBeDropped(table_id.database_name, table_id.table_name, partition_size);\n-}\n-\n-\n void StorageReplicatedMergeTree::rename(const String & new_path_to_table_data, const StorageID & new_table_id)\n {\n     MergeTreeData::rename(new_path_to_table_data, new_table_id);\ndiff --git a/src/Storages/StorageReplicatedMergeTree.h b/src/Storages/StorageReplicatedMergeTree.h\nindex 5d8b0883f70e..f6690051ad6e 100644\n--- a/src/Storages/StorageReplicatedMergeTree.h\n+++ b/src/Storages/StorageReplicatedMergeTree.h\n@@ -134,8 +134,6 @@ class StorageReplicatedMergeTree final : public ext::shared_ptr_helper<StorageRe\n \n     void checkTableCanBeDropped() const override;\n \n-    void checkPartitionCanBeDropped(const ASTPtr & partition) override;\n-\n     ActionLock getActionLock(StorageActionBlockType action_type) override;\n \n     /// Wait when replication queue size becomes less or equal than queue_size\ndiff --git a/src/Storages/getStructureOfRemoteTable.cpp b/src/Storages/getStructureOfRemoteTable.cpp\nindex aca5456d85ec..7dfee90588ab 100644\n--- a/src/Storages/getStructureOfRemoteTable.cpp\n+++ b/src/Storages/getStructureOfRemoteTable.cpp\n@@ -43,7 +43,7 @@ ColumnsDescription getStructureOfRemoteTable(\n \n             /// Expect at least some columns.\n             /// This is a hack to handle the empty block case returned by Connection when skip_unavailable_shards is set.\n-            if (res.size() == 0)\n+            if (res.empty())\n                 continue;\n \n             return res;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01388_clear_all_columns.reference b/tests/queries/0_stateless/01388_clear_all_columns.reference\nnew file mode 100644\nindex 000000000000..3a1946a27f0b\n--- /dev/null\n+++ b/tests/queries/0_stateless/01388_clear_all_columns.reference\n@@ -0,0 +1,6 @@\n+0\t1\tHello\n+0\t1\tHello\n+0\t2\tHello\n+0\t2\tHello\n+0\t3\tHello\n+0\t3\tHello\ndiff --git a/tests/queries/0_stateless/01388_clear_all_columns.sql b/tests/queries/0_stateless/01388_clear_all_columns.sql\nnew file mode 100644\nindex 000000000000..269c6eee824e\n--- /dev/null\n+++ b/tests/queries/0_stateless/01388_clear_all_columns.sql\n@@ -0,0 +1,34 @@\n+DROP TABLE IF EXISTS test;\n+CREATE TABLE test (x UInt8) ENGINE = MergeTree ORDER BY tuple();\n+INSERT INTO test (x) VALUES (1), (2), (3);\n+ALTER TABLE test CLEAR COLUMN x; --{serverError 36}\n+DROP TABLE test;\n+\n+DROP TABLE IF EXISTS test;\n+\n+CREATE TABLE test (x UInt8, y UInt8) ENGINE = MergeTree ORDER BY tuple();\n+INSERT INTO test (x, y) VALUES (1, 1), (2, 2), (3, 3);\n+\n+ALTER TABLE test CLEAR COLUMN x;\n+\n+ALTER TABLE test CLEAR COLUMN x IN PARTITION ''; --{serverError 248}\n+ALTER TABLE test CLEAR COLUMN x IN PARTITION 'asdasd'; --{serverError 248}\n+ALTER TABLE test CLEAR COLUMN x IN PARTITION '123'; --{serverError 248}\n+\n+ALTER TABLE test CLEAR COLUMN y; --{serverError 36}\n+\n+ALTER TABLE test ADD COLUMN z String DEFAULT 'Hello';\n+\n+-- y is only real column in table\n+ALTER TABLE test CLEAR COLUMN y; --{serverError 36}\n+ALTER TABLE test CLEAR COLUMN x;\n+ALTER TABLE test CLEAR COLUMN z;\n+\n+INSERT INTO test (x, y, z) VALUES (1, 1, 'a'), (2, 2, 'b'), (3, 3, 'c');\n+\n+ALTER TABLE test CLEAR COLUMN z;\n+ALTER TABLE test CLEAR COLUMN x;\n+\n+SELECT * FROM test ORDER BY y;\n+\n+DROP TABLE IF EXISTS test;\n",
  "problem_statement": "ClickHouse does not like empty columns in a part\n```\r\n:) create table t (a Int, b Int) engine = MergeTree order by tuple() partition by tuple();\r\n:) insert into t values (1,2)\r\n:) alter table t drop column b\r\n:) alter table t add column b Int\r\n:) alter table t drop column a\r\n:) alter table t add column a Int\r\n\r\n:) select * from t\r\n\r\nSELECT *\r\nFROM t\r\n\r\nReceived exception from server (version 19.18.1):\r\nCode: 49. DB::Exception: Received from localhost:9000. DB::Exception: Could not find a column of minimum size in MergeTree, part /var/lib/clickhouse/data/default/t/all_1_1_0/. \r\n\r\n0 rows in set. Elapsed: 0.002 sec. \r\n```\n",
  "hints_text": "related #6913\n```sql\r\nCREATE TABLE aaaa ENGINE = MergeTree ORDER BY tuple() AS SELECT * FROM numbers(100)\r\n\r\nOk.\r\n0 rows in set. Elapsed: 0.015 sec. \r\n\r\n\r\nALTER TABLE aaaa  DROP COLUMN number\r\n\r\nReceived exception from server (version 19.15.1):\r\nCode: 90. DB::Exception: Received from localhost:9000. DB::Exception: Empty list of columns passed. \r\n0 rows in set. Elapsed: 0.012 sec. \r\n\r\nSHOW CREATE TABLE aaaa\r\n\r\nReceived exception from server (version 19.15.1):\r\nCode: 62. DB::Exception: Received from localhost:9000. DB::Exception: Syntax error (in file /var/lib/clickhouse/metadata/default/aaaa.sql): failed at position 21 (line 3, col 1): )\r\nENGINE = MergeTree\r\nORDER BY tuple()\r\nSETTINGS index_granularity = 8192\r\n. Expected one of: table propery (column, index, constraint) declaration, columns or indices declaration list, column declaration, INDEX, CONSTRAINT, identifier, list of elements. \r\n\r\n0 rows in set. Elapsed: 0.005 sec. \r\n\r\n\r\n\u279c sudo cat /var/lib/clickhouse/metadata/default/aaaa.sql\r\nATTACH TABLE aaaa\r\n(\r\n)\r\nENGINE = MergeTree\r\nORDER BY tuple()\r\nSETTINGS index_granularity = 8192\r\n\r\n```\r\n\r\n:joy_cat:",
  "created_at": "2020-07-10T05:59:54Z"
}