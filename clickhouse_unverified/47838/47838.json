{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 47838,
  "instance_id": "ClickHouse__ClickHouse-47838",
  "issue_numbers": [
    "45249"
  ],
  "base_commit": "16ddb4cc4b3336a158e52d453407074e3658d63b",
  "patch": "diff --git a/docs/en/sql-reference/functions/type-conversion-functions.md b/docs/en/sql-reference/functions/type-conversion-functions.md\nindex 6e4686a0b930..73156898d4d9 100644\n--- a/docs/en/sql-reference/functions/type-conversion-functions.md\n+++ b/docs/en/sql-reference/functions/type-conversion-functions.md\n@@ -737,6 +737,44 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## toDecimalString\n+\n+Converts a numeric value to String with the number of fractional digits in the output specified by the user.\n+\n+**Syntax**\n+\n+``` sql\n+toDecimalString(number, scale)\n+```\n+\n+**Parameters**\n+\n+-   `number` \u2014 Value to be represented as String, [Int, UInt](/docs/en/sql-reference/data-types/int-uint.md), [Float](/docs/en/sql-reference/data-types/float.md), [Decimal](/docs/en/sql-reference/data-types/decimal.md),\n+-   `scale` \u2014 Number of fractional digits, [UInt8](/docs/en/sql-reference/data-types/int-uint.md).\n+    * Maximum scale for [Decimal](/docs/en/sql-reference/data-types/decimal.md) and [Int, UInt](/docs/en/sql-reference/data-types/int-uint.md) types is 77 (it is the maximum possible number of significant digits for Decimal),\n+    * Maximum scale for [Float](/docs/en/sql-reference/data-types/float.md) is 60.\n+\n+**Returned value**\n+\n+-   Input value represented as [String](/docs/en/sql-reference/data-types/string.md) with given number of fractional digits (scale).\n+    The number is rounded up or down according to common arithmetics in case requested scale is smaller than original number's scale.\n+\n+**Example**\n+\n+Query:\n+\n+``` sql\n+SELECT toDecimalString(CAST('64.32', 'Float64'), 5);\n+```\n+\n+Result:\n+\n+```response\n+\u250ctoDecimalString(CAST('64.32', 'Float64'), 5)\u2500\u2510\n+\u2502 64.32000                                    \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## reinterpretAsUInt(8\\|16\\|32\\|64)\n \n ## reinterpretAsInt(8\\|16\\|32\\|64)\ndiff --git a/docs/ru/sql-reference/functions/type-conversion-functions.md b/docs/ru/sql-reference/functions/type-conversion-functions.md\nindex c2beb55fee11..298b7bbc93e8 100644\n--- a/docs/ru/sql-reference/functions/type-conversion-functions.md\n+++ b/docs/ru/sql-reference/functions/type-conversion-functions.md\n@@ -553,6 +553,44 @@ SELECT toFixedString('foo\\0bar', 8) AS s, toStringCutToZero(s) AS s_cut;\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## toDecimalString\n+\n+\u041f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u043b\u044e\u0431\u043e\u0439 \u0447\u0438\u0441\u043b\u0435\u043d\u043d\u044b\u0439 \u0442\u0438\u043f \u043f\u0435\u0440\u0432\u044b\u043c \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u043c, \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0441\u0442\u0440\u043e\u043a\u043e\u0432\u043e\u0435 \u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u043e\u0435 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0447\u0438\u0441\u043b\u0430 \u0441 \u0442\u043e\u0447\u043d\u043e\u0441\u0442\u044c\u044e, \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u0439 \u0432\u0442\u043e\u0440\u044b\u043c \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u043c.\n+\n+**\u0421\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441**\n+\n+``` sql\n+toDecimalString(number, scale)\n+```\n+\n+**\u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b**\n+\n+-   `number` \u2014 \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043b\u044e\u0431\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u043e\u0432\u043e\u0433\u043e \u0442\u0438\u043f\u0430: [Int, UInt](/docs/ru/sql-reference/data-types/int-uint.md), [Float](/docs/ru/sql-reference/data-types/float.md), [Decimal](/docs/ru/sql-reference/data-types/decimal.md),\n+-   `scale` \u2014 \u0422\u0440\u0435\u0431\u0443\u0435\u043c\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u044b\u0445 \u0437\u043d\u0430\u043a\u043e\u0432 \u043f\u043e\u0441\u043b\u0435 \u0437\u0430\u043f\u044f\u0442\u043e\u0439, [UInt8](/docs/ru/sql-reference/data-types/int-uint.md).\n+    * \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 `scale` \u0434\u043b\u044f \u0442\u0438\u043f\u043e\u0432 [Decimal](/docs/ru/sql-reference/data-types/decimal.md) \u0438 [Int, UInt](/docs/ru/sql-reference/data-types/int-uint.md) \u0434\u043e\u043b\u0436\u043d\u043e \u043d\u0435 \u043f\u0440\u0435\u0432\u044b\u0448\u0430\u0442\u044c 77 (\u0442\u0430\u043a \u043a\u0430\u043a \u044d\u0442\u043e \u043d\u0430\u0438\u0431\u043e\u043b\u044c\u0448\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0437\u043d\u0430\u0447\u0438\u043c\u044b\u0445 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 \u0434\u043b\u044f \u044d\u0442\u0438\u0445 \u0442\u0438\u043f\u043e\u0432),\n+    * \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 `scale` \u0434\u043b\u044f \u0442\u0438\u043f\u0430 [Float](/docs/ru/sql-reference/data-types/float.md) \u043d\u0435 \u0434\u043e\u043b\u0436\u043d\u043e \u043f\u0440\u0435\u0432\u044b\u0448\u0430\u0442\u044c 60.\n+\n+**\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435**\n+\n+-   \u0421\u0442\u0440\u043e\u043a\u0430 ([String](/docs/en/sql-reference/data-types/string.md)), \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u044f\u044e\u0449\u0430\u044f \u0441\u043e\u0431\u043e\u0439 \u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u043e\u0435 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0432\u0445\u043e\u0434\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430 \u0441 \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u0439 \u0434\u043b\u0438\u043d\u043e\u0439 \u0434\u0440\u043e\u0431\u043d\u043e\u0439 \u0447\u0430\u0441\u0442\u0438.\n+    \u041f\u0440\u0438 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\u0441\u0442\u0438 \u0447\u0438\u0441\u043b\u043e \u043e\u043a\u0440\u0443\u0433\u043b\u044f\u0435\u0442\u0441\u044f \u043f\u043e \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u043c \u043f\u0440\u0430\u0432\u0438\u043b\u0430\u043c \u0430\u0440\u0438\u0444\u043c\u0435\u0442\u0438\u043a\u0438.\n+\n+**\u041f\u0440\u0438\u043c\u0435\u0440 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f**\n+\n+\u0417\u0430\u043f\u0440\u043e\u0441:\n+\n+``` sql\n+SELECT toDecimalString(CAST('64.32', 'Float64'), 5);\n+```\n+\n+\u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442:\n+\n+```response\n+\u250c\u2500toDecimalString(CAST('64.32', 'Float64'), 5)\u2510\n+\u2502 64.32000                                    \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## reinterpretAsUInt(8\\|16\\|32\\|64) {#reinterpretasuint8163264}\n \n ## reinterpretAsInt(8\\|16\\|32\\|64) {#reinterpretasint8163264}\ndiff --git a/src/Functions/FunctionToDecimalString.cpp b/src/Functions/FunctionToDecimalString.cpp\nnew file mode 100644\nindex 000000000000..fb076d03c6b5\n--- /dev/null\n+++ b/src/Functions/FunctionToDecimalString.cpp\n@@ -0,0 +1,22 @@\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionToDecimalString.h>\n+#include <Functions/IFunction.h>\n+\n+namespace DB\n+{\n+\n+REGISTER_FUNCTION(ToDecimalString)\n+{\n+    factory.registerFunction<FunctionToDecimalString>(\n+        {\n+            R\"(\n+Returns string representation of a number. First argument is the number of any numeric type,\n+second argument is the desired number of digits in fractional part. Returns String.\n+\n+        )\",\n+            Documentation::Examples{{\"toDecimalString\", \"SELECT toDecimalString(2.1456,2)\"}},\n+            Documentation::Categories{\"String\"}\n+        }, FunctionFactory::CaseInsensitive);\n+}\n+\n+}\ndiff --git a/src/Functions/FunctionToDecimalString.h b/src/Functions/FunctionToDecimalString.h\nnew file mode 100644\nindex 000000000000..6ae007e6b665\n--- /dev/null\n+++ b/src/Functions/FunctionToDecimalString.h\n@@ -0,0 +1,312 @@\n+#pragma once\n+\n+#include <Core/Types.h>\n+#include <Core/DecimalFunctions.h>\n+#include <Functions/IFunction.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <Columns/ColumnsNumber.h>\n+#include <Columns/ColumnString.h>\n+#include <Columns/ColumnVector.h>\n+#include <Columns/ColumnDecimal.h>\n+#include <DataTypes/DataTypeString.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <IO/WriteBufferFromVector.h>\n+#include <IO/WriteHelpers.h>\n+#include <Interpreters/Context_fwd.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int ILLEGAL_COLUMN;\n+    extern const int CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER;\n+}\n+\n+class FunctionToDecimalString : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"toDecimalString\";\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionToDecimalString>(); }\n+\n+    String getName() const override { return name; }\n+\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+\n+    size_t getNumberOfArguments() const override { return 2; }\n+\n+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    {\n+        if (!isNumber(*arguments[0]))\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                            \"Illegal first argument for formatDecimal function: got {}, expected numeric type\",\n+                            arguments[0]->getName());\n+\n+        if (!isUInt8(*arguments[1]))\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                            \"Illegal second argument for formatDecimal function: got {}, expected UInt8\",\n+                            arguments[1]->getName());\n+\n+        return std::make_shared<DataTypeString>();\n+    }\n+\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+private:\n+    /// For operations with Integer/Float\n+    template <typename FromVectorType>\n+    void vectorConstant(const FromVectorType & vec_from, UInt8 precision,\n+                        ColumnString::Chars & vec_to, ColumnString::Offsets & result_offsets) const\n+    {\n+        size_t input_rows_count = vec_from.size();\n+        result_offsets.resize(input_rows_count);\n+\n+        /// Buffer is used here and in functions below because resulting size cannot be precisely anticipated,\n+        /// and buffer resizes on-the-go. Also, .count() provided by buffer is convenient in this case.\n+        WriteBufferFromVector<ColumnString::Chars> buf_to(vec_to);\n+\n+        for (size_t i = 0; i < input_rows_count; ++i)\n+        {\n+            format(vec_from[i], buf_to, precision);\n+            result_offsets[i] = buf_to.count();\n+        }\n+\n+        buf_to.finalize();\n+    }\n+\n+    template <typename FirstArgVectorType>\n+    void vectorVector(const FirstArgVectorType & vec_from, const ColumnVector<UInt8>::Container & vec_precision,\n+                      ColumnString::Chars & vec_to, ColumnString::Offsets & result_offsets) const\n+    {\n+        size_t input_rows_count = vec_from.size();\n+        result_offsets.resize(input_rows_count);\n+\n+        WriteBufferFromVector<ColumnString::Chars> buf_to(vec_to);\n+\n+        constexpr size_t max_digits = std::numeric_limits<UInt256>::digits10;\n+\n+        for (size_t i = 0; i < input_rows_count; ++i)\n+        {\n+            if (vec_precision[i] > max_digits)\n+                throw DB::Exception(DB::ErrorCodes::CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER,\n+                                    \"Too many fractional digits requested, shall not be more than {}\", max_digits);\n+            format(vec_from[i], buf_to, vec_precision[i]);\n+            result_offsets[i] = buf_to.count();\n+        }\n+\n+        buf_to.finalize();\n+    }\n+\n+    template <typename FirstArgType>\n+    void constantVector(const FirstArgType & value_from, const ColumnVector<UInt8>::Container & vec_precision,\n+                        ColumnString::Chars & vec_to, ColumnString::Offsets & result_offsets) const\n+    {\n+        size_t input_rows_count = vec_precision.size();\n+        result_offsets.resize(input_rows_count);\n+\n+        WriteBufferFromVector<ColumnString::Chars> buf_to(vec_to);\n+\n+        constexpr size_t max_digits = std::numeric_limits<UInt256>::digits10;\n+\n+        for (size_t i = 0; i < input_rows_count; ++i)\n+        {\n+            if (vec_precision[i] > max_digits)\n+                throw DB::Exception(DB::ErrorCodes::CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER,\n+                                    \"Too many fractional digits requested, shall not be more than {}\", max_digits);\n+            format(value_from, buf_to, vec_precision[i]);\n+            result_offsets[i] = buf_to.count();\n+        }\n+\n+        buf_to.finalize();\n+    }\n+\n+    /// For operations with Decimal\n+    template <typename FirstArgVectorType>\n+    void vectorConstant(const FirstArgVectorType & vec_from, UInt8 precision,\n+                        ColumnString::Chars & vec_to, ColumnString::Offsets & result_offsets, UInt8 from_scale) const\n+    {\n+        /// There are no more than 77 meaning digits (as it is the max length of UInt256). So we can limit it with 77.\n+        constexpr size_t max_digits = std::numeric_limits<UInt256>::digits10;\n+        if (precision > max_digits)\n+            throw DB::Exception(DB::ErrorCodes::CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER,\n+                                \"Too many fractional digits requested for Decimal, must not be more than {}\", max_digits);\n+\n+        WriteBufferFromVector<ColumnString::Chars> buf_to(vec_to);\n+        size_t input_rows_count = vec_from.size();\n+        result_offsets.resize(input_rows_count);\n+\n+        for (size_t i = 0; i < input_rows_count; ++i)\n+        {\n+            writeText(vec_from[i], from_scale, buf_to, true, true, precision);\n+            writeChar(0, buf_to);\n+            result_offsets[i] = buf_to.count();\n+        }\n+        buf_to.finalize();\n+    }\n+\n+    template <typename FirstArgVectorType>\n+    void vectorVector(const FirstArgVectorType & vec_from, const ColumnVector<UInt8>::Container & vec_precision,\n+                      ColumnString::Chars & vec_to, ColumnString::Offsets & result_offsets, UInt8 from_scale) const\n+    {\n+        size_t input_rows_count = vec_from.size();\n+        result_offsets.resize(input_rows_count);\n+\n+        WriteBufferFromVector<ColumnString::Chars> buf_to(vec_to);\n+\n+        constexpr size_t max_digits = std::numeric_limits<UInt256>::digits10;\n+\n+        for (size_t i = 0; i < input_rows_count; ++i)\n+        {\n+            if (vec_precision[i] > max_digits)\n+                throw DB::Exception(DB::ErrorCodes::CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER,\n+                                    \"Too many fractional digits requested for Decimal, must not be more than {}\", max_digits);\n+            writeText(vec_from[i], from_scale, buf_to, true, true, vec_precision[i]);\n+            writeChar(0, buf_to);\n+            result_offsets[i] = buf_to.count();\n+        }\n+        buf_to.finalize();\n+    }\n+\n+    template <typename FirstArgType>\n+    void constantVector(const FirstArgType & value_from, const ColumnVector<UInt8>::Container & vec_precision,\n+                        ColumnString::Chars & vec_to, ColumnString::Offsets & result_offsets, UInt8 from_scale) const\n+    {\n+        size_t input_rows_count = vec_precision.size();\n+        result_offsets.resize(input_rows_count);\n+\n+        WriteBufferFromVector<ColumnString::Chars> buf_to(vec_to);\n+\n+        constexpr size_t max_digits = std::numeric_limits<UInt256>::digits10;\n+\n+        for (size_t i = 0; i < input_rows_count; ++i)\n+        {\n+            if (vec_precision[i] > max_digits)\n+                throw DB::Exception(DB::ErrorCodes::CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER,\n+                                    \"Too many fractional digits requested for Decimal, must not be more than {}\", max_digits);\n+            writeText(value_from, from_scale, buf_to, true, true, vec_precision[i]);\n+            writeChar(0, buf_to);\n+            result_offsets[i] = buf_to.count();\n+        }\n+        buf_to.finalize();\n+    }\n+\n+    template <is_floating_point T>\n+    static void format(T value, DB::WriteBuffer & out, UInt8 precision)\n+    {\n+        /// Maximum of 60 is hard-coded in 'double-conversion/double-conversion.h' for floating point values,\n+        /// Catch this here to give user a more reasonable error.\n+        if (precision > 60)\n+            throw DB::Exception(DB::ErrorCodes::CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER,\n+                                \"Too high precision requested for Float, must not be more than 60, got {}\", Int8(precision));\n+\n+        DB::DoubleConverter<false>::BufferType buffer;\n+        double_conversion::StringBuilder builder{buffer, sizeof(buffer)};\n+\n+        const auto result = DB::DoubleConverter<false>::instance().ToFixed(value, precision, &builder);\n+\n+        if (!result)\n+            throw DB::Exception(DB::ErrorCodes::CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER, \"Error processing number: {}\", value);\n+\n+        out.write(buffer, builder.position());\n+        writeChar(0, out);\n+    }\n+\n+    template <is_integer T>\n+    static void format(T value, DB::WriteBuffer & out, UInt8 precision)\n+    {\n+        /// Fractional part for Integer is just trailing zeros. Let's limit it with 77 (like with Decimals).\n+        constexpr size_t max_digits = std::numeric_limits<UInt256>::digits10;\n+        if (precision > max_digits)\n+            throw DB::Exception(DB::ErrorCodes::CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER,\n+                                \"Too many fractional digits requested, shall not be more than {}\", max_digits);\n+        writeText(value, out);\n+        if (precision > 0) [[likely]]\n+        {\n+            writeChar('.', out);\n+            for (int i = 0; i < precision; ++i)\n+                writeChar('0', out);\n+            writeChar(0, out);\n+        }\n+    }\n+\n+public:\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override\n+    {\n+        switch (arguments[0].type->getTypeId())\n+        {\n+            case TypeIndex::UInt8:      return executeType<UInt8>(arguments);\n+            case TypeIndex::UInt16:     return executeType<UInt16>(arguments);\n+            case TypeIndex::UInt32:     return executeType<UInt32>(arguments);\n+            case TypeIndex::UInt64:     return executeType<UInt64>(arguments);\n+            case TypeIndex::UInt128:    return executeType<UInt128>(arguments);\n+            case TypeIndex::UInt256:    return executeType<UInt256>(arguments);\n+            case TypeIndex::Int8:       return executeType<Int8>(arguments);\n+            case TypeIndex::Int16:      return executeType<Int16>(arguments);\n+            case TypeIndex::Int32:      return executeType<Int32>(arguments);\n+            case TypeIndex::Int64:      return executeType<Int64>(arguments);\n+            case TypeIndex::Int128:     return executeType<Int128>(arguments);\n+            case TypeIndex::Int256:     return executeType<Int256>(arguments);\n+            case TypeIndex::Float32:    return executeType<Float32>(arguments);\n+            case TypeIndex::Float64:    return executeType<Float64>(arguments);\n+            case TypeIndex::Decimal32:  return executeType<Decimal32>(arguments);\n+            case TypeIndex::Decimal64:  return executeType<Decimal64>(arguments);\n+            case TypeIndex::Decimal128: return executeType<Decimal128>(arguments);\n+            case TypeIndex::Decimal256: return executeType<Decimal256>(arguments);\n+            default:\n+                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of argument of function {}\",\n+                                arguments[0].column->getName(), getName());\n+        }\n+    }\n+\n+private:\n+    template <typename T>\n+    ColumnPtr executeType(const ColumnsWithTypeAndName & arguments) const\n+    {\n+        const auto * from_col_const = typeid_cast<const ColumnConst *>(arguments[0].column.get());\n+        const auto * precision_col = checkAndGetColumn<ColumnVector<UInt8>>(arguments[1].column.get());\n+        const auto * precision_col_const = typeid_cast<const ColumnConst *>(arguments[1].column.get());\n+\n+        auto result_col = ColumnString::create();\n+        auto * result_col_string = assert_cast<ColumnString *>(result_col.get());\n+        ColumnString::Chars & result_chars = result_col_string->getChars();\n+        ColumnString::Offsets & result_offsets = result_col_string->getOffsets();\n+\n+        if constexpr (is_decimal<T>)\n+        {\n+            const auto * from_col = checkAndGetColumn<ColumnDecimal<T>>(arguments[0].column.get());\n+            UInt8 from_scale = from_col->getScale();\n+\n+            if (from_col)\n+            {\n+                if (precision_col_const)\n+                    vectorConstant(from_col->getData(), precision_col_const->template getValue<UInt8>(), result_chars, result_offsets, from_scale);\n+                else\n+                    vectorVector(from_col->getData(), precision_col->getData(), result_chars, result_offsets, from_scale);\n+            }\n+            else if (from_col_const)\n+                constantVector(from_col_const->template getValue<T>(), precision_col->getData(), result_chars, result_offsets, from_scale);\n+            else\n+                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function formatDecimal\", arguments[0].column->getName());\n+        }\n+        else\n+        {\n+            const auto * from_col = checkAndGetColumn<ColumnVector<T>>(arguments[0].column.get());\n+            if (from_col)\n+            {\n+                if (precision_col_const)\n+                    vectorConstant(from_col->getData(), precision_col_const->template getValue<UInt8>(), result_chars, result_offsets);\n+                else\n+                    vectorVector(from_col->getData(), precision_col->getData(), result_chars, result_offsets);\n+            }\n+            else if (from_col_const)\n+                constantVector(from_col_const->template getValue<T>(), precision_col->getData(), result_chars, result_offsets);\n+            else\n+                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function formatDecimal\", arguments[0].column->getName());\n+        }\n+\n+        return result_col;\n+    }\n+};\n+\n+}\ndiff --git a/src/IO/WriteHelpers.h b/src/IO/WriteHelpers.h\nindex 1c0b48c53c3e..e08e451e0a7e 100644\n--- a/src/IO/WriteHelpers.h\n+++ b/src/IO/WriteHelpers.h\n@@ -891,26 +891,26 @@ inline void writeText(const IPv4 & x, WriteBuffer & buf) { writeIPv4Text(x, buf)\n inline void writeText(const IPv6 & x, WriteBuffer & buf) { writeIPv6Text(x, buf); }\n \n template <typename T>\n-void writeDecimalFractional(const T & x, UInt32 scale, WriteBuffer & ostr, bool trailing_zeros)\n+void writeDecimalFractional(const T & x, UInt32 scale, WriteBuffer & ostr, bool trailing_zeros,\n+                            bool fixed_fractional_length, UInt32 fractional_length)\n {\n     /// If it's big integer, but the number of digits is small,\n     /// use the implementation for smaller integers for more efficient arithmetic.\n-\n     if constexpr (std::is_same_v<T, Int256>)\n     {\n         if (x <= std::numeric_limits<UInt32>::max())\n         {\n-            writeDecimalFractional(static_cast<UInt32>(x), scale, ostr, trailing_zeros);\n+            writeDecimalFractional(static_cast<UInt32>(x), scale, ostr, trailing_zeros, fixed_fractional_length, fractional_length);\n             return;\n         }\n         else if (x <= std::numeric_limits<UInt64>::max())\n         {\n-            writeDecimalFractional(static_cast<UInt64>(x), scale, ostr, trailing_zeros);\n+            writeDecimalFractional(static_cast<UInt64>(x), scale, ostr, trailing_zeros, fixed_fractional_length, fractional_length);\n             return;\n         }\n         else if (x <= std::numeric_limits<UInt128>::max())\n         {\n-            writeDecimalFractional(static_cast<UInt128>(x), scale, ostr, trailing_zeros);\n+            writeDecimalFractional(static_cast<UInt128>(x), scale, ostr, trailing_zeros, fixed_fractional_length, fractional_length);\n             return;\n         }\n     }\n@@ -918,24 +918,36 @@ void writeDecimalFractional(const T & x, UInt32 scale, WriteBuffer & ostr, bool\n     {\n         if (x <= std::numeric_limits<UInt32>::max())\n         {\n-            writeDecimalFractional(static_cast<UInt32>(x), scale, ostr, trailing_zeros);\n+            writeDecimalFractional(static_cast<UInt32>(x), scale, ostr, trailing_zeros, fixed_fractional_length, fractional_length);\n             return;\n         }\n         else if (x <= std::numeric_limits<UInt64>::max())\n         {\n-            writeDecimalFractional(static_cast<UInt64>(x), scale, ostr, trailing_zeros);\n+            writeDecimalFractional(static_cast<UInt64>(x), scale, ostr, trailing_zeros, fixed_fractional_length, fractional_length);\n             return;\n         }\n     }\n \n     constexpr size_t max_digits = std::numeric_limits<UInt256>::digits10;\n     assert(scale <= max_digits);\n+    assert(fractional_length <= max_digits);\n+\n     char buf[max_digits];\n-    memset(buf, '0', scale);\n+    memset(buf, '0', std::max(scale, fractional_length));\n \n     T value = x;\n     Int32 last_nonzero_pos = 0;\n-    for (Int32 pos = scale - 1; pos >= 0; --pos)\n+\n+    if (fixed_fractional_length && fractional_length < scale)\n+    {\n+        T new_value = value / DecimalUtils::scaleMultiplier<Int256>(scale - fractional_length - 1);\n+        auto round_carry = new_value % 10;\n+        value = new_value / 10;\n+        if (round_carry >= 5)\n+            value += 1;\n+    }\n+\n+    for (Int32 pos = fixed_fractional_length ? std::min(scale - 1, fractional_length - 1) : scale - 1; pos >= 0; --pos)\n     {\n         auto remainder = value % 10;\n         value /= 10;\n@@ -947,11 +959,12 @@ void writeDecimalFractional(const T & x, UInt32 scale, WriteBuffer & ostr, bool\n     }\n \n     writeChar('.', ostr);\n-    ostr.write(buf, trailing_zeros ? scale : last_nonzero_pos + 1);\n+    ostr.write(buf, fixed_fractional_length ? fractional_length : (trailing_zeros ? scale : last_nonzero_pos + 1));\n }\n \n template <typename T>\n-void writeText(Decimal<T> x, UInt32 scale, WriteBuffer & ostr, bool trailing_zeros)\n+void writeText(Decimal<T> x, UInt32 scale, WriteBuffer & ostr, bool trailing_zeros,\n+               bool fixed_fractional_length = false, UInt32 fractional_length = 0)\n {\n     T part = DecimalUtils::getWholePart(x, scale);\n \n@@ -962,7 +975,7 @@ void writeText(Decimal<T> x, UInt32 scale, WriteBuffer & ostr, bool trailing_zer\n \n     writeIntText(part, ostr);\n \n-    if (scale)\n+    if (scale || (fixed_fractional_length && fractional_length > 0))\n     {\n         part = DecimalUtils::getFractionalPart(x, scale);\n         if (part || trailing_zeros)\n@@ -970,7 +983,7 @@ void writeText(Decimal<T> x, UInt32 scale, WriteBuffer & ostr, bool trailing_zer\n             if (part < 0)\n                 part *= T(-1);\n \n-            writeDecimalFractional(part, scale, ostr, trailing_zeros);\n+            writeDecimalFractional(part, scale, ostr, trailing_zeros, fixed_fractional_length, fractional_length);\n         }\n     }\n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02676_to_decimal_string.reference b/tests/queries/0_stateless/02676_to_decimal_string.reference\nnew file mode 100644\nindex 000000000000..4c27ee5b5286\n--- /dev/null\n+++ b/tests/queries/0_stateless/02676_to_decimal_string.reference\n@@ -0,0 +1,21 @@\n+2.00000000000000000000000000000000000000000000000000000000000000000000000000000\n+2.12\n+-2.00000000000000000000000000000000000000000000000000000000000000000000000000000\n+-2.12\n+2.987600000000000033395508580724708735942840576171875000000000\n+2.15\n+-2.987600000000000033395508580724708735942840576171875000000000\n+-2.15\n+64.1230010986\n+64.2340000000\n+-64.1230010986\n+-64.2340000000\n+-32.345\n+32.34500000000000000000000000000000000000000000000000000000000000000000000000000\n+32.46\n+-64.5671232345\n+128.78932312332132985464\n+-128.78932312332132985464\n+128.78932312332132985464000000000000000000000000000000000000000000000000000000000\n+128.7893231233\n+-128.78932312332132985464123123789323123321329854600000000000000000000000000000000\ndiff --git a/tests/queries/0_stateless/02676_to_decimal_string.sql b/tests/queries/0_stateless/02676_to_decimal_string.sql\nnew file mode 100644\nindex 000000000000..563d60c62c7e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02676_to_decimal_string.sql\n@@ -0,0 +1,35 @@\n+-- Regular types\n+SELECT toDecimalString(2, 77);  -- more digits required than exist\n+SELECT toDecimalString(2.123456, 2);  -- rounding\n+SELECT toDecimalString(-2, 77);  -- more digits required than exist\n+SELECT toDecimalString(-2.123456, 2);  -- rounding\n+\n+SELECT toDecimalString(2.9876, 60);  -- more digits required than exist (took 60 as it is float by default)\n+SELECT toDecimalString(2.1456, 2);  -- rounding\n+SELECT toDecimalString(-2.9876, 60);  -- more digits required than exist\n+SELECT toDecimalString(-2.1456, 2);  -- rounding\n+\n+-- Float32 and Float64 tests. No sense to test big float precision -- the result will be a mess anyway.\n+SELECT toDecimalString(64.123::Float32, 10);\n+SELECT toDecimalString(64.234::Float64, 10);\n+SELECT toDecimalString(-64.123::Float32, 10);\n+SELECT toDecimalString(-64.234::Float64, 10);\n+\n+-- Decimals\n+SELECT toDecimalString(-32.345::Decimal32(3), 3);\n+SELECT toDecimalString(32.345::Decimal32(3), 77);  -- more digits required than exist\n+SELECT toDecimalString(32.456::Decimal32(3), 2);  -- rounding\n+SELECT toDecimalString('-64.5671232345'::Decimal64(10), 10);\n+SELECT toDecimalString('128.78932312332132985464'::Decimal128(20), 20);\n+SELECT toDecimalString('-128.78932312332132985464123123'::Decimal128(26), 20);  -- rounding\n+SELECT toDecimalString('128.78932312332132985464'::Decimal128(20), 77);  -- more digits required than exist\n+SELECT toDecimalString('128.789323123321329854641231237893231233213298546'::Decimal256(45), 10);  -- rounding\n+SELECT toDecimalString('-128.789323123321329854641231237893231233213298546'::Decimal256(45), 77);  -- more digits required than exist\n+\n+-- Max number of decimal fractional digits is defined as 77 for Int/UInt/Decimal and 60 for Float.\n+-- These values shall work OK.\n+SELECT toDecimalString('32.32'::Float32, 61); -- {serverError CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER}\n+SELECT toDecimalString('64.64'::Float64, 61); -- {serverError CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER}\n+SELECT toDecimalString('88'::UInt8, 78); -- {serverError CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER}\n+SELECT toDecimalString('646464'::Int256, 78); -- {serverError CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER}\n+SELECT toDecimalString('-128.789323123321329854641231237893231233213298546'::Decimal256(45), 78); -- {serverError CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER}\n",
  "problem_statement": "formatDecimal function\nTakes 2 argument - first is numeric, second is precision and returns a string\r\n\r\n```\r\nSELECT formatDecimal(2,2); -- 2.00\r\nSELECT formatDecimal(2.123456,2); -- 2.12\r\nSELECT formatDecimal(2.1456,2); -- 2.15 -- rounding!\r\nSELECT formatDecimal(64.32::Float64, 2); -- 64.32\r\nSELECT formatDecimal(64.32::Decimal32(2), 2); -- 64.32\r\nSELECT formatDecimal(64.32::Decimal64(2), 2); -- 64.32\r\n``` \r\n\r\nIt should behave similar to [%f in sprintf](https://linux.die.net/man/3/sprintf), see also \r\n\r\nSee also:\r\nhttps://github.com/ClickHouse/ClickHouse/pull/27680#issuecomment-900762221\r\nhttps://github.com/ClickHouse/ClickHouse/issues/30934#issuecomment-955998935\r\n\n",
  "hints_text": "Hi! I'm a student developer looking for an open source feature to work on and was wondering if you could expand on the scope of this helper function. I read through the additional issues and its my understanding it would replace some usage of toString. Could you expand?, as in which files would be most relevant to review to see if the issue is realistic for my skill level.\nYou need to create new function, you can check something like \r\nhttps://github.com/ClickHouse/ClickHouse/blob/master/src/Functions/formatReadableDecimalSize.cpp \r\n\r\nand add tests cases for that - see tests/queries/0_stateless (SQL file & reference file)\r\n\r\nSee some example \r\nhttps://github.com/ClickHouse/ClickHouse/blob/859082c4b7c53a5cf5686aa9d36590efe0ae1876/tests/queries/0_stateless/00232_format_readable_decimal_size.sql\r\n\r\nCheck also general docs about how to build clickhouse\r\n\r\nhttps://clickhouse.com/docs/en/development/build\r\n\r\n\r\nHere you can also find a general intro about how to work with github / how to add tests:\r\n\r\nhttps://clickhouse.com/docs/en/development/adding_test_queries\nAlso loosely related https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_format\nHi @applepie23 you can also watch (a slightly outdated) video guide on how to develop a new feature and create a PR: https://youtu.be/QSYUmLYxzrQ\r\n\r\nConveniently, it shows how to add a new function and how to write a stateless test.\nThank you for the additional information. This might not match my skillset so I will not be taking the issue.\r\n",
  "created_at": "2023-03-21T12:41:41Z",
  "modified_files": [
    "docs/en/sql-reference/functions/type-conversion-functions.md",
    "docs/ru/sql-reference/functions/type-conversion-functions.md",
    "b/src/Functions/FunctionToDecimalString.cpp",
    "b/src/Functions/FunctionToDecimalString.h",
    "src/IO/WriteHelpers.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02676_to_decimal_string.reference",
    "b/tests/queries/0_stateless/02676_to_decimal_string.sql"
  ]
}