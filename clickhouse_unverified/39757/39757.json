{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 39757,
  "instance_id": "ClickHouse__ClickHouse-39757",
  "issue_numbers": [
    "39701"
  ],
  "base_commit": "d259c4fa6c4aedc93f5021e4cf8091a458da98c6",
  "patch": "diff --git a/src/Storages/RocksDB/StorageEmbeddedRocksDB.cpp b/src/Storages/RocksDB/StorageEmbeddedRocksDB.cpp\nindex fd943fbe1c54..2774c52fe7ce 100644\n--- a/src/Storages/RocksDB/StorageEmbeddedRocksDB.cpp\n+++ b/src/Storages/RocksDB/StorageEmbeddedRocksDB.cpp\n@@ -26,6 +26,7 @@\n #include <Interpreters/PreparedSets.h>\n #include <Interpreters/TreeRewriter.h>\n #include <Interpreters/convertFieldToType.h>\n+#include <Interpreters/evaluateConstantExpression.h>\n \n #include <Poco/Logger.h>\n #include <Poco/Util/AbstractConfiguration.h>\n@@ -76,7 +77,7 @@ static RocksDBOptions getOptionsFromConfig(const Poco::Util::AbstractConfigurati\n \n // returns keys may be filter by condition\n static bool traverseASTFilter(\n-    const String & primary_key, const DataTypePtr & primary_key_type, const ASTPtr & elem, const PreparedSets & sets, FieldVectorPtr & res)\n+    const String & primary_key, const DataTypePtr & primary_key_type, const ASTPtr & elem, const PreparedSets & sets, const ContextPtr & context, FieldVectorPtr & res)\n {\n     const auto * function = elem->as<ASTFunction>();\n     if (!function)\n@@ -86,7 +87,7 @@ static bool traverseASTFilter(\n     {\n         // one child has the key filter condition is ok\n         for (const auto & child : function->arguments->children)\n-            if (traverseASTFilter(primary_key, primary_key_type, child, sets, res))\n+            if (traverseASTFilter(primary_key, primary_key_type, child, sets, context, res))\n                 return true;\n         return false;\n     }\n@@ -94,7 +95,7 @@ static bool traverseASTFilter(\n     {\n         // make sure every child has the key filter condition\n         for (const auto & child : function->arguments->children)\n-            if (!traverseASTFilter(primary_key, primary_key_type, child, sets, res))\n+            if (!traverseASTFilter(primary_key, primary_key_type, child, sets, context, res))\n                 return false;\n         return true;\n     }\n@@ -102,7 +103,7 @@ static bool traverseASTFilter(\n     {\n         const auto & args = function->arguments->as<ASTExpressionList &>();\n         const ASTIdentifier * ident;\n-        const IAST * value;\n+        std::shared_ptr<IAST> value;\n \n         if (args.children.size() != 2)\n             return false;\n@@ -115,7 +116,7 @@ static bool traverseASTFilter(\n \n             if (ident->name() != primary_key)\n                 return false;\n-            value = args.children.at(1).get();\n+            value = args.children.at(1);\n \n             PreparedSetKey set_key;\n             if ((value->as<ASTSubquery>() || value->as<ASTIdentifier>()))\n@@ -140,17 +141,18 @@ static bool traverseASTFilter(\n         else\n         {\n             if ((ident = args.children.at(0)->as<ASTIdentifier>()))\n-                value = args.children.at(1).get();\n+                value = args.children.at(1);\n             else if ((ident = args.children.at(1)->as<ASTIdentifier>()))\n-                value = args.children.at(0).get();\n+                value = args.children.at(0);\n             else\n                 return false;\n \n             if (ident->name() != primary_key)\n                 return false;\n \n+            const auto node = evaluateConstantExpressionAsLiteral(value, context);\n             /// function->name == \"equals\"\n-            if (const auto * literal = value->as<ASTLiteral>())\n+            if (const auto * literal = node->as<ASTLiteral>())\n             {\n                 auto converted_field = convertFieldToType(literal->value, *primary_key_type);\n                 if (!converted_field.isNull())\n@@ -166,14 +168,14 @@ static bool traverseASTFilter(\n   * TODO support key like search\n   */\n static std::pair<FieldVectorPtr, bool> getFilterKeys(\n-    const String & primary_key, const DataTypePtr & primary_key_type, const SelectQueryInfo & query_info)\n+    const String & primary_key, const DataTypePtr & primary_key_type, const SelectQueryInfo & query_info, const ContextPtr & context)\n {\n     const auto & select = query_info.query->as<ASTSelectQuery &>();\n     if (!select.where())\n         return {{}, true};\n \n     FieldVectorPtr res = std::make_shared<FieldVector>();\n-    auto matched_keys = traverseASTFilter(primary_key, primary_key_type, select.where(), query_info.sets, res);\n+    auto matched_keys = traverseASTFilter(primary_key, primary_key_type, select.where(), query_info.sets, context, res);\n     return std::make_pair(res, !matched_keys);\n }\n \n@@ -461,7 +463,7 @@ Pipe StorageEmbeddedRocksDB::read(\n         const Names & column_names,\n         const StorageSnapshotPtr & storage_snapshot,\n         SelectQueryInfo & query_info,\n-        ContextPtr /*context*/,\n+        ContextPtr context_,\n         QueryProcessingStage::Enum /*processed_stage*/,\n         size_t max_block_size,\n         unsigned num_streams)\n@@ -473,7 +475,7 @@ Pipe StorageEmbeddedRocksDB::read(\n \n     Block sample_block = storage_snapshot->metadata->getSampleBlock();\n     auto primary_key_data_type = sample_block.getByName(primary_key).type;\n-    std::tie(keys, all_scan) = getFilterKeys(primary_key, primary_key_data_type, query_info);\n+    std::tie(keys, all_scan) = getFilterKeys(primary_key, primary_key_data_type, query_info, context_);\n     if (all_scan)\n     {\n         auto iterator = std::unique_ptr<rocksdb::Iterator>(rocksdb_ptr->NewIterator(rocksdb::ReadOptions()));\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02375_rocksdb_with_filters.reference b/tests/queries/0_stateless/02375_rocksdb_with_filters.reference\nnew file mode 100644\nindex 000000000000..2d6a0e0ad78a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02375_rocksdb_with_filters.reference\n@@ -0,0 +1,8 @@\n+1\n+\"rows_read\":1,\n+2\n+\"rows_read\":2,\n+1\n+\"rows_read\":1,\n+2\n+\"rows_read\":2,\ndiff --git a/tests/queries/0_stateless/02375_rocksdb_with_filters.sh b/tests/queries/0_stateless/02375_rocksdb_with_filters.sh\nnew file mode 100755\nindex 000000000000..1f9922100cb0\n--- /dev/null\n+++ b/tests/queries/0_stateless/02375_rocksdb_with_filters.sh\n@@ -0,0 +1,25 @@\n+#!/usr/bin/env bash\n+# Tags: no-fasttest\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+$CLICKHOUSE_CLIENT --query=\"DROP TABLE IF EXISTS rocksdb_with_filter;\"\n+\n+$CLICKHOUSE_CLIENT --query=\"CREATE TABLE rocksdb_with_filter (key String, value String) ENGINE=EmbeddedRocksDB PRIMARY KEY key;\"\n+$CLICKHOUSE_CLIENT --query=\"INSERT INTO rocksdb_with_filter (*) SELECT n.number, n.number*10 FROM numbers(10000) n;\"\n+\n+$CLICKHOUSE_CLIENT --query \"SELECT count() FROM rocksdb_with_filter WHERE key = '5000'\"\n+$CLICKHOUSE_CLIENT --query \"SELECT value FROM rocksdb_with_filter WHERE key = '5000' FORMAT JSON\" | grep \"rows_read\" | tr -d \"[:blank:]\"\n+\n+$CLICKHOUSE_CLIENT --query \"SELECT count() FROM rocksdb_with_filter WHERE key = '5000' OR key = '6000'\"\n+$CLICKHOUSE_CLIENT --query \"SELECT value FROM rocksdb_with_filter WHERE key = '5000' OR key = '6000' FORMAT JSON\" | grep \"rows_read\" | tr -d \"[:blank:]\"\n+\n+$CLICKHOUSE_CLIENT \"--param_key=5000\" --query \"SELECT count() FROM rocksdb_with_filter WHERE key = {key:String}\"\n+$CLICKHOUSE_CLIENT \"--param_key=5000\" --query \"SELECT value FROM rocksdb_with_filter WHERE key = {key:String} FORMAT JSON\" | grep \"rows_read\" | tr -d \"[:blank:]\"\n+\n+$CLICKHOUSE_CLIENT --query \"SELECT count() FROM rocksdb_with_filter WHERE key IN ('5000', '6000')\"\n+$CLICKHOUSE_CLIENT --query \"SELECT value FROM rocksdb_with_filter WHERE key IN ('5000', '6000') FORMAT JSON\" | grep \"rows_read\" | tr -d \"[:blank:]\"\n+\n+$CLICKHOUSE_CLIENT --query=\"DROP TABLE rocksdb_with_filter;\"\n",
  "problem_statement": "EmbeddedRocksDB does full scan when using `params`\n**Describe the situation**\r\n\r\nWhen using parameters (`param`) in the CLI or with the HTTP interface, the EmbeddedRocksDB engine will scan through all the data causing significant slowdown, instead of doing a proper RocksDB key lookup.\r\n\r\n**How to reproduce**\r\n\r\nsetup.sql:\r\n```sql\r\nCREATE TABLE test1 (key String, value String) ENGINE=EmbeddedRocksDB PRIMARY KEY key;\r\n\r\n-- do this a few times to exacerbate the issue\r\nINSERT INTO test1 (*) SELECT n.number, randomString(10000) FROM numbers(10000) n;\r\nINSERT INTO test1 (*) SELECT n.number, randomString(10000) FROM numbers(10000) n;\r\nINSERT INTO test1 (*) SELECT n.number, randomString(10000) FROM numbers(10000) n;\r\n```\r\n\r\n```\r\n\u276f clickhouse client \"--param_key=5000\" --query \"SELECT value FROM test1 WHERE key = {key:String} FORMAT JSON\" | jq \".statistics\"\r\n{\r\n  \"elapsed\": 0.20763,\r\n  \"rows_read\": 10000,\r\n  \"bytes_read\": 100218890\r\n}\r\n\r\n\u276f clickhouse client --query \"SELECT value FROM test1 WHERE key = '5000' FORMAT JSON\" | jq \".statistics\"\r\n{\r\n  \"elapsed\": 0.000519,\r\n  \"rows_read\": 1,\r\n  \"bytes_read\": 10022\r\n}\r\n```\r\n\r\n**Version**\r\n22.6.1.231\r\n\r\n\n",
  "hints_text": "",
  "created_at": "2022-07-31T10:47:29Z"
}