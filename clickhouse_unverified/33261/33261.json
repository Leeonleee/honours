{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 33261,
  "instance_id": "ClickHouse__ClickHouse-33261",
  "issue_numbers": [
    "33251"
  ],
  "base_commit": "f18223f51ef4e1f5ae1a0f1259c28b924d626b6d",
  "patch": "diff --git a/src/Databases/DatabaseDictionary.cpp b/src/Databases/DatabaseDictionary.cpp\nindex db7da95fb27a..82766c1e384a 100644\n--- a/src/Databases/DatabaseDictionary.cpp\n+++ b/src/Databases/DatabaseDictionary.cpp\n@@ -29,10 +29,13 @@ namespace\n                 return nullptr;\n \n             DictionaryStructure dictionary_structure = ExternalDictionariesLoader::getDictionaryStructure(*load_result.config);\n+            auto comment = load_result.config->config->getString(\"dictionary.comment\", \"\");\n+\n             return StorageDictionary::create(\n                 StorageID(database_name, load_result.name),\n                 load_result.name,\n                 dictionary_structure,\n+                comment,\n                 StorageDictionary::Location::DictionaryDatabase,\n                 context);\n         }\ndiff --git a/src/Databases/DatabasesCommon.cpp b/src/Databases/DatabasesCommon.cpp\nindex ffb39f5b113f..1c3f417b4317 100644\n--- a/src/Databases/DatabasesCommon.cpp\n+++ b/src/Databases/DatabasesCommon.cpp\n@@ -30,27 +30,33 @@ void applyMetadataChangesToCreateQuery(const ASTPtr & query, const StorageInMemo\n     auto & ast_create_query = query->as<ASTCreateQuery &>();\n \n     bool has_structure = ast_create_query.columns_list && ast_create_query.columns_list->columns;\n+\n     if (ast_create_query.as_table_function && !has_structure)\n         throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot alter table {} because it was created AS table function\"\n                                                      \" and doesn't have structure in metadata\", backQuote(ast_create_query.getTable()));\n \n-    assert(has_structure);\n-    ASTPtr new_columns = InterpreterCreateQuery::formatColumns(metadata.columns);\n-    ASTPtr new_indices = InterpreterCreateQuery::formatIndices(metadata.secondary_indices);\n-    ASTPtr new_constraints = InterpreterCreateQuery::formatConstraints(metadata.constraints);\n-    ASTPtr new_projections = InterpreterCreateQuery::formatProjections(metadata.projections);\n+    if (!has_structure && !ast_create_query.is_dictionary)\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cannot alter table {} metadata doesn't have structure\", backQuote(ast_create_query.getTable()));\n \n-    ast_create_query.columns_list->replace(ast_create_query.columns_list->columns, new_columns);\n-    ast_create_query.columns_list->setOrReplace(ast_create_query.columns_list->indices, new_indices);\n-    ast_create_query.columns_list->setOrReplace(ast_create_query.columns_list->constraints, new_constraints);\n-    ast_create_query.columns_list->setOrReplace(ast_create_query.columns_list->projections, new_projections);\n+    if (!ast_create_query.is_dictionary)\n+    {\n+        ASTPtr new_columns = InterpreterCreateQuery::formatColumns(metadata.columns);\n+        ASTPtr new_indices = InterpreterCreateQuery::formatIndices(metadata.secondary_indices);\n+        ASTPtr new_constraints = InterpreterCreateQuery::formatConstraints(metadata.constraints);\n+        ASTPtr new_projections = InterpreterCreateQuery::formatProjections(metadata.projections);\n+\n+        ast_create_query.columns_list->replace(ast_create_query.columns_list->columns, new_columns);\n+        ast_create_query.columns_list->setOrReplace(ast_create_query.columns_list->indices, new_indices);\n+        ast_create_query.columns_list->setOrReplace(ast_create_query.columns_list->constraints, new_constraints);\n+        ast_create_query.columns_list->setOrReplace(ast_create_query.columns_list->projections, new_projections);\n+    }\n \n     if (metadata.select.select_query)\n     {\n         query->replace(ast_create_query.select, metadata.select.select_query);\n     }\n \n-    /// MaterializedView is one type of CREATE query without storage.\n+    /// MaterializedView, Dictionary are types of CREATE query without storage.\n     if (ast_create_query.storage)\n     {\n         ASTStorage & storage_ast = *ast_create_query.storage;\ndiff --git a/src/Interpreters/InterpreterAlterQuery.cpp b/src/Interpreters/InterpreterAlterQuery.cpp\nindex 5f7c54e427fd..2475d437acbe 100644\n--- a/src/Interpreters/InterpreterAlterQuery.cpp\n+++ b/src/Interpreters/InterpreterAlterQuery.cpp\n@@ -48,10 +48,15 @@ BlockIO InterpreterAlterQuery::execute()\n     FunctionNameNormalizer().visit(query_ptr.get());\n     const auto & alter = query_ptr->as<ASTAlterQuery &>();\n     if (alter.alter_object == ASTAlterQuery::AlterObjectType::DATABASE)\n+    {\n         return executeToDatabase(alter);\n+    }\n     else if (alter.alter_object == ASTAlterQuery::AlterObjectType::TABLE\n             || alter.alter_object == ASTAlterQuery::AlterObjectType::LIVE_VIEW)\n+    {\n         return executeToTable(alter);\n+    }\n+\n     throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unknown alter object type\");\n }\n \ndiff --git a/src/Storages/IStorage.cpp b/src/Storages/IStorage.cpp\nindex 021335fea1ff..a923258b111c 100644\n--- a/src/Storages/IStorage.cpp\n+++ b/src/Storages/IStorage.cpp\n@@ -139,7 +139,6 @@ void IStorage::alter(const AlterCommands & params, ContextPtr context, AlterLock\n     setInMemoryMetadata(new_metadata);\n }\n \n-\n void IStorage::checkAlterIsPossible(const AlterCommands & commands, ContextPtr /* context */) const\n {\n     for (const auto & command : commands)\ndiff --git a/src/Storages/StorageDictionary.cpp b/src/Storages/StorageDictionary.cpp\nindex f6b330fe3dfa..da8c5f115b26 100644\n--- a/src/Storages/StorageDictionary.cpp\n+++ b/src/Storages/StorageDictionary.cpp\n@@ -11,6 +11,7 @@\n #include <QueryPipeline/Pipe.h>\n #include <IO/Operators.h>\n #include <Dictionaries/getDictionaryConfigurationFromAST.h>\n+#include <Storages/AlterCommands.h>\n \n \n namespace DB\n@@ -21,6 +22,7 @@ namespace ErrorCodes\n     extern const int THERE_IS_NO_COLUMN;\n     extern const int CANNOT_DETACH_DICTIONARY_AS_TABLE;\n     extern const int DICTIONARY_ALREADY_EXISTS;\n+    extern const int NOT_IMPLEMENTED;\n }\n \n namespace\n@@ -111,10 +113,11 @@ StorageDictionary::StorageDictionary(\n     const StorageID & table_id_,\n     const String & dictionary_name_,\n     const DictionaryStructure & dictionary_structure_,\n+    const String & comment,\n     Location location_,\n     ContextPtr context_)\n     : StorageDictionary(\n-        table_id_, dictionary_name_, ColumnsDescription{getNamesAndTypes(dictionary_structure_)}, String{}, location_, context_)\n+        table_id_, dictionary_name_, ColumnsDescription{getNamesAndTypes(dictionary_structure_)}, comment, location_, context_)\n {\n }\n \n@@ -126,6 +129,7 @@ StorageDictionary::StorageDictionary(\n         table_id,\n         table_id.getFullNameNotQuoted(),\n         context_->getExternalDictionariesLoader().getDictionaryStructure(*dictionary_configuration),\n+        dictionary_configuration->getString(\"dictionary.comment\", \"\"),\n         Location::SameDatabaseAndNameAsDictionary,\n         context_)\n {\n@@ -230,7 +234,7 @@ void StorageDictionary::renameInMemory(const StorageID & new_table_id)\n         if (move_to_atomic)\n             configuration->setString(\"dictionary.uuid\", toString(new_table_id.uuid));\n         else if (move_to_ordinary)\n-                configuration->remove(\"dictionary.uuid\");\n+            configuration->remove(\"dictionary.uuid\");\n     }\n \n     /// Dictionary is moving between databases of different engines or is renaming inside Ordinary database\n@@ -260,6 +264,40 @@ void StorageDictionary::renameInMemory(const StorageID & new_table_id)\n     }\n }\n \n+void StorageDictionary::checkAlterIsPossible(const AlterCommands & commands, ContextPtr /* context */) const\n+{\n+    for (const auto & command : commands)\n+    {\n+        if (location == Location::DictionaryDatabase || command.type != AlterCommand::COMMENT_TABLE)\n+            throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Alter of type '{}' is not supported by storage {}\",\n+                command.type, getName());\n+    }\n+}\n+\n+void StorageDictionary::alter(const AlterCommands & params, ContextPtr alter_context, AlterLockHolder & lock_holder)\n+{\n+    IStorage::alter(params, alter_context, lock_holder);\n+\n+    if (location == Location::Custom)\n+        return;\n+\n+    auto new_comment = getInMemoryMetadataPtr()->comment;\n+\n+    auto storage_id = getStorageID();\n+    const auto & external_dictionaries_loader = getContext()->getExternalDictionariesLoader();\n+    auto result = external_dictionaries_loader.getLoadResult(storage_id.getInternalDictionaryName());\n+\n+    if (result.object)\n+    {\n+        auto dictionary = std::static_pointer_cast<const IDictionary>(result.object);\n+        auto * dictionary_non_const = const_cast<IDictionary *>(dictionary.get());\n+        dictionary_non_const->setDictionaryComment(new_comment);\n+    }\n+\n+    std::lock_guard<std::mutex> lock(dictionary_config_mutex);\n+    configuration->setString(\"dictionary.comment\", std::move(new_comment));\n+}\n+\n void registerStorageDictionary(StorageFactory & factory)\n {\n     factory.registerStorage(\"Dictionary\", [](const StorageFactory::Arguments & args)\ndiff --git a/src/Storages/StorageDictionary.h b/src/Storages/StorageDictionary.h\nindex 7d0af8c0ee32..855d02b0947f 100644\n--- a/src/Storages/StorageDictionary.h\n+++ b/src/Storages/StorageDictionary.h\n@@ -42,6 +42,10 @@ class StorageDictionary final : public shared_ptr_helper<StorageDictionary>, pub\n \n     void renameInMemory(const StorageID & new_table_id) override;\n \n+    void checkAlterIsPossible(const AlterCommands & commands, ContextPtr /* context */) const override;\n+\n+    void alter(const AlterCommands & params, ContextPtr alter_context, AlterLockHolder &) override;\n+\n     Poco::Timestamp getUpdateTime() const;\n     LoadablesConfigurationPtr getConfiguration() const;\n \n@@ -89,6 +93,7 @@ class StorageDictionary final : public shared_ptr_helper<StorageDictionary>, pub\n         const StorageID & table_id_,\n         const String & dictionary_name_,\n         const DictionaryStructure & dictionary_structure,\n+        const String & comment,\n         Location location_,\n         ContextPtr context_);\n \ndiff --git a/src/Storages/System/StorageSystemDictionaries.cpp b/src/Storages/System/StorageSystemDictionaries.cpp\nindex d8f92d380815..c0d7d8cc4edb 100644\n--- a/src/Storages/System/StorageSystemDictionaries.cpp\n+++ b/src/Storages/System/StorageSystemDictionaries.cpp\n@@ -142,7 +142,9 @@ void StorageSystemDictionaries::fillData(MutableColumns & res_columns, ContextPt\n             res_columns[i++]->insertDefault();\n \n         if (dict_ptr)\n+        {\n             res_columns[i++]->insert(dict_ptr->getDictionaryComment());\n+        }\n         else\n         {\n             if (load_result.config && load_result.config->config->has(\"dictionary.comment\"))\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02155_dictionary_comment.reference b/tests/queries/0_stateless/02155_dictionary_comment.reference\nnew file mode 100644\nindex 000000000000..69b871a6925a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02155_dictionary_comment.reference\n@@ -0,0 +1,11 @@\n+02155_test_dictionary\t\n+02155_test_dictionary\t02155_test_dictionary_comment_0\n+02155_test_dictionary\t02155_test_dictionary_comment_0\n+0\tValue\n+02155_test_dictionary\t02155_test_dictionary_comment_0\n+02155_test_dictionary\t02155_test_dictionary_comment_0\n+02155_test_dictionary\t02155_test_dictionary_comment_1\n+02155_test_dictionary\t02155_test_dictionary_comment_1\n+0\tValue\n+02155_test_dictionary_view\t02155_test_dictionary_view_comment_0\n+02155_test_dictionary_view\t02155_test_dictionary_view_comment_0\ndiff --git a/tests/queries/0_stateless/02155_dictionary_comment.sql b/tests/queries/0_stateless/02155_dictionary_comment.sql\nnew file mode 100644\nindex 000000000000..e31d9d283664\n--- /dev/null\n+++ b/tests/queries/0_stateless/02155_dictionary_comment.sql\n@@ -0,0 +1,53 @@\n+DROP TABLE IF EXISTS 02155_test_table;\n+CREATE TABLE 02155_test_table\n+(\n+    id UInt64,\n+    value String\n+) ENGINE=TinyLog;\n+\n+INSERT INTO 02155_test_table VALUES (0, 'Value');\n+\n+DROP DICTIONARY IF EXISTS 02155_test_dictionary;\n+CREATE DICTIONARY 02155_test_dictionary\n+(\n+    id UInt64,\n+    value String\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(TABLE '02155_test_table'))\n+LAYOUT(DIRECT());\n+\n+SELECT name, comment FROM system.dictionaries WHERE name == '02155_test_dictionary' AND database == currentDatabase();\n+\n+ALTER TABLE 02155_test_dictionary COMMENT COLUMN value 'value_column'; --{serverError 48}\n+\n+ALTER TABLE 02155_test_dictionary MODIFY COMMENT '02155_test_dictionary_comment_0';\n+SELECT name, comment FROM system.dictionaries WHERE name == '02155_test_dictionary' AND database == currentDatabase();\n+SELECT name, comment FROM system.tables WHERE name == '02155_test_dictionary' AND database == currentDatabase();\n+\n+SELECT * FROM 02155_test_dictionary;\n+SELECT name, comment FROM system.dictionaries WHERE name == '02155_test_dictionary' AND database == currentDatabase();\n+SELECT name, comment FROM system.tables WHERE name == '02155_test_dictionary' AND database == currentDatabase();\n+\n+ALTER TABLE 02155_test_dictionary MODIFY COMMENT '02155_test_dictionary_comment_1';\n+SELECT name, comment FROM system.dictionaries WHERE name == '02155_test_dictionary' AND database == currentDatabase();\n+SELECT name, comment FROM system.tables WHERE name == '02155_test_dictionary' AND database == currentDatabase();\n+\n+DROP TABLE IF EXISTS 02155_test_dictionary_view;\n+CREATE TABLE 02155_test_dictionary_view\n+(\n+    id UInt64,\n+    value String\n+) ENGINE=Dictionary(concat(currentDatabase(), '.02155_test_dictionary'));\n+\n+SELECT * FROM 02155_test_dictionary_view;\n+\n+ALTER TABLE 02155_test_dictionary_view COMMENT COLUMN value 'value_column'; --{serverError 48}\n+\n+ALTER TABLE 02155_test_dictionary_view MODIFY COMMENT '02155_test_dictionary_view_comment_0';\n+SELECT name, comment FROM system.tables WHERE name == '02155_test_dictionary_view' AND database == currentDatabase();\n+SELECT name, comment FROM system.tables WHERE name == '02155_test_dictionary_view' AND database == currentDatabase();\n+\n+DROP TABLE 02155_test_dictionary_view;\n+DROP TABLE 02155_test_table;\n+DROP DICTIONARY 02155_test_dictionary;\n",
  "problem_statement": "Received signal Segmentation fault (11) when ALTER TABLE for dictionary\nClickhouse server drops when I send ALTER TABLE request with COMMENT COLUMN for DICTIONARY.\r\n\r\nI know the request is incorrect. But instead of returning the error, the server simply stops working.\r\n\r\nServer version: (version 21.12.2.17 (official build))\r\n\r\nReproduce:\r\n\r\n1. Create any dictionary. Example:\r\n\r\n```sql\r\nCREATE DICTIONARY stores (\r\n    storeId UInt64,\r\n    storeName String,\r\n    shopId UInt32,\r\n    status UInt8,\r\n    lat Float32,\r\n    lon Float32,\r\n    address String,\r\n    storeCountry String,\r\n    storeRegion String,\r\n    storeCity String,\r\n    city_id UInt32,\r\n    email String,\r\n    storeParams String\r\n)\r\nPRIMARY KEY storeId\r\nSOURCE(MYSQL(\r\n    port 3306\r\n    user 'user'\r\n    password 'pass'\r\n    replica(host '10.20.20.12' priority 1)\r\n    db 'db'\r\n    table 'stores'\r\n))\r\nLAYOUT(FLAT())\r\nLIFETIME(300);\r\n```\r\n\r\n2. Send ALTER TABLE for this dictionary. Example:\r\n\r\n```sql\r\nALTER TABLE stores COMMENT COLUMN storeId 'any comment';\r\n```\r\n\r\n```\r\n2021.12.28 09:17:05.578111 [ 251 ] {} <Fatal> BaseDaemon: ########################################\r\n2021.12.28 09:17:05.582661 [ 251 ] {} <Fatal> BaseDaemon: (version 21.12.2.17 (official build), build id: 29EDA0CC01FD10E7) (from thread 96) (query_id: 780d68be-8e65-43c5-b454-0af77e7264a8) Received signal Segmentation fault (11)\r\n2021.12.28 09:17:05.591963 [ 251 ] {} <Fatal> BaseDaemon: Address: 0x18 Access: read. Address not mapped to object.\r\n2021.12.28 09:17:05.599694 [ 251 ] {} <Fatal> BaseDaemon: Stack trace: 0x12b47423 0x12b46d9b 0x12b251ca 0x1362c344 0x12f480b7 0x12f45d52 0x134cff90 0x134d341c 0x13d3426e 0x13d389c7 0x13f9b38a 0x16ee23af 0x16ee4801 0x16ff3589 0x16ff0c80 0x7f14c5f93609 0x7f14c5eba293\r\n2021.12.28 09:17:05.607719 [ 251 ] {} <Fatal> BaseDaemon: 2. void DB::IAST::replace<DB::ASTExpressionList>(DB::ASTExpressionList*&, std::__1::shared_ptr<DB::IAST> const&) @ 0x12b47423 in /usr/bin/clickhouse\r\n2021.12.28 09:17:05.614280 [ 251 ] {} <Fatal> BaseDaemon: 3. DB::applyMetadataChangesToCreateQuery(std::__1::shared_ptr<DB::IAST> const&, DB::StorageInMemoryMetadata const&) @ 0x12b46d9b in /usr/bin/clickhouse\r\n2021.12.28 09:17:05.620176 [ 251 ] {} <Fatal> BaseDaemon: 4. DB::DatabaseOrdinary::alterTable(std::__1::shared_ptr<DB::Context const>, DB::StorageID const&, DB::StorageInMemoryMetadata const&) @ 0x12b251ca in /usr/bin/clickhouse\r\n2021.12.28 09:17:05.629057 [ 251 ] {} <Fatal> BaseDaemon: 5. DB::IStorage::alter(DB::AlterCommands const&, std::__1::shared_ptr<DB::Context const>, std::__1::unique_lock<std::__1::timed_mutex>&) @ 0x1362c344 in /usr/bin/clickhouse\r\n2021.12.28 09:17:05.634461 [ 251 ] {} <Fatal> BaseDaemon: 6. DB::InterpreterAlterQuery::executeToTable(DB::ASTAlterQuery const&) @ 0x12f480b7 in /usr/bin/clickhouse\r\n2021.12.28 09:17:05.644173 [ 251 ] {} <Fatal> BaseDaemon: 7. DB::InterpreterAlterQuery::execute() @ 0x12f45d52 in /usr/bin/clickhouse\r\n2021.12.28 09:17:05.651961 [ 251 ] {} <Fatal> BaseDaemon: 8. ? @ 0x134cff90 in /usr/bin/clickhouse\r\n2021.12.28 09:17:05.661756 [ 251 ] {} <Fatal> BaseDaemon: 9. DB::executeQuery(DB::ReadBuffer&, DB::WriteBuffer&, bool, std::__1::shared_ptr<DB::Context>, std::__1::function<void (std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&)>, std::__1::optional<DB::FormatSettings> const&) @ 0x134d341c in /usr/bin/clickhouse\r\n2021.12.28 09:17:05.673192 [ 251 ] {} <Fatal> BaseDaemon: 10. DB::HTTPHandler::processQuery(DB::HTTPServerRequest&, DB::HTMLForm&, DB::HTTPServerResponse&, DB::HTTPHandler::Output&, std::__1::optional<DB::CurrentThread::QueryScope>&) @ 0x13d3426e in /usr/bin/clickhouse\r\n2021.12.28 09:17:05.682933 [ 251 ] {} <Fatal> BaseDaemon: 11. DB::HTTPHandler::handleRequest(DB::HTTPServerRequest&, DB::HTTPServerResponse&) @ 0x13d389c7 in /usr/bin/clickhouse\r\n```\r\nFull logs:  \r\n[clickhouse-server.log](https://github.com/ClickHouse/ClickHouse/files/7784075/clickhouse-server.log)\r\n[clickhouse-server.err.log](https://github.com/ClickHouse/ClickHouse/files/7784077/clickhouse-server.err.log)\r\n\r\n\n",
  "hints_text": "",
  "created_at": "2021-12-28T16:43:31Z",
  "modified_files": [
    "src/Databases/DatabaseDictionary.cpp",
    "src/Databases/DatabasesCommon.cpp",
    "src/Interpreters/InterpreterAlterQuery.cpp",
    "src/Storages/IStorage.cpp",
    "src/Storages/StorageDictionary.cpp",
    "src/Storages/StorageDictionary.h",
    "src/Storages/System/StorageSystemDictionaries.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02155_dictionary_comment.reference",
    "b/tests/queries/0_stateless/02155_dictionary_comment.sql"
  ]
}