diff --git a/src/Functions/bitShiftLeft.cpp b/src/Functions/bitShiftLeft.cpp
index c366a1ecb44b..d561430d51f7 100644
--- a/src/Functions/bitShiftLeft.cpp
+++ b/src/Functions/bitShiftLeft.cpp
@@ -5,6 +5,7 @@ namespace DB
 {
 namespace ErrorCodes
 {
+    extern const int ARGUMENT_OUT_OF_BOUND;
     extern const int NOT_IMPLEMENTED;
     extern const int LOGICAL_ERROR;
 }
@@ -24,6 +25,8 @@ struct BitShiftLeftImpl
     {
         if constexpr (is_big_int_v<B>)
             throw Exception(ErrorCodes::NOT_IMPLEMENTED, "BitShiftLeft is not implemented for big integers as second argument");
+        else if (b < 0 || static_cast<UInt256>(b) > 8 * sizeof(A))
+            throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, "The number of shift positions needs to be a non-negative value and less or equal to the bit width of the value to shift");
         else if constexpr (is_big_int_v<A>)
             return static_cast<Result>(a) << static_cast<UInt32>(b);
         else
@@ -37,9 +40,12 @@ struct BitShiftLeftImpl
             throw Exception(ErrorCodes::NOT_IMPLEMENTED, "BitShiftLeft is not implemented for big integers as second argument");
         else
         {
-            UInt8 word_size = 8;
-            /// To prevent overflow
-            if (static_cast<double>(b) >= (static_cast<double>(end - pos) * word_size) || b < 0)
+            const UInt8 word_size = 8 * sizeof(*pos);
+            size_t n = end - pos;
+            const UInt128 bit_limit = static_cast<UInt128>(word_size) * n;
+            if (b < 0 || static_cast<decltype(bit_limit)>(b) > bit_limit)
+                throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, "The number of shift positions needs to be a non-negative value and less or equal to the bit width of the value to shift");
+            else if (b == bit_limit)
             {
                 // insert default value
                 out_vec.push_back(0);
@@ -102,10 +108,12 @@ struct BitShiftLeftImpl
             throw Exception(ErrorCodes::NOT_IMPLEMENTED, "BitShiftLeft is not implemented for big integers as second argument");
         else
         {
-            UInt8 word_size = 8;
+            const UInt8 word_size = 8;
             size_t n = end - pos;
-            /// To prevent overflow
-            if (static_cast<double>(b) >= (static_cast<double>(n) * word_size) || b < 0)
+            const UInt128 bit_limit = static_cast<UInt128>(word_size) * n;
+            if (b < 0 || static_cast<decltype(bit_limit)>(b) > bit_limit)
+                throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, "The number of shift positions needs to be a non-negative value and less or equal to the bit width of the value to shift");
+            else if (b == bit_limit)
             {
                 // insert default value
                 out_vec.resize_fill(out_vec.size() + n);
diff --git a/src/Functions/bitShiftRight.cpp b/src/Functions/bitShiftRight.cpp
index 1c37cd3bf4c5..05b8581c792d 100644
--- a/src/Functions/bitShiftRight.cpp
+++ b/src/Functions/bitShiftRight.cpp
@@ -6,6 +6,7 @@ namespace DB
 {
 namespace ErrorCodes
 {
+    extern const int ARGUMENT_OUT_OF_BOUND;
     extern const int NOT_IMPLEMENTED;
     extern const int LOGICAL_ERROR;
 }
@@ -25,6 +26,8 @@ struct BitShiftRightImpl
     {
         if constexpr (is_big_int_v<B>)
             throw Exception(ErrorCodes::NOT_IMPLEMENTED, "BitShiftRight is not implemented for big integers as second argument");
+        else if (b < 0 || static_cast<UInt256>(b) > 8 * sizeof(A))
+            throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, "The number of shift positions needs to be a non-negative value and less or equal to the bit width of the value to shift");
         else if constexpr (is_big_int_v<A>)
             return static_cast<Result>(a) >> static_cast<UInt32>(b);
         else
@@ -53,9 +56,12 @@ struct BitShiftRightImpl
             throw Exception(ErrorCodes::NOT_IMPLEMENTED, "BitShiftRight is not implemented for big integers as second argument");
         else
         {
-            UInt8 word_size = 8;
-            /// To prevent overflow
-            if (static_cast<double>(b) >= (static_cast<double>(end - pos) * word_size) || b < 0)
+            const UInt8 word_size = 8;
+            size_t n = end - pos;
+            const UInt128 bit_limit = static_cast<UInt128>(word_size) * n;
+            if (b < 0 || static_cast<decltype(bit_limit)>(b) > bit_limit)
+                throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, "The number of shift positions needs to be a non-negative value and less or equal to the bit width of the value to shift");
+            else if (b == bit_limit)
             {
                 /// insert default value
                 out_vec.push_back(0);
@@ -90,10 +96,12 @@ struct BitShiftRightImpl
             throw Exception(ErrorCodes::NOT_IMPLEMENTED, "BitShiftRight is not implemented for big integers as second argument");
         else
         {
-            UInt8 word_size = 8;
+            const UInt8 word_size = 8;
             size_t n = end - pos;
-            /// To prevent overflow
-            if (static_cast<double>(b) >= (static_cast<double>(n) * word_size) || b < 0)
+            const UInt128 bit_limit = static_cast<UInt128>(word_size) * n;
+            if (b < 0 || static_cast<decltype(bit_limit)>(b) > bit_limit)
+                throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, "The number of shift positions needs to be a non-negative value and less or equal to the bit width of the value to shift");
+            else if (b == bit_limit)
             {
                 // insert default value
                 out_vec.resize_fill(out_vec.size() + n);
