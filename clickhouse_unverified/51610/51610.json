{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 51610,
  "instance_id": "ClickHouse__ClickHouse-51610",
  "issue_numbers": [
    "51507"
  ],
  "base_commit": "8b4fda9672d1ef36e3e2c66794eff4f8da690038",
  "patch": "diff --git a/src/Processors/QueryPlan/Optimizations/Optimizations.h b/src/Processors/QueryPlan/Optimizations/Optimizations.h\nindex 2b934ec440bc..bc47413cbb50 100644\n--- a/src/Processors/QueryPlan/Optimizations/Optimizations.h\n+++ b/src/Processors/QueryPlan/Optimizations/Optimizations.h\n@@ -14,6 +14,9 @@ namespace QueryPlanOptimizations\n void optimizeTreeFirstPass(const QueryPlanOptimizationSettings & settings, QueryPlan::Node & root, QueryPlan::Nodes & nodes);\n /// Second pass is used to apply read-in-order and attach a predicate to PK.\n void optimizeTreeSecondPass(const QueryPlanOptimizationSettings & optimization_settings, QueryPlan::Node & root, QueryPlan::Nodes & nodes);\n+/// Third pass is used to apply filters such as key conditions and skip indexes to the storages that support them.\n+/// After that it add CreateSetsStep for the subqueries that has not be used in the filters.\n+void optimizeTreeThirdPass(QueryPlan::Node & root, QueryPlan::Nodes & nodes);\n \n /// Optimization (first pass) is a function applied to QueryPlan::Node.\n /// It can read and update subtree of specified node.\ndiff --git a/src/Processors/QueryPlan/Optimizations/optimizePrimaryKeyCondition.cpp b/src/Processors/QueryPlan/Optimizations/optimizePrimaryKeyCondition.cpp\nindex 5ef786ff9751..e98386a6ee9f 100644\n--- a/src/Processors/QueryPlan/Optimizations/optimizePrimaryKeyCondition.cpp\n+++ b/src/Processors/QueryPlan/Optimizations/optimizePrimaryKeyCondition.cpp\n@@ -28,8 +28,6 @@ void optimizePrimaryKeyCondition(const Stack & stack)\n         else\n             break;\n     }\n-\n-    source_step_with_filter->onAddFilterFinish();\n }\n \n }\ndiff --git a/src/Processors/QueryPlan/Optimizations/optimizeTree.cpp b/src/Processors/QueryPlan/Optimizations/optimizeTree.cpp\nindex d620170e29c2..e788918703e7 100644\n--- a/src/Processors/QueryPlan/Optimizations/optimizeTree.cpp\n+++ b/src/Processors/QueryPlan/Optimizations/optimizeTree.cpp\n@@ -167,7 +167,6 @@ void optimizeTreeSecondPass(const QueryPlanOptimizationSettings & optimization_s\n         optimizePrewhere(stack, nodes);\n         optimizePrimaryKeyCondition(stack);\n         enableMemoryBoundMerging(*stack.back().node, nodes);\n-        addPlansForSets(*stack.back().node, nodes);\n \n         stack.pop_back();\n     }\n@@ -178,5 +177,35 @@ void optimizeTreeSecondPass(const QueryPlanOptimizationSettings & optimization_s\n             \"No projection is used when optimize_use_projections = 1 and force_optimize_projection = 1\");\n }\n \n+void optimizeTreeThirdPass(QueryPlan::Node & root, QueryPlan::Nodes & nodes)\n+{\n+    Stack stack;\n+    stack.push_back({.node = &root});\n+\n+    while (!stack.empty())\n+    {\n+        /// NOTE: frame cannot be safely used after stack was modified.\n+        auto & frame = stack.back();\n+\n+        /// Traverse all children first.\n+        if (frame.next_child < frame.node->children.size())\n+        {\n+            auto next_frame = Frame{.node = frame.node->children[frame.next_child]};\n+            ++frame.next_child;\n+            stack.push_back(next_frame);\n+            continue;\n+        }\n+\n+        if (auto * source_step_with_filter = dynamic_cast<SourceStepWithFilter *>(frame.node->step.get()))\n+        {\n+            source_step_with_filter->applyFilters();\n+        }\n+\n+        addPlansForSets(*frame.node, nodes);\n+\n+        stack.pop_back();\n+    }\n+}\n+\n }\n }\ndiff --git a/src/Processors/QueryPlan/QueryPlan.cpp b/src/Processors/QueryPlan/QueryPlan.cpp\nindex cb732e588558..687260441ff3 100644\n--- a/src/Processors/QueryPlan/QueryPlan.cpp\n+++ b/src/Processors/QueryPlan/QueryPlan.cpp\n@@ -482,6 +482,7 @@ void QueryPlan::optimize(const QueryPlanOptimizationSettings & optimization_sett\n \n     QueryPlanOptimizations::optimizeTreeFirstPass(optimization_settings, *root, nodes);\n     QueryPlanOptimizations::optimizeTreeSecondPass(optimization_settings, *root, nodes);\n+    QueryPlanOptimizations::optimizeTreeThirdPass(*root, nodes);\n \n     updateDataStreams(*root);\n }\ndiff --git a/src/Processors/QueryPlan/ReadFromMergeTree.cpp b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\nindex 1e21d13e2b18..e7bf1ce2edff 100644\n--- a/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n+++ b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n@@ -1299,13 +1299,10 @@ static void buildIndexes(\n     indexes->skip_indexes = std::move(skip_indexes);\n }\n \n-void ReadFromMergeTree::onAddFilterFinish()\n+void ReadFromMergeTree::applyFilters()\n {\n-    if (!filter_nodes.nodes.empty())\n-    {\n-        auto filter_actions_dag = buildFilterDAG(context, prewhere_info, filter_nodes, query_info);\n-        buildIndexes(indexes, filter_actions_dag, data, context, query_info, metadata_for_reading);\n-    }\n+    auto filter_actions_dag = buildFilterDAG(context, prewhere_info, filter_nodes, query_info);\n+    buildIndexes(indexes, filter_actions_dag, data, context, query_info, metadata_for_reading);\n }\n \n MergeTreeDataSelectAnalysisResultPtr ReadFromMergeTree::selectRangesToRead(\ndiff --git a/src/Processors/QueryPlan/ReadFromMergeTree.h b/src/Processors/QueryPlan/ReadFromMergeTree.h\nindex 06021cb1c5bf..3e3edd4dc5c9 100644\n--- a/src/Processors/QueryPlan/ReadFromMergeTree.h\n+++ b/src/Processors/QueryPlan/ReadFromMergeTree.h\n@@ -226,7 +226,7 @@ class ReadFromMergeTree final : public SourceStepWithFilter\n     size_t getNumStreams() const { return requested_num_streams; }\n     bool isParallelReadingEnabled() const { return read_task_callback != std::nullopt; }\n \n-    void onAddFilterFinish() override;\n+    void applyFilters() override;\n \n private:\n     static MergeTreeDataSelectAnalysisResultPtr selectRangesToReadImpl(\ndiff --git a/src/Processors/QueryPlan/SourceStepWithFilter.h b/src/Processors/QueryPlan/SourceStepWithFilter.h\nindex 34b6e3c6a7bb..dbaff06fde64 100644\n--- a/src/Processors/QueryPlan/SourceStepWithFilter.h\n+++ b/src/Processors/QueryPlan/SourceStepWithFilter.h\n@@ -37,7 +37,8 @@ class SourceStepWithFilter : public ISourceStep\n         filter_dags.push_back(std::move(filter_dag));\n     }\n \n-    virtual void onAddFilterFinish() {}\n+    /// Apply filters that can optimize reading from storage.\n+    virtual void applyFilters() {}\n \n protected:\n     std::vector<ActionsDAGPtr> filter_dags;\ndiff --git a/src/Storages/MergeTree/MergeTreeWhereOptimizer.cpp b/src/Storages/MergeTree/MergeTreeWhereOptimizer.cpp\nindex 25a4579c73ea..1620ba98d589 100644\n--- a/src/Storages/MergeTree/MergeTreeWhereOptimizer.cpp\n+++ b/src/Storages/MergeTree/MergeTreeWhereOptimizer.cpp\n@@ -110,6 +110,9 @@ static void collectColumns(const RPNBuilderTreeNode & node, const NameSet & colu\n     if (node.isConstant())\n         return;\n \n+    if (node.isSubqueryOrSet())\n+        return;\n+\n     if (!node.isFunction())\n     {\n         auto column_name = node.getColumnName();\ndiff --git a/src/Storages/MergeTree/RPNBuilder.cpp b/src/Storages/MergeTree/RPNBuilder.cpp\nindex 0b42111be457..a0c96c13d59f 100644\n--- a/src/Storages/MergeTree/RPNBuilder.cpp\n+++ b/src/Storages/MergeTree/RPNBuilder.cpp\n@@ -181,6 +181,21 @@ bool RPNBuilderTreeNode::isConstant() const\n     }\n }\n \n+bool RPNBuilderTreeNode::isSubqueryOrSet() const\n+{\n+    if (ast_node)\n+    {\n+        return\n+            typeid_cast<const ASTSubquery *>(ast_node) ||\n+            typeid_cast<const ASTTableIdentifier *>(ast_node);\n+    }\n+    else\n+    {\n+        const auto * node_without_alias = getNodeWithoutAlias(dag_node);\n+        return node_without_alias->result_type->getTypeId() == TypeIndex::Set;\n+    }\n+}\n+\n ColumnWithTypeAndName RPNBuilderTreeNode::getConstantColumn() const\n {\n     if (!isConstant())\ndiff --git a/src/Storages/MergeTree/RPNBuilder.h b/src/Storages/MergeTree/RPNBuilder.h\nindex 6f624d93cd67..9eeb6deefd5e 100644\n--- a/src/Storages/MergeTree/RPNBuilder.h\n+++ b/src/Storages/MergeTree/RPNBuilder.h\n@@ -98,6 +98,8 @@ class RPNBuilderTreeNode\n     /// Is node constant\n     bool isConstant() const;\n \n+    bool isSubqueryOrSet() const;\n+\n     /** Get constant as constant column.\n       * Node must be constant before calling these method, otherwise logical exception is thrown.\n       */\ndiff --git a/src/Storages/System/StorageSystemZooKeeper.cpp b/src/Storages/System/StorageSystemZooKeeper.cpp\nindex d361a4173c12..4d7f59b8ccdc 100644\n--- a/src/Storages/System/StorageSystemZooKeeper.cpp\n+++ b/src/Storages/System/StorageSystemZooKeeper.cpp\n@@ -184,7 +184,7 @@ class ReadFromSystemZooKeeper final : public SourceStepWithFilter\n \n     void initializePipeline(QueryPipelineBuilder & pipeline, const BuildQueryPipelineSettings & settings) override;\n \n-    void onAddFilterFinish() override;\n+    void applyFilters() override;\n \n private:\n     void fillData(MutableColumns & res_columns);\n@@ -421,7 +421,7 @@ static Paths extractPath(const ActionsDAG::NodeRawConstPtrs & filter_nodes, Cont\n }\n \n \n-void ReadFromSystemZooKeeper::onAddFilterFinish()\n+void ReadFromSystemZooKeeper::applyFilters()\n {\n     paths = extractPath(getFilterNodes().nodes, context, context->getSettingsRef().allow_unrestricted_reads_from_keeper);\n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02809_prewhere_and_in.reference b/tests/queries/0_stateless/02809_prewhere_and_in.reference\nnew file mode 100644\nindex 000000000000..3080ae862bb6\n--- /dev/null\n+++ b/tests/queries/0_stateless/02809_prewhere_and_in.reference\n@@ -0,0 +1,8 @@\n+PREWHERE a IN\n+PREWHERE a IN\n+PREWHERE a IN\n+PREWHERE a IN\n+PREWHERE b NOT IN\n+PREWHERE b NOT IN\n+PREWHERE b NOT IN\n+PREWHERE b NOT IN\ndiff --git a/tests/queries/0_stateless/02809_prewhere_and_in.sql b/tests/queries/0_stateless/02809_prewhere_and_in.sql\nnew file mode 100644\nindex 000000000000..345577d6c7c6\n--- /dev/null\n+++ b/tests/queries/0_stateless/02809_prewhere_and_in.sql\n@@ -0,0 +1,56 @@\n+DROP TABLE IF EXISTS t_02809;\n+\n+CREATE TABLE t_02809(a Int64, b Int64, s String)\n+ENGINE=MergeTree order by tuple()\n+AS SELECT number, number%10, toString(arrayMap(i-> cityHash64(i*number), range(50))) FROM numbers(10000);\n+\n+CREATE TABLE t_02809_set(c Int64)\n+ENGINE=Set()\n+AS SELECT * FROM numbers(10);\n+\n+CREATE TABLE t_02809_aux(c Int64)\n+ENGINE=Memory()\n+AS SELECT * FROM numbers(10);\n+\n+\n+SET optimize_move_to_prewhere=1;\n+\n+-- Queries with 'IN'\n+SELECT substring(explain, 1, 13) FROM (EXPLAIN SYNTAX\n+     SELECT * FROM t_02809 WHERE a IN (SELECT * FROM system.one)\n+) WHERE explain LIKE '%WHERE%';\n+\n+SELECT substring(explain, 1, 13) FROM (EXPLAIN SYNTAX\n+     SELECT * FROM t_02809 WHERE a IN (1,2,3)\n+) WHERE explain LIKE '%WHERE%';\n+\n+SELECT substring(explain, 1, 13) FROM (EXPLAIN SYNTAX\n+     SELECT * FROM t_02809 WHERE a IN t_02809_set\n+) WHERE explain LIKE '%WHERE%';\n+\n+SELECT substring(explain, 1, 13) FROM (EXPLAIN SYNTAX\n+     SELECT * FROM t_02809 WHERE a IN t_02809_aux\n+) WHERE explain LIKE '%WHERE%';\n+\n+\n+-- Queries with 'NOT IN'\n+SELECT substring(explain, 1, 17) FROM (EXPLAIN SYNTAX\n+     SELECT * FROM t_02809 WHERE b NOT IN (SELECT * FROM system.one)\n+) WHERE explain LIKE '%WHERE%';\n+\n+SELECT substring(explain, 1, 17) FROM (EXPLAIN SYNTAX\n+     SELECT * FROM t_02809 WHERE b NOT IN (1,2,3)\n+) WHERE explain LIKE '%WHERE%';\n+\n+SELECT substring(explain, 1, 17) FROM (EXPLAIN SYNTAX\n+     SELECT * FROM t_02809 WHERE b NOT IN t_02809_set\n+) WHERE explain LIKE '%WHERE%';\n+\n+SELECT substring(explain, 1, 17) FROM (EXPLAIN SYNTAX\n+     SELECT * FROM t_02809 WHERE b NOT IN t_02809_aux\n+) WHERE explain LIKE '%WHERE%';\n+\n+\n+DROP TABLE t_02809;\n+DROP TABLE t_02809_set;\n+DROP TABLE t_02809_aux;\n",
  "problem_statement": "About new version query performance\nI recently upgraded the clickhouse version to 23.5\r\nFound some performance issues\uff0cMight be an execution plan selection issue\r\nSELECT\r\n    id,\r\n    learnNumber AS learn_number,\r\n    mobileEncrypt AS mobile_encrypt,\r\n    wechatProvince AS wechat_province,\r\n    wechatCity AS wechat_city,\r\n    dataFrom AS data_from,\r\n    appId AS app_id,\r\n    wechatName AS wechat_name,\r\n    wechatSex AS wechat_sex,\r\n    createdTime AS created_time,\r\n    channel1 AS channel,\r\n    subChannel AS sub_channel,\r\n    appMarket AS app_market\r\nFROM\r\n(\r\n    SELECT\r\n        id,\r\n        max(gmt_modified) AS gmtModified,\r\n        argMax(ifNull(learn_number, ''), gmt_modified) AS learnNumber,\r\n        argMax(ifNull(mobile_encrypt, ''), gmt_modified) AS mobileEncrypt,\r\n        argMax(ifNull(wechat_province, ''), gmt_modified) AS wechatProvince,\r\n        argMax(ifNull(wechat_city, ''), gmt_modified) AS wechatCity,\r\n        argMax(ifNull(data_from, 0), gmt_modified) AS dataFrom,\r\n        argMax(ifNull(app_id, ''), gmt_modified) AS appId,\r\n        argMax(ifNull(wechat_name, ''), gmt_modified) AS wechatName,\r\n        argMax(wechat_sex, gmt_modified) AS wechatSex,\r\n        argMax(created_time, gmt_modified) AS createdTime,\r\n        argMax(channel, gmt_modified) AS channel1,\r\n        argMax(sub_channel, gmt_modified) AS subChannel,\r\n        argMax(app_market, gmt_modified) AS appMarket,\r\n        argMax(is_deleted, gmt_modified) AS isDeleted\r\n    FROM t_customer\r\n    WHERE (1 = 1) AND (id IN (\r\n        SELECT id\r\n        FROM t_customer\r\n        WHERE (1 = 1) AND (mobile_encrypt = '') AND ((created_time >= '2016-06-14 00:00:00') AND (created_time <= '2023-06-28 59:59:59'))\r\n        GROUP BY id\r\n    ))\r\n    GROUP BY id\r\n    HAVING 1 = 1\r\n) AS a\r\nWHERE isDeleted = 0\r\nLIMIT 0, 20\r\nFORMAT TabSeparatedWithNamesAndTypes\r\n\r\n1 row in set. Elapsed: 1.820 sec. Processed 76.82 million rows, 11.97 GB (42.22 million rows/s., 6.58 GB/s.)\r\n\r\n\r\nIt looks like the subquery is not executed first??\r\nHere is the subquery result with only 1 record\r\nSELECT id\r\nFROM t_customer\r\nWHERE (1 = 1) AND (mobile_encrypt = '') AND ((created_time >= '2016-06-14 00:00:00') AND (created_time <= '2023-06-28 59:59:59'))\r\nGROUP BY id\r\n\r\nQuery id: 84537679-b3f7-49e2-a0a1-82b4da0ae9c2\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500id\u2500\u2510\r\n\u2502 570374905698 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.049 sec. Processed 1.76 million rows, 92.79 MB (36.30 million rows/s., 1.91 GB/s.)\r\n\r\n\r\nWhen I changed where to prewhere, the performance improved\uff1a\r\n\r\nSELECT\r\n    id,\r\n    learnNumber AS learn_number,\r\n    mobileEncrypt AS mobile_encrypt,\r\n    wechatProvince AS wechat_province,\r\n    wechatCity AS wechat_city,\r\n    dataFrom AS data_from,\r\n    appId AS app_id,\r\n    wechatName AS wechat_name,\r\n    wechatSex AS wechat_sex,\r\n    createdTime AS created_time,\r\n    channel1 AS channel,\r\n    subChannel AS sub_channel,\r\n    appMarket AS app_market\r\nFROM\r\n(\r\n    SELECT\r\n        id,\r\n        max(gmt_modified) AS gmtModified,\r\n        argMax(ifNull(learn_number, ''), gmt_modified) AS learnNumber,\r\n        argMax(ifNull(mobile_encrypt, ''), gmt_modified) AS mobileEncrypt,\r\n        argMax(ifNull(wechat_province, ''), gmt_modified) AS wechatProvince,\r\n        argMax(ifNull(wechat_city, ''), gmt_modified) AS wechatCity,\r\n        argMax(ifNull(data_from, 0), gmt_modified) AS dataFrom,\r\n        argMax(ifNull(app_id, ''), gmt_modified) AS appId,\r\n        argMax(ifNull(wechat_name, ''), gmt_modified) AS wechatName,\r\n        argMax(wechat_sex, gmt_modified) AS wechatSex,\r\n        argMax(created_time, gmt_modified) AS createdTime,\r\n        argMax(channel, gmt_modified) AS channel1,\r\n        argMax(sub_channel, gmt_modified) AS subChannel,\r\n        argMax(app_market, gmt_modified) AS appMarket,\r\n        argMax(is_deleted, gmt_modified) AS isDeleted\r\n    FROM t_customer\r\n    **PREWHERE** (1 = 1) AND (id IN (\r\n        SELECT id\r\n        FROM t_customer\r\n        WHERE (1 = 1) AND (mobile_encrypt = '') AND ((created_time >= '2016-06-14 00:00:00') AND (created_time <= '2023-06-28 59:59:59'))\r\n        GROUP BY id\r\n    ))\r\n    GROUP BY id\r\n    HAVING 1 = 1\r\n) AS a\r\nWHERE isDeleted = 0\r\nLIMIT 0, 20\r\nFORMAT TabSeparatedWithNamesAndTypes\r\n\r\nQuery id: 18955efa-fc56-47f4-8bcf-dbba0a6ca986\r\n\r\n1 row in set. Elapsed: 0.079 sec. Processed 1.81 million rows, 97.42 MB (22.96 million rows/s., 1.23 GB/s.)\r\n\r\nQuery time reduced from 1.8 seconds to 80 milliseconds\r\n\r\n\r\n\r\n\r\nI write the result of the subquery directly to the query, which is also very fast. Indicates that the original query did not execute the subquery first\r\n\r\nlike this (it only cost 35 milliseconds):\r\n\r\nSELECT\r\n    id,\r\n    learnNumber AS learn_number,\r\n    mobileEncrypt AS mobile_encrypt,\r\n    wechatProvince AS wechat_province,\r\n    wechatCity AS wechat_city,\r\n    dataFrom AS data_from,\r\n    appId AS app_id,\r\n    wechatName AS wechat_name,\r\n    wechatSex AS wechat_sex,\r\n    createdTime AS created_time,\r\n    channel1 AS channel,\r\n    subChannel AS sub_channel,\r\n    appMarket AS app_market\r\nFROM\r\n(\r\n    SELECT\r\n        id,\r\n        max(gmt_modified) AS gmtModified,\r\n        argMax(ifNull(learn_number, ''), gmt_modified) AS learnNumber,\r\n        argMax(ifNull(mobile_encrypt, ''), gmt_modified) AS mobileEncrypt,\r\n        argMax(ifNull(wechat_province, ''), gmt_modified) AS wechatProvince,\r\n        argMax(ifNull(wechat_city, ''), gmt_modified) AS wechatCity,\r\n        argMax(ifNull(data_from, 0), gmt_modified) AS dataFrom,\r\n        argMax(ifNull(app_id, ''), gmt_modified) AS appId,\r\n        argMax(ifNull(wechat_name, ''), gmt_modified) AS wechatName,\r\n        argMax(wechat_sex, gmt_modified) AS wechatSex,\r\n        argMax(created_time, gmt_modified) AS createdTime,\r\n        argMax(channel, gmt_modified) AS channel1,\r\n        argMax(sub_channel, gmt_modified) AS subChannel,\r\n        argMax(app_market, gmt_modified) AS appMarket,\r\n        argMax(is_deleted, gmt_modified) AS isDeleted\r\n    FROM t_customer\r\n    WHERE (1 = 1) AND (id IN (570374905698))\r\n    GROUP BY id\r\n    HAVING (1 = 1) AND (mobileEncrypt = 'BA7705BE0870504804D060A5BDCE3495')\r\n) AS a\r\nWHERE isDeleted = 0\r\nLIMIT 0, 20\r\nFORMAT TabSeparatedWithNamesAndTypes\r\n\r\nQuery id: 5201c954-310a-4d8b-99cf-d61f4a92061d\r\n1 row in set. Elapsed: 0.035 sec. Processed 22.42 thousand rows, 1.41 MB (649.48 thousand rows/s., 40.91 MB/s.)\r\n\r\n\r\n\n",
  "hints_text": "from which version you upgraded? I think Clickhouse never moved subquery predicates to prewhere.\n@yangshike could you please provide some more info:\r\n1. which version did you have before 23.5 ?\r\n2. what are the sizes of the columns in the t_customer table. you can get it with this query: ```select name, type, data_compressed_bytes, data_uncompressed_bytes from system.columns where table = 't_customer'```\r\n3. what ```EXPLAIN actions=1 SELECT id, ....``` show for the slow query \r\n4. logs from running the slow query. Add ```  SETTINGS send_logs_level='trace'``` to the end of the query\nThough I am wrong. 22.8 moved subqueries to prewhere\r\n\r\n```\r\ncreate table a(a Int64, b String) Engine=MergeTree order by tuple() as select number, toString(arrayMap(i-> cityHash64(i*number), range(50))) from numbers(1e7);\r\n\r\nselect * from a where  a in (select * from system.one);\r\nMergeTreeWhereOptimizer: condition \"a IN ((SELECT * FROM system.one) AS _subquery22)\" moved to PREWHERE\r\nMergeTreeWhereOptimizer: condition \"a IN (SELECT * FROM system.one)\" moved to PREWHERE\r\n\r\n1 row in set. Elapsed: 0.011 sec. Processed 10.00 million rows, 80.00 MB (933.07 million rows/s., 7.46 GB/s.)\r\n\r\n-- without prewhere\r\nselect * from a prewhere 1=1 where a in (select * from system.one);\r\n1 row in set. Elapsed: 0.925 sec. Processed 10.00 million rows, 10.37 GB (10.81 million rows/s., 11.21 GB/s.)\r\n```\n23.5.3.24 (starting from 23.3)\r\n\r\n```\r\ncreate table a(a Int64, b String) Engine=MergeTree order by tuple() as select number, toString(arrayMap(i-> cityHash64(i*number), range(50))) from numbers(1e7);\r\n\r\nset optimize_move_to_prewhere=1, move_all_conditions_to_prewhere=1, enable_multiple_prewhere_read_steps=1;\r\n\r\nselect * from a where  a in (select * from system.one);\r\n1 row in set. Elapsed: 2.170 sec. Processed 10.00 million rows, 10.37 GB (4.61 million rows/s., 4.78 GB/s.)\r\n\r\n-- with prewhere\r\nselect * from a prewhere  a in (select * from system.one);\r\n1 row in set. Elapsed: 0.062 sec. Processed 10.00 million rows, 80.00 MB (160.32 million rows/s., 1.28 GB/s.)\r\n```",
  "created_at": "2023-06-29T14:29:16Z"
}