{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 11973,
  "instance_id": "ClickHouse__ClickHouse-11973",
  "issue_numbers": [
    "7513"
  ],
  "base_commit": "c83e018855af787a4502c38e90d47898f3f8dd81",
  "patch": "diff --git a/src/DataTypes/DataTypeEnum.cpp b/src/DataTypes/DataTypeEnum.cpp\nindex dc7015c83b25..8fcd19bce7d5 100644\n--- a/src/DataTypes/DataTypeEnum.cpp\n+++ b/src/DataTypes/DataTypeEnum.cpp\n@@ -348,6 +348,25 @@ Field DataTypeEnum<Type>::castToValue(const Field & value_or_name) const\n }\n \n \n+template <typename Type>\n+bool DataTypeEnum<Type>::contains(const IDataType & rhs) const\n+{\n+    auto check = [&](const auto & value)\n+    {\n+        auto it = name_to_value_map.find(value.first);\n+        if (it == name_to_value_map.end())\n+            return false;\n+        return it->value.second == value.second;\n+    };\n+\n+    if (const auto * rhs_enum8 = typeid_cast<const DataTypeEnum8 *>(&rhs))\n+        return std::all_of(rhs_enum8->getValues().begin(), rhs_enum8->getValues().end(), check);\n+    if (const auto * rhs_enum16 = typeid_cast<const DataTypeEnum16 *>(&rhs))\n+        return std::all_of(rhs_enum16->getValues().begin(), rhs_enum16->getValues().end(), check);\n+    return false;\n+}\n+\n+\n /// Explicit instantiations.\n template class DataTypeEnum<Int8>;\n template class DataTypeEnum<Int16>;\ndiff --git a/src/DataTypes/DataTypeEnum.h b/src/DataTypes/DataTypeEnum.h\nindex 2cb677984dfc..dd41ee3fcc76 100644\n--- a/src/DataTypes/DataTypeEnum.h\n+++ b/src/DataTypes/DataTypeEnum.h\n@@ -119,6 +119,9 @@ class DataTypeEnum final : public IDataTypeEnum\n \n     bool textCanContainOnlyValidUTF8() const override;\n     size_t getSizeOfValueInMemory() const override { return sizeof(FieldType); }\n+\n+    /// Check current Enum type extends another Enum type (contains all fields with same values).\n+    bool contains(const IDataType & rhs) const;\n };\n \n \ndiff --git a/src/Storages/AlterCommands.cpp b/src/Storages/AlterCommands.cpp\nindex 436862a3804b..5d892ca07d49 100644\n--- a/src/Storages/AlterCommands.cpp\n+++ b/src/Storages/AlterCommands.cpp\n@@ -728,6 +728,10 @@ void AlterCommands::apply(StorageInMemoryMetadata & metadata, const Context & co\n         metadata_copy.primary_key.definition_ast = nullptr;\n     }\n \n+    /// And in partition key expression\n+    if (metadata_copy.partition_key.definition_ast != nullptr)\n+        metadata_copy.partition_key.recalculateWithNewColumns(metadata_copy.columns, context);\n+\n     /// Changes in columns may lead to changes in secondary indices\n     for (auto & index : metadata_copy.secondary_indices)\n         index.recalculateWithNewColumns(metadata_copy.columns, context);\ndiff --git a/src/Storages/MergeTree/IMergeTreeDataPart.h b/src/Storages/MergeTree/IMergeTreeDataPart.h\nindex 0e73b1370c52..0b816ca0711e 100644\n--- a/src/Storages/MergeTree/IMergeTreeDataPart.h\n+++ b/src/Storages/MergeTree/IMergeTreeDataPart.h\n@@ -46,7 +46,6 @@ namespace ErrorCodes\n class IMergeTreeDataPart : public std::enable_shared_from_this<IMergeTreeDataPart>\n {\n public:\n-\n     using Checksums = MergeTreeDataPartChecksums;\n     using Checksum = MergeTreeDataPartChecksums::Checksum;\n     using ValueSizeMap = std::map<std::string, double>;\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex f1567a1d18d4..e35aa4b11810 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -270,7 +270,8 @@ static void checkKeyExpression(const ExpressionActions & expr, const Block & sam\n     }\n }\n \n-void MergeTreeData::checkProperties(const StorageInMemoryMetadata & new_metadata, const StorageInMemoryMetadata & old_metadata, bool attach) const\n+void MergeTreeData::checkProperties(\n+    const StorageInMemoryMetadata & new_metadata, const StorageInMemoryMetadata & old_metadata, bool attach) const\n {\n     if (!new_metadata.sorting_key.definition_ast)\n         throw Exception(\"ORDER BY cannot be empty\", ErrorCodes::BAD_ARGUMENTS);\n@@ -343,12 +344,12 @@ void MergeTreeData::checkProperties(const StorageInMemoryMetadata & new_metadata\n             for (const String & col : used_columns)\n             {\n                 if (!added_columns.contains(col) || deleted_columns.contains(col))\n-                    throw Exception(\"Existing column \" + col + \" is used in the expression that was \"\n+                    throw Exception(\"Existing column \" + backQuoteIfNeed(col) + \" is used in the expression that was \"\n                         \"added to the sorting key. You can add expressions that use only the newly added columns\",\n                         ErrorCodes::BAD_ARGUMENTS);\n \n                 if (new_metadata.columns.getDefaults().count(col))\n-                    throw Exception(\"Newly added column \" + col + \" has a default expression, so adding \"\n+                    throw Exception(\"Newly added column \" + backQuoteIfNeed(col) + \" has a default expression, so adding \"\n                         \"expressions that use it to the sorting key is forbidden\",\n                         ErrorCodes::BAD_ARGUMENTS);\n             }\n@@ -1219,18 +1220,47 @@ bool isMetadataOnlyConversion(const IDataType * from, const IDataType * to)\n     }\n }\n \n+/// Conversion that is allowed for partition key.\n+/// Partition key should be serialized in the same way after conversion.\n+/// NOTE: The list is not complete.\n+bool isSafeForPartitionKeyConversion(const IDataType * from, const IDataType * to)\n+{\n+    if (from->getName() == to->getName())\n+        return true;\n+\n+    /// Enums are serialized in partition key as numbers - so conversion from Enum to number is Ok.\n+    /// But only for types of identical width because they are serialized as binary in minmax index.\n+    /// But not from number to Enum because Enum does not necessarily represents all numbers.\n+\n+    if (const auto * from_enum8 = typeid_cast<const DataTypeEnum8 *>(from))\n+    {\n+        if (const auto * to_enum8 = typeid_cast<const DataTypeEnum8 *>(to))\n+            return to_enum8->contains(*from_enum8);\n+        if (typeid_cast<const DataTypeInt8 *>(to))\n+            return true;    // NOLINT\n+        return false;\n+    }\n+\n+    if (const auto * from_enum16 = typeid_cast<const DataTypeEnum16 *>(from))\n+    {\n+        if (const auto * to_enum16 = typeid_cast<const DataTypeEnum16 *>(to))\n+            return to_enum16->contains(*from_enum16);\n+        if (typeid_cast<const DataTypeInt16 *>(to))\n+            return true;    // NOLINT\n+        return false;\n+    }\n+\n+    return false;\n+}\n+\n }\n \n-void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, const Settings & settings) const\n+void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, const Settings &) const\n {\n     /// Check that needed transformations can be applied to the list of columns without considering type conversions.\n     StorageInMemoryMetadata new_metadata = getInMemoryMetadata();\n     StorageInMemoryMetadata old_metadata = getInMemoryMetadata();\n     commands.apply(new_metadata, global_context);\n-    if (old_metadata.getSecondaryIndices().empty() && !new_metadata.secondary_indices.empty()\n-        && !settings.allow_experimental_data_skipping_indices)\n-        throw Exception(\"You must set the setting `allow_experimental_data_skipping_indices` to 1 \" \\\n-                        \"before using data skipping indices.\", ErrorCodes::BAD_ARGUMENTS);\n \n     /// Set of columns that shouldn't be altered.\n     NameSet columns_alter_type_forbidden;\n@@ -1239,13 +1269,22 @@ void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, const S\n     /// (and not as a part of some expression) and if the ALTER only affects column metadata.\n     NameSet columns_alter_type_metadata_only;\n \n+    /// Columns to check that the type change is safe for partition key.\n+    NameSet columns_alter_type_check_safe_for_partition;\n+\n     if (old_metadata.hasPartitionKey())\n     {\n-        /// Forbid altering partition key columns because it can change partition ID format.\n-        /// TODO: in some cases (e.g. adding an Enum value) a partition key column can still be ALTERed.\n-        /// We should allow it.\n-        for (const String & col : old_metadata.getColumnsRequiredForPartitionKey())\n-            columns_alter_type_forbidden.insert(col);\n+        /// Forbid altering columns inside partition key expressions because it can change partition ID format.\n+        auto partition_key_expr = old_metadata.getPartitionKey().expression;\n+        for (const ExpressionAction & action : partition_key_expr->getActions())\n+        {\n+            auto action_columns = action.getNeededColumns();\n+            columns_alter_type_forbidden.insert(action_columns.begin(), action_columns.end());\n+        }\n+\n+        /// But allow to alter columns without expressions under certain condition.\n+        for (const String & col : partition_key_expr->getRequiredColumns())\n+            columns_alter_type_check_safe_for_partition.insert(col);\n     }\n \n     for (const auto & index : old_metadata.getSecondaryIndices())\n@@ -1271,11 +1310,16 @@ void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, const S\n     if (!merging_params.sign_column.empty())\n         columns_alter_type_forbidden.insert(merging_params.sign_column);\n \n+    /// All of the above.\n+    NameSet columns_in_keys;\n+    columns_in_keys.insert(columns_alter_type_forbidden.begin(), columns_alter_type_forbidden.end());\n+    columns_in_keys.insert(columns_alter_type_metadata_only.begin(), columns_alter_type_metadata_only.end());\n+    columns_in_keys.insert(columns_alter_type_check_safe_for_partition.begin(), columns_alter_type_check_safe_for_partition.end());\n+\n     std::map<String, const IDataType *> old_types;\n     for (const auto & column : old_metadata.getColumns().getAllPhysical())\n         old_types.emplace(column.name, column.type.get());\n \n-\n     for (const AlterCommand & command : commands)\n     {\n         if (command.type == AlterCommand::MODIFY_ORDER_BY && !is_custom_partitioned)\n@@ -1292,17 +1336,40 @@ void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, const S\n         }\n         if (command.type == AlterCommand::RENAME_COLUMN)\n         {\n-            if (columns_alter_type_forbidden.count(command.column_name) || columns_alter_type_metadata_only.count(command.column_name))\n+            if (columns_in_keys.count(command.column_name))\n             {\n                 throw Exception(\n                     \"Trying to ALTER RENAME key \" + backQuoteIfNeed(command.column_name) + \" column which is a part of key expression\",\n                     ErrorCodes::ALTER_OF_COLUMN_IS_FORBIDDEN);\n             }\n         }\n+        else if (command.type == AlterCommand::DROP_COLUMN)\n+        {\n+            if (columns_in_keys.count(command.column_name))\n+            {\n+                throw Exception(\n+                    \"Trying to ALTER DROP key \" + backQuoteIfNeed(command.column_name) + \" column which is a part of key expression\",\n+                    ErrorCodes::ALTER_OF_COLUMN_IS_FORBIDDEN);\n+            }\n+        }\n         else if (command.isModifyingData(getInMemoryMetadata()))\n         {\n             if (columns_alter_type_forbidden.count(command.column_name))\n-                throw Exception(\"ALTER of key column \" + command.column_name + \" is forbidden\", ErrorCodes::ALTER_OF_COLUMN_IS_FORBIDDEN);\n+                throw Exception(\"ALTER of key column \" + backQuoteIfNeed(command.column_name) + \" is forbidden\",\n+                    ErrorCodes::ALTER_OF_COLUMN_IS_FORBIDDEN);\n+\n+            if (columns_alter_type_check_safe_for_partition.count(command.column_name))\n+            {\n+                if (command.type == AlterCommand::MODIFY_COLUMN)\n+                {\n+                    auto it = old_types.find(command.column_name);\n+                    if (it == old_types.end() || !isSafeForPartitionKeyConversion(it->second, command.data_type.get()))\n+                        throw Exception(\"ALTER of partition key column \" + backQuoteIfNeed(command.column_name) + \" from type \"\n+                                + it->second->getName() + \" to type \" + command.data_type->getName()\n+                                + \" is not safe because it can change the representation of partition key\",\n+                            ErrorCodes::ALTER_OF_COLUMN_IS_FORBIDDEN);\n+                }\n+            }\n \n             if (columns_alter_type_metadata_only.count(command.column_name))\n             {\n@@ -1310,7 +1377,8 @@ void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, const S\n                 {\n                     auto it = old_types.find(command.column_name);\n                     if (it == old_types.end() || !isMetadataOnlyConversion(it->second, command.data_type.get()))\n-                        throw Exception(\"ALTER of key column \" + command.column_name + \" must be metadata-only\",\n+                        throw Exception(\"ALTER of key column \" + backQuoteIfNeed(command.column_name) + \" from type \"\n+                            + it->second->getName() + \" to type \" + command.data_type->getName() + \" must be metadata-only\",\n                             ErrorCodes::ALTER_OF_COLUMN_IS_FORBIDDEN);\n                 }\n             }\n@@ -1318,7 +1386,6 @@ void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, const S\n     }\n \n     checkProperties(new_metadata, old_metadata);\n-\n     checkTTLExpressions(new_metadata, old_metadata);\n \n     if (old_metadata.hasSettingsChanges())\ndiff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h\nindex 0eea48886875..e46e8b3a646b 100644\n--- a/src/Storages/MergeTree/MergeTreeData.h\n+++ b/src/Storages/MergeTree/MergeTreeData.h\n@@ -350,8 +350,7 @@ class MergeTreeData : public IStorage\n     bool supportsSettings() const override { return true; }\n     NamesAndTypesList getVirtuals() const override;\n \n-    bool\n-    mayBenefitFromIndexForIn(const ASTPtr & left_in_operand, const Context &, const StorageMetadataPtr & metadata_snapshot) const override;\n+    bool mayBenefitFromIndexForIn(const ASTPtr & left_in_operand, const Context &, const StorageMetadataPtr & metadata_snapshot) const override;\n \n     /// Load the set of data parts from disk. Call once - immediately after the object is created.\n     void loadDataParts(bool skip_sanity_checks);\ndiff --git a/src/Storages/MergeTree/registerStorageMergeTree.cpp b/src/Storages/MergeTree/registerStorageMergeTree.cpp\nindex 1ecac8f413dc..aa9d405130f8 100644\n--- a/src/Storages/MergeTree/registerStorageMergeTree.cpp\n+++ b/src/Storages/MergeTree/registerStorageMergeTree.cpp\n@@ -613,10 +613,6 @@ static StoragePtr create(const StorageFactory::Arguments & args)\n     if (arg_num != arg_cnt)\n         throw Exception(\"Wrong number of engine arguments.\", ErrorCodes::BAD_ARGUMENTS);\n \n-    if (!args.attach && !metadata.secondary_indices.empty() && !args.local_context.getSettingsRef().allow_experimental_data_skipping_indices)\n-        throw Exception(\"You must set the setting `allow_experimental_data_skipping_indices` to 1 \" \\\n-                        \"before using data skipping indices.\", ErrorCodes::BAD_ARGUMENTS);\n-\n     if (replicated)\n         return StorageReplicatedMergeTree::create(\n             zookeeper_path, replica_name, args.attach, args.table_id, args.relative_data_path,\ndiff --git a/src/Storages/StorageInMemoryMetadata.h b/src/Storages/StorageInMemoryMetadata.h\nindex 254942ddfe80..8611d3d6c231 100644\n--- a/src/Storages/StorageInMemoryMetadata.h\n+++ b/src/Storages/StorageInMemoryMetadata.h\n@@ -61,17 +61,13 @@ struct StorageInMemoryMetadata\n     /// Sets constraints\n     void setConstraints(ConstraintsDescription constraints_);\n \n-    /// Set partition key for storage (methods bellow, are just wrappers for this\n-    /// struct).\n+    /// Set partition key for storage (methods bellow, are just wrappers for this struct).\n     void setPartitionKey(const KeyDescription & partition_key_);\n-    /// Set sorting key for storage (methods bellow, are just wrappers for this\n-    /// struct).\n+    /// Set sorting key for storage (methods bellow, are just wrappers for this struct).\n     void setSortingKey(const KeyDescription & sorting_key_);\n-    /// Set primary key for storage (methods bellow, are just wrappers for this\n-    /// struct).\n+    /// Set primary key for storage (methods bellow, are just wrappers for this struct).\n     void setPrimaryKey(const KeyDescription & primary_key_);\n-    /// Set sampling key for storage (methods bellow, are just wrappers for this\n-    /// struct).\n+    /// Set sampling key for storage (methods bellow, are just wrappers for this struct).\n     void setSamplingKey(const KeyDescription & sampling_key_);\n \n     /// Set common table TTLs\ndiff --git a/src/Storages/StorageMergeTree.cpp b/src/Storages/StorageMergeTree.cpp\nindex 4caa08cae9be..c3b5758c7a51 100644\n--- a/src/Storages/StorageMergeTree.cpp\n+++ b/src/Storages/StorageMergeTree.cpp\n@@ -276,8 +276,8 @@ void StorageMergeTree::alter(\n     {\n         {\n             changeSettings(new_metadata.settings_changes, table_lock_holder);\n-            /// Reinitialize primary key because primary key column types might have changed.\n             checkTTLExpressions(new_metadata, old_metadata);\n+            /// Reinitialize primary key because primary key column types might have changed.\n             setProperties(new_metadata, old_metadata);\n \n             DatabaseCatalog::instance().getDatabase(table_id.database_name)->alterTable(context, table_id, new_metadata);\ndiff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp\nindex bb267c1a9f3e..96e376f85fed 100644\n--- a/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -755,10 +755,12 @@ void StorageReplicatedMergeTree::checkTableStructure(const String & zookeeper_pr\n     }\n }\n \n-void StorageReplicatedMergeTree::setTableStructure(ColumnsDescription new_columns, const ReplicatedMergeTreeTableMetadata::Diff & metadata_diff)\n+void StorageReplicatedMergeTree::setTableStructure(\n+ColumnsDescription new_columns, const ReplicatedMergeTreeTableMetadata::Diff & metadata_diff)\n {\n     StorageInMemoryMetadata new_metadata = getInMemoryMetadata();\n     StorageInMemoryMetadata old_metadata = getInMemoryMetadata();\n+\n     if (new_columns != new_metadata.columns)\n     {\n         new_metadata.columns = new_columns;\n@@ -769,6 +771,10 @@ void StorageReplicatedMergeTree::setTableStructure(ColumnsDescription new_column\n             auto new_ttl_entry = TTLDescription::getTTLFromAST(ast, new_metadata.columns, global_context, new_metadata.primary_key);\n             new_metadata.column_ttls_by_name[name] = new_ttl_entry;\n         }\n+\n+        /// The type of partition key expression may change\n+        if (new_metadata.partition_key.definition_ast != nullptr)\n+            new_metadata.partition_key.recalculateWithNewColumns(new_metadata.columns, global_context);\n     }\n \n     if (!metadata_diff.empty())\n@@ -812,12 +818,13 @@ void StorageReplicatedMergeTree::setTableStructure(ColumnsDescription new_column\n         {\n             ParserTTLExpressionList parser;\n             auto ttl_for_table_ast = parseQuery(parser, metadata_diff.new_ttl_table, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n-            new_metadata.table_ttl = TTLTableDescription::getTTLForTableFromAST(ttl_for_table_ast, new_metadata.columns, global_context, new_metadata.primary_key);\n+            new_metadata.table_ttl = TTLTableDescription::getTTLForTableFromAST(\n+                ttl_for_table_ast, new_metadata.columns, global_context, new_metadata.primary_key);\n         }\n     }\n \n-    /// Even if the primary/sorting keys didn't change we must reinitialize it\n-    /// because primary key column types might have changed.\n+    /// Even if the primary/sorting/partition keys didn't change we must reinitialize it\n+    /// because primary/partition key column types might have changed.\n     checkTTLExpressions(new_metadata, old_metadata);\n     setProperties(new_metadata, old_metadata);\n \n@@ -3688,7 +3695,6 @@ void StorageReplicatedMergeTree::alter(\n         if (is_readonly)\n             throw Exception(\"Can't ALTER readonly table\", ErrorCodes::TABLE_IS_READ_ONLY);\n \n-\n         auto current_metadata = getInMemoryMetadataPtr();\n \n         StorageInMemoryMetadata future_metadata = *current_metadata;\n@@ -3698,6 +3704,9 @@ void StorageReplicatedMergeTree::alter(\n         if (ast_to_str(future_metadata.sorting_key.definition_ast) != ast_to_str(current_metadata->sorting_key.definition_ast))\n             future_metadata_in_zk.sorting_key = serializeAST(*future_metadata.sorting_key.expression_list_ast);\n \n+        if (ast_to_str(future_metadata.partition_key.definition_ast) != ast_to_str(current_metadata->partition_key.definition_ast))\n+            future_metadata_in_zk.partition_key = serializeAST(*future_metadata.partition_key.expression_list_ast);\n+\n         if (ast_to_str(future_metadata.table_ttl.definition_ast) != ast_to_str(current_metadata->table_ttl.definition_ast))\n             future_metadata_in_zk.ttl_table = serializeAST(*future_metadata.table_ttl.definition_ast);\n \n@@ -3746,8 +3755,8 @@ void StorageReplicatedMergeTree::alter(\n \n         std::optional<EphemeralLocksInAllPartitions> lock_holder;\n \n-        /// No we will prepare mutations record\n-        /// This code pretty same with mutate() function but process results slightly differently\n+        /// Now we will prepare mutations record.\n+        /// This code pretty same with mutate() function but process results slightly differently.\n         if (alter_entry->have_mutation)\n         {\n             String mutations_path = zookeeper_path + \"/mutations\";\n@@ -3798,7 +3807,8 @@ void StorageReplicatedMergeTree::alter(\n         else if (rc == Coordination::Error::ZBADVERSION)\n         {\n             if (results[0]->error != Coordination::Error::ZOK)\n-                throw Exception(\"Metadata on replica is not up to date with common metadata in Zookeeper. Cannot alter\", ErrorCodes::CANNOT_ASSIGN_ALTER);\n+                throw Exception(\"Metadata on replica is not up to date with common metadata in Zookeeper. Cannot alter\",\n+                    ErrorCodes::CANNOT_ASSIGN_ALTER);\n \n             continue;\n         }\n@@ -3808,7 +3818,6 @@ void StorageReplicatedMergeTree::alter(\n         }\n     }\n \n-\n     table_lock_holder.reset();\n \n     std::vector<String> unwaited;\ndiff --git a/src/Storages/StorageReplicatedMergeTree.h b/src/Storages/StorageReplicatedMergeTree.h\nindex a60ee6263695..712d997b26c2 100644\n--- a/src/Storages/StorageReplicatedMergeTree.h\n+++ b/src/Storages/StorageReplicatedMergeTree.h\n@@ -101,7 +101,13 @@ class StorageReplicatedMergeTree final : public ext::shared_ptr_helper<StorageRe\n \n     BlockOutputStreamPtr write(const ASTPtr & query, const StorageMetadataPtr & /*metadata_snapshot*/, const Context & context) override;\n \n-    bool optimize(const ASTPtr & query, const StorageMetadataPtr & metadata_snapshot, const ASTPtr & partition, bool final, bool deduplicate, const Context & query_context) override;\n+    bool optimize(\n+        const ASTPtr & query,\n+        const StorageMetadataPtr & metadata_snapshot,\n+        const ASTPtr & partition,\n+        bool final,\n+        bool deduplicate,\n+        const Context & query_context) override;\n \n     void alter(const AlterCommands & params, const Context & query_context, TableLockHolder & table_lock_holder) override;\n \n@@ -560,7 +566,6 @@ class StorageReplicatedMergeTree final : public ext::shared_ptr_helper<StorageRe\n         const MergingParams & merging_params_,\n         std::unique_ptr<MergeTreeSettings> settings_,\n         bool has_force_restore_data_flag);\n-\n };\n \n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01344_alter_enum_partition_key.reference b/tests/queries/0_stateless/01344_alter_enum_partition_key.reference\nnew file mode 100644\nindex 000000000000..bf8a7949282f\n--- /dev/null\n+++ b/tests/queries/0_stateless/01344_alter_enum_partition_key.reference\n@@ -0,0 +1,12 @@\n+hello\ttest\n+1_1_1_0\thello\t1\n+hello\ttest\n+goodbye\ttest\n+3_2_2_1\tgoodbye\t3\n+1_1_1_1\thello\t1\n+1\ttest\n+3\ttest\n+111\tabc\n+1_1_1_2\t1\t1\n+111_3_3_1\t111\t111\n+3_2_2_2\t3\t3\ndiff --git a/tests/queries/0_stateless/01344_alter_enum_partition_key.sql b/tests/queries/0_stateless/01344_alter_enum_partition_key.sql\nnew file mode 100644\nindex 000000000000..14bc3b5cdaaa\n--- /dev/null\n+++ b/tests/queries/0_stateless/01344_alter_enum_partition_key.sql\n@@ -0,0 +1,36 @@\n+DROP TABLE IF EXISTS test;\n+CREATE TABLE test (x Enum('hello' = 1, 'world' = 2), y String) ENGINE = MergeTree PARTITION BY x ORDER BY y;\n+INSERT INTO test VALUES ('hello', 'test');\n+\n+SELECT * FROM test;\n+SELECT name, partition, partition_id FROM system.parts WHERE database = currentDatabase() AND table = 'test' AND active ORDER BY partition;\n+\n+ALTER TABLE test MODIFY COLUMN x Enum('hello' = 1, 'world' = 2, 'goodbye' = 3);\n+INSERT INTO test VALUES ('goodbye', 'test');\n+OPTIMIZE TABLE test FINAL;\n+SELECT * FROM test ORDER BY x;\n+SELECT name, partition, partition_id FROM system.parts WHERE database = currentDatabase() AND table = 'test' AND active ORDER BY partition;\n+\n+ALTER TABLE test MODIFY COLUMN x Enum('hello' = 1, 'world' = 2); -- { serverError 524 }\n+ALTER TABLE test MODIFY COLUMN x Enum('hello' = 1, 'world' = 2, 'test' = 3); -- { serverError 524 }\n+ALTER TABLE test MODIFY COLUMN x Enum('hello' = 1, 'world' = 2, 'goodbye' = 4); -- { serverError 524 }\n+\n+ALTER TABLE test MODIFY COLUMN x Int8;\n+INSERT INTO test VALUES (111, 'abc');\n+OPTIMIZE TABLE test FINAL;\n+SELECT * FROM test ORDER BY x;\n+SELECT name, partition, partition_id FROM system.parts WHERE database = currentDatabase() AND table = 'test' AND active ORDER BY partition;\n+\n+ALTER TABLE test MODIFY COLUMN x Enum8('' = 1); -- { serverError 524 }\n+ALTER TABLE test MODIFY COLUMN x Enum16('' = 1); -- { serverError 524 }\n+\n+ALTER TABLE test MODIFY COLUMN x UInt64; -- { serverError 524 }\n+ALTER TABLE test MODIFY COLUMN x String; -- { serverError 524 }\n+ALTER TABLE test MODIFY COLUMN x Nullable(Int64); -- { serverError 524 }\n+\n+ALTER TABLE test RENAME COLUMN x TO z; -- { serverError 47 }\n+ALTER TABLE test RENAME COLUMN y TO z; -- { serverError 47 }\n+ALTER TABLE test DROP COLUMN x; -- { serverError 47 }\n+ALTER TABLE test DROP COLUMN y; -- { serverError 47 }\n+\n+DROP TABLE test;\ndiff --git a/tests/queries/0_stateless/01346_alter_enum_partition_key_replicated.reference b/tests/queries/0_stateless/01346_alter_enum_partition_key_replicated.reference\nnew file mode 100644\nindex 000000000000..60c6076aef0c\n--- /dev/null\n+++ b/tests/queries/0_stateless/01346_alter_enum_partition_key_replicated.reference\n@@ -0,0 +1,24 @@\n+hello\ttest\n+hello\ttest\n+1_0_0_0\thello\t1\n+1_0_0_0\thello\t1\n+hello\ttest\n+goodbye\ttest\n+hello\ttest\n+goodbye\ttest\n+3_0_0_1\tgoodbye\t3\n+1_0_0_1\thello\t1\n+3_0_0_1\tgoodbye\t3\n+1_0_0_1\thello\t1\n+1\ttest\n+3\ttest\n+111\tabc\n+1\ttest\n+3\ttest\n+111\tabc\n+1_0_0_2\t1\t1\n+111_0_0_1\t111\t111\n+3_0_0_2\t3\t3\n+1_0_0_2\t1\t1\n+111_0_0_1\t111\t111\n+3_0_0_2\t3\t3\ndiff --git a/tests/queries/0_stateless/01346_alter_enum_partition_key_replicated.sql b/tests/queries/0_stateless/01346_alter_enum_partition_key_replicated.sql\nnew file mode 100644\nindex 000000000000..8929fb79d174\n--- /dev/null\n+++ b/tests/queries/0_stateless/01346_alter_enum_partition_key_replicated.sql\n@@ -0,0 +1,48 @@\n+DROP TABLE IF EXISTS test;\n+DROP TABLE IF EXISTS test2;\n+\n+CREATE TABLE test (x Enum('hello' = 1, 'world' = 2), y String) ENGINE = ReplicatedMergeTree('/clickhouse/test/table', 'r1') PARTITION BY x ORDER BY y;\n+CREATE TABLE test2 (x Enum('hello' = 1, 'world' = 2), y String) ENGINE = ReplicatedMergeTree('/clickhouse/test/table', 'r2') PARTITION BY x ORDER BY y;\n+INSERT INTO test VALUES ('hello', 'test');\n+\n+SELECT * FROM test;\n+SYSTEM SYNC REPLICA test2;\n+SELECT * FROM test2;\n+SELECT name, partition, partition_id FROM system.parts WHERE database = currentDatabase() AND table = 'test' AND active ORDER BY partition;\n+SELECT name, partition, partition_id FROM system.parts WHERE database = currentDatabase() AND table = 'test2' AND active ORDER BY partition;\n+\n+ALTER TABLE test MODIFY COLUMN x Enum('hello' = 1, 'world' = 2, 'goodbye' = 3);\n+INSERT INTO test VALUES ('goodbye', 'test');\n+OPTIMIZE TABLE test FINAL;\n+SELECT * FROM test ORDER BY x;\n+SYSTEM SYNC REPLICA test2;\n+SELECT * FROM test2 ORDER BY x;\n+SELECT name, partition, partition_id FROM system.parts WHERE database = currentDatabase() AND table = 'test' AND active ORDER BY partition;\n+SELECT name, partition, partition_id FROM system.parts WHERE database = currentDatabase() AND table = 'test2' AND active ORDER BY partition;\n+\n+ALTER TABLE test MODIFY COLUMN x Enum('hello' = 1, 'world' = 2); -- { serverError 524 }\n+ALTER TABLE test MODIFY COLUMN x Enum('hello' = 1, 'world' = 2, 'test' = 3); -- { serverError 524 }\n+ALTER TABLE test MODIFY COLUMN x Enum('hello' = 1, 'world' = 2, 'goodbye' = 4); -- { serverError 524 }\n+\n+ALTER TABLE test MODIFY COLUMN x Int8;\n+INSERT INTO test VALUES (111, 'abc');\n+OPTIMIZE TABLE test FINAL;\n+SELECT * FROM test ORDER BY x;\n+SYSTEM SYNC REPLICA test2;\n+SELECT * FROM test2 ORDER BY x;\n+SELECT name, partition, partition_id FROM system.parts WHERE database = currentDatabase() AND table = 'test' AND active ORDER BY partition;\n+SELECT name, partition, partition_id FROM system.parts WHERE database = currentDatabase() AND table = 'test2' AND active ORDER BY partition;\n+\n+ALTER TABLE test MODIFY COLUMN x Enum8('' = 1); -- { serverError 524 }\n+ALTER TABLE test MODIFY COLUMN x Enum16('' = 1); -- { serverError 524 }\n+\n+ALTER TABLE test MODIFY COLUMN x UInt64; -- { serverError 524 }\n+ALTER TABLE test MODIFY COLUMN x String; -- { serverError 524 }\n+ALTER TABLE test MODIFY COLUMN x Nullable(Int64); -- { serverError 524 }\n+\n+ALTER TABLE test RENAME COLUMN x TO z; -- { serverError 47 }\n+ALTER TABLE test RENAME COLUMN y TO z; -- { serverError 47 }\n+ALTER TABLE test DROP COLUMN x; -- { serverError 47 }\n+ALTER TABLE test DROP COLUMN y; -- { serverError 47 }\n+\n+DROP TABLE test;\n",
  "problem_statement": "Changes of Enum in partition key don't work\nFrom #2667. thanks @develar  \r\n\r\n```\r\nCREATE TABLE report\r\n(\r\n    `product` Enum8('IU' = 1, 'WS' = 2), \r\n    `machine` String, \r\n    `branch` String, \r\n    `build_c1` String, \r\n    `build_c2` String, \r\n    `build_c3` String, \r\n    `build_time` DateTime, \r\n    `generated_time` DateTime\r\n)\r\nENGINE = MergeTree\r\nPARTITION BY (product, toYYYYMM(generated_time))\r\nORDER BY (product, machine, branch, build_c1, build_c2, build_c3, build_time, generated_time)\r\nSETTINGS old_parts_lifetime = 10;\r\n\r\nalter table report modify column product Enum8('IU' = 1, 'WS' = 2, 'PS' = 3);\r\n```\r\n\r\nGot:\r\n```\r\nReceived exception from server (version 19.16.1):\r\nCode: 44. DB::Exception: Received from localhost:9000. DB::Exception: Trying to ALTER key column product. Stack trace:\r\n\r\n0. 0x55e1ab472d20 StackTrace::StackTrace() /build/obj-x86_64-linux-gnu/../dbms/src/Common/StackTrace.cpp:228\r\n1. 0x55e1ab472af5 DB::Exception::Exception(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, int) /build/obj-x86_64-linux-gnu/../dbms/src/Common/Exception.h:27\r\n2. 0x55e1ab1ff52d DB::MergeTreeData::checkAlter(DB::AlterCommands const&, DB::Context const&) [clone .cold] /usr/include/c++/9/bits/basic_string.h:222\r\n3. 0x55e1aea283af DB::StorageMergeTree::alter(DB::AlterCommands const&, DB::Context const&, DB::TableStructureWriteLockHolder&) /build/obj-x86_64-linux-gnu/../dbms/src/Storages/StorageMergeTree.cpp:273\r\n4. 0x55e1aef5ab33 DB::InterpreterAlterQuery::execute() /usr/include/c++/9/bits/shared_ptr_base.h:729\r\n5. 0x55e1ae917916 DB::executeQueryImpl(char const*, char const*, DB::Context&, bool, DB::QueryProcessingStage::Enum, bool, DB::ReadBuffer*, bool) /build/obj-x86_64-linux-gnu/../dbms/src/Interpreters/executeQuery.cpp:314\r\n6. 0x55e1ae918ade DB::executeQuery(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, DB::Context&, bool, DB::QueryProcessingStage::Enum, bool, bool) /build/obj-x86_64-linux-gnu/../dbms/src/Interpreters/executeQuery.cpp:562\r\n7. 0x55e1ab4fae74 DB::TCPHandler::runImpl() /build/obj-x86_64-linux-gnu/../dbms/programs/server/TCPHandler.cpp:247\r\n8. 0x55e1ab4fb8ab DB::TCPHandler::run() /build/obj-x86_64-linux-gnu/../dbms/programs/server/TCPHandler.cpp:1225\r\n9. 0x55e1af392970 Poco::Net::TCPServerConnection::start() /build/obj-x86_64-linux-gnu/../contrib/poco/Net/src/TCPServerConnection.cpp:57\r\n10. 0x55e1af39308d Poco::Net::TCPServerDispatcher::run() /usr/include/c++/9/bits/atomic_base.h:327\r\n11. 0x55e1b0a69261 Poco::PooledThread::run() /usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h:748\r\n12. 0x55e1b0a6700c Poco::ThreadImpl::runnableEntry(void*) /build/obj-x86_64-linux-gnu/../contrib/poco/Foundation/include/Poco/AutoPtr.h:205\r\n13. 0x55e1b11d8ba0 execute_native_thread_routine /usr/lib/debug/usr/bin/clickhouse\r\n14. 0x7f67701416db start_thread /lib/x86_64-linux-gnu/libpthread-2.27.so\r\n15. 0x7f676fa5e88f clone /build/glibc-OTsEL5/glibc-2.27/misc/../sysdeps/unix/sysv/linux/x86_64/clone.S:97\r\n0 rows in set. Elapsed: 0.147 sec. \r\n```\r\n\r\nmetadata only changes of ORDER BY is allowed:\r\nhttps://github.com/ClickHouse/ClickHouse/commit/9918965c\r\nhttps://github.com/yandex/ClickHouse/blob/master/dbms/tests/queries/0_stateless/00427_alter_primary_key.sh\r\n\r\nBut not for partition key\n",
  "hints_text": "It's actually about solving that TODO: \r\n\r\nhttps://github.com/ClickHouse/ClickHouse/blob/5d8d1df80271c476ef329dfd0295746ef736b8c8/dbms/src/Storages/MergeTree/MergeTreeData.cpp#L1325-L1326\n@alexey-milovidov, So what about this bug/feature?\nbtw, here is right link\r\n[https://github.com/ClickHouse/ClickHouse/blob/master/tests/queries/0_stateless/00427_alter_primary_key.sh](https://github.com/ClickHouse/ClickHouse/blob/master/tests/queries/0_stateless/00427_alter_primary_key.sh)",
  "created_at": "2020-06-25T21:08:23Z",
  "modified_files": [
    "src/DataTypes/DataTypeEnum.cpp",
    "src/DataTypes/DataTypeEnum.h",
    "src/Storages/AlterCommands.cpp",
    "src/Storages/MergeTree/IMergeTreeDataPart.h",
    "src/Storages/MergeTree/MergeTreeData.cpp",
    "src/Storages/MergeTree/MergeTreeData.h",
    "src/Storages/MergeTree/registerStorageMergeTree.cpp",
    "src/Storages/StorageInMemoryMetadata.h",
    "src/Storages/StorageMergeTree.cpp",
    "src/Storages/StorageReplicatedMergeTree.cpp",
    "src/Storages/StorageReplicatedMergeTree.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01344_alter_enum_partition_key.reference",
    "b/tests/queries/0_stateless/01344_alter_enum_partition_key.sql",
    "b/tests/queries/0_stateless/01346_alter_enum_partition_key_replicated.reference",
    "b/tests/queries/0_stateless/01346_alter_enum_partition_key_replicated.sql"
  ]
}