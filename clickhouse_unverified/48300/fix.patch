diff --git a/src/Functions/caseWithExpression.cpp b/src/Functions/caseWithExpression.cpp
index c8b8dbd76cf4..9547cd200b24 100644
--- a/src/Functions/caseWithExpression.cpp
+++ b/src/Functions/caseWithExpression.cpp
@@ -24,6 +24,9 @@ class FunctionCaseWithExpression : public IFunction
 
     explicit FunctionCaseWithExpression(ContextPtr context_) : context(context_) {}
     bool isVariadic() const override { return true; }
+    bool useDefaultImplementationForConstants() const override { return false; }
+    bool useDefaultImplementationForNulls() const override { return false; }
+    bool useDefaultImplementationForNothing() const override { return false; }
     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }
     size_t getNumberOfArguments() const override { return 0; }
     String getName() const override { return name; }
diff --git a/src/Functions/transform.cpp b/src/Functions/transform.cpp
index df0f13ed97ca..33e03b541e98 100644
--- a/src/Functions/transform.cpp
+++ b/src/Functions/transform.cpp
@@ -1,24 +1,26 @@
 #include <mutex>
 #include <base/bit_cast.h>
 
-#include <Common/FieldVisitorDump.h>
-#include <Common/FieldVisitorConvertToNumber.h>
-#include <DataTypes/DataTypeArray.h>
-#include <Columns/ColumnString.h>
 #include <Columns/ColumnArray.h>
 #include <Columns/ColumnConst.h>
-#include <Columns/ColumnsNumber.h>
 #include <Columns/ColumnDecimal.h>
+#include <Columns/ColumnNullable.h>
+#include <Columns/ColumnString.h>
+#include <Columns/ColumnsNumber.h>
+#include <Core/DecimalFunctions.h>
+#include <DataTypes/DataTypeArray.h>
+#include <DataTypes/getLeastSupertype.h>
+#include <Functions/FunctionFactory.h>
+#include <Functions/FunctionHelpers.h>
+#include <Functions/IFunction.h>
+#include <Interpreters/castColumn.h>
+#include <Interpreters/convertFieldToType.h>
+#include <base/StringRef.h>
 #include <Common/Arena.h>
+#include <Common/FieldVisitorConvertToNumber.h>
+#include <Common/FieldVisitorDump.h>
 #include <Common/HashTable/HashMap.h>
 #include <Common/typeid_cast.h>
-#include <base/StringRef.h>
-#include <Functions/IFunction.h>
-#include <Functions/FunctionHelpers.h>
-#include <Functions/FunctionFactory.h>
-#include <DataTypes/getLeastSupertype.h>
-#include <Interpreters/convertFieldToType.h>
-
 
 namespace DB
 {
@@ -32,11 +34,9 @@ namespace ErrorCodes
 
 namespace
 {
-
-/** transform(x, from_array, to_array[, default]) - convert x according to an explicitly passed match.
+    /** transform(x, from_array, to_array[, default]) - convert x according to an explicitly passed match.
   */
-
-/** transform(x, [from...], [to...], default)
+    /** transform(x, [from...], [to...], default)
   * - converts the values according to the explicitly specified mapping.
   *
   * x - what to transform.
@@ -56,1147 +56,658 @@ namespace
   *
   * Note: the implementation is rather cumbersome.
   */
-class FunctionTransform : public IFunction
-{
-public:
-    static constexpr auto name = "transform";
-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionTransform>(); }
-
-    String getName() const override
+    class FunctionTransform : public IFunction
     {
-        return name;
-    }
+    public:
+        static constexpr auto name = "transform";
+        static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionTransform>(); }
 
-    bool isVariadic() const override { return true; }
-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
-    size_t getNumberOfArguments() const override { return 0; }
-    bool useDefaultImplementationForConstants() const override { return true; }
-    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1, 2}; }
-
-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
-    {
-        const auto args_size = arguments.size();
-        if (args_size != 3 && args_size != 4)
-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, "Number of arguments for function {} doesn't match: "
-                "passed {}, should be 3 or 4", getName(), args_size);
+        String getName() const override { return name; }
 
-        const DataTypePtr & type_x = arguments[0];
+        bool isVariadic() const override { return true; }
+        bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
+        size_t getNumberOfArguments() const override { return 0; }
+        bool useDefaultImplementationForConstants() const override { return false; }
+        bool useDefaultImplementationForNulls() const override { return false; }
+        bool useDefaultImplementationForNothing() const override { return false; }
+        ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1, 2}; }
 
-        if (!type_x->isValueRepresentedByNumber() && !isString(type_x))
-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
-                            "Unsupported type {} of first argument "
-                            "of function {}, must be numeric type or Date/DateTime or String",
-                            type_x->getName(), getName());
-
-        const DataTypeArray * type_arr_from = checkAndGetDataType<DataTypeArray>(arguments[1].get());
-
-        if (!type_arr_from)
-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
-                            "Second argument of function {}, must be array of source values to transform from.",
-                            getName());
-
-        const auto type_arr_from_nested = type_arr_from->getNestedType();
-
-        if ((type_x->isValueRepresentedByNumber() != type_arr_from_nested->isValueRepresentedByNumber())
-            || (isString(type_x) != isString(type_arr_from_nested)))
+        DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
         {
-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
-                            "First argument and elements of array "
-                            "of second argument of function {} must have compatible types: "
-                            "both numeric or both strings.", getName());
-        }
-
-        const DataTypeArray * type_arr_to = checkAndGetDataType<DataTypeArray>(arguments[2].get());
-
-        if (!type_arr_to)
-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
-                            "Third argument of function {}, must be array of destination values to transform to.",
-                            getName());
-
-        const DataTypePtr & type_arr_to_nested = type_arr_to->getNestedType();
-
-        if (args_size == 3)
-        {
-            if ((type_x->isValueRepresentedByNumber() != type_arr_to_nested->isValueRepresentedByNumber())
-                || (isString(type_x) != isString(type_arr_to_nested)))
-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Function {} has signature: "
-                                "transform(T, Array(T), Array(U), U) -> U; "
-                                "or transform(T, Array(T), Array(T)) -> T; where T and U are types.", getName());
-
-            return getLeastSupertype(DataTypes{type_x, type_arr_to_nested});
-        }
-        else
-        {
-            const DataTypePtr & type_default = arguments[3];
+            const auto args_size = arguments.size();
+            if (args_size != 3 && args_size != 4)
+                throw Exception(
+                    ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
+                    "Number of arguments for function {} doesn't match: "
+                    "passed {}, should be 3 or 4",
+                    getName(),
+                    args_size);
+
+            const DataTypePtr & type_x = arguments[0];
+            const auto & type_x_nn = removeNullable(type_x);
+
+            if (!type_x_nn->isValueRepresentedByNumber() && !isString(type_x_nn) && !isNothing(type_x_nn))
+                throw Exception(
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                    "Unsupported type {} of first argument "
+                    "of function {}, must be numeric type or Date/DateTime or String",
+                    type_x->getName(),
+                    getName());
+
+            const DataTypeArray * type_arr_from = checkAndGetDataType<DataTypeArray>(arguments[1].get());
+
+            if (!type_arr_from)
+                throw Exception(
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                    "Second argument of function {}, must be array of source values to transform from.",
+                    getName());
+
+            const auto type_arr_from_nested = type_arr_from->getNestedType();
+
+            if ((type_x->isValueRepresentedByNumber() != type_arr_from_nested->isValueRepresentedByNumber())
+                || (isString(type_x) != isString(type_arr_from_nested)))
+            {
+                throw Exception(
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                    "First argument and elements of array "
+                    "of second argument of function {} must have compatible types: "
+                    "both numeric or both strings.",
+                    getName());
+            }
 
-            if (!type_default->isValueRepresentedByNumber() && !isString(type_default))
-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
-                                "Unsupported type {} of fourth argument (default value) "
-                                "of function {}, must be numeric type or Date/DateTime or String",
-                                type_default->getName(), getName());
+            const DataTypeArray * type_arr_to = checkAndGetDataType<DataTypeArray>(arguments[2].get());
 
-            bool default_is_string = WhichDataType(type_default).isString();
-            bool nested_is_string = WhichDataType(type_arr_to_nested).isString();
+            if (!type_arr_to)
+                throw Exception(
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                    "Third argument of function {}, must be array of destination values to transform to.",
+                    getName());
 
-            if ((type_default->isValueRepresentedByNumber() != type_arr_to_nested->isValueRepresentedByNumber())
-                || (default_is_string != nested_is_string))
-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Function {} have signature: "
-                                "transform(T, Array(T), Array(U), U) -> U; "
-                                "or transform(T, Array(T), Array(T)) -> T; where T and U are types.", getName());
+            const DataTypePtr & type_arr_to_nested = type_arr_to->getNestedType();
 
-            if (type_arr_to_nested->isValueRepresentedByNumber() && type_default->isValueRepresentedByNumber())
+            if (args_size == 3)
             {
-                /// We take the smallest common type for the elements of the array of values `to` and for `default`.
-                return getLeastSupertype(DataTypes{type_arr_to_nested, type_default});
+                if ((type_x->isValueRepresentedByNumber() != type_arr_to_nested->isValueRepresentedByNumber())
+                    || (isString(type_x) != isString(type_arr_to_nested)))
+                    throw Exception(
+                        ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                        "Function {} has signature: "
+                        "transform(T, Array(T), Array(U), U) -> U; "
+                        "or transform(T, Array(T), Array(T)) -> T; where T and U are types.",
+                        getName());
+
+                auto ret = tryGetLeastSupertype(DataTypes{type_arr_to_nested, type_x});
+                if (!ret)
+                    throw Exception(
+                        ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                        "Function {} has signature: "
+                        "transform(T, Array(T), Array(U), U) -> U; "
+                        "or transform(T, Array(T), Array(T)) -> T; where T and U are types.",
+                        getName());
+                checkAllowedType(ret);
+                return ret;
+            }
+            else
+            {
+                auto ret = tryGetLeastSupertype(DataTypes{type_arr_to_nested, arguments[3]});
+                if (!ret)
+                    throw Exception(
+                        ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                        "Function {} have signature: "
+                        "transform(T, Array(T), Array(U), U) -> U; "
+                        "or transform(T, Array(T), Array(T)) -> T; where T and U are types.",
+                        getName());
+                checkAllowedType(ret);
+                return ret;
             }
-
-            /// TODO More checks.
-            return type_arr_to_nested;
         }
-    }
 
-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override
-    {
-        const ColumnConst * array_from = checkAndGetColumnConst<ColumnArray>(arguments[1].column.get());
-        const ColumnConst * array_to = checkAndGetColumnConst<ColumnArray>(arguments[2].column.get());
-
-        if (!array_from || !array_to)
-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Second and third arguments of function {} must be constant arrays.", getName());
-
-        initialize(array_from->getValue<Array>(), array_to->getValue<Array>(), arguments);
-
-        const auto * in = arguments.front().column.get();
-
-        if (isColumnConst(*in))
-            return executeConst(arguments, result_type, input_rows_count);
-
-        const IColumn * default_column = nullptr;
-        if (arguments.size() == 4)
-            default_column = arguments[3].column.get();
-
-        auto column_result = result_type->createColumn();
-        auto * out = column_result.get();
-
-        if (!executeNum<UInt8>(in, out, default_column)
-            && !executeNum<UInt16>(in, out, default_column)
-            && !executeNum<UInt32>(in, out, default_column)
-            && !executeNum<UInt64>(in, out, default_column)
-            && !executeNum<Int8>(in, out, default_column)
-            && !executeNum<Int16>(in, out, default_column)
-            && !executeNum<Int32>(in, out, default_column)
-            && !executeNum<Int64>(in, out, default_column)
-            && !executeNum<Float32>(in, out, default_column)
-            && !executeNum<Float64>(in, out, default_column)
-            && !executeDecimal<Decimal32>(in, out, default_column)
-            && !executeDecimal<Decimal64>(in, out, default_column)
-            && !executeString(in, out, default_column))
+        ColumnPtr
+        executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override
         {
-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of first argument of function {}", in->getName(), getName());
+            initialize(arguments, result_type);
+
+            const auto * in = arguments.front().column.get();
+
+            if (isColumnConst(*in))
+                return executeConst(arguments, result_type, input_rows_count);
+
+            ColumnPtr default_non_const;
+            if (!cache.default_column && arguments.size() == 4)
+                default_non_const = castColumn(arguments[3], result_type);
+
+            auto column_result = result_type->createColumn();
+            if (!executeNum<ColumnVector<UInt8>>(in, *column_result, default_non_const)
+                && !executeNum<ColumnVector<UInt16>>(in, *column_result, default_non_const)
+                && !executeNum<ColumnVector<UInt32>>(in, *column_result, default_non_const)
+                && !executeNum<ColumnVector<UInt64>>(in, *column_result, default_non_const)
+                && !executeNum<ColumnVector<Int8>>(in, *column_result, default_non_const)
+                && !executeNum<ColumnVector<Int16>>(in, *column_result, default_non_const)
+                && !executeNum<ColumnVector<Int32>>(in, *column_result, default_non_const)
+                && !executeNum<ColumnVector<Int64>>(in, *column_result, default_non_const)
+                && !executeNum<ColumnVector<Float32>>(in, *column_result, default_non_const)
+                && !executeNum<ColumnVector<Float64>>(in, *column_result, default_non_const)
+                && !executeNum<ColumnDecimal<Decimal32>>(in, *column_result, default_non_const)
+                && !executeNum<ColumnDecimal<Decimal64>>(in, *column_result, default_non_const)
+                && !executeString(in, *column_result, default_non_const))
+            {
+                throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of first argument of function {}", in->getName(), getName());
+            }
+            return column_result;
         }
 
-        return column_result;
-    }
-
-private:
-    static ColumnPtr executeConst(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count)
-    {
-        /// Materialize the input column and compute the function as usual.
+    private:
+        static ColumnPtr executeConst(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count)
+        {
+            /// Materialize the input column and compute the function as usual.
 
-        ColumnsWithTypeAndName args = arguments;
-        args[0].column = args[0].column->cloneResized(input_rows_count)->convertToFullColumnIfConst();
+            ColumnsWithTypeAndName args = arguments;
+            args[0].column = args[0].column->cloneResized(input_rows_count)->convertToFullColumnIfConst();
 
-        auto impl = FunctionToOverloadResolverAdaptor(std::make_shared<FunctionTransform>()).build(args);
+            auto impl = FunctionToOverloadResolverAdaptor(std::make_shared<FunctionTransform>()).build(args);
 
-        return impl->execute(args, result_type, input_rows_count);
-    }
+            return impl->execute(args, result_type, input_rows_count);
+        }
 
-    template <typename T>
-    bool executeNum(const IColumn * in_untyped, IColumn * out_untyped, const IColumn * default_untyped) const
-    {
-        if (const auto in = checkAndGetColumn<ColumnVector<T>>(in_untyped))
+        template <typename T>
+        bool executeNum(const IColumn * in_untyped, IColumn & column_result, const ColumnPtr default_non_const) const
         {
-            if (!default_untyped)
+            const auto * const in = checkAndGetColumn<T>(in_untyped);
+            if (!in)
+                return false;
+            const auto & pod = in->getData();
+            UInt32 in_scale = 0;
+            if constexpr (std::is_same_v<ColumnDecimal<Decimal32>, T> || std::is_same_v<ColumnDecimal<Decimal64>, T>)
+                in_scale = in->getScale();
+
+            if (!executeNumToString(pod, column_result, default_non_const)
+                && !executeNumToNum<ColumnVector<UInt8>>(pod, column_result, default_non_const, in_scale)
+                && !executeNumToNum<ColumnVector<UInt16>>(pod, column_result, default_non_const, in_scale)
+                && !executeNumToNum<ColumnVector<UInt32>>(pod, column_result, default_non_const, in_scale)
+                && !executeNumToNum<ColumnVector<UInt64>>(pod, column_result, default_non_const, in_scale)
+                && !executeNumToNum<ColumnVector<Int8>>(pod, column_result, default_non_const, in_scale)
+                && !executeNumToNum<ColumnVector<Int16>>(pod, column_result, default_non_const, in_scale)
+                && !executeNumToNum<ColumnVector<Int32>>(pod, column_result, default_non_const, in_scale)
+                && !executeNumToNum<ColumnVector<Int64>>(pod, column_result, default_non_const, in_scale)
+                && !executeNumToNum<ColumnVector<Float32>>(pod, column_result, default_non_const, in_scale)
+                && !executeNumToNum<ColumnVector<Float64>>(pod, column_result, default_non_const, in_scale)
+                && !executeNumToNum<ColumnDecimal<Decimal32>>(pod, column_result, default_non_const, in_scale)
+                && !executeNumToNum<ColumnDecimal<Decimal64>>(pod, column_result, default_non_const, in_scale))
             {
-                auto out = typeid_cast<ColumnVector<T> *>(out_untyped);
-                if (!out)
+                const size_t size = pod.size();
+                const auto & table = *cache.table_num_to_idx;
+                column_result.reserve(size);
+                for (size_t i = 0; i < size; ++i)
                 {
-                    throw Exception(ErrorCodes::ILLEGAL_COLUMN,
-                                    "Illegal column {} of elements "
-                                    "of array of third argument of function {}, must be {}",
-                                    out_untyped->getName(), getName(), in->getName());
+                    const auto * it = table.find(bit_cast<UInt64>(pod[i]));
+                    if (it)
+                        column_result.insertFrom(*cache.to_columns, it->getMapped());
+                    else if (cache.default_column)
+                        column_result.insertFrom(*cache.default_column, 0);
+                    else if (default_non_const)
+                        column_result.insertFrom(*default_non_const, i);
+                    else
+                        column_result.insertFrom(*in, i);
                 }
-
-                executeImplNumToNum<T>(in->getData(), out->getData());
             }
-            else if (isColumnConst(*default_untyped))
+            return true;
+        }
+
+        template <typename T>
+        bool executeNumToString(const PaddedPODArray<T> & pod, IColumn & column_result, const ColumnPtr default_non_const) const
+        {
+            auto * out = typeid_cast<ColumnString *>(&column_result);
+            if (!out)
+                return false;
+            auto & out_offs = out->getOffsets();
+            const size_t size = pod.size();
+            out_offs.resize(size);
+            auto & out_chars = out->getChars();
+
+            const auto * to_col = reinterpret_cast<const ColumnString *>(cache.to_columns.get());
+            const auto & to_chars = to_col->getChars();
+            const auto & to_offs = to_col->getOffsets();
+            const auto & table = *cache.table_num_to_idx;
+
+            if (cache.default_column)
             {
-                if (!executeNumToNumWithConstDefault<T, UInt8>(in, out_untyped)
-                    && !executeNumToNumWithConstDefault<T, UInt16>(in, out_untyped)
-                    && !executeNumToNumWithConstDefault<T, UInt32>(in, out_untyped)
-                    && !executeNumToNumWithConstDefault<T, UInt64>(in, out_untyped)
-                    && !executeNumToNumWithConstDefault<T, Int8>(in, out_untyped)
-                    && !executeNumToNumWithConstDefault<T, Int16>(in, out_untyped)
-                    && !executeNumToNumWithConstDefault<T, Int32>(in, out_untyped)
-                    && !executeNumToNumWithConstDefault<T, Int64>(in, out_untyped)
-                    && !executeNumToNumWithConstDefault<T, Float32>(in, out_untyped)
-                    && !executeNumToNumWithConstDefault<T, Float64>(in, out_untyped)
-                    && !executeNumToDecimalWithConstDefault<T, Decimal32>(in, out_untyped)
-                    && !executeNumToDecimalWithConstDefault<T, Decimal64>(in, out_untyped)
-                    && !executeNumToStringWithConstDefault<T>(in, out_untyped))
-                {
-                    throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of elements of array of second argument of function {}",
-                        in->getName(), getName());
-                }
+                const auto * def = reinterpret_cast<const ColumnString *>(cache.default_column.get());
+                const auto & def_chars = def->getChars();
+                const auto & def_offs = def->getOffsets();
+                const auto * def_data = def_chars.data();
+                auto def_size = def_offs[0];
+                executeNumToStringHelper(table, pod, out_chars, out_offs, to_chars, to_offs, def_data, def_size, size);
             }
             else
             {
-                if (!executeNumToNumWithNonConstDefault<T, UInt8>(in, out_untyped, default_untyped)
-                    && !executeNumToNumWithNonConstDefault<T, UInt16>(in, out_untyped, default_untyped)
-                    && !executeNumToNumWithNonConstDefault<T, UInt32>(in, out_untyped, default_untyped)
-                    && !executeNumToNumWithNonConstDefault<T, UInt64>(in, out_untyped, default_untyped)
-                    && !executeNumToNumWithNonConstDefault<T, Int8>(in, out_untyped, default_untyped)
-                    && !executeNumToNumWithNonConstDefault<T, Int16>(in, out_untyped, default_untyped)
-                    && !executeNumToNumWithNonConstDefault<T, Int32>(in, out_untyped, default_untyped)
-                    && !executeNumToNumWithNonConstDefault<T, Int64>(in, out_untyped, default_untyped)
-                    && !executeNumToNumWithNonConstDefault<T, Float32>(in, out_untyped, default_untyped)
-                    && !executeNumToNumWithNonConstDefault<T, Float64>(in, out_untyped, default_untyped)
-                    && !executeNumToDecimalWithNonConstDefault<T, Decimal32>(in, out_untyped, default_untyped)
-                    && !executeNumToDecimalWithNonConstDefault<T, Decimal64>(in, out_untyped, default_untyped)
-                    && !executeNumToStringWithNonConstDefault<T>(in, out_untyped, default_untyped))
-                {
-                    throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of elements of array of second argument of function {}",
-                        in->getName(), getName());
-                }
+                const auto * def = reinterpret_cast<const ColumnString *>(default_non_const.get());
+                const auto & def_chars = def->getChars();
+                const auto & def_offs = def->getOffsets();
+                executeNumToStringHelper(table, pod, out_chars, out_offs, to_chars, to_offs, def_chars, def_offs, size);
             }
-
             return true;
         }
 
-        return false;
-    }
-
-    template <typename T>
-    bool executeDecimal(const IColumn * in_untyped, IColumn * out_untyped, const IColumn * default_untyped) const
-    {
-        if (const auto in = checkAndGetColumn<ColumnDecimal<T>>(in_untyped))
+        template <typename Table, typename In, typename DefData, typename DefOffs>
+        void executeNumToStringHelper(
+            const Table & table,
+            const PaddedPODArray<In> & pod,
+            ColumnString::Chars & out_data,
+            ColumnString::Offsets & out_offsets,
+            const ColumnString::Chars & to_data,
+            const ColumnString::Offsets & to_offsets,
+            const DefData & def_data,
+            const DefOffs & def_offsets,
+            const size_t size) const
         {
-            if (!default_untyped)
+            size_t out_cur_off = 0;
+            for (size_t i = 0; i < size; ++i)
             {
-                auto out = typeid_cast<ColumnDecimal<T> *>(out_untyped);
-                if (!out)
+                const char8_t * to = nullptr;
+                size_t to_size = 0;
+                const auto * it = table.find(bit_cast<UInt64>(pod[i]));
+                if (it)
                 {
-                    throw Exception(ErrorCodes::ILLEGAL_COLUMN,
-                                    "Illegal column {} of elements "
-                                    "of array of third argument of function {}, must be {}",
-                                    out_untyped->getName(), getName(), in->getName());
+                    const auto idx = it->getMapped();
+                    const auto start = to_offsets[idx - 1];
+                    to = &to_data[start];
+                    to_size = to_offsets[idx] - start;
                 }
-
-                executeImplNumToNum<T>(in->getData(), out->getData());
-            }
-            else if (isColumnConst(*default_untyped))
-            {
-                if (!executeDecimalToNumWithConstDefault<T, UInt8>(in, out_untyped)
-                    && !executeDecimalToNumWithConstDefault<T, UInt16>(in, out_untyped)
-                    && !executeDecimalToNumWithConstDefault<T, UInt32>(in, out_untyped)
-                    && !executeDecimalToNumWithConstDefault<T, UInt64>(in, out_untyped)
-                    && !executeDecimalToNumWithConstDefault<T, Int8>(in, out_untyped)
-                    && !executeDecimalToNumWithConstDefault<T, Int16>(in, out_untyped)
-                    && !executeDecimalToNumWithConstDefault<T, Int32>(in, out_untyped)
-                    && !executeDecimalToNumWithConstDefault<T, Int64>(in, out_untyped)
-                    && !executeDecimalToNumWithConstDefault<T, Float32>(in, out_untyped)
-                    && !executeDecimalToNumWithConstDefault<T, Float64>(in, out_untyped)
-                    && !executeDecimalToDecimalWithConstDefault<T, Decimal32>(in, out_untyped)
-                    && !executeDecimalToDecimalWithConstDefault<T, Decimal64>(in, out_untyped)
-                    && !executeDecimalToStringWithConstDefault<T>(in, out_untyped))
+                else if constexpr (std::is_same_v<DefData, ColumnString::Chars>)
                 {
-                    throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of elements of array of second argument of function {}",
-                                    in->getName(), getName());
+                    const auto start = def_offsets[i - 1];
+                    to = &def_data[start];
+                    to_size = def_offsets[i] - start;
                 }
-            }
-            else
-            {
-                if (!executeDecimalToNumWithNonConstDefault<T, UInt8>(in, out_untyped, default_untyped)
-                    && !executeDecimalToNumWithNonConstDefault<T, UInt16>(in, out_untyped, default_untyped)
-                    && !executeDecimalToNumWithNonConstDefault<T, UInt32>(in, out_untyped, default_untyped)
-                    && !executeDecimalToNumWithNonConstDefault<T, UInt64>(in, out_untyped, default_untyped)
-                    && !executeDecimalToNumWithNonConstDefault<T, Int8>(in, out_untyped, default_untyped)
-                    && !executeDecimalToNumWithNonConstDefault<T, Int16>(in, out_untyped, default_untyped)
-                    && !executeDecimalToNumWithNonConstDefault<T, Int32>(in, out_untyped, default_untyped)
-                    && !executeDecimalToNumWithNonConstDefault<T, Int64>(in, out_untyped, default_untyped)
-                    && !executeDecimalToNumWithNonConstDefault<T, Float32>(in, out_untyped, default_untyped)
-                    && !executeDecimalToNumWithNonConstDefault<T, Float64>(in, out_untyped, default_untyped)
-                    && !executeDecimalToDecimalWithNonConstDefault<T, Decimal32>(in, out_untyped, default_untyped)
-                    && !executeDecimalToDecimalWithNonConstDefault<T, Decimal64>(in, out_untyped, default_untyped)
-                    && !executeDecimalToStringWithNonConstDefault<T>(in, out_untyped, default_untyped))
+                else
                 {
-                    throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of elements of array of second argument of function {}",
-                                    in->getName(), getName());
+                    to = def_data;
+                    to_size = def_offsets;
                 }
+                out_data.resize(out_cur_off + to_size);
+                memcpy(&out_data[out_cur_off], to, to_size);
+                out_cur_off += to_size;
+                out_offsets[i] = out_cur_off;
             }
-
-            return true;
         }
 
-        return false;
-    }
-
-    bool executeString(const IColumn * in_untyped, IColumn * out_untyped, const IColumn * default_untyped) const
-    {
-        if (const auto * in = checkAndGetColumn<ColumnString>(in_untyped))
+        template <typename T, typename U>
+        bool executeNumToNum(
+            const PaddedPODArray<U> & pod, IColumn & column_result, const ColumnPtr default_non_const, const UInt32 in_scale) const
         {
-            if (!default_untyped)
+            auto * out = typeid_cast<T *>(&column_result);
+            if (!out)
+                return false;
+            auto & out_pod = out->getData();
+            const size_t size = pod.size();
+            out_pod.resize(size);
+            UInt32 out_scale = 0;
+            if constexpr (std::is_same_v<ColumnDecimal<Decimal32>, T> || std::is_same_v<ColumnDecimal<Decimal64>, T>)
+                out_scale = out->getScale();
+
+            const auto & to_pod = reinterpret_cast<const T *>(cache.to_columns.get())->getData();
+            const auto & table = *cache.table_num_to_idx;
+            if (cache.default_column)
             {
-                if (!executeStringToString(in, out_untyped))
-                    throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of elements of array of second argument of function {}",
-                        in->getName(), getName());
+                const auto const_def = reinterpret_cast<const T *>(cache.default_column.get())->getData()[0];
+                executeNumToNumHelper(table, pod, out_pod, to_pod, const_def, size, out_scale, out_scale);
             }
-            else if (isColumnConst(*default_untyped))
+            else if (default_non_const)
             {
-                if (!executeStringToNumWithConstDefault<UInt8>(in, out_untyped)
-                    && !executeStringToNumWithConstDefault<UInt16>(in, out_untyped)
-                    && !executeStringToNumWithConstDefault<UInt32>(in, out_untyped)
-                    && !executeStringToNumWithConstDefault<UInt64>(in, out_untyped)
-                    && !executeStringToNumWithConstDefault<Int8>(in, out_untyped)
-                    && !executeStringToNumWithConstDefault<Int16>(in, out_untyped)
-                    && !executeStringToNumWithConstDefault<Int32>(in, out_untyped)
-                    && !executeStringToNumWithConstDefault<Int64>(in, out_untyped)
-                    && !executeStringToNumWithConstDefault<Float32>(in, out_untyped)
-                    && !executeStringToNumWithConstDefault<Float64>(in, out_untyped)
-                    && !executeStringToDecimalWithConstDefault<Decimal32>(in, out_untyped)
-                    && !executeStringToDecimalWithConstDefault<Decimal64>(in, out_untyped)
-                    && !executeStringToStringWithConstDefault(in, out_untyped))
-                {
-                    throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of elements of array of second argument of function {}",
-                        in->getName(), getName());
-                }
+                const auto & nconst_def = reinterpret_cast<const T *>(default_non_const.get())->getData();
+                executeNumToNumHelper(table, pod, out_pod, to_pod, nconst_def, size, out_scale, out_scale);
             }
             else
-            {
-                if (!executeStringToNumWithNonConstDefault<UInt8>(in, out_untyped, default_untyped)
-                    && !executeStringToNumWithNonConstDefault<UInt16>(in, out_untyped, default_untyped)
-                    && !executeStringToNumWithNonConstDefault<UInt32>(in, out_untyped, default_untyped)
-                    && !executeStringToNumWithNonConstDefault<UInt64>(in, out_untyped, default_untyped)
-                    && !executeStringToNumWithNonConstDefault<Int8>(in, out_untyped, default_untyped)
-                    && !executeStringToNumWithNonConstDefault<Int16>(in, out_untyped, default_untyped)
-                    && !executeStringToNumWithNonConstDefault<Int32>(in, out_untyped, default_untyped)
-                    && !executeStringToNumWithNonConstDefault<Int64>(in, out_untyped, default_untyped)
-                    && !executeStringToNumWithNonConstDefault<Float32>(in, out_untyped, default_untyped)
-                    && !executeStringToNumWithNonConstDefault<Float64>(in, out_untyped, default_untyped)
-                    && !executeStringToDecimalWithNonConstDefault<Decimal32>(in, out_untyped, default_untyped)
-                    && !executeStringToDecimalWithNonConstDefault<Decimal64>(in, out_untyped, default_untyped)
-
-                    && !executeStringToStringWithNonConstDefault(in, out_untyped, default_untyped))
-                {
-                    throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of elements of array of second argument of function {}",
-                        in->getName(), getName());
-                }
-            }
-
+                executeNumToNumHelper(table, pod, out_pod, to_pod, pod, size, out_scale, in_scale);
             return true;
         }
 
-        return false;
-    }
-
-    template <typename T, typename U>
-    bool executeNumToNumWithConstDefault(const ColumnVector<T> * in, IColumn * out_untyped) const
-    {
-        auto out = typeid_cast<ColumnVector<U> *>(out_untyped);
-        if (!out)
-            return false;
-
-        executeImplNumToNumWithConstDefault<T, U>(in->getData(), out->getData(), static_cast<U>(cache.const_default_value.get<U>()));
-        return true;
-    }
-
-    template <typename T, typename U>
-    bool executeNumToDecimalWithConstDefault(const ColumnVector<T> * in, IColumn * out_untyped) const
-    {
-        auto out = typeid_cast<ColumnDecimal<U> *>(out_untyped);
-        if (!out)
-            return false;
-
-        executeImplNumToNumWithConstDefault<T, U>(in->getData(), out->getData(), cache.const_default_value.get<U>());
-        return true;
-    }
-
-
-    template <typename T, typename U>
-    bool executeDecimalToNumWithConstDefault(const ColumnDecimal<T> * in, IColumn * out_untyped) const
-    {
-        auto out = typeid_cast<ColumnVector<U> *>(out_untyped);
-        if (!out)
-            return false;
-
-        executeImplNumToNumWithConstDefault<T, U>(in->getData(), out->getData(), static_cast<U>(cache.const_default_value.get<U>()));
-        return true;
-    }
-
-    template <typename T, typename U>
-    bool executeDecimalToDecimalWithConstDefault(const ColumnDecimal<T> * in, IColumn * out_untyped) const
-    {
-        auto out = typeid_cast<ColumnDecimal<U> *>(out_untyped);
-        if (!out)
-            return false;
-
-        executeImplNumToNumWithConstDefault<T, U>(in->getData(), out->getData(), cache.const_default_value.get<U>());
-        return true;
-    }
-
-    template <typename T, typename U>
-    bool executeNumToNumWithNonConstDefault(const ColumnVector<T> * in, IColumn * out_untyped, const IColumn * default_untyped) const
-    {
-        auto out = typeid_cast<ColumnVector<U> *>(out_untyped);
-        if (!out)
-            return false;
-
-        if (!executeNumToNumWithNonConstDefault2<T, U, UInt8>(in, out, default_untyped)
-            && !executeNumToNumWithNonConstDefault2<T, U, UInt16>(in, out, default_untyped)
-            && !executeNumToNumWithNonConstDefault2<T, U, UInt32>(in, out, default_untyped)
-            && !executeNumToNumWithNonConstDefault2<T, U, UInt64>(in, out, default_untyped)
-            && !executeNumToNumWithNonConstDefault2<T, U, Int8>(in, out, default_untyped)
-            && !executeNumToNumWithNonConstDefault2<T, U, Int16>(in, out, default_untyped)
-            && !executeNumToNumWithNonConstDefault2<T, U, Int32>(in, out, default_untyped)
-            && !executeNumToNumWithNonConstDefault2<T, U, Int64>(in, out, default_untyped)
-            && !executeNumToNumWithNonConstDefault2<T, U, Float32>(in, out, default_untyped)
-            && !executeNumToNumWithNonConstDefault2<T, U, Float64>(in, out, default_untyped))
-        {
-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of fourth argument of function {}",
-                default_untyped->getName(), getName());
-        }
-
-        return true;
-    }
-
-    template <typename T, typename U>
-    bool executeNumToDecimalWithNonConstDefault(const ColumnVector<T> * in, IColumn * out_untyped, const IColumn * default_untyped) const
-    {
-        auto out = typeid_cast<ColumnDecimal<U> *>(out_untyped);
-        if (!out)
-            return false;
-
-        if (!executeNumToDecimalWithNonConstDefault2<T, U, UInt8>(in, out, default_untyped)
-            && !executeNumToDecimalWithNonConstDefault2<T, U, UInt16>(in, out, default_untyped)
-            && !executeNumToDecimalWithNonConstDefault2<T, U, UInt32>(in, out, default_untyped)
-            && !executeNumToDecimalWithNonConstDefault2<T, U, UInt64>(in, out, default_untyped)
-            && !executeNumToDecimalWithNonConstDefault2<T, U, Int8>(in, out, default_untyped)
-            && !executeNumToDecimalWithNonConstDefault2<T, U, Int16>(in, out, default_untyped)
-            && !executeNumToDecimalWithNonConstDefault2<T, U, Int32>(in, out, default_untyped)
-            && !executeNumToDecimalWithNonConstDefault2<T, U, Int64>(in, out, default_untyped)
-            && !executeNumToDecimalWithNonConstDefault2<T, U, Float32>(in, out, default_untyped)
-            && !executeNumToDecimalWithNonConstDefault2<T, U, Float64>(in, out, default_untyped)
-            && !executeNumToDecimalWithNonConstDefaultDecimal2<T, U, Decimal32>(in, out, default_untyped)
-            && !executeNumToDecimalWithNonConstDefaultDecimal2<T, U, Decimal64>(in, out, default_untyped))
-        {
-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of fourth argument of function {}",
-                default_untyped->getName(), getName());
-        }
-
-        return true;
-    }
-
-    template <typename T, typename U>
-    bool executeDecimalToNumWithNonConstDefault(const ColumnDecimal<T> * in, IColumn * out_untyped, const IColumn * default_untyped) const
-    {
-        auto out = typeid_cast<ColumnVector<U> *>(out_untyped);
-        if (!out)
-            return false;
-
-        if (!executeDecimalToNumWithNonConstDefault2<T, U, UInt8>(in, out, default_untyped)
-            && !executeDecimalToNumWithNonConstDefault2<T, U, UInt16>(in, out, default_untyped)
-            && !executeDecimalToNumWithNonConstDefault2<T, U, UInt32>(in, out, default_untyped)
-            && !executeDecimalToNumWithNonConstDefault2<T, U, UInt64>(in, out, default_untyped)
-            && !executeDecimalToNumWithNonConstDefault2<T, U, Int8>(in, out, default_untyped)
-            && !executeDecimalToNumWithNonConstDefault2<T, U, Int16>(in, out, default_untyped)
-            && !executeDecimalToNumWithNonConstDefault2<T, U, Int32>(in, out, default_untyped)
-            && !executeDecimalToNumWithNonConstDefault2<T, U, Int64>(in, out, default_untyped)
-            && !executeDecimalToNumWithNonConstDefault2<T, U, Float32>(in, out, default_untyped)
-            && !executeDecimalToNumWithNonConstDefault2<T, U, Float64>(in, out, default_untyped)
-            && !executeDecimalToNumWithNonConstDefaultDecimal2<T, U, Decimal32>(in, out, default_untyped)
-            && !executeDecimalToNumWithNonConstDefaultDecimal2<T, U, Decimal64>(in, out, default_untyped))
-        {
-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of fourth argument of function {}",
-                default_untyped->getName(), getName());
-        }
-
-        return true;
-    }
-
-    template <typename T, typename U>
-    bool executeDecimalToDecimalWithNonConstDefault(const ColumnDecimal<T> * in, IColumn * out_untyped, const IColumn * default_untyped) const
-    {
-        auto out = typeid_cast<ColumnDecimal<U> *>(out_untyped);
-        if (!out)
-            return false;
-
-        if (!executeDecimalToDecimalWithNonConstDefault2<T, U, UInt8>(in, out, default_untyped)
-            && !executeDecimalToDecimalWithNonConstDefault2<T, U, UInt16>(in, out, default_untyped)
-            && !executeDecimalToDecimalWithNonConstDefault2<T, U, UInt32>(in, out, default_untyped)
-            && !executeDecimalToDecimalWithNonConstDefault2<T, U, UInt64>(in, out, default_untyped)
-            && !executeDecimalToDecimalWithNonConstDefault2<T, U, Int8>(in, out, default_untyped)
-            && !executeDecimalToDecimalWithNonConstDefault2<T, U, Int16>(in, out, default_untyped)
-            && !executeDecimalToDecimalWithNonConstDefault2<T, U, Int32>(in, out, default_untyped)
-            && !executeDecimalToDecimalWithNonConstDefault2<T, U, Int64>(in, out, default_untyped)
-            && !executeDecimalToDecimalWithNonConstDefault2<T, U, Float32>(in, out, default_untyped)
-            && !executeDecimalToDecimalWithNonConstDefault2<T, U, Float64>(in, out, default_untyped)
-            && !executeDecimalToDecimalWithNonConstDefaultDecimal2<T, U, Decimal32>(in, out, default_untyped)
-            && !executeDecimalToDecimalWithNonConstDefaultDecimal2<T, U, Decimal64>(in, out, default_untyped))
+        template <typename Table, typename In, typename Out, typename Def>
+        void executeNumToNumHelper(
+            const Table & table,
+            const PaddedPODArray<In> & pod,
+            PaddedPODArray<Out> & out_pod,
+            const PaddedPODArray<Out> & to_pod,
+            const Def & def,
+            const size_t size,
+            const UInt32 out_scale,
+            const UInt32 def_scale) const
         {
-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of fourth argument of function {}",
-                default_untyped->getName(), getName());
-        }
-
-        return true;
-    }
-
-    template <typename T, typename U, typename V>
-    bool executeNumToNumWithNonConstDefault2(const ColumnVector<T> * in, ColumnVector<U> * out, const IColumn * default_untyped) const
-    {
-        auto col_default = checkAndGetColumn<ColumnVector<V>>(default_untyped);
-        if (!col_default)
-            return false;
-
-        executeImplNumToNumWithNonConstDefault<T, U, V>(in->getData(), out->getData(), col_default->getData());
-        return true;
-    }
-
-    template <typename T, typename U, typename V>
-    bool executeNumToDecimalWithNonConstDefault2(const ColumnVector<T> * in, ColumnDecimal<U> * out, const IColumn * default_untyped) const
-    {
-        auto col_default = checkAndGetColumn<ColumnVector<V>>(default_untyped);
-        if (!col_default)
-            return false;
-
-        executeImplNumToNumWithNonConstDefault<T, U, V>(in->getData(), out->getData(), col_default->getData());
-        return true;
-    }
-
-    template <typename T, typename U, typename V>
-    bool executeNumToDecimalWithNonConstDefaultDecimal2(const ColumnVector<T> * in, ColumnDecimal<U> * out, const IColumn * default_untyped) const
-    {
-        auto col_default = checkAndGetColumn<ColumnDecimal<V>>(default_untyped);
-        if (!col_default)
-            return false;
-
-        executeImplNumToNumWithNonConstDefault<T, U, V>(in->getData(), out->getData(), col_default->getData());
-        return true;
-    }
-
-    template <typename T, typename U, typename V>
-    bool executeDecimalToNumWithNonConstDefault2(const ColumnDecimal<T> * in, ColumnVector<U> * out, const IColumn * default_untyped) const
-    {
-        auto col_default = checkAndGetColumn<ColumnVector<V>>(default_untyped);
-        if (!col_default)
-            return false;
-
-        executeImplNumToNumWithNonConstDefault<T, U, V>(in->getData(), out->getData(), col_default->getData());
-        return true;
-    }
-
-    template <typename T, typename U, typename V>
-    bool executeDecimalToDecimalWithNonConstDefault2(const ColumnDecimal<T> * in, ColumnDecimal<U> * out, const IColumn * default_untyped) const
-    {
-        auto col_default = checkAndGetColumn<ColumnVector<V>>(default_untyped);
-        if (!col_default)
-            return false;
-
-        executeImplNumToNumWithNonConstDefault<T, U, V>(in->getData(), out->getData(), col_default->getData());
-        return true;
-    }
-
-    template <typename T, typename U, typename V>
-    bool executeDecimalToNumWithNonConstDefaultDecimal2(const ColumnDecimal<T> * in, ColumnVector<U> * out, const IColumn * default_untyped) const
-    {
-        auto col_default = checkAndGetColumn<ColumnDecimal<V>>(default_untyped);
-        if (!col_default)
-            return false;
-
-        executeImplNumToNumWithNonConstDefault<T, U, V>(in->getData(), out->getData(), col_default->getData());
-        return true;
-    }
-
-    template <typename T, typename U, typename V>
-    bool executeDecimalToDecimalWithNonConstDefaultDecimal2(const ColumnDecimal<T> * in, ColumnDecimal<U> * out, const IColumn * default_untyped) const
-    {
-        auto col_default = checkAndGetColumn<ColumnDecimal<V>>(default_untyped);
-        if (!col_default)
-            return false;
-
-        executeImplNumToNumWithNonConstDefault<T, U, V>(in->getData(), out->getData(), col_default->getData());
-        return true;
-    }
-
-    template <typename T>
-    bool executeNumToStringWithConstDefault(const ColumnVector<T> * in, IColumn * out_untyped) const
-    {
-        auto * out = typeid_cast<ColumnString *>(out_untyped);
-        if (!out)
-            return false;
-
-        const String & default_str = cache.const_default_value.get<const String &>();
-        StringRef default_string_ref{default_str.data(), default_str.size() + 1};
-        executeImplNumToStringWithConstDefault<T>(in->getData(), out->getChars(), out->getOffsets(), default_string_ref);
-        return true;
-    }
-
-    template <typename T>
-    bool executeDecimalToStringWithConstDefault(const ColumnDecimal<T> * in, IColumn * out_untyped) const
-    {
-        auto * out = typeid_cast<ColumnString *>(out_untyped);
-        if (!out)
-            return false;
-
-        const String & default_str = cache.const_default_value.get<const String &>();
-        StringRef default_string_ref{default_str.data(), default_str.size() + 1};
-        executeImplNumToStringWithConstDefault<T>(in->getData(), out->getChars(), out->getOffsets(), default_string_ref);
-        return true;
-    }
-
-    template <typename T>
-    bool executeNumToStringWithNonConstDefault(const ColumnVector<T> * in, IColumn * out_untyped, const IColumn * default_untyped) const
-    {
-        auto * out = typeid_cast<ColumnString *>(out_untyped);
-        if (!out)
-            return false;
-
-        const auto * default_col = checkAndGetColumn<ColumnString>(default_untyped);
-        if (!default_col)
-        {
-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of fourth argument of function {}",
-                default_untyped->getName(), getName());
-        }
-
-        executeImplNumToStringWithNonConstDefault<T>(
-            in->getData(),
-            out->getChars(), out->getOffsets(),
-            default_col->getChars(), default_col->getOffsets());
-
-        return true;
-    }
-
-    template <typename T>
-    bool executeDecimalToStringWithNonConstDefault(const ColumnDecimal<T> * in, IColumn * out_untyped, const IColumn * default_untyped) const
-    {
-        auto * out = typeid_cast<ColumnString *>(out_untyped);
-        if (!out)
-            return false;
-
-        const auto * default_col = checkAndGetColumn<ColumnString>(default_untyped);
-        if (!default_col)
-        {
-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of fourth argument of function {}",
-                            default_untyped->getName(), getName());
-        }
-
-        executeImplNumToStringWithNonConstDefault<T>(
-            in->getData(),
-            out->getChars(), out->getOffsets(),
-            default_col->getChars(), default_col->getOffsets());
-
-        return true;
-    }
-
-    template <typename U>
-    bool executeStringToNumWithConstDefault(const ColumnString * in, IColumn * out_untyped) const
-    {
-        auto out = typeid_cast<ColumnVector<U> *>(out_untyped);
-        if (!out)
-            return false;
-
-        executeImplStringToNumWithConstDefault<U>(
-            in->getChars(), in->getOffsets(), out->getData(), static_cast<U>(cache.const_default_value.get<U>()));
-        return true;
-    }
-
-    template <typename U>
-    bool executeStringToDecimalWithConstDefault(const ColumnString * in, IColumn * out_untyped) const
-    {
-        auto out = typeid_cast<ColumnDecimal<U> *>(out_untyped);
-        if (!out)
-            return false;
-
-        executeImplStringToNumWithConstDefault<U>(in->getChars(), in->getOffsets(), out->getData(), cache.const_default_value.get<U>());
-        return true;
-    }
-
-    template <typename U>
-    bool executeStringToNumWithNonConstDefault(const ColumnString * in, IColumn * out_untyped, const IColumn * default_untyped) const
-    {
-        auto out = typeid_cast<ColumnVector<U> *>(out_untyped);
-        if (!out)
-            return false;
-
-        if (!executeStringToNumWithNonConstDefault2<U, UInt8>(in, out, default_untyped)
-            && !executeStringToNumWithNonConstDefault2<U, UInt16>(in, out, default_untyped)
-            && !executeStringToNumWithNonConstDefault2<U, UInt32>(in, out, default_untyped)
-            && !executeStringToNumWithNonConstDefault2<U, UInt64>(in, out, default_untyped)
-            && !executeStringToNumWithNonConstDefault2<U, Int8>(in, out, default_untyped)
-            && !executeStringToNumWithNonConstDefault2<U, Int16>(in, out, default_untyped)
-            && !executeStringToNumWithNonConstDefault2<U, Int32>(in, out, default_untyped)
-            && !executeStringToNumWithNonConstDefault2<U, Int64>(in, out, default_untyped)
-            && !executeStringToNumWithNonConstDefault2<U, Float32>(in, out, default_untyped)
-            && !executeStringToNumWithNonConstDefault2<U, Float64>(in, out, default_untyped))
-        {
-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of fourth argument of function {}",
-                default_untyped->getName(), getName());
-        }
-
-        return true;
-    }
-
-    template <typename U>
-    bool executeStringToDecimalWithNonConstDefault(const ColumnString * in, IColumn * out_untyped, const IColumn * default_untyped) const
-    {
-        auto out = typeid_cast<ColumnDecimal<U> *>(out_untyped);
-        if (!out)
-            return false;
-
-        if (!executeStringToDecimalWithNonConstDefault2<U, UInt8>(in, out, default_untyped)
-            && !executeStringToDecimalWithNonConstDefault2<U, UInt16>(in, out, default_untyped)
-            && !executeStringToDecimalWithNonConstDefault2<U, UInt32>(in, out, default_untyped)
-            && !executeStringToDecimalWithNonConstDefault2<U, UInt64>(in, out, default_untyped)
-            && !executeStringToDecimalWithNonConstDefault2<U, Int8>(in, out, default_untyped)
-            && !executeStringToDecimalWithNonConstDefault2<U, Int16>(in, out, default_untyped)
-            && !executeStringToDecimalWithNonConstDefault2<U, Int32>(in, out, default_untyped)
-            && !executeStringToDecimalWithNonConstDefault2<U, Int64>(in, out, default_untyped)
-            && !executeStringToDecimalWithNonConstDefault2<U, Float32>(in, out, default_untyped)
-            && !executeStringToDecimalWithNonConstDefault2<U, Float64>(in, out, default_untyped)
-            && !executeStringToDecimalWithNonConstDefaultDecimal2<U, Decimal32>(in, out, default_untyped)
-            && !executeStringToDecimalWithNonConstDefaultDecimal2<U, Decimal64>(in, out, default_untyped))
-        {
-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of fourth argument of function {}",
-                            default_untyped->getName(), getName());
-        }
-
-        return true;
-    }
-
-
-    template <typename U, typename V>
-    bool executeStringToNumWithNonConstDefault2(const ColumnString * in, ColumnVector<U> * out, const IColumn * default_untyped) const
-    {
-        auto col_default = checkAndGetColumn<ColumnVector<V>>(default_untyped);
-        if (!col_default)
-            return false;
-
-        executeImplStringToNumWithNonConstDefault<U, V>(in->getChars(), in->getOffsets(), out->getData(), col_default->getData());
-        return true;
-    }
-
-    template <typename U, typename V>
-    bool executeStringToDecimalWithNonConstDefault2(const ColumnString * in, ColumnDecimal<U> * out, const IColumn * default_untyped) const
-    {
-        auto col_default = checkAndGetColumn<ColumnVector<V>>(default_untyped);
-        if (!col_default)
-            return false;
-
-        executeImplStringToNumWithNonConstDefault<U, V>(in->getChars(), in->getOffsets(), out->getData(), col_default->getData());
-        return true;
-    }
-
-    template <typename U, typename V>
-    bool executeStringToDecimalWithNonConstDefaultDecimal2(const ColumnString * in, ColumnDecimal<U> * out, const IColumn * default_untyped) const
-    {
-        auto col_default = checkAndGetColumn<ColumnDecimal<V>>(default_untyped);
-        if (!col_default)
-            return false;
-
-        executeImplStringToNumWithNonConstDefault<U, V>(in->getChars(), in->getOffsets(), out->getData(), col_default->getData());
-        return true;
-    }
-
-    bool executeStringToString(const ColumnString * in, IColumn * out_untyped) const
-    {
-        auto * out = typeid_cast<ColumnString *>(out_untyped);
-        if (!out)
-            return false;
-
-        executeImplStringToString(in->getChars(), in->getOffsets(), out->getChars(), out->getOffsets());
-        return true;
-    }
-
-    bool executeStringToStringWithConstDefault(const ColumnString * in, IColumn * out_untyped) const
-    {
-        auto * out = typeid_cast<ColumnString *>(out_untyped);
-        if (!out)
-            return false;
-
-        const String & default_str = cache.const_default_value.get<const String &>();
-        StringRef default_string_ref{default_str.data(), default_str.size() + 1};
-        executeImplStringToStringWithConstDefault(in->getChars(), in->getOffsets(), out->getChars(), out->getOffsets(), default_string_ref);
-        return true;
-    }
-
-    bool executeStringToStringWithNonConstDefault(const ColumnString * in, IColumn * out_untyped, const IColumn * default_untyped) const
-    {
-        auto * out = typeid_cast<ColumnString *>(out_untyped);
-        if (!out)
-            return false;
-
-        const auto * default_col = checkAndGetColumn<ColumnString>(default_untyped);
-        if (!default_col)
-        {
-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of fourth argument of function {}",
-                default_untyped->getName(), getName());
-        }
-
-        executeImplStringToStringWithNonConstDefault(
-            in->getChars(), in->getOffsets(),
-            out->getChars(), out->getOffsets(),
-            default_col->getChars(), default_col->getOffsets());
-
-        return true;
-    }
-
-
-    template <typename T, typename U>
-    void executeImplNumToNumWithConstDefault(const PaddedPODArray<T> & src, PaddedPODArray<U> & dst, U dst_default) const
-    {
-        const auto & table = *cache.table_num_to_num;
-        size_t size = src.size();
-        dst.resize(size);
-        for (size_t i = 0; i < size; ++i)
-        {
-            const auto * it = table.find(bit_cast<UInt64>(src[i]));
-            if (it)
+            for (size_t i = 0; i < size; ++i)
             {
-                if constexpr (std::endian::native == std::endian::little)
-                    memcpy(&dst[i], &it->getMapped(), sizeof(dst[i]));
+                const auto * it = table.find(bit_cast<UInt64>(pod[i]));
+                if (it)
+                {
+                    const auto idx = it->getMapped();
+                    out_pod[i] = to_pod[idx];
+                }
+                else if constexpr (std::is_same_v<Def, Out>)
+                    out_pod[i] = def;
+                else if constexpr (is_decimal<Out> && !is_decimal<typename Def::value_type>)
+                    out_pod[i] = DecimalUtils::decimalFromComponents<Out>(static_cast<typename Out::NativeType>(def[i]), 0, out_scale);
+                else if constexpr (is_decimal<Out>)
+                {
+                    if (def_scale == out_scale)
+                        out_pod[i] = static_cast<typename Out::NativeType>(def[i]);
+                    else
+                    {
+                        const auto whole = static_cast<typename Out::NativeType>(DecimalUtils::getWholePart(def[i], def_scale));
+                        const auto fract = static_cast<typename Out::NativeType>(DecimalUtils::getFractionalPart(def[i], def_scale));
+                        out_pod[i] = DecimalUtils::decimalFromComponents<Out>(whole, fract, out_scale);
+                    }
+                }
                 else
-                    memcpy(&dst[i], reinterpret_cast<const char *>(&it->getMapped()) + sizeof(UInt64) - sizeof(dst[i]), sizeof(dst[i]));
+                    out_pod[i] = static_cast<Out>(def[i]); // NOLINT(bugprone-signed-char-misuse,cert-str34-c)
             }
-            else
-                dst[i] = dst_default;
         }
-    }
 
-    template <typename T, typename U, typename V>
-    void executeImplNumToNumWithNonConstDefault(const PaddedPODArray<T> & src, PaddedPODArray<U> & dst, const PaddedPODArray<V> & dst_default) const
-    {
-        const auto & table = *cache.table_num_to_num;
-        size_t size = src.size();
-        dst.resize(size);
-        for (size_t i = 0; i < size; ++i)
+        bool executeString(const IColumn * in_untyped, IColumn & column_result, const ColumnPtr default_non_const) const
         {
-            const auto * it = table.find(bit_cast<UInt64>(src[i]));
-            if (it)
+            const auto * const in = checkAndGetColumn<ColumnString>(in_untyped);
+            if (!in)
+                return false;
+            const auto & data = in->getChars();
+            const auto & offsets = in->getOffsets();
+
+            if (!executeStringToString(data, offsets, column_result, default_non_const)
+                && !executeStringToNum<ColumnVector<UInt8>>(data, offsets, column_result, default_non_const)
+                && !executeStringToNum<ColumnVector<UInt16>>(data, offsets, column_result, default_non_const)
+                && !executeStringToNum<ColumnVector<UInt32>>(data, offsets, column_result, default_non_const)
+                && !executeStringToNum<ColumnVector<UInt64>>(data, offsets, column_result, default_non_const)
+                && !executeStringToNum<ColumnVector<Int8>>(data, offsets, column_result, default_non_const)
+                && !executeStringToNum<ColumnVector<Int16>>(data, offsets, column_result, default_non_const)
+                && !executeStringToNum<ColumnVector<Int32>>(data, offsets, column_result, default_non_const)
+                && !executeStringToNum<ColumnVector<Int64>>(data, offsets, column_result, default_non_const)
+                && !executeStringToNum<ColumnVector<Float32>>(data, offsets, column_result, default_non_const)
+                && !executeStringToNum<ColumnVector<Float64>>(data, offsets, column_result, default_non_const)
+                && !executeStringToNum<ColumnDecimal<Decimal32>>(data, offsets, column_result, default_non_const)
+                && !executeStringToNum<ColumnDecimal<Decimal64>>(data, offsets, column_result, default_non_const))
             {
-                if constexpr (std::endian::native == std::endian::little)
-                    memcpy(&dst[i], &it->getMapped(), sizeof(dst[i]));
-                else
-                    memcpy(&dst[i], reinterpret_cast<const char *>(&it->getMapped()) + sizeof(UInt64) - sizeof(dst[i]), sizeof(dst[i]));
+                const size_t size = offsets.size();
+                const auto & table = *cache.table_string_to_idx;
+                ColumnString::Offset current_offset = 0;
+                for (size_t i = 0; i < size; ++i)
+                {
+                    const StringRef ref{&data[current_offset], offsets[i] - current_offset};
+                    current_offset = offsets[i];
+                    const auto * it = table.find(ref);
+                    if (it)
+                        column_result.insertFrom(*cache.to_columns, it->getMapped());
+                    else if (cache.default_column)
+                        column_result.insertFrom(*cache.default_column, 0);
+                    else if (default_non_const)
+                        column_result.insertFrom(*default_non_const, 0);
+                    else
+                        column_result.insertFrom(*in, i);
+                }
             }
-            else if constexpr (is_decimal<U>)
-                dst[i] = static_cast<typename U::NativeType>(dst_default[i]);
-            else
-                dst[i] = static_cast<U>(dst_default[i]); // NOLINT(bugprone-signed-char-misuse,cert-str34-c)
+            return true;
         }
-    }
 
-    template <typename T>
-    void executeImplNumToNum(const PaddedPODArray<T> & src, PaddedPODArray<T> & dst) const
-    {
-        const auto & table = *cache.table_num_to_num;
-        size_t size = src.size();
-        dst.resize(size);
-        for (size_t i = 0; i < size; ++i)
+        bool executeStringToString(
+            const ColumnString::Chars & data,
+            const ColumnString::Offsets & offsets,
+            IColumn & column_result,
+            const ColumnPtr default_non_const) const
         {
-            const auto * it = table.find(bit_cast<UInt64>(src[i]));
-            if (it)
+            auto * out = typeid_cast<ColumnString *>(&column_result);
+            if (!out)
+                return false;
+            auto & out_offs = out->getOffsets();
+            const size_t size = offsets.size();
+            out_offs.resize(size);
+            auto & out_chars = out->getChars();
+
+            const auto * to_col = reinterpret_cast<const ColumnString *>(cache.to_columns.get());
+            const auto & to_chars = to_col->getChars();
+            const auto & to_offs = to_col->getOffsets();
+
+            const auto & table = *cache.table_string_to_idx;
+            if (cache.default_column)
             {
-                if constexpr (std::endian::native == std::endian::little)
-                    memcpy(&dst[i], &it->getMapped(), sizeof(dst[i]));
-                else
-                    memcpy(&dst[i], reinterpret_cast<const char *>(&it->getMapped()) + sizeof(UInt64) - sizeof(dst[i]), sizeof(dst[i]));
+                const auto * def = reinterpret_cast<const ColumnString *>(cache.default_column.get());
+                const auto & def_chars = def->getChars();
+                const auto & def_offs = def->getOffsets();
+                const auto * def_data = def_chars.data();
+                auto def_size = def_offs[0];
+                executeStringToStringHelper(table, data, offsets, out_chars, out_offs, to_chars, to_offs, def_data, def_size, size);
+            }
+            else if (default_non_const)
+            {
+                const auto * def = reinterpret_cast<const ColumnString *>(default_non_const.get());
+                const auto & def_chars = def->getChars();
+                const auto & def_offs = def->getOffsets();
+                executeStringToStringHelper(table, data, offsets, out_chars, out_offs, to_chars, to_offs, def_chars, def_offs, size);
             }
             else
-                dst[i] = src[i];
-        }
-    }
-
-    template <typename T>
-    void executeImplNumToStringWithConstDefault(const PaddedPODArray<T> & src,
-        ColumnString::Chars & dst_data, ColumnString::Offsets & dst_offsets, StringRef dst_default) const
-    {
-        const auto & table = *cache.table_num_to_string;
-        size_t size = src.size();
-        dst_offsets.resize(size);
-        ColumnString::Offset current_dst_offset = 0;
-        for (size_t i = 0; i < size; ++i)
-        {
-            const auto * it = table.find(bit_cast<UInt64>(src[i]));
-            StringRef ref = it ? it->getMapped() : dst_default;
-            dst_data.resize(current_dst_offset + ref.size);
-            memcpy(&dst_data[current_dst_offset], ref.data, ref.size);
-            current_dst_offset += ref.size;
-            dst_offsets[i] = current_dst_offset;
+            {
+                executeStringToStringHelper(table, data, offsets, out_chars, out_offs, to_chars, to_offs, data, offsets, size);
+            }
+            return true;
         }
-    }
 
-    template <typename T>
-    void executeImplNumToStringWithNonConstDefault(const PaddedPODArray<T> & src,
-        ColumnString::Chars & dst_data, ColumnString::Offsets & dst_offsets,
-        const ColumnString::Chars & dst_default_data, const ColumnString::Offsets & dst_default_offsets) const
-    {
-        const auto & table = *cache.table_num_to_string;
-        size_t size = src.size();
-        dst_offsets.resize(size);
-        ColumnString::Offset current_dst_offset = 0;
-        ColumnString::Offset current_dst_default_offset = 0;
-        for (size_t i = 0; i < size; ++i)
+        template <typename Table, typename DefData, typename DefOffs>
+        void executeStringToStringHelper(
+            const Table & table,
+            const ColumnString::Chars & data,
+            const ColumnString::Offsets & offsets,
+            ColumnString::Chars & out_data,
+            ColumnString::Offsets & out_offsets,
+            const ColumnString::Chars & to_data,
+            const ColumnString::Offsets & to_offsets,
+            const DefData & def_data,
+            const DefOffs & def_offsets,
+            const size_t size) const
         {
-            const auto * it = table.find(bit_cast<UInt64>(src[i]));
-            StringRef ref;
-
-            if (it)
-                ref = it->getMapped();
-            else
+            ColumnString::Offset current_offset = 0;
+            size_t out_cur_off = 0;
+            for (size_t i = 0; i < size; ++i)
             {
-                ref.data = reinterpret_cast<const char *>(&dst_default_data[current_dst_default_offset]);
-                ref.size = dst_default_offsets[i] - current_dst_default_offset;
+                const char8_t * to = nullptr;
+                size_t to_size = 0;
+                const StringRef ref{&data[current_offset], offsets[i] - current_offset};
+                current_offset = offsets[i];
+                const auto * it = table.find(ref);
+                if (it)
+                {
+                    const auto idx = it->getMapped();
+                    const auto start = to_offsets[idx - 1];
+                    to = &to_data[start];
+                    to_size = to_offsets[idx] - start;
+                }
+                else if constexpr (std::is_same_v<DefData, ColumnString::Chars>)
+                {
+                    const auto start = def_offsets[i - 1];
+                    to = &def_data[start];
+                    to_size = def_offsets[i] - start;
+                }
+                else
+                {
+                    to = def_data;
+                    to_size = def_offsets;
+                }
+                out_data.resize(out_cur_off + to_size);
+                memcpy(&out_data[out_cur_off], to, to_size);
+                out_cur_off += to_size;
+                out_offsets[i] = out_cur_off;
             }
-
-            dst_data.resize(current_dst_offset + ref.size);
-            memcpy(&dst_data[current_dst_offset], ref.data, ref.size);
-            current_dst_offset += ref.size;
-            current_dst_default_offset = dst_default_offsets[i];
-            dst_offsets[i] = current_dst_offset;
         }
-    }
 
-    template <typename U>
-    void executeImplStringToNumWithConstDefault(
-        const ColumnString::Chars & src_data, const ColumnString::Offsets & src_offsets,
-        PaddedPODArray<U> & dst, U dst_default) const
-    {
-        const auto & table = *cache.table_string_to_num;
-        size_t size = src_offsets.size();
-        dst.resize(size);
-        ColumnString::Offset current_src_offset = 0;
-        for (size_t i = 0; i < size; ++i)
+        template <typename T>
+        bool executeStringToNum(
+            const ColumnString::Chars & data,
+            const ColumnString::Offsets & offsets,
+            IColumn & column_result,
+            const ColumnPtr default_non_const) const
         {
-            StringRef ref{&src_data[current_src_offset], src_offsets[i] - current_src_offset};
-            current_src_offset = src_offsets[i];
-            const auto * it = table.find(ref);
-            if (it)
+            auto * out = typeid_cast<T *>(&column_result);
+            if (!out)
+                return false;
+            auto & out_pod = out->getData();
+            const size_t size = offsets.size();
+            out_pod.resize(size);
+
+            const auto & to_pod = reinterpret_cast<const T *>(cache.to_columns.get())->getData();
+            const auto & table = *cache.table_string_to_idx;
+            if (cache.default_column)
             {
-                if constexpr (std::endian::native == std::endian::little)
-                    memcpy(&dst[i], &it->getMapped(), sizeof(dst[i]));
-                else
-                    memcpy(&dst[i], reinterpret_cast<const char *>(&it->getMapped()) + sizeof(UInt64) - sizeof(dst[i]), sizeof(dst[i]));
+                const auto const_def = reinterpret_cast<const T *>(cache.default_column.get())->getData()[0];
+                executeStringToNumHelper(table, data, offsets, out_pod, to_pod, const_def, size);
             }
             else
-                dst[i] = dst_default;
+            {
+                const auto & nconst_def = reinterpret_cast<const T *>(default_non_const.get())->getData();
+                executeStringToNumHelper(table, data, offsets, out_pod, to_pod, nconst_def, size);
+            }
+            return true;
         }
-    }
 
-    template <typename U, typename V>
-    void executeImplStringToNumWithNonConstDefault(
-        const ColumnString::Chars & src_data, const ColumnString::Offsets & src_offsets,
-        PaddedPODArray<U> & dst, const PaddedPODArray<V> & dst_default) const
-    {
-        const auto & table = *cache.table_string_to_num;
-        size_t size = src_offsets.size();
-        dst.resize(size);
-        ColumnString::Offset current_src_offset = 0;
-        for (size_t i = 0; i < size; ++i)
+        template <typename Table, typename Out, typename Def>
+        void executeStringToNumHelper(
+            const Table & table,
+            const ColumnString::Chars & data,
+            const ColumnString::Offsets & offsets,
+            PaddedPODArray<Out> & out_pod,
+            const PaddedPODArray<Out> & to_pod,
+            const Def & def,
+            const size_t size) const
         {
-            StringRef ref{&src_data[current_src_offset], src_offsets[i] - current_src_offset};
-            current_src_offset = src_offsets[i];
-            const auto * it = table.find(ref);
-            if (it)
+            ColumnString::Offset current_offset = 0;
+            for (size_t i = 0; i < size; ++i)
             {
-                if constexpr (std::endian::native == std::endian::little)
-                    memcpy(&dst[i], &it->getMapped(), sizeof(dst[i]));
+                const StringRef ref{&data[current_offset], offsets[i] - current_offset};
+                current_offset = offsets[i];
+                const auto * it = table.find(ref);
+                if (it)
+                {
+                    const auto idx = it->getMapped();
+                    out_pod[i] = to_pod[idx];
+                }
+                else if constexpr (std::is_same_v<Def, Out>)
+                    out_pod[i] = def;
+                else if constexpr (is_decimal<Out>)
+                    out_pod[i] = static_cast<typename Out::NativeType>(def[i]);
                 else
-                    memcpy(&dst[i], reinterpret_cast<const char *>(&it->getMapped()) + sizeof(UInt64) - sizeof(dst[i]), sizeof(dst[i]));
+                    out_pod[i] = static_cast<Out>(def[i]); // NOLINT(bugprone-signed-char-misuse,cert-str34-c)
             }
-            else if constexpr (is_decimal<U>)
-                dst[i] = static_cast<typename U::NativeType>(dst_default[i]);
-            else
-                dst[i] = static_cast<U>(dst_default[i]); // NOLINT(bugprone-signed-char-misuse,cert-str34-c)
         }
-    }
 
-    template <bool with_default>
-    void executeImplStringToStringWithOrWithoutConstDefault(
-        const ColumnString::Chars & src_data, const ColumnString::Offsets & src_offsets,
-        ColumnString::Chars & dst_data, ColumnString::Offsets & dst_offsets, StringRef dst_default) const
-    {
-        const auto & table = *cache.table_string_to_string;
-        size_t size = src_offsets.size();
-        dst_offsets.resize(size);
-        ColumnString::Offset current_src_offset = 0;
-        ColumnString::Offset current_dst_offset = 0;
-        for (size_t i = 0; i < size; ++i)
+        /// Different versions of the hash tables to implement the mapping.
+
+        struct Cache
         {
-            StringRef src_ref{&src_data[current_src_offset], src_offsets[i] - current_src_offset};
-            current_src_offset = src_offsets[i];
+            using NumToIdx = HashMap<UInt64, size_t, HashCRC32<UInt64>>;
+            using StringToIdx = HashMap<StringRef, size_t, StringRefHash>;
 
-            const auto * it = table.find(src_ref);
+            std::unique_ptr<NumToIdx> table_num_to_idx;
+            std::unique_ptr<StringToIdx> table_string_to_idx;
 
-            StringRef dst_ref = it ? it->getMapped() : (with_default ? dst_default : src_ref);
-            dst_data.resize(current_dst_offset + dst_ref.size);
-            memcpy(&dst_data[current_dst_offset], dst_ref.data, dst_ref.size);
-            current_dst_offset += dst_ref.size;
-            dst_offsets[i] = current_dst_offset;
-        }
-    }
+            ColumnPtr to_columns;
+            ColumnPtr default_column;
 
-    void executeImplStringToString(
-        const ColumnString::Chars & src_data, const ColumnString::Offsets & src_offsets,
-        ColumnString::Chars & dst_data, ColumnString::Offsets & dst_offsets) const
-    {
-        executeImplStringToStringWithOrWithoutConstDefault<false>(src_data, src_offsets, dst_data, dst_offsets, {});
-    }
+            Arena string_pool;
 
-    void executeImplStringToStringWithConstDefault(
-        const ColumnString::Chars & src_data, const ColumnString::Offsets & src_offsets,
-        ColumnString::Chars & dst_data, ColumnString::Offsets & dst_offsets, StringRef dst_default) const
-    {
-        executeImplStringToStringWithOrWithoutConstDefault<true>(src_data, src_offsets, dst_data, dst_offsets, dst_default);
-    }
+            std::atomic<bool> initialized{false};
+            std::mutex mutex;
+        };
 
-    void executeImplStringToStringWithNonConstDefault(
-        const ColumnString::Chars & src_data, const ColumnString::Offsets & src_offsets,
-        ColumnString::Chars & dst_data, ColumnString::Offsets & dst_offsets,
-        const ColumnString::Chars & dst_default_data, const ColumnString::Offsets & dst_default_offsets) const
-    {
-        const auto & table = *cache.table_string_to_string;
-        size_t size = src_offsets.size();
-        dst_offsets.resize(size);
-        ColumnString::Offset current_src_offset = 0;
-        ColumnString::Offset current_dst_offset = 0;
-        ColumnString::Offset current_dst_default_offset = 0;
-        for (size_t i = 0; i < size; ++i)
-        {
-            StringRef src_ref{&src_data[current_src_offset], src_offsets[i] - current_src_offset};
-            current_src_offset = src_offsets[i];
+        mutable Cache cache;
 
-            const auto * it = table.find(src_ref);
-            StringRef dst_ref;
 
-            if (it)
-                dst_ref = it->getMapped();
-            else
+        static UInt64 bitCastToUInt64(const Field & x)
+        {
+            switch (x.getType())
             {
-                dst_ref.data = reinterpret_cast<const char *>(&dst_default_data[current_dst_default_offset]);
-                dst_ref.size = dst_default_offsets[i] - current_dst_default_offset;
+                case Field::Types::UInt64:
+                    return x.get<UInt64>();
+                case Field::Types::Int64:
+                    return x.get<Int64>();
+                case Field::Types::Float64:
+                    return std::bit_cast<UInt64>(x.get<Float64>());
+                case Field::Types::Bool:
+                    return x.get<bool>();
+                case Field::Types::Decimal32:
+                    return x.get<DecimalField<Decimal32>>().getValue();
+                case Field::Types::Decimal64:
+                    return x.get<DecimalField<Decimal64>>().getValue();
+                default:
+                    throw Exception(ErrorCodes::BAD_ARGUMENTS, "Unexpected type in function 'transform'");
             }
-
-            dst_data.resize(current_dst_offset + dst_ref.size);
-            memcpy(&dst_data[current_dst_offset], dst_ref.data, dst_ref.size);
-            current_dst_offset += dst_ref.size;
-            current_dst_default_offset = dst_default_offsets[i];
-            dst_offsets[i] = current_dst_offset;
         }
-    }
-
-
-    /// Different versions of the hash tables to implement the mapping.
-
-    struct Cache
-    {
-        using NumToNum = HashMap<UInt64, UInt64, HashCRC32<UInt64>>;
-        using NumToString = HashMap<UInt64, StringRef, HashCRC32<UInt64>>;     /// Everywhere StringRef's with trailing zero.
-        using StringToNum = HashMap<StringRef, UInt64, StringRefHash>;
-        using StringToString = HashMap<StringRef, StringRef, StringRefHash>;
-
-        std::unique_ptr<NumToNum> table_num_to_num;
-        std::unique_ptr<NumToString> table_num_to_string;
-        std::unique_ptr<StringToNum> table_string_to_num;
-        std::unique_ptr<StringToString> table_string_to_string;
-
-        Arena string_pool;
-
-        Field const_default_value;    /// Null, if not specified.
-
-        std::atomic<bool> initialized{false};
-        std::mutex mutex;
-    };
 
-    mutable Cache cache;
-
-
-    static UInt64 bitCastToUInt64(const Field & x)
-    {
-        switch (x.getType())
+        static void checkAllowedType(const DataTypePtr & dt)
         {
-            case Field::Types::UInt64:      return x.get<UInt64>();
-            case Field::Types::Int64:       return x.get<Int64>();
-            case Field::Types::Float64:     return std::bit_cast<UInt64>(x.get<Float64>());
-            case Field::Types::Bool:        return x.get<bool>();
-            case Field::Types::Decimal32:   return x.get<DecimalField<Decimal32>>().getValue();
-            case Field::Types::Decimal64:   return x.get<DecimalField<Decimal64>>().getValue();
-            default:
-                throw Exception(ErrorCodes::BAD_ARGUMENTS, "Unexpected type in function 'transform'");
+            if (dt->isNullable())
+                checkAllowedTypeHelper(static_cast<const DataTypeNullable *>(dt.get())->getNestedType());
+            else
+                checkAllowedTypeHelper(dt);
         }
-    }
-
-    /// Can be called from different threads. It works only on the first call.
-    void initialize(const Array & from, const Array & to, const ColumnsWithTypeAndName & arguments) const
-    {
-        if (cache.initialized)
-            return;
 
-        const size_t size = from.size();
-        if (0 == size)
-            throw Exception(ErrorCodes::BAD_ARGUMENTS, "Empty arrays are illegal in function {}", getName());
+        static void checkAllowedTypeHelper(const DataTypePtr & dt)
+        {
+            if (isStringOrFixedString(dt))
+                return;
+            auto dtsize = dt->getMaximumSizeOfValueInMemory();
+            if (dtsize <= sizeof(UInt64))
+                return;
+            throw Exception(ErrorCodes::BAD_ARGUMENTS, "Unexpected type {} in function 'transform'", dt->getName());
+        }
 
-        std::lock_guard lock(cache.mutex);
+        /// Can be called from different threads. It works only on the first call.
+        void initialize(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type) const
+        {
+            const ColumnConst * array_from = checkAndGetColumnConst<ColumnArray>(arguments[1].column.get());
+            const ColumnConst * array_to = checkAndGetColumnConst<ColumnArray>(arguments[2].column.get());
 
-        if (cache.initialized)
-            return;
+            if (!array_from || !array_to)
+                throw Exception(
+                    ErrorCodes::ILLEGAL_COLUMN, "Second and third arguments of function {} must be constant arrays.", getName());
 
-        if (size != to.size())
-            throw Exception(ErrorCodes::BAD_ARGUMENTS, "Second and third arguments of function {} must be arrays of same size", getName());
+            if (cache.initialized)
+                return;
 
-        Array converted_to;
-        const Array * used_to = &to;
+            const auto & from = array_from->getValue<Array>();
+            const size_t size = from.size();
+            if (0 == size)
+                throw Exception(ErrorCodes::BAD_ARGUMENTS, "Empty arrays are illegal in function {}", getName());
 
-        /// Whether the default value is set.
+            std::lock_guard lock(cache.mutex);
 
-        if (arguments.size() == 4)
-        {
-            const IColumn * default_col = arguments[3].column.get();
-            const ColumnConst * const_default_col = typeid_cast<const ColumnConst *>(default_col);
+            if (cache.initialized)
+                return;
 
-            if (const_default_col)
-                cache.const_default_value = (*const_default_col)[0];
+            const auto & to = array_to->getValue<Array>();
+            if (size != to.size())
+                throw Exception(
+                    ErrorCodes::BAD_ARGUMENTS, "Second and third arguments of function {} must be arrays of same size", getName());
 
-            /// Do we need to convert the elements `to` and `default_value` to the smallest common type that is Float64?
-            bool default_col_is_float =
-                   checkColumn<ColumnFloat32>(default_col)
-                || checkColumn<ColumnFloat64>(default_col)
-                || checkColumnConst<ColumnFloat32>(default_col)
-                || checkColumnConst<ColumnFloat64>(default_col);
+            /// Whether the default value is set.
 
-            bool to_is_float = to[0].getType() == Field::Types::Float64;
-
-            if (default_col_is_float && !to_is_float)
+            if (arguments.size() == 4)
             {
-                converted_to.resize(size);
-                for (size_t i = 0; i < size; ++i)
-                    converted_to[i] = applyVisitor(FieldVisitorConvertToNumber<Float64>(), to[i]);
-                used_to = &converted_to;
-            }
-            else if (!default_col_is_float && to_is_float)
-            {
-                if (const_default_col)
-                    cache.const_default_value = applyVisitor(FieldVisitorConvertToNumber<Float64>(), cache.const_default_value);
+                const IColumn * default_col = arguments[3].column.get();
+                if (default_col && isColumnConst(*default_col))
+                {
+                    auto default_column = result_type->createColumn();
+                    if (!default_col->onlyNull())
+                    {
+                        Field f = convertFieldToType((*default_col)[0], *result_type);
+                        default_column->insert(f);
+                    }
+                    else
+                        default_column->insertDefault();
+                    cache.default_column = std::move(default_column);
+                }
             }
-        }
 
-        /// Note: Doesn't check the duplicates in the `from` array.
+            /// Note: Doesn't check the duplicates in the `from` array.
 
-        const IDataType & from_type = *arguments[0].type;
+            const IDataType & from_type = *arguments[0].type;
 
-        if (from[0].getType() != Field::Types::String)
-        {
-            if (to[0].getType() != Field::Types::String)
+            if (from[0].getType() != Field::Types::String)
             {
-                cache.table_num_to_num = std::make_unique<Cache::NumToNum>();
-                auto & table = *cache.table_num_to_num;
+                cache.table_num_to_idx = std::make_unique<Cache::NumToIdx>();
+                auto & table = *cache.table_num_to_idx;
                 for (size_t i = 0; i < size; ++i)
                 {
                     Field key = convertFieldToType(from[i], from_type);
@@ -1204,55 +715,31 @@ class FunctionTransform : public IFunction
                         continue;
 
                     /// Field may be of Float type, but for the purpose of bitwise equality we can treat them as UInt64
-                    table[bitCastToUInt64(key)] = bitCastToUInt64((*used_to)[i]);
+                    table[bitCastToUInt64(key)] = i;
                 }
             }
             else
             {
-                cache.table_num_to_string = std::make_unique<Cache::NumToString>();
-                auto & table = *cache.table_num_to_string;
-                for (size_t i = 0; i < size; ++i)
-                {
-                    Field key = convertFieldToType(from[i], from_type);
-                    if (key.isNull())
-                        continue;
-
-                    const String & str_to = to[i].get<const String &>();
-                    StringRef ref{cache.string_pool.insert(str_to.data(), str_to.size() + 1), str_to.size() + 1};
-                    table[bitCastToUInt64(key)] = ref;
-                }
-            }
-        }
-        else
-        {
-            if (to[0].getType() != Field::Types::String)
-            {
-                cache.table_string_to_num = std::make_unique<Cache::StringToNum>();
-                auto & table = *cache.table_string_to_num;
+                cache.table_string_to_idx = std::make_unique<Cache::StringToIdx>();
+                auto & table = *cache.table_string_to_idx;
                 for (size_t i = 0; i < size; ++i)
                 {
                     const String & str_from = from[i].get<const String &>();
                     StringRef ref{cache.string_pool.insert(str_from.data(), str_from.size() + 1), str_from.size() + 1};
-                    table[ref] = bitCastToUInt64((*used_to)[i]);
+                    table[ref] = i;
                 }
             }
-            else
+
+            auto to_columns = result_type->createColumn();
+            for (size_t i = 0; i < size; ++i)
             {
-                cache.table_string_to_string = std::make_unique<Cache::StringToString>();
-                auto & table = *cache.table_string_to_string;
-                for (size_t i = 0; i < size; ++i)
-                {
-                    const String & str_from = from[i].get<const String &>();
-                    const String & str_to = to[i].get<const String &>();
-                    StringRef ref_from{cache.string_pool.insert(str_from.data(), str_from.size() + 1), str_from.size() + 1};
-                    StringRef ref_to{cache.string_pool.insert(str_to.data(), str_to.size() + 1), str_to.size() + 1};
-                    table[ref_from] = ref_to;
-                }
+                Field to_value = convertFieldToType(to[i], *result_type);
+                to_columns->insert(to_value);
             }
-        }
+            cache.to_columns = std::move(to_columns);
 
-        cache.initialized = true;
-    }
+            cache.initialized = true;
+        }
 };
 
 }
