{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 48300,
  "instance_id": "ClickHouse__ClickHouse-48300",
  "issue_numbers": [
    "7237"
  ],
  "base_commit": "6434fd8a47a4631a8d7b85229b71a219a74b2b36",
  "patch": "diff --git a/src/Functions/caseWithExpression.cpp b/src/Functions/caseWithExpression.cpp\nindex c8b8dbd76cf4..9547cd200b24 100644\n--- a/src/Functions/caseWithExpression.cpp\n+++ b/src/Functions/caseWithExpression.cpp\n@@ -24,6 +24,9 @@ class FunctionCaseWithExpression : public IFunction\n \n     explicit FunctionCaseWithExpression(ContextPtr context_) : context(context_) {}\n     bool isVariadic() const override { return true; }\n+    bool useDefaultImplementationForConstants() const override { return false; }\n+    bool useDefaultImplementationForNulls() const override { return false; }\n+    bool useDefaultImplementationForNothing() const override { return false; }\n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n     size_t getNumberOfArguments() const override { return 0; }\n     String getName() const override { return name; }\ndiff --git a/src/Functions/transform.cpp b/src/Functions/transform.cpp\nindex df0f13ed97ca..33e03b541e98 100644\n--- a/src/Functions/transform.cpp\n+++ b/src/Functions/transform.cpp\n@@ -1,24 +1,26 @@\n #include <mutex>\n #include <base/bit_cast.h>\n \n-#include <Common/FieldVisitorDump.h>\n-#include <Common/FieldVisitorConvertToNumber.h>\n-#include <DataTypes/DataTypeArray.h>\n-#include <Columns/ColumnString.h>\n #include <Columns/ColumnArray.h>\n #include <Columns/ColumnConst.h>\n-#include <Columns/ColumnsNumber.h>\n #include <Columns/ColumnDecimal.h>\n+#include <Columns/ColumnNullable.h>\n+#include <Columns/ColumnString.h>\n+#include <Columns/ColumnsNumber.h>\n+#include <Core/DecimalFunctions.h>\n+#include <DataTypes/DataTypeArray.h>\n+#include <DataTypes/getLeastSupertype.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <Functions/IFunction.h>\n+#include <Interpreters/castColumn.h>\n+#include <Interpreters/convertFieldToType.h>\n+#include <base/StringRef.h>\n #include <Common/Arena.h>\n+#include <Common/FieldVisitorConvertToNumber.h>\n+#include <Common/FieldVisitorDump.h>\n #include <Common/HashTable/HashMap.h>\n #include <Common/typeid_cast.h>\n-#include <base/StringRef.h>\n-#include <Functions/IFunction.h>\n-#include <Functions/FunctionHelpers.h>\n-#include <Functions/FunctionFactory.h>\n-#include <DataTypes/getLeastSupertype.h>\n-#include <Interpreters/convertFieldToType.h>\n-\n \n namespace DB\n {\n@@ -32,11 +34,9 @@ namespace ErrorCodes\n \n namespace\n {\n-\n-/** transform(x, from_array, to_array[, default]) - convert x according to an explicitly passed match.\n+    /** transform(x, from_array, to_array[, default]) - convert x according to an explicitly passed match.\n   */\n-\n-/** transform(x, [from...], [to...], default)\n+    /** transform(x, [from...], [to...], default)\n   * - converts the values according to the explicitly specified mapping.\n   *\n   * x - what to transform.\n@@ -56,1147 +56,658 @@ namespace\n   *\n   * Note: the implementation is rather cumbersome.\n   */\n-class FunctionTransform : public IFunction\n-{\n-public:\n-    static constexpr auto name = \"transform\";\n-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionTransform>(); }\n-\n-    String getName() const override\n+    class FunctionTransform : public IFunction\n     {\n-        return name;\n-    }\n+    public:\n+        static constexpr auto name = \"transform\";\n+        static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionTransform>(); }\n \n-    bool isVariadic() const override { return true; }\n-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n-    size_t getNumberOfArguments() const override { return 0; }\n-    bool useDefaultImplementationForConstants() const override { return true; }\n-    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1, 2}; }\n-\n-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n-    {\n-        const auto args_size = arguments.size();\n-        if (args_size != 3 && args_size != 4)\n-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Number of arguments for function {} doesn't match: \"\n-                \"passed {}, should be 3 or 4\", getName(), args_size);\n+        String getName() const override { return name; }\n \n-        const DataTypePtr & type_x = arguments[0];\n+        bool isVariadic() const override { return true; }\n+        bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+        size_t getNumberOfArguments() const override { return 0; }\n+        bool useDefaultImplementationForConstants() const override { return false; }\n+        bool useDefaultImplementationForNulls() const override { return false; }\n+        bool useDefaultImplementationForNothing() const override { return false; }\n+        ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1, 2}; }\n \n-        if (!type_x->isValueRepresentedByNumber() && !isString(type_x))\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                            \"Unsupported type {} of first argument \"\n-                            \"of function {}, must be numeric type or Date/DateTime or String\",\n-                            type_x->getName(), getName());\n-\n-        const DataTypeArray * type_arr_from = checkAndGetDataType<DataTypeArray>(arguments[1].get());\n-\n-        if (!type_arr_from)\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                            \"Second argument of function {}, must be array of source values to transform from.\",\n-                            getName());\n-\n-        const auto type_arr_from_nested = type_arr_from->getNestedType();\n-\n-        if ((type_x->isValueRepresentedByNumber() != type_arr_from_nested->isValueRepresentedByNumber())\n-            || (isString(type_x) != isString(type_arr_from_nested)))\n+        DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n         {\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                            \"First argument and elements of array \"\n-                            \"of second argument of function {} must have compatible types: \"\n-                            \"both numeric or both strings.\", getName());\n-        }\n-\n-        const DataTypeArray * type_arr_to = checkAndGetDataType<DataTypeArray>(arguments[2].get());\n-\n-        if (!type_arr_to)\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                            \"Third argument of function {}, must be array of destination values to transform to.\",\n-                            getName());\n-\n-        const DataTypePtr & type_arr_to_nested = type_arr_to->getNestedType();\n-\n-        if (args_size == 3)\n-        {\n-            if ((type_x->isValueRepresentedByNumber() != type_arr_to_nested->isValueRepresentedByNumber())\n-                || (isString(type_x) != isString(type_arr_to_nested)))\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Function {} has signature: \"\n-                                \"transform(T, Array(T), Array(U), U) -> U; \"\n-                                \"or transform(T, Array(T), Array(T)) -> T; where T and U are types.\", getName());\n-\n-            return getLeastSupertype(DataTypes{type_x, type_arr_to_nested});\n-        }\n-        else\n-        {\n-            const DataTypePtr & type_default = arguments[3];\n+            const auto args_size = arguments.size();\n+            if (args_size != 3 && args_size != 4)\n+                throw Exception(\n+                    ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+                    \"Number of arguments for function {} doesn't match: \"\n+                    \"passed {}, should be 3 or 4\",\n+                    getName(),\n+                    args_size);\n+\n+            const DataTypePtr & type_x = arguments[0];\n+            const auto & type_x_nn = removeNullable(type_x);\n+\n+            if (!type_x_nn->isValueRepresentedByNumber() && !isString(type_x_nn) && !isNothing(type_x_nn))\n+                throw Exception(\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"Unsupported type {} of first argument \"\n+                    \"of function {}, must be numeric type or Date/DateTime or String\",\n+                    type_x->getName(),\n+                    getName());\n+\n+            const DataTypeArray * type_arr_from = checkAndGetDataType<DataTypeArray>(arguments[1].get());\n+\n+            if (!type_arr_from)\n+                throw Exception(\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"Second argument of function {}, must be array of source values to transform from.\",\n+                    getName());\n+\n+            const auto type_arr_from_nested = type_arr_from->getNestedType();\n+\n+            if ((type_x->isValueRepresentedByNumber() != type_arr_from_nested->isValueRepresentedByNumber())\n+                || (isString(type_x) != isString(type_arr_from_nested)))\n+            {\n+                throw Exception(\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"First argument and elements of array \"\n+                    \"of second argument of function {} must have compatible types: \"\n+                    \"both numeric or both strings.\",\n+                    getName());\n+            }\n \n-            if (!type_default->isValueRepresentedByNumber() && !isString(type_default))\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                                \"Unsupported type {} of fourth argument (default value) \"\n-                                \"of function {}, must be numeric type or Date/DateTime or String\",\n-                                type_default->getName(), getName());\n+            const DataTypeArray * type_arr_to = checkAndGetDataType<DataTypeArray>(arguments[2].get());\n \n-            bool default_is_string = WhichDataType(type_default).isString();\n-            bool nested_is_string = WhichDataType(type_arr_to_nested).isString();\n+            if (!type_arr_to)\n+                throw Exception(\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"Third argument of function {}, must be array of destination values to transform to.\",\n+                    getName());\n \n-            if ((type_default->isValueRepresentedByNumber() != type_arr_to_nested->isValueRepresentedByNumber())\n-                || (default_is_string != nested_is_string))\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Function {} have signature: \"\n-                                \"transform(T, Array(T), Array(U), U) -> U; \"\n-                                \"or transform(T, Array(T), Array(T)) -> T; where T and U are types.\", getName());\n+            const DataTypePtr & type_arr_to_nested = type_arr_to->getNestedType();\n \n-            if (type_arr_to_nested->isValueRepresentedByNumber() && type_default->isValueRepresentedByNumber())\n+            if (args_size == 3)\n             {\n-                /// We take the smallest common type for the elements of the array of values `to` and for `default`.\n-                return getLeastSupertype(DataTypes{type_arr_to_nested, type_default});\n+                if ((type_x->isValueRepresentedByNumber() != type_arr_to_nested->isValueRepresentedByNumber())\n+                    || (isString(type_x) != isString(type_arr_to_nested)))\n+                    throw Exception(\n+                        ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                        \"Function {} has signature: \"\n+                        \"transform(T, Array(T), Array(U), U) -> U; \"\n+                        \"or transform(T, Array(T), Array(T)) -> T; where T and U are types.\",\n+                        getName());\n+\n+                auto ret = tryGetLeastSupertype(DataTypes{type_arr_to_nested, type_x});\n+                if (!ret)\n+                    throw Exception(\n+                        ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                        \"Function {} has signature: \"\n+                        \"transform(T, Array(T), Array(U), U) -> U; \"\n+                        \"or transform(T, Array(T), Array(T)) -> T; where T and U are types.\",\n+                        getName());\n+                checkAllowedType(ret);\n+                return ret;\n+            }\n+            else\n+            {\n+                auto ret = tryGetLeastSupertype(DataTypes{type_arr_to_nested, arguments[3]});\n+                if (!ret)\n+                    throw Exception(\n+                        ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                        \"Function {} have signature: \"\n+                        \"transform(T, Array(T), Array(U), U) -> U; \"\n+                        \"or transform(T, Array(T), Array(T)) -> T; where T and U are types.\",\n+                        getName());\n+                checkAllowedType(ret);\n+                return ret;\n             }\n-\n-            /// TODO More checks.\n-            return type_arr_to_nested;\n         }\n-    }\n \n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n-    {\n-        const ColumnConst * array_from = checkAndGetColumnConst<ColumnArray>(arguments[1].column.get());\n-        const ColumnConst * array_to = checkAndGetColumnConst<ColumnArray>(arguments[2].column.get());\n-\n-        if (!array_from || !array_to)\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Second and third arguments of function {} must be constant arrays.\", getName());\n-\n-        initialize(array_from->getValue<Array>(), array_to->getValue<Array>(), arguments);\n-\n-        const auto * in = arguments.front().column.get();\n-\n-        if (isColumnConst(*in))\n-            return executeConst(arguments, result_type, input_rows_count);\n-\n-        const IColumn * default_column = nullptr;\n-        if (arguments.size() == 4)\n-            default_column = arguments[3].column.get();\n-\n-        auto column_result = result_type->createColumn();\n-        auto * out = column_result.get();\n-\n-        if (!executeNum<UInt8>(in, out, default_column)\n-            && !executeNum<UInt16>(in, out, default_column)\n-            && !executeNum<UInt32>(in, out, default_column)\n-            && !executeNum<UInt64>(in, out, default_column)\n-            && !executeNum<Int8>(in, out, default_column)\n-            && !executeNum<Int16>(in, out, default_column)\n-            && !executeNum<Int32>(in, out, default_column)\n-            && !executeNum<Int64>(in, out, default_column)\n-            && !executeNum<Float32>(in, out, default_column)\n-            && !executeNum<Float64>(in, out, default_column)\n-            && !executeDecimal<Decimal32>(in, out, default_column)\n-            && !executeDecimal<Decimal64>(in, out, default_column)\n-            && !executeString(in, out, default_column))\n+        ColumnPtr\n+        executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n         {\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\", in->getName(), getName());\n+            initialize(arguments, result_type);\n+\n+            const auto * in = arguments.front().column.get();\n+\n+            if (isColumnConst(*in))\n+                return executeConst(arguments, result_type, input_rows_count);\n+\n+            ColumnPtr default_non_const;\n+            if (!cache.default_column && arguments.size() == 4)\n+                default_non_const = castColumn(arguments[3], result_type);\n+\n+            auto column_result = result_type->createColumn();\n+            if (!executeNum<ColumnVector<UInt8>>(in, *column_result, default_non_const)\n+                && !executeNum<ColumnVector<UInt16>>(in, *column_result, default_non_const)\n+                && !executeNum<ColumnVector<UInt32>>(in, *column_result, default_non_const)\n+                && !executeNum<ColumnVector<UInt64>>(in, *column_result, default_non_const)\n+                && !executeNum<ColumnVector<Int8>>(in, *column_result, default_non_const)\n+                && !executeNum<ColumnVector<Int16>>(in, *column_result, default_non_const)\n+                && !executeNum<ColumnVector<Int32>>(in, *column_result, default_non_const)\n+                && !executeNum<ColumnVector<Int64>>(in, *column_result, default_non_const)\n+                && !executeNum<ColumnVector<Float32>>(in, *column_result, default_non_const)\n+                && !executeNum<ColumnVector<Float64>>(in, *column_result, default_non_const)\n+                && !executeNum<ColumnDecimal<Decimal32>>(in, *column_result, default_non_const)\n+                && !executeNum<ColumnDecimal<Decimal64>>(in, *column_result, default_non_const)\n+                && !executeString(in, *column_result, default_non_const))\n+            {\n+                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\", in->getName(), getName());\n+            }\n+            return column_result;\n         }\n \n-        return column_result;\n-    }\n-\n-private:\n-    static ColumnPtr executeConst(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count)\n-    {\n-        /// Materialize the input column and compute the function as usual.\n+    private:\n+        static ColumnPtr executeConst(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count)\n+        {\n+            /// Materialize the input column and compute the function as usual.\n \n-        ColumnsWithTypeAndName args = arguments;\n-        args[0].column = args[0].column->cloneResized(input_rows_count)->convertToFullColumnIfConst();\n+            ColumnsWithTypeAndName args = arguments;\n+            args[0].column = args[0].column->cloneResized(input_rows_count)->convertToFullColumnIfConst();\n \n-        auto impl = FunctionToOverloadResolverAdaptor(std::make_shared<FunctionTransform>()).build(args);\n+            auto impl = FunctionToOverloadResolverAdaptor(std::make_shared<FunctionTransform>()).build(args);\n \n-        return impl->execute(args, result_type, input_rows_count);\n-    }\n+            return impl->execute(args, result_type, input_rows_count);\n+        }\n \n-    template <typename T>\n-    bool executeNum(const IColumn * in_untyped, IColumn * out_untyped, const IColumn * default_untyped) const\n-    {\n-        if (const auto in = checkAndGetColumn<ColumnVector<T>>(in_untyped))\n+        template <typename T>\n+        bool executeNum(const IColumn * in_untyped, IColumn & column_result, const ColumnPtr default_non_const) const\n         {\n-            if (!default_untyped)\n+            const auto * const in = checkAndGetColumn<T>(in_untyped);\n+            if (!in)\n+                return false;\n+            const auto & pod = in->getData();\n+            UInt32 in_scale = 0;\n+            if constexpr (std::is_same_v<ColumnDecimal<Decimal32>, T> || std::is_same_v<ColumnDecimal<Decimal64>, T>)\n+                in_scale = in->getScale();\n+\n+            if (!executeNumToString(pod, column_result, default_non_const)\n+                && !executeNumToNum<ColumnVector<UInt8>>(pod, column_result, default_non_const, in_scale)\n+                && !executeNumToNum<ColumnVector<UInt16>>(pod, column_result, default_non_const, in_scale)\n+                && !executeNumToNum<ColumnVector<UInt32>>(pod, column_result, default_non_const, in_scale)\n+                && !executeNumToNum<ColumnVector<UInt64>>(pod, column_result, default_non_const, in_scale)\n+                && !executeNumToNum<ColumnVector<Int8>>(pod, column_result, default_non_const, in_scale)\n+                && !executeNumToNum<ColumnVector<Int16>>(pod, column_result, default_non_const, in_scale)\n+                && !executeNumToNum<ColumnVector<Int32>>(pod, column_result, default_non_const, in_scale)\n+                && !executeNumToNum<ColumnVector<Int64>>(pod, column_result, default_non_const, in_scale)\n+                && !executeNumToNum<ColumnVector<Float32>>(pod, column_result, default_non_const, in_scale)\n+                && !executeNumToNum<ColumnVector<Float64>>(pod, column_result, default_non_const, in_scale)\n+                && !executeNumToNum<ColumnDecimal<Decimal32>>(pod, column_result, default_non_const, in_scale)\n+                && !executeNumToNum<ColumnDecimal<Decimal64>>(pod, column_result, default_non_const, in_scale))\n             {\n-                auto out = typeid_cast<ColumnVector<T> *>(out_untyped);\n-                if (!out)\n+                const size_t size = pod.size();\n+                const auto & table = *cache.table_num_to_idx;\n+                column_result.reserve(size);\n+                for (size_t i = 0; i < size; ++i)\n                 {\n-                    throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n-                                    \"Illegal column {} of elements \"\n-                                    \"of array of third argument of function {}, must be {}\",\n-                                    out_untyped->getName(), getName(), in->getName());\n+                    const auto * it = table.find(bit_cast<UInt64>(pod[i]));\n+                    if (it)\n+                        column_result.insertFrom(*cache.to_columns, it->getMapped());\n+                    else if (cache.default_column)\n+                        column_result.insertFrom(*cache.default_column, 0);\n+                    else if (default_non_const)\n+                        column_result.insertFrom(*default_non_const, i);\n+                    else\n+                        column_result.insertFrom(*in, i);\n                 }\n-\n-                executeImplNumToNum<T>(in->getData(), out->getData());\n             }\n-            else if (isColumnConst(*default_untyped))\n+            return true;\n+        }\n+\n+        template <typename T>\n+        bool executeNumToString(const PaddedPODArray<T> & pod, IColumn & column_result, const ColumnPtr default_non_const) const\n+        {\n+            auto * out = typeid_cast<ColumnString *>(&column_result);\n+            if (!out)\n+                return false;\n+            auto & out_offs = out->getOffsets();\n+            const size_t size = pod.size();\n+            out_offs.resize(size);\n+            auto & out_chars = out->getChars();\n+\n+            const auto * to_col = reinterpret_cast<const ColumnString *>(cache.to_columns.get());\n+            const auto & to_chars = to_col->getChars();\n+            const auto & to_offs = to_col->getOffsets();\n+            const auto & table = *cache.table_num_to_idx;\n+\n+            if (cache.default_column)\n             {\n-                if (!executeNumToNumWithConstDefault<T, UInt8>(in, out_untyped)\n-                    && !executeNumToNumWithConstDefault<T, UInt16>(in, out_untyped)\n-                    && !executeNumToNumWithConstDefault<T, UInt32>(in, out_untyped)\n-                    && !executeNumToNumWithConstDefault<T, UInt64>(in, out_untyped)\n-                    && !executeNumToNumWithConstDefault<T, Int8>(in, out_untyped)\n-                    && !executeNumToNumWithConstDefault<T, Int16>(in, out_untyped)\n-                    && !executeNumToNumWithConstDefault<T, Int32>(in, out_untyped)\n-                    && !executeNumToNumWithConstDefault<T, Int64>(in, out_untyped)\n-                    && !executeNumToNumWithConstDefault<T, Float32>(in, out_untyped)\n-                    && !executeNumToNumWithConstDefault<T, Float64>(in, out_untyped)\n-                    && !executeNumToDecimalWithConstDefault<T, Decimal32>(in, out_untyped)\n-                    && !executeNumToDecimalWithConstDefault<T, Decimal64>(in, out_untyped)\n-                    && !executeNumToStringWithConstDefault<T>(in, out_untyped))\n-                {\n-                    throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of elements of array of second argument of function {}\",\n-                        in->getName(), getName());\n-                }\n+                const auto * def = reinterpret_cast<const ColumnString *>(cache.default_column.get());\n+                const auto & def_chars = def->getChars();\n+                const auto & def_offs = def->getOffsets();\n+                const auto * def_data = def_chars.data();\n+                auto def_size = def_offs[0];\n+                executeNumToStringHelper(table, pod, out_chars, out_offs, to_chars, to_offs, def_data, def_size, size);\n             }\n             else\n             {\n-                if (!executeNumToNumWithNonConstDefault<T, UInt8>(in, out_untyped, default_untyped)\n-                    && !executeNumToNumWithNonConstDefault<T, UInt16>(in, out_untyped, default_untyped)\n-                    && !executeNumToNumWithNonConstDefault<T, UInt32>(in, out_untyped, default_untyped)\n-                    && !executeNumToNumWithNonConstDefault<T, UInt64>(in, out_untyped, default_untyped)\n-                    && !executeNumToNumWithNonConstDefault<T, Int8>(in, out_untyped, default_untyped)\n-                    && !executeNumToNumWithNonConstDefault<T, Int16>(in, out_untyped, default_untyped)\n-                    && !executeNumToNumWithNonConstDefault<T, Int32>(in, out_untyped, default_untyped)\n-                    && !executeNumToNumWithNonConstDefault<T, Int64>(in, out_untyped, default_untyped)\n-                    && !executeNumToNumWithNonConstDefault<T, Float32>(in, out_untyped, default_untyped)\n-                    && !executeNumToNumWithNonConstDefault<T, Float64>(in, out_untyped, default_untyped)\n-                    && !executeNumToDecimalWithNonConstDefault<T, Decimal32>(in, out_untyped, default_untyped)\n-                    && !executeNumToDecimalWithNonConstDefault<T, Decimal64>(in, out_untyped, default_untyped)\n-                    && !executeNumToStringWithNonConstDefault<T>(in, out_untyped, default_untyped))\n-                {\n-                    throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of elements of array of second argument of function {}\",\n-                        in->getName(), getName());\n-                }\n+                const auto * def = reinterpret_cast<const ColumnString *>(default_non_const.get());\n+                const auto & def_chars = def->getChars();\n+                const auto & def_offs = def->getOffsets();\n+                executeNumToStringHelper(table, pod, out_chars, out_offs, to_chars, to_offs, def_chars, def_offs, size);\n             }\n-\n             return true;\n         }\n \n-        return false;\n-    }\n-\n-    template <typename T>\n-    bool executeDecimal(const IColumn * in_untyped, IColumn * out_untyped, const IColumn * default_untyped) const\n-    {\n-        if (const auto in = checkAndGetColumn<ColumnDecimal<T>>(in_untyped))\n+        template <typename Table, typename In, typename DefData, typename DefOffs>\n+        void executeNumToStringHelper(\n+            const Table & table,\n+            const PaddedPODArray<In> & pod,\n+            ColumnString::Chars & out_data,\n+            ColumnString::Offsets & out_offsets,\n+            const ColumnString::Chars & to_data,\n+            const ColumnString::Offsets & to_offsets,\n+            const DefData & def_data,\n+            const DefOffs & def_offsets,\n+            const size_t size) const\n         {\n-            if (!default_untyped)\n+            size_t out_cur_off = 0;\n+            for (size_t i = 0; i < size; ++i)\n             {\n-                auto out = typeid_cast<ColumnDecimal<T> *>(out_untyped);\n-                if (!out)\n+                const char8_t * to = nullptr;\n+                size_t to_size = 0;\n+                const auto * it = table.find(bit_cast<UInt64>(pod[i]));\n+                if (it)\n                 {\n-                    throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n-                                    \"Illegal column {} of elements \"\n-                                    \"of array of third argument of function {}, must be {}\",\n-                                    out_untyped->getName(), getName(), in->getName());\n+                    const auto idx = it->getMapped();\n+                    const auto start = to_offsets[idx - 1];\n+                    to = &to_data[start];\n+                    to_size = to_offsets[idx] - start;\n                 }\n-\n-                executeImplNumToNum<T>(in->getData(), out->getData());\n-            }\n-            else if (isColumnConst(*default_untyped))\n-            {\n-                if (!executeDecimalToNumWithConstDefault<T, UInt8>(in, out_untyped)\n-                    && !executeDecimalToNumWithConstDefault<T, UInt16>(in, out_untyped)\n-                    && !executeDecimalToNumWithConstDefault<T, UInt32>(in, out_untyped)\n-                    && !executeDecimalToNumWithConstDefault<T, UInt64>(in, out_untyped)\n-                    && !executeDecimalToNumWithConstDefault<T, Int8>(in, out_untyped)\n-                    && !executeDecimalToNumWithConstDefault<T, Int16>(in, out_untyped)\n-                    && !executeDecimalToNumWithConstDefault<T, Int32>(in, out_untyped)\n-                    && !executeDecimalToNumWithConstDefault<T, Int64>(in, out_untyped)\n-                    && !executeDecimalToNumWithConstDefault<T, Float32>(in, out_untyped)\n-                    && !executeDecimalToNumWithConstDefault<T, Float64>(in, out_untyped)\n-                    && !executeDecimalToDecimalWithConstDefault<T, Decimal32>(in, out_untyped)\n-                    && !executeDecimalToDecimalWithConstDefault<T, Decimal64>(in, out_untyped)\n-                    && !executeDecimalToStringWithConstDefault<T>(in, out_untyped))\n+                else if constexpr (std::is_same_v<DefData, ColumnString::Chars>)\n                 {\n-                    throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of elements of array of second argument of function {}\",\n-                                    in->getName(), getName());\n+                    const auto start = def_offsets[i - 1];\n+                    to = &def_data[start];\n+                    to_size = def_offsets[i] - start;\n                 }\n-            }\n-            else\n-            {\n-                if (!executeDecimalToNumWithNonConstDefault<T, UInt8>(in, out_untyped, default_untyped)\n-                    && !executeDecimalToNumWithNonConstDefault<T, UInt16>(in, out_untyped, default_untyped)\n-                    && !executeDecimalToNumWithNonConstDefault<T, UInt32>(in, out_untyped, default_untyped)\n-                    && !executeDecimalToNumWithNonConstDefault<T, UInt64>(in, out_untyped, default_untyped)\n-                    && !executeDecimalToNumWithNonConstDefault<T, Int8>(in, out_untyped, default_untyped)\n-                    && !executeDecimalToNumWithNonConstDefault<T, Int16>(in, out_untyped, default_untyped)\n-                    && !executeDecimalToNumWithNonConstDefault<T, Int32>(in, out_untyped, default_untyped)\n-                    && !executeDecimalToNumWithNonConstDefault<T, Int64>(in, out_untyped, default_untyped)\n-                    && !executeDecimalToNumWithNonConstDefault<T, Float32>(in, out_untyped, default_untyped)\n-                    && !executeDecimalToNumWithNonConstDefault<T, Float64>(in, out_untyped, default_untyped)\n-                    && !executeDecimalToDecimalWithNonConstDefault<T, Decimal32>(in, out_untyped, default_untyped)\n-                    && !executeDecimalToDecimalWithNonConstDefault<T, Decimal64>(in, out_untyped, default_untyped)\n-                    && !executeDecimalToStringWithNonConstDefault<T>(in, out_untyped, default_untyped))\n+                else\n                 {\n-                    throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of elements of array of second argument of function {}\",\n-                                    in->getName(), getName());\n+                    to = def_data;\n+                    to_size = def_offsets;\n                 }\n+                out_data.resize(out_cur_off + to_size);\n+                memcpy(&out_data[out_cur_off], to, to_size);\n+                out_cur_off += to_size;\n+                out_offsets[i] = out_cur_off;\n             }\n-\n-            return true;\n         }\n \n-        return false;\n-    }\n-\n-    bool executeString(const IColumn * in_untyped, IColumn * out_untyped, const IColumn * default_untyped) const\n-    {\n-        if (const auto * in = checkAndGetColumn<ColumnString>(in_untyped))\n+        template <typename T, typename U>\n+        bool executeNumToNum(\n+            const PaddedPODArray<U> & pod, IColumn & column_result, const ColumnPtr default_non_const, const UInt32 in_scale) const\n         {\n-            if (!default_untyped)\n+            auto * out = typeid_cast<T *>(&column_result);\n+            if (!out)\n+                return false;\n+            auto & out_pod = out->getData();\n+            const size_t size = pod.size();\n+            out_pod.resize(size);\n+            UInt32 out_scale = 0;\n+            if constexpr (std::is_same_v<ColumnDecimal<Decimal32>, T> || std::is_same_v<ColumnDecimal<Decimal64>, T>)\n+                out_scale = out->getScale();\n+\n+            const auto & to_pod = reinterpret_cast<const T *>(cache.to_columns.get())->getData();\n+            const auto & table = *cache.table_num_to_idx;\n+            if (cache.default_column)\n             {\n-                if (!executeStringToString(in, out_untyped))\n-                    throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of elements of array of second argument of function {}\",\n-                        in->getName(), getName());\n+                const auto const_def = reinterpret_cast<const T *>(cache.default_column.get())->getData()[0];\n+                executeNumToNumHelper(table, pod, out_pod, to_pod, const_def, size, out_scale, out_scale);\n             }\n-            else if (isColumnConst(*default_untyped))\n+            else if (default_non_const)\n             {\n-                if (!executeStringToNumWithConstDefault<UInt8>(in, out_untyped)\n-                    && !executeStringToNumWithConstDefault<UInt16>(in, out_untyped)\n-                    && !executeStringToNumWithConstDefault<UInt32>(in, out_untyped)\n-                    && !executeStringToNumWithConstDefault<UInt64>(in, out_untyped)\n-                    && !executeStringToNumWithConstDefault<Int8>(in, out_untyped)\n-                    && !executeStringToNumWithConstDefault<Int16>(in, out_untyped)\n-                    && !executeStringToNumWithConstDefault<Int32>(in, out_untyped)\n-                    && !executeStringToNumWithConstDefault<Int64>(in, out_untyped)\n-                    && !executeStringToNumWithConstDefault<Float32>(in, out_untyped)\n-                    && !executeStringToNumWithConstDefault<Float64>(in, out_untyped)\n-                    && !executeStringToDecimalWithConstDefault<Decimal32>(in, out_untyped)\n-                    && !executeStringToDecimalWithConstDefault<Decimal64>(in, out_untyped)\n-                    && !executeStringToStringWithConstDefault(in, out_untyped))\n-                {\n-                    throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of elements of array of second argument of function {}\",\n-                        in->getName(), getName());\n-                }\n+                const auto & nconst_def = reinterpret_cast<const T *>(default_non_const.get())->getData();\n+                executeNumToNumHelper(table, pod, out_pod, to_pod, nconst_def, size, out_scale, out_scale);\n             }\n             else\n-            {\n-                if (!executeStringToNumWithNonConstDefault<UInt8>(in, out_untyped, default_untyped)\n-                    && !executeStringToNumWithNonConstDefault<UInt16>(in, out_untyped, default_untyped)\n-                    && !executeStringToNumWithNonConstDefault<UInt32>(in, out_untyped, default_untyped)\n-                    && !executeStringToNumWithNonConstDefault<UInt64>(in, out_untyped, default_untyped)\n-                    && !executeStringToNumWithNonConstDefault<Int8>(in, out_untyped, default_untyped)\n-                    && !executeStringToNumWithNonConstDefault<Int16>(in, out_untyped, default_untyped)\n-                    && !executeStringToNumWithNonConstDefault<Int32>(in, out_untyped, default_untyped)\n-                    && !executeStringToNumWithNonConstDefault<Int64>(in, out_untyped, default_untyped)\n-                    && !executeStringToNumWithNonConstDefault<Float32>(in, out_untyped, default_untyped)\n-                    && !executeStringToNumWithNonConstDefault<Float64>(in, out_untyped, default_untyped)\n-                    && !executeStringToDecimalWithNonConstDefault<Decimal32>(in, out_untyped, default_untyped)\n-                    && !executeStringToDecimalWithNonConstDefault<Decimal64>(in, out_untyped, default_untyped)\n-\n-                    && !executeStringToStringWithNonConstDefault(in, out_untyped, default_untyped))\n-                {\n-                    throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of elements of array of second argument of function {}\",\n-                        in->getName(), getName());\n-                }\n-            }\n-\n+                executeNumToNumHelper(table, pod, out_pod, to_pod, pod, size, out_scale, in_scale);\n             return true;\n         }\n \n-        return false;\n-    }\n-\n-    template <typename T, typename U>\n-    bool executeNumToNumWithConstDefault(const ColumnVector<T> * in, IColumn * out_untyped) const\n-    {\n-        auto out = typeid_cast<ColumnVector<U> *>(out_untyped);\n-        if (!out)\n-            return false;\n-\n-        executeImplNumToNumWithConstDefault<T, U>(in->getData(), out->getData(), static_cast<U>(cache.const_default_value.get<U>()));\n-        return true;\n-    }\n-\n-    template <typename T, typename U>\n-    bool executeNumToDecimalWithConstDefault(const ColumnVector<T> * in, IColumn * out_untyped) const\n-    {\n-        auto out = typeid_cast<ColumnDecimal<U> *>(out_untyped);\n-        if (!out)\n-            return false;\n-\n-        executeImplNumToNumWithConstDefault<T, U>(in->getData(), out->getData(), cache.const_default_value.get<U>());\n-        return true;\n-    }\n-\n-\n-    template <typename T, typename U>\n-    bool executeDecimalToNumWithConstDefault(const ColumnDecimal<T> * in, IColumn * out_untyped) const\n-    {\n-        auto out = typeid_cast<ColumnVector<U> *>(out_untyped);\n-        if (!out)\n-            return false;\n-\n-        executeImplNumToNumWithConstDefault<T, U>(in->getData(), out->getData(), static_cast<U>(cache.const_default_value.get<U>()));\n-        return true;\n-    }\n-\n-    template <typename T, typename U>\n-    bool executeDecimalToDecimalWithConstDefault(const ColumnDecimal<T> * in, IColumn * out_untyped) const\n-    {\n-        auto out = typeid_cast<ColumnDecimal<U> *>(out_untyped);\n-        if (!out)\n-            return false;\n-\n-        executeImplNumToNumWithConstDefault<T, U>(in->getData(), out->getData(), cache.const_default_value.get<U>());\n-        return true;\n-    }\n-\n-    template <typename T, typename U>\n-    bool executeNumToNumWithNonConstDefault(const ColumnVector<T> * in, IColumn * out_untyped, const IColumn * default_untyped) const\n-    {\n-        auto out = typeid_cast<ColumnVector<U> *>(out_untyped);\n-        if (!out)\n-            return false;\n-\n-        if (!executeNumToNumWithNonConstDefault2<T, U, UInt8>(in, out, default_untyped)\n-            && !executeNumToNumWithNonConstDefault2<T, U, UInt16>(in, out, default_untyped)\n-            && !executeNumToNumWithNonConstDefault2<T, U, UInt32>(in, out, default_untyped)\n-            && !executeNumToNumWithNonConstDefault2<T, U, UInt64>(in, out, default_untyped)\n-            && !executeNumToNumWithNonConstDefault2<T, U, Int8>(in, out, default_untyped)\n-            && !executeNumToNumWithNonConstDefault2<T, U, Int16>(in, out, default_untyped)\n-            && !executeNumToNumWithNonConstDefault2<T, U, Int32>(in, out, default_untyped)\n-            && !executeNumToNumWithNonConstDefault2<T, U, Int64>(in, out, default_untyped)\n-            && !executeNumToNumWithNonConstDefault2<T, U, Float32>(in, out, default_untyped)\n-            && !executeNumToNumWithNonConstDefault2<T, U, Float64>(in, out, default_untyped))\n-        {\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of fourth argument of function {}\",\n-                default_untyped->getName(), getName());\n-        }\n-\n-        return true;\n-    }\n-\n-    template <typename T, typename U>\n-    bool executeNumToDecimalWithNonConstDefault(const ColumnVector<T> * in, IColumn * out_untyped, const IColumn * default_untyped) const\n-    {\n-        auto out = typeid_cast<ColumnDecimal<U> *>(out_untyped);\n-        if (!out)\n-            return false;\n-\n-        if (!executeNumToDecimalWithNonConstDefault2<T, U, UInt8>(in, out, default_untyped)\n-            && !executeNumToDecimalWithNonConstDefault2<T, U, UInt16>(in, out, default_untyped)\n-            && !executeNumToDecimalWithNonConstDefault2<T, U, UInt32>(in, out, default_untyped)\n-            && !executeNumToDecimalWithNonConstDefault2<T, U, UInt64>(in, out, default_untyped)\n-            && !executeNumToDecimalWithNonConstDefault2<T, U, Int8>(in, out, default_untyped)\n-            && !executeNumToDecimalWithNonConstDefault2<T, U, Int16>(in, out, default_untyped)\n-            && !executeNumToDecimalWithNonConstDefault2<T, U, Int32>(in, out, default_untyped)\n-            && !executeNumToDecimalWithNonConstDefault2<T, U, Int64>(in, out, default_untyped)\n-            && !executeNumToDecimalWithNonConstDefault2<T, U, Float32>(in, out, default_untyped)\n-            && !executeNumToDecimalWithNonConstDefault2<T, U, Float64>(in, out, default_untyped)\n-            && !executeNumToDecimalWithNonConstDefaultDecimal2<T, U, Decimal32>(in, out, default_untyped)\n-            && !executeNumToDecimalWithNonConstDefaultDecimal2<T, U, Decimal64>(in, out, default_untyped))\n-        {\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of fourth argument of function {}\",\n-                default_untyped->getName(), getName());\n-        }\n-\n-        return true;\n-    }\n-\n-    template <typename T, typename U>\n-    bool executeDecimalToNumWithNonConstDefault(const ColumnDecimal<T> * in, IColumn * out_untyped, const IColumn * default_untyped) const\n-    {\n-        auto out = typeid_cast<ColumnVector<U> *>(out_untyped);\n-        if (!out)\n-            return false;\n-\n-        if (!executeDecimalToNumWithNonConstDefault2<T, U, UInt8>(in, out, default_untyped)\n-            && !executeDecimalToNumWithNonConstDefault2<T, U, UInt16>(in, out, default_untyped)\n-            && !executeDecimalToNumWithNonConstDefault2<T, U, UInt32>(in, out, default_untyped)\n-            && !executeDecimalToNumWithNonConstDefault2<T, U, UInt64>(in, out, default_untyped)\n-            && !executeDecimalToNumWithNonConstDefault2<T, U, Int8>(in, out, default_untyped)\n-            && !executeDecimalToNumWithNonConstDefault2<T, U, Int16>(in, out, default_untyped)\n-            && !executeDecimalToNumWithNonConstDefault2<T, U, Int32>(in, out, default_untyped)\n-            && !executeDecimalToNumWithNonConstDefault2<T, U, Int64>(in, out, default_untyped)\n-            && !executeDecimalToNumWithNonConstDefault2<T, U, Float32>(in, out, default_untyped)\n-            && !executeDecimalToNumWithNonConstDefault2<T, U, Float64>(in, out, default_untyped)\n-            && !executeDecimalToNumWithNonConstDefaultDecimal2<T, U, Decimal32>(in, out, default_untyped)\n-            && !executeDecimalToNumWithNonConstDefaultDecimal2<T, U, Decimal64>(in, out, default_untyped))\n-        {\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of fourth argument of function {}\",\n-                default_untyped->getName(), getName());\n-        }\n-\n-        return true;\n-    }\n-\n-    template <typename T, typename U>\n-    bool executeDecimalToDecimalWithNonConstDefault(const ColumnDecimal<T> * in, IColumn * out_untyped, const IColumn * default_untyped) const\n-    {\n-        auto out = typeid_cast<ColumnDecimal<U> *>(out_untyped);\n-        if (!out)\n-            return false;\n-\n-        if (!executeDecimalToDecimalWithNonConstDefault2<T, U, UInt8>(in, out, default_untyped)\n-            && !executeDecimalToDecimalWithNonConstDefault2<T, U, UInt16>(in, out, default_untyped)\n-            && !executeDecimalToDecimalWithNonConstDefault2<T, U, UInt32>(in, out, default_untyped)\n-            && !executeDecimalToDecimalWithNonConstDefault2<T, U, UInt64>(in, out, default_untyped)\n-            && !executeDecimalToDecimalWithNonConstDefault2<T, U, Int8>(in, out, default_untyped)\n-            && !executeDecimalToDecimalWithNonConstDefault2<T, U, Int16>(in, out, default_untyped)\n-            && !executeDecimalToDecimalWithNonConstDefault2<T, U, Int32>(in, out, default_untyped)\n-            && !executeDecimalToDecimalWithNonConstDefault2<T, U, Int64>(in, out, default_untyped)\n-            && !executeDecimalToDecimalWithNonConstDefault2<T, U, Float32>(in, out, default_untyped)\n-            && !executeDecimalToDecimalWithNonConstDefault2<T, U, Float64>(in, out, default_untyped)\n-            && !executeDecimalToDecimalWithNonConstDefaultDecimal2<T, U, Decimal32>(in, out, default_untyped)\n-            && !executeDecimalToDecimalWithNonConstDefaultDecimal2<T, U, Decimal64>(in, out, default_untyped))\n+        template <typename Table, typename In, typename Out, typename Def>\n+        void executeNumToNumHelper(\n+            const Table & table,\n+            const PaddedPODArray<In> & pod,\n+            PaddedPODArray<Out> & out_pod,\n+            const PaddedPODArray<Out> & to_pod,\n+            const Def & def,\n+            const size_t size,\n+            const UInt32 out_scale,\n+            const UInt32 def_scale) const\n         {\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of fourth argument of function {}\",\n-                default_untyped->getName(), getName());\n-        }\n-\n-        return true;\n-    }\n-\n-    template <typename T, typename U, typename V>\n-    bool executeNumToNumWithNonConstDefault2(const ColumnVector<T> * in, ColumnVector<U> * out, const IColumn * default_untyped) const\n-    {\n-        auto col_default = checkAndGetColumn<ColumnVector<V>>(default_untyped);\n-        if (!col_default)\n-            return false;\n-\n-        executeImplNumToNumWithNonConstDefault<T, U, V>(in->getData(), out->getData(), col_default->getData());\n-        return true;\n-    }\n-\n-    template <typename T, typename U, typename V>\n-    bool executeNumToDecimalWithNonConstDefault2(const ColumnVector<T> * in, ColumnDecimal<U> * out, const IColumn * default_untyped) const\n-    {\n-        auto col_default = checkAndGetColumn<ColumnVector<V>>(default_untyped);\n-        if (!col_default)\n-            return false;\n-\n-        executeImplNumToNumWithNonConstDefault<T, U, V>(in->getData(), out->getData(), col_default->getData());\n-        return true;\n-    }\n-\n-    template <typename T, typename U, typename V>\n-    bool executeNumToDecimalWithNonConstDefaultDecimal2(const ColumnVector<T> * in, ColumnDecimal<U> * out, const IColumn * default_untyped) const\n-    {\n-        auto col_default = checkAndGetColumn<ColumnDecimal<V>>(default_untyped);\n-        if (!col_default)\n-            return false;\n-\n-        executeImplNumToNumWithNonConstDefault<T, U, V>(in->getData(), out->getData(), col_default->getData());\n-        return true;\n-    }\n-\n-    template <typename T, typename U, typename V>\n-    bool executeDecimalToNumWithNonConstDefault2(const ColumnDecimal<T> * in, ColumnVector<U> * out, const IColumn * default_untyped) const\n-    {\n-        auto col_default = checkAndGetColumn<ColumnVector<V>>(default_untyped);\n-        if (!col_default)\n-            return false;\n-\n-        executeImplNumToNumWithNonConstDefault<T, U, V>(in->getData(), out->getData(), col_default->getData());\n-        return true;\n-    }\n-\n-    template <typename T, typename U, typename V>\n-    bool executeDecimalToDecimalWithNonConstDefault2(const ColumnDecimal<T> * in, ColumnDecimal<U> * out, const IColumn * default_untyped) const\n-    {\n-        auto col_default = checkAndGetColumn<ColumnVector<V>>(default_untyped);\n-        if (!col_default)\n-            return false;\n-\n-        executeImplNumToNumWithNonConstDefault<T, U, V>(in->getData(), out->getData(), col_default->getData());\n-        return true;\n-    }\n-\n-    template <typename T, typename U, typename V>\n-    bool executeDecimalToNumWithNonConstDefaultDecimal2(const ColumnDecimal<T> * in, ColumnVector<U> * out, const IColumn * default_untyped) const\n-    {\n-        auto col_default = checkAndGetColumn<ColumnDecimal<V>>(default_untyped);\n-        if (!col_default)\n-            return false;\n-\n-        executeImplNumToNumWithNonConstDefault<T, U, V>(in->getData(), out->getData(), col_default->getData());\n-        return true;\n-    }\n-\n-    template <typename T, typename U, typename V>\n-    bool executeDecimalToDecimalWithNonConstDefaultDecimal2(const ColumnDecimal<T> * in, ColumnDecimal<U> * out, const IColumn * default_untyped) const\n-    {\n-        auto col_default = checkAndGetColumn<ColumnDecimal<V>>(default_untyped);\n-        if (!col_default)\n-            return false;\n-\n-        executeImplNumToNumWithNonConstDefault<T, U, V>(in->getData(), out->getData(), col_default->getData());\n-        return true;\n-    }\n-\n-    template <typename T>\n-    bool executeNumToStringWithConstDefault(const ColumnVector<T> * in, IColumn * out_untyped) const\n-    {\n-        auto * out = typeid_cast<ColumnString *>(out_untyped);\n-        if (!out)\n-            return false;\n-\n-        const String & default_str = cache.const_default_value.get<const String &>();\n-        StringRef default_string_ref{default_str.data(), default_str.size() + 1};\n-        executeImplNumToStringWithConstDefault<T>(in->getData(), out->getChars(), out->getOffsets(), default_string_ref);\n-        return true;\n-    }\n-\n-    template <typename T>\n-    bool executeDecimalToStringWithConstDefault(const ColumnDecimal<T> * in, IColumn * out_untyped) const\n-    {\n-        auto * out = typeid_cast<ColumnString *>(out_untyped);\n-        if (!out)\n-            return false;\n-\n-        const String & default_str = cache.const_default_value.get<const String &>();\n-        StringRef default_string_ref{default_str.data(), default_str.size() + 1};\n-        executeImplNumToStringWithConstDefault<T>(in->getData(), out->getChars(), out->getOffsets(), default_string_ref);\n-        return true;\n-    }\n-\n-    template <typename T>\n-    bool executeNumToStringWithNonConstDefault(const ColumnVector<T> * in, IColumn * out_untyped, const IColumn * default_untyped) const\n-    {\n-        auto * out = typeid_cast<ColumnString *>(out_untyped);\n-        if (!out)\n-            return false;\n-\n-        const auto * default_col = checkAndGetColumn<ColumnString>(default_untyped);\n-        if (!default_col)\n-        {\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of fourth argument of function {}\",\n-                default_untyped->getName(), getName());\n-        }\n-\n-        executeImplNumToStringWithNonConstDefault<T>(\n-            in->getData(),\n-            out->getChars(), out->getOffsets(),\n-            default_col->getChars(), default_col->getOffsets());\n-\n-        return true;\n-    }\n-\n-    template <typename T>\n-    bool executeDecimalToStringWithNonConstDefault(const ColumnDecimal<T> * in, IColumn * out_untyped, const IColumn * default_untyped) const\n-    {\n-        auto * out = typeid_cast<ColumnString *>(out_untyped);\n-        if (!out)\n-            return false;\n-\n-        const auto * default_col = checkAndGetColumn<ColumnString>(default_untyped);\n-        if (!default_col)\n-        {\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of fourth argument of function {}\",\n-                            default_untyped->getName(), getName());\n-        }\n-\n-        executeImplNumToStringWithNonConstDefault<T>(\n-            in->getData(),\n-            out->getChars(), out->getOffsets(),\n-            default_col->getChars(), default_col->getOffsets());\n-\n-        return true;\n-    }\n-\n-    template <typename U>\n-    bool executeStringToNumWithConstDefault(const ColumnString * in, IColumn * out_untyped) const\n-    {\n-        auto out = typeid_cast<ColumnVector<U> *>(out_untyped);\n-        if (!out)\n-            return false;\n-\n-        executeImplStringToNumWithConstDefault<U>(\n-            in->getChars(), in->getOffsets(), out->getData(), static_cast<U>(cache.const_default_value.get<U>()));\n-        return true;\n-    }\n-\n-    template <typename U>\n-    bool executeStringToDecimalWithConstDefault(const ColumnString * in, IColumn * out_untyped) const\n-    {\n-        auto out = typeid_cast<ColumnDecimal<U> *>(out_untyped);\n-        if (!out)\n-            return false;\n-\n-        executeImplStringToNumWithConstDefault<U>(in->getChars(), in->getOffsets(), out->getData(), cache.const_default_value.get<U>());\n-        return true;\n-    }\n-\n-    template <typename U>\n-    bool executeStringToNumWithNonConstDefault(const ColumnString * in, IColumn * out_untyped, const IColumn * default_untyped) const\n-    {\n-        auto out = typeid_cast<ColumnVector<U> *>(out_untyped);\n-        if (!out)\n-            return false;\n-\n-        if (!executeStringToNumWithNonConstDefault2<U, UInt8>(in, out, default_untyped)\n-            && !executeStringToNumWithNonConstDefault2<U, UInt16>(in, out, default_untyped)\n-            && !executeStringToNumWithNonConstDefault2<U, UInt32>(in, out, default_untyped)\n-            && !executeStringToNumWithNonConstDefault2<U, UInt64>(in, out, default_untyped)\n-            && !executeStringToNumWithNonConstDefault2<U, Int8>(in, out, default_untyped)\n-            && !executeStringToNumWithNonConstDefault2<U, Int16>(in, out, default_untyped)\n-            && !executeStringToNumWithNonConstDefault2<U, Int32>(in, out, default_untyped)\n-            && !executeStringToNumWithNonConstDefault2<U, Int64>(in, out, default_untyped)\n-            && !executeStringToNumWithNonConstDefault2<U, Float32>(in, out, default_untyped)\n-            && !executeStringToNumWithNonConstDefault2<U, Float64>(in, out, default_untyped))\n-        {\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of fourth argument of function {}\",\n-                default_untyped->getName(), getName());\n-        }\n-\n-        return true;\n-    }\n-\n-    template <typename U>\n-    bool executeStringToDecimalWithNonConstDefault(const ColumnString * in, IColumn * out_untyped, const IColumn * default_untyped) const\n-    {\n-        auto out = typeid_cast<ColumnDecimal<U> *>(out_untyped);\n-        if (!out)\n-            return false;\n-\n-        if (!executeStringToDecimalWithNonConstDefault2<U, UInt8>(in, out, default_untyped)\n-            && !executeStringToDecimalWithNonConstDefault2<U, UInt16>(in, out, default_untyped)\n-            && !executeStringToDecimalWithNonConstDefault2<U, UInt32>(in, out, default_untyped)\n-            && !executeStringToDecimalWithNonConstDefault2<U, UInt64>(in, out, default_untyped)\n-            && !executeStringToDecimalWithNonConstDefault2<U, Int8>(in, out, default_untyped)\n-            && !executeStringToDecimalWithNonConstDefault2<U, Int16>(in, out, default_untyped)\n-            && !executeStringToDecimalWithNonConstDefault2<U, Int32>(in, out, default_untyped)\n-            && !executeStringToDecimalWithNonConstDefault2<U, Int64>(in, out, default_untyped)\n-            && !executeStringToDecimalWithNonConstDefault2<U, Float32>(in, out, default_untyped)\n-            && !executeStringToDecimalWithNonConstDefault2<U, Float64>(in, out, default_untyped)\n-            && !executeStringToDecimalWithNonConstDefaultDecimal2<U, Decimal32>(in, out, default_untyped)\n-            && !executeStringToDecimalWithNonConstDefaultDecimal2<U, Decimal64>(in, out, default_untyped))\n-        {\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of fourth argument of function {}\",\n-                            default_untyped->getName(), getName());\n-        }\n-\n-        return true;\n-    }\n-\n-\n-    template <typename U, typename V>\n-    bool executeStringToNumWithNonConstDefault2(const ColumnString * in, ColumnVector<U> * out, const IColumn * default_untyped) const\n-    {\n-        auto col_default = checkAndGetColumn<ColumnVector<V>>(default_untyped);\n-        if (!col_default)\n-            return false;\n-\n-        executeImplStringToNumWithNonConstDefault<U, V>(in->getChars(), in->getOffsets(), out->getData(), col_default->getData());\n-        return true;\n-    }\n-\n-    template <typename U, typename V>\n-    bool executeStringToDecimalWithNonConstDefault2(const ColumnString * in, ColumnDecimal<U> * out, const IColumn * default_untyped) const\n-    {\n-        auto col_default = checkAndGetColumn<ColumnVector<V>>(default_untyped);\n-        if (!col_default)\n-            return false;\n-\n-        executeImplStringToNumWithNonConstDefault<U, V>(in->getChars(), in->getOffsets(), out->getData(), col_default->getData());\n-        return true;\n-    }\n-\n-    template <typename U, typename V>\n-    bool executeStringToDecimalWithNonConstDefaultDecimal2(const ColumnString * in, ColumnDecimal<U> * out, const IColumn * default_untyped) const\n-    {\n-        auto col_default = checkAndGetColumn<ColumnDecimal<V>>(default_untyped);\n-        if (!col_default)\n-            return false;\n-\n-        executeImplStringToNumWithNonConstDefault<U, V>(in->getChars(), in->getOffsets(), out->getData(), col_default->getData());\n-        return true;\n-    }\n-\n-    bool executeStringToString(const ColumnString * in, IColumn * out_untyped) const\n-    {\n-        auto * out = typeid_cast<ColumnString *>(out_untyped);\n-        if (!out)\n-            return false;\n-\n-        executeImplStringToString(in->getChars(), in->getOffsets(), out->getChars(), out->getOffsets());\n-        return true;\n-    }\n-\n-    bool executeStringToStringWithConstDefault(const ColumnString * in, IColumn * out_untyped) const\n-    {\n-        auto * out = typeid_cast<ColumnString *>(out_untyped);\n-        if (!out)\n-            return false;\n-\n-        const String & default_str = cache.const_default_value.get<const String &>();\n-        StringRef default_string_ref{default_str.data(), default_str.size() + 1};\n-        executeImplStringToStringWithConstDefault(in->getChars(), in->getOffsets(), out->getChars(), out->getOffsets(), default_string_ref);\n-        return true;\n-    }\n-\n-    bool executeStringToStringWithNonConstDefault(const ColumnString * in, IColumn * out_untyped, const IColumn * default_untyped) const\n-    {\n-        auto * out = typeid_cast<ColumnString *>(out_untyped);\n-        if (!out)\n-            return false;\n-\n-        const auto * default_col = checkAndGetColumn<ColumnString>(default_untyped);\n-        if (!default_col)\n-        {\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of fourth argument of function {}\",\n-                default_untyped->getName(), getName());\n-        }\n-\n-        executeImplStringToStringWithNonConstDefault(\n-            in->getChars(), in->getOffsets(),\n-            out->getChars(), out->getOffsets(),\n-            default_col->getChars(), default_col->getOffsets());\n-\n-        return true;\n-    }\n-\n-\n-    template <typename T, typename U>\n-    void executeImplNumToNumWithConstDefault(const PaddedPODArray<T> & src, PaddedPODArray<U> & dst, U dst_default) const\n-    {\n-        const auto & table = *cache.table_num_to_num;\n-        size_t size = src.size();\n-        dst.resize(size);\n-        for (size_t i = 0; i < size; ++i)\n-        {\n-            const auto * it = table.find(bit_cast<UInt64>(src[i]));\n-            if (it)\n+            for (size_t i = 0; i < size; ++i)\n             {\n-                if constexpr (std::endian::native == std::endian::little)\n-                    memcpy(&dst[i], &it->getMapped(), sizeof(dst[i]));\n+                const auto * it = table.find(bit_cast<UInt64>(pod[i]));\n+                if (it)\n+                {\n+                    const auto idx = it->getMapped();\n+                    out_pod[i] = to_pod[idx];\n+                }\n+                else if constexpr (std::is_same_v<Def, Out>)\n+                    out_pod[i] = def;\n+                else if constexpr (is_decimal<Out> && !is_decimal<typename Def::value_type>)\n+                    out_pod[i] = DecimalUtils::decimalFromComponents<Out>(static_cast<typename Out::NativeType>(def[i]), 0, out_scale);\n+                else if constexpr (is_decimal<Out>)\n+                {\n+                    if (def_scale == out_scale)\n+                        out_pod[i] = static_cast<typename Out::NativeType>(def[i]);\n+                    else\n+                    {\n+                        const auto whole = static_cast<typename Out::NativeType>(DecimalUtils::getWholePart(def[i], def_scale));\n+                        const auto fract = static_cast<typename Out::NativeType>(DecimalUtils::getFractionalPart(def[i], def_scale));\n+                        out_pod[i] = DecimalUtils::decimalFromComponents<Out>(whole, fract, out_scale);\n+                    }\n+                }\n                 else\n-                    memcpy(&dst[i], reinterpret_cast<const char *>(&it->getMapped()) + sizeof(UInt64) - sizeof(dst[i]), sizeof(dst[i]));\n+                    out_pod[i] = static_cast<Out>(def[i]); // NOLINT(bugprone-signed-char-misuse,cert-str34-c)\n             }\n-            else\n-                dst[i] = dst_default;\n         }\n-    }\n \n-    template <typename T, typename U, typename V>\n-    void executeImplNumToNumWithNonConstDefault(const PaddedPODArray<T> & src, PaddedPODArray<U> & dst, const PaddedPODArray<V> & dst_default) const\n-    {\n-        const auto & table = *cache.table_num_to_num;\n-        size_t size = src.size();\n-        dst.resize(size);\n-        for (size_t i = 0; i < size; ++i)\n+        bool executeString(const IColumn * in_untyped, IColumn & column_result, const ColumnPtr default_non_const) const\n         {\n-            const auto * it = table.find(bit_cast<UInt64>(src[i]));\n-            if (it)\n+            const auto * const in = checkAndGetColumn<ColumnString>(in_untyped);\n+            if (!in)\n+                return false;\n+            const auto & data = in->getChars();\n+            const auto & offsets = in->getOffsets();\n+\n+            if (!executeStringToString(data, offsets, column_result, default_non_const)\n+                && !executeStringToNum<ColumnVector<UInt8>>(data, offsets, column_result, default_non_const)\n+                && !executeStringToNum<ColumnVector<UInt16>>(data, offsets, column_result, default_non_const)\n+                && !executeStringToNum<ColumnVector<UInt32>>(data, offsets, column_result, default_non_const)\n+                && !executeStringToNum<ColumnVector<UInt64>>(data, offsets, column_result, default_non_const)\n+                && !executeStringToNum<ColumnVector<Int8>>(data, offsets, column_result, default_non_const)\n+                && !executeStringToNum<ColumnVector<Int16>>(data, offsets, column_result, default_non_const)\n+                && !executeStringToNum<ColumnVector<Int32>>(data, offsets, column_result, default_non_const)\n+                && !executeStringToNum<ColumnVector<Int64>>(data, offsets, column_result, default_non_const)\n+                && !executeStringToNum<ColumnVector<Float32>>(data, offsets, column_result, default_non_const)\n+                && !executeStringToNum<ColumnVector<Float64>>(data, offsets, column_result, default_non_const)\n+                && !executeStringToNum<ColumnDecimal<Decimal32>>(data, offsets, column_result, default_non_const)\n+                && !executeStringToNum<ColumnDecimal<Decimal64>>(data, offsets, column_result, default_non_const))\n             {\n-                if constexpr (std::endian::native == std::endian::little)\n-                    memcpy(&dst[i], &it->getMapped(), sizeof(dst[i]));\n-                else\n-                    memcpy(&dst[i], reinterpret_cast<const char *>(&it->getMapped()) + sizeof(UInt64) - sizeof(dst[i]), sizeof(dst[i]));\n+                const size_t size = offsets.size();\n+                const auto & table = *cache.table_string_to_idx;\n+                ColumnString::Offset current_offset = 0;\n+                for (size_t i = 0; i < size; ++i)\n+                {\n+                    const StringRef ref{&data[current_offset], offsets[i] - current_offset};\n+                    current_offset = offsets[i];\n+                    const auto * it = table.find(ref);\n+                    if (it)\n+                        column_result.insertFrom(*cache.to_columns, it->getMapped());\n+                    else if (cache.default_column)\n+                        column_result.insertFrom(*cache.default_column, 0);\n+                    else if (default_non_const)\n+                        column_result.insertFrom(*default_non_const, 0);\n+                    else\n+                        column_result.insertFrom(*in, i);\n+                }\n             }\n-            else if constexpr (is_decimal<U>)\n-                dst[i] = static_cast<typename U::NativeType>(dst_default[i]);\n-            else\n-                dst[i] = static_cast<U>(dst_default[i]); // NOLINT(bugprone-signed-char-misuse,cert-str34-c)\n+            return true;\n         }\n-    }\n \n-    template <typename T>\n-    void executeImplNumToNum(const PaddedPODArray<T> & src, PaddedPODArray<T> & dst) const\n-    {\n-        const auto & table = *cache.table_num_to_num;\n-        size_t size = src.size();\n-        dst.resize(size);\n-        for (size_t i = 0; i < size; ++i)\n+        bool executeStringToString(\n+            const ColumnString::Chars & data,\n+            const ColumnString::Offsets & offsets,\n+            IColumn & column_result,\n+            const ColumnPtr default_non_const) const\n         {\n-            const auto * it = table.find(bit_cast<UInt64>(src[i]));\n-            if (it)\n+            auto * out = typeid_cast<ColumnString *>(&column_result);\n+            if (!out)\n+                return false;\n+            auto & out_offs = out->getOffsets();\n+            const size_t size = offsets.size();\n+            out_offs.resize(size);\n+            auto & out_chars = out->getChars();\n+\n+            const auto * to_col = reinterpret_cast<const ColumnString *>(cache.to_columns.get());\n+            const auto & to_chars = to_col->getChars();\n+            const auto & to_offs = to_col->getOffsets();\n+\n+            const auto & table = *cache.table_string_to_idx;\n+            if (cache.default_column)\n             {\n-                if constexpr (std::endian::native == std::endian::little)\n-                    memcpy(&dst[i], &it->getMapped(), sizeof(dst[i]));\n-                else\n-                    memcpy(&dst[i], reinterpret_cast<const char *>(&it->getMapped()) + sizeof(UInt64) - sizeof(dst[i]), sizeof(dst[i]));\n+                const auto * def = reinterpret_cast<const ColumnString *>(cache.default_column.get());\n+                const auto & def_chars = def->getChars();\n+                const auto & def_offs = def->getOffsets();\n+                const auto * def_data = def_chars.data();\n+                auto def_size = def_offs[0];\n+                executeStringToStringHelper(table, data, offsets, out_chars, out_offs, to_chars, to_offs, def_data, def_size, size);\n+            }\n+            else if (default_non_const)\n+            {\n+                const auto * def = reinterpret_cast<const ColumnString *>(default_non_const.get());\n+                const auto & def_chars = def->getChars();\n+                const auto & def_offs = def->getOffsets();\n+                executeStringToStringHelper(table, data, offsets, out_chars, out_offs, to_chars, to_offs, def_chars, def_offs, size);\n             }\n             else\n-                dst[i] = src[i];\n-        }\n-    }\n-\n-    template <typename T>\n-    void executeImplNumToStringWithConstDefault(const PaddedPODArray<T> & src,\n-        ColumnString::Chars & dst_data, ColumnString::Offsets & dst_offsets, StringRef dst_default) const\n-    {\n-        const auto & table = *cache.table_num_to_string;\n-        size_t size = src.size();\n-        dst_offsets.resize(size);\n-        ColumnString::Offset current_dst_offset = 0;\n-        for (size_t i = 0; i < size; ++i)\n-        {\n-            const auto * it = table.find(bit_cast<UInt64>(src[i]));\n-            StringRef ref = it ? it->getMapped() : dst_default;\n-            dst_data.resize(current_dst_offset + ref.size);\n-            memcpy(&dst_data[current_dst_offset], ref.data, ref.size);\n-            current_dst_offset += ref.size;\n-            dst_offsets[i] = current_dst_offset;\n+            {\n+                executeStringToStringHelper(table, data, offsets, out_chars, out_offs, to_chars, to_offs, data, offsets, size);\n+            }\n+            return true;\n         }\n-    }\n \n-    template <typename T>\n-    void executeImplNumToStringWithNonConstDefault(const PaddedPODArray<T> & src,\n-        ColumnString::Chars & dst_data, ColumnString::Offsets & dst_offsets,\n-        const ColumnString::Chars & dst_default_data, const ColumnString::Offsets & dst_default_offsets) const\n-    {\n-        const auto & table = *cache.table_num_to_string;\n-        size_t size = src.size();\n-        dst_offsets.resize(size);\n-        ColumnString::Offset current_dst_offset = 0;\n-        ColumnString::Offset current_dst_default_offset = 0;\n-        for (size_t i = 0; i < size; ++i)\n+        template <typename Table, typename DefData, typename DefOffs>\n+        void executeStringToStringHelper(\n+            const Table & table,\n+            const ColumnString::Chars & data,\n+            const ColumnString::Offsets & offsets,\n+            ColumnString::Chars & out_data,\n+            ColumnString::Offsets & out_offsets,\n+            const ColumnString::Chars & to_data,\n+            const ColumnString::Offsets & to_offsets,\n+            const DefData & def_data,\n+            const DefOffs & def_offsets,\n+            const size_t size) const\n         {\n-            const auto * it = table.find(bit_cast<UInt64>(src[i]));\n-            StringRef ref;\n-\n-            if (it)\n-                ref = it->getMapped();\n-            else\n+            ColumnString::Offset current_offset = 0;\n+            size_t out_cur_off = 0;\n+            for (size_t i = 0; i < size; ++i)\n             {\n-                ref.data = reinterpret_cast<const char *>(&dst_default_data[current_dst_default_offset]);\n-                ref.size = dst_default_offsets[i] - current_dst_default_offset;\n+                const char8_t * to = nullptr;\n+                size_t to_size = 0;\n+                const StringRef ref{&data[current_offset], offsets[i] - current_offset};\n+                current_offset = offsets[i];\n+                const auto * it = table.find(ref);\n+                if (it)\n+                {\n+                    const auto idx = it->getMapped();\n+                    const auto start = to_offsets[idx - 1];\n+                    to = &to_data[start];\n+                    to_size = to_offsets[idx] - start;\n+                }\n+                else if constexpr (std::is_same_v<DefData, ColumnString::Chars>)\n+                {\n+                    const auto start = def_offsets[i - 1];\n+                    to = &def_data[start];\n+                    to_size = def_offsets[i] - start;\n+                }\n+                else\n+                {\n+                    to = def_data;\n+                    to_size = def_offsets;\n+                }\n+                out_data.resize(out_cur_off + to_size);\n+                memcpy(&out_data[out_cur_off], to, to_size);\n+                out_cur_off += to_size;\n+                out_offsets[i] = out_cur_off;\n             }\n-\n-            dst_data.resize(current_dst_offset + ref.size);\n-            memcpy(&dst_data[current_dst_offset], ref.data, ref.size);\n-            current_dst_offset += ref.size;\n-            current_dst_default_offset = dst_default_offsets[i];\n-            dst_offsets[i] = current_dst_offset;\n         }\n-    }\n \n-    template <typename U>\n-    void executeImplStringToNumWithConstDefault(\n-        const ColumnString::Chars & src_data, const ColumnString::Offsets & src_offsets,\n-        PaddedPODArray<U> & dst, U dst_default) const\n-    {\n-        const auto & table = *cache.table_string_to_num;\n-        size_t size = src_offsets.size();\n-        dst.resize(size);\n-        ColumnString::Offset current_src_offset = 0;\n-        for (size_t i = 0; i < size; ++i)\n+        template <typename T>\n+        bool executeStringToNum(\n+            const ColumnString::Chars & data,\n+            const ColumnString::Offsets & offsets,\n+            IColumn & column_result,\n+            const ColumnPtr default_non_const) const\n         {\n-            StringRef ref{&src_data[current_src_offset], src_offsets[i] - current_src_offset};\n-            current_src_offset = src_offsets[i];\n-            const auto * it = table.find(ref);\n-            if (it)\n+            auto * out = typeid_cast<T *>(&column_result);\n+            if (!out)\n+                return false;\n+            auto & out_pod = out->getData();\n+            const size_t size = offsets.size();\n+            out_pod.resize(size);\n+\n+            const auto & to_pod = reinterpret_cast<const T *>(cache.to_columns.get())->getData();\n+            const auto & table = *cache.table_string_to_idx;\n+            if (cache.default_column)\n             {\n-                if constexpr (std::endian::native == std::endian::little)\n-                    memcpy(&dst[i], &it->getMapped(), sizeof(dst[i]));\n-                else\n-                    memcpy(&dst[i], reinterpret_cast<const char *>(&it->getMapped()) + sizeof(UInt64) - sizeof(dst[i]), sizeof(dst[i]));\n+                const auto const_def = reinterpret_cast<const T *>(cache.default_column.get())->getData()[0];\n+                executeStringToNumHelper(table, data, offsets, out_pod, to_pod, const_def, size);\n             }\n             else\n-                dst[i] = dst_default;\n+            {\n+                const auto & nconst_def = reinterpret_cast<const T *>(default_non_const.get())->getData();\n+                executeStringToNumHelper(table, data, offsets, out_pod, to_pod, nconst_def, size);\n+            }\n+            return true;\n         }\n-    }\n \n-    template <typename U, typename V>\n-    void executeImplStringToNumWithNonConstDefault(\n-        const ColumnString::Chars & src_data, const ColumnString::Offsets & src_offsets,\n-        PaddedPODArray<U> & dst, const PaddedPODArray<V> & dst_default) const\n-    {\n-        const auto & table = *cache.table_string_to_num;\n-        size_t size = src_offsets.size();\n-        dst.resize(size);\n-        ColumnString::Offset current_src_offset = 0;\n-        for (size_t i = 0; i < size; ++i)\n+        template <typename Table, typename Out, typename Def>\n+        void executeStringToNumHelper(\n+            const Table & table,\n+            const ColumnString::Chars & data,\n+            const ColumnString::Offsets & offsets,\n+            PaddedPODArray<Out> & out_pod,\n+            const PaddedPODArray<Out> & to_pod,\n+            const Def & def,\n+            const size_t size) const\n         {\n-            StringRef ref{&src_data[current_src_offset], src_offsets[i] - current_src_offset};\n-            current_src_offset = src_offsets[i];\n-            const auto * it = table.find(ref);\n-            if (it)\n+            ColumnString::Offset current_offset = 0;\n+            for (size_t i = 0; i < size; ++i)\n             {\n-                if constexpr (std::endian::native == std::endian::little)\n-                    memcpy(&dst[i], &it->getMapped(), sizeof(dst[i]));\n+                const StringRef ref{&data[current_offset], offsets[i] - current_offset};\n+                current_offset = offsets[i];\n+                const auto * it = table.find(ref);\n+                if (it)\n+                {\n+                    const auto idx = it->getMapped();\n+                    out_pod[i] = to_pod[idx];\n+                }\n+                else if constexpr (std::is_same_v<Def, Out>)\n+                    out_pod[i] = def;\n+                else if constexpr (is_decimal<Out>)\n+                    out_pod[i] = static_cast<typename Out::NativeType>(def[i]);\n                 else\n-                    memcpy(&dst[i], reinterpret_cast<const char *>(&it->getMapped()) + sizeof(UInt64) - sizeof(dst[i]), sizeof(dst[i]));\n+                    out_pod[i] = static_cast<Out>(def[i]); // NOLINT(bugprone-signed-char-misuse,cert-str34-c)\n             }\n-            else if constexpr (is_decimal<U>)\n-                dst[i] = static_cast<typename U::NativeType>(dst_default[i]);\n-            else\n-                dst[i] = static_cast<U>(dst_default[i]); // NOLINT(bugprone-signed-char-misuse,cert-str34-c)\n         }\n-    }\n \n-    template <bool with_default>\n-    void executeImplStringToStringWithOrWithoutConstDefault(\n-        const ColumnString::Chars & src_data, const ColumnString::Offsets & src_offsets,\n-        ColumnString::Chars & dst_data, ColumnString::Offsets & dst_offsets, StringRef dst_default) const\n-    {\n-        const auto & table = *cache.table_string_to_string;\n-        size_t size = src_offsets.size();\n-        dst_offsets.resize(size);\n-        ColumnString::Offset current_src_offset = 0;\n-        ColumnString::Offset current_dst_offset = 0;\n-        for (size_t i = 0; i < size; ++i)\n+        /// Different versions of the hash tables to implement the mapping.\n+\n+        struct Cache\n         {\n-            StringRef src_ref{&src_data[current_src_offset], src_offsets[i] - current_src_offset};\n-            current_src_offset = src_offsets[i];\n+            using NumToIdx = HashMap<UInt64, size_t, HashCRC32<UInt64>>;\n+            using StringToIdx = HashMap<StringRef, size_t, StringRefHash>;\n \n-            const auto * it = table.find(src_ref);\n+            std::unique_ptr<NumToIdx> table_num_to_idx;\n+            std::unique_ptr<StringToIdx> table_string_to_idx;\n \n-            StringRef dst_ref = it ? it->getMapped() : (with_default ? dst_default : src_ref);\n-            dst_data.resize(current_dst_offset + dst_ref.size);\n-            memcpy(&dst_data[current_dst_offset], dst_ref.data, dst_ref.size);\n-            current_dst_offset += dst_ref.size;\n-            dst_offsets[i] = current_dst_offset;\n-        }\n-    }\n+            ColumnPtr to_columns;\n+            ColumnPtr default_column;\n \n-    void executeImplStringToString(\n-        const ColumnString::Chars & src_data, const ColumnString::Offsets & src_offsets,\n-        ColumnString::Chars & dst_data, ColumnString::Offsets & dst_offsets) const\n-    {\n-        executeImplStringToStringWithOrWithoutConstDefault<false>(src_data, src_offsets, dst_data, dst_offsets, {});\n-    }\n+            Arena string_pool;\n \n-    void executeImplStringToStringWithConstDefault(\n-        const ColumnString::Chars & src_data, const ColumnString::Offsets & src_offsets,\n-        ColumnString::Chars & dst_data, ColumnString::Offsets & dst_offsets, StringRef dst_default) const\n-    {\n-        executeImplStringToStringWithOrWithoutConstDefault<true>(src_data, src_offsets, dst_data, dst_offsets, dst_default);\n-    }\n+            std::atomic<bool> initialized{false};\n+            std::mutex mutex;\n+        };\n \n-    void executeImplStringToStringWithNonConstDefault(\n-        const ColumnString::Chars & src_data, const ColumnString::Offsets & src_offsets,\n-        ColumnString::Chars & dst_data, ColumnString::Offsets & dst_offsets,\n-        const ColumnString::Chars & dst_default_data, const ColumnString::Offsets & dst_default_offsets) const\n-    {\n-        const auto & table = *cache.table_string_to_string;\n-        size_t size = src_offsets.size();\n-        dst_offsets.resize(size);\n-        ColumnString::Offset current_src_offset = 0;\n-        ColumnString::Offset current_dst_offset = 0;\n-        ColumnString::Offset current_dst_default_offset = 0;\n-        for (size_t i = 0; i < size; ++i)\n-        {\n-            StringRef src_ref{&src_data[current_src_offset], src_offsets[i] - current_src_offset};\n-            current_src_offset = src_offsets[i];\n+        mutable Cache cache;\n \n-            const auto * it = table.find(src_ref);\n-            StringRef dst_ref;\n \n-            if (it)\n-                dst_ref = it->getMapped();\n-            else\n+        static UInt64 bitCastToUInt64(const Field & x)\n+        {\n+            switch (x.getType())\n             {\n-                dst_ref.data = reinterpret_cast<const char *>(&dst_default_data[current_dst_default_offset]);\n-                dst_ref.size = dst_default_offsets[i] - current_dst_default_offset;\n+                case Field::Types::UInt64:\n+                    return x.get<UInt64>();\n+                case Field::Types::Int64:\n+                    return x.get<Int64>();\n+                case Field::Types::Float64:\n+                    return std::bit_cast<UInt64>(x.get<Float64>());\n+                case Field::Types::Bool:\n+                    return x.get<bool>();\n+                case Field::Types::Decimal32:\n+                    return x.get<DecimalField<Decimal32>>().getValue();\n+                case Field::Types::Decimal64:\n+                    return x.get<DecimalField<Decimal64>>().getValue();\n+                default:\n+                    throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Unexpected type in function 'transform'\");\n             }\n-\n-            dst_data.resize(current_dst_offset + dst_ref.size);\n-            memcpy(&dst_data[current_dst_offset], dst_ref.data, dst_ref.size);\n-            current_dst_offset += dst_ref.size;\n-            current_dst_default_offset = dst_default_offsets[i];\n-            dst_offsets[i] = current_dst_offset;\n         }\n-    }\n-\n-\n-    /// Different versions of the hash tables to implement the mapping.\n-\n-    struct Cache\n-    {\n-        using NumToNum = HashMap<UInt64, UInt64, HashCRC32<UInt64>>;\n-        using NumToString = HashMap<UInt64, StringRef, HashCRC32<UInt64>>;     /// Everywhere StringRef's with trailing zero.\n-        using StringToNum = HashMap<StringRef, UInt64, StringRefHash>;\n-        using StringToString = HashMap<StringRef, StringRef, StringRefHash>;\n-\n-        std::unique_ptr<NumToNum> table_num_to_num;\n-        std::unique_ptr<NumToString> table_num_to_string;\n-        std::unique_ptr<StringToNum> table_string_to_num;\n-        std::unique_ptr<StringToString> table_string_to_string;\n-\n-        Arena string_pool;\n-\n-        Field const_default_value;    /// Null, if not specified.\n-\n-        std::atomic<bool> initialized{false};\n-        std::mutex mutex;\n-    };\n \n-    mutable Cache cache;\n-\n-\n-    static UInt64 bitCastToUInt64(const Field & x)\n-    {\n-        switch (x.getType())\n+        static void checkAllowedType(const DataTypePtr & dt)\n         {\n-            case Field::Types::UInt64:      return x.get<UInt64>();\n-            case Field::Types::Int64:       return x.get<Int64>();\n-            case Field::Types::Float64:     return std::bit_cast<UInt64>(x.get<Float64>());\n-            case Field::Types::Bool:        return x.get<bool>();\n-            case Field::Types::Decimal32:   return x.get<DecimalField<Decimal32>>().getValue();\n-            case Field::Types::Decimal64:   return x.get<DecimalField<Decimal64>>().getValue();\n-            default:\n-                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Unexpected type in function 'transform'\");\n+            if (dt->isNullable())\n+                checkAllowedTypeHelper(static_cast<const DataTypeNullable *>(dt.get())->getNestedType());\n+            else\n+                checkAllowedTypeHelper(dt);\n         }\n-    }\n-\n-    /// Can be called from different threads. It works only on the first call.\n-    void initialize(const Array & from, const Array & to, const ColumnsWithTypeAndName & arguments) const\n-    {\n-        if (cache.initialized)\n-            return;\n \n-        const size_t size = from.size();\n-        if (0 == size)\n-            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Empty arrays are illegal in function {}\", getName());\n+        static void checkAllowedTypeHelper(const DataTypePtr & dt)\n+        {\n+            if (isStringOrFixedString(dt))\n+                return;\n+            auto dtsize = dt->getMaximumSizeOfValueInMemory();\n+            if (dtsize <= sizeof(UInt64))\n+                return;\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Unexpected type {} in function 'transform'\", dt->getName());\n+        }\n \n-        std::lock_guard lock(cache.mutex);\n+        /// Can be called from different threads. It works only on the first call.\n+        void initialize(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type) const\n+        {\n+            const ColumnConst * array_from = checkAndGetColumnConst<ColumnArray>(arguments[1].column.get());\n+            const ColumnConst * array_to = checkAndGetColumnConst<ColumnArray>(arguments[2].column.get());\n \n-        if (cache.initialized)\n-            return;\n+            if (!array_from || !array_to)\n+                throw Exception(\n+                    ErrorCodes::ILLEGAL_COLUMN, \"Second and third arguments of function {} must be constant arrays.\", getName());\n \n-        if (size != to.size())\n-            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Second and third arguments of function {} must be arrays of same size\", getName());\n+            if (cache.initialized)\n+                return;\n \n-        Array converted_to;\n-        const Array * used_to = &to;\n+            const auto & from = array_from->getValue<Array>();\n+            const size_t size = from.size();\n+            if (0 == size)\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Empty arrays are illegal in function {}\", getName());\n \n-        /// Whether the default value is set.\n+            std::lock_guard lock(cache.mutex);\n \n-        if (arguments.size() == 4)\n-        {\n-            const IColumn * default_col = arguments[3].column.get();\n-            const ColumnConst * const_default_col = typeid_cast<const ColumnConst *>(default_col);\n+            if (cache.initialized)\n+                return;\n \n-            if (const_default_col)\n-                cache.const_default_value = (*const_default_col)[0];\n+            const auto & to = array_to->getValue<Array>();\n+            if (size != to.size())\n+                throw Exception(\n+                    ErrorCodes::BAD_ARGUMENTS, \"Second and third arguments of function {} must be arrays of same size\", getName());\n \n-            /// Do we need to convert the elements `to` and `default_value` to the smallest common type that is Float64?\n-            bool default_col_is_float =\n-                   checkColumn<ColumnFloat32>(default_col)\n-                || checkColumn<ColumnFloat64>(default_col)\n-                || checkColumnConst<ColumnFloat32>(default_col)\n-                || checkColumnConst<ColumnFloat64>(default_col);\n+            /// Whether the default value is set.\n \n-            bool to_is_float = to[0].getType() == Field::Types::Float64;\n-\n-            if (default_col_is_float && !to_is_float)\n+            if (arguments.size() == 4)\n             {\n-                converted_to.resize(size);\n-                for (size_t i = 0; i < size; ++i)\n-                    converted_to[i] = applyVisitor(FieldVisitorConvertToNumber<Float64>(), to[i]);\n-                used_to = &converted_to;\n-            }\n-            else if (!default_col_is_float && to_is_float)\n-            {\n-                if (const_default_col)\n-                    cache.const_default_value = applyVisitor(FieldVisitorConvertToNumber<Float64>(), cache.const_default_value);\n+                const IColumn * default_col = arguments[3].column.get();\n+                if (default_col && isColumnConst(*default_col))\n+                {\n+                    auto default_column = result_type->createColumn();\n+                    if (!default_col->onlyNull())\n+                    {\n+                        Field f = convertFieldToType((*default_col)[0], *result_type);\n+                        default_column->insert(f);\n+                    }\n+                    else\n+                        default_column->insertDefault();\n+                    cache.default_column = std::move(default_column);\n+                }\n             }\n-        }\n \n-        /// Note: Doesn't check the duplicates in the `from` array.\n+            /// Note: Doesn't check the duplicates in the `from` array.\n \n-        const IDataType & from_type = *arguments[0].type;\n+            const IDataType & from_type = *arguments[0].type;\n \n-        if (from[0].getType() != Field::Types::String)\n-        {\n-            if (to[0].getType() != Field::Types::String)\n+            if (from[0].getType() != Field::Types::String)\n             {\n-                cache.table_num_to_num = std::make_unique<Cache::NumToNum>();\n-                auto & table = *cache.table_num_to_num;\n+                cache.table_num_to_idx = std::make_unique<Cache::NumToIdx>();\n+                auto & table = *cache.table_num_to_idx;\n                 for (size_t i = 0; i < size; ++i)\n                 {\n                     Field key = convertFieldToType(from[i], from_type);\n@@ -1204,55 +715,31 @@ class FunctionTransform : public IFunction\n                         continue;\n \n                     /// Field may be of Float type, but for the purpose of bitwise equality we can treat them as UInt64\n-                    table[bitCastToUInt64(key)] = bitCastToUInt64((*used_to)[i]);\n+                    table[bitCastToUInt64(key)] = i;\n                 }\n             }\n             else\n             {\n-                cache.table_num_to_string = std::make_unique<Cache::NumToString>();\n-                auto & table = *cache.table_num_to_string;\n-                for (size_t i = 0; i < size; ++i)\n-                {\n-                    Field key = convertFieldToType(from[i], from_type);\n-                    if (key.isNull())\n-                        continue;\n-\n-                    const String & str_to = to[i].get<const String &>();\n-                    StringRef ref{cache.string_pool.insert(str_to.data(), str_to.size() + 1), str_to.size() + 1};\n-                    table[bitCastToUInt64(key)] = ref;\n-                }\n-            }\n-        }\n-        else\n-        {\n-            if (to[0].getType() != Field::Types::String)\n-            {\n-                cache.table_string_to_num = std::make_unique<Cache::StringToNum>();\n-                auto & table = *cache.table_string_to_num;\n+                cache.table_string_to_idx = std::make_unique<Cache::StringToIdx>();\n+                auto & table = *cache.table_string_to_idx;\n                 for (size_t i = 0; i < size; ++i)\n                 {\n                     const String & str_from = from[i].get<const String &>();\n                     StringRef ref{cache.string_pool.insert(str_from.data(), str_from.size() + 1), str_from.size() + 1};\n-                    table[ref] = bitCastToUInt64((*used_to)[i]);\n+                    table[ref] = i;\n                 }\n             }\n-            else\n+\n+            auto to_columns = result_type->createColumn();\n+            for (size_t i = 0; i < size; ++i)\n             {\n-                cache.table_string_to_string = std::make_unique<Cache::StringToString>();\n-                auto & table = *cache.table_string_to_string;\n-                for (size_t i = 0; i < size; ++i)\n-                {\n-                    const String & str_from = from[i].get<const String &>();\n-                    const String & str_to = to[i].get<const String &>();\n-                    StringRef ref_from{cache.string_pool.insert(str_from.data(), str_from.size() + 1), str_from.size() + 1};\n-                    StringRef ref_to{cache.string_pool.insert(str_to.data(), str_to.size() + 1), str_to.size() + 1};\n-                    table[ref_from] = ref_to;\n-                }\n+                Field to_value = convertFieldToType(to[i], *result_type);\n+                to_columns->insert(to_value);\n             }\n-        }\n+            cache.to_columns = std::move(to_columns);\n \n-        cache.initialized = true;\n-    }\n+            cache.initialized = true;\n+        }\n };\n \n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02125_transform_decimal_bug.reference b/tests/queries/0_stateless/02125_transform_decimal_bug.reference\nindex 7f59d0ee7bf6..d1bf333ec8e1 100644\n--- a/tests/queries/0_stateless/02125_transform_decimal_bug.reference\n+++ b/tests/queries/0_stateless/02125_transform_decimal_bug.reference\n@@ -1,3 +1,4 @@\n+1\n 0\n 1\n 2\ndiff --git a/tests/queries/0_stateless/02125_transform_decimal_bug.sql b/tests/queries/0_stateless/02125_transform_decimal_bug.sql\nindex 4ef471ea875e..002f60076e9a 100644\n--- a/tests/queries/0_stateless/02125_transform_decimal_bug.sql\n+++ b/tests/queries/0_stateless/02125_transform_decimal_bug.sql\n@@ -1,4 +1,4 @@\n-SELECT transform(1, [1], [toDecimal32(1, 2)]); -- { serverError 44 }\n+SELECT transform(1, [1], [toDecimal32(1, 2)]);\n SELECT transform(toDecimal32(number, 2), [toDecimal32(3, 2)], [toDecimal32(30, 2)]) FROM system.numbers LIMIT 10;\n SELECT transform(toDecimal32(number, 2), [toDecimal32(3, 2)], [toDecimal32(30, 2)], toDecimal32(1000, 2)) FROM system.numbers LIMIT 10;\n SELECT transform(number, [3, 5, 11], [toDecimal32(30, 2), toDecimal32(50, 2), toDecimal32(70,2)], toDecimal32(1000, 2)) FROM system.numbers LIMIT 10;\ndiff --git a/tests/queries/0_stateless/02163_operators.sql b/tests/queries/0_stateless/02163_operators.sql\nindex b2414bb197ef..3f2d7d8bbb7a 100644\n--- a/tests/queries/0_stateless/02163_operators.sql\n+++ b/tests/queries/0_stateless/02163_operators.sql\n@@ -1,2 +1,2 @@\n-WITH 2 AS `b.c`, [4, 5] AS a, 6 AS u, 3 AS v, 2 AS d, TRUE AS e, 1 AS f, 0 AS g, 2 AS h, 'Hello' AS i, 'World' AS j, TIMESTAMP '2022-02-02 02:02:02' AS w, [] AS k, (1, 2) AS l, 2 AS m, 3 AS n, [] AS o, [1] AS p, 1 AS q, q AS r, 1 AS s, 1 AS t\n+WITH 2 AS `b.c`, [4, 5] AS a, 6 AS u, 3 AS v, 2 AS d, TRUE AS e, 1 AS f, 0 AS g, 2 AS h, 'Hello' AS i, 'World' AS j, 'hi' AS w, NULL AS k, (1, 2) AS l, 2 AS m, 3 AS n, [] AS o, [1] AS p, 1 AS q, q AS r, 1 AS s, 1 AS t\n SELECT INTERVAL CASE CASE WHEN NOT -a[`b.c`] * u DIV v + d IS NOT NULL AND e OR f BETWEEN g AND h THEN i ELSE j END WHEN w THEN k END || [l, (m, n)] MINUTE IS NULL OR NOT o::Array(INT) = p <> q < r > s != t AS upyachka;\ndiff --git a/tests/queries/0_stateless/02497_if_transform_strings_to_enum.reference b/tests/queries/0_stateless/02497_if_transform_strings_to_enum.reference\nindex f5284f38b86a..a1a653361ee2 100644\n--- a/tests/queries/0_stateless/02497_if_transform_strings_to_enum.reference\n+++ b/tests/queries/0_stateless/02497_if_transform_strings_to_enum.reference\n@@ -405,16 +405,6 @@ QUERY id: 0\n     TABLE id: 7, table_name: system.numbers\n   LIMIT\n     CONSTANT id: 17, constant_value: UInt64_10, constant_value_type: UInt64\n-\\N\n-\\N\n-\\N\n-\\N\n-\\N\n-\\N\n-\\N\n-\\N\n-\\N\n-\\N\n SELECT transform(number, [NULL], _CAST([\\'google\\', \\'censor.net\\', \\'yahoo\\'], \\'Array(Enum8(\\\\\\'censor.net\\\\\\' = 1, \\\\\\'google\\\\\\' = 2, \\\\\\'other\\\\\\' = 3, \\\\\\'yahoo\\\\\\' = 4))\\'), _CAST(\\'other\\', \\'Enum8(\\\\\\'censor.net\\\\\\' = 1, \\\\\\'google\\\\\\' = 2, \\\\\\'other\\\\\\' = 3, \\\\\\'yahoo\\\\\\' = 4)\\'))\n FROM\n (\n@@ -424,56 +414,38 @@ FROM\n )\n QUERY id: 0\n   PROJECTION COLUMNS\n-    transform(number, [NULL], [\\'google\\', \\'censor.net\\', \\'yahoo\\'], \\'other\\') Nullable(Nothing)\n+    transform(number, [NULL], [\\'google\\', \\'censor.net\\', \\'yahoo\\'], \\'other\\') String\n   PROJECTION\n     LIST id: 1, nodes: 1\n-      FUNCTION id: 2, function_name: transform, function_type: ordinary, result_type: Nullable(Nothing)\n+      FUNCTION id: 2, function_name: toString, function_type: ordinary, result_type: String\n         ARGUMENTS\n-          LIST id: 3, nodes: 4\n-            COLUMN id: 4, column_name: number, result_type: Nullable(Nothing), source_id: 5\n-            CONSTANT id: 6, constant_value: Array_[NULL], constant_value_type: Array(Nullable(Nothing))\n-            CONSTANT id: 7, constant_value: Array_[\\'google\\', \\'censor.net\\', \\'yahoo\\'], constant_value_type: Array(String)\n-            CONSTANT id: 8, constant_value: \\'other\\', constant_value_type: String\n+          LIST id: 3, nodes: 1\n+            FUNCTION id: 4, function_name: transform, function_type: ordinary, result_type: Enum8(\\'censor.net\\' = 1, \\'google\\' = 2, \\'other\\' = 3, \\'yahoo\\' = 4)\n+              ARGUMENTS\n+                LIST id: 5, nodes: 4\n+                  COLUMN id: 6, column_name: number, result_type: Nullable(Nothing), source_id: 7\n+                  CONSTANT id: 8, constant_value: Array_[NULL], constant_value_type: Array(Nullable(Nothing))\n+                  FUNCTION id: 9, function_name: _CAST, function_type: ordinary, result_type: Array(Enum8(\\'censor.net\\' = 1, \\'google\\' = 2, \\'other\\' = 3, \\'yahoo\\' = 4))\n+                    ARGUMENTS\n+                      LIST id: 10, nodes: 2\n+                        CONSTANT id: 11, constant_value: Array_[\\'google\\', \\'censor.net\\', \\'yahoo\\'], constant_value_type: Array(String)\n+                        CONSTANT id: 12, constant_value: \\'Array(Enum8(\\\\\\'censor.net\\\\\\' = 1, \\\\\\'google\\\\\\' = 2, \\\\\\'other\\\\\\' = 3, \\\\\\'yahoo\\\\\\' = 4))\\', constant_value_type: String\n+                  FUNCTION id: 13, function_name: _CAST, function_type: ordinary, result_type: Enum8(\\'censor.net\\' = 1, \\'google\\' = 2, \\'other\\' = 3, \\'yahoo\\' = 4)\n+                    ARGUMENTS\n+                      LIST id: 14, nodes: 2\n+                        CONSTANT id: 15, constant_value: \\'other\\', constant_value_type: String\n+                        CONSTANT id: 16, constant_value: \\'Enum8(\\\\\\'censor.net\\\\\\' = 1, \\\\\\'google\\\\\\' = 2, \\\\\\'other\\\\\\' = 3, \\\\\\'yahoo\\\\\\' = 4)\\', constant_value_type: String\n   JOIN TREE\n-    QUERY id: 5, is_subquery: 1\n+    QUERY id: 7, is_subquery: 1\n       PROJECTION COLUMNS\n         number Nullable(Nothing)\n       PROJECTION\n-        LIST id: 9, nodes: 1\n-          CONSTANT id: 10, constant_value: NULL, constant_value_type: Nullable(Nothing)\n+        LIST id: 17, nodes: 1\n+          CONSTANT id: 18, constant_value: NULL, constant_value_type: Nullable(Nothing)\n       JOIN TREE\n-        TABLE id: 11, table_name: system.numbers\n+        TABLE id: 19, table_name: system.numbers\n       LIMIT\n-        CONSTANT id: 12, constant_value: UInt64_10, constant_value_type: UInt64\n-\\N\n-\\N\n-\\N\n-\\N\n-\\N\n-\\N\n-\\N\n-\\N\n-\\N\n-\\N\n-SELECT transform(number, NULL, _CAST([\\'google\\', \\'censor.net\\', \\'yahoo\\'], \\'Array(Enum8(\\\\\\'censor.net\\\\\\' = 1, \\\\\\'google\\\\\\' = 2, \\\\\\'other\\\\\\' = 3, \\\\\\'yahoo\\\\\\' = 4))\\'), _CAST(\\'other\\', \\'Enum8(\\\\\\'censor.net\\\\\\' = 1, \\\\\\'google\\\\\\' = 2, \\\\\\'other\\\\\\' = 3, \\\\\\'yahoo\\\\\\' = 4)\\'))\n-FROM system.numbers\n-LIMIT 10\n-QUERY id: 0\n-  PROJECTION COLUMNS\n-    transform(number, NULL, [\\'google\\', \\'censor.net\\', \\'yahoo\\'], \\'other\\') Nullable(Nothing)\n-  PROJECTION\n-    LIST id: 1, nodes: 1\n-      FUNCTION id: 2, function_name: transform, function_type: ordinary, result_type: Nullable(Nothing)\n-        ARGUMENTS\n-          LIST id: 3, nodes: 4\n-            COLUMN id: 4, column_name: number, result_type: UInt64, source_id: 5\n-            CONSTANT id: 6, constant_value: NULL, constant_value_type: Nullable(Nothing)\n-            CONSTANT id: 7, constant_value: Array_[\\'google\\', \\'censor.net\\', \\'yahoo\\'], constant_value_type: Array(String)\n-            CONSTANT id: 8, constant_value: \\'other\\', constant_value_type: String\n-  JOIN TREE\n-    TABLE id: 5, table_name: system.numbers\n-  LIMIT\n-    CONSTANT id: 9, constant_value: UInt64_10, constant_value_type: UInt64\n+        CONSTANT id: 20, constant_value: UInt64_10, constant_value_type: UInt64\n other\n other\n google\ndiff --git a/tests/queries/0_stateless/02497_if_transform_strings_to_enum.sql b/tests/queries/0_stateless/02497_if_transform_strings_to_enum.sql\nindex c23046c7b208..492d42cb6bc2 100644\n--- a/tests/queries/0_stateless/02497_if_transform_strings_to_enum.sql\n+++ b/tests/queries/0_stateless/02497_if_transform_strings_to_enum.sql\n@@ -33,13 +33,13 @@ SELECT transform(number, [2, 4, 6], ['google', 'censor.net', 'yahoo'], 'other')\n EXPLAIN SYNTAX SELECT transform(number, [2, 4, 6], ['google', 'censor.net', 'yahoo'], 'other') as value, value FROM system.numbers LIMIT 10;\n EXPLAIN QUERY TREE run_passes = 1 SELECT transform(number, [2, 4, 6], ['google', 'censor.net', 'yahoo'], 'other') as value, value FROM system.numbers LIMIT 10;\n \n-SELECT transform(number, [NULL], ['google', 'censor.net', 'yahoo'], 'other') FROM (SELECT NULL as number FROM system.numbers LIMIT 10);\n+SELECT transform(number, [NULL], ['google', 'censor.net', 'yahoo'], 'other') FROM (SELECT NULL as number FROM system.numbers LIMIT 10); -- { serverError 36 }\n EXPLAIN SYNTAX SELECT transform(number, [NULL], ['google', 'censor.net', 'yahoo'], 'other') FROM (SELECT NULL as number FROM system.numbers LIMIT 10);\n EXPLAIN QUERY TREE run_passes = 1 SELECT transform(number, [NULL], ['google', 'censor.net', 'yahoo'], 'other') FROM (SELECT NULL as number FROM system.numbers LIMIT 10);\n \n-SELECT transform(number, NULL, ['google', 'censor.net', 'yahoo'], 'other') FROM system.numbers LIMIT 10;\n-EXPLAIN SYNTAX SELECT transform(number, NULL, ['google', 'censor.net', 'yahoo'], 'other') FROM system.numbers LIMIT 10;\n-EXPLAIN QUERY TREE run_passes = 1 SELECT transform(number, NULL, ['google', 'censor.net', 'yahoo'], 'other') FROM system.numbers LIMIT 10;\n+SELECT transform(number, NULL, ['google', 'censor.net', 'yahoo'], 'other') FROM system.numbers LIMIT 10; -- { serverError 43 }\n+EXPLAIN SYNTAX SELECT transform(number, NULL, ['google', 'censor.net', 'yahoo'], 'other') FROM system.numbers LIMIT 10; -- { serverError 43 }\n+EXPLAIN QUERY TREE run_passes = 1 SELECT transform(number, NULL, ['google', 'censor.net', 'yahoo'], 'other') FROM system.numbers LIMIT 10; -- { serverError 43 }\n \n SET optimize_if_transform_strings_to_enum = 0;\n \ndiff --git a/tests/queries/0_stateless/02542_case_no_else.reference b/tests/queries/0_stateless/02542_case_no_else.reference\nnew file mode 100644\nindex 000000000000..8f3fdf29168a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02542_case_no_else.reference\n@@ -0,0 +1,3 @@\n+2\n+1\tZ\n+1\tZ\ndiff --git a/tests/queries/0_stateless/02542_case_no_else.sql b/tests/queries/0_stateless/02542_case_no_else.sql\nnew file mode 100644\nindex 000000000000..0c7975a750ee\n--- /dev/null\n+++ b/tests/queries/0_stateless/02542_case_no_else.sql\n@@ -0,0 +1,14 @@\n+SELECT CASE 1 WHEN 1 THEN 2 END;\n+\n+SELECT id,\n+    CASE id\n+         WHEN 1 THEN 'Z'\n+    END x\n+FROM  (SELECT 1 as id);\n+\n+SELECT id,\n+       CASE id\n+            WHEN 1 THEN 'Z'\n+            ELSE 'X'\n+     END x\n+FROM  (SELECT 1 as id);\ndiff --git a/tests/queries/0_stateless/02542_transform_new.reference b/tests/queries/0_stateless/02542_transform_new.reference\nnew file mode 100644\nindex 000000000000..b6eaa692c416\n--- /dev/null\n+++ b/tests/queries/0_stateless/02542_transform_new.reference\n@@ -0,0 +1,32 @@\n+1\n+1\n+1\n+1\n+9\n+9\n+\\N\n+7\n+1\n+9\n+7\n+b\n+b\n+b\n+b\n+a\n+a\n+\\N\n+c\n+sep1\n+80000\n+80000\n+sep2\n+80000\n+80000\n+sep3\n+1\n+sep4\n+8000\n+sep5\n+8000\n+sep6\ndiff --git a/tests/queries/0_stateless/02542_transform_new.sql b/tests/queries/0_stateless/02542_transform_new.sql\nnew file mode 100644\nindex 000000000000..43da0a507317\n--- /dev/null\n+++ b/tests/queries/0_stateless/02542_transform_new.sql\n@@ -0,0 +1,35 @@\n+select transform(2, [1,2], [9,1], materialize(null));\n+select transform(2, [1,2], [9,1], materialize(7));\n+select transform(2, [1,2], [9,1], null);\n+select transform(2, [1,2], [9,1], 7);\n+select transform(1, [1,2], [9,1], null);\n+select transform(1, [1,2], [9,1], 7);\n+select transform(5, [1,2], [9,1], null);\n+select transform(5, [1,2], [9,1], 7);\n+select transform(2, [1,2], [9,1]);\n+select transform(1, [1,2], [9,1]);\n+select transform(7, [1,2], [9,1]);\n+\n+select transform(2, [1,2], ['a','b'], materialize(null));\n+select transform(2, [1,2], ['a','b'], materialize('c'));\n+select transform(2, [1,2], ['a','b'], null);\n+select transform(2, [1,2], ['a','b'], 'c');\n+select transform(1, [1,2], ['a','b'], null);\n+select transform(1, [1,2], ['a','b'], 'c');\n+select transform(5, [1,2], ['a','b'], null);\n+select transform(5, [1,2], ['a','b'], 'c');\n+\n+select 'sep1';\n+SELECT transform(number, [2], [toDecimal32(1, 1)], materialize(80000)) as x FROM numbers(2);\n+select 'sep2';\n+SELECT transform(number, [2], [toDecimal32(1, 1)], 80000) as x FROM numbers(2);\n+select 'sep3';\n+SELECT transform(toDecimal32(2, 1), [toDecimal32(2, 1)], [1]);\n+select 'sep4';\n+SELECT transform(8000, [1], [toDecimal32(2, 1)]);\n+select 'sep5';\n+SELECT transform(toDecimal32(8000,0), [1], [toDecimal32(2, 1)]);\n+select 'sep6';\n+SELECT transform(-9223372036854775807, [-1], [toDecimal32(1024, 3)]) FROM system.numbers LIMIT 7; -- { serverError BAD_ARGUMENTS }\n+SELECT [NULL, NULL, NULL, NULL], transform(number, [2147483648], [toDecimal32(1, 2)]) AS x FROM numbers(257) WHERE materialize(10); -- { serverError BAD_ARGUMENTS }\n+SELECT transform(-2147483649, [1], [toDecimal32(1, 2)]) GROUP BY [1] WITH TOTALS; -- { serverError BAD_ARGUMENTS }\ndiff --git a/tests/queries/0_stateless/02542_transform_old.reference b/tests/queries/0_stateless/02542_transform_old.reference\nnew file mode 100644\nindex 000000000000..d03b17d40a32\n--- /dev/null\n+++ b/tests/queries/0_stateless/02542_transform_old.reference\n@@ -0,0 +1,72 @@\n+google\n+other\n+yahoo\n+yandex\n+#1\n+20\n+21\n+22\n+29\n+#2\n+0\n+1\n+3\n+5\n+7\n+8\n+9\n+20\n+21\n+29\n+#3\n+20\n+21\n+22\n+29\n+#4\n+google\n+other\n+yahoo\n+yandex\n+#5\n+0\n+1\n+3\n+5\n+7\n+8\n+9\n+google\n+yahoo\n+yandex\n+----\n+google\n+other\n+yahoo\n+yandex\n+#1\n+20\n+21\n+22\n+29\n+#3\n+20\n+21\n+22\n+29\n+#4\n+google\n+other\n+yahoo\n+yandex\n+----\n+2000\n+2100\n+2200\n+2900\n+#1\n+2000\n+2100\n+2200\n+2900\n+----\ndiff --git a/tests/queries/0_stateless/02542_transform_old.sql b/tests/queries/0_stateless/02542_transform_old.sql\nnew file mode 100644\nindex 000000000000..01a960ec3674\n--- /dev/null\n+++ b/tests/queries/0_stateless/02542_transform_old.sql\n@@ -0,0 +1,25 @@\n+SELECT transform(number, [2, 4, 6], ['google', 'yandex', 'yahoo'], 'other') as x FROM numbers(10) GROUP BY x ORDER BY x;\n+SELECT '#1';\n+SELECT transform(number, [2, 4, 6], [29, 20, 21], 22) as x FROM numbers(10) GROUP BY x ORDER BY x;\n+SELECT '#2';\n+SELECT transform(number, [2, 4, 6], [29, 20, 21]) as x FROM numbers(10) GROUP BY x ORDER BY x;\n+SELECT '#3';\n+SELECT transform(toString(number), ['2', '4', '6'], [29, 20, 21], 22) as x FROM numbers(10) GROUP BY x ORDER BY x;\n+SELECT '#4';\n+SELECT transform(toString(number), ['2', '4', '6'], ['google', 'yandex', 'yahoo'], 'other') as x FROM numbers(10) GROUP BY x ORDER BY x;\n+SELECT '#5';\n+SELECT transform(toString(number), ['2', '4', '6'], ['google', 'yandex', 'yahoo']) as x FROM numbers(10) GROUP BY x ORDER BY x;\n+SELECT '----';\n+SELECT transform(number, [2, 4, 6], ['google', 'yandex', 'yahoo'], materialize('other')) as x FROM numbers(10) GROUP BY x ORDER BY x;\n+SELECT '#1';\n+SELECT transform(number, [2, 4, 6], [29, 20, 21], materialize(22)) as x FROM numbers(10) GROUP BY x ORDER BY x;\n+SELECT '#3';\n+SELECT transform(toString(number), ['2', '4', '6'], [29, 20, 21], materialize(22)) as x FROM numbers(10) GROUP BY x ORDER BY x;\n+SELECT '#4';\n+SELECT transform(toString(number), ['2', '4', '6'], ['google', 'yandex', 'yahoo'], materialize('other')) as x FROM numbers(10) GROUP BY x ORDER BY x;\n+SELECT '----';\n+SELECT transform(number, [2, 4, 6], [2900, 2000, 2100], 2200) as x FROM numbers(10) GROUP BY x ORDER BY x;\n+SELECT '#1';\n+SELECT transform(number, [2, 4, 6], [2900, 2000, 2100], materialize(2200)) as x FROM numbers(10) GROUP BY x ORDER BY x;\n+SELECT '----';\n+SELECT transform(number, [1], [null]) FROM system.numbers LIMIT 1; -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n",
  "problem_statement": "CASE  unexpected behaviour\n```\r\nSELECT id,  \r\n    CASE id \r\n         WHEN 1 THEN 'Z'  \r\n    END x \r\nFROM  (SELECT 1 as id)\r\n\r\n\u250c\u2500id\u2500\u252c\u2500x\u2500\u2500\u2500\u2500\u2510\r\n\u2502  1 \u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nSELECT id,  \r\n       CASE id \r\n            WHEN 1 THEN 'Z' \r\n            ELSE 'X' \r\n     END x \r\nFROM  (SELECT 1 as id)\r\n\r\n\u250c\u2500id\u2500\u252c\u2500x\u2500\u2510\r\n\u2502  1 \u2502 Z \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\r\n18.14.18, 19.16.1.1414 \r\n```\n",
  "hints_text": "Minimal example:\r\n\r\n```\r\nSELECT CASE 1 WHEN 1 THEN 2 END\r\n```\nFrom internal task tracker:\r\n```\r\n\u041d\u0443\u0436\u043d\u043e \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c generic \u0432\u0430\u0440\u0438\u0430\u043d\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 transform.\r\n\r\n\u0414\u043b\u044f \u044d\u0442\u043e\u0433\u043e:\r\n- \u0435\u0441\u043b\u0438 \u043f\u0440\u0438\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442 default, \u0442\u043e \u043f\u0440\u0438\u0432\u043e\u0434\u0438\u043c \u0442\u0438\u043f\u044b \u043c\u0430\u0441\u0441\u0438\u0432\u0430 dst \u0438 default \u043a \u043d\u0430\u0438\u043c\u0435\u043d\u044c\u0448\u0435\u043c\u0443 \u043e\u0431\u0449\u0435\u043c\u0443 \u0442\u0438\u043f\u0443;\r\n- \u0441\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 %%src_hash -> array_index_in_dst%%;\r\n- \u0444\u043e\u0440\u043c\u0438\u0440\u0443\u0435\u043c \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u043c\u0435\u0442\u043e\u0434\u0430 %%IColumn::insertFrom%%;\r\n\r\n\u0421\u0442\u043e\u0438\u0442 \u043e\u0431\u0440\u0430\u0442\u0438\u0442\u044c \u0432\u043d\u0438\u043c\u0430\u043d\u0438\u0435, \u0447\u0442\u043e \u044d\u0442\u043e \u043c\u043e\u0436\u0435\u0442 \u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u043a\u0430\u043a \u0441 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u043d\u044b\u043c, \u0442\u0430\u043a \u0438 \u0441 \u043d\u0435\u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u043d\u044b\u043c \u043c\u0430\u0441\u0441\u0438\u0432\u043e\u043c dst \u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435\u043c default. \u041c\u043e\u0436\u043d\u043e \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0432\u0441\u0435 \u044d\u0442\u0438 \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u044b.\r\n\r\n\u0422\u0430\u043a\u0436\u0435 \u043c\u043e\u0436\u043d\u043e \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0432\u0430\u0440\u0438\u0430\u043d\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 transform, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043c\u043e\u0436\u0435\u0442 \u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u0441 \u043d\u0435\u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u043d\u044b\u043c \u043c\u0430\u0441\u0441\u0438\u0432\u043e\u043c src.\r\n\u0414\u043b\u044f \u044d\u0442\u043e\u0433\u043e \u0431\u0443\u0434\u0435\u043c \u0438\u0441\u043a\u0430\u0442\u044c \u0438\u043d\u0434\u0435\u043a\u0441 \u0432 \u043d\u0451\u043c \u043d\u0435 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u043f\u043e\u0438\u0441\u043a\u0430 \u043f\u043e \u0437\u0430\u0440\u0430\u043d\u0435\u0435 \u0441\u043e\u0437\u0434\u0430\u043d\u043d\u043e\u0439 \u0445\u044d\u0448-\u0442\u0430\u0431\u043b\u0438\u0446\u0435, \u0430 \u043f\u0443\u0442\u0451\u043c \u043f\u0435\u0440\u0435\u0431\u043e\u0440\u0430 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0441\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0439 %%IColumn::compareAt%%. \u0410\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u043d\u043e %%transform(x, from, to, default) = indexOf(from, x) = 0 ? default : to[indexOf(from, x)]%%\r\n```\n```sql\r\n\r\n select c.* ,\r\n                    case  when timeInForce = 'IOC' then 3\r\n                          else null end time_in_force,\r\n                    case  timeInForce  when 'IOC' then 3\r\n                          else null end time_in_force2\r\n               from ( select 'IOC' timeInForce ) c\r\n\r\n\u250c\u2500timeInForce\u2500\u252c\u2500time_in_force\u2500\u252c\u2500time_in_force2\u2500\u2510\r\n\u2502 IOC         \u2502             3 \u2502 \u1d3a\u1d41\u1d38\u1d38           \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nI'd like this to be assigned to me.",
  "created_at": "2023-03-31T16:13:32Z"
}