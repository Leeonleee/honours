{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 6409,
  "instance_id": "ClickHouse__ClickHouse-6409",
  "issue_numbers": [
    "6401"
  ],
  "base_commit": "62a6248ca9d212e8f70e053905329cd2cabecf19",
  "patch": "diff --git a/dbms/src/DataTypes/DataTypeAggregateFunction.cpp b/dbms/src/DataTypes/DataTypeAggregateFunction.cpp\nindex a2c00e18acb9..b53b7529f952 100644\n--- a/dbms/src/DataTypes/DataTypeAggregateFunction.cpp\n+++ b/dbms/src/DataTypes/DataTypeAggregateFunction.cpp\n@@ -366,7 +366,7 @@ static DataTypePtr create(const ASTPtr & arguments)\n             params_row[i] = literal->value;\n         }\n     }\n-    else if (auto opt_name = getIdentifierName(arguments->children[0]))\n+    else if (auto opt_name = tryGetIdentifierName(arguments->children[0]))\n     {\n         function_name = *opt_name;\n     }\ndiff --git a/dbms/src/DataTypes/DataTypeCustomSimpleAggregateFunction.cpp b/dbms/src/DataTypes/DataTypeCustomSimpleAggregateFunction.cpp\nindex 2cb0f87facd3..8151ccf19483 100644\n--- a/dbms/src/DataTypes/DataTypeCustomSimpleAggregateFunction.cpp\n+++ b/dbms/src/DataTypes/DataTypeCustomSimpleAggregateFunction.cpp\n@@ -88,7 +88,7 @@ static std::pair<DataTypePtr, DataTypeCustomDescPtr> create(const ASTPtr & argum\n             params_row[i] = lit->value;\n         }\n     }\n-    else if (auto opt_name = getIdentifierName(arguments->children[0]))\n+    else if (auto opt_name = tryGetIdentifierName(arguments->children[0]))\n     {\n         function_name = *opt_name;\n     }\ndiff --git a/dbms/src/Interpreters/ActionsVisitor.cpp b/dbms/src/Interpreters/ActionsVisitor.cpp\nindex d0237f7cb88e..523343a288e7 100644\n--- a/dbms/src/Interpreters/ActionsVisitor.cpp\n+++ b/dbms/src/Interpreters/ActionsVisitor.cpp\n@@ -463,7 +463,7 @@ void ActionsVisitor::visit(const ASTPtr & ast)\n \n                     for (size_t j = 0; j < lambda_arg_asts.size(); ++j)\n                     {\n-                        auto opt_arg_name = getIdentifierName(lambda_arg_asts[j]);\n+                        auto opt_arg_name = tryGetIdentifierName(lambda_arg_asts[j]);\n                         if (!opt_arg_name)\n                             throw Exception(\"lambda argument declarations must be identifiers\", ErrorCodes::TYPE_MISMATCH);\n \ndiff --git a/dbms/src/Interpreters/ColumnNamesContext.h b/dbms/src/Interpreters/ColumnNamesContext.h\nindex 72f5f8f86846..c30102cf8d7d 100644\n--- a/dbms/src/Interpreters/ColumnNamesContext.h\n+++ b/dbms/src/Interpreters/ColumnNamesContext.h\n@@ -39,7 +39,7 @@ struct ColumnNamesContext\n         std::optional<String> name() const\n         {\n             if (expr)\n-                return getIdentifierName(expr->database_and_table_name);\n+                return tryGetIdentifierName(expr->database_and_table_name);\n             return {};\n         }\n \ndiff --git a/dbms/src/Interpreters/GlobalSubqueriesVisitor.h b/dbms/src/Interpreters/GlobalSubqueriesVisitor.h\nindex 229fa00a59fb..1622c27f62f6 100644\n--- a/dbms/src/Interpreters/GlobalSubqueriesVisitor.h\n+++ b/dbms/src/Interpreters/GlobalSubqueriesVisitor.h\n@@ -75,7 +75,7 @@ class GlobalSubqueriesMatcher\n             if (is_table)\n             {\n                 /// If this is already an external table, you do not need to add anything. Just remember its presence.\n-                if (external_tables.end() != external_tables.find(*getIdentifierName(subquery_or_table_name)))\n+                if (external_tables.end() != external_tables.find(getIdentifierName(subquery_or_table_name)))\n                     return;\n             }\n \ndiff --git a/dbms/src/Interpreters/QueryNormalizer.cpp b/dbms/src/Interpreters/QueryNormalizer.cpp\nindex cea801c7c2f0..844c53c79ace 100644\n--- a/dbms/src/Interpreters/QueryNormalizer.cpp\n+++ b/dbms/src/Interpreters/QueryNormalizer.cpp\n@@ -74,7 +74,7 @@ void QueryNormalizer::visit(ASTFunction & node, const ASTPtr &, Data & data)\n     if (functionIsInOrGlobalInOperator(func_name))\n     {\n         auto & ast = func_arguments->children.at(1);\n-        if (auto opt_name = getIdentifierName(ast))\n+        if (auto opt_name = tryGetIdentifierName(ast))\n             if (!aliases.count(*opt_name))\n                 setIdentifierSpecial(ast);\n     }\ndiff --git a/dbms/src/Interpreters/TranslateQualifiedNamesVisitor.cpp b/dbms/src/Interpreters/TranslateQualifiedNamesVisitor.cpp\nindex 34b59d4f993e..7ae98d3e9c84 100644\n--- a/dbms/src/Interpreters/TranslateQualifiedNamesVisitor.cpp\n+++ b/dbms/src/Interpreters/TranslateQualifiedNamesVisitor.cpp\n@@ -253,7 +253,7 @@ void TranslateQualifiedNamesMatcher::extractJoinUsingColumns(const ASTPtr ast, D\n     {\n         const auto & keys = table_join.using_expression_list->as<ASTExpressionList &>();\n         for (const auto & key : keys.children)\n-            if (auto opt_column = getIdentifierName(key))\n+            if (auto opt_column = tryGetIdentifierName(key))\n                 data.join_using_columns.insert(*opt_column);\n             else if (key->as<ASTLiteral>())\n                 data.join_using_columns.insert(key->getColumnName());\ndiff --git a/dbms/src/Interpreters/executeQuery.cpp b/dbms/src/Interpreters/executeQuery.cpp\nindex 5c7617aa8a14..36bdcc27634f 100644\n--- a/dbms/src/Interpreters/executeQuery.cpp\n+++ b/dbms/src/Interpreters/executeQuery.cpp\n@@ -565,7 +565,7 @@ void executeQuery(\n             }\n \n             String format_name = ast_query_with_output && (ast_query_with_output->format != nullptr)\n-                ? *getIdentifierName(ast_query_with_output->format)\n+                ? getIdentifierName(ast_query_with_output->format)\n                 : context.getDefaultFormat();\n \n             if (ast_query_with_output && ast_query_with_output->settings_ast)\n@@ -610,7 +610,7 @@ void executeQuery(\n             }\n \n             String format_name = ast_query_with_output && (ast_query_with_output->format != nullptr)\n-                                 ? *getIdentifierName(ast_query_with_output->format)\n+                                 ? getIdentifierName(ast_query_with_output->format)\n                                  : context.getDefaultFormat();\n \n             if (ast_query_with_output && ast_query_with_output->settings_ast)\ndiff --git a/dbms/src/Parsers/ASTIdentifier.cpp b/dbms/src/Parsers/ASTIdentifier.cpp\nindex fe806ce795a9..e3948f99f5b0 100644\n--- a/dbms/src/Parsers/ASTIdentifier.cpp\n+++ b/dbms/src/Parsers/ASTIdentifier.cpp\n@@ -1,5 +1,6 @@\n #include <Common/typeid_cast.h>\n #include <Parsers/ASTIdentifier.h>\n+#include <Parsers/queryToString.h>\n #include <IO/WriteBufferFromOStream.h>\n #include <IO/WriteHelpers.h>\n #include <Interpreters/IdentifierSemantic.h>\n@@ -8,6 +9,12 @@\n namespace DB\n {\n \n+namespace ErrorCodes\n+{\n+    extern const int UNEXPECTED_AST_STRUCTURE;\n+}\n+\n+\n ASTPtr ASTIdentifier::clone() const\n {\n     auto ret = std::make_shared<ASTIdentifier>(*this);\n@@ -92,22 +99,32 @@ ASTPtr createTableIdentifier(const String & database_name, const String & table_\n     return database_and_table;\n }\n \n-std::optional<String> getIdentifierName(const IAST * const ast)\n+String getIdentifierName(const IAST * ast)\n {\n-    if (ast)\n-        if (const auto * node = ast->as<ASTIdentifier>())\n-            return node->name;\n+    String res;\n+    if (tryGetIdentifierNameInto(ast, res))\n+        return res;\n+    throw Exception(ast ? queryToString(*ast) + \" is not an identifier\" : \"AST node is nullptr\", ErrorCodes::UNEXPECTED_AST_STRUCTURE);\n+}\n+\n+std::optional<String> tryGetIdentifierName(const IAST * ast)\n+{\n+    String res;\n+    if (tryGetIdentifierNameInto(ast, res))\n+        return res;\n     return {};\n }\n \n-bool getIdentifierName(const ASTPtr & ast, String & name)\n+bool tryGetIdentifierNameInto(const IAST * ast, String & name)\n {\n     if (ast)\n+    {\n         if (const auto * node = ast->as<ASTIdentifier>())\n         {\n             name = node->name;\n             return true;\n         }\n+    }\n     return false;\n }\n \ndiff --git a/dbms/src/Parsers/ASTIdentifier.h b/dbms/src/Parsers/ASTIdentifier.h\nindex 01f7766f1ef3..3aaf7381138a 100644\n--- a/dbms/src/Parsers/ASTIdentifier.h\n+++ b/dbms/src/Parsers/ASTIdentifier.h\n@@ -70,9 +70,12 @@ class ASTIdentifier : public ASTWithAlias\n ASTPtr createTableIdentifier(const String & database_name, const String & table_name);\n void setIdentifierSpecial(ASTPtr & ast);\n \n-std::optional<String> getIdentifierName(const IAST * const ast);\n-inline std::optional<String> getIdentifierName(const ASTPtr & ast) { return getIdentifierName(ast.get()); }\n-bool getIdentifierName(const ASTPtr & ast, String & name);\n+String getIdentifierName(const IAST * ast);\n+std::optional<String> tryGetIdentifierName(const IAST * ast);\n+bool tryGetIdentifierNameInto(const IAST * ast, String & name);\n \n+inline String getIdentifierName(const ASTPtr & ast) { return getIdentifierName(ast.get()); }\n+inline std::optional<String> tryGetIdentifierName(const ASTPtr & ast) { return tryGetIdentifierName(ast.get()); }\n+inline bool tryGetIdentifierNameInto(const ASTPtr & ast, String & name) { return tryGetIdentifierNameInto(ast.get(), name); }\n \n }\ndiff --git a/dbms/src/Parsers/ExpressionElementParsers.cpp b/dbms/src/Parsers/ExpressionElementParsers.cpp\nindex 33c95cdf1aa1..eddbe2abb2f1 100644\n--- a/dbms/src/Parsers/ExpressionElementParsers.cpp\n+++ b/dbms/src/Parsers/ExpressionElementParsers.cpp\n@@ -177,7 +177,7 @@ bool ParserCompoundIdentifier::parseImpl(Pos & pos, ASTPtr & node, Expected & ex\n     {\n         if (!name.empty())\n             name += '.';\n-        parts.emplace_back(*getIdentifierName(child));\n+        parts.emplace_back(getIdentifierName(child));\n         name += parts.back();\n     }\n \n@@ -225,7 +225,7 @@ bool ParserFunction::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n       * If you do not report that the first option is an error, then the argument will be interpreted as 2014 - 01 - 01 - some number,\n       *  and the query silently returns an unexpected result.\n       */\n-    if (*getIdentifierName(identifier) == \"toDate\"\n+    if (getIdentifierName(identifier) == \"toDate\"\n         && contents_end - contents_begin == strlen(\"2014-01-01\")\n         && contents_begin[0] >= '2' && contents_begin[0] <= '3'\n         && contents_begin[1] >= '0' && contents_begin[1] <= '9'\n@@ -267,7 +267,7 @@ bool ParserFunction::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     }\n \n     auto function_node = std::make_shared<ASTFunction>();\n-    getIdentifierName(identifier, function_node->name);\n+    tryGetIdentifierNameInto(identifier, function_node->name);\n \n     /// func(DISTINCT ...) is equivalent to funcDistinct(...)\n     if (has_distinct_modifier)\n@@ -1158,7 +1158,7 @@ bool ParserAlias::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n           *  and in the query \"SELECT x FRO FROM t\", the word FRO was considered an alias.\n           */\n \n-        const String name = *getIdentifierName(node);\n+        const String name = getIdentifierName(node);\n \n         for (const char ** keyword = restricted_keywords; *keyword != nullptr; ++keyword)\n             if (0 == strcasecmp(name.data(), *keyword))\n@@ -1326,7 +1326,7 @@ bool ParserWithOptionalAlias::parseImpl(Pos & pos, ASTPtr & node, Expected & exp\n       */\n     bool allow_alias_without_as_keyword_now = allow_alias_without_as_keyword;\n     if (allow_alias_without_as_keyword)\n-        if (auto opt_id = getIdentifierName(node))\n+        if (auto opt_id = tryGetIdentifierName(node))\n             if (0 == strcasecmp(opt_id->data(), \"FROM\"))\n                 allow_alias_without_as_keyword_now = false;\n \n@@ -1336,7 +1336,7 @@ bool ParserWithOptionalAlias::parseImpl(Pos & pos, ASTPtr & node, Expected & exp\n         /// FIXME: try to prettify this cast using `as<>()`\n         if (auto * ast_with_alias = dynamic_cast<ASTWithAlias *>(node.get()))\n         {\n-            getIdentifierName(alias_node, ast_with_alias->alias);\n+            tryGetIdentifierNameInto(alias_node, ast_with_alias->alias);\n         }\n         else\n         {\ndiff --git a/dbms/src/Parsers/ParserAlterQuery.cpp b/dbms/src/Parsers/ParserAlterQuery.cpp\nindex 98891bbdf5fa..1959cd1ddeba 100644\n--- a/dbms/src/Parsers/ParserAlterQuery.cpp\n+++ b/dbms/src/Parsers/ParserAlterQuery.cpp\n@@ -354,7 +354,7 @@ bool ParserAssignment::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     if (!p_expression.parse(pos, assignment->expression, expected))\n         return false;\n \n-    getIdentifierName(column, assignment->column_name);\n+    tryGetIdentifierNameInto(column, assignment->column_name);\n     if (assignment->expression)\n         assignment->children.push_back(assignment->expression);\n \ndiff --git a/dbms/src/Parsers/ParserCheckQuery.cpp b/dbms/src/Parsers/ParserCheckQuery.cpp\nindex 5ba8119571d3..c397e1c33c52 100644\n--- a/dbms/src/Parsers/ParserCheckQuery.cpp\n+++ b/dbms/src/Parsers/ParserCheckQuery.cpp\n@@ -32,13 +32,13 @@ bool ParserCheckQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n         if (!table_parser.parse(pos, table, expected))\n             return false;\n \n-        getIdentifierName(database, query->database);\n-        getIdentifierName(table, query->table);\n+        tryGetIdentifierNameInto(database, query->database);\n+        tryGetIdentifierNameInto(table, query->table);\n     }\n     else\n     {\n         table = database;\n-        getIdentifierName(table, query->table);\n+        tryGetIdentifierNameInto(table, query->table);\n     }\n \n     if (s_partition.ignore(pos, expected))\ndiff --git a/dbms/src/Parsers/ParserCreateQuery.cpp b/dbms/src/Parsers/ParserCreateQuery.cpp\nindex be0779c4d522..2e7c03a66b9e 100644\n--- a/dbms/src/Parsers/ParserCreateQuery.cpp\n+++ b/dbms/src/Parsers/ParserCreateQuery.cpp\n@@ -39,7 +39,7 @@ bool ParserNestedTable::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n         return false;\n \n     auto func = std::make_shared<ASTFunction>();\n-    getIdentifierName(name, func->name);\n+    tryGetIdentifierNameInto(name, func->name);\n     func->arguments = columns;\n     func->children.push_back(columns);\n     node = func;\n@@ -74,7 +74,7 @@ bool ParserIdentifierWithOptionalParameters::parseImpl(Pos & pos, ASTPtr & node,\n     if (non_parametric.parse(pos, ident, expected))\n     {\n         auto func = std::make_shared<ASTFunction>();\n-        getIdentifierName(ident, func->name);\n+        tryGetIdentifierNameInto(ident, func->name);\n         node = func;\n         return true;\n     }\n@@ -384,8 +384,8 @@ bool ParserCreateQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n             query->if_not_exists = if_not_exists;\n             query->cluster = cluster_str;\n \n-            getIdentifierName(database, query->database);\n-            getIdentifierName(table, query->table);\n+            tryGetIdentifierNameInto(database, query->database);\n+            tryGetIdentifierNameInto(table, query->table);\n \n             return true;\n         }\n@@ -542,18 +542,18 @@ bool ParserCreateQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     query->temporary = is_temporary;\n     query->replace_view = replace_view;\n \n-    getIdentifierName(database, query->database);\n-    getIdentifierName(table, query->table);\n+    tryGetIdentifierNameInto(database, query->database);\n+    tryGetIdentifierNameInto(table, query->table);\n     query->cluster = cluster_str;\n \n-    getIdentifierName(to_database, query->to_database);\n-    getIdentifierName(to_table, query->to_table);\n+    tryGetIdentifierNameInto(to_database, query->to_database);\n+    tryGetIdentifierNameInto(to_table, query->to_table);\n \n     query->set(query->columns_list, columns_list);\n     query->set(query->storage, storage);\n \n-    getIdentifierName(as_database, query->as_database);\n-    getIdentifierName(as_table, query->as_table);\n+    tryGetIdentifierNameInto(as_database, query->as_database);\n+    tryGetIdentifierNameInto(as_table, query->as_table);\n     query->set(query->select, select);\n \n     return true;\ndiff --git a/dbms/src/Parsers/ParserCreateQuery.h b/dbms/src/Parsers/ParserCreateQuery.h\nindex 98109ae98930..d95e66566b23 100644\n--- a/dbms/src/Parsers/ParserCreateQuery.h\n+++ b/dbms/src/Parsers/ParserCreateQuery.h\n@@ -73,7 +73,7 @@ bool IParserNameTypePair<NameParser>::parseImpl(Pos & pos, ASTPtr & node, Expect\n         && type_parser.parse(pos, type, expected))\n     {\n         auto name_type_pair = std::make_shared<ASTNameTypePair>();\n-        getIdentifierName(name, name_type_pair->name);\n+        tryGetIdentifierNameInto(name, name_type_pair->name);\n         name_type_pair->type = type;\n         name_type_pair->children.push_back(type);\n         node = name_type_pair;\n@@ -189,7 +189,7 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E\n \n     const auto column_declaration = std::make_shared<ASTColumnDeclaration>();\n     node = column_declaration;\n-    getIdentifierName(name, column_declaration->name);\n+    tryGetIdentifierNameInto(name, column_declaration->name);\n \n     if (type)\n     {\ndiff --git a/dbms/src/Parsers/ParserDropQuery.cpp b/dbms/src/Parsers/ParserDropQuery.cpp\nindex ca757ae61681..9cd9744f2f47 100644\n--- a/dbms/src/Parsers/ParserDropQuery.cpp\n+++ b/dbms/src/Parsers/ParserDropQuery.cpp\n@@ -116,8 +116,8 @@ bool ParserDropQuery::parseDropQuery(Pos & pos, ASTPtr & node, Expected & expect\n     query->if_exists = if_exists;\n     query->temporary = temporary;\n \n-    getIdentifierName(database, query->database);\n-    getIdentifierName(table, query->table);\n+    tryGetIdentifierNameInto(database, query->database);\n+    tryGetIdentifierNameInto(table, query->table);\n \n     query->cluster = cluster_str;\n \ndiff --git a/dbms/src/Parsers/ParserInsertQuery.cpp b/dbms/src/Parsers/ParserInsertQuery.cpp\nindex e86535e8094c..f9b38132f18e 100644\n--- a/dbms/src/Parsers/ParserInsertQuery.cpp\n+++ b/dbms/src/Parsers/ParserInsertQuery.cpp\n@@ -147,11 +147,11 @@ bool ParserInsertQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     }\n     else\n     {\n-        getIdentifierName(database, query->database);\n-        getIdentifierName(table, query->table);\n+        tryGetIdentifierNameInto(database, query->database);\n+        tryGetIdentifierNameInto(table, query->table);\n     }\n \n-    getIdentifierName(format, query->format);\n+    tryGetIdentifierNameInto(format, query->format);\n \n     query->columns = columns;\n     query->select = select;\ndiff --git a/dbms/src/Parsers/ParserOptimizeQuery.cpp b/dbms/src/Parsers/ParserOptimizeQuery.cpp\nindex f749b316794c..56e28876133e 100644\n--- a/dbms/src/Parsers/ParserOptimizeQuery.cpp\n+++ b/dbms/src/Parsers/ParserOptimizeQuery.cpp\n@@ -58,8 +58,8 @@ bool ParserOptimizeQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expecte\n     auto query = std::make_shared<ASTOptimizeQuery>();\n     node = query;\n \n-    getIdentifierName(database, query->database);\n-    getIdentifierName(table, query->table);\n+    tryGetIdentifierNameInto(database, query->database);\n+    tryGetIdentifierNameInto(table, query->table);\n \n     query->cluster = cluster_str;\n     query->partition = partition;\ndiff --git a/dbms/src/Parsers/ParserRenameQuery.cpp b/dbms/src/Parsers/ParserRenameQuery.cpp\nindex aa5fb43742b3..9323ca16ee4c 100644\n--- a/dbms/src/Parsers/ParserRenameQuery.cpp\n+++ b/dbms/src/Parsers/ParserRenameQuery.cpp\n@@ -30,8 +30,8 @@ static bool parseDatabaseAndTable(\n     }\n \n     db_and_table.database.clear();\n-    getIdentifierName(database, db_and_table.database);\n-    getIdentifierName(table, db_and_table.table);\n+    tryGetIdentifierNameInto(database, db_and_table.database);\n+    tryGetIdentifierNameInto(table, db_and_table.table);\n \n     return true;\n }\ndiff --git a/dbms/src/Parsers/ParserSetQuery.cpp b/dbms/src/Parsers/ParserSetQuery.cpp\nindex 1bdb4be60147..99b08bff3371 100644\n--- a/dbms/src/Parsers/ParserSetQuery.cpp\n+++ b/dbms/src/Parsers/ParserSetQuery.cpp\n@@ -31,7 +31,7 @@ static bool parseNameValuePair(SettingChange & change, IParser::Pos & pos, Expec\n     if (!value_p.parse(pos, value, expected))\n         return false;\n \n-    getIdentifierName(name, change.name);\n+    tryGetIdentifierNameInto(name, change.name);\n     change.value = value->as<ASTLiteral &>().value;\n \n     return true;\ndiff --git a/dbms/src/Parsers/ParserShowTablesQuery.cpp b/dbms/src/Parsers/ParserShowTablesQuery.cpp\nindex 9c247a284c1c..00e5dcd451ef 100644\n--- a/dbms/src/Parsers/ParserShowTablesQuery.cpp\n+++ b/dbms/src/Parsers/ParserShowTablesQuery.cpp\n@@ -65,7 +65,7 @@ bool ParserShowTablesQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expec\n             return false;\n     }\n \n-    getIdentifierName(database, query->from);\n+    tryGetIdentifierNameInto(database, query->from);\n     if (like)\n         query->like = safeGet<const String &>(like->as<ASTLiteral &>().value);\n \ndiff --git a/dbms/src/Parsers/ParserTablePropertiesQuery.cpp b/dbms/src/Parsers/ParserTablePropertiesQuery.cpp\nindex f736023e0d5c..a75124a322c2 100644\n--- a/dbms/src/Parsers/ParserTablePropertiesQuery.cpp\n+++ b/dbms/src/Parsers/ParserTablePropertiesQuery.cpp\n@@ -75,8 +75,8 @@ bool ParserTablePropertiesQuery::parseImpl(Pos & pos, ASTPtr & node, Expected &\n         }\n     }\n \n-    getIdentifierName(database, query->database);\n-    getIdentifierName(table, query->table);\n+    tryGetIdentifierNameInto(database, query->database);\n+    tryGetIdentifierNameInto(table, query->table);\n \n     node = query;\n \ndiff --git a/dbms/src/Parsers/ParserUseQuery.cpp b/dbms/src/Parsers/ParserUseQuery.cpp\nindex c63a251357c1..a71fa17ab785 100644\n--- a/dbms/src/Parsers/ParserUseQuery.cpp\n+++ b/dbms/src/Parsers/ParserUseQuery.cpp\n@@ -21,7 +21,7 @@ bool ParserUseQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n         return false;\n \n     auto query = std::make_shared<ASTUseQuery>();\n-    getIdentifierName(database, query->database);\n+    tryGetIdentifierNameInto(database, query->database);\n     node = query;\n \n     return true;\ndiff --git a/dbms/src/Parsers/parseDatabaseAndTableName.cpp b/dbms/src/Parsers/parseDatabaseAndTableName.cpp\nindex d7a199a34862..018fee10731e 100644\n--- a/dbms/src/Parsers/parseDatabaseAndTableName.cpp\n+++ b/dbms/src/Parsers/parseDatabaseAndTableName.cpp\n@@ -29,13 +29,13 @@ bool parseDatabaseAndTableName(IParser::Pos & pos, Expected & expected, String &\n             return false;\n         }\n \n-        getIdentifierName(database, database_str);\n-        getIdentifierName(table, table_str);\n+        tryGetIdentifierNameInto(database, database_str);\n+        tryGetIdentifierNameInto(table, table_str);\n     }\n     else\n     {\n         database_str = \"\";\n-        getIdentifierName(database, table_str);\n+        tryGetIdentifierNameInto(database, table_str);\n     }\n \n     return true;\ndiff --git a/dbms/src/Parsers/parseIdentifierOrStringLiteral.cpp b/dbms/src/Parsers/parseIdentifierOrStringLiteral.cpp\nindex 815a5d3f3cc1..7258d3e39dab 100644\n--- a/dbms/src/Parsers/parseIdentifierOrStringLiteral.cpp\n+++ b/dbms/src/Parsers/parseIdentifierOrStringLiteral.cpp\n@@ -20,7 +20,7 @@ bool parseIdentifierOrStringLiteral(IParser::Pos & pos, Expected & expected, Str\n         result = res->as<ASTLiteral &>().value.safeGet<String>();\n     }\n     else\n-        result = *getIdentifierName(res);\n+        result = getIdentifierName(res);\n \n     return true;\n }\ndiff --git a/dbms/src/Storages/AlterCommands.cpp b/dbms/src/Storages/AlterCommands.cpp\nindex 7814f1a6ba03..daa639883d40 100644\n--- a/dbms/src/Storages/AlterCommands.cpp\n+++ b/dbms/src/Storages/AlterCommands.cpp\n@@ -64,7 +64,7 @@ std::optional<AlterCommand> AlterCommand::parse(const ASTAlterCommand * command_\n             command.codec = compression_codec_factory.get(ast_col_decl.codec, command.data_type);\n \n         if (command_ast->column)\n-            command.after_column = *getIdentifierName(command_ast->column);\n+            command.after_column = getIdentifierName(command_ast->column);\n \n         if (ast_col_decl.ttl)\n             command.ttl = ast_col_decl.ttl;\n@@ -80,7 +80,7 @@ std::optional<AlterCommand> AlterCommand::parse(const ASTAlterCommand * command_\n \n         AlterCommand command;\n         command.type = AlterCommand::DROP_COLUMN;\n-        command.column_name = *getIdentifierName(command_ast->column);\n+        command.column_name = getIdentifierName(command_ast->column);\n         command.if_exists = command_ast->if_exists;\n         return command;\n     }\n@@ -123,7 +123,7 @@ std::optional<AlterCommand> AlterCommand::parse(const ASTAlterCommand * command_\n     {\n         AlterCommand command;\n         command.type = COMMENT_COLUMN;\n-        command.column_name = *getIdentifierName(command_ast->column);\n+        command.column_name = getIdentifierName(command_ast->column);\n         const auto & ast_comment = command_ast->comment->as<ASTLiteral &>();\n         command.comment = ast_comment.value.get<String>();\n         command.if_exists = command_ast->if_exists;\ndiff --git a/dbms/src/Storages/ColumnsDescription.cpp b/dbms/src/Storages/ColumnsDescription.cpp\nindex 2dbe308ea57f..b3caeaa767bf 100644\n--- a/dbms/src/Storages/ColumnsDescription.cpp\n+++ b/dbms/src/Storages/ColumnsDescription.cpp\n@@ -91,7 +91,7 @@ void ColumnDescription::writeText(WriteBuffer & buf) const\n \n void ColumnDescription::readText(ReadBuffer & buf)\n {\n-    ParserColumnDeclaration column_parser(true);\n+    ParserColumnDeclaration column_parser(/* require type */ true);\n     String column_line;\n     readEscapedStringUntilEOL(column_line, buf);\n     ASTPtr ast = parseQuery(column_parser, column_line, \"column parser\", 0);\ndiff --git a/dbms/src/Storages/MergeTree/MergeTreeWhereOptimizer.cpp b/dbms/src/Storages/MergeTree/MergeTreeWhereOptimizer.cpp\nindex 4311fd027efc..5b132c6d7d02 100644\n--- a/dbms/src/Storages/MergeTree/MergeTreeWhereOptimizer.cpp\n+++ b/dbms/src/Storages/MergeTree/MergeTreeWhereOptimizer.cpp\n@@ -62,7 +62,7 @@ void MergeTreeWhereOptimizer::calculateColumnSizes(const MergeTreeData & data, c\n \n static void collectIdentifiersNoSubqueries(const ASTPtr & ast, NameSet & set)\n {\n-    if (auto opt_name = getIdentifierName(ast))\n+    if (auto opt_name = tryGetIdentifierName(ast))\n         return (void)set.insert(*opt_name);\n \n     if (ast->as<ASTSubquery>())\ndiff --git a/dbms/src/Storages/MergeTree/registerStorageMergeTree.cpp b/dbms/src/Storages/MergeTree/registerStorageMergeTree.cpp\nindex 138e7c14f9d8..19dbe49b27e9 100644\n--- a/dbms/src/Storages/MergeTree/registerStorageMergeTree.cpp\n+++ b/dbms/src/Storages/MergeTree/registerStorageMergeTree.cpp\n@@ -45,13 +45,13 @@ static Names extractColumnNames(const ASTPtr & node)\n         Names res;\n         res.reserve(elements.size());\n         for (const auto & elem : elements)\n-            res.push_back(*getIdentifierName(elem));\n+            res.push_back(getIdentifierName(elem));\n \n         return res;\n     }\n     else\n     {\n-        return { *getIdentifierName(node) };\n+        return { getIdentifierName(node) };\n     }\n }\n \n@@ -502,7 +502,7 @@ static StoragePtr create(const StorageFactory::Arguments & args)\n \n     if (merging_params.mode == MergeTreeData::MergingParams::Collapsing)\n     {\n-        if (!getIdentifierName(engine_args.back(), merging_params.sign_column))\n+        if (!tryGetIdentifierNameInto(engine_args.back(), merging_params.sign_column))\n             throw Exception(\n                 \"Sign column name must be an unquoted string\" + getMergeTreeVerboseHelp(is_extended_storage_def),\n                 ErrorCodes::BAD_ARGUMENTS);\n@@ -514,7 +514,7 @@ static StoragePtr create(const StorageFactory::Arguments & args)\n         /// If the last element is not index_granularity or replica_name (a literal), then this is the name of the version column.\n         if (!engine_args.empty() && !engine_args.back()->as<ASTLiteral>())\n         {\n-            if (!getIdentifierName(engine_args.back(), merging_params.version_column))\n+            if (!tryGetIdentifierNameInto(engine_args.back(), merging_params.version_column))\n                 throw Exception(\n                     \"Version column name must be an unquoted string\" + getMergeTreeVerboseHelp(is_extended_storage_def),\n                     ErrorCodes::BAD_ARGUMENTS);\n@@ -552,14 +552,14 @@ static StoragePtr create(const StorageFactory::Arguments & args)\n     }\n     else if (merging_params.mode == MergeTreeData::MergingParams::VersionedCollapsing)\n     {\n-        if (!getIdentifierName(engine_args.back(), merging_params.version_column))\n+        if (!tryGetIdentifierNameInto(engine_args.back(), merging_params.version_column))\n             throw Exception(\n                     \"Version column name must be an unquoted string\" + getMergeTreeVerboseHelp(is_extended_storage_def),\n                     ErrorCodes::BAD_ARGUMENTS);\n \n         engine_args.pop_back();\n \n-        if (!getIdentifierName(engine_args.back(), merging_params.sign_column))\n+        if (!tryGetIdentifierNameInto(engine_args.back(), merging_params.sign_column))\n             throw Exception(\n                     \"Sign column name must be an unquoted string\" + getMergeTreeVerboseHelp(is_extended_storage_def),\n                     ErrorCodes::BAD_ARGUMENTS);\n@@ -616,7 +616,7 @@ static StoragePtr create(const StorageFactory::Arguments & args)\n \n         /// Now only three parameters remain - date (or partitioning expression), primary_key, index_granularity.\n \n-        if (!getIdentifierName(engine_args[0], date_column_name))\n+        if (!tryGetIdentifierNameInto(engine_args[0], date_column_name))\n             throw Exception(\n                 \"Date column name must be an unquoted string\" + getMergeTreeVerboseHelp(is_extended_storage_def),\n                 ErrorCodes::BAD_ARGUMENTS);\ndiff --git a/dbms/src/Storages/PartitionCommands.cpp b/dbms/src/Storages/PartitionCommands.cpp\nindex f6aaee4c70eb..69632332b489 100644\n--- a/dbms/src/Storages/PartitionCommands.cpp\n+++ b/dbms/src/Storages/PartitionCommands.cpp\n@@ -65,7 +65,7 @@ std::optional<PartitionCommand> PartitionCommand::parse(const ASTAlterCommand *\n         PartitionCommand res;\n         res.type = CLEAR_COLUMN;\n         res.partition = command_ast->partition;\n-        res.column_name = *getIdentifierName(command_ast->column);\n+        res.column_name = getIdentifierName(command_ast->column);\n         return res;\n     }\n     else if (command_ast->type == ASTAlterCommand::FREEZE_ALL)\ndiff --git a/dbms/src/Storages/StorageFile.cpp b/dbms/src/Storages/StorageFile.cpp\nindex 35bc1747deeb..5bc23d009759 100644\n--- a/dbms/src/Storages/StorageFile.cpp\n+++ b/dbms/src/Storages/StorageFile.cpp\n@@ -303,7 +303,7 @@ void registerStorageFile(StorageFactory & factory)\n         {\n             /// Will use FD if engine_args[1] is int literal or identifier with std* name\n \n-            if (auto opt_name = getIdentifierName(engine_args[1]))\n+            if (auto opt_name = tryGetIdentifierName(engine_args[1]))\n             {\n                 if (*opt_name == \"stdin\")\n                     source_fd = STDIN_FILENO;\ndiff --git a/dbms/src/Storages/StorageJoin.cpp b/dbms/src/Storages/StorageJoin.cpp\nindex 3c90917b0f66..3de820a5f4ec 100644\n--- a/dbms/src/Storages/StorageJoin.cpp\n+++ b/dbms/src/Storages/StorageJoin.cpp\n@@ -90,7 +90,7 @@ void registerStorageJoin(StorageFactory & factory)\n                 \"Storage Join requires at least 3 parameters: Join(ANY|ALL, LEFT|INNER, keys...).\",\n                 ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n-        auto opt_strictness_id = getIdentifierName(engine_args[0]);\n+        auto opt_strictness_id = tryGetIdentifierName(engine_args[0]);\n         if (!opt_strictness_id)\n             throw Exception(\"First parameter of storage Join must be ANY or ALL (without quotes).\", ErrorCodes::BAD_ARGUMENTS);\n \n@@ -103,7 +103,7 @@ void registerStorageJoin(StorageFactory & factory)\n         else\n             throw Exception(\"First parameter of storage Join must be ANY or ALL (without quotes).\", ErrorCodes::BAD_ARGUMENTS);\n \n-        auto opt_kind_id = getIdentifierName(engine_args[1]);\n+        auto opt_kind_id = tryGetIdentifierName(engine_args[1]);\n         if (!opt_kind_id)\n             throw Exception(\"Second parameter of storage Join must be LEFT or INNER (without quotes).\", ErrorCodes::BAD_ARGUMENTS);\n \n@@ -124,7 +124,7 @@ void registerStorageJoin(StorageFactory & factory)\n         key_names.reserve(engine_args.size() - 2);\n         for (size_t i = 2, size = engine_args.size(); i < size; ++i)\n         {\n-            auto opt_key = getIdentifierName(engine_args[i]);\n+            auto opt_key = tryGetIdentifierName(engine_args[i]);\n             if (!opt_key)\n                 throw Exception(\"Parameter \u2116\" + toString(i + 1) + \" of storage Join don't look like column name.\", ErrorCodes::BAD_ARGUMENTS);\n \ndiff --git a/dbms/src/TableFunctions/TableFunctionRemote.cpp b/dbms/src/TableFunctions/TableFunctionRemote.cpp\nindex c4e0cd1866a0..f6fa75bb2d2c 100644\n--- a/dbms/src/TableFunctions/TableFunctionRemote.cpp\n+++ b/dbms/src/TableFunctions/TableFunctionRemote.cpp\n@@ -67,7 +67,7 @@ StoragePtr TableFunctionRemote::executeImpl(const ASTPtr & ast_function, const C\n     }\n     else\n     {\n-        if (!getIdentifierName(args[arg_num], cluster_name))\n+        if (!tryGetIdentifierNameInto(args[arg_num], cluster_name))\n             cluster_description = getStringLiteral(*args[arg_num], \"Hosts pattern\");\n     }\n     ++arg_num;\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/00983_summing_merge_tree_not_an_identifier.reference b/dbms/tests/queries/0_stateless/00983_summing_merge_tree_not_an_identifier.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/dbms/tests/queries/0_stateless/00983_summing_merge_tree_not_an_identifier.sql b/dbms/tests/queries/0_stateless/00983_summing_merge_tree_not_an_identifier.sql\nnew file mode 100644\nindex 000000000000..7e138df20f5e\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/00983_summing_merge_tree_not_an_identifier.sql\n@@ -0,0 +1,13 @@\n+CREATE TABLE xx\n+(\n+    `date` Date, \n+    `id` Int64, \n+    `clicks` Int64, \n+    `price` Float64, \n+    `spend` Float64\n+)\n+ENGINE = SummingMergeTree([price, spend])\n+PARTITION BY toYYYYMM(date)\n+ORDER BY id\n+SAMPLE BY id\n+SETTINGS index_granularity = 8192; -- { serverError 223 }\n",
  "problem_statement": "SummingMergeTree breaks Clickhouse server\nHello,\r\n\r\nI am using the Altinity ClickHouse build for the Amazon distro in an Amazon's EC2 server.\r\n`Connected to ClickHouse server version 19.11.2 revision 54423.`\r\nAnd when I execute the following query the Clickhouse server breaks down.\r\n```\r\nCREATE TABLE xx\r\n(\r\n    `date` Date, \r\n    `id` Int64, \r\n    `clicks` Int64, \r\n    `price` Float64, \r\n    `spend` Float64\r\n)\r\nENGINE = SummingMergeTree([price, spend])\r\nPARTITION BY toYYYYMM(date)\r\nORDER BY id\r\nSAMPLE BY id\r\nSETTINGS index_granularity = 8192\r\n```\r\nIf I do not specify the columns in the `SummingMergeTree` it works but that's not what I am looking for.\r\nThe server log prints the following when the query is executed:\r\n```\r\n2019.08.08 07:20:15.143586 [ 41 ] {fb26ccfb-5078-4f59-ad47-24b33b077a92} <Debug> executeQuery: (from 127.0.0.1:39233) CREATE TABLE xx (`date` Date, `id` Int64, `clicks` Int64, `price` Float64, `spend` Float64) ENGINE = SummingMergeTree([price, spend]) PARTITION BY toYYYYMM(date) ORDER BY id SAMPLE BY id SETTINGS index_granularity = 8192\r\n2019.08.08 07:20:15.143794 [ 46 ] {} <Error> BaseDaemon: ########################################\r\n2019.08.08 07:20:15.143861 [ 46 ] {} <Error> BaseDaemon: (version 19.11.2.7) (from thread 41) Received signal Segmentation fault (11).\r\n2019.08.08 07:20:15.143896 [ 46 ] {} <Error> BaseDaemon: Address: 0xfffffffffffffff8 Access: read. Address not mapped to object.\r\n2019.08.08 07:20:15.149080 [ 46 ] {} <Error> BaseDaemon: 0. clickhouse-server(StackTrace::StackTrace(ucontext const&)+0x22) [0x6d0a8f2]\r\n1. clickhouse-server() [0x31ca5a5]\r\n2. /lib64/libpthread.so.0(+0xf5a0) [0x7f851d2b95a0]\r\n3. clickhouse-server() [0x602de81]\r\n```\r\n\n",
  "hints_text": "Does it crash if you remove square brackets?\r\nSummingMergeTree(price, spend)\nIt doesn't work without brackets and following the Clickhouse doc:\r\n`columns - a tuple with the names of columns where values will be summarized`\r\n\r\nSo I just want to sum the price and spend columns\nWhy did you use [ ] -- it's an array not a tuple\r\n\r\ntry  `ENGINE = SummingMergeTree(price, spend)`\r\nand by the way `clicks` won't be summed, you'll get `any(clicks)` -- are you sure?\r\n\r\n\r\nENGINE = SummingMergeTree([columns]) -- [ ] - it means columns are optional (documentation agreement). \n@den-crane  when I do  `ENGINE = SummingMergeTree(price, spend)` it shows me the following text and a description of how MergeTree works.\r\n```\r\nCode: 42. DB::Exception: Received from localhost:9000. DB::Exception: With extended storage definition syntax storage SummingMergeTree requires 0 to 1 parameters: \r\nlist of columns to sum]\r\n```\r\n\r\nBUT this works: `ENGINE = SummingMergeTree((price, spend))`. Anyway, the issue still there... so I am not going to close the issue because when an array is used it causes a segfault.\r\n\r\nAnd about the `clicks` column, don't worry it was just an example but thanks for pointing that out hehe.\nRight, I've missed () for the tuple.\r\n\r\nAnd yes segfault should be fixed somehow. Maybe forbiden as wrong syntax at create table level.  \nBetter stack trace:\r\n\r\n```\r\n2019.08.08 22:44:28.643953 [ 47 ] {72c459ed-02e9-4810-8164-96c144061c1b} <Debug> executeQuery: (from 127.0.0.1:51864) CREATE TABLE xx (`date` Date, `id` Int64, `clicks` Int64, `price` Float64, `spend` Float64) ENGINE = SummingMergeTree([price, spend]) PARTITION BY toYYYYMM(date) ORDER BY id SAMPLE BY id SETTINGS index_granularity = 8192\r\n/home/milovidov/work/ClickHouse/contrib/libcxx/include/optional:920: _LIBCPP_ASSERT 'this->has_value()' failed. optional operator* called for disengaged value\r\n2019.08.08 22:44:28.665386 [ 54 ] {} <Error> BaseDaemon: ########################################\r\n2019.08.08 22:44:28.666917 [ 54 ] {} <Error> BaseDaemon: (version 19.13.1.1) (from thread 47) Received signal Aborted (6).\r\n2019.08.08 22:44:28.667506 [ 54 ] {} <Error> BaseDaemon: \r\n2019.08.08 22:44:29.288849 [ 54 ] {} <Error> BaseDaemon: 4. 0x7fadbfa83e97 raise /build/glibc-OTsEL5/glibc-2.27/signal/../sysdeps/unix/sysv/linux/raise.c:51\r\n5. 0x7fadbfa85801 __GI_abort /build/glibc-OTsEL5/glibc-2.27/stdlib/abort.c:81\r\n6. 0x148cca1c std::__1::__libcpp_abort_debug_function(std::__1::__libcpp_debug_info const&) /home/milovidov/work/ClickHouse/build/../contrib/libcxx/src/debug.cpp:40\r\n7. 0x1235d933 std::__1::optional<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >::operator*() && /home/milovidov/work/ClickHouse/contrib/libcxx/include/optional:0\r\n8. 0x12e24ec1 DB::extractColumnNames(std::__1::shared_ptr<DB::IAST> const&) /home/milovidov/work/ClickHouse/build/../dbms/src/Storages/MergeTree/registerStorageMergeTree.cpp:54\r\n9. 0x12e23456 DB::create(DB::StorageFactory::Arguments const&) /home/milovidov/work/ClickHouse/build/../dbms/src/Storages/MergeTree/registerStorageMergeTree.cpp:530\r\n10. 0x12e30ecb decltype(std::__1::forward<std::__1::shared_ptr<DB::IStorage> (*&)(DB::StorageFactory::Arguments const&)>(fp)(std::__1::forward<DB::StorageFactory::Arguments const&>(fp0))) std::__1::__invoke<std::__1::shared_ptr<DB::IStorage> (*&)(DB::StorageFactory::Arguments const&), DB::StorageFactory::Arguments const&>(std::__1::shared_ptr<DB::IStorage> (*&)(DB::StorageFactory::Arguments const&), DB::StorageFactory::Arguments const&) /home/milovidov/work/ClickHouse/contrib/libcxx/include/type_traits:4410\r\n11. 0x12e30e4b std::__1::shared_ptr<DB::IStorage> std::__1::__invoke_void_return_wrapper<std::__1::shared_ptr<DB::IStorage> >::__call<std::__1::shared_ptr<DB::IStorage> (*&)(DB::StorageFactory::Arguments const&), DB::StorageFactory::Arguments const&>(std::__1::shared_ptr<DB::IStorage> (*&)(DB::StorageFactory::Arguments const&), DB::StorageFactory::Arguments const&) /home/milovidov/work/ClickHouse/contrib/libcxx/include/__functional_base:317\r\n12. 0x12e30deb std::__1::__function::__alloc_func<std::__1::shared_ptr<DB::IStorage> (*)(DB::StorageFactory::Arguments const&), std::__1::allocator<std::__1::shared_ptr<DB::IStorage> (*)(DB::StorageFactory::Arguments const&)>, std::__1::shared_ptr<DB::IStorage> (DB::StorageFactory::Arguments const&)>::operator()(DB::StorageFactory::Arguments const&) /home/milovidov/work/ClickHouse/contrib/libcxx/include/functional:1527\r\n13. 0x12e2ff0d std::__1::__function::__func<std::__1::shared_ptr<DB::IStorage> (*)(DB::StorageFactory::Arguments const&), std::__1::allocator<std::__1::shared_ptr<DB::IStorage> (*)(DB::StorageFactory::Arguments const&)>, std::__1::shared_ptr<DB::IStorage> (DB::StorageFactory::Arguments const&)>::operator()(DB::StorageFactory::Arguments const&) /home/milovidov/work/ClickHouse/contrib/libcxx/include/functional:1651\r\n14. 0x12a2f22b std::__1::__function::__value_func<std::__1::shared_ptr<DB::IStorage> (DB::StorageFactory::Arguments const&)>::operator()(DB::StorageFactory::Arguments const&) const /home/milovidov/work/ClickHouse/contrib/libcxx/include/functional:1799\r\n15. 0x12a2ce26 std::__1::function<std::__1::shared_ptr<DB::IStorage> (DB::StorageFactory::Arguments const&)>::operator()(DB::StorageFactory::Arguments const&) const /home/milovidov/work/ClickHouse/contrib/libcxx/include/functional:2347\r\n16. 0x12a2c9bc DB::StorageFactory::get(DB::ASTCreateQuery&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, DB::Context&, DB::Context&, DB::ColumnsDescription const&, bool, bool) const /home/milovidov/work/ClickHouse/build/../dbms/src/Storages/StorageFactory.cpp:147\r\n17. 0x123216bf DB::InterpreterCreateQuery::createTable(DB::ASTCreateQuery&) /home/milovidov/work/ClickHouse/build/../dbms/src/Interpreters/InterpreterCreateQuery.cpp:603\r\n18. 0x12321e11 DB::InterpreterCreateQuery::execute() /home/milovidov/work/ClickHouse/build/../dbms/src/Interpreters/InterpreterCreateQuery.cpp:0\r\n19. 0x128c5cb8 DB::executeQueryImpl(char const*, char const*, DB::Context&, bool, DB::QueryProcessingStage::Enum, bool) /home/milovidov/work/ClickHouse/build/../dbms/src/Interpreters/executeQuery.cpp:247\r\n20. 0x128c532f DB::executeQuery(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, DB::Context&, bool, DB::QueryProcessingStage::Enum, bool) /home/milovidov/work/ClickHouse/build/../dbms/src/Interpreters/executeQuery.cpp:487\r\n21. 0xd67e708 DB::TCPHandler::runImpl() /home/milovidov/work/ClickHouse/build/../dbms/programs/server/TCPHandler.cpp:210\r\n22. 0xd684512 DB::TCPHandler::run() /home/milovidov/work/ClickHouse/build/../dbms/programs/server/TCPHandler.cpp:1083\r\n23. 0x134f330c Poco::Net::TCPServerConnection::start() /home/milovidov/work/ClickHouse/build/../contrib/poco/Net/src/TCPServerConnection.cpp:43\r\n24. 0x134f3b1c Poco::Net::TCPServerDispatcher::run() /home/milovidov/work/ClickHouse/build/../contrib/poco/Net/src/TCPServerDispatcher.cpp:114\r\n25. 0x13f5e9f3 Poco::PooledThread::run() /home/milovidov/work/ClickHouse/build/../contrib/poco/Foundation/src/ThreadPool.cpp:214\r\n26. 0x13f5a4fd Poco::(anonymous namespace)::RunnableHolder::run() /home/milovidov/work/ClickHouse/build/../contrib/poco/Foundation/src/Thread.cpp:44\r\n27. 0x13f59534 Poco::ThreadImpl::runnableEntry(void*) /home/milovidov/work/ClickHouse/build/../contrib/poco/Foundation/src/Thread_STD.cpp:139\r\n28. 0x13f5bfe5 decltype(std::__1::forward<void* (*)(void*)>(fp)(std::__1::forward<Poco::ThreadImpl*>(fp0))) std::__1::__invoke<void* (*)(void*), Poco::ThreadImpl*>(void* (*&&)(void*), Poco::ThreadImpl*&&) /home/milovidov/work/ClickHouse/contrib/libcxx/include/type_traits:4410\r\n29. 0x13f5bf6e void std::__1::__thread_execute<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct> >, void* (*)(void*), Poco::ThreadImpl*, 2ul>(std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct> >, void* (*)(void*), Poco::ThreadImpl*>&, std::__1::__tuple_indices<2ul>) /home/milovidov/work/ClickHouse/contrib/libcxx/include/thread:342\r\n30. 0x13f5bc86 void* std::__1::__thread_proxy<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct> >, void* (*)(void*), Poco::ThreadImpl*> >(void*) /home/milovidov/work/ClickHouse/contrib/libcxx/include/thread:351\r\n31. 0x7fadc01db6db start_thread /lib/x86_64-linux-gnu/libpthread-2.27.so\r\n```\nhttps://github.com/yandex/ClickHouse/pull/4056",
  "created_at": "2019-08-08T20:28:22Z",
  "modified_files": [
    "dbms/src/DataTypes/DataTypeAggregateFunction.cpp",
    "dbms/src/DataTypes/DataTypeCustomSimpleAggregateFunction.cpp",
    "dbms/src/Interpreters/ActionsVisitor.cpp",
    "dbms/src/Interpreters/ColumnNamesContext.h",
    "dbms/src/Interpreters/GlobalSubqueriesVisitor.h",
    "dbms/src/Interpreters/QueryNormalizer.cpp",
    "dbms/src/Interpreters/TranslateQualifiedNamesVisitor.cpp",
    "dbms/src/Interpreters/executeQuery.cpp",
    "dbms/src/Parsers/ASTIdentifier.cpp",
    "dbms/src/Parsers/ASTIdentifier.h",
    "dbms/src/Parsers/ExpressionElementParsers.cpp",
    "dbms/src/Parsers/ParserAlterQuery.cpp",
    "dbms/src/Parsers/ParserCheckQuery.cpp",
    "dbms/src/Parsers/ParserCreateQuery.cpp",
    "dbms/src/Parsers/ParserCreateQuery.h",
    "dbms/src/Parsers/ParserDropQuery.cpp",
    "dbms/src/Parsers/ParserInsertQuery.cpp",
    "dbms/src/Parsers/ParserOptimizeQuery.cpp",
    "dbms/src/Parsers/ParserRenameQuery.cpp",
    "dbms/src/Parsers/ParserSetQuery.cpp",
    "dbms/src/Parsers/ParserShowTablesQuery.cpp",
    "dbms/src/Parsers/ParserTablePropertiesQuery.cpp",
    "dbms/src/Parsers/ParserUseQuery.cpp",
    "dbms/src/Parsers/parseDatabaseAndTableName.cpp",
    "dbms/src/Parsers/parseIdentifierOrStringLiteral.cpp",
    "dbms/src/Storages/AlterCommands.cpp",
    "dbms/src/Storages/ColumnsDescription.cpp",
    "dbms/src/Storages/MergeTree/MergeTreeWhereOptimizer.cpp",
    "dbms/src/Storages/MergeTree/registerStorageMergeTree.cpp",
    "dbms/src/Storages/PartitionCommands.cpp",
    "dbms/src/Storages/StorageFile.cpp",
    "dbms/src/Storages/StorageJoin.cpp",
    "dbms/src/TableFunctions/TableFunctionRemote.cpp"
  ],
  "modified_test_files": [
    "b/dbms/tests/queries/0_stateless/00983_summing_merge_tree_not_an_identifier.sql"
  ]
}