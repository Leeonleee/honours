{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 50150,
  "instance_id": "ClickHouse__ClickHouse-50150",
  "issue_numbers": [
    "46146"
  ],
  "base_commit": "23cff1fc32a0e3fbc8e2b3453ea909a69ead2964",
  "patch": "diff --git a/docs/en/engines/table-engines/index.md b/docs/en/engines/table-engines/index.md\nindex d7c582164de7..bd704d0e87e4 100644\n--- a/docs/en/engines/table-engines/index.md\n+++ b/docs/en/engines/table-engines/index.md\n@@ -53,6 +53,7 @@ Engines in the family:\n - [JDBC](../../engines/table-engines/integrations/jdbc.md)\n - [MySQL](../../engines/table-engines/integrations/mysql.md)\n - [MongoDB](../../engines/table-engines/integrations/mongodb.md)\n+- [Redis](../../engines/table-engines/integrations/redis.md)\n - [HDFS](../../engines/table-engines/integrations/hdfs.md)\n - [S3](../../engines/table-engines/integrations/s3.md)\n - [Kafka](../../engines/table-engines/integrations/kafka.md)\ndiff --git a/docs/en/engines/table-engines/integrations/index.md b/docs/en/engines/table-engines/integrations/index.md\nindex b9171d9033b9..d3b4afc95a28 100644\n--- a/docs/en/engines/table-engines/integrations/index.md\n+++ b/docs/en/engines/table-engines/integrations/index.md\n@@ -7,4 +7,3 @@ sidebar_label:  Integrations\n # Table Engines for Integrations\n \n ClickHouse provides various means for integrating with external systems, including table engines. Like with all other table engines, the configuration is done using `CREATE TABLE` or `ALTER TABLE` queries. Then from a user perspective, the configured integration looks like a normal table, but queries to it are proxied to the external system. This transparent querying is one of the key advantages of this approach over alternative integration methods, like dictionaries or table functions, which require the use of custom query methods on each use.\n-\ndiff --git a/docs/en/engines/table-engines/integrations/redis.md b/docs/en/engines/table-engines/integrations/redis.md\nnew file mode 100644\nindex 000000000000..a78942ab7bb3\n--- /dev/null\n+++ b/docs/en/engines/table-engines/integrations/redis.md\n@@ -0,0 +1,119 @@\n+---\n+slug: /en/sql-reference/table-functions/redis\n+sidebar_position: 43\n+sidebar_label: Redis\n+---\n+\n+# Redis\n+\n+This engine allows integrating ClickHouse with [Redis](https://redis.io/). For Redis takes kv model, we strongly recommend you only query it in a point way, such as `where k=xx` or `where k in (xx, xx)`.\n+\n+## Creating a Table {#creating-a-table}\n+\n+``` sql\n+CREATE TABLE [IF NOT EXISTS] [db.]table_name\n+(\n+    name1 [type1],\n+    name2 [type2],\n+    ...\n+) ENGINE = Redis(host:port[, db_index[, password[, pool_size]]]) PRIMARY KEY(primary_key_name);\n+```\n+\n+**Engine Parameters**\n+\n+- `host:port` \u2014 Redis server address, you can ignore port and default Redis port 6379 will be used.\n+\n+- `db_index` \u2014 Redis db index range from 0 to 15, default is 0.\n+\n+- `password` \u2014 User password, default is blank string.\n+\n+- `pool_size` \u2014 Redis max connection pool size, default is 16.\n+\n+- `primary_key_name` - any column name in the column list.\n+\n+- `primary` must be specified, it supports only one column in the primary key. The primary key will be serialized in binary as a Redis key.\n+\n+- columns other than the primary key will be serialized in binary as Redis value in corresponding order.\n+  \n+- queries with key equals or in filtering will be optimized to multi keys lookup from Redis. If queries without filtering key full table scan will happen which is a heavy operation.\n+\n+## Usage Example {#usage-example}\n+\n+Create a table in ClickHouse which allows to read data from Redis:\n+\n+``` sql\n+CREATE TABLE redis_table\n+(\n+    `k` String,\n+    `m` String,\n+    `n` UInt32\n+)\n+ENGINE = Redis('redis1:6379') PRIMARY KEY(k);\n+```\n+\n+Insert:\n+\n+```sql\n+INSERT INTO redis_table Values('1', 1, '1', 1.0), ('2', 2, '2', 2.0);\n+```\n+\n+Query:\n+\n+``` sql\n+SELECT COUNT(*) FROM redis_table;\n+```\n+\n+``` text\n+\u250c\u2500count()\u2500\u2510\n+\u2502       2 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+``` sql\n+SELECT * FROM redis_table WHERE key='1';\n+```\n+\n+```text\n+\u250c\u2500key\u2500\u252c\u2500v1\u2500\u252c\u2500v2\u2500\u252c\u2500v3\u2500\u2510\n+\u2502 1   \u2502  1 \u2502 1  \u2502  1 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+``` sql\n+SELECT * FROM redis_table WHERE v1=2;\n+```\n+\n+```text\n+\u250c\u2500key\u2500\u252c\u2500v1\u2500\u252c\u2500v2\u2500\u252c\u2500v3\u2500\u2510\n+\u2502 2   \u2502  2 \u2502 2  \u2502  2 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+Update:\n+\n+Note that the primary key cannot be updated.\n+\n+```sql\n+ALTER TABLE redis_table UPDATE v1=2 WHERE key='1';\n+```\n+\n+Delete:\n+\n+```sql\n+ALTER TABLE redis_table DELETE WHERE key='1';\n+```\n+\n+Truncate:\n+\n+Flush Redis db asynchronously. Also `Truncate` support SYNC mode.\n+\n+```sql\n+TRUNCATE TABLE redis_table SYNC;\n+```\n+\n+\n+## Limitations {#limitations}\n+\n+Redis engine also supports scanning queries, such as `where k > xx`, but it has some limitations:\n+1. Scanning query may produce some duplicated keys in a very rare case when it is rehashing. See details in [Redis Scan](https://github.com/redis/redis/blob/e4d183afd33e0b2e6e8d1c79a832f678a04a7886/src/dict.c#L1186-L1269)\n+2. During the scanning, keys could be created and deleted, so the resulting dataset can not represent a valid point in time.\ndiff --git a/docs/en/sql-reference/table-functions/redis.md b/docs/en/sql-reference/table-functions/redis.md\nnew file mode 100644\nindex 000000000000..5b32f118fb88\n--- /dev/null\n+++ b/docs/en/sql-reference/table-functions/redis.md\n@@ -0,0 +1,67 @@\n+---\n+slug: /en/sql-reference/table-functions/redis\n+sidebar_position: 10\n+sidebar_label: Redis\n+---\n+\n+# Redis\n+\n+This table function allows integrating ClickHouse with [Redis](https://redis.io/).\n+\n+**Syntax**\n+\n+```sql\n+redis(host:port, key, structure[, db_index[, password[, pool_size]]])\n+```\n+\n+**Arguments**\n+\n+- `host:port` \u2014 Redis server address, you can ignore port and default Redis port 6379 will be used.\n+\n+- `key` \u2014 any column name in the column list.\n+\n+- `structure` \u2014 The schema for the ClickHouse table returned from this function.\n+\n+- `db_index` \u2014 Redis db index range from 0 to 15, default is 0.\n+\n+- `password` \u2014 User password, default is blank string.\n+\n+- `pool_size` \u2014 Redis max connection pool size, default is 16.\n+\n+- `primary` must be specified, it supports only one column in the primary key. The primary key will be serialized in binary as a Redis key.\n+\n+- columns other than the primary key will be serialized in binary as Redis value in corresponding order.\n+  \n+- queries with key equals or in filtering will be optimized to multi keys lookup from Redis. If queries without filtering key full table scan will happen which is a heavy operation.\n+\n+\n+**Returned Value**\n+\n+A table object with key as Redis key, other columns packaged together as Redis value.\n+\n+## Usage Example {#usage-example}\n+\n+Create a table in ClickHouse which allows to read data from Redis:\n+\n+``` sql\n+CREATE TABLE redis_table\n+(\n+    `k` String,\n+    `m` String,\n+    `n` UInt32\n+)\n+ENGINE = Redis('redis1:6379') PRIMARY KEY(k);\n+```\n+\n+```sql\n+SELECT * FROM redis(\n+    'redis1:6379',\n+    'key',\n+    'key String, v1 String, v2 UInt32'\n+)\n+```\n+\n+**See Also**\n+\n+- [The `Redis` table engine](/docs/en/engines/table-engines/integrations/redis.md)\n+- [Using redis as a dictionary source](/docs/en/sql-reference/dictionaries/index.md#redis)\ndiff --git a/src/Access/Common/AccessType.h b/src/Access/Common/AccessType.h\nindex 84c99939f2da..f65a77c1d6af 100644\n--- a/src/Access/Common/AccessType.h\n+++ b/src/Access/Common/AccessType.h\n@@ -201,6 +201,7 @@ enum class AccessType\n     M(URL, \"\", GLOBAL, SOURCES) \\\n     M(REMOTE, \"\", GLOBAL, SOURCES) \\\n     M(MONGO, \"\", GLOBAL, SOURCES) \\\n+    M(REDIS, \"\", GLOBAL, SOURCES) \\\n     M(MEILISEARCH, \"\", GLOBAL, SOURCES) \\\n     M(MYSQL, \"\", GLOBAL, SOURCES) \\\n     M(POSTGRES, \"\", GLOBAL, SOURCES) \\\ndiff --git a/src/CMakeLists.txt b/src/CMakeLists.txt\nindex e1359a5a8aa0..ca428fbff3af 100644\n--- a/src/CMakeLists.txt\n+++ b/src/CMakeLists.txt\n@@ -413,6 +413,7 @@ dbms_target_link_libraries (\n         boost::system\n         clickhouse_common_io\n         Poco::MongoDB\n+        Poco::Redis\n )\n \n if (TARGET ch::mysqlxx)\ndiff --git a/src/Common/ErrorCodes.cpp b/src/Common/ErrorCodes.cpp\nindex 83a7314ac7a6..4c08d762df2d 100644\n--- a/src/Common/ErrorCodes.cpp\n+++ b/src/Common/ErrorCodes.cpp\n@@ -580,6 +580,8 @@\n     M(695, ASYNC_LOAD_FAILED) \\\n     M(696, ASYNC_LOAD_CANCELED) \\\n     M(697, CANNOT_RESTORE_TO_NONENCRYPTED_DISK) \\\n+    M(698, INVALID_REDIS_STORAGE_TYPE) \\\n+    M(699, INVALID_REDIS_TABLE_STRUCTURE) \\\n     \\\n     M(999, KEEPER_EXCEPTION) \\\n     M(1000, POCO_EXCEPTION) \\\ndiff --git a/src/Dictionaries/RedisDictionarySource.cpp b/src/Dictionaries/RedisDictionarySource.cpp\nindex 6e4c5d1d5d9c..1736cdff3069 100644\n--- a/src/Dictionaries/RedisDictionarySource.cpp\n+++ b/src/Dictionaries/RedisDictionarySource.cpp\n@@ -3,10 +3,6 @@\n #include \"DictionaryStructure.h\"\n #include \"registerDictionaries.h\"\n \n-#include <Poco/Redis/Array.h>\n-#include <Poco/Redis/Client.h>\n-#include <Poco/Redis/Command.h>\n-#include <Poco/Redis/Type.h>\n #include <Poco/Util/AbstractConfiguration.h>\n #include <Interpreters/Context.h>\n #include <QueryPipeline/QueryPipeline.h>\n@@ -21,19 +17,7 @@ namespace DB\n     {\n         extern const int UNSUPPORTED_METHOD;\n         extern const int INVALID_CONFIG_PARAMETER;\n-        extern const int INTERNAL_REDIS_ERROR;\n         extern const int LOGICAL_ERROR;\n-        extern const int TIMEOUT_EXCEEDED;\n-    }\n-\n-    static RedisStorageType parseStorageType(const String & storage_type_str)\n-    {\n-        if (storage_type_str == \"hash_map\")\n-            return RedisStorageType::HASH_MAP;\n-        else if (!storage_type_str.empty() && storage_type_str != \"simple\")\n-            throw Exception(ErrorCodes::INVALID_CONFIG_PARAMETER, \"Unknown storage type {} for Redis dictionary\", storage_type_str);\n-\n-        return RedisStorageType::SIMPLE;\n     }\n \n     void registerDictionarySourceRedis(DictionarySourceFactory & factory)\n@@ -52,14 +36,14 @@ namespace DB\n             auto port = config.getUInt(redis_config_prefix + \".port\");\n             global_context->getRemoteHostFilter().checkHostAndPort(host, toString(port));\n \n-            RedisDictionarySource::Configuration configuration =\n+            RedisConfiguration configuration =\n             {\n                 .host = host,\n                 .port = static_cast<UInt16>(port),\n-                .db_index = config.getUInt(redis_config_prefix + \".db_index\", 0),\n-                .password = config.getString(redis_config_prefix + \".password\", \"\"),\n+                .db_index = config.getUInt(redis_config_prefix + \".db_index\", DEFAULT_REDIS_DB_INDEX),\n+                .password = config.getString(redis_config_prefix + \".password\", DEFAULT_REDIS_PASSWORD),\n                 .storage_type = parseStorageType(config.getString(redis_config_prefix + \".storage_type\", \"\")),\n-                .pool_size = config.getUInt(redis_config_prefix + \".pool_size\", 16),\n+                .pool_size = config.getUInt(redis_config_prefix + \".pool_size\", DEFAULT_REDIS_POOL_SIZE),\n             };\n \n             return std::make_unique<RedisDictionarySource>(dict_struct, configuration, sample_block);\n@@ -68,26 +52,13 @@ namespace DB\n         factory.registerSource(\"redis\", create_table_source);\n     }\n \n-    RedisDictionarySource::Connection::Connection(PoolPtr pool_, ClientPtr client_)\n-        : pool(std::move(pool_)), client(std::move(client_))\n-    {\n-    }\n-\n-    RedisDictionarySource::Connection::~Connection()\n-    {\n-        pool->returnObject(std::move(client));\n-    }\n-\n-    static constexpr size_t REDIS_MAX_BLOCK_SIZE = DEFAULT_BLOCK_SIZE;\n-    static constexpr size_t REDIS_LOCK_ACQUIRE_TIMEOUT_MS = 5000;\n-\n     RedisDictionarySource::RedisDictionarySource(\n         const DictionaryStructure & dict_struct_,\n-        const Configuration & configuration_,\n+        const RedisConfiguration & configuration_,\n         const Block & sample_block_)\n         : dict_struct{dict_struct_}\n         , configuration(configuration_)\n-        , pool(std::make_shared<Pool>(configuration.pool_size))\n+        , pool(std::make_shared<RedisPool>(configuration.pool_size))\n         , sample_block{sample_block_}\n     {\n         if (dict_struct.attributes.size() != 1)\n@@ -122,24 +93,9 @@ namespace DB\n \n     RedisDictionarySource::~RedisDictionarySource() = default;\n \n-    static String storageTypeToKeyType(RedisStorageType type)\n-    {\n-        switch (type)\n-        {\n-            case RedisStorageType::SIMPLE:\n-                return \"string\";\n-            case RedisStorageType::HASH_MAP:\n-                return \"hash\";\n-            default:\n-                return \"none\";\n-        }\n-\n-        UNREACHABLE();\n-    }\n-\n     QueryPipeline RedisDictionarySource::loadAll()\n     {\n-        auto connection = getConnection();\n+        auto connection = getRedisConnection(pool, configuration);\n \n         RedisCommand command_for_keys(\"KEYS\");\n         command_for_keys << \"*\";\n@@ -159,33 +115,7 @@ namespace DB\n \n         if (configuration.storage_type == RedisStorageType::HASH_MAP)\n         {\n-            RedisArray hkeys;\n-            for (const auto & key : keys)\n-            {\n-                RedisCommand command_for_secondary_keys(\"HKEYS\");\n-                command_for_secondary_keys.addRedisType(key);\n-\n-                auto secondary_keys = connection->client->execute<RedisArray>(command_for_secondary_keys);\n-\n-                RedisArray primary_with_secondary;\n-                primary_with_secondary.addRedisType(key);\n-                for (const auto & secondary_key : secondary_keys)\n-                {\n-                    primary_with_secondary.addRedisType(secondary_key);\n-                    /// Do not store more than max_block_size values for one request.\n-                    if (primary_with_secondary.size() == REDIS_MAX_BLOCK_SIZE + 1)\n-                    {\n-                        hkeys.add(primary_with_secondary);\n-                        primary_with_secondary.clear();\n-                        primary_with_secondary.addRedisType(key);\n-                    }\n-                }\n-\n-                if (primary_with_secondary.size() > 1)\n-                    hkeys.add(primary_with_secondary);\n-            }\n-\n-            keys = hkeys;\n+            keys = *getRedisHashMapKeys(connection, keys);\n         }\n \n         return QueryPipeline(std::make_shared<RedisSource>(\n@@ -195,7 +125,7 @@ namespace DB\n \n     QueryPipeline RedisDictionarySource::loadIds(const std::vector<UInt64> & ids)\n     {\n-        auto connection = getConnection();\n+        auto connection = getRedisConnection(pool, configuration);\n \n         if (configuration.storage_type == RedisStorageType::HASH_MAP)\n             throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Cannot use loadIds with 'hash_map' storage type\");\n@@ -215,7 +145,7 @@ namespace DB\n \n     QueryPipeline RedisDictionarySource::loadKeys(const Columns & key_columns, const std::vector<size_t> & requested_rows)\n     {\n-        auto connection = getConnection();\n+        auto connection = getRedisConnection(pool, configuration);\n \n         if (key_columns.size() != dict_struct.key->size())\n             throw Exception(ErrorCodes::LOGICAL_ERROR, \"The size of key_columns does not equal to the size of dictionary key\");\n@@ -248,55 +178,4 @@ namespace DB\n         return \"Redis: \" + configuration.host + ':' + DB::toString(configuration.port);\n     }\n \n-    RedisDictionarySource::ConnectionPtr RedisDictionarySource::getConnection() const\n-    {\n-        ClientPtr client;\n-        bool ok = pool->tryBorrowObject(client,\n-            [] { return std::make_unique<Poco::Redis::Client>(); },\n-            REDIS_LOCK_ACQUIRE_TIMEOUT_MS);\n-\n-        if (!ok)\n-            throw Exception(ErrorCodes::TIMEOUT_EXCEEDED,\n-                \"Could not get connection from pool, timeout exceeded {} seconds\",\n-                REDIS_LOCK_ACQUIRE_TIMEOUT_MS);\n-\n-        if (!client->isConnected())\n-        {\n-            try\n-            {\n-                client->connect(configuration.host, configuration.port);\n-\n-                if (!configuration.password.empty())\n-                {\n-                    RedisCommand command(\"AUTH\");\n-                    command << configuration.password;\n-                    String reply = client->execute<String>(command);\n-                    if (reply != \"OK\")\n-                        throw Exception(ErrorCodes::INTERNAL_REDIS_ERROR,\n-                            \"Authentication failed with reason {}\", reply);\n-                }\n-\n-                if (configuration.db_index != 0)\n-                {\n-                    RedisCommand command(\"SELECT\");\n-                    command << std::to_string(configuration.db_index);\n-                    String reply = client->execute<String>(command);\n-                    if (reply != \"OK\")\n-                        throw Exception(ErrorCodes::INTERNAL_REDIS_ERROR,\n-                            \"Selecting database with index {} failed with reason {}\",\n-                            configuration.db_index, reply);\n-                }\n-            }\n-            catch (...)\n-            {\n-                if (client->isConnected())\n-                    client->disconnect();\n-\n-                pool->returnObject(std::move(client));\n-                throw;\n-            }\n-        }\n-\n-        return std::make_unique<Connection>(pool, std::move(client));\n-    }\n }\ndiff --git a/src/Dictionaries/RedisDictionarySource.h b/src/Dictionaries/RedisDictionarySource.h\nindex 8fb6f93193b4..a55f220321d4 100644\n--- a/src/Dictionaries/RedisDictionarySource.h\n+++ b/src/Dictionaries/RedisDictionarySource.h\n@@ -5,16 +5,7 @@\n \n #include \"DictionaryStructure.h\"\n #include \"IDictionarySource.h\"\n-\n-namespace Poco\n-{\n-    namespace Redis\n-    {\n-        class Client;\n-        class Array;\n-        class Command;\n-    }\n-}\n+#include <Storages/RedisCommon.h>\n \n namespace DB\n {\n@@ -23,47 +14,12 @@ namespace DB\n         extern const int NOT_IMPLEMENTED;\n     }\n \n-    enum class RedisStorageType\n-    {\n-            SIMPLE,\n-            HASH_MAP,\n-            UNKNOWN\n-    };\n-\n     class RedisDictionarySource final : public IDictionarySource\n     {\n     public:\n-        using RedisArray = Poco::Redis::Array;\n-        using RedisCommand = Poco::Redis::Command;\n-\n-        using ClientPtr = std::unique_ptr<Poco::Redis::Client>;\n-        using Pool = BorrowedObjectPool<ClientPtr>;\n-        using PoolPtr = std::shared_ptr<Pool>;\n-\n-        struct Configuration\n-        {\n-            const std::string host;\n-            const UInt16 port;\n-            const UInt32 db_index;\n-            const std::string password;\n-            const RedisStorageType storage_type;\n-            const size_t pool_size;\n-        };\n-\n-        struct Connection\n-        {\n-            Connection(PoolPtr pool_, ClientPtr client_);\n-            ~Connection();\n-\n-            PoolPtr pool;\n-            ClientPtr client;\n-        };\n-\n-        using ConnectionPtr = std::unique_ptr<Connection>;\n-\n         RedisDictionarySource(\n             const DictionaryStructure & dict_struct_,\n-            const Configuration & configuration_,\n+            const RedisConfiguration & configuration_,\n             const Block & sample_block_);\n \n         RedisDictionarySource(const RedisDictionarySource & other);\n@@ -92,12 +48,10 @@ namespace DB\n         std::string toString() const override;\n \n     private:\n-        ConnectionPtr getConnection() const;\n-\n         const DictionaryStructure dict_struct;\n-        const Configuration configuration;\n+        const RedisConfiguration configuration;\n \n-        PoolPtr pool;\n+        RedisPoolPtr pool;\n         Block sample_block;\n     };\n }\ndiff --git a/src/Dictionaries/RedisSource.cpp b/src/Dictionaries/RedisSource.cpp\nindex 4622f65a1a91..719c02787077 100644\n--- a/src/Dictionaries/RedisSource.cpp\n+++ b/src/Dictionaries/RedisSource.cpp\n@@ -1,20 +1,12 @@\n #include \"RedisSource.h\"\n \n-#include <string>\n #include <vector>\n-\n-#include <Poco/Redis/Array.h>\n-#include <Poco/Redis/Client.h>\n-#include <Poco/Redis/Command.h>\n-#include <Poco/Redis/Type.h>\n-\n #include <Columns/ColumnNullable.h>\n #include <Columns/ColumnString.h>\n #include <Columns/ColumnsNumber.h>\n #include <IO/ReadHelpers.h>\n #include <IO/WriteHelpers.h>\n-\n-#include \"DictionaryStructure.h\"\n+#include <IO/ReadBufferFromString.h>\n \n \n namespace DB\n@@ -30,7 +22,7 @@ namespace DB\n \n \n     RedisSource::RedisSource(\n-        ConnectionPtr connection_,\n+        RedisConnectionPtr connection_,\n         const RedisArray & keys_,\n         const RedisStorageType & storage_type_,\n         const DB::Block & sample_block,\ndiff --git a/src/Dictionaries/RedisSource.h b/src/Dictionaries/RedisSource.h\nindex 0f8cc3170039..9aa2b0ddba4e 100644\n--- a/src/Dictionaries/RedisSource.h\n+++ b/src/Dictionaries/RedisSource.h\n@@ -6,15 +6,7 @@\n #include <Processors/ISource.h>\n #include <Poco/Redis/Array.h>\n #include <Poco/Redis/Type.h>\n-#include \"RedisDictionarySource.h\"\n-\n-namespace Poco\n-{\n-    namespace Redis\n-    {\n-        class Client;\n-    }\n-}\n+#include <Storages/RedisCommon.h>\n \n \n namespace DB\n@@ -22,15 +14,11 @@ namespace DB\n     class RedisSource final : public ISource\n     {\n     public:\n-        using RedisArray = Poco::Redis::Array;\n-        using RedisBulkString = Poco::Redis::BulkString;\n-        using ConnectionPtr = RedisDictionarySource::ConnectionPtr;\n-\n         RedisSource(\n-            ConnectionPtr connection_,\n-            const Poco::Redis::Array & keys_,\n+            RedisConnectionPtr connection_,\n+            const RedisArray & keys_,\n             const RedisStorageType & storage_type_,\n-            const Block & sample_block,\n+            const DB::Block & sample_block,\n             size_t max_block_size);\n \n         ~RedisSource() override;\n@@ -40,7 +28,7 @@ namespace DB\n     private:\n         Chunk generate() override;\n \n-        ConnectionPtr connection;\n+        RedisConnectionPtr connection;\n         Poco::Redis::Array keys;\n         RedisStorageType storage_type;\n         const size_t max_block_size;\ndiff --git a/src/Storages/KVStorageUtils.cpp b/src/Storages/KVStorageUtils.cpp\nindex d5563108ad7b..370327e4c7eb 100644\n--- a/src/Storages/KVStorageUtils.cpp\n+++ b/src/Storages/KVStorageUtils.cpp\n@@ -175,7 +175,7 @@ std::vector<std::string> serializeKeysToRawString(const ColumnWithTypeAndName &\n     return result;\n }\n \n-/// In current implementation rocks db can have key with only one column.\n+/// In current implementation rocks db/redis can have key with only one column.\n size_t getPrimaryKeyPos(const Block & header, const Names & primary_key)\n {\n     if (primary_key.size() != 1)\ndiff --git a/src/Storages/NamedCollectionsHelpers.h b/src/Storages/NamedCollectionsHelpers.h\nindex 1473a3fbe489..d0d6a526f9b1 100644\n--- a/src/Storages/NamedCollectionsHelpers.h\n+++ b/src/Storages/NamedCollectionsHelpers.h\n@@ -36,6 +36,10 @@ struct MongoDBEqualKeysSet\n     static constexpr std::array<std::pair<std::string_view, std::string_view>, 4> equal_keys{\n         std::pair{\"username\", \"user\"}, std::pair{\"database\", \"db\"}, std::pair{\"hostname\", \"host\"}, std::pair{\"table\", \"collection\"}};\n };\n+struct RedisEqualKeysSet\n+{\n+    static constexpr std::array<std::pair<std::string_view, std::string_view>, 4> equal_keys{std::pair{\"hostname\", \"host\"}};\n+};\n \n template <typename EqualKeys> struct NamedCollectionValidateKey\n {\ndiff --git a/src/Storages/RedisCommon.cpp b/src/Storages/RedisCommon.cpp\nnew file mode 100644\nindex 000000000000..a0534a9e23b1\n--- /dev/null\n+++ b/src/Storages/RedisCommon.cpp\n@@ -0,0 +1,150 @@\n+#include \"RedisCommon.h\"\n+#include <Common/Exception.h>\n+#include <Common/parseAddress.h>\n+#include <Interpreters/evaluateConstantExpression.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int INTERNAL_REDIS_ERROR;\n+    extern const int TIMEOUT_EXCEEDED;\n+    extern const int INVALID_REDIS_STORAGE_TYPE;\n+}\n+\n+RedisConnection::RedisConnection(RedisPoolPtr pool_, RedisClientPtr client_)\n+    : pool(std::move(pool_)), client(std::move(client_))\n+{\n+}\n+\n+RedisConnection::~RedisConnection()\n+{\n+    pool->returnObject(std::move(client));\n+}\n+\n+String storageTypeToKeyType(RedisStorageType type)\n+{\n+    switch (type)\n+    {\n+        case RedisStorageType::SIMPLE:\n+            return \"string\";\n+        case RedisStorageType::HASH_MAP:\n+            return \"hash\";\n+        default:\n+            return \"none\";\n+    }\n+\n+    UNREACHABLE();\n+}\n+\n+String serializeStorageType(RedisStorageType storage_type)\n+{\n+    switch (storage_type)\n+    {\n+        case RedisStorageType::SIMPLE:\n+            return \"simple\";\n+        case RedisStorageType::HASH_MAP:\n+            return \"hash_map\";\n+        default:\n+            return \"none\";\n+    }\n+}\n+\n+RedisStorageType parseStorageType(const String & storage_type_str)\n+{\n+    if (storage_type_str == \"hash_map\")\n+        return RedisStorageType::HASH_MAP;\n+    else if (!storage_type_str.empty() && storage_type_str != \"simple\")\n+        throw Exception(ErrorCodes::INVALID_REDIS_STORAGE_TYPE, \"Unknown storage type {} for Redis dictionary\", storage_type_str);\n+\n+    return RedisStorageType::SIMPLE;\n+}\n+\n+RedisConnectionPtr getRedisConnection(RedisPoolPtr pool, const RedisConfiguration & configuration)\n+{\n+    RedisClientPtr client;\n+    bool ok = pool->tryBorrowObject(client,\n+        [] { return std::make_unique<Poco::Redis::Client>(); },\n+        REDIS_LOCK_ACQUIRE_TIMEOUT_MS);\n+\n+    if (!ok)\n+        throw Exception(ErrorCodes::TIMEOUT_EXCEEDED,\n+                        \"Could not get connection from pool, timeout exceeded {} seconds\",\n+                        REDIS_LOCK_ACQUIRE_TIMEOUT_MS);\n+\n+    if (!client->isConnected())\n+    {\n+        try\n+        {\n+            client->connect(configuration.host, configuration.port);\n+\n+            if (!configuration.password.empty())\n+            {\n+                RedisCommand command(\"AUTH\");\n+                command << configuration.password;\n+                String reply = client->execute<String>(command);\n+                if (reply != \"OK\")\n+                    throw Exception(ErrorCodes::INTERNAL_REDIS_ERROR,\n+                                    \"Authentication failed with reason {}\", reply);\n+            }\n+\n+            if (configuration.db_index != 0)\n+            {\n+                RedisCommand command(\"SELECT\");\n+                command << std::to_string(configuration.db_index);\n+                String reply = client->execute<String>(command);\n+                if (reply != \"OK\")\n+                    throw Exception(ErrorCodes::INTERNAL_REDIS_ERROR,\n+                                    \"Selecting database with index {} failed with reason {}\",\n+                                    configuration.db_index, reply);\n+            }\n+        }\n+        catch (...)\n+        {\n+            if (client->isConnected())\n+                client->disconnect();\n+\n+            pool->returnObject(std::move(client));\n+            throw;\n+        }\n+    }\n+\n+    return std::make_unique<RedisConnection>(pool, std::move(client));\n+}\n+\n+\n+RedisArrayPtr getRedisHashMapKeys(const RedisConnectionPtr & connection, RedisArray & keys)\n+{\n+    RedisArrayPtr hkeys = std::make_shared<RedisArray>();\n+    for (const auto & key : keys)\n+    {\n+        RedisCommand command_for_secondary_keys(\"HKEYS\");\n+        command_for_secondary_keys.addRedisType(key);\n+\n+        auto secondary_keys = connection->client->execute<RedisArray>(command_for_secondary_keys);\n+        if (secondary_keys.isNull())\n+            continue;\n+\n+        RedisArray primary_with_secondary;\n+        primary_with_secondary.addRedisType(key);\n+        for (const auto & secondary_key : secondary_keys)\n+        {\n+            primary_with_secondary.addRedisType(secondary_key);\n+            /// Do not store more than max_block_size values for one request.\n+            if (primary_with_secondary.size() == REDIS_MAX_BLOCK_SIZE + 1)\n+            {\n+                hkeys->add(primary_with_secondary);\n+                primary_with_secondary.clear();\n+                primary_with_secondary.addRedisType(key);\n+            }\n+        }\n+\n+        if (primary_with_secondary.size() > 1)\n+            hkeys->add(primary_with_secondary);\n+    }\n+\n+    return hkeys;\n+}\n+\n+}\ndiff --git a/src/Storages/RedisCommon.h b/src/Storages/RedisCommon.h\nnew file mode 100644\nindex 000000000000..4cc358e65363\n--- /dev/null\n+++ b/src/Storages/RedisCommon.h\n@@ -0,0 +1,78 @@\n+#pragma once\n+\n+#include <Poco/Redis/Client.h>\n+#include <Poco/Redis/Command.h>\n+#include <Poco/Redis/Array.h>\n+#include <Poco/Types.h>\n+\n+#include <Core/Defines.h>\n+#include <base/BorrowedObjectPool.h>\n+#include <Core/Names.h>\n+#include <Storages/ColumnsDescription.h>\n+#include <Storages/StorageFactory.h>\n+\n+namespace DB\n+{\n+static constexpr size_t REDIS_MAX_BLOCK_SIZE = DEFAULT_BLOCK_SIZE;\n+static constexpr size_t REDIS_LOCK_ACQUIRE_TIMEOUT_MS = 5000;\n+\n+enum class RedisStorageType\n+{\n+    SIMPLE,\n+    HASH_MAP,\n+    UNKNOWN\n+};\n+\n+\n+/// storage type to Redis key type\n+String storageTypeToKeyType(RedisStorageType type);\n+\n+RedisStorageType parseStorageType(const String & storage_type_str);\n+String serializeStorageType(RedisStorageType storage_type);\n+\n+struct RedisConfiguration\n+{\n+    String host;\n+    uint32_t port;\n+    uint32_t db_index;\n+    String password;\n+    RedisStorageType storage_type;\n+    uint32_t pool_size;\n+};\n+\n+static uint32_t DEFAULT_REDIS_DB_INDEX = 0;\n+static uint32_t DEFAULT_REDIS_POOL_SIZE = 16;\n+static String DEFAULT_REDIS_PASSWORD;\n+\n+using RedisCommand = Poco::Redis::Command;\n+using RedisArray = Poco::Redis::Array;\n+using RedisArrayPtr = std::shared_ptr<RedisArray>;\n+using RedisBulkString = Poco::Redis::BulkString;\n+using RedisSimpleString = String;\n+using RedisInteger = Poco::Int64;\n+\n+using RedisClientPtr = std::unique_ptr<Poco::Redis::Client>;\n+using RedisPool = BorrowedObjectPool<RedisClientPtr>;\n+using RedisPoolPtr = std::shared_ptr<RedisPool>;\n+\n+/// Redis scan iterator\n+using RedisIterator = int64_t;\n+\n+struct RedisConnection\n+{\n+    RedisConnection(RedisPoolPtr pool_, RedisClientPtr client_);\n+    ~RedisConnection();\n+\n+    RedisPoolPtr pool;\n+    RedisClientPtr client;\n+};\n+\n+using RedisConnectionPtr = std::unique_ptr<RedisConnection>;\n+\n+RedisConnectionPtr getRedisConnection(RedisPoolPtr pool, const RedisConfiguration & configuration);\n+\n+///get all redis hash key array\n+///    eg: keys -> [key1, key2] and get [[key1, field1, field2], [key2, field1, field2]]\n+RedisArrayPtr getRedisHashMapKeys(const RedisConnectionPtr & connection, RedisArray & keys);\n+\n+}\ndiff --git a/src/Storages/StorageFactory.h b/src/Storages/StorageFactory.h\nindex 773095413748..f1c1c2373935 100644\n--- a/src/Storages/StorageFactory.h\n+++ b/src/Storages/StorageFactory.h\n@@ -2,6 +2,7 @@\n \n #include <Common/NamePrompter.h>\n #include <Parsers/IAST_fwd.h>\n+#include <Parsers/ASTCreateQuery.h>\n #include <Storages/ColumnsDescription.h>\n #include <Storages/ConstraintsDescription.h>\n #include <Storages/IStorage_fwd.h>\n@@ -14,8 +15,6 @@ namespace DB\n {\n \n class Context;\n-class ASTCreateQuery;\n-class ASTStorage;\n struct StorageID;\n \n \ndiff --git a/src/Storages/StorageRedis.cpp b/src/Storages/StorageRedis.cpp\nnew file mode 100644\nindex 000000000000..ddb1b62c7b03\n--- /dev/null\n+++ b/src/Storages/StorageRedis.cpp\n@@ -0,0 +1,586 @@\n+#include <unordered_set>\n+#include <IO/WriteHelpers.h>\n+#include <Interpreters/MutationsInterpreter.h>\n+#include <Interpreters/evaluateConstantExpression.h>\n+#include <Parsers/ASTCreateQuery.h>\n+#include <Parsers/ASTDropQuery.h>\n+#include <Parsers/ASTLiteral.h>\n+#include <Processors/Executors/PullingPipelineExecutor.h>\n+#include <Processors/Sinks/SinkToStorage.h>\n+#include <QueryPipeline/Pipe.h>\n+#include <QueryPipeline/QueryPipelineBuilder.h>\n+\n+#include <Storages/KVStorageUtils.h>\n+#include <Storages/KeyDescription.h>\n+#include <Storages/NamedCollectionsHelpers.h>\n+#include <Storages/StorageFactory.h>\n+#include <Storages/StorageInMemoryMetadata.h>\n+#include <Storages/StorageRedis.h>\n+#include <Storages/checkAndGetLiteralArgument.h>\n+\n+#include <Common/Exception.h>\n+#include <Common/checkStackSize.h>\n+#include <Common/logger_useful.h>\n+#include <Common/parseAddress.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int BAD_ARGUMENTS;\n+    extern const int LOGICAL_ERROR;\n+    extern const int INTERNAL_REDIS_ERROR;\n+}\n+\n+class RedisDataSource : public ISource\n+{\n+public:\n+    RedisDataSource(\n+        StorageRedis & storage_,\n+        const Block & header,\n+        FieldVectorPtr keys_,\n+        FieldVector::const_iterator begin_,\n+        FieldVector::const_iterator end_,\n+        const size_t max_block_size_)\n+        : ISource(header)\n+        , storage(storage_)\n+        , primary_key_pos(getPrimaryKeyPos(header, storage.getPrimaryKey()))\n+        , keys(keys_)\n+        , begin(begin_)\n+        , end(end_)\n+        , it(begin)\n+        , max_block_size(max_block_size_)\n+    {\n+    }\n+\n+    RedisDataSource(StorageRedis & storage_, const Block & header, const size_t max_block_size_, const String & pattern_ = \"*\")\n+        : ISource(header)\n+        , storage(storage_)\n+        , primary_key_pos(getPrimaryKeyPos(header, storage.getPrimaryKey()))\n+        , iterator(-1)\n+        , pattern(pattern_)\n+        , max_block_size(max_block_size_)\n+    {\n+    }\n+\n+    String getName() const override { return storage.getName(); }\n+\n+    Chunk generate() override\n+    {\n+        if (keys)\n+            return generateWithKeys();\n+        return generateFullScan();\n+    }\n+\n+    Chunk generateWithKeys()\n+    {\n+        const auto & sample_block = getPort().getHeader();\n+        if (it >= end)\n+        {\n+            it = {};\n+            return {};\n+        }\n+\n+        const auto & key_column_type = sample_block.getByName(storage.getPrimaryKey().at(0)).type;\n+        auto raw_keys = serializeKeysToRawString(it, end, key_column_type, max_block_size);\n+\n+        return storage.getBySerializedKeys(raw_keys, nullptr);\n+    }\n+\n+    /// TODO scan may get duplicated keys when Redis is rehashing, it is a very rare case.\n+    Chunk generateFullScan()\n+    {\n+        checkStackSize();\n+\n+        /// redis scan ending\n+        if (iterator == 0)\n+            return {};\n+\n+        RedisArray scan_keys;\n+        RedisIterator next_iterator;\n+\n+        std::tie(next_iterator, scan_keys) = storage.scan(iterator == -1 ? 0 : iterator, pattern, max_block_size);\n+        iterator = next_iterator;\n+\n+        /// redis scan can return nothing\n+        if (scan_keys.isNull() || scan_keys.size() == 0)\n+            return generateFullScan();\n+\n+        const auto & sample_block = getPort().getHeader();\n+        MutableColumns columns = sample_block.cloneEmptyColumns();\n+\n+        RedisArray values = storage.multiGet(scan_keys);\n+        for (size_t i = 0; i < scan_keys.size() && !values.get<RedisBulkString>(i).isNull(); i++)\n+        {\n+            fillColumns(scan_keys.get<RedisBulkString>(i).value(),\n+                        values.get<RedisBulkString>(i).value(),\n+                        primary_key_pos, sample_block, columns\n+            );\n+        }\n+\n+        Block block = sample_block.cloneWithColumns(std::move(columns));\n+        return Chunk(block.getColumns(), block.rows());\n+    }\n+\n+private:\n+    StorageRedis & storage;\n+\n+    size_t primary_key_pos;\n+\n+    /// For key scan\n+    FieldVectorPtr keys = nullptr;\n+    FieldVector::const_iterator begin;\n+    FieldVector::const_iterator end;\n+    FieldVector::const_iterator it;\n+\n+    /// For full scan\n+    RedisIterator iterator;\n+    String pattern;\n+\n+    const size_t max_block_size;\n+};\n+\n+\n+class RedisSink : public SinkToStorage\n+{\n+public:\n+    RedisSink(StorageRedis & storage_, const StorageMetadataPtr & metadata_snapshot_);\n+\n+    void consume(Chunk chunk) override;\n+    String getName() const override { return \"RedisSink\"; }\n+\n+private:\n+    StorageRedis & storage;\n+    StorageMetadataPtr metadata_snapshot;\n+    size_t primary_key_pos = 0;\n+};\n+\n+RedisSink::RedisSink(StorageRedis & storage_, const StorageMetadataPtr & metadata_snapshot_)\n+    : SinkToStorage(metadata_snapshot_->getSampleBlock())\n+    , storage(storage_)\n+    , metadata_snapshot(metadata_snapshot_)\n+{\n+    for (const auto & column : getHeader())\n+    {\n+        if (column.name == storage.getPrimaryKey()[0])\n+            break;\n+        ++primary_key_pos;\n+    }\n+}\n+\n+void RedisSink::consume(Chunk chunk)\n+{\n+    auto rows = chunk.getNumRows();\n+    auto block = getHeader().cloneWithColumns(chunk.detachColumns());\n+\n+    WriteBufferFromOwnString wb_key;\n+    WriteBufferFromOwnString wb_value;\n+\n+    RedisArray data;\n+    for (size_t i = 0; i < rows; ++i)\n+    {\n+        wb_key.restart();\n+        wb_value.restart();\n+\n+        size_t idx = 0;\n+        for (const auto & elem : block)\n+        {\n+            elem.type->getDefaultSerialization()->serializeBinary(*elem.column, i, idx == primary_key_pos ? wb_key : wb_value, {});\n+            ++idx;\n+        }\n+        data.add(wb_key.str());\n+        data.add(wb_value.str());\n+    }\n+\n+    storage.multiSet(data);\n+}\n+\n+StorageRedis::StorageRedis(\n+    const StorageID & table_id_,\n+    const RedisConfiguration & configuration_,\n+    ContextPtr context_,\n+    const StorageInMemoryMetadata & storage_metadata,\n+    const String & primary_key_)\n+    : IStorage(table_id_)\n+    , WithContext(context_->getGlobalContext())\n+    , table_id(table_id_)\n+    , configuration(configuration_)\n+    , log(&Poco::Logger::get(\"StorageRedis\"))\n+    , primary_key(primary_key_)\n+{\n+    pool = std::make_shared<RedisPool>(configuration.pool_size);\n+    setInMemoryMetadata(storage_metadata);\n+}\n+\n+Pipe StorageRedis::read(\n+    const Names & column_names,\n+    const StorageSnapshotPtr & storage_snapshot,\n+    SelectQueryInfo & query_info,\n+    ContextPtr context_,\n+    QueryProcessingStage::Enum /*processed_stage*/,\n+    size_t max_block_size,\n+    size_t num_streams)\n+{\n+    storage_snapshot->check(column_names);\n+\n+    FieldVectorPtr keys;\n+    bool all_scan = false;\n+\n+    Block header = storage_snapshot->metadata->getSampleBlock();\n+    auto primary_key_data_type = header.getByName(primary_key).type;\n+\n+    std::tie(keys, all_scan) = getFilterKeys(primary_key, primary_key_data_type, query_info, context_);\n+\n+    if (all_scan)\n+    {\n+        return Pipe(std::make_shared<RedisDataSource>(*this, header, max_block_size));\n+    }\n+    else\n+    {\n+        if (keys->empty())\n+            return {};\n+\n+        Pipes pipes;\n+\n+        ::sort(keys->begin(), keys->end());\n+        keys->erase(std::unique(keys->begin(), keys->end()), keys->end());\n+\n+        size_t num_keys = keys->size();\n+        size_t num_threads = std::min<size_t>(num_streams, keys->size());\n+\n+        num_threads = std::min<size_t>(num_threads, configuration.pool_size);\n+        assert(num_keys <= std::numeric_limits<uint32_t>::max());\n+\n+        for (size_t thread_idx = 0; thread_idx < num_threads; ++thread_idx)\n+        {\n+            size_t begin = num_keys * thread_idx / num_threads;\n+            size_t end = num_keys * (thread_idx + 1) / num_threads;\n+\n+            pipes.emplace_back(\n+                std::make_shared<RedisDataSource>(*this, header, keys, keys->begin() + begin, keys->begin() + end, max_block_size));\n+        }\n+        return Pipe::unitePipes(std::move(pipes));\n+    }\n+}\n+\n+namespace\n+{\n+    //  host:port, db_index, password, pool_size\n+    RedisConfiguration getRedisConfiguration(ASTs & engine_args, ContextPtr context)\n+    {\n+        RedisConfiguration configuration;\n+\n+        if (engine_args.empty())\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Bad arguments count when creating Redis table engine\");\n+\n+        if (auto named_collection = tryGetNamedCollectionWithOverrides(engine_args, context))\n+        {\n+            validateNamedCollection(\n+                *named_collection,\n+                ValidateKeysMultiset<RedisEqualKeysSet>{\"host\", \"port\", \"hostname\", \"password\", \"db_index\", \"pool_size\"},\n+                {});\n+\n+            configuration.host = named_collection->getAny<String>({\"host\", \"hostname\"});\n+            configuration.port = static_cast<uint32_t>(named_collection->getOrDefault<UInt64>(\"port\", 6379));\n+            configuration.password = named_collection->getOrDefault<String>(\"password\", DEFAULT_REDIS_PASSWORD);\n+            configuration.db_index = static_cast<uint32_t>(named_collection->getOrDefault<UInt64>(\"db_index\", DEFAULT_REDIS_DB_INDEX));\n+            configuration.pool_size = static_cast<uint32_t>(named_collection->getOrDefault<UInt64>(\"pool_size\", DEFAULT_REDIS_POOL_SIZE));\n+        }\n+        else\n+        {\n+            for (auto & engine_arg : engine_args)\n+                engine_arg = evaluateConstantExpressionOrIdentifierAsLiteral(engine_arg, context);\n+\n+            /// 6379 is the default Redis port.\n+            auto parsed_host_port = parseAddress(checkAndGetLiteralArgument<String>(engine_args[0], \"host:port\"), 6379);\n+            configuration.host = parsed_host_port.first;\n+            configuration.port = parsed_host_port.second;\n+\n+            if (engine_args.size() > 1)\n+                configuration.db_index = static_cast<uint32_t>(checkAndGetLiteralArgument<UInt64>(engine_args[1], \"db_index\"));\n+            else\n+                configuration.db_index = DEFAULT_REDIS_DB_INDEX;\n+            if (engine_args.size() > 2)\n+                configuration.password = checkAndGetLiteralArgument<String>(engine_args[2], \"password\");\n+            else\n+                configuration.password = DEFAULT_REDIS_PASSWORD;\n+            if (engine_args.size() > 3)\n+                configuration.pool_size = static_cast<uint32_t>(checkAndGetLiteralArgument<UInt64>(engine_args[3], \"pool_size\"));\n+            else\n+                configuration.pool_size = DEFAULT_REDIS_POOL_SIZE;\n+        }\n+\n+        context->getRemoteHostFilter().checkHostAndPort(configuration.host, toString(configuration.port));\n+        return configuration;\n+    }\n+\n+    StoragePtr createStorageRedis(const StorageFactory::Arguments & args)\n+    {\n+        auto configuration = getRedisConfiguration(args.engine_args, args.getLocalContext());\n+\n+        StorageInMemoryMetadata metadata;\n+        metadata.setColumns(args.columns);\n+        metadata.setConstraints(args.constraints);\n+        metadata.setComment(args.comment);\n+\n+        if (!args.storage_def->primary_key)\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"StorageRedis must require one column in primary key\");\n+\n+        auto primary_key_desc = KeyDescription::getKeyFromAST(args.storage_def->primary_key->ptr(), metadata.columns, args.getContext());\n+        auto primary_key_names = primary_key_desc.expression->getRequiredColumns();\n+\n+        if (primary_key_names.size() != 1)\n+        {\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"StorageRedis must require one column in primary key\");\n+        }\n+\n+        return std::make_shared<StorageRedis>(args.table_id, configuration, args.getContext(), metadata, primary_key_names[0]);\n+    }\n+}\n+\n+Chunk StorageRedis::getBySerializedKeys(const std::vector<std::string> & keys, PaddedPODArray<UInt8> * null_map) const\n+{\n+    RedisArray redis_keys;\n+    for (const auto & key : keys)\n+        redis_keys.add(key);\n+    return getBySerializedKeys(redis_keys, null_map);\n+}\n+\n+Chunk StorageRedis::getBySerializedKeys(const RedisArray & keys, PaddedPODArray<UInt8> * null_map) const\n+{\n+    Block sample_block = getInMemoryMetadataPtr()->getSampleBlock();\n+\n+    size_t primary_key_pos = getPrimaryKeyPos(sample_block, getPrimaryKey());\n+    MutableColumns columns = sample_block.cloneEmptyColumns();\n+\n+    RedisArray values = multiGet(keys);\n+    if (values.isNull() || values.size() == 0)\n+        return {};\n+\n+    if (null_map)\n+    {\n+        null_map->clear();\n+        null_map->resize_fill(keys.size(), 1);\n+    }\n+\n+    for (size_t i = 0; i < values.size(); ++i)\n+    {\n+        if (!values.get<RedisBulkString>(i).isNull())\n+        {\n+            fillColumns(keys.get<RedisBulkString>(i).value(),\n+                        values.get<RedisBulkString>(i).value(),\n+                        primary_key_pos, sample_block, columns\n+            );\n+        }\n+        else /// key not found\n+        {\n+            if (null_map)\n+            {\n+                (*null_map)[i] = 0;\n+                for (size_t col_idx = 0; col_idx < sample_block.columns(); ++col_idx)\n+                {\n+                    columns[col_idx]->insert(sample_block.getByPosition(col_idx).type->getDefault());\n+                }\n+            }\n+        }\n+    }\n+\n+    size_t num_rows = columns.at(0)->size();\n+    return Chunk(std::move(columns), num_rows);\n+}\n+\n+std::pair<RedisIterator, RedisArray> StorageRedis::scan(RedisIterator iterator, const String & pattern, uint64_t max_count)\n+{\n+    auto connection = getRedisConnection(pool, configuration);\n+    RedisCommand scan(\"SCAN\");\n+    scan << toString(iterator) << \"MATCH\" << pattern << \"COUNT\" << toString(max_count);\n+\n+    const auto & result = connection->client->execute<RedisArray>(scan);\n+    RedisIterator next = parse<RedisIterator>(result.get<RedisBulkString>(0).value());\n+\n+    return {next, result.get<RedisArray>(1)};\n+}\n+\n+RedisArray StorageRedis::multiGet(const RedisArray & keys) const\n+{\n+    auto connection = getRedisConnection(pool, configuration);\n+\n+    RedisCommand cmd_mget(\"MGET\");\n+    for (size_t i = 0; i < keys.size(); ++i)\n+        cmd_mget.add(keys.get<RedisBulkString>(i));\n+\n+    return connection->client->execute<RedisArray>(cmd_mget);\n+}\n+\n+void StorageRedis::multiSet(const RedisArray & data) const\n+{\n+    auto connection = getRedisConnection(pool, configuration);\n+\n+    RedisCommand cmd_mget(\"MSET\");\n+    for (size_t i = 0; i < data.size(); ++i)\n+        cmd_mget.add(data.get<RedisBulkString>(i));\n+\n+    auto ret = connection->client->execute<RedisSimpleString>(cmd_mget);\n+    if (ret != \"OK\")\n+        throw Exception(ErrorCodes::INTERNAL_REDIS_ERROR, \"Fail to write to redis table {}, for {}\", table_id.getFullNameNotQuoted(), ret);\n+}\n+\n+RedisInteger StorageRedis::multiDelete(const RedisArray & keys) const\n+{\n+    auto connection = getRedisConnection(pool, configuration);\n+\n+    RedisCommand cmd(\"DEL\");\n+    for (size_t i = 0; i < keys.size(); ++i)\n+        cmd.add(keys.get<RedisBulkString>(i));\n+\n+    auto ret = connection->client->execute<RedisInteger>(cmd);\n+    if (ret != static_cast<RedisInteger>(keys.size()))\n+        LOG_DEBUG(\n+            log,\n+            \"Try to delete {} rows but actually deleted {} rows from redis table {}.\",\n+            keys.size(),\n+            ret,\n+            table_id.getFullNameNotQuoted());\n+\n+    return ret;\n+}\n+\n+Chunk StorageRedis::getByKeys(const ColumnsWithTypeAndName & keys, PaddedPODArray<UInt8> & null_map, const Names &) const\n+{\n+    if (keys.size() != 1)\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"StorageRedis supports only one key, got: {}\", keys.size());\n+\n+    auto raw_keys = serializeKeysToRawString(keys[0]);\n+\n+    if (raw_keys.size() != keys[0].column->size())\n+        throw DB::Exception(ErrorCodes::LOGICAL_ERROR, \"Assertion failed: {} != {}\", raw_keys.size(), keys[0].column->size());\n+\n+    return getBySerializedKeys(raw_keys, &null_map);\n+}\n+\n+Block StorageRedis::getSampleBlock(const Names &) const\n+{\n+    return getInMemoryMetadataPtr()->getSampleBlock();\n+}\n+\n+SinkToStoragePtr StorageRedis::write(\n+    const ASTPtr & /*query*/,\n+    const StorageMetadataPtr & metadata_snapshot,\n+    ContextPtr /*context*/,\n+    bool /*async_insert*/)\n+{\n+    return std::make_shared<RedisSink>(*this, metadata_snapshot);\n+}\n+\n+void StorageRedis::truncate(const ASTPtr & query, const StorageMetadataPtr &, ContextPtr, TableExclusiveLockHolder &)\n+{\n+    auto connection = getRedisConnection(pool, configuration);\n+\n+    auto * truncate_query = query->as<ASTDropQuery>();\n+    assert(truncate_query != nullptr);\n+\n+    RedisCommand cmd_flush_db(\"FLUSHDB\");\n+    if (!truncate_query->sync)\n+        cmd_flush_db.add(\"ASYNC\");\n+\n+    auto ret = connection->client->execute<RedisSimpleString>(cmd_flush_db);\n+\n+    if (ret != \"OK\")\n+        throw Exception(ErrorCodes::INTERNAL_REDIS_ERROR, \"Fail to truncate redis table {}, for {}\", table_id.getFullNameNotQuoted(), ret);\n+}\n+\n+void StorageRedis::checkMutationIsPossible(const MutationCommands & commands, const Settings & /* settings */) const\n+{\n+    if (commands.empty())\n+        return;\n+\n+    if (commands.size() > 1)\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Mutations cannot be combined for StorageRedis\");\n+\n+    const auto command_type = commands.front().type;\n+    if (command_type != MutationCommand::Type::UPDATE && command_type != MutationCommand::Type::DELETE)\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Only DELETE and UPDATE mutation supported for StorageRedis\");\n+}\n+\n+void StorageRedis::mutate(const MutationCommands & commands, ContextPtr context_)\n+{\n+    if (commands.empty())\n+        return;\n+\n+    assert(commands.size() == 1);\n+\n+    auto metadata_snapshot = getInMemoryMetadataPtr();\n+    auto storage = getStorageID();\n+    auto storage_ptr = DatabaseCatalog::instance().getTable(storage, context_);\n+\n+    if (commands.front().type == MutationCommand::Type::DELETE)\n+    {\n+        MutationsInterpreter::Settings settings(true);\n+        settings.return_all_columns = true;\n+        settings.return_mutated_rows = true;\n+\n+        auto interpreter = std::make_unique<MutationsInterpreter>(storage_ptr, metadata_snapshot, commands, context_, settings);\n+        auto pipeline = QueryPipelineBuilder::getPipeline(interpreter->execute());\n+        PullingPipelineExecutor executor(pipeline);\n+\n+        auto sink = std::make_shared<RedisSink>(*this, metadata_snapshot);\n+\n+        auto header = interpreter->getUpdatedHeader();\n+        auto primary_key_pos = header.getPositionByName(primary_key);\n+\n+        Block block;\n+        while (executor.pull(block))\n+        {\n+            auto & column_type_name = block.getByPosition(primary_key_pos);\n+\n+            auto column = column_type_name.column;\n+            auto size = column->size();\n+\n+            RedisArray keys;\n+            WriteBufferFromOwnString wb_key;\n+            for (size_t i = 0; i < size; ++i)\n+            {\n+                wb_key.restart();\n+                column_type_name.type->getDefaultSerialization()->serializeBinary(*column, i, wb_key, {});\n+                keys.add(wb_key.str());\n+            }\n+            multiDelete(keys);\n+        }\n+        return;\n+    }\n+\n+    assert(commands.front().type == MutationCommand::Type::UPDATE);\n+    if (commands.front().column_to_update_expression.contains(primary_key))\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Primary key cannot be updated (cannot update column {})\", primary_key);\n+\n+    MutationsInterpreter::Settings settings(true);\n+    settings.return_all_columns = true;\n+    settings.return_mutated_rows = true;\n+\n+    auto interpreter = std::make_unique<MutationsInterpreter>(storage_ptr, metadata_snapshot, commands, context_, settings);\n+    auto pipeline = QueryPipelineBuilder::getPipeline(interpreter->execute());\n+    PullingPipelineExecutor executor(pipeline);\n+\n+    auto sink = std::make_shared<RedisSink>(*this, metadata_snapshot);\n+\n+    Block block;\n+    while (executor.pull(block))\n+    {\n+        sink->consume(Chunk{block.getColumns(), block.rows()});\n+    }\n+}\n+\n+/// TODO support ttl\n+void registerStorageRedis(StorageFactory & factory)\n+{\n+    StorageFactory::StorageFeatures features{\n+        .supports_sort_order = true,\n+        .supports_parallel_insert = true,\n+        .source_access_type = AccessType::REDIS,\n+    };\n+\n+    factory.registerStorage(\"Redis\", createStorageRedis, features);\n+}\n+\n+}\ndiff --git a/src/Storages/StorageRedis.h b/src/Storages/StorageRedis.h\nnew file mode 100644\nindex 000000000000..a525a4ed7de9\n--- /dev/null\n+++ b/src/Storages/StorageRedis.h\n@@ -0,0 +1,83 @@\n+#pragma once\n+\n+#include <Poco/Redis/Redis.h>\n+#include <Storages/IStorage.h>\n+#include <Storages/RedisCommon.h>\n+#include <Interpreters/IKeyValueEntity.h>\n+#include <Interpreters/Context_fwd.h>\n+#include <Storages/MutationCommands.h>\n+\n+namespace DB\n+{\n+/* Implements storage in the Redis.\n+ * Use ENGINE = Redis(host:port[, db_index[, password[, pool_size]]]) PRIMARY KEY(key);\n+ */\n+class StorageRedis : public IStorage, public IKeyValueEntity, WithContext\n+{\n+public:\n+    StorageRedis(\n+        const StorageID & table_id_,\n+        const RedisConfiguration & configuration_,\n+        ContextPtr context_,\n+        const StorageInMemoryMetadata & storage_metadata,\n+        const String & primary_key_);\n+\n+    std::string getName() const override { return \"Redis\"; }\n+\n+    Pipe read(\n+        const Names & column_names,\n+        const StorageSnapshotPtr & storage_snapshot,\n+        SelectQueryInfo & query_info,\n+        ContextPtr context_,\n+        QueryProcessingStage::Enum processed_stage,\n+        size_t max_block_size,\n+        size_t num_streams) override;\n+\n+    SinkToStoragePtr write(\n+        const ASTPtr & query,\n+        const StorageMetadataPtr & /*metadata_snapshot*/,\n+        ContextPtr context,\n+        bool /*async_insert*/) override;\n+\n+    void truncate(const ASTPtr &,\n+        const StorageMetadataPtr & metadata_snapshot,\n+        ContextPtr,\n+        TableExclusiveLockHolder &) override;\n+\n+    void checkMutationIsPossible(const MutationCommands & commands, const Settings & settings) const override;\n+    void mutate(const MutationCommands &, ContextPtr) override;\n+\n+    Names getPrimaryKey() const override { return {primary_key}; }\n+\n+    /// Return chunk with data for given serialized keys.\n+    /// If out_null_map is passed, fill it with 1/0 depending on key was/wasn't found. Result chunk may contain default values.\n+    /// If out_null_map is not passed. Not found rows excluded from result chunk.\n+    Chunk getBySerializedKeys(\n+        const std::vector<std::string> & keys,\n+        PaddedPODArray<UInt8> * out_null_map) const;\n+\n+    Chunk getBySerializedKeys(\n+        const RedisArray & keys,\n+        PaddedPODArray<UInt8> * out_null_map) const;\n+\n+    std::pair<RedisIterator, RedisArray> scan(RedisIterator iterator, const String & pattern, uint64_t max_count);\n+\n+    RedisArray multiGet(const RedisArray & keys) const;\n+    void multiSet(const RedisArray & data) const;\n+    RedisInteger multiDelete(const RedisArray & keys) const;\n+\n+    Chunk getByKeys(const ColumnsWithTypeAndName & keys, PaddedPODArray<UInt8> & null_map, const Names &) const override;\n+\n+    Block getSampleBlock(const Names &) const override;\n+\n+private:\n+    StorageID table_id;\n+    RedisConfiguration configuration;\n+\n+    Poco::Logger * log;\n+    RedisPoolPtr pool;\n+\n+    const String primary_key;\n+};\n+\n+}\ndiff --git a/src/Storages/registerStorages.cpp b/src/Storages/registerStorages.cpp\nindex 5606e6728d4f..a4f1d963704d 100644\n--- a/src/Storages/registerStorages.cpp\n+++ b/src/Storages/registerStorages.cpp\n@@ -59,6 +59,7 @@ void registerStorageMySQL(StorageFactory & factory);\n #endif\n \n void registerStorageMongoDB(StorageFactory & factory);\n+void registerStorageRedis(StorageFactory & factory);\n \n \n #if USE_RDKAFKA\n@@ -160,6 +161,7 @@ void registerStorages()\n     #endif\n \n     registerStorageMongoDB(factory);\n+    registerStorageRedis(factory);\n \n     #if USE_RDKAFKA\n     registerStorageKafka(factory);\ndiff --git a/src/TableFunctions/TableFunctionRedis.cpp b/src/TableFunctions/TableFunctionRedis.cpp\nnew file mode 100644\nindex 000000000000..ec659ae61e04\n--- /dev/null\n+++ b/src/TableFunctions/TableFunctionRedis.cpp\n@@ -0,0 +1,94 @@\n+#include <TableFunctions/TableFunctionRedis.h>\n+\n+#include <Common/Exception.h>\n+#include <Common/parseAddress.h>\n+\n+#include <Interpreters/Context.h>\n+\n+#include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTIdentifier.h>\n+\n+#include <Interpreters/parseColumnsListForTableFunction.h>\n+#include <Storages/ColumnsDescription.h>\n+#include <TableFunctions/TableFunctionFactory.h>\n+#include <TableFunctions/registerTableFunctions.h>\n+#include <Storages/checkAndGetLiteralArgument.h>\n+#include <Interpreters/evaluateConstantExpression.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int BAD_ARGUMENTS;\n+}\n+\n+StoragePtr TableFunctionRedis::executeImpl(\n+    const ASTPtr & /*ast_function*/, ContextPtr context, const String & table_name, ColumnsDescription /*cached_columns*/) const\n+{\n+    auto columns = getActualTableStructure(context);\n+\n+    StorageInMemoryMetadata metadata;\n+    metadata.setColumns(columns);\n+\n+    String db_name = \"redis\" + getDatabaseName() + \"_db_\" + toString(configuration.db_index);\n+    auto storage = std::make_shared<StorageRedis>(\n+        StorageID(db_name, table_name), configuration, context, metadata, primary_key);\n+    storage->startup();\n+    return storage;\n+}\n+\n+ColumnsDescription TableFunctionRedis::getActualTableStructure(ContextPtr context) const\n+{\n+    return parseColumnsListFromString(structure, context);\n+}\n+\n+void TableFunctionRedis::parseArguments(const ASTPtr & ast_function, ContextPtr context)\n+{\n+    const auto & func_args = ast_function->as<ASTFunction &>();\n+    if (!func_args.arguments)\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Table function 'redis' must have arguments.\");\n+\n+    ASTs & args = func_args.arguments->children;\n+\n+    if (args.size() < 3)\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Bad arguments count when creating Redis table function\");\n+\n+    for (auto & arg : args)\n+        arg = evaluateConstantExpressionOrIdentifierAsLiteral(arg, context);\n+\n+    auto parsed_host_port = parseAddress(checkAndGetLiteralArgument<String>(args[0], \"host:port\"), 6379);\n+    configuration.host = parsed_host_port.first;\n+    configuration.port = parsed_host_port.second;\n+\n+    primary_key = checkAndGetLiteralArgument<String>(args[1], \"key\");\n+    structure = checkAndGetLiteralArgument<String>(args[2], \"structure\");\n+\n+    if (args.size() > 3)\n+        configuration.db_index = static_cast<uint32_t>(checkAndGetLiteralArgument<UInt64>(args[3], \"db_index\"));\n+    else\n+        configuration.db_index = DEFAULT_REDIS_DB_INDEX;\n+    if (args.size() > 4)\n+        configuration.password = checkAndGetLiteralArgument<String>(args[4], \"password\");\n+    else\n+        configuration.password = DEFAULT_REDIS_PASSWORD;\n+    if (args.size() > 5)\n+        configuration.pool_size = static_cast<uint32_t>(checkAndGetLiteralArgument<UInt64>(args[5], \"pool_size\"));\n+    else\n+        configuration.pool_size = DEFAULT_REDIS_POOL_SIZE;\n+\n+    context->getRemoteHostFilter().checkHostAndPort(configuration.host, toString(configuration.port));\n+\n+    auto columns = parseColumnsListFromString(structure, context);\n+    if (!columns.has(primary_key))\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Bad arguments redis table function structure should contains key.\");\n+}\n+\n+\n+void registerTableFunctionRedis(TableFunctionFactory & factory)\n+{\n+    factory.registerFunction<TableFunctionRedis>();\n+}\n+\n+}\ndiff --git a/src/TableFunctions/TableFunctionRedis.h b/src/TableFunctions/TableFunctionRedis.h\nnew file mode 100644\nindex 000000000000..b985a89e3d72\n--- /dev/null\n+++ b/src/TableFunctions/TableFunctionRedis.h\n@@ -0,0 +1,34 @@\n+#pragma once\n+\n+#include <Storages/StorageRedis.h>\n+#include <TableFunctions/ITableFunction.h>\n+#include <Storages/ExternalDataSourceConfiguration.h>\n+\n+namespace DB\n+{\n+\n+/* Implements Redis table function.\n+ * Use redis(host:port, key, structure[, db_index[, password[, pool_size]]]);\n+ */\n+class TableFunctionRedis : public ITableFunction\n+{\n+public:\n+    static constexpr auto name = \"redis\";\n+    String getName() const override { return name; }\n+\n+private:\n+    StoragePtr executeImpl(\n+        const ASTPtr & ast_function, ContextPtr context,\n+        const String & table_name, ColumnsDescription cached_columns) const override;\n+\n+    const char * getStorageTypeName() const override { return \"Redis\"; }\n+\n+    ColumnsDescription getActualTableStructure(ContextPtr context) const override;\n+    void parseArguments(const ASTPtr & ast_function, ContextPtr context) override;\n+\n+    RedisConfiguration configuration;\n+    String structure;\n+    String primary_key;\n+};\n+\n+}\ndiff --git a/src/TableFunctions/registerTableFunctions.cpp b/src/TableFunctions/registerTableFunctions.cpp\nindex 0499524a9121..eb6e0372223d 100644\n--- a/src/TableFunctions/registerTableFunctions.cpp\n+++ b/src/TableFunctions/registerTableFunctions.cpp\n@@ -21,6 +21,7 @@ void registerTableFunctions()\n     registerTableFunctionInput(factory);\n     registerTableFunctionGenerate(factory);\n     registerTableFunctionMongoDB(factory);\n+    registerTableFunctionRedis(factory);\n \n     registerTableFunctionMeiliSearch(factory);\n \ndiff --git a/src/TableFunctions/registerTableFunctions.h b/src/TableFunctions/registerTableFunctions.h\nindex 393bc080a3da..758e193e88f4 100644\n--- a/src/TableFunctions/registerTableFunctions.h\n+++ b/src/TableFunctions/registerTableFunctions.h\n@@ -18,6 +18,7 @@ void registerTableFunctionValues(TableFunctionFactory & factory);\n void registerTableFunctionInput(TableFunctionFactory & factory);\n void registerTableFunctionGenerate(TableFunctionFactory & factory);\n void registerTableFunctionMongoDB(TableFunctionFactory & factory);\n+void registerTableFunctionRedis(TableFunctionFactory & factory);\n \n void registerTableFunctionMeiliSearch(TableFunctionFactory & factory);\n \ndiff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt\nindex 8a88149a7609..73ec64e2f30b 100644\n--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt\n+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt\n@@ -2046,6 +2046,7 @@ reconnection\n recurse\n redash\n reddit\n+redis\n redisstreams\n refcounter\n regexpExtract\n",
  "test_patch": "diff --git a/tests/integration/test_storage_redis/__init__.py b/tests/integration/test_storage_redis/__init__.py\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/integration/test_storage_redis/test.py b/tests/integration/test_storage_redis/test.py\nnew file mode 100644\nindex 000000000000..2fd97b9bebd0\n--- /dev/null\n+++ b/tests/integration/test_storage_redis/test.py\n@@ -0,0 +1,388 @@\n+## sudo -H pip install redis\n+import redis\n+import pytest\n+import struct\n+import sys\n+\n+from helpers.client import QueryRuntimeException\n+from helpers.cluster import ClickHouseCluster\n+from helpers.test_tools import TSV\n+\n+cluster = ClickHouseCluster(__file__)\n+\n+node = cluster.add_instance(\"node\", with_redis=True)\n+\n+\n+@pytest.fixture(scope=\"module\")\n+def started_cluster():\n+    try:\n+        cluster.start()\n+        yield cluster\n+    finally:\n+        cluster.shutdown()\n+\n+\n+def get_redis_connection(db_id=0):\n+    client = redis.Redis(\n+        host=\"localhost\", port=cluster.redis_port, password=\"clickhouse\", db=db_id\n+    )\n+    return client\n+\n+\n+def get_address_for_ch():\n+    return cluster.redis_host + \":6379\"\n+\n+\n+def drop_table(table):\n+    node.query(f\"DROP TABLE IF EXISTS {table} SYNC\")\n+\n+\n+# see SerializationString.serializeBinary\n+def serialize_binary_for_string(x):\n+    var_uint_max = (1 << 63) - 1\n+    buf = bytearray()\n+    # write length\n+    length = len(x)\n+    # length = (length << 1) ^ (length >> 63)\n+    if length > var_uint_max:\n+        raise ValueError(\"Value too large for varint encoding\")\n+    for i in range(9):\n+        byte = length & 0x7F\n+        if length > 0x7F:\n+            byte |= 0x80\n+        buf += bytes([byte])\n+        length >>= 7\n+        if not length:\n+            break\n+    # write data\n+    buf += x.encode(\"utf-8\")\n+    return bytes(buf)\n+\n+\n+# see SerializationNumber.serializeBinary\n+def serialize_binary_for_uint32(x):\n+    buf = bytearray()\n+    packed_num = struct.pack(\"I\", x)\n+    buf += packed_num\n+    if sys.byteorder != \"little\":\n+        buf.reverse()\n+    return bytes(buf)\n+\n+\n+def test_simple_select(started_cluster):\n+    client = get_redis_connection()\n+    address = get_address_for_ch()\n+\n+    # clean all\n+    client.flushall()\n+    drop_table(\"test_simple_select\")\n+\n+    data = {}\n+    for i in range(100):\n+        packed = serialize_binary_for_string(str(i))\n+        data[packed] = packed\n+\n+    client.mset(data)\n+    client.close()\n+\n+    # create table\n+    node.query(\n+        f\"\"\"\n+        CREATE TABLE test_simple_select(\n+            k String, \n+            v String\n+        ) Engine=Redis('{address}', 0, 'clickhouse') PRIMARY KEY (k)\n+        \"\"\"\n+    )\n+\n+    response = TSV.toMat(\n+        node.query(\"SELECT k, v FROM test_simple_select WHERE k='0' FORMAT TSV\")\n+    )\n+    assert len(response) == 1\n+    assert response[0] == [\"0\", \"0\"]\n+\n+    response = TSV.toMat(\n+        node.query(\"SELECT * FROM test_simple_select ORDER BY k FORMAT TSV\")\n+    )\n+    assert len(response) == 100\n+    assert response[0] == [\"0\", \"0\"]\n+\n+\n+def test_select_int(started_cluster):\n+    client = get_redis_connection()\n+    address = get_address_for_ch()\n+\n+    # clean all\n+    client.flushall()\n+    drop_table(\"test_select_int\")\n+\n+    data = {}\n+    for i in range(100):\n+        packed = serialize_binary_for_uint32(i)\n+        data[packed] = packed\n+\n+    client.mset(data)\n+    client.close()\n+\n+    # create table\n+    node.query(\n+        f\"\"\"\n+        CREATE TABLE test_select_int(\n+            k UInt32, \n+            v UInt32\n+        ) Engine=Redis('{address}', 0, 'clickhouse') PRIMARY KEY (k)\n+        \"\"\"\n+    )\n+\n+    response = TSV.toMat(\n+        node.query(\"SELECT k, v FROM test_select_int WHERE k=0 FORMAT TSV\")\n+    )\n+    assert len(response) == 1\n+    assert response[0] == [\"0\", \"0\"]\n+\n+    response = TSV.toMat(\n+        node.query(\"SELECT * FROM test_select_int ORDER BY k FORMAT TSV\")\n+    )\n+    assert len(response) == 100\n+    assert response[0] == [\"0\", \"0\"]\n+\n+\n+def test_create_table(started_cluster):\n+    address = get_address_for_ch()\n+\n+    # simple creation\n+    drop_table(\"test_create_table\")\n+    node.query(\n+        f\"\"\"\n+        CREATE TABLE test_create_table(\n+            k String,\n+            v UInt32\n+        ) Engine=Redis('{address}') PRIMARY KEY (k)\n+        \"\"\"\n+    )\n+\n+    # simple creation with full engine args\n+    drop_table(\"test_create_table\")\n+    node.query(\n+        f\"\"\"\n+        CREATE TABLE test_create_table(\n+            k String,\n+            v UInt32\n+        ) Engine=Redis('{address}', 0, 'clickhouse', 10) PRIMARY KEY (k)\n+        \"\"\"\n+    )\n+\n+    drop_table(\"test_create_table\")\n+    node.query(\n+        f\"\"\"\n+        CREATE TABLE test_create_table(\n+            k String,\n+            f String,\n+            v UInt32\n+        ) Engine=Redis('{address}', 0, 'clickhouse', 10) PRIMARY KEY (k)\n+        \"\"\"\n+    )\n+\n+    drop_table(\"test_create_table\")\n+    with pytest.raises(QueryRuntimeException):\n+        node.query(\n+            f\"\"\"\n+            CREATE TABLE test_create_table(\n+                k String,\n+                f String,\n+                v UInt32\n+            ) Engine=Redis('{address}', 0, 'clickhouse', 10) PRIMARY KEY ()\n+            \"\"\"\n+        )\n+\n+    drop_table(\"test_create_table\")\n+    with pytest.raises(QueryRuntimeException):\n+        node.query(\n+            f\"\"\"\n+            CREATE TABLE test_create_table(\n+                k String,\n+                f String,\n+                v UInt32\n+            ) Engine=Redis('{address}', 0, 'clickhouse', 10)\n+            \"\"\"\n+        )\n+\n+\n+def test_simple_insert(started_cluster):\n+    client = get_redis_connection()\n+    address = get_address_for_ch()\n+\n+    # clean all\n+    client.flushall()\n+    drop_table(\"test_simple_insert\")\n+\n+    node.query(\n+        f\"\"\"\n+        CREATE TABLE test_simple_insert(\n+            k UInt32, \n+            m DateTime,\n+            n String\n+        ) Engine=Redis('{address}', 0, 'clickhouse') PRIMARY KEY (k)\n+        \"\"\"\n+    )\n+\n+    node.query(\n+        \"\"\"\n+        INSERT INTO test_simple_insert Values \n+        (1, '2023-06-01 00:00:00', 'lili'), (2, '2023-06-02 00:00:00', 'lucy')\n+        \"\"\"\n+    )\n+\n+    response = node.query(\"SELECT COUNT(*) FROM test_simple_insert FORMAT Values\")\n+    assert response == \"(2)\"\n+\n+    response = TSV.toMat(\n+        node.query(\"SELECT k, m, n FROM test_simple_insert WHERE k=1 FORMAT TSV\")\n+    )\n+    assert len(response) == 1\n+    assert response[0] == [\"1\", \"2023-06-01 00:00:00\", \"lili\"]\n+\n+    response = TSV.toMat(\n+        node.query(\n+            \"SELECT k, m, n FROM test_simple_insert WHERE m='2023-06-01 00:00:00' FORMAT TSV\"\n+        )\n+    )\n+    assert len(response) == 1\n+    assert response[0] == [\"1\", \"2023-06-01 00:00:00\", \"lili\"]\n+\n+    response = TSV.toMat(\n+        node.query(\"SELECT k, m, n FROM test_simple_insert WHERE n='lili' FORMAT TSV\")\n+    )\n+    assert len(response) == 1\n+    assert response[0] == [\"1\", \"2023-06-01 00:00:00\", \"lili\"]\n+\n+\n+def test_update(started_cluster):\n+    client = get_redis_connection()\n+    address = get_address_for_ch()\n+    # clean all\n+    client.flushall()\n+    drop_table(\"test_update\")\n+\n+    node.query(\n+        f\"\"\"\n+        CREATE TABLE test_update(\n+            k UInt32, \n+            m DateTime,\n+            n String\n+        ) Engine=Redis('{address}', 0, 'clickhouse') PRIMARY KEY (k)\n+        \"\"\"\n+    )\n+\n+    node.query(\n+        \"\"\"\n+        INSERT INTO test_update Values \n+        (1, '2023-06-01 00:00:00', 'lili'), (2, '2023-06-02 00:00:00', 'lucy')\n+        \"\"\"\n+    )\n+\n+    response = node.query(\n+        \"\"\"\n+        ALTER TABLE test_update UPDATE m='2023-06-03 00:00:00' WHERE k=1\n+        \"\"\"\n+    )\n+\n+    print(\"update response: \", response)\n+\n+    response = TSV.toMat(\n+        node.query(\"SELECT k, m, n FROM test_update WHERE k=1 FORMAT TSV\")\n+    )\n+    assert len(response) == 1\n+    assert response[0] == [\"1\", \"2023-06-03 00:00:00\", \"lili\"]\n+\n+    # can not update key\n+    with pytest.raises(QueryRuntimeException):\n+        node.query(\n+            \"\"\"\n+            ALTER TABLE test_update UPDATE k=2 WHERE k=1\n+            \"\"\"\n+        )\n+\n+\n+def test_delete(started_cluster):\n+    client = get_redis_connection()\n+    address = get_address_for_ch()\n+\n+    # clean all\n+    client.flushall()\n+    drop_table(\"test_delete\")\n+\n+    node.query(\n+        f\"\"\"\n+        CREATE TABLE test_delete(\n+            k UInt32, \n+            m DateTime,\n+            n String\n+        ) Engine=Redis('{address}', 0, 'clickhouse') PRIMARY KEY (k)\n+        \"\"\"\n+    )\n+\n+    node.query(\n+        \"\"\"\n+        INSERT INTO test_delete Values \n+        (1, '2023-06-01 00:00:00', 'lili'), (2, '2023-06-02 00:00:00', 'lucy')\n+        \"\"\"\n+    )\n+\n+    response = node.query(\n+        \"\"\"\n+        ALTER TABLE test_delete DELETE WHERE k=1\n+        \"\"\"\n+    )\n+\n+    print(\"delete response: \", response)\n+\n+    response = TSV.toMat(node.query(\"SELECT k, m, n FROM test_delete FORMAT TSV\"))\n+    assert len(response) == 1\n+    assert response[0] == [\"2\", \"2023-06-02 00:00:00\", \"lucy\"]\n+\n+    response = node.query(\n+        \"\"\"\n+        ALTER TABLE test_delete DELETE WHERE m='2023-06-02 00:00:00'\n+        \"\"\"\n+    )\n+\n+    response = TSV.toMat(node.query(\"SELECT k, m, n FROM test_delete FORMAT TSV\"))\n+    assert len(response) == 0\n+\n+\n+def test_truncate(started_cluster):\n+    client = get_redis_connection()\n+    address = get_address_for_ch()\n+    # clean all\n+    client.flushall()\n+    drop_table(\"test_truncate\")\n+\n+    node.query(\n+        f\"\"\"\n+        CREATE TABLE test_truncate(\n+            k UInt32, \n+            m DateTime,\n+            n String\n+        ) Engine=Redis('{address}', 0, 'clickhouse') PRIMARY KEY (k)\n+        \"\"\"\n+    )\n+\n+    node.query(\n+        \"\"\"\n+        INSERT INTO test_truncate Values \n+        (1, '2023-06-01 00:00:00', 'lili'), (2, '2023-06-02 00:00:00', 'lucy')\n+        \"\"\"\n+    )\n+\n+    response = node.query(\n+        \"\"\"\n+        TRUNCATE TABLE test_truncate\n+        \"\"\"\n+    )\n+\n+    print(\"truncate table response: \", response)\n+\n+    response = TSV.toMat(node.query(\"SELECT COUNT(*) FROM test_truncate FORMAT TSV\"))\n+    assert len(response) == 1\n+    assert response[0] == [\"0\"]\ndiff --git a/tests/integration/test_table_function_redis/__init__.py b/tests/integration/test_table_function_redis/__init__.py\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/integration/test_table_function_redis/test.py b/tests/integration/test_table_function_redis/test.py\nnew file mode 100644\nindex 000000000000..f4bcebe2f902\n--- /dev/null\n+++ b/tests/integration/test_table_function_redis/test.py\n@@ -0,0 +1,230 @@\n+import datetime\n+\n+import redis\n+import pytest\n+import sys\n+import struct\n+\n+from helpers.client import QueryRuntimeException\n+from helpers.cluster import ClickHouseCluster\n+from helpers.test_tools import TSV\n+\n+cluster = ClickHouseCluster(__file__)\n+\n+node = cluster.add_instance(\"node\", with_redis=True)\n+\n+\n+@pytest.fixture(scope=\"module\")\n+def started_cluster():\n+    try:\n+        cluster.start()\n+        yield cluster\n+    finally:\n+        cluster.shutdown()\n+\n+\n+def get_redis_connection(db_id=0):\n+    client = redis.Redis(\n+        host=\"localhost\", port=cluster.redis_port, password=\"clickhouse\", db=db_id\n+    )\n+    return client\n+\n+\n+def get_address_for_ch():\n+    return cluster.redis_host + \":6379\"\n+\n+\n+# see SerializationString.serializeBinary\n+def serialize_binary_for_string(x):\n+    var_uint_max = (1 << 63) - 1\n+    buf = bytearray()\n+    # write length\n+    length = len(x)\n+    # length = (length << 1) ^ (length >> 63)\n+    if length > var_uint_max:\n+        raise ValueError(\"Value too large for varint encoding\")\n+    for i in range(9):\n+        byte = length & 0x7F\n+        if length > 0x7F:\n+            byte |= 0x80\n+        buf += bytes([byte])\n+        length >>= 7\n+        if not length:\n+            break\n+    # write data\n+    buf += x.encode(\"utf-8\")\n+    return bytes(buf)\n+\n+\n+# see SerializationNumber.serializeBinary\n+def serialize_binary_for_uint32(x):\n+    buf = bytearray()\n+    packed_num = struct.pack(\"I\", x)\n+    buf += packed_num\n+    if sys.byteorder != \"little\":\n+        buf.reverse()\n+    return bytes(buf)\n+\n+\n+def test_simple_select(started_cluster):\n+    client = get_redis_connection()\n+    address = get_address_for_ch()\n+\n+    # clean all\n+    client.flushall()\n+\n+    data = {}\n+    for i in range(100):\n+        packed = serialize_binary_for_string(str(i))\n+        data[packed] = packed\n+\n+    client.mset(data)\n+    client.close()\n+\n+    response = TSV.toMat(\n+        node.query(\n+            f\"\"\"\n+            SELECT \n+                key, value \n+            FROM \n+                redis('{address}', 'key', 'key String, value String', 0, 'clickhouse', 10) \n+            WHERE \n+                key='0' \n+            FORMAT TSV\n+            \"\"\"\n+        )\n+    )\n+\n+    assert len(response) == 1\n+    assert response[0] == [\"0\", \"0\"]\n+\n+    response = TSV.toMat(\n+        node.query(\n+            f\"\"\"\n+            SELECT \n+                * \n+            FROM \n+                redis('{address}', 'key', 'key String, value String', 0, 'clickhouse', 10) \n+            ORDER BY \n+                key \n+            FORMAT TSV\n+            \"\"\"\n+        )\n+    )\n+\n+    assert len(response) == 100\n+    assert response[0] == [\"0\", \"0\"]\n+\n+\n+def test_create_table(started_cluster):\n+    client = get_redis_connection()\n+    address = get_address_for_ch()\n+\n+    # clean all\n+    client.flushall()\n+    client.close()\n+\n+    node.query(\n+        f\"\"\"\n+        SELECT \n+            *\n+        FROM \n+            redis('{address}', 'k', 'k String, v UInt32', 0, 'clickhouse', 10) \n+        \"\"\"\n+    )\n+\n+    # illegal data type\n+    with pytest.raises(QueryRuntimeException):\n+        node.query(\n+            f\"\"\"\n+            SELECT \n+                *\n+            FROM \n+                redis('{address}', 'k', 'k not_exist_type, v String', 0, 'clickhouse', 10) \n+            \"\"\"\n+        )\n+\n+    # illegal key\n+    with pytest.raises(QueryRuntimeException):\n+        node.query(\n+            f\"\"\"\n+            SELECT \n+                *\n+            FROM \n+                redis('{address}', 'not_exist_key', 'k not_exist_type, v String', 0, 'clickhouse', 10) \n+            \"\"\"\n+        )\n+\n+\n+def test_data_type(started_cluster):\n+    client = get_redis_connection()\n+    address = get_address_for_ch()\n+\n+    # string\n+    client.flushall()\n+    value = serialize_binary_for_string(\"0\")\n+    client.set(value, value)\n+\n+    response = TSV.toMat(\n+        node.query(\n+            f\"\"\"\n+            SELECT\n+                *\n+            FROM\n+                redis('{address}', 'k', 'k String, v String', 0, 'clickhouse', 10)\n+            WHERE\n+                k='0'\n+            FORMAT TSV\n+            \"\"\"\n+        )\n+    )\n+\n+    assert len(response) == 1\n+    assert response[0] == [\"0\", \"0\"]\n+\n+    # number\n+    client.flushall()\n+    value = serialize_binary_for_uint32(0)\n+    client.set(value, value)\n+\n+    response = TSV.toMat(\n+        node.query(\n+            f\"\"\"\n+            SELECT\n+                *\n+            FROM\n+                redis('{address}', 'k', 'k UInt32, v UInt32', 0, 'clickhouse', 10)\n+            WHERE\n+                k=0\n+            FORMAT TSV\n+            \"\"\"\n+        )\n+    )\n+\n+    assert len(response) == 1\n+    assert response[0] == [\"0\", \"0\"]\n+\n+    # datetime\n+    client.flushall()\n+    # clickhouse store datatime as uint32 in internal\n+    dt = datetime.datetime(2023, 6, 1, 0, 0, 0)\n+    seconds_since_epoch = dt.timestamp()\n+    value = serialize_binary_for_uint32(int(seconds_since_epoch))\n+    client.set(value, value)\n+\n+    response = TSV.toMat(\n+        node.query(\n+            f\"\"\"\n+            SELECT\n+                *\n+            FROM\n+                redis('{address}', 'k', 'k DateTime, v DateTime', 0, 'clickhouse', 10)\n+            WHERE\n+                k='2023-06-01 00:00:00'\n+            FORMAT TSV\n+            \"\"\"\n+        )\n+    )\n+\n+    assert len(response) == 1\n+    assert response[0] == [\"2023-06-01 00:00:00\", \"2023-06-01 00:00:00\"]\ndiff --git a/tests/queries/0_stateless/01271_show_privileges.reference b/tests/queries/0_stateless/01271_show_privileges.reference\nindex 5d30da5d2ea7..9e6249bfcb39 100644\n--- a/tests/queries/0_stateless/01271_show_privileges.reference\n+++ b/tests/queries/0_stateless/01271_show_privileges.reference\n@@ -149,6 +149,7 @@ FILE\t[]\tGLOBAL\tSOURCES\n URL\t[]\tGLOBAL\tSOURCES\n REMOTE\t[]\tGLOBAL\tSOURCES\n MONGO\t[]\tGLOBAL\tSOURCES\n+REDIS\t[]\tGLOBAL\tSOURCES\n MEILISEARCH\t[]\tGLOBAL\tSOURCES\n MYSQL\t[]\tGLOBAL\tSOURCES\n POSTGRES\t[]\tGLOBAL\tSOURCES\ndiff --git a/tests/queries/0_stateless/02117_show_create_table_system.reference b/tests/queries/0_stateless/02117_show_create_table_system.reference\nindex e864ba850188..703972279e70 100644\n--- a/tests/queries/0_stateless/02117_show_create_table_system.reference\n+++ b/tests/queries/0_stateless/02117_show_create_table_system.reference\n@@ -297,7 +297,7 @@ CREATE TABLE system.grants\n (\n     `user_name` Nullable(String),\n     `role_name` Nullable(String),\n-    `access_type` Enum16('SHOW DATABASES' = 0, 'SHOW TABLES' = 1, 'SHOW COLUMNS' = 2, 'SHOW DICTIONARIES' = 3, 'SHOW' = 4, 'SHOW FILESYSTEM CACHES' = 5, 'SELECT' = 6, 'INSERT' = 7, 'ALTER UPDATE' = 8, 'ALTER DELETE' = 9, 'ALTER ADD COLUMN' = 10, 'ALTER MODIFY COLUMN' = 11, 'ALTER DROP COLUMN' = 12, 'ALTER COMMENT COLUMN' = 13, 'ALTER CLEAR COLUMN' = 14, 'ALTER RENAME COLUMN' = 15, 'ALTER MATERIALIZE COLUMN' = 16, 'ALTER COLUMN' = 17, 'ALTER MODIFY COMMENT' = 18, 'ALTER ORDER BY' = 19, 'ALTER SAMPLE BY' = 20, 'ALTER ADD INDEX' = 21, 'ALTER DROP INDEX' = 22, 'ALTER MATERIALIZE INDEX' = 23, 'ALTER CLEAR INDEX' = 24, 'ALTER INDEX' = 25, 'ALTER ADD PROJECTION' = 26, 'ALTER DROP PROJECTION' = 27, 'ALTER MATERIALIZE PROJECTION' = 28, 'ALTER CLEAR PROJECTION' = 29, 'ALTER PROJECTION' = 30, 'ALTER ADD CONSTRAINT' = 31, 'ALTER DROP CONSTRAINT' = 32, 'ALTER CONSTRAINT' = 33, 'ALTER TTL' = 34, 'ALTER MATERIALIZE TTL' = 35, 'ALTER SETTINGS' = 36, 'ALTER MOVE PARTITION' = 37, 'ALTER FETCH PARTITION' = 38, 'ALTER FREEZE PARTITION' = 39, 'ALTER DATABASE SETTINGS' = 40, 'ALTER NAMED COLLECTION' = 41, 'ALTER TABLE' = 42, 'ALTER DATABASE' = 43, 'ALTER VIEW REFRESH' = 44, 'ALTER VIEW MODIFY QUERY' = 45, 'ALTER VIEW' = 46, 'ALTER' = 47, 'CREATE DATABASE' = 48, 'CREATE TABLE' = 49, 'CREATE VIEW' = 50, 'CREATE DICTIONARY' = 51, 'CREATE TEMPORARY TABLE' = 52, 'CREATE ARBITRARY TEMPORARY TABLE' = 53, 'CREATE FUNCTION' = 54, 'CREATE NAMED COLLECTION' = 55, 'CREATE' = 56, 'DROP DATABASE' = 57, 'DROP TABLE' = 58, 'DROP VIEW' = 59, 'DROP DICTIONARY' = 60, 'DROP FUNCTION' = 61, 'DROP NAMED COLLECTION' = 62, 'DROP' = 63, 'UNDROP TABLE' = 64, 'TRUNCATE' = 65, 'OPTIMIZE' = 66, 'BACKUP' = 67, 'KILL QUERY' = 68, 'KILL TRANSACTION' = 69, 'MOVE PARTITION BETWEEN SHARDS' = 70, 'CREATE USER' = 71, 'ALTER USER' = 72, 'DROP USER' = 73, 'CREATE ROLE' = 74, 'ALTER ROLE' = 75, 'DROP ROLE' = 76, 'ROLE ADMIN' = 77, 'CREATE ROW POLICY' = 78, 'ALTER ROW POLICY' = 79, 'DROP ROW POLICY' = 80, 'CREATE QUOTA' = 81, 'ALTER QUOTA' = 82, 'DROP QUOTA' = 83, 'CREATE SETTINGS PROFILE' = 84, 'ALTER SETTINGS PROFILE' = 85, 'DROP SETTINGS PROFILE' = 86, 'SHOW USERS' = 87, 'SHOW ROLES' = 88, 'SHOW ROW POLICIES' = 89, 'SHOW QUOTAS' = 90, 'SHOW SETTINGS PROFILES' = 91, 'SHOW ACCESS' = 92, 'ACCESS MANAGEMENT' = 93, 'SHOW NAMED COLLECTIONS' = 94, 'SHOW NAMED COLLECTIONS SECRETS' = 95, 'NAMED COLLECTION CONTROL' = 96, 'SYSTEM SHUTDOWN' = 97, 'SYSTEM DROP DNS CACHE' = 98, 'SYSTEM DROP MARK CACHE' = 99, 'SYSTEM DROP UNCOMPRESSED CACHE' = 100, 'SYSTEM DROP MMAP CACHE' = 101, 'SYSTEM DROP QUERY CACHE' = 102, 'SYSTEM DROP COMPILED EXPRESSION CACHE' = 103, 'SYSTEM DROP FILESYSTEM CACHE' = 104, 'SYSTEM DROP SCHEMA CACHE' = 105, 'SYSTEM DROP S3 CLIENT CACHE' = 106, 'SYSTEM DROP CACHE' = 107, 'SYSTEM RELOAD CONFIG' = 108, 'SYSTEM RELOAD USERS' = 109, 'SYSTEM RELOAD SYMBOLS' = 110, 'SYSTEM RELOAD DICTIONARY' = 111, 'SYSTEM RELOAD MODEL' = 112, 'SYSTEM RELOAD FUNCTION' = 113, 'SYSTEM RELOAD EMBEDDED DICTIONARIES' = 114, 'SYSTEM RELOAD' = 115, 'SYSTEM RESTART DISK' = 116, 'SYSTEM MERGES' = 117, 'SYSTEM TTL MERGES' = 118, 'SYSTEM FETCHES' = 119, 'SYSTEM MOVES' = 120, 'SYSTEM DISTRIBUTED SENDS' = 121, 'SYSTEM REPLICATED SENDS' = 122, 'SYSTEM SENDS' = 123, 'SYSTEM REPLICATION QUEUES' = 124, 'SYSTEM DROP REPLICA' = 125, 'SYSTEM SYNC REPLICA' = 126, 'SYSTEM RESTART REPLICA' = 127, 'SYSTEM RESTORE REPLICA' = 128, 'SYSTEM WAIT LOADING PARTS' = 129, 'SYSTEM SYNC DATABASE REPLICA' = 130, 'SYSTEM SYNC TRANSACTION LOG' = 131, 'SYSTEM SYNC FILE CACHE' = 132, 'SYSTEM FLUSH DISTRIBUTED' = 133, 'SYSTEM FLUSH LOGS' = 134, 'SYSTEM FLUSH' = 135, 'SYSTEM THREAD FUZZER' = 136, 'SYSTEM UNFREEZE' = 137, 'SYSTEM FAILPOINT' = 138, 'SYSTEM' = 139, 'dictGet' = 140, 'displaySecretsInShowAndSelect' = 141, 'addressToLine' = 142, 'addressToLineWithInlines' = 143, 'addressToSymbol' = 144, 'demangle' = 145, 'INTROSPECTION' = 146, 'FILE' = 147, 'URL' = 148, 'REMOTE' = 149, 'MONGO' = 150, 'MEILISEARCH' = 151, 'MYSQL' = 152, 'POSTGRES' = 153, 'SQLITE' = 154, 'ODBC' = 155, 'JDBC' = 156, 'HDFS' = 157, 'S3' = 158, 'HIVE' = 159, 'AZURE' = 160, 'SOURCES' = 161, 'CLUSTER' = 162, 'ALL' = 163, 'NONE' = 164),\n+    `access_type` Enum16('SHOW DATABASES' = 0, 'SHOW TABLES' = 1, 'SHOW COLUMNS' = 2, 'SHOW DICTIONARIES' = 3, 'SHOW' = 4, 'SHOW FILESYSTEM CACHES' = 5, 'SELECT' = 6, 'INSERT' = 7, 'ALTER UPDATE' = 8, 'ALTER DELETE' = 9, 'ALTER ADD COLUMN' = 10, 'ALTER MODIFY COLUMN' = 11, 'ALTER DROP COLUMN' = 12, 'ALTER COMMENT COLUMN' = 13, 'ALTER CLEAR COLUMN' = 14, 'ALTER RENAME COLUMN' = 15, 'ALTER MATERIALIZE COLUMN' = 16, 'ALTER COLUMN' = 17, 'ALTER MODIFY COMMENT' = 18, 'ALTER ORDER BY' = 19, 'ALTER SAMPLE BY' = 20, 'ALTER ADD INDEX' = 21, 'ALTER DROP INDEX' = 22, 'ALTER MATERIALIZE INDEX' = 23, 'ALTER CLEAR INDEX' = 24, 'ALTER INDEX' = 25, 'ALTER ADD PROJECTION' = 26, 'ALTER DROP PROJECTION' = 27, 'ALTER MATERIALIZE PROJECTION' = 28, 'ALTER CLEAR PROJECTION' = 29, 'ALTER PROJECTION' = 30, 'ALTER ADD CONSTRAINT' = 31, 'ALTER DROP CONSTRAINT' = 32, 'ALTER CONSTRAINT' = 33, 'ALTER TTL' = 34, 'ALTER MATERIALIZE TTL' = 35, 'ALTER SETTINGS' = 36, 'ALTER MOVE PARTITION' = 37, 'ALTER FETCH PARTITION' = 38, 'ALTER FREEZE PARTITION' = 39, 'ALTER DATABASE SETTINGS' = 40, 'ALTER NAMED COLLECTION' = 41, 'ALTER TABLE' = 42, 'ALTER DATABASE' = 43, 'ALTER VIEW REFRESH' = 44, 'ALTER VIEW MODIFY QUERY' = 45, 'ALTER VIEW' = 46, 'ALTER' = 47, 'CREATE DATABASE' = 48, 'CREATE TABLE' = 49, 'CREATE VIEW' = 50, 'CREATE DICTIONARY' = 51, 'CREATE TEMPORARY TABLE' = 52, 'CREATE ARBITRARY TEMPORARY TABLE' = 53, 'CREATE FUNCTION' = 54, 'CREATE NAMED COLLECTION' = 55, 'CREATE' = 56, 'DROP DATABASE' = 57, 'DROP TABLE' = 58, 'DROP VIEW' = 59, 'DROP DICTIONARY' = 60, 'DROP FUNCTION' = 61, 'DROP NAMED COLLECTION' = 62, 'DROP' = 63, 'UNDROP TABLE' = 64, 'TRUNCATE' = 65, 'OPTIMIZE' = 66, 'BACKUP' = 67, 'KILL QUERY' = 68, 'KILL TRANSACTION' = 69, 'MOVE PARTITION BETWEEN SHARDS' = 70, 'CREATE USER' = 71, 'ALTER USER' = 72, 'DROP USER' = 73, 'CREATE ROLE' = 74, 'ALTER ROLE' = 75, 'DROP ROLE' = 76, 'ROLE ADMIN' = 77, 'CREATE ROW POLICY' = 78, 'ALTER ROW POLICY' = 79, 'DROP ROW POLICY' = 80, 'CREATE QUOTA' = 81, 'ALTER QUOTA' = 82, 'DROP QUOTA' = 83, 'CREATE SETTINGS PROFILE' = 84, 'ALTER SETTINGS PROFILE' = 85, 'DROP SETTINGS PROFILE' = 86, 'SHOW USERS' = 87, 'SHOW ROLES' = 88, 'SHOW ROW POLICIES' = 89, 'SHOW QUOTAS' = 90, 'SHOW SETTINGS PROFILES' = 91, 'SHOW ACCESS' = 92, 'ACCESS MANAGEMENT' = 93, 'SHOW NAMED COLLECTIONS' = 94, 'SHOW NAMED COLLECTIONS SECRETS' = 95, 'NAMED COLLECTION CONTROL' = 96, 'SYSTEM SHUTDOWN' = 97, 'SYSTEM DROP DNS CACHE' = 98, 'SYSTEM DROP MARK CACHE' = 99, 'SYSTEM DROP UNCOMPRESSED CACHE' = 100, 'SYSTEM DROP MMAP CACHE' = 101, 'SYSTEM DROP QUERY CACHE' = 102, 'SYSTEM DROP COMPILED EXPRESSION CACHE' = 103, 'SYSTEM DROP FILESYSTEM CACHE' = 104, 'SYSTEM DROP SCHEMA CACHE' = 105, 'SYSTEM DROP S3 CLIENT CACHE' = 106, 'SYSTEM DROP CACHE' = 107, 'SYSTEM RELOAD CONFIG' = 108, 'SYSTEM RELOAD USERS' = 109, 'SYSTEM RELOAD SYMBOLS' = 110, 'SYSTEM RELOAD DICTIONARY' = 111, 'SYSTEM RELOAD MODEL' = 112, 'SYSTEM RELOAD FUNCTION' = 113, 'SYSTEM RELOAD EMBEDDED DICTIONARIES' = 114, 'SYSTEM RELOAD' = 115, 'SYSTEM RESTART DISK' = 116, 'SYSTEM MERGES' = 117, 'SYSTEM TTL MERGES' = 118, 'SYSTEM FETCHES' = 119, 'SYSTEM MOVES' = 120, 'SYSTEM DISTRIBUTED SENDS' = 121, 'SYSTEM REPLICATED SENDS' = 122, 'SYSTEM SENDS' = 123, 'SYSTEM REPLICATION QUEUES' = 124, 'SYSTEM DROP REPLICA' = 125, 'SYSTEM SYNC REPLICA' = 126, 'SYSTEM RESTART REPLICA' = 127, 'SYSTEM RESTORE REPLICA' = 128, 'SYSTEM WAIT LOADING PARTS' = 129, 'SYSTEM SYNC DATABASE REPLICA' = 130, 'SYSTEM SYNC TRANSACTION LOG' = 131, 'SYSTEM SYNC FILE CACHE' = 132, 'SYSTEM FLUSH DISTRIBUTED' = 133, 'SYSTEM FLUSH LOGS' = 134, 'SYSTEM FLUSH' = 135, 'SYSTEM THREAD FUZZER' = 136, 'SYSTEM UNFREEZE' = 137, 'SYSTEM FAILPOINT' = 138, 'SYSTEM' = 139, 'dictGet' = 140, 'displaySecretsInShowAndSelect' = 141, 'addressToLine' = 142, 'addressToLineWithInlines' = 143, 'addressToSymbol' = 144, 'demangle' = 145, 'INTROSPECTION' = 146, 'FILE' = 147, 'URL' = 148, 'REMOTE' = 149, 'MONGO' = 150, 'REDIS' = 151, 'MEILISEARCH' = 152, 'MYSQL' = 153, 'POSTGRES' = 154, 'SQLITE' = 155, 'ODBC' = 156, 'JDBC' = 157, 'HDFS' = 158, 'S3' = 159, 'HIVE' = 160, 'AZURE' = 161, 'SOURCES' = 162, 'CLUSTER' = 163, 'ALL' = 164, 'NONE' = 165),\n     `database` Nullable(String),\n     `table` Nullable(String),\n     `column` Nullable(String),\n@@ -581,10 +581,10 @@ ENGINE = SystemPartsColumns\n COMMENT 'SYSTEM TABLE is built on the fly.'\n CREATE TABLE system.privileges\n (\n-    `privilege` Enum16('SHOW DATABASES' = 0, 'SHOW TABLES' = 1, 'SHOW COLUMNS' = 2, 'SHOW DICTIONARIES' = 3, 'SHOW' = 4, 'SHOW FILESYSTEM CACHES' = 5, 'SELECT' = 6, 'INSERT' = 7, 'ALTER UPDATE' = 8, 'ALTER DELETE' = 9, 'ALTER ADD COLUMN' = 10, 'ALTER MODIFY COLUMN' = 11, 'ALTER DROP COLUMN' = 12, 'ALTER COMMENT COLUMN' = 13, 'ALTER CLEAR COLUMN' = 14, 'ALTER RENAME COLUMN' = 15, 'ALTER MATERIALIZE COLUMN' = 16, 'ALTER COLUMN' = 17, 'ALTER MODIFY COMMENT' = 18, 'ALTER ORDER BY' = 19, 'ALTER SAMPLE BY' = 20, 'ALTER ADD INDEX' = 21, 'ALTER DROP INDEX' = 22, 'ALTER MATERIALIZE INDEX' = 23, 'ALTER CLEAR INDEX' = 24, 'ALTER INDEX' = 25, 'ALTER ADD PROJECTION' = 26, 'ALTER DROP PROJECTION' = 27, 'ALTER MATERIALIZE PROJECTION' = 28, 'ALTER CLEAR PROJECTION' = 29, 'ALTER PROJECTION' = 30, 'ALTER ADD CONSTRAINT' = 31, 'ALTER DROP CONSTRAINT' = 32, 'ALTER CONSTRAINT' = 33, 'ALTER TTL' = 34, 'ALTER MATERIALIZE TTL' = 35, 'ALTER SETTINGS' = 36, 'ALTER MOVE PARTITION' = 37, 'ALTER FETCH PARTITION' = 38, 'ALTER FREEZE PARTITION' = 39, 'ALTER DATABASE SETTINGS' = 40, 'ALTER NAMED COLLECTION' = 41, 'ALTER TABLE' = 42, 'ALTER DATABASE' = 43, 'ALTER VIEW REFRESH' = 44, 'ALTER VIEW MODIFY QUERY' = 45, 'ALTER VIEW' = 46, 'ALTER' = 47, 'CREATE DATABASE' = 48, 'CREATE TABLE' = 49, 'CREATE VIEW' = 50, 'CREATE DICTIONARY' = 51, 'CREATE TEMPORARY TABLE' = 52, 'CREATE ARBITRARY TEMPORARY TABLE' = 53, 'CREATE FUNCTION' = 54, 'CREATE NAMED COLLECTION' = 55, 'CREATE' = 56, 'DROP DATABASE' = 57, 'DROP TABLE' = 58, 'DROP VIEW' = 59, 'DROP DICTIONARY' = 60, 'DROP FUNCTION' = 61, 'DROP NAMED COLLECTION' = 62, 'DROP' = 63, 'UNDROP TABLE' = 64, 'TRUNCATE' = 65, 'OPTIMIZE' = 66, 'BACKUP' = 67, 'KILL QUERY' = 68, 'KILL TRANSACTION' = 69, 'MOVE PARTITION BETWEEN SHARDS' = 70, 'CREATE USER' = 71, 'ALTER USER' = 72, 'DROP USER' = 73, 'CREATE ROLE' = 74, 'ALTER ROLE' = 75, 'DROP ROLE' = 76, 'ROLE ADMIN' = 77, 'CREATE ROW POLICY' = 78, 'ALTER ROW POLICY' = 79, 'DROP ROW POLICY' = 80, 'CREATE QUOTA' = 81, 'ALTER QUOTA' = 82, 'DROP QUOTA' = 83, 'CREATE SETTINGS PROFILE' = 84, 'ALTER SETTINGS PROFILE' = 85, 'DROP SETTINGS PROFILE' = 86, 'SHOW USERS' = 87, 'SHOW ROLES' = 88, 'SHOW ROW POLICIES' = 89, 'SHOW QUOTAS' = 90, 'SHOW SETTINGS PROFILES' = 91, 'SHOW ACCESS' = 92, 'ACCESS MANAGEMENT' = 93, 'SHOW NAMED COLLECTIONS' = 94, 'SHOW NAMED COLLECTIONS SECRETS' = 95, 'NAMED COLLECTION CONTROL' = 96, 'SYSTEM SHUTDOWN' = 97, 'SYSTEM DROP DNS CACHE' = 98, 'SYSTEM DROP MARK CACHE' = 99, 'SYSTEM DROP UNCOMPRESSED CACHE' = 100, 'SYSTEM DROP MMAP CACHE' = 101, 'SYSTEM DROP QUERY CACHE' = 102, 'SYSTEM DROP COMPILED EXPRESSION CACHE' = 103, 'SYSTEM DROP FILESYSTEM CACHE' = 104, 'SYSTEM DROP SCHEMA CACHE' = 105, 'SYSTEM DROP S3 CLIENT CACHE' = 106, 'SYSTEM DROP CACHE' = 107, 'SYSTEM RELOAD CONFIG' = 108, 'SYSTEM RELOAD USERS' = 109, 'SYSTEM RELOAD SYMBOLS' = 110, 'SYSTEM RELOAD DICTIONARY' = 111, 'SYSTEM RELOAD MODEL' = 112, 'SYSTEM RELOAD FUNCTION' = 113, 'SYSTEM RELOAD EMBEDDED DICTIONARIES' = 114, 'SYSTEM RELOAD' = 115, 'SYSTEM RESTART DISK' = 116, 'SYSTEM MERGES' = 117, 'SYSTEM TTL MERGES' = 118, 'SYSTEM FETCHES' = 119, 'SYSTEM MOVES' = 120, 'SYSTEM DISTRIBUTED SENDS' = 121, 'SYSTEM REPLICATED SENDS' = 122, 'SYSTEM SENDS' = 123, 'SYSTEM REPLICATION QUEUES' = 124, 'SYSTEM DROP REPLICA' = 125, 'SYSTEM SYNC REPLICA' = 126, 'SYSTEM RESTART REPLICA' = 127, 'SYSTEM RESTORE REPLICA' = 128, 'SYSTEM WAIT LOADING PARTS' = 129, 'SYSTEM SYNC DATABASE REPLICA' = 130, 'SYSTEM SYNC TRANSACTION LOG' = 131, 'SYSTEM SYNC FILE CACHE' = 132, 'SYSTEM FLUSH DISTRIBUTED' = 133, 'SYSTEM FLUSH LOGS' = 134, 'SYSTEM FLUSH' = 135, 'SYSTEM THREAD FUZZER' = 136, 'SYSTEM UNFREEZE' = 137, 'SYSTEM FAILPOINT' = 138, 'SYSTEM' = 139, 'dictGet' = 140, 'displaySecretsInShowAndSelect' = 141, 'addressToLine' = 142, 'addressToLineWithInlines' = 143, 'addressToSymbol' = 144, 'demangle' = 145, 'INTROSPECTION' = 146, 'FILE' = 147, 'URL' = 148, 'REMOTE' = 149, 'MONGO' = 150, 'MEILISEARCH' = 151, 'MYSQL' = 152, 'POSTGRES' = 153, 'SQLITE' = 154, 'ODBC' = 155, 'JDBC' = 156, 'HDFS' = 157, 'S3' = 158, 'HIVE' = 159, 'AZURE' = 160, 'SOURCES' = 161, 'CLUSTER' = 162, 'ALL' = 163, 'NONE' = 164),\n+    `privilege` Enum16('SHOW DATABASES' = 0, 'SHOW TABLES' = 1, 'SHOW COLUMNS' = 2, 'SHOW DICTIONARIES' = 3, 'SHOW' = 4, 'SHOW FILESYSTEM CACHES' = 5, 'SELECT' = 6, 'INSERT' = 7, 'ALTER UPDATE' = 8, 'ALTER DELETE' = 9, 'ALTER ADD COLUMN' = 10, 'ALTER MODIFY COLUMN' = 11, 'ALTER DROP COLUMN' = 12, 'ALTER COMMENT COLUMN' = 13, 'ALTER CLEAR COLUMN' = 14, 'ALTER RENAME COLUMN' = 15, 'ALTER MATERIALIZE COLUMN' = 16, 'ALTER COLUMN' = 17, 'ALTER MODIFY COMMENT' = 18, 'ALTER ORDER BY' = 19, 'ALTER SAMPLE BY' = 20, 'ALTER ADD INDEX' = 21, 'ALTER DROP INDEX' = 22, 'ALTER MATERIALIZE INDEX' = 23, 'ALTER CLEAR INDEX' = 24, 'ALTER INDEX' = 25, 'ALTER ADD PROJECTION' = 26, 'ALTER DROP PROJECTION' = 27, 'ALTER MATERIALIZE PROJECTION' = 28, 'ALTER CLEAR PROJECTION' = 29, 'ALTER PROJECTION' = 30, 'ALTER ADD CONSTRAINT' = 31, 'ALTER DROP CONSTRAINT' = 32, 'ALTER CONSTRAINT' = 33, 'ALTER TTL' = 34, 'ALTER MATERIALIZE TTL' = 35, 'ALTER SETTINGS' = 36, 'ALTER MOVE PARTITION' = 37, 'ALTER FETCH PARTITION' = 38, 'ALTER FREEZE PARTITION' = 39, 'ALTER DATABASE SETTINGS' = 40, 'ALTER NAMED COLLECTION' = 41, 'ALTER TABLE' = 42, 'ALTER DATABASE' = 43, 'ALTER VIEW REFRESH' = 44, 'ALTER VIEW MODIFY QUERY' = 45, 'ALTER VIEW' = 46, 'ALTER' = 47, 'CREATE DATABASE' = 48, 'CREATE TABLE' = 49, 'CREATE VIEW' = 50, 'CREATE DICTIONARY' = 51, 'CREATE TEMPORARY TABLE' = 52, 'CREATE ARBITRARY TEMPORARY TABLE' = 53, 'CREATE FUNCTION' = 54, 'CREATE NAMED COLLECTION' = 55, 'CREATE' = 56, 'DROP DATABASE' = 57, 'DROP TABLE' = 58, 'DROP VIEW' = 59, 'DROP DICTIONARY' = 60, 'DROP FUNCTION' = 61, 'DROP NAMED COLLECTION' = 62, 'DROP' = 63, 'UNDROP TABLE' = 64, 'TRUNCATE' = 65, 'OPTIMIZE' = 66, 'BACKUP' = 67, 'KILL QUERY' = 68, 'KILL TRANSACTION' = 69, 'MOVE PARTITION BETWEEN SHARDS' = 70, 'CREATE USER' = 71, 'ALTER USER' = 72, 'DROP USER' = 73, 'CREATE ROLE' = 74, 'ALTER ROLE' = 75, 'DROP ROLE' = 76, 'ROLE ADMIN' = 77, 'CREATE ROW POLICY' = 78, 'ALTER ROW POLICY' = 79, 'DROP ROW POLICY' = 80, 'CREATE QUOTA' = 81, 'ALTER QUOTA' = 82, 'DROP QUOTA' = 83, 'CREATE SETTINGS PROFILE' = 84, 'ALTER SETTINGS PROFILE' = 85, 'DROP SETTINGS PROFILE' = 86, 'SHOW USERS' = 87, 'SHOW ROLES' = 88, 'SHOW ROW POLICIES' = 89, 'SHOW QUOTAS' = 90, 'SHOW SETTINGS PROFILES' = 91, 'SHOW ACCESS' = 92, 'ACCESS MANAGEMENT' = 93, 'SHOW NAMED COLLECTIONS' = 94, 'SHOW NAMED COLLECTIONS SECRETS' = 95, 'NAMED COLLECTION CONTROL' = 96, 'SYSTEM SHUTDOWN' = 97, 'SYSTEM DROP DNS CACHE' = 98, 'SYSTEM DROP MARK CACHE' = 99, 'SYSTEM DROP UNCOMPRESSED CACHE' = 100, 'SYSTEM DROP MMAP CACHE' = 101, 'SYSTEM DROP QUERY CACHE' = 102, 'SYSTEM DROP COMPILED EXPRESSION CACHE' = 103, 'SYSTEM DROP FILESYSTEM CACHE' = 104, 'SYSTEM DROP SCHEMA CACHE' = 105, 'SYSTEM DROP S3 CLIENT CACHE' = 106, 'SYSTEM DROP CACHE' = 107, 'SYSTEM RELOAD CONFIG' = 108, 'SYSTEM RELOAD USERS' = 109, 'SYSTEM RELOAD SYMBOLS' = 110, 'SYSTEM RELOAD DICTIONARY' = 111, 'SYSTEM RELOAD MODEL' = 112, 'SYSTEM RELOAD FUNCTION' = 113, 'SYSTEM RELOAD EMBEDDED DICTIONARIES' = 114, 'SYSTEM RELOAD' = 115, 'SYSTEM RESTART DISK' = 116, 'SYSTEM MERGES' = 117, 'SYSTEM TTL MERGES' = 118, 'SYSTEM FETCHES' = 119, 'SYSTEM MOVES' = 120, 'SYSTEM DISTRIBUTED SENDS' = 121, 'SYSTEM REPLICATED SENDS' = 122, 'SYSTEM SENDS' = 123, 'SYSTEM REPLICATION QUEUES' = 124, 'SYSTEM DROP REPLICA' = 125, 'SYSTEM SYNC REPLICA' = 126, 'SYSTEM RESTART REPLICA' = 127, 'SYSTEM RESTORE REPLICA' = 128, 'SYSTEM WAIT LOADING PARTS' = 129, 'SYSTEM SYNC DATABASE REPLICA' = 130, 'SYSTEM SYNC TRANSACTION LOG' = 131, 'SYSTEM SYNC FILE CACHE' = 132, 'SYSTEM FLUSH DISTRIBUTED' = 133, 'SYSTEM FLUSH LOGS' = 134, 'SYSTEM FLUSH' = 135, 'SYSTEM THREAD FUZZER' = 136, 'SYSTEM UNFREEZE' = 137, 'SYSTEM FAILPOINT' = 138, 'SYSTEM' = 139, 'dictGet' = 140, 'displaySecretsInShowAndSelect' = 141, 'addressToLine' = 142, 'addressToLineWithInlines' = 143, 'addressToSymbol' = 144, 'demangle' = 145, 'INTROSPECTION' = 146, 'FILE' = 147, 'URL' = 148, 'REMOTE' = 149, 'MONGO' = 150, 'REDIS' = 151, 'MEILISEARCH' = 152, 'MYSQL' = 153, 'POSTGRES' = 154, 'SQLITE' = 155, 'ODBC' = 156, 'JDBC' = 157, 'HDFS' = 158, 'S3' = 159, 'HIVE' = 160, 'AZURE' = 161, 'SOURCES' = 162, 'CLUSTER' = 163, 'ALL' = 164, 'NONE' = 165),\n     `aliases` Array(String),\n     `level` Nullable(Enum8('GLOBAL' = 0, 'DATABASE' = 1, 'TABLE' = 2, 'DICTIONARY' = 3, 'VIEW' = 4, 'COLUMN' = 5, 'NAMED_COLLECTION' = 6)),\n-    `parent_group` Nullable(Enum16('SHOW DATABASES' = 0, 'SHOW TABLES' = 1, 'SHOW COLUMNS' = 2, 'SHOW DICTIONARIES' = 3, 'SHOW' = 4, 'SHOW FILESYSTEM CACHES' = 5, 'SELECT' = 6, 'INSERT' = 7, 'ALTER UPDATE' = 8, 'ALTER DELETE' = 9, 'ALTER ADD COLUMN' = 10, 'ALTER MODIFY COLUMN' = 11, 'ALTER DROP COLUMN' = 12, 'ALTER COMMENT COLUMN' = 13, 'ALTER CLEAR COLUMN' = 14, 'ALTER RENAME COLUMN' = 15, 'ALTER MATERIALIZE COLUMN' = 16, 'ALTER COLUMN' = 17, 'ALTER MODIFY COMMENT' = 18, 'ALTER ORDER BY' = 19, 'ALTER SAMPLE BY' = 20, 'ALTER ADD INDEX' = 21, 'ALTER DROP INDEX' = 22, 'ALTER MATERIALIZE INDEX' = 23, 'ALTER CLEAR INDEX' = 24, 'ALTER INDEX' = 25, 'ALTER ADD PROJECTION' = 26, 'ALTER DROP PROJECTION' = 27, 'ALTER MATERIALIZE PROJECTION' = 28, 'ALTER CLEAR PROJECTION' = 29, 'ALTER PROJECTION' = 30, 'ALTER ADD CONSTRAINT' = 31, 'ALTER DROP CONSTRAINT' = 32, 'ALTER CONSTRAINT' = 33, 'ALTER TTL' = 34, 'ALTER MATERIALIZE TTL' = 35, 'ALTER SETTINGS' = 36, 'ALTER MOVE PARTITION' = 37, 'ALTER FETCH PARTITION' = 38, 'ALTER FREEZE PARTITION' = 39, 'ALTER DATABASE SETTINGS' = 40, 'ALTER NAMED COLLECTION' = 41, 'ALTER TABLE' = 42, 'ALTER DATABASE' = 43, 'ALTER VIEW REFRESH' = 44, 'ALTER VIEW MODIFY QUERY' = 45, 'ALTER VIEW' = 46, 'ALTER' = 47, 'CREATE DATABASE' = 48, 'CREATE TABLE' = 49, 'CREATE VIEW' = 50, 'CREATE DICTIONARY' = 51, 'CREATE TEMPORARY TABLE' = 52, 'CREATE ARBITRARY TEMPORARY TABLE' = 53, 'CREATE FUNCTION' = 54, 'CREATE NAMED COLLECTION' = 55, 'CREATE' = 56, 'DROP DATABASE' = 57, 'DROP TABLE' = 58, 'DROP VIEW' = 59, 'DROP DICTIONARY' = 60, 'DROP FUNCTION' = 61, 'DROP NAMED COLLECTION' = 62, 'DROP' = 63, 'UNDROP TABLE' = 64, 'TRUNCATE' = 65, 'OPTIMIZE' = 66, 'BACKUP' = 67, 'KILL QUERY' = 68, 'KILL TRANSACTION' = 69, 'MOVE PARTITION BETWEEN SHARDS' = 70, 'CREATE USER' = 71, 'ALTER USER' = 72, 'DROP USER' = 73, 'CREATE ROLE' = 74, 'ALTER ROLE' = 75, 'DROP ROLE' = 76, 'ROLE ADMIN' = 77, 'CREATE ROW POLICY' = 78, 'ALTER ROW POLICY' = 79, 'DROP ROW POLICY' = 80, 'CREATE QUOTA' = 81, 'ALTER QUOTA' = 82, 'DROP QUOTA' = 83, 'CREATE SETTINGS PROFILE' = 84, 'ALTER SETTINGS PROFILE' = 85, 'DROP SETTINGS PROFILE' = 86, 'SHOW USERS' = 87, 'SHOW ROLES' = 88, 'SHOW ROW POLICIES' = 89, 'SHOW QUOTAS' = 90, 'SHOW SETTINGS PROFILES' = 91, 'SHOW ACCESS' = 92, 'ACCESS MANAGEMENT' = 93, 'SHOW NAMED COLLECTIONS' = 94, 'SHOW NAMED COLLECTIONS SECRETS' = 95, 'NAMED COLLECTION CONTROL' = 96, 'SYSTEM SHUTDOWN' = 97, 'SYSTEM DROP DNS CACHE' = 98, 'SYSTEM DROP MARK CACHE' = 99, 'SYSTEM DROP UNCOMPRESSED CACHE' = 100, 'SYSTEM DROP MMAP CACHE' = 101, 'SYSTEM DROP QUERY CACHE' = 102, 'SYSTEM DROP COMPILED EXPRESSION CACHE' = 103, 'SYSTEM DROP FILESYSTEM CACHE' = 104, 'SYSTEM DROP SCHEMA CACHE' = 105, 'SYSTEM DROP S3 CLIENT CACHE' = 106, 'SYSTEM DROP CACHE' = 107, 'SYSTEM RELOAD CONFIG' = 108, 'SYSTEM RELOAD USERS' = 109, 'SYSTEM RELOAD SYMBOLS' = 110, 'SYSTEM RELOAD DICTIONARY' = 111, 'SYSTEM RELOAD MODEL' = 112, 'SYSTEM RELOAD FUNCTION' = 113, 'SYSTEM RELOAD EMBEDDED DICTIONARIES' = 114, 'SYSTEM RELOAD' = 115, 'SYSTEM RESTART DISK' = 116, 'SYSTEM MERGES' = 117, 'SYSTEM TTL MERGES' = 118, 'SYSTEM FETCHES' = 119, 'SYSTEM MOVES' = 120, 'SYSTEM DISTRIBUTED SENDS' = 121, 'SYSTEM REPLICATED SENDS' = 122, 'SYSTEM SENDS' = 123, 'SYSTEM REPLICATION QUEUES' = 124, 'SYSTEM DROP REPLICA' = 125, 'SYSTEM SYNC REPLICA' = 126, 'SYSTEM RESTART REPLICA' = 127, 'SYSTEM RESTORE REPLICA' = 128, 'SYSTEM WAIT LOADING PARTS' = 129, 'SYSTEM SYNC DATABASE REPLICA' = 130, 'SYSTEM SYNC TRANSACTION LOG' = 131, 'SYSTEM SYNC FILE CACHE' = 132, 'SYSTEM FLUSH DISTRIBUTED' = 133, 'SYSTEM FLUSH LOGS' = 134, 'SYSTEM FLUSH' = 135, 'SYSTEM THREAD FUZZER' = 136, 'SYSTEM UNFREEZE' = 137, 'SYSTEM FAILPOINT' = 138, 'SYSTEM' = 139, 'dictGet' = 140, 'displaySecretsInShowAndSelect' = 141, 'addressToLine' = 142, 'addressToLineWithInlines' = 143, 'addressToSymbol' = 144, 'demangle' = 145, 'INTROSPECTION' = 146, 'FILE' = 147, 'URL' = 148, 'REMOTE' = 149, 'MONGO' = 150, 'MEILISEARCH' = 151, 'MYSQL' = 152, 'POSTGRES' = 153, 'SQLITE' = 154, 'ODBC' = 155, 'JDBC' = 156, 'HDFS' = 157, 'S3' = 158, 'HIVE' = 159, 'AZURE' = 160, 'SOURCES' = 161, 'CLUSTER' = 162, 'ALL' = 163, 'NONE' = 164))\n+    `parent_group` Nullable(Enum16('SHOW DATABASES' = 0, 'SHOW TABLES' = 1, 'SHOW COLUMNS' = 2, 'SHOW DICTIONARIES' = 3, 'SHOW' = 4, 'SHOW FILESYSTEM CACHES' = 5, 'SELECT' = 6, 'INSERT' = 7, 'ALTER UPDATE' = 8, 'ALTER DELETE' = 9, 'ALTER ADD COLUMN' = 10, 'ALTER MODIFY COLUMN' = 11, 'ALTER DROP COLUMN' = 12, 'ALTER COMMENT COLUMN' = 13, 'ALTER CLEAR COLUMN' = 14, 'ALTER RENAME COLUMN' = 15, 'ALTER MATERIALIZE COLUMN' = 16, 'ALTER COLUMN' = 17, 'ALTER MODIFY COMMENT' = 18, 'ALTER ORDER BY' = 19, 'ALTER SAMPLE BY' = 20, 'ALTER ADD INDEX' = 21, 'ALTER DROP INDEX' = 22, 'ALTER MATERIALIZE INDEX' = 23, 'ALTER CLEAR INDEX' = 24, 'ALTER INDEX' = 25, 'ALTER ADD PROJECTION' = 26, 'ALTER DROP PROJECTION' = 27, 'ALTER MATERIALIZE PROJECTION' = 28, 'ALTER CLEAR PROJECTION' = 29, 'ALTER PROJECTION' = 30, 'ALTER ADD CONSTRAINT' = 31, 'ALTER DROP CONSTRAINT' = 32, 'ALTER CONSTRAINT' = 33, 'ALTER TTL' = 34, 'ALTER MATERIALIZE TTL' = 35, 'ALTER SETTINGS' = 36, 'ALTER MOVE PARTITION' = 37, 'ALTER FETCH PARTITION' = 38, 'ALTER FREEZE PARTITION' = 39, 'ALTER DATABASE SETTINGS' = 40, 'ALTER NAMED COLLECTION' = 41, 'ALTER TABLE' = 42, 'ALTER DATABASE' = 43, 'ALTER VIEW REFRESH' = 44, 'ALTER VIEW MODIFY QUERY' = 45, 'ALTER VIEW' = 46, 'ALTER' = 47, 'CREATE DATABASE' = 48, 'CREATE TABLE' = 49, 'CREATE VIEW' = 50, 'CREATE DICTIONARY' = 51, 'CREATE TEMPORARY TABLE' = 52, 'CREATE ARBITRARY TEMPORARY TABLE' = 53, 'CREATE FUNCTION' = 54, 'CREATE NAMED COLLECTION' = 55, 'CREATE' = 56, 'DROP DATABASE' = 57, 'DROP TABLE' = 58, 'DROP VIEW' = 59, 'DROP DICTIONARY' = 60, 'DROP FUNCTION' = 61, 'DROP NAMED COLLECTION' = 62, 'DROP' = 63, 'UNDROP TABLE' = 64, 'TRUNCATE' = 65, 'OPTIMIZE' = 66, 'BACKUP' = 67, 'KILL QUERY' = 68, 'KILL TRANSACTION' = 69, 'MOVE PARTITION BETWEEN SHARDS' = 70, 'CREATE USER' = 71, 'ALTER USER' = 72, 'DROP USER' = 73, 'CREATE ROLE' = 74, 'ALTER ROLE' = 75, 'DROP ROLE' = 76, 'ROLE ADMIN' = 77, 'CREATE ROW POLICY' = 78, 'ALTER ROW POLICY' = 79, 'DROP ROW POLICY' = 80, 'CREATE QUOTA' = 81, 'ALTER QUOTA' = 82, 'DROP QUOTA' = 83, 'CREATE SETTINGS PROFILE' = 84, 'ALTER SETTINGS PROFILE' = 85, 'DROP SETTINGS PROFILE' = 86, 'SHOW USERS' = 87, 'SHOW ROLES' = 88, 'SHOW ROW POLICIES' = 89, 'SHOW QUOTAS' = 90, 'SHOW SETTINGS PROFILES' = 91, 'SHOW ACCESS' = 92, 'ACCESS MANAGEMENT' = 93, 'SHOW NAMED COLLECTIONS' = 94, 'SHOW NAMED COLLECTIONS SECRETS' = 95, 'NAMED COLLECTION CONTROL' = 96, 'SYSTEM SHUTDOWN' = 97, 'SYSTEM DROP DNS CACHE' = 98, 'SYSTEM DROP MARK CACHE' = 99, 'SYSTEM DROP UNCOMPRESSED CACHE' = 100, 'SYSTEM DROP MMAP CACHE' = 101, 'SYSTEM DROP QUERY CACHE' = 102, 'SYSTEM DROP COMPILED EXPRESSION CACHE' = 103, 'SYSTEM DROP FILESYSTEM CACHE' = 104, 'SYSTEM DROP SCHEMA CACHE' = 105, 'SYSTEM DROP S3 CLIENT CACHE' = 106, 'SYSTEM DROP CACHE' = 107, 'SYSTEM RELOAD CONFIG' = 108, 'SYSTEM RELOAD USERS' = 109, 'SYSTEM RELOAD SYMBOLS' = 110, 'SYSTEM RELOAD DICTIONARY' = 111, 'SYSTEM RELOAD MODEL' = 112, 'SYSTEM RELOAD FUNCTION' = 113, 'SYSTEM RELOAD EMBEDDED DICTIONARIES' = 114, 'SYSTEM RELOAD' = 115, 'SYSTEM RESTART DISK' = 116, 'SYSTEM MERGES' = 117, 'SYSTEM TTL MERGES' = 118, 'SYSTEM FETCHES' = 119, 'SYSTEM MOVES' = 120, 'SYSTEM DISTRIBUTED SENDS' = 121, 'SYSTEM REPLICATED SENDS' = 122, 'SYSTEM SENDS' = 123, 'SYSTEM REPLICATION QUEUES' = 124, 'SYSTEM DROP REPLICA' = 125, 'SYSTEM SYNC REPLICA' = 126, 'SYSTEM RESTART REPLICA' = 127, 'SYSTEM RESTORE REPLICA' = 128, 'SYSTEM WAIT LOADING PARTS' = 129, 'SYSTEM SYNC DATABASE REPLICA' = 130, 'SYSTEM SYNC TRANSACTION LOG' = 131, 'SYSTEM SYNC FILE CACHE' = 132, 'SYSTEM FLUSH DISTRIBUTED' = 133, 'SYSTEM FLUSH LOGS' = 134, 'SYSTEM FLUSH' = 135, 'SYSTEM THREAD FUZZER' = 136, 'SYSTEM UNFREEZE' = 137, 'SYSTEM FAILPOINT' = 138, 'SYSTEM' = 139, 'dictGet' = 140, 'displaySecretsInShowAndSelect' = 141, 'addressToLine' = 142, 'addressToLineWithInlines' = 143, 'addressToSymbol' = 144, 'demangle' = 145, 'INTROSPECTION' = 146, 'FILE' = 147, 'URL' = 148, 'REMOTE' = 149, 'MONGO' = 150, 'REDIS' = 151, 'MEILISEARCH' = 152, 'MYSQL' = 153, 'POSTGRES' = 154, 'SQLITE' = 155, 'ODBC' = 156, 'JDBC' = 157, 'HDFS' = 158, 'S3' = 159, 'HIVE' = 160, 'AZURE' = 161, 'SOURCES' = 162, 'CLUSTER' = 163, 'ALL' = 164, 'NONE' = 165))\n )\n ENGINE = SystemPrivileges\n COMMENT 'SYSTEM TABLE is built on the fly.'\ndiff --git a/tests/queries/0_stateless/02414_all_new_table_functions_must_be_documented.reference b/tests/queries/0_stateless/02414_all_new_table_functions_must_be_documented.reference\nindex 2277e19cf259..bc83e6262071 100644\n--- a/tests/queries/0_stateless/02414_all_new_table_functions_must_be_documented.reference\n+++ b/tests/queries/0_stateless/02414_all_new_table_functions_must_be_documented.reference\n@@ -13,6 +13,7 @@ null\n numbers\n numbers_mt\n odbc\n+redis\n remote\n remoteSecure\n url\n",
  "problem_statement": "Add `redis` table function and `Redis` table engine.\nSee #37865\n",
  "hints_text": "",
  "created_at": "2023-05-23T13:58:23Z"
}