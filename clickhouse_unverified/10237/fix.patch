diff --git a/src/Interpreters/MutationsInterpreter.cpp b/src/Interpreters/MutationsInterpreter.cpp
index df0267b94507..b1b226b157f2 100644
--- a/src/Interpreters/MutationsInterpreter.cpp
+++ b/src/Interpreters/MutationsInterpreter.cpp
@@ -36,34 +36,46 @@ namespace ErrorCodes
 
 namespace
 {
-struct FirstNonDeterministicFuncData
+/// Helps to detect situations, where non-deterministic functions may be used in mutations of Replicated*MergeTree.
+class FirstNonDeterministicFuncMatcher
 {
-    using TypeToVisit = ASTFunction;
-
-    explicit FirstNonDeterministicFuncData(const Context & context_)
-        : context{context_}
-    {}
+public:
+    struct Data
+    {
+        const Context & context;
+        std::optional<String> nondeterministic_function_name;
+    };
 
-    const Context & context;
-    std::optional<String> nondeterministic_function_name;
+public:
+    static bool needChildVisit(const ASTPtr & /*node*/, const ASTPtr & child)
+    {
+        return child != nullptr;
+    }
 
-    void visit(ASTFunction & function, ASTPtr &)
+    static void visit(const ASTPtr & node, Data & data)
     {
-        if (nondeterministic_function_name)
+        if (data.nondeterministic_function_name)
             return;
 
-        const auto func = FunctionFactory::instance().get(function.name, context);
-        if (!func->isDeterministic())
-            nondeterministic_function_name = func->getName();
+        if (const auto * function = typeid_cast<const ASTFunction *>(node.get()))
+        {
+            /// Property of being deterministic for lambda expression is completely determined
+            /// by the contents of its definition, so we just proceed to it.
+            if (function->name != "lambda")
+            {
+                const auto func = FunctionFactory::instance().get(function->name, data.context);
+                if (!func->isDeterministic())
+                    data.nondeterministic_function_name = func->getName();
+            }
+        }
     }
 };
 
-using FirstNonDeterministicFuncFinder =
-        InDepthNodeVisitor<OneTypeMatcher<FirstNonDeterministicFuncData>, true>;
+using FirstNonDeterministicFuncFinder = InDepthNodeVisitor<FirstNonDeterministicFuncMatcher, true>;
 
 std::optional<String> findFirstNonDeterministicFuncName(const MutationCommand & command, const Context & context)
 {
-    FirstNonDeterministicFuncData finder_data(context);
+    FirstNonDeterministicFuncMatcher::Data finder_data{context, std::nullopt};
 
     switch (command.type)
     {
