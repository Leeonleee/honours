{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 7434,
  "instance_id": "ClickHouse__ClickHouse-7434",
  "issue_numbers": [
    "7424"
  ],
  "base_commit": "7ba4e36e73c135ba8bcf65eb14cd9959621e904f",
  "patch": "diff --git a/dbms/src/Storages/MergeTree/MergeTreeData.cpp b/dbms/src/Storages/MergeTree/MergeTreeData.cpp\nindex af985c02927f..e3de86f5a780 100644\n--- a/dbms/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/dbms/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -2723,10 +2723,20 @@ void MergeTreeData::movePartitionToDisk(const ASTPtr & partition, const String &\n     if (!disk)\n         throw Exception(\"Disk \" + name + \" does not exists on policy \" + storage_policy->getName(), ErrorCodes::UNKNOWN_DISK);\n \n-    for (const auto & part : parts)\n+    parts.erase(std::remove_if(parts.begin(), parts.end(), [&](auto part_ptr)\n+        {\n+            return part_ptr->disk->getName() == disk->getName();\n+        }), parts.end());\n+\n+    if (parts.empty())\n     {\n-        if (part->disk->getName() == disk->getName())\n-            throw Exception(\"Part \" + part->name + \" already on disk \" + name, ErrorCodes::UNKNOWN_DISK);\n+        String no_parts_to_move_message;\n+        if (moving_part)\n+            no_parts_to_move_message = \"Part '\" + partition_id + \"' is already on disk '\" + disk->getName() + \"'\";\n+        else\n+            no_parts_to_move_message = \"All parts of partition '\" + partition_id + \"' are already on disk '\" + disk->getName() + \"'\";\n+\n+        throw Exception(no_parts_to_move_message, ErrorCodes::UNKNOWN_DISK);\n     }\n \n     if (!movePartsToSpace(parts, std::static_pointer_cast<const DiskSpace::Space>(disk)))\n@@ -2758,10 +2768,28 @@ void MergeTreeData::movePartitionToVolume(const ASTPtr & partition, const String\n     if (!volume)\n         throw Exception(\"Volume \" + name + \" does not exists on policy \" + storage_policy->getName(), ErrorCodes::UNKNOWN_DISK);\n \n-    for (const auto & part : parts)\n-        for (const auto & disk : volume->disks)\n-            if (part->disk->getName() == disk->getName())\n-                throw Exception(\"Part \" + part->name + \" already on volume '\" + name + \"'\", ErrorCodes::UNKNOWN_DISK);\n+    parts.erase(std::remove_if(parts.begin(), parts.end(), [&](auto part_ptr)\n+        {\n+            for (const auto & disk : volume->disks)\n+            {\n+                if (part_ptr->disk->getName() == disk->getName())\n+                {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }), parts.end());\n+\n+    if (parts.empty())\n+    {\n+        String no_parts_to_move_message;\n+        if (moving_part)\n+            no_parts_to_move_message = \"Part '\" + partition_id + \"' is already on volume '\" + volume->getName() + \"'\";\n+        else\n+            no_parts_to_move_message = \"All parts of partition '\" + partition_id + \"' are already on volume '\" + volume->getName() + \"'\";\n+\n+        throw Exception(no_parts_to_move_message, ErrorCodes::UNKNOWN_DISK);\n+    }\n \n     if (!movePartsToSpace(parts, std::static_pointer_cast<const DiskSpace::Space>(volume)))\n         throw Exception(\"Cannot move parts because moves are manually disabled.\", ErrorCodes::ABORTED);\n",
  "test_patch": "diff --git a/dbms/tests/integration/test_multiple_disks/test.py b/dbms/tests/integration/test_multiple_disks/test.py\nindex 4ee337229c93..ed8ad699472b 100644\n--- a/dbms/tests/integration/test_multiple_disks/test.py\n+++ b/dbms/tests/integration/test_multiple_disks/test.py\n@@ -462,7 +462,7 @@ def test_alter_move(start_cluster, name, engine):\n         node1.query(\"INSERT INTO {} VALUES(toDate('2019-04-10'), 42)\".format(name))\n         node1.query(\"INSERT INTO {} VALUES(toDate('2019-04-11'), 43)\".format(name))\n         used_disks = get_used_disks_for_table(node1, name)\n-        assert all(d.startswith(\"jbod\") for d in used_disks), \"All writes shoud go to jbods\"\n+        assert all(d.startswith(\"jbod\") for d in used_disks), \"All writes should go to jbods\"\n \n         first_part = node1.query(\"SELECT name FROM system.parts WHERE table = '{}' and active = 1 ORDER BY modification_time LIMIT 1\".format(name)).strip()\n \n@@ -498,6 +498,91 @@ def test_alter_move(start_cluster, name, engine):\n     finally:\n         node1.query(\"DROP TABLE IF EXISTS {name}\".format(name=name))\n \n+\n+@pytest.mark.parametrize(\"volume_or_disk\", [\n+    \"DISK\",\n+    \"VOLUME\"\n+])\n+def test_alter_move_half_of_partition(start_cluster, volume_or_disk):\n+    name = \"alter_move_half_of_partition\"\n+    engine = \"MergeTree()\"\n+    try:\n+        node1.query(\"\"\"\n+            CREATE TABLE {name} (\n+                EventDate Date,\n+                number UInt64\n+            ) ENGINE = {engine}\n+            ORDER BY tuple()\n+            PARTITION BY toYYYYMM(EventDate)\n+            SETTINGS storage_policy='jbods_with_external'\n+        \"\"\".format(name=name, engine=engine))\n+\n+        node1.query(\"SYSTEM STOP MERGES {}\".format(name))\n+\n+        node1.query(\"INSERT INTO {} VALUES(toDate('2019-03-15'), 65)\".format(name))\n+        node1.query(\"INSERT INTO {} VALUES(toDate('2019-03-16'), 42)\".format(name))\n+        used_disks = get_used_disks_for_table(node1, name)\n+        assert all(d.startswith(\"jbod\") for d in used_disks), \"All writes should go to jbods\"\n+\n+        time.sleep(1)\n+        parts = node1.query(\"SELECT name FROM system.parts WHERE table = '{}' and active = 1\".format(name)).splitlines()\n+        assert len(parts) == 2\n+\n+        node1.query(\"ALTER TABLE {} MOVE PART '{}' TO VOLUME 'external'\".format(name, parts[0]))\n+        disks = node1.query(\"SELECT disk_name FROM system.parts WHERE table = '{}' and name = '{}' and active = 1\".format(name, parts[0])).splitlines()\n+        assert disks == [\"external\"]\n+\n+        time.sleep(1)\n+        node1.query(\"ALTER TABLE {} MOVE PARTITION 201903 TO {volume_or_disk} 'external'\".format(name, volume_or_disk=volume_or_disk))\n+        disks = node1.query(\"SELECT disk_name FROM system.parts WHERE table = '{}' and partition = '201903' and active = 1\".format(name)).splitlines()\n+        assert disks == [\"external\"]*2\n+\n+        assert node1.query(\"SELECT COUNT() FROM {}\".format(name)) == \"2\\n\"\n+\n+    finally:\n+        node1.query(\"DROP TABLE IF EXISTS {name}\".format(name=name))\n+\n+\n+@pytest.mark.parametrize(\"volume_or_disk\", [\n+    \"DISK\",\n+    \"VOLUME\"\n+])\n+def test_alter_double_move_partition(start_cluster, volume_or_disk):\n+    name = \"alter_double_move_partition\"\n+    engine = \"MergeTree()\"\n+    try:\n+        node1.query(\"\"\"\n+            CREATE TABLE {name} (\n+                EventDate Date,\n+                number UInt64\n+            ) ENGINE = {engine}\n+            ORDER BY tuple()\n+            PARTITION BY toYYYYMM(EventDate)\n+            SETTINGS storage_policy='jbods_with_external'\n+        \"\"\".format(name=name, engine=engine))\n+\n+        node1.query(\"SYSTEM STOP MERGES {}\".format(name))\n+\n+        node1.query(\"INSERT INTO {} VALUES(toDate('2019-03-15'), 65)\".format(name))\n+        node1.query(\"INSERT INTO {} VALUES(toDate('2019-03-16'), 42)\".format(name))\n+        used_disks = get_used_disks_for_table(node1, name)\n+        assert all(d.startswith(\"jbod\") for d in used_disks), \"All writes should go to jbods\"\n+\n+        time.sleep(1)\n+        node1.query(\"ALTER TABLE {} MOVE PARTITION 201903 TO {volume_or_disk} 'external'\".format(name, volume_or_disk=volume_or_disk))\n+        disks = node1.query(\"SELECT disk_name FROM system.parts WHERE table = '{}' and partition = '201903' and active = 1\".format(name)).splitlines()\n+        assert disks == [\"external\"]*2\n+\n+        assert node1.query(\"SELECT COUNT() FROM {}\".format(name)) == \"2\\n\"\n+\n+        time.sleep(1)\n+        with pytest.raises(QueryRuntimeException):\n+            node1.query(\"ALTER TABLE {} MOVE PARTITION 201903 TO {volume_or_disk} 'external'\".format(name, volume_or_disk=volume_or_disk))\n+\n+    finally:\n+        node1.query(\"DROP TABLE IF EXISTS {name}\".format(name=name))\n+\n+\n def produce_alter_move(node, name):\n     move_type = random.choice([\"PART\", \"PARTITION\"])\n     if move_type == \"PART\":\n",
  "problem_statement": "MOVE PARTITION tries to move parts to the same disk where they already belong\n@filimonov:\r\n> ```\r\n> alter table test move partition tuple() TO volume 'default';\r\n> \r\n> ALTER TABLE test\r\n>     MOVE PARTITION tuple() TO VOLUME 'default'\r\n> \r\n> \r\n> Ok.\r\n> \r\n> 0 rows in set. Elapsed: 148.339 sec.\r\n> \r\n> ip-172-31-47-236.eu-central-1.compute.internal :) select database, table, disk_name,formatReadableSize(sum(bytes_on_disk)) from system.parts group by database, table, disk_name;\r\n> \r\n> SELECT \r\n>     database, \r\n>     table, \r\n>     disk_name, \r\n>     formatReadableSize(sum(bytes_on_disk))\r\n> FROM system.parts\r\n> GROUP BY \r\n>     database, \r\n>     table, \r\n>     disk_name\r\n> \r\n> \u250c\u2500database\u2500\u252c\u2500table\u2500\u2500\u2500\u2500\u2500\u252c\u2500disk_name\u2500\u252c\u2500formatReadableSize(sum(bytes_on_disk))\u2500\u2510\r\n> \u2502 default  \u2502 test      \u2502 default   \u2502 13.32 GiB                              \u2502\r\n> \u2502 system   \u2502 trace_log \u2502 default   \u2502 9.87 KiB                               \u2502\r\n> \u2502 default  \u2502 test      \u2502 ephemeral \u2502 8.39 GiB                               \u2502\r\n> \u2502 system   \u2502 part_log  \u2502 default   \u2502 48.35 KiB                              \u2502\r\n> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n> \r\n> alter table test move partition tuple() TO volume 'default';\r\n> \r\n> ALTER TABLE test\r\n>     MOVE PARTITION tuple() TO VOLUME 'default'\r\n> \r\n> \r\n> Received exception from server (version 19.15.3):\r\n> Code: 479. DB::Exception: Received from localhost:9000. DB::Exception: Part all_601_792_3_955 already on volume 'default'. \r\n> \r\n> 0 rows in set. Elapsed: 0.041 sec. \r\n> ```\r\n> \r\n> Why not moved?\r\n\r\n\n",
  "hints_text": "",
  "created_at": "2019-10-22T14:46:15Z",
  "modified_files": [
    "dbms/src/Storages/MergeTree/MergeTreeData.cpp"
  ],
  "modified_test_files": [
    "dbms/tests/integration/test_multiple_disks/test.py"
  ]
}