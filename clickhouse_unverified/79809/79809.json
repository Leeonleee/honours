{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 79809,
  "instance_id": "ClickHouse__ClickHouse-79809",
  "issue_numbers": [
    "15498"
  ],
  "base_commit": "7cc632455c55bd4e6cd6e1c8ae08a6b2a4ea5b47",
  "patch": "diff --git a/docs/en/sql-reference/functions/string-functions.md b/docs/en/sql-reference/functions/string-functions.md\nindex 9d3567111e6d..a58dc968b7d4 100644\n--- a/docs/en/sql-reference/functions/string-functions.md\n+++ b/docs/en/sql-reference/functions/string-functions.md\n@@ -1140,6 +1140,102 @@ Returns string `s` converted from the encoding `from` to encoding `to`.\n convertCharset(s, from, to)\n ```\n \n+## base32Encode {#base32encode}\n+\n+Encodes a string using [Base32](https://datatracker.ietf.org/doc/html/rfc4648#section-6).\n+\n+**Syntax**\n+\n+```sql\n+base32Encode(plaintext)\n+```\n+\n+**Arguments**\n+\n+- `plaintext` \u2014 [String](../data-types/string.md) column or constant.\n+\n+**Returned value**\n+\n+- A string containing the encoded value of the argument. [String](../data-types/string.md) or [FixedString](../data-types/fixedstring.md).\n+\n+**Example**\n+\n+```sql\n+SELECT base32Encode('Encoded');\n+```\n+\n+Result:\n+\n+```result\n+\u250c\u2500base32Encode('Encoded')\u2500\u2510\n+\u2502 IVXGG33EMVSA====        \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## base32Decode {#base32decode}\n+\n+Accepts a string and decodes it using [Base32](https://datatracker.ietf.org/doc/html/rfc4648#section-6) encoding scheme.\n+\n+**Syntax**\n+\n+```sql\n+base32Decode(encoded)\n+```\n+\n+**Arguments**\n+\n+- `encoded` \u2014 [String](../data-types/string.md) or [FixedString](../data-types/fixedstring.md). If the string is not a valid Base32-encoded value, an exception is thrown.\n+\n+**Returned value**\n+\n+- A string containing the decoded value of the argument. [String](../data-types/string.md).\n+\n+**Example**\n+\n+```sql\n+SELECT base32Decode('IVXGG33EMVSA====');\n+```\n+\n+Result:\n+\n+```result\n+\u250c\u2500base32Decode('IVXGG33EMVSA====')\u2500\u2510\n+\u2502 Encoded                          \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## tryBase32Decode {#trybase32decode}\n+\n+Like `base32Decode` but returns an empty string in case of error.\n+\n+**Syntax**\n+\n+```sql\n+tryBase32Decode(encoded)\n+```\n+\n+**Parameters**\n+\n+- `encoded`: [String](../data-types/string.md) or [FixedString](../data-types/fixedstring.md). If the string is not a valid Base32-encoded value, returns an empty string in case of error.\n+\n+**Returned value**\n+\n+- A string containing the decoded value of the argument.\n+\n+**Examples**\n+\n+Query:\n+\n+```sql\n+SELECT tryBase32Decode('IVXGG33EMVSA====') as res, tryBase32Decode('invalid') as res_invalid;\n+```\n+\n+```response\n+\u250c\u2500res\u2500\u2500\u2500\u2500\u2500\u252c\u2500res_invalid\u2500\u2510\n+\u2502 Encoded \u2502             \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## base58Encode {#base58encode}\n \n Encodes a string using [Base58](https://datatracker.ietf.org/doc/html/draft-msporny-base58) in the \"Bitcoin\" alphabet.\ndiff --git a/src/Common/Base32.h b/src/Common/Base32.h\nnew file mode 100644\nindex 000000000000..1abb8eb2613f\n--- /dev/null\n+++ b/src/Common/Base32.h\n@@ -0,0 +1,155 @@\n+#pragma once\n+\n+#include <optional>\n+#include <base/types.h>\n+#include \"base/defines.h\"\n+\n+namespace DB\n+{\n+\n+struct Base32Rfc4648\n+{\n+    static constexpr char encodeChar(UInt8 c)\n+    {\n+        chassert(c < 32);\n+        if (c < 26)\n+            return 'A' + c;\n+        return '2' + (c - 26);\n+    }\n+    static constexpr UInt8 decodeChar(UInt8 c)\n+    {\n+        if (c >= 'A' && c <= 'Z')\n+            return c - 'A';\n+\n+        // Handle lowercase letters the same as uppercase\n+        if (c >= 'a' && c <= 'z')\n+            return c - 'a';\n+\n+        if (c >= '2' && c <= '7')\n+            return (c - '2') + 26;\n+\n+        return 0xFF;\n+    }\n+    static constexpr Int8 padding_char = '=';\n+};\n+\n+template <typename Traits, typename Tag>\n+struct Base32;\n+\n+struct Base32NaiveTag;\n+\n+template <typename Traits>\n+struct Base32<Traits, Base32NaiveTag>\n+{\n+    static size_t encodeBase32(const UInt8 * src, size_t src_length, UInt8 * dst)\n+    {\n+        //  in:      [01010101] [11001100] [11110000]\n+\n+        // out:      01010 | 11100 | 11001 | 11100 | 000\n+        //           [ 5b ]  [ 5b ]  [ 5b ]  [ 5b ] ...\n+\n+        size_t ipos = 0;\n+        size_t opos = 0;\n+        uint32_t buffer = 0;\n+        uint8_t bits_left = 0;\n+\n+        while (ipos < src_length)\n+        {\n+            buffer = (buffer << 8) | src[ipos++];\n+            bits_left += 8;\n+\n+            while (bits_left >= 5)\n+            {\n+                dst[opos++] = Traits::encodeChar((buffer >> (bits_left - 5)) & 0x1F);\n+                bits_left -= 5;\n+            }\n+        }\n+\n+        if (bits_left > 0)\n+        {\n+            dst[opos++] = Traits::encodeChar((buffer << (5 - bits_left)) & 0x1F);\n+        }\n+\n+        while (opos % 8 != 0)\n+        {\n+            dst[opos++] = Traits::padding_char;\n+        }\n+\n+        return opos;\n+    }\n+\n+    /// This function might write into dst even if decoding fails (nullopt returned)\n+    static std::optional<size_t> decodeBase32(const UInt8 * src, size_t src_length, UInt8 * dst)\n+    {\n+        if (src_length % 8 != 0)\n+        {\n+            return std::nullopt;\n+        }\n+\n+        size_t dst_pos = 0;\n+        size_t buffer = 0;\n+        int bits = 0;\n+        size_t pad_count = 0;\n+        bool padding_started = false;\n+\n+        for (size_t i = 0; i < src_length; ++i)\n+        {\n+            UInt8 c = src[i];\n+\n+            if (c == Traits::padding_char)\n+            {\n+                padding_started = true;\n+                pad_count++;\n+                continue;\n+            }\n+\n+            if (padding_started)\n+            {\n+                return std::nullopt; // Only padding was expected\n+            }\n+\n+            UInt8 value = Traits::decodeChar(c);\n+            if (value == 0xFF)\n+            {\n+                return std::nullopt; // Invalid symbol\n+            }\n+\n+            // Stuff in decoded bits, write out if there's enough\n+            buffer = (buffer << 5) | value;\n+            bits += 5;\n+\n+            if (bits >= 8)\n+            {\n+                bits -= 8;\n+                dst[dst_pos++] = (buffer >> bits) & 0xFF;\n+            }\n+        }\n+\n+        if (pad_count > 0)\n+        {\n+            if (!(pad_count == 1 || pad_count == 3 || pad_count == 4 || pad_count == 6))\n+            {\n+                return std::nullopt;\n+            }\n+\n+            if (bits > 0 && (buffer & ((1 << bits) - 1)) != 0)\n+            {\n+                return std::nullopt;\n+            }\n+        }\n+\n+        return dst_pos;\n+    }\n+};\n+\n+inline size_t encodeBase32(const UInt8 * src, size_t src_length, UInt8 * dst)\n+{\n+    return Base32<Base32Rfc4648, Base32NaiveTag>::encodeBase32(src, src_length, dst);\n+}\n+\n+inline std::optional<size_t> decodeBase32(const UInt8 * src, size_t src_length, UInt8 * dst)\n+{\n+    return Base32<Base32Rfc4648, Base32NaiveTag>::decodeBase32(src, src_length, dst);\n+}\n+\n+}\ndiff --git a/src/Functions/FunctionBase32Conversion.h b/src/Functions/FunctionBase32Conversion.h\nnew file mode 100644\nindex 000000000000..c30b9d976d6a\n--- /dev/null\n+++ b/src/Functions/FunctionBase32Conversion.h\n@@ -0,0 +1,45 @@\n+#pragma once\n+\n+#include <Functions/FunctionBaseXXConversion.h>\n+\n+#include <Common/Base32.h>\n+\n+namespace DB\n+{\n+struct Base32EncodeTraits\n+{\n+    template <typename Col>\n+    static size_t getBufferSize(Col const & src_column)\n+    {\n+        auto const src_length = src_column.getChars().size();\n+        auto const string_count = src_column.size();\n+        /// Every 5 bytes becomes 8 bytes in base32\n+        /// Add padding for incomplete blocks and round up\n+        /// Plus one byte for null terminator for each string\n+        return ((src_length + 4) / 5 * 8 + 1) * string_count;\n+    }\n+\n+    static size_t perform(std::string_view src, UInt8 * dst)\n+    {\n+        return encodeBase32(reinterpret_cast<const UInt8 *>(src.data()), src.size(), dst);\n+    }\n+};\n+\n+struct Base32DecodeTraits\n+{\n+    template <typename Col>\n+    static size_t getBufferSize(Col const & src_column)\n+    {\n+        auto const string_length = src_column.byteSize();\n+        auto const string_count = src_column.size();\n+        /// decoded size is at most length of encoded (every 8 bytes becomes at most 5 bytes)\n+        /// plus one byte for null terminator for each string\n+        return ((string_length * 5 + 7) / 8 + 1) * string_count;\n+    }\n+\n+    static std::optional<size_t> perform(std::string_view src, UInt8 * dst)\n+    {\n+        return decodeBase32(reinterpret_cast<const UInt8 *>(src.data()), src.size(), dst);\n+    }\n+};\n+}\ndiff --git a/src/Functions/FunctionBase58Conversion.h b/src/Functions/FunctionBase58Conversion.h\nindex 655db8b63a22..3b77bbe213ee 100644\n--- a/src/Functions/FunctionBase58Conversion.h\n+++ b/src/Functions/FunctionBase58Conversion.h\n@@ -1,242 +1,44 @@\n #pragma once\n \n-#include <cstring>\n-#include <base/MemorySanitizer.h>\n-#include <Columns/ColumnConst.h>\n-#include <Columns/ColumnFixedString.h>\n-#include <Columns/ColumnString.h>\n-#include <DataTypes/DataTypeString.h>\n-#include <Functions/FunctionFactory.h>\n-#include <Functions/FunctionHelpers.h>\n-#include <IO/WriteHelpers.h>\n-#include <Common/Base58.h>\n+#include <Functions/FunctionBaseXXConversion.h>\n \n+#include <Common/Base58.h>\n \n namespace DB\n {\n-\n-namespace ErrorCodes\n-{\n-    extern const int ILLEGAL_COLUMN;\n-    extern const int BAD_ARGUMENTS;\n-}\n-\n-struct Base58Encode\n+struct Base58EncodeTraits\n {\n-    static constexpr auto name = \"base58Encode\";\n-\n-    static void processString(const ColumnString & src_column, ColumnString::MutablePtr & dst_column, size_t input_rows_count)\n+    template <typename Col>\n+    static size_t getBufferSize(Col const & src_column)\n     {\n-        auto & dst_data = dst_column->getChars();\n-        auto & dst_offsets = dst_column->getOffsets();\n-\n+        auto const src_length = src_column.getChars().size();\n         /// Base58 has efficiency of 73% (8/11) [https://monerodocs.org/cryptography/base58/],\n         /// and we take double scale to avoid any reallocation.\n-        size_t max_result_size = static_cast<size_t>(ceil(2 * src_column.getChars().size() + 1));\n-\n-        dst_data.resize(max_result_size);\n-        dst_offsets.resize(input_rows_count);\n-\n-        const ColumnString::Offsets & src_offsets = src_column.getOffsets();\n-\n-        const auto * src = src_column.getChars().data();\n-        auto * dst = dst_data.data();\n-\n-        size_t prev_src_offset = 0;\n-        size_t current_dst_offset = 0;\n-\n-        for (size_t row = 0; row < input_rows_count; ++row)\n-        {\n-            size_t current_src_offset = src_offsets[row];\n-            size_t src_length = current_src_offset - prev_src_offset - 1;\n-            size_t encoded_size = encodeBase58(&src[prev_src_offset], src_length, &dst[current_dst_offset]);\n-            prev_src_offset = current_src_offset;\n-            current_dst_offset += encoded_size;\n-            dst[current_dst_offset] = 0;\n-            ++current_dst_offset;\n-\n-            dst_offsets[row] = current_dst_offset;\n-        }\n-\n-        dst_data.resize(current_dst_offset);\n+        constexpr auto oversize = 2;\n+        return static_cast<size_t>(ceil(oversize * src_length + 1));\n     }\n \n-    static void processFixedString(const ColumnFixedString & src_column, ColumnString::MutablePtr & dst_column, size_t input_rows_count)\n+    static size_t perform(std::string_view src, UInt8 * dst)\n     {\n-        auto & dst_data = dst_column->getChars();\n-        auto & dst_offsets = dst_column->getOffsets();\n-\n-        /// Base58 has efficiency of 73% (8/11) [https://monerodocs.org/cryptography/base58/],\n-        /// and we take double scale to avoid any reallocation.\n-        size_t max_result_size = static_cast<size_t>(ceil(2 * src_column.getChars().size() + 1));\n-\n-        dst_data.resize(max_result_size);\n-        dst_offsets.resize(input_rows_count);\n-\n-        const auto * src = src_column.getChars().data();\n-        auto * dst = dst_data.data();\n-\n-        size_t N = src_column.getN();\n-        size_t current_dst_offset = 0;\n-\n-        for (size_t row = 0; row < input_rows_count; ++row)\n-        {\n-            size_t encoded_size = encodeBase58(&src[row * N], N, &dst[current_dst_offset]);\n-            current_dst_offset += encoded_size;\n-            dst[current_dst_offset] = 0;\n-            ++current_dst_offset;\n-\n-            dst_offsets[row] = current_dst_offset;\n-        }\n-\n-        dst_data.resize(current_dst_offset);\n+        return encodeBase58(reinterpret_cast<const UInt8 *>(src.data()), src.size(), dst);\n     }\n };\n \n-enum class Base58DecodeErrorHandling : uint8_t\n+struct Base58DecodeTraits\n {\n-    ThrowException,\n-    ReturnEmptyString\n-};\n-\n-template <typename Name, Base58DecodeErrorHandling ErrorHandling>\n-struct Base58Decode\n-{\n-    static constexpr auto name = Name::name;\n-\n-    static void processString(const ColumnString & src_column, ColumnString::MutablePtr & dst_column, size_t input_rows_count)\n+    template <typename Col>\n+    static size_t getBufferSize(Col const & src_column)\n     {\n-        auto & dst_data = dst_column->getChars();\n-        auto & dst_offsets = dst_column->getOffsets();\n-\n-        /// Base58 has efficiency of 73% (8/11) [https://monerodocs.org/cryptography/base58/],\n-        /// and decoded value will be no longer than source.\n-        size_t max_result_size = src_column.getChars().size() + 1;\n-\n-        dst_data.resize(max_result_size);\n-        dst_offsets.resize(input_rows_count);\n-\n-        const ColumnString::Offsets & src_offsets = src_column.getOffsets();\n-\n-        const auto * src = src_column.getChars().data();\n-        auto * dst = dst_data.data();\n-\n-        size_t prev_src_offset = 0;\n-        size_t current_dst_offset = 0;\n-\n-        for (size_t row = 0; row < input_rows_count; ++row)\n-        {\n-            size_t current_src_offset = src_offsets[row];\n-            size_t src_length = current_src_offset - prev_src_offset - 1;\n-            std::optional<size_t> decoded_size = decodeBase58(&src[prev_src_offset], src_length, &dst[current_dst_offset]);\n-            if (!decoded_size)\n-            {\n-                if constexpr (ErrorHandling == Base58DecodeErrorHandling::ThrowException)\n-                    throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Invalid Base58 value, cannot be decoded\");\n-                else\n-                    decoded_size = 0;\n-            }\n-\n-            prev_src_offset = current_src_offset;\n-            current_dst_offset += *decoded_size;\n-            dst[current_dst_offset] = 0;\n-            ++current_dst_offset;\n-\n-            dst_offsets[row] = current_dst_offset;\n-        }\n-\n-        dst_data.resize(current_dst_offset);\n+        auto const string_length = src_column.byteSize();\n+        auto const string_count = src_column.size();\n+        /// decoded size is at most length of encoded (every 8 bytes becomes at most 6 bytes)\n+        /// plus one byte for null terminator for each string\n+        return ((string_length * 6 + 7) / 8 + 1) * string_count;\n     }\n \n-    static void processFixedString(const ColumnFixedString & src_column, ColumnString::MutablePtr & dst_column, size_t input_rows_count)\n+    static std::optional<size_t> perform(std::string_view src, UInt8 * dst)\n     {\n-        auto & dst_data = dst_column->getChars();\n-        auto & dst_offsets = dst_column->getOffsets();\n-\n-        /// Base58 has efficiency of 73% (8/11) [https://monerodocs.org/cryptography/base58/],\n-        /// and decoded value will be no longer than source.\n-        size_t max_result_size = src_column.getChars().size() + 1;\n-\n-        dst_data.resize(max_result_size);\n-        dst_offsets.resize(input_rows_count);\n-\n-        const auto * src = src_column.getChars().data();\n-        auto * dst = dst_data.data();\n-\n-        size_t N = src_column.getN();\n-        size_t current_dst_offset = 0;\n-\n-        for (size_t row = 0; row < input_rows_count; ++row)\n-        {\n-            std::optional<size_t> decoded_size = decodeBase58(&src[row * N], N, &dst[current_dst_offset]);\n-            if (!decoded_size)\n-            {\n-                if constexpr (ErrorHandling == Base58DecodeErrorHandling::ThrowException)\n-                    throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Invalid Base58 value, cannot be decoded\");\n-                else\n-                    decoded_size = 0;\n-            }\n-\n-            current_dst_offset += *decoded_size;\n-            dst[current_dst_offset] = 0;\n-            ++current_dst_offset;\n-\n-            dst_offsets[row] = current_dst_offset;\n-        }\n-\n-        dst_data.resize(current_dst_offset);\n-    }\n-};\n-\n-template <typename Func>\n-class FunctionBase58Conversion : public IFunction\n-{\n-public:\n-    static constexpr auto name = Func::name;\n-\n-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionBase58Conversion>(); }\n-    String getName() const override { return Func::name; }\n-    size_t getNumberOfArguments() const override { return 1; }\n-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n-    bool useDefaultImplementationForConstants() const override { return true; }\n-    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n-\n-    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n-    {\n-        FunctionArgumentDescriptors args{\n-            {\"arg\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isStringOrFixedString), nullptr, \"String or FixedString\"}\n-        };\n-        validateFunctionArguments(*this, arguments, args);\n-\n-        return std::make_shared<DataTypeString>();\n-    }\n-\n-    DataTypePtr getReturnTypeForDefaultImplementationForDynamic() const override\n-    {\n-        return std::make_shared<DataTypeString>();\n-    }\n-\n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n-    {\n-        const ColumnPtr col = arguments[0].column;\n-\n-        if (const ColumnString * col_string = checkAndGetColumn<ColumnString>(col.get()))\n-        {\n-            auto col_res = ColumnString::create();\n-            Func::processString(*col_string, col_res, input_rows_count);\n-            return col_res;\n-        }\n-        else if (const ColumnFixedString * col_fixed_string = checkAndGetColumn<ColumnFixedString>(col.get()))\n-        {\n-            auto col_res = ColumnString::create();\n-            Func::processFixedString(*col_fixed_string, col_res, input_rows_count);\n-            return col_res;\n-        }\n-\n-        throw Exception(\n-            ErrorCodes::ILLEGAL_COLUMN,\n-            \"Illegal column {} of first argument of function {}, must be String or FixedString\",\n-            arguments[0].column->getName(), getName());\n+        return decodeBase58(reinterpret_cast<const UInt8 *>(src.data()), src.size(), dst);\n     }\n };\n }\ndiff --git a/src/Functions/FunctionBase64Conversion.h b/src/Functions/FunctionBase64Conversion.h\nindex ed007250e541..38e4025c9250 100644\n--- a/src/Functions/FunctionBase64Conversion.h\n+++ b/src/Functions/FunctionBase64Conversion.h\n@@ -6,8 +6,7 @@\n #    include <Columns/ColumnFixedString.h>\n #    include <Columns/ColumnString.h>\n #    include <DataTypes/DataTypeString.h>\n-#    include <Functions/FunctionHelpers.h>\n-#    include <Functions/IFunction.h>\n+#    include <Functions/FunctionBaseXXConversion.h>\n #    include <Interpreters/Context_fwd.h>\n #    include <libbase64.h>\n \n@@ -16,11 +15,6 @@\n \n namespace DB\n {\n-namespace ErrorCodes\n-{\n-    extern const int ILLEGAL_COLUMN;\n-    extern const int INCORRECT_DATA;\n-}\n \n enum class Base64Variant : uint8_t\n {\n@@ -92,13 +86,15 @@ inline size_t postprocessBase64URL(UInt8 * dst, size_t out_len)\n     return out_len;\n }\n \n-template <Base64Variant variant>\n-struct Base64Encode\n-{\n-    static constexpr auto name = (variant == Base64Variant::Normal) ? \"base64Encode\" : \"base64URLEncode\";\n \n-    static size_t getBufferSize(size_t string_length, size_t string_count)\n+template<Base64Variant variant>\n+struct Base64EncodeTraits\n+{\n+    template<typename Col>\n+    static size_t getBufferSize(Col const& src_column)\n     {\n+        auto const string_length = src_column.byteSize();\n+        auto const string_count = src_column.size();\n         return ((string_length - string_count) / 3 + string_count) * 4 + string_count;\n     }\n \n@@ -118,52 +114,18 @@ struct Base64Encode\n     }\n };\n \n-template <Base64Variant variant>\n-struct Base64Decode\n+template<Base64Variant variant>\n+struct Base64DecodeTraits\n {\n-    static constexpr auto name = (variant == Base64Variant::Normal) ? \"base64Decode\" : \"base64URLDecode\";\n-\n-    static size_t getBufferSize(size_t string_length, size_t string_count)\n+    template<typename Col>\n+    static size_t getBufferSize(Col const& src_column)\n     {\n+        auto const string_length = src_column.byteSize();\n+        auto const string_count = src_column.size();\n         return ((string_length - string_count) / 4 + string_count) * 3 + string_count;\n     }\n \n-    static size_t perform(std::string_view src, UInt8 * dst)\n-    {\n-        int rc;\n-        size_t outlen = 0;\n-        if constexpr (variant == Base64Variant::URL)\n-        {\n-            std::string src_padded = preprocessBase64URL(src);\n-            rc = base64_decode(src_padded.data(), src_padded.size(), reinterpret_cast<char *>(dst), &outlen, 0);\n-        }\n-        else\n-        {\n-            rc = base64_decode(src.data(), src.size(), reinterpret_cast<char *>(dst), &outlen, 0);\n-        }\n-\n-        if (rc != 1)\n-            throw Exception(\n-                ErrorCodes::INCORRECT_DATA,\n-                \"Failed to {} input '{}'\",\n-                name,\n-                String(reinterpret_cast<const char *>(src.data()), src.size()));\n-\n-        return outlen;\n-    }\n-};\n-\n-template <Base64Variant variant>\n-struct TryBase64Decode\n-{\n-    static constexpr auto name = (variant == Base64Variant::Normal) ? \"tryBase64Decode\" : \"tryBase64URLDecode\";\n-\n-    static size_t getBufferSize(size_t string_length, size_t string_count)\n-    {\n-        return Base64Decode<variant>::getBufferSize(string_length, string_count);\n-    }\n-\n-    static size_t perform(std::string_view src, UInt8 * dst)\n+    static std::optional<size_t> perform(std::string_view src, UInt8 * dst)\n     {\n         int rc;\n         size_t outlen = 0;\n@@ -176,128 +138,12 @@ struct TryBase64Decode\n         {\n             rc = base64_decode(src.data(), src.size(), reinterpret_cast<char *>(dst), &outlen, 0);\n         }\n-\n-        if (rc != 1)\n-            outlen = 0;\n-\n+        if (rc != 1) [[unlikely]]\n+            return std::nullopt;\n         return outlen;\n     }\n };\n \n-template <typename Func>\n-class FunctionBase64Conversion : public IFunction\n-{\n-public:\n-    static constexpr auto name = Func::name;\n-\n-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionBase64Conversion>(); }\n-    String getName() const override { return Func::name; }\n-    size_t getNumberOfArguments() const override { return 1; }\n-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n-    bool useDefaultImplementationForConstants() const override { return true; }\n-\n-    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n-    {\n-        FunctionArgumentDescriptors mandatory_arguments{\n-            {\"value\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isStringOrFixedString), nullptr, \"String or FixedString\"}\n-        };\n-\n-        validateFunctionArguments(*this, arguments, mandatory_arguments);\n-\n-        return std::make_shared<DataTypeString>();\n-    }\n-\n-    DataTypePtr getReturnTypeForDefaultImplementationForDynamic() const override\n-    {\n-        return std::make_shared<DataTypeString>();\n-    }\n-\n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n-    {\n-        const auto & input_column = arguments[0].column;\n-        if (const auto * src_column_as_fixed_string = checkAndGetColumn<ColumnFixedString>(&*input_column))\n-            return execute(*src_column_as_fixed_string, input_rows_count);\n-        if (const auto * src_column_as_string = checkAndGetColumn<ColumnString>(&*input_column))\n-            return execute(*src_column_as_string, input_rows_count);\n-\n-        throw Exception(\n-            ErrorCodes::ILLEGAL_COLUMN,\n-            \"Illegal column {} of first argument of function {}, must be of type FixedString or String.\",\n-            input_column->getName(),\n-            getName());\n-    }\n-\n-private:\n-    static ColumnPtr execute(const ColumnString & src_column, size_t src_row_count)\n-    {\n-        auto dst_column = ColumnString::create();\n-        auto & dst_chars = dst_column->getChars();\n-        auto & dst_offsets = dst_column->getOffsets();\n-\n-        const auto reserve = Func::getBufferSize(src_column.byteSize(), src_column.size());\n-        dst_chars.resize(reserve);\n-        dst_offsets.resize(src_row_count);\n-\n-        const auto & src_chars = src_column.getChars();\n-        const auto & src_offsets = src_column.getOffsets();\n-\n-        auto * dst = dst_chars.data();\n-        auto * dst_pos = dst;\n-        const auto * src = reinterpret_cast<const char *>(src_chars.data());\n-\n-        size_t src_offset_prev = 0;\n-        for (size_t row = 0; row < src_row_count; ++row)\n-        {\n-            const size_t src_length = src_offsets[row] - src_offset_prev - 1;\n-            const size_t outlen = Func::perform({src, src_length}, dst_pos);\n-\n-            src += src_length + 1;\n-            dst_pos += outlen;\n-            *dst_pos = '\\0';\n-            dst_pos += 1;\n-\n-            dst_offsets[row] = dst_pos - dst;\n-            src_offset_prev = src_offsets[row];\n-        }\n-\n-        dst_chars.resize(dst_pos - dst);\n-        return dst_column;\n-    }\n-\n-    static ColumnPtr execute(const ColumnFixedString & src_column, size_t src_row_count)\n-    {\n-        auto dst_column = ColumnString::create();\n-        auto & dst_chars = dst_column->getChars();\n-        auto & dst_offsets = dst_column->getOffsets();\n-\n-        const auto reserve = Func::getBufferSize(src_column.byteSize(), src_column.size());\n-        dst_chars.resize(reserve);\n-        dst_offsets.resize(src_row_count);\n-\n-        const auto & src_chars = src_column.getChars();\n-        const auto & src_n = src_column.getN();\n-\n-        auto * dst = dst_chars.data();\n-        auto * dst_pos = dst;\n-        const auto * src = reinterpret_cast<const char *>(src_chars.data());\n-\n-        for (size_t row = 0; row < src_row_count; ++row)\n-        {\n-            const auto outlen = Func::perform({src, src_n}, dst_pos);\n-\n-            src += src_n;\n-            dst_pos += outlen;\n-            *dst_pos = '\\0';\n-            dst_pos += 1;\n-\n-            dst_offsets[row] = dst_pos - dst;\n-        }\n-\n-        dst_chars.resize(dst_pos - dst);\n-        return dst_column;\n-    }\n-};\n-\n }\n \n #endif\ndiff --git a/src/Functions/FunctionBaseXXConversion.h b/src/Functions/FunctionBaseXXConversion.h\nnew file mode 100644\nindex 000000000000..b5b3ac43d04f\n--- /dev/null\n+++ b/src/Functions/FunctionBaseXXConversion.h\n@@ -0,0 +1,230 @@\n+#pragma once\n+\n+#include <Columns/ColumnConst.h>\n+#include <Columns/ColumnFixedString.h>\n+#include <Columns/ColumnString.h>\n+#include <DataTypes/DataTypeString.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <IO/WriteHelpers.h>\n+#include <fmt/format.h>\n+#include <Common/Base58.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+extern const int ILLEGAL_COLUMN;\n+extern const int INCORRECT_DATA;\n+}\n+\n+template <typename Traits, typename Name>\n+struct BaseXXEncode\n+{\n+    static constexpr auto name = Name::name;\n+\n+    static void processString(const ColumnString & src_column, ColumnString::MutablePtr & dst_column, size_t input_rows_count)\n+    {\n+        auto & dst_data = dst_column->getChars();\n+        auto & dst_offsets = dst_column->getOffsets();\n+        size_t const max_result_size = Traits::getBufferSize(src_column);\n+\n+        dst_data.resize(max_result_size);\n+        dst_offsets.resize(input_rows_count);\n+\n+        const ColumnString::Offsets & src_offsets = src_column.getOffsets();\n+\n+        const auto * src = reinterpret_cast<const char *>(src_column.getChars().data());\n+        auto * dst = dst_data.data();\n+\n+        size_t prev_src_offset = 0;\n+        size_t current_dst_offset = 0;\n+\n+        for (size_t row = 0; row < input_rows_count; ++row)\n+        {\n+            size_t current_src_offset = src_offsets[row];\n+            size_t src_length = current_src_offset - prev_src_offset - 1;\n+            size_t encoded_size = Traits::perform({&src[prev_src_offset], src_length}, &dst[current_dst_offset]);\n+            prev_src_offset = current_src_offset;\n+            current_dst_offset += encoded_size;\n+            dst[current_dst_offset] = '\\0';\n+            ++current_dst_offset;\n+\n+            dst_offsets[row] = current_dst_offset;\n+        }\n+\n+        dst_data.resize(current_dst_offset);\n+    }\n+\n+    static void processFixedString(const ColumnFixedString & src_column, ColumnString::MutablePtr & dst_column, size_t input_rows_count)\n+    {\n+        auto & dst_data = dst_column->getChars();\n+        auto & dst_offsets = dst_column->getOffsets();\n+        size_t const max_result_size = Traits::getBufferSize(src_column);\n+\n+        dst_data.resize(max_result_size);\n+        dst_offsets.resize(input_rows_count);\n+\n+        const auto * src = reinterpret_cast<const char *>(src_column.getChars().data());\n+        auto * dst = dst_data.data();\n+\n+        size_t const N = src_column.getN();\n+        size_t current_dst_offset = 0;\n+\n+        for (size_t row = 0; row < input_rows_count; ++row)\n+        {\n+            size_t encoded_size = Traits::perform({&src[row * N], N}, &dst[current_dst_offset]);\n+            current_dst_offset += encoded_size;\n+            dst[current_dst_offset] = 0;\n+            ++current_dst_offset;\n+\n+            dst_offsets[row] = current_dst_offset;\n+        }\n+\n+        dst_data.resize(current_dst_offset);\n+    }\n+};\n+\n+enum class BaseXXDecodeErrorHandling : uint8_t\n+{\n+    ThrowException,\n+    ReturnEmptyString\n+};\n+\n+template <typename Traits, typename Name, BaseXXDecodeErrorHandling ErrorHandling>\n+struct BaseXXDecode\n+{\n+    static constexpr auto name = Name::name;\n+\n+    static void processString(const ColumnString & src_column, ColumnString::MutablePtr & dst_column, size_t input_rows_count)\n+    {\n+        auto & dst_data = dst_column->getChars();\n+        auto & dst_offsets = dst_column->getOffsets();\n+        size_t max_result_size = Traits::getBufferSize(src_column);\n+\n+        dst_data.resize(max_result_size);\n+        dst_offsets.resize(input_rows_count);\n+\n+        const ColumnString::Offsets & src_offsets = src_column.getOffsets();\n+\n+        const auto * src = reinterpret_cast<const char *>(src_column.getChars().data());\n+        auto * dst = dst_data.data();\n+\n+        size_t prev_src_offset = 0;\n+        size_t current_dst_offset = 0;\n+\n+        for (size_t row = 0; row < input_rows_count; ++row)\n+        {\n+            size_t current_src_offset = src_offsets[row];\n+            size_t src_length = current_src_offset - prev_src_offset - 1;\n+            std::optional<size_t> decoded_size = Traits::perform({&src[prev_src_offset], src_length}, &dst[current_dst_offset]);\n+            if (!decoded_size)\n+            {\n+                if constexpr (ErrorHandling == BaseXXDecodeErrorHandling::ThrowException)\n+                    throw Exception(\n+                        ErrorCodes::INCORRECT_DATA,\n+                        \"Invalid {} value ({}), cannot be decoded\",\n+                        name,\n+                        String(&src[prev_src_offset], src_length));\n+                else\n+                    decoded_size = 0;\n+            }\n+\n+            prev_src_offset = current_src_offset;\n+            current_dst_offset += *decoded_size;\n+            dst[current_dst_offset] = '\\0';\n+            ++current_dst_offset;\n+\n+            dst_offsets[row] = current_dst_offset;\n+        }\n+\n+        dst_data.resize(current_dst_offset);\n+    }\n+\n+    static void processFixedString(const ColumnFixedString & src_column, ColumnString::MutablePtr & dst_column, size_t input_rows_count)\n+    {\n+        auto & dst_data = dst_column->getChars();\n+        auto & dst_offsets = dst_column->getOffsets();\n+        size_t max_result_size = Traits::getBufferSize(src_column);\n+\n+        dst_data.resize(max_result_size);\n+        dst_offsets.resize(input_rows_count);\n+\n+        const auto * src = reinterpret_cast<const char *>(src_column.getChars().data());\n+        auto * dst = dst_data.data();\n+\n+        size_t N = src_column.getN();\n+        size_t current_dst_offset = 0;\n+\n+        for (size_t row = 0; row < input_rows_count; ++row)\n+        {\n+            std::optional<size_t> decoded_size = Traits::perform({&src[row * N], N}, &dst[current_dst_offset]);\n+            if (!decoded_size)\n+            {\n+                if constexpr (ErrorHandling == BaseXXDecodeErrorHandling::ThrowException)\n+                    throw Exception(ErrorCodes::INCORRECT_DATA, \"Invalid {} value ({}), cannot be decoded\", name, String(&src[row * N], N));\n+                else\n+                    decoded_size = 0;\n+            }\n+\n+            current_dst_offset += *decoded_size;\n+            dst[current_dst_offset] = '\\0';\n+            ++current_dst_offset;\n+\n+            dst_offsets[row] = current_dst_offset;\n+        }\n+\n+        dst_data.resize(current_dst_offset);\n+    }\n+};\n+\n+template <typename Func>\n+class FunctionBaseXXConversion : public IFunction\n+{\n+public:\n+    static constexpr auto name = Func::name;\n+\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionBaseXXConversion>(); }\n+    String getName() const override { return Func::name; }\n+    size_t getNumberOfArguments() const override { return 1; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        FunctionArgumentDescriptors args{\n+            {\"arg\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isStringOrFixedString), nullptr, \"String or FixedString\"}};\n+        validateFunctionArguments(*this, arguments, args);\n+\n+        return std::make_shared<DataTypeString>();\n+    }\n+\n+    DataTypePtr getReturnTypeForDefaultImplementationForDynamic() const override { return std::make_shared<DataTypeString>(); }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        const ColumnPtr col = arguments[0].column;\n+\n+        if (const ColumnString * col_string = checkAndGetColumn<ColumnString>(col.get()))\n+        {\n+            auto col_res = ColumnString::create();\n+            Func::processString(*col_string, col_res, input_rows_count);\n+            return col_res;\n+        }\n+        else if (const ColumnFixedString * col_fixed_string = checkAndGetColumn<ColumnFixedString>(col.get()))\n+        {\n+            auto col_res = ColumnString::create();\n+            Func::processFixedString(*col_fixed_string, col_res, input_rows_count);\n+            return col_res;\n+        }\n+\n+        throw Exception(\n+            ErrorCodes::ILLEGAL_COLUMN,\n+            \"Illegal column {} of first argument of function {}, must be String or FixedString\",\n+            arguments[0].column->getName(),\n+            getName());\n+    }\n+};\n+\n+}\ndiff --git a/src/Functions/base32Decode.cpp b/src/Functions/base32Decode.cpp\nnew file mode 100644\nindex 000000000000..9af117b98f0f\n--- /dev/null\n+++ b/src/Functions/base32Decode.cpp\n@@ -0,0 +1,33 @@\n+#include <Functions/FunctionBase32Conversion.h>\n+#include <Functions/FunctionFactory.h>\n+\n+namespace DB\n+{\n+namespace\n+{\n+struct NameBase32Decode\n+{\n+    static constexpr auto name = \"base32Decode\";\n+};\n+\n+using Base32DecodeImpl = BaseXXDecode<Base32DecodeTraits, NameBase32Decode, BaseXXDecodeErrorHandling::ThrowException>;\n+using FunctionBase32Decode = FunctionBaseXXConversion<Base32DecodeImpl>;\n+}\n+\n+REGISTER_FUNCTION(Base32Decode)\n+{\n+    factory.registerFunction<FunctionBase32Decode>(FunctionDocumentation{\n+        .description = R\"(\n+Decode a [Base32](https://datatracker.ietf.org/doc/html/rfc4648) encoded string. The input string must be a valid Base32 encoded string, otherwise an exception will be thrown.)\",\n+        .arguments = {\n+            {\"arg\", \"A Base32 (rfc4648) encoded string\"},\n+        },\n+        .examples = {\n+            {\"simple_decoding1\", \"SELECT base32Decode('ME======')\", \"a\"},\n+            {\"simple_decoding2\", \"SELECT base32Decode('JBSWY3DP')\", \"Hello\"},\n+            {\"empty_string\", \"SELECT base32Decode('')\", \"\"},\n+            {\"non_ascii\", \"SELECT hex(base32Decode('4W2HIXV4'))\", \"E5B4745EBC\"},\n+        },\n+        .category = FunctionDocumentation::Category::String});\n+}\n+}\ndiff --git a/src/Functions/base32Encode.cpp b/src/Functions/base32Encode.cpp\nnew file mode 100644\nindex 000000000000..55785b781aa0\n--- /dev/null\n+++ b/src/Functions/base32Encode.cpp\n@@ -0,0 +1,31 @@\n+#include <Functions/FunctionBase32Conversion.h>\n+#include <Functions/FunctionFactory.h>\n+\n+namespace DB\n+{\n+namespace\n+{\n+struct NameBase32Encode\n+{\n+    static constexpr auto name = \"base32Encode\";\n+};\n+\n+using Base32EncodeImpl = BaseXXEncode<Base32EncodeTraits, NameBase32Encode>;\n+using FunctionBase32Encode = FunctionBaseXXConversion<Base32EncodeImpl>;\n+}\n+\n+REGISTER_FUNCTION(Base32Encode)\n+{\n+    factory.registerFunction<FunctionBase32Encode>(FunctionDocumentation{\n+        .description = R\"(\n+Encode a string with [Base32](https://datatracker.ietf.org/doc/html/rfc4648) encoding.)\",\n+        .arguments = {\n+            {\"arg\", \"A string to be encoded\"},\n+        },\n+        .examples = {\n+            {\"simple_encoding1\", \"SELECT base32Encode('a')\", \"ME======\"},\n+            {\"simple_encoding2\", \"SELECT base32Encode('Hello')\", \"JBSWY3DP\"}\n+        },\n+        .category = FunctionDocumentation::Category::String});\n+}\n+}\ndiff --git a/src/Functions/base58Decode.cpp b/src/Functions/base58Decode.cpp\nindex 4c437473f814..c5d340fe5a18 100644\n--- a/src/Functions/base58Decode.cpp\n+++ b/src/Functions/base58Decode.cpp\n@@ -5,15 +5,13 @@ namespace DB\n {\n namespace\n {\n-\n struct NameBase58Decode\n {\n     static constexpr auto name = \"base58Decode\";\n };\n \n-using Base58DecodeImpl = Base58Decode<NameBase58Decode, Base58DecodeErrorHandling::ThrowException>;\n-using FunctionBase58Decode = FunctionBase58Conversion<Base58DecodeImpl>;\n-\n+using Base58DecodeImpl = BaseXXDecode<Base58DecodeTraits, NameBase58Decode, BaseXXDecodeErrorHandling::ThrowException>;\n+using FunctionBase58Decode = FunctionBaseXXConversion<Base58DecodeImpl>;\n }\n \n REGISTER_FUNCTION(Base58Decode)\ndiff --git a/src/Functions/base58Encode.cpp b/src/Functions/base58Encode.cpp\nindex 3ae2fb12c5e9..c6e45ccea793 100644\n--- a/src/Functions/base58Encode.cpp\n+++ b/src/Functions/base58Encode.cpp\n@@ -3,10 +3,19 @@\n \n namespace DB\n {\n+namespace\n+{\n+struct NameBase58Encode\n+{\n+    static constexpr auto name = \"base58Encode\";\n+};\n \n+using Base58EncodeImpl = BaseXXEncode<Base58EncodeTraits, NameBase58Encode>;\n+using FunctionBase58Encode = FunctionBaseXXConversion<Base58EncodeImpl>;\n+}\n REGISTER_FUNCTION(Base58Encode)\n {\n-    factory.registerFunction<FunctionBase58Conversion<Base58Encode>>();\n+    factory.registerFunction<FunctionBase58Encode>();\n }\n \n }\ndiff --git a/src/Functions/base64Decode.cpp b/src/Functions/base64Decode.cpp\nindex 4c3ee0de348f..c311b3046c3d 100644\n--- a/src/Functions/base64Decode.cpp\n+++ b/src/Functions/base64Decode.cpp\n@@ -5,6 +5,16 @@\n \n namespace DB\n {\n+namespace\n+{\n+struct NameBase64Decode\n+{\n+    static constexpr auto name = \"base64Decode\";\n+};\n+\n+using Base64DecodeImpl = BaseXXDecode<Base64DecodeTraits<Base64Variant::Normal>, NameBase64Decode, BaseXXDecodeErrorHandling::ThrowException>;\n+using FunctionBase64Decode = FunctionBaseXXConversion<Base64DecodeImpl>;\n+}\n \n REGISTER_FUNCTION(Base64Decode)\n {\n@@ -16,7 +26,7 @@ REGISTER_FUNCTION(Base64Decode)\n     FunctionDocumentation::IntroducedIn introduced_in = {18, 16};\n     FunctionDocumentation::Category category = FunctionDocumentation::Category::Encoding;\n \n-    factory.registerFunction<FunctionBase64Conversion<Base64Decode<Base64Variant::Normal>>>({description, syntax, arguments, returned_value, examples, introduced_in, category});\n+    factory.registerFunction<FunctionBase64Decode>({description, syntax, arguments, returned_value, examples, introduced_in, category});\n \n     /// MySQL compatibility alias.\n     factory.registerAlias(\"FROM_BASE64\", \"base64Decode\", FunctionFactory::Case::Insensitive);\ndiff --git a/src/Functions/base64Encode.cpp b/src/Functions/base64Encode.cpp\nindex de9e7f15aa6e..8bec3025700b 100644\n--- a/src/Functions/base64Encode.cpp\n+++ b/src/Functions/base64Encode.cpp\n@@ -5,6 +5,16 @@\n \n namespace DB\n {\n+namespace\n+{\n+struct NameBase64Encode\n+{\n+static constexpr auto name = \"base64Encode\";\n+};\n+\n+using Base64EncodeImpl = BaseXXEncode<Base64EncodeTraits<Base64Variant::Normal>, NameBase64Encode>;\n+using FunctionBase64Encode = FunctionBaseXXConversion<Base64EncodeImpl>;\n+}\n \n REGISTER_FUNCTION(Base64Encode)\n {\n@@ -16,7 +26,7 @@ REGISTER_FUNCTION(Base64Encode)\n     FunctionDocumentation::IntroducedIn introduced_in = {18, 16};\n     FunctionDocumentation::Category category = FunctionDocumentation::Category::String;\n \n-    factory.registerFunction<FunctionBase64Conversion<Base64Encode<Base64Variant::Normal>>>({description, syntax, arguments, returned_value, examples, introduced_in, category});\n+    factory.registerFunction<FunctionBase64Encode>({description, syntax, arguments, returned_value, examples, introduced_in, category});\n \n     /// MySQL compatibility alias.\n     factory.registerAlias(\"TO_BASE64\", \"base64Encode\", FunctionFactory::Case::Insensitive);\ndiff --git a/src/Functions/base64URLDecode.cpp b/src/Functions/base64URLDecode.cpp\nindex bf9fc14ac3d0..e3226cdf5c7a 100644\n--- a/src/Functions/base64URLDecode.cpp\n+++ b/src/Functions/base64URLDecode.cpp\n@@ -5,6 +5,16 @@\n \n namespace DB\n {\n+namespace\n+{\n+struct NameBase64Decode\n+{\n+    static constexpr auto name = \"base64URLDecode\";\n+};\n+\n+using Base64DecodeImpl = BaseXXDecode<Base64DecodeTraits<Base64Variant::URL>, NameBase64Decode, BaseXXDecodeErrorHandling::ThrowException>;\n+using FunctionBase64Decode = FunctionBaseXXConversion<Base64DecodeImpl>;\n+}\n \n REGISTER_FUNCTION(Base64URLDecode)\n {\n@@ -16,7 +26,7 @@ REGISTER_FUNCTION(Base64URLDecode)\n     FunctionDocumentation::IntroducedIn introduced_in = {24, 6};\n     FunctionDocumentation::Category category = FunctionDocumentation::Category::Encoding;\n \n-    factory.registerFunction<FunctionBase64Conversion<Base64Decode<Base64Variant::URL>>>({description, syntax, arguments, returned_value, examples, introduced_in, category});\n+    factory.registerFunction<FunctionBase64Decode>({description, syntax, arguments, returned_value, examples, introduced_in, category});\n }\n \n }\ndiff --git a/src/Functions/base64URLEncode.cpp b/src/Functions/base64URLEncode.cpp\nindex 3525bdd6b75c..d6b72366a099 100644\n--- a/src/Functions/base64URLEncode.cpp\n+++ b/src/Functions/base64URLEncode.cpp\n@@ -5,6 +5,16 @@\n \n namespace DB\n {\n+namespace\n+{\n+struct NameBase64Encode\n+{\n+static constexpr auto name = \"base64URLEncode\";\n+};\n+\n+using Base64EncodeImpl = BaseXXEncode<Base64EncodeTraits<Base64Variant::URL>, NameBase64Encode>;\n+using FunctionBase64Encode = FunctionBaseXXConversion<Base64EncodeImpl>;\n+}\n \n REGISTER_FUNCTION(Base64URLEncode)\n {\n@@ -16,7 +26,7 @@ REGISTER_FUNCTION(Base64URLEncode)\n     FunctionDocumentation::IntroducedIn introduced_in = {24, 6};\n     FunctionDocumentation::Category category = FunctionDocumentation::Category::Encoding;\n \n-    factory.registerFunction<FunctionBase64Conversion<Base64Encode<Base64Variant::URL>>>({description, syntax, arguments, returned_value, examples, introduced_in, category});\n+    factory.registerFunction<FunctionBase64Encode>({description, syntax, arguments, returned_value, examples, introduced_in, category});\n }\n \n }\ndiff --git a/src/Functions/tryBase32Decode.cpp b/src/Functions/tryBase32Decode.cpp\nnew file mode 100644\nindex 000000000000..061ce7ae38a9\n--- /dev/null\n+++ b/src/Functions/tryBase32Decode.cpp\n@@ -0,0 +1,35 @@\n+#include <Functions/FunctionBase32Conversion.h>\n+#include <Functions/FunctionFactory.h>\n+\n+namespace DB\n+{\n+namespace\n+{\n+struct NameTryBase32Decode\n+{\n+    static constexpr auto name = \"tryBase32Decode\";\n+};\n+\n+using TryBase32DecodeImpl = BaseXXDecode<Base32DecodeTraits, NameTryBase32Decode, BaseXXDecodeErrorHandling::ReturnEmptyString>;\n+using FunctionTryBase32Decode = FunctionBaseXXConversion<TryBase32DecodeImpl>;\n+}\n+\n+REGISTER_FUNCTION(TryBase32Decode)\n+{\n+    factory.registerFunction<FunctionTryBase32Decode>(FunctionDocumentation{\n+        .description = R\"(\n+Decode a [Base32](https://datatracker.ietf.org/doc/html/rfc4648) encoded string. If the input string is not a valid Base32 return an empty string.)\",\n+        .arguments = {\n+            {\"arg\", \"A Base32 (rfc4648) encoded string\"},\n+        },\n+        .examples = {\n+            {\"simple_decoding1\", \"SELECT tryBase32Decode('ME======')\", \"a\"},\n+            {\"simple_decoding2\", \"SELECT tryBase32Decode('JBSWY3DP')\", \"Hello\"},\n+            {\"non_ascii\", \"SELECT hex(tryBase32Decode('4W2HIXV4'))\", \"E5B4745EBC\"},\n+            {\"invalid_base32\", \"SELECT tryBase32Decode('invalid_base32')\", \"\"},\n+            {\"empty_string\", \"SELECT tryBase32Decode('')\", \"\"},\n+            {\"non_base32_characters\", \"SELECT tryBase32Decode('12345')\", \"\"},\n+        },\n+        .category = FunctionDocumentation::Category::String});\n+}\n+}\ndiff --git a/src/Functions/tryBase58Decode.cpp b/src/Functions/tryBase58Decode.cpp\nindex b722693fd8c3..bfc784bc2d36 100644\n--- a/src/Functions/tryBase58Decode.cpp\n+++ b/src/Functions/tryBase58Decode.cpp\n@@ -5,15 +5,13 @@ namespace DB\n {\n namespace\n {\n-\n struct NameTryBase58Decode\n {\n     static constexpr auto name = \"tryBase58Decode\";\n };\n \n-using TryBase58DecodeImpl = Base58Decode<NameTryBase58Decode, Base58DecodeErrorHandling::ReturnEmptyString>;\n-using FunctionTryBase58Decode = FunctionBase58Conversion<TryBase58DecodeImpl>;\n-\n+using TryBase58DecodeImpl = BaseXXDecode<Base58DecodeTraits, NameTryBase58Decode, BaseXXDecodeErrorHandling::ReturnEmptyString>;\n+using FunctionTryBase58Decode = FunctionBaseXXConversion<TryBase58DecodeImpl>;\n }\n \n REGISTER_FUNCTION(TryBase58Decode)\ndiff --git a/src/Functions/tryBase64Decode.cpp b/src/Functions/tryBase64Decode.cpp\nindex a7a3140823e8..83ec07668476 100644\n--- a/src/Functions/tryBase64Decode.cpp\n+++ b/src/Functions/tryBase64Decode.cpp\n@@ -5,6 +5,16 @@\n \n namespace DB\n {\n+namespace\n+{\n+struct NameBase64Decode\n+{\n+static constexpr auto name = \"tryBase64Decode\";\n+};\n+\n+using Base64DecodeImpl = BaseXXDecode<Base64DecodeTraits<Base64Variant::Normal>, NameBase64Decode, BaseXXDecodeErrorHandling::ReturnEmptyString>;\n+using FunctionBase64Decode = FunctionBaseXXConversion<Base64DecodeImpl>;\n+}\n REGISTER_FUNCTION(TryBase64Decode)\n {\n     FunctionDocumentation::Description description = R\"(Decodes a String or FixedString from base64, like base64Decode but returns an empty string in case of an error.)\";\n@@ -15,7 +25,7 @@ REGISTER_FUNCTION(TryBase64Decode)\n     FunctionDocumentation::IntroducedIn introduced_in = {18, 16};\n     FunctionDocumentation::Category category = FunctionDocumentation::Category::Encoding;\n \n-    factory.registerFunction<FunctionBase64Conversion<TryBase64Decode<Base64Variant::Normal>>>({description, syntax, arguments, returned_value, examples, introduced_in, category});\n+    factory.registerFunction<FunctionBase64Decode>({description, syntax, arguments, returned_value, examples, introduced_in, category});\n }\n }\n \ndiff --git a/src/Functions/tryBase64URLDecode.cpp b/src/Functions/tryBase64URLDecode.cpp\nindex 358ee5e87098..30e57de18b19 100644\n--- a/src/Functions/tryBase64URLDecode.cpp\n+++ b/src/Functions/tryBase64URLDecode.cpp\n@@ -5,6 +5,16 @@\n \n namespace DB\n {\n+namespace\n+{\n+struct NameBase64Decode\n+{\n+static constexpr auto name = \"tryBase64URLDecode\";\n+};\n+\n+using Base64DecodeImpl = BaseXXDecode<Base64DecodeTraits<Base64Variant::URL>, NameBase64Decode, BaseXXDecodeErrorHandling::ReturnEmptyString>;\n+using FunctionBase64Decode = FunctionBaseXXConversion<Base64DecodeImpl>;\n+}\n REGISTER_FUNCTION(TryBase64URLDecode)\n {\n     FunctionDocumentation::Description description = R\"(Decodes an URL from base64, like base64URLDecode but returns an empty string in case of an error.)\";\n@@ -15,7 +25,7 @@ REGISTER_FUNCTION(TryBase64URLDecode)\n     FunctionDocumentation::IntroducedIn introduced_in = {24, 6};\n     FunctionDocumentation::Category category = FunctionDocumentation::Category::Encoding;\n \n-    factory.registerFunction<FunctionBase64Conversion<TryBase64Decode<Base64Variant::URL>>>({description, syntax, arguments, returned_value, examples, introduced_in, category});\n+    factory.registerFunction<FunctionBase64Decode>({description, syntax, arguments, returned_value, examples, introduced_in, category});\n }\n }\n \n",
  "test_patch": "diff --git a/src/Common/tests/gtest_base32.cpp b/src/Common/tests/gtest_base32.cpp\nnew file mode 100644\nindex 000000000000..ff985c662e71\n--- /dev/null\n+++ b/src/Common/tests/gtest_base32.cpp\n@@ -0,0 +1,212 @@\n+#include <Common/Base32.h>\n+\n+#include <string_view>\n+\n+#include <gtest/gtest.h>\n+\n+using namespace std::string_view_literals;\n+\n+namespace DB\n+{\n+\n+static std::string to_hex(const UInt8 * data, size_t length)\n+{\n+    static constexpr char hex_chars[] = \"0123456789ABCDEF\";\n+    std::string result;\n+    result.reserve(length * 2);\n+\n+    for (size_t i = 0; i < length; ++i)\n+    {\n+        result += hex_chars[(data[i] >> 4) & 0x0F];\n+        result += hex_chars[data[i] & 0x0F];\n+    }\n+\n+    return result;\n+}\n+\n+struct EncodeDecodeData\n+{\n+    int id;\n+    std::string_view input;\n+    std::string_view expected;\n+};\n+\n+struct InvalidData\n+{\n+    int id;\n+    std::string_view input;\n+};\n+\n+template <typename TestData, typename Coder>\n+struct CoderTestConfiguration\n+{\n+    using test_data_t = TestData;\n+    using coder_t = Coder;\n+};\n+\n+struct Base32Rfc4648TestData\n+{\n+    constexpr static bool allow_lowercase_encoded = true;\n+\n+    // clang-format off\n+    constexpr static EncodeDecodeData encode_tests[] = {\n+        {100, \"\"sv, \"\"sv},\n+        {101, \"f\"sv, \"MY======\"sv},\n+        {102, \"fo\"sv, \"MZXQ====\"sv},\n+        {103, \"foo\"sv, \"MZXW6===\"sv},\n+        {104, \"foob\"sv, \"MZXW6YQ=\"sv},\n+        {105, \"fooba\"sv, \"MZXW6YTB\"sv},\n+        {106, \"foobar\"sv, \"MZXW6YTBOI======\"sv},\n+        \n+        {200, \"\\x00\"sv, \"AA======\"sv},\n+        {201, \"\\x00\\x00\"sv, \"AAAA====\"sv},\n+        {202, \"\\x00\\x00\\x00\"sv, \"AAAAA===\"sv},\n+        {203, \"\\x00\\x00\\x00\\x00\"sv, \"AAAAAAA=\"sv},\n+        {204, \"\\x00\\x00\\x00\\x00\\x00\"sv, \"AAAAAAAA\"sv},\n+\n+        {300, \"\\xFF\"sv, \"74======\"sv},\n+        {301, \"\\xFF\\xFF\"sv, \"777Q====\"sv},\n+        {302, \"\\xFF\\xFF\\xFF\"sv, \"77776===\"sv},\n+        {303, \"\\xFF\\xFF\\xFF\\xFF\"sv, \"777777Y=\"sv},\n+        {304, \"\\xFF\\xFF\\xFF\\xFF\\xFF\"sv, \"77777777\"sv},\n+        \n+        {400, \"\\x01\\x23\\x45\\x67\\x89\"sv, \"AERUKZ4J\"sv},\n+        {401, \"\\xAB\\xCD\\xEF\\x01\\x23\"sv, \"VPG66AJD\"sv},\n+        \n+        {400, \"1234567890\"sv, \"GEZDGNBVGY3TQOJQ\"sv},\n+        {401, \"The quick brown fox jumps over the lazy dog\"sv, \n+        \"KRUGKIDROVUWG2ZAMJZG653OEBTG66BANJ2W24DTEBXXMZLSEB2GQZJANRQXU6JAMRXWO===\"sv},\n+        \n+        {500, \"a\"sv, \"ME======\"sv},          // 1 byte \u2192 8 chars (2+6 padding)\n+        {501, \"ab\"sv, \"MFRA====\"sv},         // 2 bytes \u2192 8 chars (4+4 padding)\n+        {502, \"abc\"sv, \"MFRGG===\"sv},        // 3 bytes \u2192 8 chars (5+3 padding)\n+        {503, \"abcd\"sv, \"MFRGGZA=\"sv},       // 4 bytes \u2192 8 chars (7+1 padding)\n+        {504, \"abcde\"sv, \"MFRGGZDF\"sv},      // 5 bytes \u2192 8 chars (no padding)\n+        {505, \"abcdef\"sv, \"MFRGGZDFMY======\"sv}, // 6 bytes \u2192 16 chars (4+12 padding)\n+    };\n+    constexpr static InvalidData bad_decode_tests[] = {\n+        {100, \"========\"sv}, // Invalid padding\n+        {101, \"MZXW6YT!\"sv}, // Invalid character\n+        {102, \"MZXW6Y=B\"sv}, // Padding in wrong place\n+        {103, \"MZXW6Y=!\"sv}, // Invalid character and padding\n+        {104, \"MZXW6Y===\"sv}, // Invalid padding length\n+        {105, \"MZXW6YQ=Q\"sv}, // Extra character after padding\n+        {106, \"MZXW6YQ======\"sv}, // Too much padding\n+        {107, \"12345678\"sv}, // Characters not in Base32 alphabet\n+        {108, \"MZXW6YQ\"sv}, // Missing padding\n+        {109, \"MZXW6YQ==\"sv}, // Incorrect padding length\n+        {110, \"MZXW6YQ===\"sv}, // Excessive padding\n+        {111, \"MZXW6YQ====\"sv}, // Invalid padding sequence\n+        {112, \"MZXW6YQ=====\"sv}, // Too much padding\n+        {113, \"MZXW6YQ======\"sv}, // Excessive padding\n+        {114, \"MZXW6YQ=======\"sv}, // Invalid padding length\n+        {115, \"MZXW6YQ====!==\"sv}, // Invalid character in padding\n+        {116, \"MZXW6YQ====A==\"sv}, // Extra character in padding\n+        {117, \"MZXW6YQ======\"sv}, // Invalid padding with valid length\n+        {118, \"MZXW6Y==\"sv}, // Invalid padding length\n+    };\n+    // clang-format on\n+};\n+\n+template <typename T>\n+struct BaseCoderTest : public ::testing::Test\n+{\n+    using test_data_t = typename T::test_data_t;\n+    using coder_t = typename T::coder_t;\n+};\n+\n+using TestedTypes = ::testing::Types<CoderTestConfiguration<Base32Rfc4648TestData, Base32<Base32Rfc4648, Base32NaiveTag>>>;\n+TYPED_TEST_SUITE(BaseCoderTest, TestedTypes);\n+\n+TYPED_TEST(BaseCoderTest, Null)\n+{\n+    using coder_t = typename TypeParam::coder_t;\n+    UInt8 output[64] = {0};\n+    {\n+        size_t const result = coder_t::encodeBase32(nullptr, 0, output);\n+        EXPECT_EQ(result, 0) << \" for empty input encode\";\n+    }\n+    {\n+        auto const result = coder_t::decodeBase32(nullptr, 0, output);\n+        ASSERT_TRUE(result.has_value()) << \" for empty input decode\";\n+        EXPECT_EQ(result.value(), 0) << \" for empty input decode\";\n+    }\n+}\n+\n+TYPED_TEST(BaseCoderTest, EncodeDecode)\n+{\n+    using test_data_t = typename TypeParam::test_data_t;\n+    using coder_t = typename TypeParam::coder_t;\n+    for (const auto & test : test_data_t::encode_tests)\n+    {\n+        size_t const input_len = test.input.size();\n+        size_t const expected_output_len = ((input_len + 4) / 5) * 8;\n+        UInt8 encode_output[128] = {0};\n+\n+        size_t const encoded_result_len\n+            = coder_t::encodeBase32(reinterpret_cast<const UInt8 *>(test.input.data()), input_len, encode_output);\n+\n+        ASSERT_EQ(expected_output_len, encoded_result_len) << \" for id=\" << test.id;\n+        auto const encode_output_sv = std::string_view(reinterpret_cast<const char *>(encode_output), encoded_result_len);\n+        EXPECT_EQ(test.expected, encode_output_sv) << \" for id=\" << test.id;\n+\n+        auto decode = [&](std::string_view what)\n+        {\n+            UInt8 decode_output[128] = {0};\n+            auto const decode_result = coder_t::decodeBase32(reinterpret_cast<const UInt8 *>(what.data()), what.size(), decode_output);\n+            ASSERT_TRUE(decode_result.has_value()) << \" for id=\" << test.id;\n+            EXPECT_EQ(input_len, decode_result.value()) << \" for id=\" << test.id;\n+            auto const decode_output_sv = std::string_view(reinterpret_cast<const char *>(decode_output), decode_result.value());\n+            EXPECT_EQ(test.input, decode_output_sv) << \" for id=\" << test.id;\n+        };\n+        // And now decode it back\n+        decode(encode_output_sv);\n+        if constexpr (test_data_t::allow_lowercase_encoded)\n+        {\n+            std::string lower_case(encode_output_sv);\n+            std::transform(lower_case.begin(), lower_case.end(), lower_case.begin(), ::tolower);\n+            decode(lower_case);\n+        }\n+    }\n+}\n+\n+TYPED_TEST(BaseCoderTest, DecodeInvalid)\n+{\n+    using test_data_t = typename TypeParam::test_data_t;\n+    using coder_t = typename TypeParam::coder_t;\n+    for (const auto & test : test_data_t::bad_decode_tests)\n+    {\n+        size_t const input_len = test.input.size();\n+        UInt8 output[128] = {0};\n+\n+        auto const result = coder_t::decodeBase32(reinterpret_cast<const UInt8 *>(test.input.data()), input_len, output);\n+\n+        ASSERT_FALSE(result.has_value()) << \" for id=\" << test.id;\n+    }\n+}\n+\n+TYPED_TEST(BaseCoderTest, LargeTest)\n+{\n+    using coder_t = typename TypeParam::coder_t;\n+    size_t const large_size = 1234;\n+    std::vector<UInt8> large_input(large_size);\n+    for (size_t i = 0; i < large_size; ++i)\n+    {\n+        large_input[i] = static_cast<UInt8>(i % 256);\n+    }\n+\n+    size_t const encoded_len = ((large_size + 4) / 5) * 8;\n+    std::vector<UInt8> encoded(encoded_len + 1);\n+    auto const actual_encoded_len = coder_t::encodeBase32(large_input.data(), large_size, encoded.data());\n+    ASSERT_EQ(encoded_len, actual_encoded_len) << \" for input (as hex) \" << to_hex(large_input.data(), large_size);\n+\n+    std::vector<UInt8> decoded(large_size);\n+    auto const decode_result = coder_t::decodeBase32(encoded.data(), encoded_len, decoded.data());\n+\n+    ASSERT_TRUE(decode_result.has_value()) << \" for input (as hex) \" << to_hex(large_input.data(), large_size);\n+    ASSERT_EQ(large_size, decode_result.value()) << \" for input (as hex) \" << to_hex(large_input.data(), large_size);\n+    EXPECT_EQ(0, memcmp(large_input.data(), decoded.data(), large_size))\n+        << \" for input (as hex) \" << to_hex(large_input.data(), large_size);\n+}\n+\n+}\ndiff --git a/tests/fuzz/all.dict b/tests/fuzz/all.dict\nindex 28774fd8f091..492b2089ad97 100644\n--- a/tests/fuzz/all.dict\n+++ b/tests/fuzz/all.dict\n@@ -1349,6 +1349,8 @@\n \"avgWeightedState\"\n \"bagexpansion\"\n \"bar\"\n+\"base32Decode\"\n+\"base32Encode\"\n \"base58Decode\"\n \"base58Encode\"\n \"base64Decode\"\n@@ -4700,6 +4702,7 @@\n \"trimRight\"\n \"trunc\"\n \"truncate\"\n+\"tryBase32Decode\"\n \"tryBase58Decode\"\n \"tryBase64Decode\"\n \"tryBase64URLDecode\"\ndiff --git a/tests/fuzz/dictionaries/functions.dict b/tests/fuzz/dictionaries/functions.dict\nindex ddc2db582e77..ef4afec44ea6 100644\n--- a/tests/fuzz/dictionaries/functions.dict\n+++ b/tests/fuzz/dictionaries/functions.dict\n@@ -661,6 +661,8 @@\n \"avgWeightedSimpleState\"\n \"avgWeightedState\"\n \"bar\"\n+\"base32Decode\"\n+\"base32Encode\"\n \"base58Decode\"\n \"base58Encode\"\n \"base64Decode\"\n@@ -4009,6 +4011,7 @@\n \"trimRight\"\n \"trunc\"\n \"truncate\"\n+\"tryBase32Decode\"\n \"tryBase58Decode\"\n \"tryBase64Decode\"\n \"tryBase64URLDecode\"\ndiff --git a/tests/queries/0_stateless/02337_base58.sql b/tests/queries/0_stateless/02337_base58.sql\nindex 554492e8254b..d14dd91387be 100644\n--- a/tests/queries/0_stateless/02337_base58.sql\n+++ b/tests/queries/0_stateless/02337_base58.sql\n@@ -3,7 +3,7 @@\n SELECT base58Encode('Hold my beer...');\n \n SELECT base58Encode('Hold my beer...', 'Second arg'); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n-SELECT base58Decode('Hold my beer...'); -- { serverError BAD_ARGUMENTS }\n+SELECT base58Decode('Hold my beer...'); -- { serverError INCORRECT_DATA }\n \n SELECT base58Decode(encoded) FROM (SELECT base58Encode(val) as encoded FROM (SELECT arrayJoin(['', 'f', 'fo', 'foo', 'foob', 'fooba', 'foobar', 'Hello world!']) val));\n SELECT tryBase58Decode(encoded) FROM (SELECT base58Encode(val) as encoded FROM (SELECT arrayJoin(['', 'f', 'fo', 'foo', 'foob', 'fooba', 'foobar', 'Hello world!']) val));\ndiff --git a/tests/queries/0_stateless/02415_all_new_functions_must_have_version_information.reference b/tests/queries/0_stateless/02415_all_new_functions_must_have_version_information.reference\nindex 4c31698becb0..42e1e768b804 100644\n--- a/tests/queries/0_stateless/02415_all_new_functions_must_have_version_information.reference\n+++ b/tests/queries/0_stateless/02415_all_new_functions_must_have_version_information.reference\n@@ -185,6 +185,8 @@ atan\n atan2\n atanh\n bar\n+base32Decode\n+base32Encode\n base58Decode\n base58Encode\n basename\n@@ -1092,6 +1094,7 @@ trimBoth\n trimLeft\n trimRight\n trunc\n+tryBase32Decode\n tryBase58Decode\n tumble\n tumbleEnd\ndiff --git a/tests/queries/0_stateless/03447_base32_encode_decode.reference b/tests/queries/0_stateless/03447_base32_encode_decode.reference\nnew file mode 100644\nindex 000000000000..0f9875a4634a\n--- /dev/null\n+++ b/tests/queries/0_stateless/03447_base32_encode_decode.reference\n@@ -0,0 +1,312 @@\n+KRUGS4ZANFZSAYJAORSXG5BAON2HE2LOM4======\n+Part 1 - Encoding\n+100\t\t\t\t\t1\n+101\tf\t66\tMY======\tMY======\t1\n+102\tfo\t666F\tMZXQ====\tMZXQ====\t1\n+103\tfoo\t666F6F\tMZXW6===\tMZXW6===\t1\n+104\tfoob\t666F6F62\tMZXW6YQ=\tMZXW6YQ=\t1\n+105\tfooba\t666F6F6261\tMZXW6YTB\tMZXW6YTB\t1\n+106\tfoobar\t666F6F626172\tMZXW6YTBOI======\tMZXW6YTBOI======\t1\n+200\t\\0\t00\tAA======\tAA======\t1\n+201\t\\0\\0\t0000\tAAAA====\tAAAA====\t1\n+202\t\\0\\0\\0\t000000\tAAAAA===\tAAAAA===\t1\n+203\t\\0\\0\\0\\0\t00000000\tAAAAAAA=\tAAAAAAA=\t1\n+204\t\\0\\0\\0\\0\\0\t0000000000\tAAAAAAAA\tAAAAAAAA\t1\n+300\t\ufffd\tFF\t74======\t74======\t1\n+301\t\ufffd\ufffd\tFFFF\t777Q====\t777Q====\t1\n+302\t\ufffd\ufffd\ufffd\tFFFFFF\t77776===\t77776===\t1\n+303\t\ufffd\ufffd\ufffd\ufffd\tFFFFFFFF\t777777Y=\t777777Y=\t1\n+304\t\ufffd\ufffd\ufffd\ufffd\ufffd\tFFFFFFFFFF\t77777777\t77777777\t1\n+400\t\u0001#Eg\ufffd\t0123456789\tAERUKZ4J\tAERUKZ4J\t1\n+401\t\ufffd\ufffd\ufffd\u0001#\tABCDEF0123\tVPG66AJD\tVPG66AJD\t1\n+402\t1234567890\t31323334353637383930\tGEZDGNBVGY3TQOJQ\tGEZDGNBVGY3TQOJQ\t1\n+403\tThe quick brown fox jumps over the lazy dog\t54686520717569636B2062726F776E20666F78206A756D7073206F76657220746865206C617A7920646F67\tKRUGKIDROVUWG2ZAMJZG653OEBTG66BANJ2W24DTEBXXMZLSEB2GQZJANRQXU6JAMRXWO===\tKRUGKIDROVUWG2ZAMJZG653OEBTG66BANJ2W24DTEBXXMZLSEB2GQZJANRQXU6JAMRXWO===\t1\n+500\ta\t61\tME======\tME======\t1\n+501\tab\t6162\tMFRA====\tMFRA====\t1\n+502\tabc\t616263\tMFRGG===\tMFRGG===\t1\n+503\tabcd\t61626364\tMFRGGZA=\tMFRGGZA=\t1\n+504\tabcde\t6162636465\tMFRGGZDF\tMFRGGZDF\t1\n+505\tabcdef\t616263646566\tMFRGGZDFMY======\tMFRGGZDFMY======\t1\n+506\tfoo\t666F6F\tMZXW6===\tMZXW6===\t1\n+507\tfoobar\t666F6F626172\tMZXW6YTBOI======\tMZXW6YTBOI======\t1\n+508\tHello world!\t48656C6C6F20776F726C6421\tJBSWY3DPEB3W64TMMQQQ====\tJBSWY3DPEB3W64TMMQQQ====\t1\n+509\tHold my beer\t486F6C64206D792062656572\tJBXWYZBANV4SAYTFMVZA====\tJBXWYZBANV4SAYTFMVZA====\t1\n+510\tHold another beer\t486F6C6420616E6F746865722062656572\tJBXWYZBAMFXG65DIMVZCAYTFMVZA====\tJBXWYZBAMFXG65DIMVZCAYTFMVZA====\t1\n+511\tAnd a wine\t416E6420612077696E65\tIFXGIIDBEB3WS3TF\tIFXGIIDBEB3WS3TF\t1\n+512\tAnd another wine\t416E6420616E6F746865722077696E65\tIFXGIIDBNZXXI2DFOIQHO2LOMU======\tIFXGIIDBNZXXI2DFOIQHO2LOMU======\t1\n+513\tAnd a lemonade\t416E642061206C656D6F6E616465\tIFXGIIDBEBWGK3LPNZQWIZI=\tIFXGIIDBEBWGK3LPNZQWIZI=\t1\n+514\tt1Zv2yaZ\t74315A763279615A\tOQYVU5RSPFQVU===\tOQYVU5RSPFQVU===\t1\n+515\tAnd another wine\t416E6420616E6F746865722077696E65\tIFXGIIDBNZXXI2DFOIQHO2LOMU======\tIFXGIIDBNZXXI2DFOIQHO2LOMU======\t1\n+Part 2a - Decoding\n+100\t\t\t\t\t1\n+101\tMY======\tf\t66\t66\t1\n+102\tMZXQ====\tfo\t666F\t666F\t1\n+103\tMZXW6===\tfoo\t666F6F\t666F6F\t1\n+104\tMZXW6YQ=\tfoob\t666F6F62\t666F6F62\t1\n+105\tMZXW6YTB\tfooba\t666F6F6261\t666F6F6261\t1\n+106\tMZXW6YTBOI======\tfoobar\t666F6F626172\t666F6F626172\t1\n+200\tAA======\t\\0\t00\t00\t1\n+201\tAAAA====\t\\0\\0\t0000\t0000\t1\n+202\tAAAAA===\t\\0\\0\\0\t000000\t000000\t1\n+203\tAAAAAAA=\t\\0\\0\\0\\0\t00000000\t00000000\t1\n+204\tAAAAAAAA\t\\0\\0\\0\\0\\0\t0000000000\t0000000000\t1\n+300\t74======\t\ufffd\tFF\tFF\t1\n+301\t777Q====\t\ufffd\ufffd\tFFFF\tFFFF\t1\n+302\t77776===\t\ufffd\ufffd\ufffd\tFFFFFF\tFFFFFF\t1\n+303\t777777Y=\t\ufffd\ufffd\ufffd\ufffd\tFFFFFFFF\tFFFFFFFF\t1\n+304\t77777777\t\ufffd\ufffd\ufffd\ufffd\ufffd\tFFFFFFFFFF\tFFFFFFFFFF\t1\n+400\tAERUKZ4J\t\u0001#Eg\ufffd\t0123456789\t0123456789\t1\n+401\tVPG66AJD\t\ufffd\ufffd\ufffd\u0001#\tABCDEF0123\tABCDEF0123\t1\n+402\tGEZDGNBVGY3TQOJQ\t1234567890\t31323334353637383930\t31323334353637383930\t1\n+403\tKRUGKIDROVUWG2ZAMJZG653OEBTG66BANJ2W24DTEBXXMZLSEB2GQZJANRQXU6JAMRXWO===\tThe quick brown fox jumps over the lazy dog\t54686520717569636B2062726F776E20666F78206A756D7073206F76657220746865206C617A7920646F67\t54686520717569636B2062726F776E20666F78206A756D7073206F76657220746865206C617A7920646F67\t1\n+500\tME======\ta\t61\t61\t1\n+501\tMFRA====\tab\t6162\t6162\t1\n+502\tMFRGG===\tabc\t616263\t616263\t1\n+503\tMFRGGZA=\tabcd\t61626364\t61626364\t1\n+504\tMFRGGZDF\tabcde\t6162636465\t6162636465\t1\n+505\tMFRGGZDFMY======\tabcdef\t616263646566\t616263646566\t1\n+506\tMZXW6===\tfoo\t666F6F\t666F6F\t1\n+507\tMZXW6YTBOI======\tfoobar\t666F6F626172\t666F6F626172\t1\n+508\tJBSWY3DPEB3W64TMMQQQ====\tHello world!\t48656C6C6F20776F726C6421\t48656C6C6F20776F726C6421\t1\n+509\tJBXWYZBANV4SAYTFMVZA====\tHold my beer\t486F6C64206D792062656572\t486F6C64206D792062656572\t1\n+510\tJBXWYZBAMFXG65DIMVZCAYTFMVZA====\tHold another beer\t486F6C6420616E6F746865722062656572\t486F6C6420616E6F746865722062656572\t1\n+511\tIFXGIIDBEB3WS3TF\tAnd a wine\t416E6420612077696E65\t416E6420612077696E65\t1\n+512\tIFXGIIDBNZXXI2DFOIQHO2LOMU======\tAnd another wine\t416E6420616E6F746865722077696E65\t416E6420616E6F746865722077696E65\t1\n+513\tIFXGIIDBEBWGK3LPNZQWIZI=\tAnd a lemonade\t416E642061206C656D6F6E616465\t416E642061206C656D6F6E616465\t1\n+514\tOQYVU5RSPFQVU===\tt1Zv2yaZ\t74315A763279615A\t74315A763279615A\t1\n+515\tIFXGIIDBNZXXI2DFOIQHO2LOMU======\tAnd another wine\t416E6420616E6F746865722077696E65\t416E6420616E6F746865722077696E65\t1\n+Part 2b - Decoding lowercase\n+100\t\t\t\t\t1\n+101\tmy======\tf\t66\t66\t1\n+102\tmzxq====\tfo\t666F\t666F\t1\n+103\tmzxw6===\tfoo\t666F6F\t666F6F\t1\n+104\tmzxw6yq=\tfoob\t666F6F62\t666F6F62\t1\n+105\tmzxw6ytb\tfooba\t666F6F6261\t666F6F6261\t1\n+106\tmzxw6ytboi======\tfoobar\t666F6F626172\t666F6F626172\t1\n+200\taa======\t\\0\t00\t00\t1\n+201\taaaa====\t\\0\\0\t0000\t0000\t1\n+202\taaaaa===\t\\0\\0\\0\t000000\t000000\t1\n+203\taaaaaaa=\t\\0\\0\\0\\0\t00000000\t00000000\t1\n+204\taaaaaaaa\t\\0\\0\\0\\0\\0\t0000000000\t0000000000\t1\n+300\t74======\t\ufffd\tFF\tFF\t1\n+301\t777q====\t\ufffd\ufffd\tFFFF\tFFFF\t1\n+302\t77776===\t\ufffd\ufffd\ufffd\tFFFFFF\tFFFFFF\t1\n+303\t777777y=\t\ufffd\ufffd\ufffd\ufffd\tFFFFFFFF\tFFFFFFFF\t1\n+304\t77777777\t\ufffd\ufffd\ufffd\ufffd\ufffd\tFFFFFFFFFF\tFFFFFFFFFF\t1\n+400\taerukz4j\t\u0001#Eg\ufffd\t0123456789\t0123456789\t1\n+401\tvpg66ajd\t\ufffd\ufffd\ufffd\u0001#\tABCDEF0123\tABCDEF0123\t1\n+402\tgezdgnbvgy3tqojq\t1234567890\t31323334353637383930\t31323334353637383930\t1\n+403\tkrugkidrovuwg2zamjzg653oebtg66banj2w24dtebxxmzlseb2gqzjanrqxu6jamrxwo===\tThe quick brown fox jumps over the lazy dog\t54686520717569636B2062726F776E20666F78206A756D7073206F76657220746865206C617A7920646F67\t54686520717569636B2062726F776E20666F78206A756D7073206F76657220746865206C617A7920646F67\t1\n+500\tme======\ta\t61\t61\t1\n+501\tmfra====\tab\t6162\t6162\t1\n+502\tmfrgg===\tabc\t616263\t616263\t1\n+503\tmfrggza=\tabcd\t61626364\t61626364\t1\n+504\tmfrggzdf\tabcde\t6162636465\t6162636465\t1\n+505\tmfrggzdfmy======\tabcdef\t616263646566\t616263646566\t1\n+506\tmzxw6===\tfoo\t666F6F\t666F6F\t1\n+507\tmzxw6ytboi======\tfoobar\t666F6F626172\t666F6F626172\t1\n+508\tjbswy3dpeb3w64tmmqqq====\tHello world!\t48656C6C6F20776F726C6421\t48656C6C6F20776F726C6421\t1\n+509\tjbxwyzbanv4saytfmvza====\tHold my beer\t486F6C64206D792062656572\t486F6C64206D792062656572\t1\n+510\tjbxwyzbamfxg65dimvzcaytfmvza====\tHold another beer\t486F6C6420616E6F746865722062656572\t486F6C6420616E6F746865722062656572\t1\n+511\tifxgiidbeb3ws3tf\tAnd a wine\t416E6420612077696E65\t416E6420612077696E65\t1\n+512\tifxgiidbnzxxi2dfoiqho2lomu======\tAnd another wine\t416E6420616E6F746865722077696E65\t416E6420616E6F746865722077696E65\t1\n+513\tifxgiidbebwgk3lpnzqwizi=\tAnd a lemonade\t416E642061206C656D6F6E616465\t416E642061206C656D6F6E616465\t1\n+514\toqyvu5rspfqvu===\tt1Zv2yaZ\t74315A763279615A\t74315A763279615A\t1\n+515\tifxgiidbnzxxi2dfoiqho2lomu======\tAnd another wine\t416E6420616E6F746865722077696E65\t416E6420616E6F746865722077696E65\t1\n+Part 3 - Roundtrip\n+100\t\t\t\t1\n+101\tf\t66\tf\t1\n+102\tfo\t666F\tfo\t1\n+103\tfoo\t666F6F\tfoo\t1\n+104\tfoob\t666F6F62\tfoob\t1\n+105\tfooba\t666F6F6261\tfooba\t1\n+106\tfoobar\t666F6F626172\tfoobar\t1\n+200\t\\0\t00\t\\0\t1\n+201\t\\0\\0\t0000\t\\0\\0\t1\n+202\t\\0\\0\\0\t000000\t\\0\\0\\0\t1\n+203\t\\0\\0\\0\\0\t00000000\t\\0\\0\\0\\0\t1\n+204\t\\0\\0\\0\\0\\0\t0000000000\t\\0\\0\\0\\0\\0\t1\n+300\t\ufffd\tFF\t\ufffd\t1\n+301\t\ufffd\ufffd\tFFFF\t\ufffd\ufffd\t1\n+302\t\ufffd\ufffd\ufffd\tFFFFFF\t\ufffd\ufffd\ufffd\t1\n+303\t\ufffd\ufffd\ufffd\ufffd\tFFFFFFFF\t\ufffd\ufffd\ufffd\ufffd\t1\n+304\t\ufffd\ufffd\ufffd\ufffd\ufffd\tFFFFFFFFFF\t\ufffd\ufffd\ufffd\ufffd\ufffd\t1\n+400\t\u0001#Eg\ufffd\t0123456789\t\u0001#Eg\ufffd\t1\n+401\t\ufffd\ufffd\ufffd\u0001#\tABCDEF0123\t\ufffd\ufffd\ufffd\u0001#\t1\n+402\t1234567890\t31323334353637383930\t1234567890\t1\n+403\tThe quick brown fox jumps over the lazy dog\t54686520717569636B2062726F776E20666F78206A756D7073206F76657220746865206C617A7920646F67\tThe quick brown fox jumps over the lazy dog\t1\n+500\ta\t61\ta\t1\n+501\tab\t6162\tab\t1\n+502\tabc\t616263\tabc\t1\n+503\tabcd\t61626364\tabcd\t1\n+504\tabcde\t6162636465\tabcde\t1\n+505\tabcdef\t616263646566\tabcdef\t1\n+506\tfoo\t666F6F\tfoo\t1\n+507\tfoobar\t666F6F626172\tfoobar\t1\n+508\tHello world!\t48656C6C6F20776F726C6421\tHello world!\t1\n+509\tHold my beer\t486F6C64206D792062656572\tHold my beer\t1\n+510\tHold another beer\t486F6C6420616E6F746865722062656572\tHold another beer\t1\n+511\tAnd a wine\t416E6420612077696E65\tAnd a wine\t1\n+512\tAnd another wine\t416E6420616E6F746865722077696E65\tAnd another wine\t1\n+513\tAnd a lemonade\t416E642061206C656D6F6E616465\tAnd a lemonade\t1\n+514\tt1Zv2yaZ\t74315A763279615A\tt1Zv2yaZ\t1\n+515\tAnd another wine\t416E6420616E6F746865722077696E65\tAnd another wine\t1\n+Part 4 - Invalid input\n+Part 5 - tryBase32Decode\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+Part 6 - FixedString encoding + decoding\n+\t\t\t\t1\n+f\t66\tMY======\t66\t1\n+fo\t666F\tMZXQ====\t666F\t1\n+foo\t666F6F\tMZXW6===\t666F6F\t1\n+foob\t666F6F62\tMZXW6YQ=\t666F6F62\t1\n+fooba\t666F6F6261\tMZXW6YTB\t666F6F6261\t1\n+foobar\t666F6F626172\tMZXW6YTBOI======\t666F6F626172\t1\n+\t\t\t\t1\n+\t\t\t\t1\n+\t\t\t\t1\n+\t\t\t\t1\n+\t\t\t\t1\n+\ufffd\tFF\t74======\tFF\t1\n+\ufffd\ufffd\tFFFF\t777Q====\tFFFF\t1\n+\ufffd\ufffd\ufffd\tFFFFFF\t77776===\tFFFFFF\t1\n+\ufffd\ufffd\ufffd\ufffd\tFFFFFFFF\t777777Y=\tFFFFFFFF\t1\n+\ufffd\ufffd\ufffd\ufffd\ufffd\tFFFFFFFFFF\t77777777\tFFFFFFFFFF\t1\n+\u0001#Eg\ufffd\t0123456789\tAERUKZ4J\t0123456789\t1\n+\ufffd\ufffd\ufffd\u0001#\tABCDEF0123\tVPG66AJD\tABCDEF0123\t1\n+1234567890\t31323334353637383930\tGEZDGNBVGY3TQOJQ\t31323334353637383930\t1\n+The quick brown fox jumps over the lazy dog\t54686520717569636B2062726F776E20666F78206A756D7073206F76657220746865206C617A7920646F67\tKRUGKIDROVUWG2ZAMJZG653OEBTG66BANJ2W24DTEBXXMZLSEB2GQZJANRQXU6JAMRXWO===\t54686520717569636B2062726F776E20666F78206A756D7073206F76657220746865206C617A7920646F67\t1\n+a\t61\tME======\t61\t1\n+ab\t6162\tMFRA====\t6162\t1\n+abc\t616263\tMFRGG===\t616263\t1\n+abcd\t61626364\tMFRGGZA=\t61626364\t1\n+abcde\t6162636465\tMFRGGZDF\t6162636465\t1\n+abcdef\t616263646566\tMFRGGZDFMY======\t616263646566\t1\n+foo\t666F6F\tMZXW6===\t666F6F\t1\n+foobar\t666F6F626172\tMZXW6YTBOI======\t666F6F626172\t1\n+Hello world!\t48656C6C6F20776F726C6421\tJBSWY3DPEB3W64TMMQQQ====\t48656C6C6F20776F726C6421\t1\n+Hold my beer\t486F6C64206D792062656572\tJBXWYZBANV4SAYTFMVZA====\t486F6C64206D792062656572\t1\n+Hold another beer\t486F6C6420616E6F746865722062656572\tJBXWYZBAMFXG65DIMVZCAYTFMVZA====\t486F6C6420616E6F746865722062656572\t1\n+And a wine\t416E6420612077696E65\tIFXGIIDBEB3WS3TF\t416E6420612077696E65\t1\n+And another wine\t416E6420616E6F746865722077696E65\tIFXGIIDBNZXXI2DFOIQHO2LOMU======\t416E6420616E6F746865722077696E65\t1\n+And a lemonade\t416E642061206C656D6F6E616465\tIFXGIIDBEBWGK3LPNZQWIZI=\t416E642061206C656D6F6E616465\t1\n+t1Zv2yaZ\t74315A763279615A\tOQYVU5RSPFQVU===\t74315A763279615A\t1\n+And another wine\t416E6420616E6F746865722077696E65\tIFXGIIDBNZXXI2DFOIQHO2LOMU======\t416E6420616E6F746865722077696E65\t1\n+Part 6 - FixedString decoding + encoding\n+AAAAA===\t\\0\\0\\0\t000000\tAAAAA===\t1\n+MY======\tf\t66\tMY======\t1\n+MZXQ====\tfo\t666F\tMZXQ====\t1\n+MZXW6===\tfoo\t666F6F\tMZXW6===\t1\n+MZXW6YQ=\tfoob\t666F6F62\tMZXW6YQ=\t1\n+MZXW6YTB\tfooba\t666F6F6261\tMZXW6YTB\t1\n+MZXW6YTBOI======\tfoobar\t666F6F626172\tMZXW6YTBOI======\t1\n+AA======\t\\0\t00\tAA======\t1\n+AAAA====\t\\0\\0\t0000\tAAAA====\t1\n+AAAAA===\t\\0\\0\\0\t000000\tAAAAA===\t1\n+AAAAAAA=\t\\0\\0\\0\\0\t00000000\tAAAAAAA=\t1\n+AAAAAAAA\t\\0\\0\\0\\0\\0\t0000000000\tAAAAAAAA\t1\n+74======\t\ufffd\tFF\t74======\t1\n+777Q====\t\ufffd\ufffd\tFFFF\t777Q====\t1\n+77776===\t\ufffd\ufffd\ufffd\tFFFFFF\t77776===\t1\n+777777Y=\t\ufffd\ufffd\ufffd\ufffd\tFFFFFFFF\t777777Y=\t1\n+77777777\t\ufffd\ufffd\ufffd\ufffd\ufffd\tFFFFFFFFFF\t77777777\t1\n+AERUKZ4J\t\u0001#Eg\ufffd\t0123456789\tAERUKZ4J\t1\n+VPG66AJD\t\ufffd\ufffd\ufffd\u0001#\tABCDEF0123\tVPG66AJD\t1\n+GEZDGNBVGY3TQOJQ\t1234567890\t31323334353637383930\tGEZDGNBVGY3TQOJQ\t1\n+KRUGKIDROVUWG2ZAMJZG653OEBTG66BANJ2W24DTEBXXMZLSEB2GQZJANRQXU6JAMRXWO===\tThe quick brown fox jumps over the lazy dog\t54686520717569636B2062726F776E20666F78206A756D7073206F76657220746865206C617A7920646F67\tKRUGKIDROVUWG2ZAMJZG653OEBTG66BANJ2W24DTEBXXMZLSEB2GQZJANRQXU6JAMRXWO===\t1\n+ME======\ta\t61\tME======\t1\n+MFRA====\tab\t6162\tMFRA====\t1\n+MFRGG===\tabc\t616263\tMFRGG===\t1\n+MFRGGZA=\tabcd\t61626364\tMFRGGZA=\t1\n+MFRGGZDF\tabcde\t6162636465\tMFRGGZDF\t1\n+MFRGGZDFMY======\tabcdef\t616263646566\tMFRGGZDFMY======\t1\n+MZXW6===\tfoo\t666F6F\tMZXW6===\t1\n+MZXW6YTBOI======\tfoobar\t666F6F626172\tMZXW6YTBOI======\t1\n+JBSWY3DPEB3W64TMMQQQ====\tHello world!\t48656C6C6F20776F726C6421\tJBSWY3DPEB3W64TMMQQQ====\t1\n+JBXWYZBANV4SAYTFMVZA====\tHold my beer\t486F6C64206D792062656572\tJBXWYZBANV4SAYTFMVZA====\t1\n+JBXWYZBAMFXG65DIMVZCAYTFMVZA====\tHold another beer\t486F6C6420616E6F746865722062656572\tJBXWYZBAMFXG65DIMVZCAYTFMVZA====\t1\n+IFXGIIDBEB3WS3TF\tAnd a wine\t416E6420612077696E65\tIFXGIIDBEB3WS3TF\t1\n+IFXGIIDBNZXXI2DFOIQHO2LOMU======\tAnd another wine\t416E6420616E6F746865722077696E65\tIFXGIIDBNZXXI2DFOIQHO2LOMU======\t1\n+IFXGIIDBEBWGK3LPNZQWIZI=\tAnd a lemonade\t416E642061206C656D6F6E616465\tIFXGIIDBEBWGK3LPNZQWIZI=\t1\n+OQYVU5RSPFQVU===\tt1Zv2yaZ\t74315A763279615A\tOQYVU5RSPFQVU===\t1\n+IFXGIIDBNZXXI2DFOIQHO2LOMU======\tAnd another wine\t416E6420616E6F746865722077696E65\tIFXGIIDBNZXXI2DFOIQHO2LOMU======\t1\n+Part 7 - Similar to 02337_base58.sql\n+\n+f\n+fo\n+foo\n+foob\n+fooba\n+foobar\n+Hello world!\n+\n+f\n+fo\n+foo\n+foob\n+fooba\n+foobar\n+Hello world!\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+MY======\n+MZXQ====\n+MZXW6===\n+MZXW6YQ=\n+MZXW6YTB\n+MZXW6YTBOI======\n+\n+f\n+fo\n+foo\n+foob\n+fooba\n+foobar\n+1\n+1\n+JBXWYZBANV4SAYTFMVZC4LRO\n+\n+AAAAA===\n+MYAAA===\n+MZXQA===\n+MZXW6===\n+\\0\\0\\0\n+f\\0\\0\n+fo\\0\n+foo\n+1\n+1\n+1\n+1\n+ORSXG5BR\n+ORSXG5BS\n+ORSXG5BT\n+ORSXG5BRGIZQ====\n+ORSXG5BUGU3A====\n+Test\n+test \n+test!\ndiff --git a/tests/queries/0_stateless/03447_base32_encode_decode.sql b/tests/queries/0_stateless/03447_base32_encode_decode.sql\nnew file mode 100644\nindex 000000000000..610e90b8e5f8\n--- /dev/null\n+++ b/tests/queries/0_stateless/03447_base32_encode_decode.sql\n@@ -0,0 +1,214 @@\n+SELECT base32Encode('This is a test string');\n+\n+SELECT base32Encode('This is a test string', 'Second arg'); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+\n+DROP TABLE IF EXISTS t3447;\n+CREATE TABLE t3447 (id Int32, str String, b32 String) ENGINE = Memory;\n+INSERT INTO t3447 VALUES\n+    (100, '', ''),\n+    (101, 'f', 'MY======'),\n+    (102, 'fo', 'MZXQ===='),\n+    (103, 'foo', 'MZXW6==='),\n+    (104, 'foob', 'MZXW6YQ='),\n+    (105, 'fooba', 'MZXW6YTB'),\n+    (106, 'foobar', 'MZXW6YTBOI======'),\n+\n+    (200, '\\x00', 'AA======'),\n+    (201, '\\x00\\x00', 'AAAA===='),\n+    (202, '\\x00\\x00\\x00', 'AAAAA==='),\n+    (203, '\\x00\\x00\\x00\\x00', 'AAAAAAA='),\n+    (204, '\\x00\\x00\\x00\\x00\\x00', 'AAAAAAAA'),\n+\n+    (300, '\\xFF', '74======'),\n+    (301, '\\xFF\\xFF', '777Q===='),\n+    (302, '\\xFF\\xFF\\xFF', '77776==='),\n+    (303, '\\xFF\\xFF\\xFF\\xFF', '777777Y='),\n+    (304, '\\xFF\\xFF\\xFF\\xFF\\xFF', '77777777'),\n+\n+    (400, '\\x01\\x23\\x45\\x67\\x89', 'AERUKZ4J'),\n+    (401, '\\xAB\\xCD\\xEF\\x01\\x23', 'VPG66AJD'),\n+\n+    (402, '1234567890', 'GEZDGNBVGY3TQOJQ'),\n+    (403, 'The quick brown fox jumps over the lazy dog', 'KRUGKIDROVUWG2ZAMJZG653OEBTG66BANJ2W24DTEBXXMZLSEB2GQZJANRQXU6JAMRXWO==='),\n+\n+    (500, 'a', 'ME======'),\n+    (501, 'ab', 'MFRA===='),\n+    (502, 'abc', 'MFRGG==='),\n+    (503, 'abcd', 'MFRGGZA='),\n+    (504, 'abcde', 'MFRGGZDF'),\n+    (505, 'abcdef', 'MFRGGZDFMY======'),\n+    (506, 'foo', 'MZXW6==='),\n+    (507, 'foobar', 'MZXW6YTBOI======'),\n+    (508, 'Hello world!', 'JBSWY3DPEB3W64TMMQQQ===='),\n+    (509, 'Hold my beer', 'JBXWYZBANV4SAYTFMVZA===='),\n+    (510, 'Hold another beer', 'JBXWYZBAMFXG65DIMVZCAYTFMVZA===='),\n+    (511, 'And a wine', 'IFXGIIDBEB3WS3TF'),\n+    (512, 'And another wine', 'IFXGIIDBNZXXI2DFOIQHO2LOMU======'),\n+    (513, 'And a lemonade', 'IFXGIIDBEBWGK3LPNZQWIZI='),\n+    (514, 't1Zv2yaZ', 'OQYVU5RSPFQVU==='),\n+    (515, 'And another wine', 'IFXGIIDBNZXXI2DFOIQHO2LOMU======');\n+\n+\n+SELECT 'Part 1 - Encoding';\n+SELECT id, str AS input, hex(str) AS input_hex, base32Encode(str) AS result, b32, result == b32 FROM t3447;\n+\n+SELECT 'Part 2a - Decoding';\n+SELECT id, b32 as input, base32Decode(input) AS result, hex(result) as result_hex, hex(str) as expected_hex, result == str FROM t3447;\n+\n+SELECT 'Part 2b - Decoding lowercase';\n+SELECT id, lower(b32) as input, base32Decode(input) AS result, hex(result) as result_hex, hex(str) as expected_hex, result == str FROM t3447;\n+\n+SELECT 'Part 3 - Roundtrip';\n+SELECT id, str AS input, hex(str) AS input_hex, base32Decode(base32Encode(str)) AS result, result == str FROM t3447;\n+\n+SELECT 'Part 4 - Invalid input';\n+SELECT base32Decode('========'); -- { serverError INCORRECT_DATA }\n+SELECT base32Decode('MZXW6YT!'); -- { serverError INCORRECT_DATA }\n+SELECT base32Decode('MZXW6Y=B'); -- { serverError INCORRECT_DATA }\n+SELECT base32Decode('MZXW6Y=!'); -- { serverError INCORRECT_DATA }\n+SELECT base32Decode('MZXW6Y==='); -- { serverError INCORRECT_DATA }\n+SELECT base32Decode('MZXW6YQ=Q'); -- { serverError INCORRECT_DATA }\n+SELECT base32Decode('MZXW6YQ======'); -- { serverError INCORRECT_DATA }\n+SELECT base32Decode('12345678'); -- { serverError INCORRECT_DATA }\n+SELECT base32Decode('MZXW6YQ'); -- { serverError INCORRECT_DATA }\n+SELECT base32Decode('MZXW6YQ=='); -- { serverError INCORRECT_DATA }\n+SELECT base32Decode('MZXW6YQ==='); -- { serverError INCORRECT_DATA }\n+SELECT base32Decode('MZXW6YQ===='); -- { serverError INCORRECT_DATA }\n+SELECT base32Decode('MZXW6YQ====='); -- { serverError INCORRECT_DATA }\n+SELECT base32Decode('MZXW6YQ======'); -- { serverError INCORRECT_DATA }\n+SELECT base32Decode('MZXW6YQ======='); -- { serverError INCORRECT_DATA }\n+SELECT base32Decode('MZXW6YQ====!=='); -- { serverError INCORRECT_DATA }\n+SELECT base32Decode('MZXW6YQ====A=='); -- { serverError INCORRECT_DATA }\n+SELECT base32Decode('MZXW6YQ======'); -- { serverError INCORRECT_DATA }\n+\n+SELECT 'Part 5 - tryBase32Decode';\n+SELECT tryBase32Decode('========');\n+SELECT tryBase32Decode('MZXW6YT!');\n+SELECT tryBase32Decode('MZXW6Y=B');\n+SELECT tryBase32Decode('MZXW6Y=!');\n+SELECT tryBase32Decode('MZXW6Y===');\n+SELECT tryBase32Decode('MZXW6YQ=Q');\n+SELECT tryBase32Decode('MZXW6YQ======');\n+SELECT tryBase32Decode('12345678');\n+SELECT tryBase32Decode('MZXW6YQ');\n+SELECT tryBase32Decode('MZXW6YQ==');\n+SELECT tryBase32Decode('MZXW6YQ===');\n+SELECT tryBase32Decode('MZXW6YQ====');\n+SELECT tryBase32Decode('MZXW6YQ=====');\n+SELECT tryBase32Decode('MZXW6YQ======');\n+SELECT tryBase32Decode('MZXW6YQ=======');\n+SELECT tryBase32Decode('MZXW6YQ====!==');\n+SELECT tryBase32Decode('MZXW6YQ====A==');\n+SELECT tryBase32Decode('MZXW6YQ======');\n+\n+SELECT 'Part 6 - FixedString encoding + decoding';\n+SELECT val, hex(val), base32Encode(val) as enc_res, hex(base32Decode(enc_res)) as dec_res, dec_res == hex(val) FROM (SELECT arrayJoin([\n+    toFixedString('', 1),\n+    toFixedString('f', 1),\n+    toFixedString('fo', 2),\n+    toFixedString('foo', 3),\n+    toFixedString('foob', 4),\n+    toFixedString('fooba', 5),\n+    toFixedString('foobar', 6),\n+    toFixedString('\\x00', 1),\n+    toFixedString('\\x00\\x00', 2),\n+    toFixedString('\\x00\\x00\\x00', 3),\n+    toFixedString('\\x00\\x00\\x00\\x00', 4),\n+    toFixedString('\\x00\\x00\\x00\\x00\\x00', 5),\n+    toFixedString('\\xFF', 1),\n+    toFixedString('\\xFF\\xFF', 2),\n+    toFixedString('\\xFF\\xFF\\xFF', 3),\n+    toFixedString('\\xFF\\xFF\\xFF\\xFF', 4),\n+    toFixedString('\\xFF\\xFF\\xFF\\xFF\\xFF', 5),\n+    toFixedString('\\x01\\x23\\x45\\x67\\x89', 5),\n+    toFixedString('\\xAB\\xCD\\xEF\\x01\\x23', 5),\n+    toFixedString('1234567890', 10),\n+    toFixedString('The quick brown fox jumps over the lazy dog', 43),\n+    toFixedString('a', 1),\n+    toFixedString('ab', 2),\n+    toFixedString('abc', 3),\n+    toFixedString('abcd', 4),\n+    toFixedString('abcde', 5),\n+    toFixedString('abcdef', 6),\n+    toFixedString('foo', 3),\n+    toFixedString('foobar', 6),\n+    toFixedString('Hello world!', 12),\n+    toFixedString('Hold my beer', 12),\n+    toFixedString('Hold another beer', 18),\n+    toFixedString('And a wine', 10),\n+    toFixedString('And another wine', 17),\n+    toFixedString('And a lemonade', 14),\n+    toFixedString('t1Zv2yaZ', 8),\n+    toFixedString('And another wine', 17)\n+    ]) val);\n+\n+SELECT 'Part 6 - FixedString decoding + encoding';\n+SELECT val, base32Decode(val) as dec_res, hex(dec_res), base32Encode(dec_res) as enc_res, enc_res == val FROM (SELECT arrayJoin([\n+    toFixedString('AAAAA===', 8),\n+    toFixedString('MY======', 8),\n+    toFixedString('MZXQ====', 8),\n+    toFixedString('MZXW6===', 8),\n+    toFixedString('MZXW6YQ=', 8),\n+    toFixedString('MZXW6YTB', 8),\n+    toFixedString('MZXW6YTBOI======', 16),\n+    toFixedString('AA======', 8),\n+    toFixedString('AAAA====', 8),\n+    toFixedString('AAAAA===', 8),\n+    toFixedString('AAAAAAA=', 8),\n+    toFixedString('AAAAAAAA', 8),\n+    toFixedString('74======', 8),\n+    toFixedString('777Q====', 8),\n+    toFixedString('77776===', 8),\n+    toFixedString('777777Y=', 8),\n+    toFixedString('77777777', 8),\n+    toFixedString('AERUKZ4J', 8),\n+    toFixedString('VPG66AJD', 8),\n+    toFixedString('GEZDGNBVGY3TQOJQ', 16),\n+    toFixedString('KRUGKIDROVUWG2ZAMJZG653OEBTG66BANJ2W24DTEBXXMZLSEB2GQZJANRQXU6JAMRXWO===', 96),\n+    toFixedString('ME======', 8),\n+    toFixedString('MFRA====', 8),\n+    toFixedString('MFRGG===', 8),\n+    toFixedString('MFRGGZA=', 8),\n+    toFixedString('MFRGGZDF', 8),\n+    toFixedString('MFRGGZDFMY======', 16),\n+    toFixedString('MZXW6===', 8),\n+    toFixedString('MZXW6YTBOI======', 16),\n+    toFixedString('JBSWY3DPEB3W64TMMQQQ====', 24),\n+    toFixedString('JBXWYZBANV4SAYTFMVZA====', 24),\n+    toFixedString('JBXWYZBAMFXG65DIMVZCAYTFMVZA====', 32),\n+    toFixedString('IFXGIIDBEB3WS3TF', 16),\n+    toFixedString('IFXGIIDBNZXXI2DFOIQHO2LOMU======', 32),\n+    toFixedString('IFXGIIDBEBWGK3LPNZQWIZI=', 24),\n+    toFixedString('OQYVU5RSPFQVU===', 16),\n+    toFixedString('IFXGIIDBNZXXI2DFOIQHO2LOMU======', 32)\n+    ]) val);\n+\n+SELECT 'Part 7 - Similar to 02337_base58.sql';\n+\n+SELECT base32Decode(encoded) FROM (SELECT base32Encode(val) as encoded FROM (SELECT arrayJoin(['', 'f', 'fo', 'foo', 'foob', 'fooba', 'foobar', 'Hello world!']) val));\n+SELECT tryBase32Decode(encoded) FROM (SELECT base32Encode(val) as encoded FROM (SELECT arrayJoin(['', 'f', 'fo', 'foo', 'foob', 'fooba', 'foobar', 'Hello world!']) val));\n+SELECT tryBase32Decode(val) FROM (SELECT arrayJoin(['Hold my beer', 'Hold another beer', '3csAg9', 'And a wine', 'And another wine', 'And a lemonade', 't1Zv2yaZ', 'And another wine']) val);\n+\n+SELECT base32Encode(val) FROM (SELECT arrayJoin(['', 'f', 'fo', 'foo', 'foob', 'fooba', 'foobar']) val);\n+SELECT base32Decode(val) FROM (SELECT arrayJoin(['', 'MY======', 'MZXQ====', 'MZXW6===', 'MZXW6YQ=', 'MZXW6YTB', 'MZXW6YTBOI======']) val);\n+\n+SELECT base32Encode(base32Decode('KRUGKIDROVUWG2ZAMJZG653OEBTG66BANJ2W24DTEBXXMZLSEB2GQZJANRQXU6JAMRXWO===')) == 'KRUGKIDROVUWG2ZAMJZG653OEBTG66BANJ2W24DTEBXXMZLSEB2GQZJANRQXU6JAMRXWO===';\n+SELECT base32Encode('\\xAB\\xCD\\xEF\\x01\\x23') == 'VPG66AJD';\n+\n+SELECT base32Encode(toFixedString('Hold my beer...', 15));\n+SELECT base32Decode(toFixedString('t1Zv2yaZ', 8)); -- { serverError INCORRECT_DATA }\n+SELECT tryBase32Decode(toFixedString('t1Zv2yaZ', 8));\n+\n+SELECT base32Encode(val) FROM (SELECT arrayJoin([toFixedString('', 3), toFixedString('f', 3), toFixedString('fo', 3), toFixedString('foo', 3)]) val);\n+SELECT base32Decode(val) FROM (SELECT arrayJoin([toFixedString('AAAAA===', 8), toFixedString('MYAAA===', 8), toFixedString('MZXQA===', 8), toFixedString('MZXW6===', 8)]) val);\n+\n+SELECT base32Encode(reinterpretAsFixedString(byteSwap(toUInt256('256')))) == 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAA====';\n+SELECT base32Encode(reinterpretAsString(byteSwap(toUInt256('256')))) == 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE======';  -- { reinterpretAsString drops the last null byte hence, encoded value is different than the FixedString version above }\n+\n+SELECT base32Encode('Testing') == 'KRSXG5DJNZTQ====';\n+SELECT base32Decode('KRSXG5DJNZTQ====') == 'Testing';\n+\n+SELECT base32Encode(val) FROM (SELECT arrayJoin(['test1', 'test2', 'test3', 'test123', 'test456']) val);\n+SELECT base32Decode(val) FROM (SELECT arrayJoin(['KRSXG5A=', 'ORSXG5BA', 'ORSXG5BB']) val);\n+\n+DROP TABLE IF EXISTS t3447;\n",
  "problem_statement": "Add Base32 functions\n**Use case**\r\nIt will be useful to implement functions `base32Encode`, `base32Decode` and `tryBase32Decode` just like as for base64.\r\nIn some cases we don't have ability to convert to base32 in our code. For example if we are showing query results in [metabase](https://www.metabase.com/).\n",
  "hints_text": "It will be useful and we already have quite decent implementation of base32 in `GeoHash.cpp`, we can reuse it.\n> \u0411\u043b\u0438\u043d, \u043d\u0430\u0445\u0435\u0440\u0430 \u0442\u0435\u0431\u0435 \u044d\u0442\u043e \u043d\u0430\u0434\u043e ?\r\n> \r\n> en: I wonder why do you need this?\r\n\r\nThanks for translation, but I understand in Russian too. :)\r\nWe actively use base32 in our system because the resulting character set is all one case.\nbut the Base 32 Alphabet of geohash.cpp is not same as https://tools.ietf.org/html/rfc4648\r\n\r\ngeohash.cpp\r\n```\r\nconst char geohash_base32_encode_lookup_table[32] = {\r\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n    'b', 'c', 'd', 'e', 'f', 'g', 'h', 'j', 'k', 'm',\r\n    'n', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',\r\n    'y', 'z',\r\n};\r\n```\r\nrfc4648\r\n```\r\nTable 3: The Base 32 Alphabet\r\n\r\n     Value Encoding  Value Encoding  Value Encoding  Value Encoding\r\n         0 A             9 J            18 S            27 3\r\n         1 B            10 K            19 T            28 4\r\n         2 C            11 L            20 U            29 5\r\n         3 D            12 M            21 V            30 6\r\n         4 E            13 N            22 W            31 7\r\n         5 F            14 O            23 X\r\n         6 G            15 P            24 Y         (pad) =\r\n         7 H            16 Q            25 Z\r\n         8 I            17 R            26 2\r\n```\r\nor\r\n```\r\n                 Table 4: The \"Extended Hex\" Base 32 Alphabet\r\n\r\n         Value Encoding  Value Encoding  Value Encoding  Value Encoding\r\n             0 0             9 9            18 I            27 R\r\n             1 1            10 A            19 J            28 S\r\n             2 2            11 B            20 K            29 T\r\n             3 3            12 C            21 L            30 U\r\n             4 4            13 D            22 M            31 V\r\n             5 5            14 E            23 N\r\n             6 6            15 F            24 O         (pad) =\r\n             7 7            16 G            25 P\r\n             8 8            17 H            26 Q\r\n```\nOk, then we cannot reuse this implementation as is.\nIt's also worth to note that the base32 implementation from geohash is very inefficient (byte-by-byte processing). We can find or write something better.\nFor the impatient ones (rfc4648, nopadding):\r\n\r\n```sql\r\nCREATE OR REPLACE FUNCTION fn_base32Encode\r\nAS (input) -> (\r\n    WITH 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567' as alphabet\r\n    ,(length(input) * 8 + 4) / 5 * 5 as paddedLength\r\n    ,arrayMap(\r\n        i -> substring(\r\n            alphabet,\r\n            reinterpretAsUInt8((bitShiftRight(bitSlice(input, i*5+1, 5),3))) + 1,\r\n            1\r\n        ),\r\n        range(intDiv(paddedLength,5))\r\n    ) as base32Chars    \r\n    select arrayStringConcat(base32Chars)\r\n);\r\n```",
  "created_at": "2025-05-03T16:54:36Z",
  "modified_files": [
    "docs/en/sql-reference/functions/string-functions.md",
    "b/src/Common/Base32.h",
    "b/src/Functions/FunctionBase32Conversion.h",
    "src/Functions/FunctionBase58Conversion.h",
    "src/Functions/FunctionBase64Conversion.h",
    "b/src/Functions/FunctionBaseXXConversion.h",
    "b/src/Functions/base32Decode.cpp",
    "b/src/Functions/base32Encode.cpp",
    "src/Functions/base58Decode.cpp",
    "src/Functions/base58Encode.cpp",
    "src/Functions/base64Decode.cpp",
    "src/Functions/base64Encode.cpp",
    "src/Functions/base64URLDecode.cpp",
    "src/Functions/base64URLEncode.cpp",
    "b/src/Functions/tryBase32Decode.cpp",
    "src/Functions/tryBase58Decode.cpp",
    "src/Functions/tryBase64Decode.cpp",
    "src/Functions/tryBase64URLDecode.cpp"
  ],
  "modified_test_files": [
    "b/src/Common/tests/gtest_base32.cpp",
    "tests/fuzz/all.dict",
    "tests/fuzz/dictionaries/functions.dict",
    "tests/queries/0_stateless/02337_base58.sql",
    "tests/queries/0_stateless/02415_all_new_functions_must_have_version_information.reference",
    "b/tests/queries/0_stateless/03447_base32_encode_decode.reference",
    "b/tests/queries/0_stateless/03447_base32_encode_decode.sql"
  ]
}