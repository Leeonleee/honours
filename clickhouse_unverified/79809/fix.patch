diff --git a/docs/en/sql-reference/functions/string-functions.md b/docs/en/sql-reference/functions/string-functions.md
index 9d3567111e6d..a58dc968b7d4 100644
--- a/docs/en/sql-reference/functions/string-functions.md
+++ b/docs/en/sql-reference/functions/string-functions.md
@@ -1140,6 +1140,102 @@ Returns string `s` converted from the encoding `from` to encoding `to`.
 convertCharset(s, from, to)
 ```
 
+## base32Encode {#base32encode}
+
+Encodes a string using [Base32](https://datatracker.ietf.org/doc/html/rfc4648#section-6).
+
+**Syntax**
+
+```sql
+base32Encode(plaintext)
+```
+
+**Arguments**
+
+- `plaintext` — [String](../data-types/string.md) column or constant.
+
+**Returned value**
+
+- A string containing the encoded value of the argument. [String](../data-types/string.md) or [FixedString](../data-types/fixedstring.md).
+
+**Example**
+
+```sql
+SELECT base32Encode('Encoded');
+```
+
+Result:
+
+```result
+┌─base32Encode('Encoded')─┐
+│ IVXGG33EMVSA====        │
+└─────────────────────────┘
+```
+
+## base32Decode {#base32decode}
+
+Accepts a string and decodes it using [Base32](https://datatracker.ietf.org/doc/html/rfc4648#section-6) encoding scheme.
+
+**Syntax**
+
+```sql
+base32Decode(encoded)
+```
+
+**Arguments**
+
+- `encoded` — [String](../data-types/string.md) or [FixedString](../data-types/fixedstring.md). If the string is not a valid Base32-encoded value, an exception is thrown.
+
+**Returned value**
+
+- A string containing the decoded value of the argument. [String](../data-types/string.md).
+
+**Example**
+
+```sql
+SELECT base32Decode('IVXGG33EMVSA====');
+```
+
+Result:
+
+```result
+┌─base32Decode('IVXGG33EMVSA====')─┐
+│ Encoded                          │
+└──────────────────────────────────┘
+```
+
+## tryBase32Decode {#trybase32decode}
+
+Like `base32Decode` but returns an empty string in case of error.
+
+**Syntax**
+
+```sql
+tryBase32Decode(encoded)
+```
+
+**Parameters**
+
+- `encoded`: [String](../data-types/string.md) or [FixedString](../data-types/fixedstring.md). If the string is not a valid Base32-encoded value, returns an empty string in case of error.
+
+**Returned value**
+
+- A string containing the decoded value of the argument.
+
+**Examples**
+
+Query:
+
+```sql
+SELECT tryBase32Decode('IVXGG33EMVSA====') as res, tryBase32Decode('invalid') as res_invalid;
+```
+
+```response
+┌─res─────┬─res_invalid─┐
+│ Encoded │             │
+└─────────┴─────────────┘
+```
+
 ## base58Encode {#base58encode}
 
 Encodes a string using [Base58](https://datatracker.ietf.org/doc/html/draft-msporny-base58) in the "Bitcoin" alphabet.
diff --git a/src/Common/Base32.h b/src/Common/Base32.h
new file mode 100644
index 000000000000..1abb8eb2613f
--- /dev/null
+++ b/src/Common/Base32.h
@@ -0,0 +1,155 @@
+#pragma once
+
+#include <optional>
+#include <base/types.h>
+#include "base/defines.h"
+
+namespace DB
+{
+
+struct Base32Rfc4648
+{
+    static constexpr char encodeChar(UInt8 c)
+    {
+        chassert(c < 32);
+        if (c < 26)
+            return 'A' + c;
+        return '2' + (c - 26);
+    }
+    static constexpr UInt8 decodeChar(UInt8 c)
+    {
+        if (c >= 'A' && c <= 'Z')
+            return c - 'A';
+
+        // Handle lowercase letters the same as uppercase
+        if (c >= 'a' && c <= 'z')
+            return c - 'a';
+
+        if (c >= '2' && c <= '7')
+            return (c - '2') + 26;
+
+        return 0xFF;
+    }
+    static constexpr Int8 padding_char = '=';
+};
+
+template <typename Traits, typename Tag>
+struct Base32;
+
+struct Base32NaiveTag;
+
+template <typename Traits>
+struct Base32<Traits, Base32NaiveTag>
+{
+    static size_t encodeBase32(const UInt8 * src, size_t src_length, UInt8 * dst)
+    {
+        //  in:      [01010101] [11001100] [11110000]
+
+        // out:      01010 | 11100 | 11001 | 11100 | 000
+        //           [ 5b ]  [ 5b ]  [ 5b ]  [ 5b ] ...
+
+        size_t ipos = 0;
+        size_t opos = 0;
+        uint32_t buffer = 0;
+        uint8_t bits_left = 0;
+
+        while (ipos < src_length)
+        {
+            buffer = (buffer << 8) | src[ipos++];
+            bits_left += 8;
+
+            while (bits_left >= 5)
+            {
+                dst[opos++] = Traits::encodeChar((buffer >> (bits_left - 5)) & 0x1F);
+                bits_left -= 5;
+            }
+        }
+
+        if (bits_left > 0)
+        {
+            dst[opos++] = Traits::encodeChar((buffer << (5 - bits_left)) & 0x1F);
+        }
+
+        while (opos % 8 != 0)
+        {
+            dst[opos++] = Traits::padding_char;
+        }
+
+        return opos;
+    }
+
+    /// This function might write into dst even if decoding fails (nullopt returned)
+    static std::optional<size_t> decodeBase32(const UInt8 * src, size_t src_length, UInt8 * dst)
+    {
+        if (src_length % 8 != 0)
+        {
+            return std::nullopt;
+        }
+
+        size_t dst_pos = 0;
+        size_t buffer = 0;
+        int bits = 0;
+        size_t pad_count = 0;
+        bool padding_started = false;
+
+        for (size_t i = 0; i < src_length; ++i)
+        {
+            UInt8 c = src[i];
+
+            if (c == Traits::padding_char)
+            {
+                padding_started = true;
+                pad_count++;
+                continue;
+            }
+
+            if (padding_started)
+            {
+                return std::nullopt; // Only padding was expected
+            }
+
+            UInt8 value = Traits::decodeChar(c);
+            if (value == 0xFF)
+            {
+                return std::nullopt; // Invalid symbol
+            }
+
+            // Stuff in decoded bits, write out if there's enough
+            buffer = (buffer << 5) | value;
+            bits += 5;
+
+            if (bits >= 8)
+            {
+                bits -= 8;
+                dst[dst_pos++] = (buffer >> bits) & 0xFF;
+            }
+        }
+
+        if (pad_count > 0)
+        {
+            if (!(pad_count == 1 || pad_count == 3 || pad_count == 4 || pad_count == 6))
+            {
+                return std::nullopt;
+            }
+
+            if (bits > 0 && (buffer & ((1 << bits) - 1)) != 0)
+            {
+                return std::nullopt;
+            }
+        }
+
+        return dst_pos;
+    }
+};
+
+inline size_t encodeBase32(const UInt8 * src, size_t src_length, UInt8 * dst)
+{
+    return Base32<Base32Rfc4648, Base32NaiveTag>::encodeBase32(src, src_length, dst);
+}
+
+inline std::optional<size_t> decodeBase32(const UInt8 * src, size_t src_length, UInt8 * dst)
+{
+    return Base32<Base32Rfc4648, Base32NaiveTag>::decodeBase32(src, src_length, dst);
+}
+
+}
diff --git a/src/Functions/FunctionBase32Conversion.h b/src/Functions/FunctionBase32Conversion.h
new file mode 100644
index 000000000000..c30b9d976d6a
--- /dev/null
+++ b/src/Functions/FunctionBase32Conversion.h
@@ -0,0 +1,45 @@
+#pragma once
+
+#include <Functions/FunctionBaseXXConversion.h>
+
+#include <Common/Base32.h>
+
+namespace DB
+{
+struct Base32EncodeTraits
+{
+    template <typename Col>
+    static size_t getBufferSize(Col const & src_column)
+    {
+        auto const src_length = src_column.getChars().size();
+        auto const string_count = src_column.size();
+        /// Every 5 bytes becomes 8 bytes in base32
+        /// Add padding for incomplete blocks and round up
+        /// Plus one byte for null terminator for each string
+        return ((src_length + 4) / 5 * 8 + 1) * string_count;
+    }
+
+    static size_t perform(std::string_view src, UInt8 * dst)
+    {
+        return encodeBase32(reinterpret_cast<const UInt8 *>(src.data()), src.size(), dst);
+    }
+};
+
+struct Base32DecodeTraits
+{
+    template <typename Col>
+    static size_t getBufferSize(Col const & src_column)
+    {
+        auto const string_length = src_column.byteSize();
+        auto const string_count = src_column.size();
+        /// decoded size is at most length of encoded (every 8 bytes becomes at most 5 bytes)
+        /// plus one byte for null terminator for each string
+        return ((string_length * 5 + 7) / 8 + 1) * string_count;
+    }
+
+    static std::optional<size_t> perform(std::string_view src, UInt8 * dst)
+    {
+        return decodeBase32(reinterpret_cast<const UInt8 *>(src.data()), src.size(), dst);
+    }
+};
+}
diff --git a/src/Functions/FunctionBase58Conversion.h b/src/Functions/FunctionBase58Conversion.h
index 655db8b63a22..3b77bbe213ee 100644
--- a/src/Functions/FunctionBase58Conversion.h
+++ b/src/Functions/FunctionBase58Conversion.h
@@ -1,242 +1,44 @@
 #pragma once
 
-#include <cstring>
-#include <base/MemorySanitizer.h>
-#include <Columns/ColumnConst.h>
-#include <Columns/ColumnFixedString.h>
-#include <Columns/ColumnString.h>
-#include <DataTypes/DataTypeString.h>
-#include <Functions/FunctionFactory.h>
-#include <Functions/FunctionHelpers.h>
-#include <IO/WriteHelpers.h>
-#include <Common/Base58.h>
+#include <Functions/FunctionBaseXXConversion.h>
 
+#include <Common/Base58.h>
 
 namespace DB
 {
-
-namespace ErrorCodes
-{
-    extern const int ILLEGAL_COLUMN;
-    extern const int BAD_ARGUMENTS;
-}
-
-struct Base58Encode
+struct Base58EncodeTraits
 {
-    static constexpr auto name = "base58Encode";
-
-    static void processString(const ColumnString & src_column, ColumnString::MutablePtr & dst_column, size_t input_rows_count)
+    template <typename Col>
+    static size_t getBufferSize(Col const & src_column)
     {
-        auto & dst_data = dst_column->getChars();
-        auto & dst_offsets = dst_column->getOffsets();
-
+        auto const src_length = src_column.getChars().size();
         /// Base58 has efficiency of 73% (8/11) [https://monerodocs.org/cryptography/base58/],
         /// and we take double scale to avoid any reallocation.
-        size_t max_result_size = static_cast<size_t>(ceil(2 * src_column.getChars().size() + 1));
-
-        dst_data.resize(max_result_size);
-        dst_offsets.resize(input_rows_count);
-
-        const ColumnString::Offsets & src_offsets = src_column.getOffsets();
-
-        const auto * src = src_column.getChars().data();
-        auto * dst = dst_data.data();
-
-        size_t prev_src_offset = 0;
-        size_t current_dst_offset = 0;
-
-        for (size_t row = 0; row < input_rows_count; ++row)
-        {
-            size_t current_src_offset = src_offsets[row];
-            size_t src_length = current_src_offset - prev_src_offset - 1;
-            size_t encoded_size = encodeBase58(&src[prev_src_offset], src_length, &dst[current_dst_offset]);
-            prev_src_offset = current_src_offset;
-            current_dst_offset += encoded_size;
-            dst[current_dst_offset] = 0;
-            ++current_dst_offset;
-
-            dst_offsets[row] = current_dst_offset;
-        }
-
-        dst_data.resize(current_dst_offset);
+        constexpr auto oversize = 2;
+        return static_cast<size_t>(ceil(oversize * src_length + 1));
     }
 
-    static void processFixedString(const ColumnFixedString & src_column, ColumnString::MutablePtr & dst_column, size_t input_rows_count)
+    static size_t perform(std::string_view src, UInt8 * dst)
     {
-        auto & dst_data = dst_column->getChars();
-        auto & dst_offsets = dst_column->getOffsets();
-
-        /// Base58 has efficiency of 73% (8/11) [https://monerodocs.org/cryptography/base58/],
-        /// and we take double scale to avoid any reallocation.
-        size_t max_result_size = static_cast<size_t>(ceil(2 * src_column.getChars().size() + 1));
-
-        dst_data.resize(max_result_size);
-        dst_offsets.resize(input_rows_count);
-
-        const auto * src = src_column.getChars().data();
-        auto * dst = dst_data.data();
-
-        size_t N = src_column.getN();
-        size_t current_dst_offset = 0;
-
-        for (size_t row = 0; row < input_rows_count; ++row)
-        {
-            size_t encoded_size = encodeBase58(&src[row * N], N, &dst[current_dst_offset]);
-            current_dst_offset += encoded_size;
-            dst[current_dst_offset] = 0;
-            ++current_dst_offset;
-
-            dst_offsets[row] = current_dst_offset;
-        }
-
-        dst_data.resize(current_dst_offset);
+        return encodeBase58(reinterpret_cast<const UInt8 *>(src.data()), src.size(), dst);
     }
 };
 
-enum class Base58DecodeErrorHandling : uint8_t
+struct Base58DecodeTraits
 {
-    ThrowException,
-    ReturnEmptyString
-};
-
-template <typename Name, Base58DecodeErrorHandling ErrorHandling>
-struct Base58Decode
-{
-    static constexpr auto name = Name::name;
-
-    static void processString(const ColumnString & src_column, ColumnString::MutablePtr & dst_column, size_t input_rows_count)
+    template <typename Col>
+    static size_t getBufferSize(Col const & src_column)
     {
-        auto & dst_data = dst_column->getChars();
-        auto & dst_offsets = dst_column->getOffsets();
-
-        /// Base58 has efficiency of 73% (8/11) [https://monerodocs.org/cryptography/base58/],
-        /// and decoded value will be no longer than source.
-        size_t max_result_size = src_column.getChars().size() + 1;
-
-        dst_data.resize(max_result_size);
-        dst_offsets.resize(input_rows_count);
-
-        const ColumnString::Offsets & src_offsets = src_column.getOffsets();
-
-        const auto * src = src_column.getChars().data();
-        auto * dst = dst_data.data();
-
-        size_t prev_src_offset = 0;
-        size_t current_dst_offset = 0;
-
-        for (size_t row = 0; row < input_rows_count; ++row)
-        {
-            size_t current_src_offset = src_offsets[row];
-            size_t src_length = current_src_offset - prev_src_offset - 1;
-            std::optional<size_t> decoded_size = decodeBase58(&src[prev_src_offset], src_length, &dst[current_dst_offset]);
-            if (!decoded_size)
-            {
-                if constexpr (ErrorHandling == Base58DecodeErrorHandling::ThrowException)
-                    throw Exception(ErrorCodes::BAD_ARGUMENTS, "Invalid Base58 value, cannot be decoded");
-                else
-                    decoded_size = 0;
-            }
-
-            prev_src_offset = current_src_offset;
-            current_dst_offset += *decoded_size;
-            dst[current_dst_offset] = 0;
-            ++current_dst_offset;
-
-            dst_offsets[row] = current_dst_offset;
-        }
-
-        dst_data.resize(current_dst_offset);
+        auto const string_length = src_column.byteSize();
+        auto const string_count = src_column.size();
+        /// decoded size is at most length of encoded (every 8 bytes becomes at most 6 bytes)
+        /// plus one byte for null terminator for each string
+        return ((string_length * 6 + 7) / 8 + 1) * string_count;
     }
 
-    static void processFixedString(const ColumnFixedString & src_column, ColumnString::MutablePtr & dst_column, size_t input_rows_count)
+    static std::optional<size_t> perform(std::string_view src, UInt8 * dst)
     {
-        auto & dst_data = dst_column->getChars();
-        auto & dst_offsets = dst_column->getOffsets();
-
-        /// Base58 has efficiency of 73% (8/11) [https://monerodocs.org/cryptography/base58/],
-        /// and decoded value will be no longer than source.
-        size_t max_result_size = src_column.getChars().size() + 1;
-
-        dst_data.resize(max_result_size);
-        dst_offsets.resize(input_rows_count);
-
-        const auto * src = src_column.getChars().data();
-        auto * dst = dst_data.data();
-
-        size_t N = src_column.getN();
-        size_t current_dst_offset = 0;
-
-        for (size_t row = 0; row < input_rows_count; ++row)
-        {
-            std::optional<size_t> decoded_size = decodeBase58(&src[row * N], N, &dst[current_dst_offset]);
-            if (!decoded_size)
-            {
-                if constexpr (ErrorHandling == Base58DecodeErrorHandling::ThrowException)
-                    throw Exception(ErrorCodes::BAD_ARGUMENTS, "Invalid Base58 value, cannot be decoded");
-                else
-                    decoded_size = 0;
-            }
-
-            current_dst_offset += *decoded_size;
-            dst[current_dst_offset] = 0;
-            ++current_dst_offset;
-
-            dst_offsets[row] = current_dst_offset;
-        }
-
-        dst_data.resize(current_dst_offset);
-    }
-};
-
-template <typename Func>
-class FunctionBase58Conversion : public IFunction
-{
-public:
-    static constexpr auto name = Func::name;
-
-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionBase58Conversion>(); }
-    String getName() const override { return Func::name; }
-    size_t getNumberOfArguments() const override { return 1; }
-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
-    bool useDefaultImplementationForConstants() const override { return true; }
-    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }
-
-    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
-    {
-        FunctionArgumentDescriptors args{
-            {"arg", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isStringOrFixedString), nullptr, "String or FixedString"}
-        };
-        validateFunctionArguments(*this, arguments, args);
-
-        return std::make_shared<DataTypeString>();
-    }
-
-    DataTypePtr getReturnTypeForDefaultImplementationForDynamic() const override
-    {
-        return std::make_shared<DataTypeString>();
-    }
-
-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override
-    {
-        const ColumnPtr col = arguments[0].column;
-
-        if (const ColumnString * col_string = checkAndGetColumn<ColumnString>(col.get()))
-        {
-            auto col_res = ColumnString::create();
-            Func::processString(*col_string, col_res, input_rows_count);
-            return col_res;
-        }
-        else if (const ColumnFixedString * col_fixed_string = checkAndGetColumn<ColumnFixedString>(col.get()))
-        {
-            auto col_res = ColumnString::create();
-            Func::processFixedString(*col_fixed_string, col_res, input_rows_count);
-            return col_res;
-        }
-
-        throw Exception(
-            ErrorCodes::ILLEGAL_COLUMN,
-            "Illegal column {} of first argument of function {}, must be String or FixedString",
-            arguments[0].column->getName(), getName());
+        return decodeBase58(reinterpret_cast<const UInt8 *>(src.data()), src.size(), dst);
     }
 };
 }
diff --git a/src/Functions/FunctionBase64Conversion.h b/src/Functions/FunctionBase64Conversion.h
index ed007250e541..38e4025c9250 100644
--- a/src/Functions/FunctionBase64Conversion.h
+++ b/src/Functions/FunctionBase64Conversion.h
@@ -6,8 +6,7 @@
 #    include <Columns/ColumnFixedString.h>
 #    include <Columns/ColumnString.h>
 #    include <DataTypes/DataTypeString.h>
-#    include <Functions/FunctionHelpers.h>
-#    include <Functions/IFunction.h>
+#    include <Functions/FunctionBaseXXConversion.h>
 #    include <Interpreters/Context_fwd.h>
 #    include <libbase64.h>
 
@@ -16,11 +15,6 @@
 
 namespace DB
 {
-namespace ErrorCodes
-{
-    extern const int ILLEGAL_COLUMN;
-    extern const int INCORRECT_DATA;
-}
 
 enum class Base64Variant : uint8_t
 {
@@ -92,13 +86,15 @@ inline size_t postprocessBase64URL(UInt8 * dst, size_t out_len)
     return out_len;
 }
 
-template <Base64Variant variant>
-struct Base64Encode
-{
-    static constexpr auto name = (variant == Base64Variant::Normal) ? "base64Encode" : "base64URLEncode";
 
-    static size_t getBufferSize(size_t string_length, size_t string_count)
+template<Base64Variant variant>
+struct Base64EncodeTraits
+{
+    template<typename Col>
+    static size_t getBufferSize(Col const& src_column)
     {
+        auto const string_length = src_column.byteSize();
+        auto const string_count = src_column.size();
         return ((string_length - string_count) / 3 + string_count) * 4 + string_count;
     }
 
@@ -118,52 +114,18 @@ struct Base64Encode
     }
 };
 
-template <Base64Variant variant>
-struct Base64Decode
+template<Base64Variant variant>
+struct Base64DecodeTraits
 {
-    static constexpr auto name = (variant == Base64Variant::Normal) ? "base64Decode" : "base64URLDecode";
-
-    static size_t getBufferSize(size_t string_length, size_t string_count)
+    template<typename Col>
+    static size_t getBufferSize(Col const& src_column)
     {
+        auto const string_length = src_column.byteSize();
+        auto const string_count = src_column.size();
         return ((string_length - string_count) / 4 + string_count) * 3 + string_count;
     }
 
-    static size_t perform(std::string_view src, UInt8 * dst)
-    {
-        int rc;
-        size_t outlen = 0;
-        if constexpr (variant == Base64Variant::URL)
-        {
-            std::string src_padded = preprocessBase64URL(src);
-            rc = base64_decode(src_padded.data(), src_padded.size(), reinterpret_cast<char *>(dst), &outlen, 0);
-        }
-        else
-        {
-            rc = base64_decode(src.data(), src.size(), reinterpret_cast<char *>(dst), &outlen, 0);
-        }
-
-        if (rc != 1)
-            throw Exception(
-                ErrorCodes::INCORRECT_DATA,
-                "Failed to {} input '{}'",
-                name,
-                String(reinterpret_cast<const char *>(src.data()), src.size()));
-
-        return outlen;
-    }
-};
-
-template <Base64Variant variant>
-struct TryBase64Decode
-{
-    static constexpr auto name = (variant == Base64Variant::Normal) ? "tryBase64Decode" : "tryBase64URLDecode";
-
-    static size_t getBufferSize(size_t string_length, size_t string_count)
-    {
-        return Base64Decode<variant>::getBufferSize(string_length, string_count);
-    }
-
-    static size_t perform(std::string_view src, UInt8 * dst)
+    static std::optional<size_t> perform(std::string_view src, UInt8 * dst)
     {
         int rc;
         size_t outlen = 0;
@@ -176,128 +138,12 @@ struct TryBase64Decode
         {
             rc = base64_decode(src.data(), src.size(), reinterpret_cast<char *>(dst), &outlen, 0);
         }
-
-        if (rc != 1)
-            outlen = 0;
-
+        if (rc != 1) [[unlikely]]
+            return std::nullopt;
         return outlen;
     }
 };
 
-template <typename Func>
-class FunctionBase64Conversion : public IFunction
-{
-public:
-    static constexpr auto name = Func::name;
-
-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionBase64Conversion>(); }
-    String getName() const override { return Func::name; }
-    size_t getNumberOfArguments() const override { return 1; }
-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
-    bool useDefaultImplementationForConstants() const override { return true; }
-
-    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
-    {
-        FunctionArgumentDescriptors mandatory_arguments{
-            {"value", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isStringOrFixedString), nullptr, "String or FixedString"}
-        };
-
-        validateFunctionArguments(*this, arguments, mandatory_arguments);
-
-        return std::make_shared<DataTypeString>();
-    }
-
-    DataTypePtr getReturnTypeForDefaultImplementationForDynamic() const override
-    {
-        return std::make_shared<DataTypeString>();
-    }
-
-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override
-    {
-        const auto & input_column = arguments[0].column;
-        if (const auto * src_column_as_fixed_string = checkAndGetColumn<ColumnFixedString>(&*input_column))
-            return execute(*src_column_as_fixed_string, input_rows_count);
-        if (const auto * src_column_as_string = checkAndGetColumn<ColumnString>(&*input_column))
-            return execute(*src_column_as_string, input_rows_count);
-
-        throw Exception(
-            ErrorCodes::ILLEGAL_COLUMN,
-            "Illegal column {} of first argument of function {}, must be of type FixedString or String.",
-            input_column->getName(),
-            getName());
-    }
-
-private:
-    static ColumnPtr execute(const ColumnString & src_column, size_t src_row_count)
-    {
-        auto dst_column = ColumnString::create();
-        auto & dst_chars = dst_column->getChars();
-        auto & dst_offsets = dst_column->getOffsets();
-
-        const auto reserve = Func::getBufferSize(src_column.byteSize(), src_column.size());
-        dst_chars.resize(reserve);
-        dst_offsets.resize(src_row_count);
-
-        const auto & src_chars = src_column.getChars();
-        const auto & src_offsets = src_column.getOffsets();
-
-        auto * dst = dst_chars.data();
-        auto * dst_pos = dst;
-        const auto * src = reinterpret_cast<const char *>(src_chars.data());
-
-        size_t src_offset_prev = 0;
-        for (size_t row = 0; row < src_row_count; ++row)
-        {
-            const size_t src_length = src_offsets[row] - src_offset_prev - 1;
-            const size_t outlen = Func::perform({src, src_length}, dst_pos);
-
-            src += src_length + 1;
-            dst_pos += outlen;
-            *dst_pos = '\0';
-            dst_pos += 1;
-
-            dst_offsets[row] = dst_pos - dst;
-            src_offset_prev = src_offsets[row];
-        }
-
-        dst_chars.resize(dst_pos - dst);
-        return dst_column;
-    }
-
-    static ColumnPtr execute(const ColumnFixedString & src_column, size_t src_row_count)
-    {
-        auto dst_column = ColumnString::create();
-        auto & dst_chars = dst_column->getChars();
-        auto & dst_offsets = dst_column->getOffsets();
-
-        const auto reserve = Func::getBufferSize(src_column.byteSize(), src_column.size());
-        dst_chars.resize(reserve);
-        dst_offsets.resize(src_row_count);
-
-        const auto & src_chars = src_column.getChars();
-        const auto & src_n = src_column.getN();
-
-        auto * dst = dst_chars.data();
-        auto * dst_pos = dst;
-        const auto * src = reinterpret_cast<const char *>(src_chars.data());
-
-        for (size_t row = 0; row < src_row_count; ++row)
-        {
-            const auto outlen = Func::perform({src, src_n}, dst_pos);
-
-            src += src_n;
-            dst_pos += outlen;
-            *dst_pos = '\0';
-            dst_pos += 1;
-
-            dst_offsets[row] = dst_pos - dst;
-        }
-
-        dst_chars.resize(dst_pos - dst);
-        return dst_column;
-    }
-};
-
 }
 
 #endif
diff --git a/src/Functions/FunctionBaseXXConversion.h b/src/Functions/FunctionBaseXXConversion.h
new file mode 100644
index 000000000000..b5b3ac43d04f
--- /dev/null
+++ b/src/Functions/FunctionBaseXXConversion.h
@@ -0,0 +1,230 @@
+#pragma once
+
+#include <Columns/ColumnConst.h>
+#include <Columns/ColumnFixedString.h>
+#include <Columns/ColumnString.h>
+#include <DataTypes/DataTypeString.h>
+#include <Functions/FunctionFactory.h>
+#include <Functions/FunctionHelpers.h>
+#include <IO/WriteHelpers.h>
+#include <fmt/format.h>
+#include <Common/Base58.h>
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+extern const int ILLEGAL_COLUMN;
+extern const int INCORRECT_DATA;
+}
+
+template <typename Traits, typename Name>
+struct BaseXXEncode
+{
+    static constexpr auto name = Name::name;
+
+    static void processString(const ColumnString & src_column, ColumnString::MutablePtr & dst_column, size_t input_rows_count)
+    {
+        auto & dst_data = dst_column->getChars();
+        auto & dst_offsets = dst_column->getOffsets();
+        size_t const max_result_size = Traits::getBufferSize(src_column);
+
+        dst_data.resize(max_result_size);
+        dst_offsets.resize(input_rows_count);
+
+        const ColumnString::Offsets & src_offsets = src_column.getOffsets();
+
+        const auto * src = reinterpret_cast<const char *>(src_column.getChars().data());
+        auto * dst = dst_data.data();
+
+        size_t prev_src_offset = 0;
+        size_t current_dst_offset = 0;
+
+        for (size_t row = 0; row < input_rows_count; ++row)
+        {
+            size_t current_src_offset = src_offsets[row];
+            size_t src_length = current_src_offset - prev_src_offset - 1;
+            size_t encoded_size = Traits::perform({&src[prev_src_offset], src_length}, &dst[current_dst_offset]);
+            prev_src_offset = current_src_offset;
+            current_dst_offset += encoded_size;
+            dst[current_dst_offset] = '\0';
+            ++current_dst_offset;
+
+            dst_offsets[row] = current_dst_offset;
+        }
+
+        dst_data.resize(current_dst_offset);
+    }
+
+    static void processFixedString(const ColumnFixedString & src_column, ColumnString::MutablePtr & dst_column, size_t input_rows_count)
+    {
+        auto & dst_data = dst_column->getChars();
+        auto & dst_offsets = dst_column->getOffsets();
+        size_t const max_result_size = Traits::getBufferSize(src_column);
+
+        dst_data.resize(max_result_size);
+        dst_offsets.resize(input_rows_count);
+
+        const auto * src = reinterpret_cast<const char *>(src_column.getChars().data());
+        auto * dst = dst_data.data();
+
+        size_t const N = src_column.getN();
+        size_t current_dst_offset = 0;
+
+        for (size_t row = 0; row < input_rows_count; ++row)
+        {
+            size_t encoded_size = Traits::perform({&src[row * N], N}, &dst[current_dst_offset]);
+            current_dst_offset += encoded_size;
+            dst[current_dst_offset] = 0;
+            ++current_dst_offset;
+
+            dst_offsets[row] = current_dst_offset;
+        }
+
+        dst_data.resize(current_dst_offset);
+    }
+};
+
+enum class BaseXXDecodeErrorHandling : uint8_t
+{
+    ThrowException,
+    ReturnEmptyString
+};
+
+template <typename Traits, typename Name, BaseXXDecodeErrorHandling ErrorHandling>
+struct BaseXXDecode
+{
+    static constexpr auto name = Name::name;
+
+    static void processString(const ColumnString & src_column, ColumnString::MutablePtr & dst_column, size_t input_rows_count)
+    {
+        auto & dst_data = dst_column->getChars();
+        auto & dst_offsets = dst_column->getOffsets();
+        size_t max_result_size = Traits::getBufferSize(src_column);
+
+        dst_data.resize(max_result_size);
+        dst_offsets.resize(input_rows_count);
+
+        const ColumnString::Offsets & src_offsets = src_column.getOffsets();
+
+        const auto * src = reinterpret_cast<const char *>(src_column.getChars().data());
+        auto * dst = dst_data.data();
+
+        size_t prev_src_offset = 0;
+        size_t current_dst_offset = 0;
+
+        for (size_t row = 0; row < input_rows_count; ++row)
+        {
+            size_t current_src_offset = src_offsets[row];
+            size_t src_length = current_src_offset - prev_src_offset - 1;
+            std::optional<size_t> decoded_size = Traits::perform({&src[prev_src_offset], src_length}, &dst[current_dst_offset]);
+            if (!decoded_size)
+            {
+                if constexpr (ErrorHandling == BaseXXDecodeErrorHandling::ThrowException)
+                    throw Exception(
+                        ErrorCodes::INCORRECT_DATA,
+                        "Invalid {} value ({}), cannot be decoded",
+                        name,
+                        String(&src[prev_src_offset], src_length));
+                else
+                    decoded_size = 0;
+            }
+
+            prev_src_offset = current_src_offset;
+            current_dst_offset += *decoded_size;
+            dst[current_dst_offset] = '\0';
+            ++current_dst_offset;
+
+            dst_offsets[row] = current_dst_offset;
+        }
+
+        dst_data.resize(current_dst_offset);
+    }
+
+    static void processFixedString(const ColumnFixedString & src_column, ColumnString::MutablePtr & dst_column, size_t input_rows_count)
+    {
+        auto & dst_data = dst_column->getChars();
+        auto & dst_offsets = dst_column->getOffsets();
+        size_t max_result_size = Traits::getBufferSize(src_column);
+
+        dst_data.resize(max_result_size);
+        dst_offsets.resize(input_rows_count);
+
+        const auto * src = reinterpret_cast<const char *>(src_column.getChars().data());
+        auto * dst = dst_data.data();
+
+        size_t N = src_column.getN();
+        size_t current_dst_offset = 0;
+
+        for (size_t row = 0; row < input_rows_count; ++row)
+        {
+            std::optional<size_t> decoded_size = Traits::perform({&src[row * N], N}, &dst[current_dst_offset]);
+            if (!decoded_size)
+            {
+                if constexpr (ErrorHandling == BaseXXDecodeErrorHandling::ThrowException)
+                    throw Exception(ErrorCodes::INCORRECT_DATA, "Invalid {} value ({}), cannot be decoded", name, String(&src[row * N], N));
+                else
+                    decoded_size = 0;
+            }
+
+            current_dst_offset += *decoded_size;
+            dst[current_dst_offset] = '\0';
+            ++current_dst_offset;
+
+            dst_offsets[row] = current_dst_offset;
+        }
+
+        dst_data.resize(current_dst_offset);
+    }
+};
+
+template <typename Func>
+class FunctionBaseXXConversion : public IFunction
+{
+public:
+    static constexpr auto name = Func::name;
+
+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionBaseXXConversion>(); }
+    String getName() const override { return Func::name; }
+    size_t getNumberOfArguments() const override { return 1; }
+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
+    bool useDefaultImplementationForConstants() const override { return true; }
+
+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
+    {
+        FunctionArgumentDescriptors args{
+            {"arg", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isStringOrFixedString), nullptr, "String or FixedString"}};
+        validateFunctionArguments(*this, arguments, args);
+
+        return std::make_shared<DataTypeString>();
+    }
+
+    DataTypePtr getReturnTypeForDefaultImplementationForDynamic() const override { return std::make_shared<DataTypeString>(); }
+
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override
+    {
+        const ColumnPtr col = arguments[0].column;
+
+        if (const ColumnString * col_string = checkAndGetColumn<ColumnString>(col.get()))
+        {
+            auto col_res = ColumnString::create();
+            Func::processString(*col_string, col_res, input_rows_count);
+            return col_res;
+        }
+        else if (const ColumnFixedString * col_fixed_string = checkAndGetColumn<ColumnFixedString>(col.get()))
+        {
+            auto col_res = ColumnString::create();
+            Func::processFixedString(*col_fixed_string, col_res, input_rows_count);
+            return col_res;
+        }
+
+        throw Exception(
+            ErrorCodes::ILLEGAL_COLUMN,
+            "Illegal column {} of first argument of function {}, must be String or FixedString",
+            arguments[0].column->getName(),
+            getName());
+    }
+};
+
+}
diff --git a/src/Functions/base32Decode.cpp b/src/Functions/base32Decode.cpp
new file mode 100644
index 000000000000..9af117b98f0f
--- /dev/null
+++ b/src/Functions/base32Decode.cpp
@@ -0,0 +1,33 @@
+#include <Functions/FunctionBase32Conversion.h>
+#include <Functions/FunctionFactory.h>
+
+namespace DB
+{
+namespace
+{
+struct NameBase32Decode
+{
+    static constexpr auto name = "base32Decode";
+};
+
+using Base32DecodeImpl = BaseXXDecode<Base32DecodeTraits, NameBase32Decode, BaseXXDecodeErrorHandling::ThrowException>;
+using FunctionBase32Decode = FunctionBaseXXConversion<Base32DecodeImpl>;
+}
+
+REGISTER_FUNCTION(Base32Decode)
+{
+    factory.registerFunction<FunctionBase32Decode>(FunctionDocumentation{
+        .description = R"(
+Decode a [Base32](https://datatracker.ietf.org/doc/html/rfc4648) encoded string. The input string must be a valid Base32 encoded string, otherwise an exception will be thrown.)",
+        .arguments = {
+            {"arg", "A Base32 (rfc4648) encoded string"},
+        },
+        .examples = {
+            {"simple_decoding1", "SELECT base32Decode('ME======')", "a"},
+            {"simple_decoding2", "SELECT base32Decode('JBSWY3DP')", "Hello"},
+            {"empty_string", "SELECT base32Decode('')", ""},
+            {"non_ascii", "SELECT hex(base32Decode('4W2HIXV4'))", "E5B4745EBC"},
+        },
+        .category = FunctionDocumentation::Category::String});
+}
+}
diff --git a/src/Functions/base32Encode.cpp b/src/Functions/base32Encode.cpp
new file mode 100644
index 000000000000..55785b781aa0
--- /dev/null
+++ b/src/Functions/base32Encode.cpp
@@ -0,0 +1,31 @@
+#include <Functions/FunctionBase32Conversion.h>
+#include <Functions/FunctionFactory.h>
+
+namespace DB
+{
+namespace
+{
+struct NameBase32Encode
+{
+    static constexpr auto name = "base32Encode";
+};
+
+using Base32EncodeImpl = BaseXXEncode<Base32EncodeTraits, NameBase32Encode>;
+using FunctionBase32Encode = FunctionBaseXXConversion<Base32EncodeImpl>;
+}
+
+REGISTER_FUNCTION(Base32Encode)
+{
+    factory.registerFunction<FunctionBase32Encode>(FunctionDocumentation{
+        .description = R"(
+Encode a string with [Base32](https://datatracker.ietf.org/doc/html/rfc4648) encoding.)",
+        .arguments = {
+            {"arg", "A string to be encoded"},
+        },
+        .examples = {
+            {"simple_encoding1", "SELECT base32Encode('a')", "ME======"},
+            {"simple_encoding2", "SELECT base32Encode('Hello')", "JBSWY3DP"}
+        },
+        .category = FunctionDocumentation::Category::String});
+}
+}
diff --git a/src/Functions/base58Decode.cpp b/src/Functions/base58Decode.cpp
index 4c437473f814..c5d340fe5a18 100644
--- a/src/Functions/base58Decode.cpp
+++ b/src/Functions/base58Decode.cpp
@@ -5,15 +5,13 @@ namespace DB
 {
 namespace
 {
-
 struct NameBase58Decode
 {
     static constexpr auto name = "base58Decode";
 };
 
-using Base58DecodeImpl = Base58Decode<NameBase58Decode, Base58DecodeErrorHandling::ThrowException>;
-using FunctionBase58Decode = FunctionBase58Conversion<Base58DecodeImpl>;
-
+using Base58DecodeImpl = BaseXXDecode<Base58DecodeTraits, NameBase58Decode, BaseXXDecodeErrorHandling::ThrowException>;
+using FunctionBase58Decode = FunctionBaseXXConversion<Base58DecodeImpl>;
 }
 
 REGISTER_FUNCTION(Base58Decode)
diff --git a/src/Functions/base58Encode.cpp b/src/Functions/base58Encode.cpp
index 3ae2fb12c5e9..c6e45ccea793 100644
--- a/src/Functions/base58Encode.cpp
+++ b/src/Functions/base58Encode.cpp
@@ -3,10 +3,19 @@
 
 namespace DB
 {
+namespace
+{
+struct NameBase58Encode
+{
+    static constexpr auto name = "base58Encode";
+};
 
+using Base58EncodeImpl = BaseXXEncode<Base58EncodeTraits, NameBase58Encode>;
+using FunctionBase58Encode = FunctionBaseXXConversion<Base58EncodeImpl>;
+}
 REGISTER_FUNCTION(Base58Encode)
 {
-    factory.registerFunction<FunctionBase58Conversion<Base58Encode>>();
+    factory.registerFunction<FunctionBase58Encode>();
 }
 
 }
diff --git a/src/Functions/base64Decode.cpp b/src/Functions/base64Decode.cpp
index 4c3ee0de348f..c311b3046c3d 100644
--- a/src/Functions/base64Decode.cpp
+++ b/src/Functions/base64Decode.cpp
@@ -5,6 +5,16 @@
 
 namespace DB
 {
+namespace
+{
+struct NameBase64Decode
+{
+    static constexpr auto name = "base64Decode";
+};
+
+using Base64DecodeImpl = BaseXXDecode<Base64DecodeTraits<Base64Variant::Normal>, NameBase64Decode, BaseXXDecodeErrorHandling::ThrowException>;
+using FunctionBase64Decode = FunctionBaseXXConversion<Base64DecodeImpl>;
+}
 
 REGISTER_FUNCTION(Base64Decode)
 {
@@ -16,7 +26,7 @@ REGISTER_FUNCTION(Base64Decode)
     FunctionDocumentation::IntroducedIn introduced_in = {18, 16};
     FunctionDocumentation::Category category = FunctionDocumentation::Category::Encoding;
 
-    factory.registerFunction<FunctionBase64Conversion<Base64Decode<Base64Variant::Normal>>>({description, syntax, arguments, returned_value, examples, introduced_in, category});
+    factory.registerFunction<FunctionBase64Decode>({description, syntax, arguments, returned_value, examples, introduced_in, category});
 
     /// MySQL compatibility alias.
     factory.registerAlias("FROM_BASE64", "base64Decode", FunctionFactory::Case::Insensitive);
diff --git a/src/Functions/base64Encode.cpp b/src/Functions/base64Encode.cpp
index de9e7f15aa6e..8bec3025700b 100644
--- a/src/Functions/base64Encode.cpp
+++ b/src/Functions/base64Encode.cpp
@@ -5,6 +5,16 @@
 
 namespace DB
 {
+namespace
+{
+struct NameBase64Encode
+{
+static constexpr auto name = "base64Encode";
+};
+
+using Base64EncodeImpl = BaseXXEncode<Base64EncodeTraits<Base64Variant::Normal>, NameBase64Encode>;
+using FunctionBase64Encode = FunctionBaseXXConversion<Base64EncodeImpl>;
+}
 
 REGISTER_FUNCTION(Base64Encode)
 {
@@ -16,7 +26,7 @@ REGISTER_FUNCTION(Base64Encode)
     FunctionDocumentation::IntroducedIn introduced_in = {18, 16};
     FunctionDocumentation::Category category = FunctionDocumentation::Category::String;
 
-    factory.registerFunction<FunctionBase64Conversion<Base64Encode<Base64Variant::Normal>>>({description, syntax, arguments, returned_value, examples, introduced_in, category});
+    factory.registerFunction<FunctionBase64Encode>({description, syntax, arguments, returned_value, examples, introduced_in, category});
 
     /// MySQL compatibility alias.
     factory.registerAlias("TO_BASE64", "base64Encode", FunctionFactory::Case::Insensitive);
diff --git a/src/Functions/base64URLDecode.cpp b/src/Functions/base64URLDecode.cpp
index bf9fc14ac3d0..e3226cdf5c7a 100644
--- a/src/Functions/base64URLDecode.cpp
+++ b/src/Functions/base64URLDecode.cpp
@@ -5,6 +5,16 @@
 
 namespace DB
 {
+namespace
+{
+struct NameBase64Decode
+{
+    static constexpr auto name = "base64URLDecode";
+};
+
+using Base64DecodeImpl = BaseXXDecode<Base64DecodeTraits<Base64Variant::URL>, NameBase64Decode, BaseXXDecodeErrorHandling::ThrowException>;
+using FunctionBase64Decode = FunctionBaseXXConversion<Base64DecodeImpl>;
+}
 
 REGISTER_FUNCTION(Base64URLDecode)
 {
@@ -16,7 +26,7 @@ REGISTER_FUNCTION(Base64URLDecode)
     FunctionDocumentation::IntroducedIn introduced_in = {24, 6};
     FunctionDocumentation::Category category = FunctionDocumentation::Category::Encoding;
 
-    factory.registerFunction<FunctionBase64Conversion<Base64Decode<Base64Variant::URL>>>({description, syntax, arguments, returned_value, examples, introduced_in, category});
+    factory.registerFunction<FunctionBase64Decode>({description, syntax, arguments, returned_value, examples, introduced_in, category});
 }
 
 }
diff --git a/src/Functions/base64URLEncode.cpp b/src/Functions/base64URLEncode.cpp
index 3525bdd6b75c..d6b72366a099 100644
--- a/src/Functions/base64URLEncode.cpp
+++ b/src/Functions/base64URLEncode.cpp
@@ -5,6 +5,16 @@
 
 namespace DB
 {
+namespace
+{
+struct NameBase64Encode
+{
+static constexpr auto name = "base64URLEncode";
+};
+
+using Base64EncodeImpl = BaseXXEncode<Base64EncodeTraits<Base64Variant::URL>, NameBase64Encode>;
+using FunctionBase64Encode = FunctionBaseXXConversion<Base64EncodeImpl>;
+}
 
 REGISTER_FUNCTION(Base64URLEncode)
 {
@@ -16,7 +26,7 @@ REGISTER_FUNCTION(Base64URLEncode)
     FunctionDocumentation::IntroducedIn introduced_in = {24, 6};
     FunctionDocumentation::Category category = FunctionDocumentation::Category::Encoding;
 
-    factory.registerFunction<FunctionBase64Conversion<Base64Encode<Base64Variant::URL>>>({description, syntax, arguments, returned_value, examples, introduced_in, category});
+    factory.registerFunction<FunctionBase64Encode>({description, syntax, arguments, returned_value, examples, introduced_in, category});
 }
 
 }
diff --git a/src/Functions/tryBase32Decode.cpp b/src/Functions/tryBase32Decode.cpp
new file mode 100644
index 000000000000..061ce7ae38a9
--- /dev/null
+++ b/src/Functions/tryBase32Decode.cpp
@@ -0,0 +1,35 @@
+#include <Functions/FunctionBase32Conversion.h>
+#include <Functions/FunctionFactory.h>
+
+namespace DB
+{
+namespace
+{
+struct NameTryBase32Decode
+{
+    static constexpr auto name = "tryBase32Decode";
+};
+
+using TryBase32DecodeImpl = BaseXXDecode<Base32DecodeTraits, NameTryBase32Decode, BaseXXDecodeErrorHandling::ReturnEmptyString>;
+using FunctionTryBase32Decode = FunctionBaseXXConversion<TryBase32DecodeImpl>;
+}
+
+REGISTER_FUNCTION(TryBase32Decode)
+{
+    factory.registerFunction<FunctionTryBase32Decode>(FunctionDocumentation{
+        .description = R"(
+Decode a [Base32](https://datatracker.ietf.org/doc/html/rfc4648) encoded string. If the input string is not a valid Base32 return an empty string.)",
+        .arguments = {
+            {"arg", "A Base32 (rfc4648) encoded string"},
+        },
+        .examples = {
+            {"simple_decoding1", "SELECT tryBase32Decode('ME======')", "a"},
+            {"simple_decoding2", "SELECT tryBase32Decode('JBSWY3DP')", "Hello"},
+            {"non_ascii", "SELECT hex(tryBase32Decode('4W2HIXV4'))", "E5B4745EBC"},
+            {"invalid_base32", "SELECT tryBase32Decode('invalid_base32')", ""},
+            {"empty_string", "SELECT tryBase32Decode('')", ""},
+            {"non_base32_characters", "SELECT tryBase32Decode('12345')", ""},
+        },
+        .category = FunctionDocumentation::Category::String});
+}
+}
diff --git a/src/Functions/tryBase58Decode.cpp b/src/Functions/tryBase58Decode.cpp
index b722693fd8c3..bfc784bc2d36 100644
--- a/src/Functions/tryBase58Decode.cpp
+++ b/src/Functions/tryBase58Decode.cpp
@@ -5,15 +5,13 @@ namespace DB
 {
 namespace
 {
-
 struct NameTryBase58Decode
 {
     static constexpr auto name = "tryBase58Decode";
 };
 
-using TryBase58DecodeImpl = Base58Decode<NameTryBase58Decode, Base58DecodeErrorHandling::ReturnEmptyString>;
-using FunctionTryBase58Decode = FunctionBase58Conversion<TryBase58DecodeImpl>;
-
+using TryBase58DecodeImpl = BaseXXDecode<Base58DecodeTraits, NameTryBase58Decode, BaseXXDecodeErrorHandling::ReturnEmptyString>;
+using FunctionTryBase58Decode = FunctionBaseXXConversion<TryBase58DecodeImpl>;
 }
 
 REGISTER_FUNCTION(TryBase58Decode)
diff --git a/src/Functions/tryBase64Decode.cpp b/src/Functions/tryBase64Decode.cpp
index a7a3140823e8..83ec07668476 100644
--- a/src/Functions/tryBase64Decode.cpp
+++ b/src/Functions/tryBase64Decode.cpp
@@ -5,6 +5,16 @@
 
 namespace DB
 {
+namespace
+{
+struct NameBase64Decode
+{
+static constexpr auto name = "tryBase64Decode";
+};
+
+using Base64DecodeImpl = BaseXXDecode<Base64DecodeTraits<Base64Variant::Normal>, NameBase64Decode, BaseXXDecodeErrorHandling::ReturnEmptyString>;
+using FunctionBase64Decode = FunctionBaseXXConversion<Base64DecodeImpl>;
+}
 REGISTER_FUNCTION(TryBase64Decode)
 {
     FunctionDocumentation::Description description = R"(Decodes a String or FixedString from base64, like base64Decode but returns an empty string in case of an error.)";
@@ -15,7 +25,7 @@ REGISTER_FUNCTION(TryBase64Decode)
     FunctionDocumentation::IntroducedIn introduced_in = {18, 16};
     FunctionDocumentation::Category category = FunctionDocumentation::Category::Encoding;
 
-    factory.registerFunction<FunctionBase64Conversion<TryBase64Decode<Base64Variant::Normal>>>({description, syntax, arguments, returned_value, examples, introduced_in, category});
+    factory.registerFunction<FunctionBase64Decode>({description, syntax, arguments, returned_value, examples, introduced_in, category});
 }
 }
 
diff --git a/src/Functions/tryBase64URLDecode.cpp b/src/Functions/tryBase64URLDecode.cpp
index 358ee5e87098..30e57de18b19 100644
--- a/src/Functions/tryBase64URLDecode.cpp
+++ b/src/Functions/tryBase64URLDecode.cpp
@@ -5,6 +5,16 @@
 
 namespace DB
 {
+namespace
+{
+struct NameBase64Decode
+{
+static constexpr auto name = "tryBase64URLDecode";
+};
+
+using Base64DecodeImpl = BaseXXDecode<Base64DecodeTraits<Base64Variant::URL>, NameBase64Decode, BaseXXDecodeErrorHandling::ReturnEmptyString>;
+using FunctionBase64Decode = FunctionBaseXXConversion<Base64DecodeImpl>;
+}
 REGISTER_FUNCTION(TryBase64URLDecode)
 {
     FunctionDocumentation::Description description = R"(Decodes an URL from base64, like base64URLDecode but returns an empty string in case of an error.)";
@@ -15,7 +25,7 @@ REGISTER_FUNCTION(TryBase64URLDecode)
     FunctionDocumentation::IntroducedIn introduced_in = {24, 6};
     FunctionDocumentation::Category category = FunctionDocumentation::Category::Encoding;
 
-    factory.registerFunction<FunctionBase64Conversion<TryBase64Decode<Base64Variant::URL>>>({description, syntax, arguments, returned_value, examples, introduced_in, category});
+    factory.registerFunction<FunctionBase64Decode>({description, syntax, arguments, returned_value, examples, introduced_in, category});
 }
 }
 
