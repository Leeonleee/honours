{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 54480,
  "instance_id": "ClickHouse__ClickHouse-54480",
  "issue_numbers": [
    "54406"
  ],
  "base_commit": "c0a43df749c827ce13abb015faca4ad8ab524685",
  "patch": "diff --git a/src/Columns/ColumnAggregateFunction.cpp b/src/Columns/ColumnAggregateFunction.cpp\nindex 3ebb30df87e9..0ec5db6c69da 100644\n--- a/src/Columns/ColumnAggregateFunction.cpp\n+++ b/src/Columns/ColumnAggregateFunction.cpp\n@@ -73,7 +73,7 @@ ColumnAggregateFunction::ColumnAggregateFunction(const AggregateFunctionPtr & fu\n \n }\n \n-void ColumnAggregateFunction::set(const AggregateFunctionPtr & func_, size_t version_)\n+void ColumnAggregateFunction::set(const AggregateFunctionPtr & func_, std::optional<size_t> version_)\n {\n     func = func_;\n     version = version_;\ndiff --git a/src/Columns/ColumnAggregateFunction.h b/src/Columns/ColumnAggregateFunction.h\nindex 7c7201e585a6..e37a8a5f109f 100644\n--- a/src/Columns/ColumnAggregateFunction.h\n+++ b/src/Columns/ColumnAggregateFunction.h\n@@ -103,7 +103,7 @@ class ColumnAggregateFunction final : public COWHelper<IColumn, ColumnAggregateF\n public:\n     ~ColumnAggregateFunction() override;\n \n-    void set(const AggregateFunctionPtr & func_, size_t version_);\n+    void set(const AggregateFunctionPtr & func_, std::optional<size_t> version_ = std::nullopt);\n \n     AggregateFunctionPtr getAggregateFunction() { return func; }\n     AggregateFunctionPtr getAggregateFunction() const { return func; }\ndiff --git a/src/DataTypes/DataTypeAggregateFunction.cpp b/src/DataTypes/DataTypeAggregateFunction.cpp\nindex b580ecc9592f..be60886d74b3 100644\n--- a/src/DataTypes/DataTypeAggregateFunction.cpp\n+++ b/src/DataTypes/DataTypeAggregateFunction.cpp\n@@ -117,43 +117,43 @@ Field DataTypeAggregateFunction::getDefault() const\n     return field;\n }\n \n-\n-bool DataTypeAggregateFunction::equals(const IDataType & rhs) const\n+bool DataTypeAggregateFunction::strictEquals(const DataTypePtr & lhs_state_type, const DataTypePtr & rhs_state_type)\n {\n-    if (typeid(rhs) != typeid(*this))\n-        return false;\n+    const auto * lhs_state = typeid_cast<const DataTypeAggregateFunction *>(lhs_state_type.get());\n+    const auto * rhs_state = typeid_cast<const DataTypeAggregateFunction *>(rhs_state_type.get());\n \n-    auto lhs_state_type = function->getNormalizedStateType();\n-    auto rhs_state_type = typeid_cast<const DataTypeAggregateFunction &>(rhs).function->getNormalizedStateType();\n-\n-    if (typeid(lhs_state_type.get()) != typeid(rhs_state_type.get()))\n+    if (!lhs_state || !rhs_state)\n         return false;\n \n-    if (const auto * lhs_state = typeid_cast<const DataTypeAggregateFunction *>(lhs_state_type.get()))\n-    {\n-        const auto & rhs_state = typeid_cast<const DataTypeAggregateFunction &>(*rhs_state_type);\n+    if (lhs_state->function->getName() != rhs_state->function->getName())\n+        return false;\n \n-        if (lhs_state->function->getName() != rhs_state.function->getName())\n-            return false;\n+    if (lhs_state->parameters.size() != rhs_state->parameters.size())\n+        return false;\n \n-        if (lhs_state->parameters.size() != rhs_state.parameters.size())\n+    for (size_t i = 0; i < lhs_state->parameters.size(); ++i)\n+        if (lhs_state->parameters[i] != rhs_state->parameters[i])\n             return false;\n \n-        for (size_t i = 0; i < lhs_state->parameters.size(); ++i)\n-            if (lhs_state->parameters[i] != rhs_state.parameters[i])\n-                return false;\n+    if (lhs_state->argument_types.size() != rhs_state->argument_types.size())\n+        return false;\n \n-        if (lhs_state->argument_types.size() != rhs_state.argument_types.size())\n+    for (size_t i = 0; i < lhs_state->argument_types.size(); ++i)\n+        if (!lhs_state->argument_types[i]->equals(*rhs_state->argument_types[i]))\n             return false;\n \n-        for (size_t i = 0; i < lhs_state->argument_types.size(); ++i)\n-            if (!lhs_state->argument_types[i]->equals(*rhs_state.argument_types[i]))\n-                return false;\n+    return true;\n+}\n \n-        return true;\n-    }\n+bool DataTypeAggregateFunction::equals(const IDataType & rhs) const\n+{\n+    if (typeid(rhs) != typeid(*this))\n+        return false;\n+\n+    auto lhs_state_type = function->getNormalizedStateType();\n+    auto rhs_state_type = typeid_cast<const DataTypeAggregateFunction &>(rhs).function->getNormalizedStateType();\n \n-    return lhs_state_type->equals(*rhs_state_type);\n+    return strictEquals(lhs_state_type, rhs_state_type);\n }\n \n \ndiff --git a/src/DataTypes/DataTypeAggregateFunction.h b/src/DataTypes/DataTypeAggregateFunction.h\nindex 83c9f10f407c..6331c23222f9 100644\n--- a/src/DataTypes/DataTypeAggregateFunction.h\n+++ b/src/DataTypes/DataTypeAggregateFunction.h\n@@ -60,6 +60,7 @@ class DataTypeAggregateFunction final : public IDataType\n \n     Field getDefault() const override;\n \n+    static bool strictEquals(const DataTypePtr & lhs_state_type, const DataTypePtr & rhs_state_type);\n     bool equals(const IDataType & rhs) const override;\n \n     bool isParametric() const override { return true; }\ndiff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex 00e2ebcda434..ae5b3305baf0 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -33,6 +33,7 @@\n #include <Columns/ColumnString.h>\n #include <Columns/ColumnFixedString.h>\n #include <Columns/ColumnConst.h>\n+#include <Columns/ColumnAggregateFunction.h>\n #include <Columns/ColumnArray.h>\n #include <Columns/ColumnNullable.h>\n #include <Columns/ColumnTuple.h>\n@@ -3188,14 +3189,40 @@ class FunctionCast final : public FunctionCastBase\n         {\n             return &ConvertImplGenericFromString<ColumnString>::execute;\n         }\n-        else\n+        else if (const auto * agg_type = checkAndGetDataType<DataTypeAggregateFunction>(from_type_untyped.get()))\n         {\n-            if (cast_type == CastType::accurateOrNull)\n-                return createToNullableColumnWrapper();\n-            else\n-                throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Conversion from {} to {} is not supported\",\n-                    from_type_untyped->getName(), to_type->getName());\n+            if (agg_type->getFunction()->haveSameStateRepresentation(*to_type->getFunction()))\n+            {\n+                return [function = to_type->getFunction()](\n+                           ColumnsWithTypeAndName & arguments,\n+                           const DataTypePtr & /* result_type */,\n+                           const ColumnNullable * /* nullable_source */,\n+                           size_t /*input_rows_count*/) -> ColumnPtr\n+                {\n+                    const auto & argument_column = arguments.front();\n+                    const auto * col_agg = checkAndGetColumn<ColumnAggregateFunction>(argument_column.column.get());\n+                    if (col_agg)\n+                    {\n+                        auto new_col_agg = ColumnAggregateFunction::create(*col_agg);\n+                        new_col_agg->set(function);\n+                        return new_col_agg;\n+                    }\n+                    else\n+                    {\n+                        throw Exception(\n+                            ErrorCodes::LOGICAL_ERROR,\n+                            \"Illegal column {} for function CAST AS AggregateFunction\",\n+                            argument_column.column->getName());\n+                    }\n+                };\n+            }\n         }\n+\n+        if (cast_type == CastType::accurateOrNull)\n+            return createToNullableColumnWrapper();\n+        else\n+            throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Conversion from {} to {} is not supported\",\n+                from_type_untyped->getName(), to_type->getName());\n     }\n \n     WrapperType createArrayWrapper(const DataTypePtr & from_type_untyped, const DataTypeArray & to_type) const\n@@ -3976,7 +4003,16 @@ class FunctionCast final : public FunctionCastBase\n             safe_convert_custom_types = to_type->getCustomName() && from_type_custom_name->getName() == to_type->getCustomName()->getName();\n \n         if (from_type->equals(*to_type) && safe_convert_custom_types)\n-            return createIdentityWrapper(from_type);\n+        {\n+            /// We can only use identity conversion for DataTypeAggregateFunction when they are strictly equivalent.\n+            if (typeid_cast<const DataTypeAggregateFunction *>(from_type.get()))\n+            {\n+                if (DataTypeAggregateFunction::strictEquals(from_type, to_type))\n+                    return createIdentityWrapper(from_type);\n+            }\n+            else\n+                return createIdentityWrapper(from_type);\n+        }\n         else if (WhichDataType(from_type).isNothing())\n             return createNothingWrapper(to_type.get());\n \ndiff --git a/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp b/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp\nindex eab4d3f5d434..0599a0fa369d 100644\n--- a/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp\n+++ b/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp\n@@ -143,12 +143,12 @@ std::optional<AggregateFunctionMatches> matchAggregateFunctions(\n             argument_types.clear();\n             const auto & candidate = info.aggregates[idx];\n \n-            /// Note: this check is a bit strict.\n-            /// We check that aggregate function names, argument types and parameters are equal.\n             /// In some cases it's possible only to check that states are equal,\n             /// e.g. for quantile(0.3)(...) and quantile(0.5)(...).\n-            /// But also functions sum(...) and sumIf(...) will have equal states,\n-            /// and we can't replace one to another from projection.\n+            ///\n+            /// Note we already checked that aggregate function names are equal,\n+            /// so that functions sum(...) and sumIf(...) with equal states will\n+            /// not match.\n             if (!candidate.function->getStateType()->equals(*aggregate.function->getStateType()))\n             {\n                 // LOG_TRACE(&Poco::Logger::get(\"optimizeUseProjections\"), \"Cannot match agg func {} vs {} by state {} vs {}\",\n@@ -249,12 +249,24 @@ static void appendAggregateFunctions(\n \n         auto & input = inputs[match.description];\n         if (!input)\n-            input = &proj_dag.addInput(match.description->column_name, std::move(type));\n+            input = &proj_dag.addInput(match.description->column_name, type);\n \n         const auto * node = input;\n \n         if (node->result_name != aggregate.column_name)\n-            node = &proj_dag.addAlias(*node, aggregate.column_name);\n+        {\n+            if (DataTypeAggregateFunction::strictEquals(type, node->result_type))\n+            {\n+                node = &proj_dag.addAlias(*node, aggregate.column_name);\n+            }\n+            else\n+            {\n+                /// Cast to aggregate types specified in query if it's not\n+                /// strictly the same as the one specified in projection. This\n+                /// is required to generate correct results during finalization.\n+                node = &proj_dag.addCast(*node, type, aggregate.column_name);\n+            }\n+        }\n \n         proj_dag_outputs.push_back(node);\n     }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01710_aggregate_projection_with_normalized_states.reference b/tests/queries/0_stateless/01710_aggregate_projection_with_normalized_states.reference\nnew file mode 100644\nindex 000000000000..25aa9dc5dec2\n--- /dev/null\n+++ b/tests/queries/0_stateless/01710_aggregate_projection_with_normalized_states.reference\n@@ -0,0 +1,2 @@\n+3\n+950\t990\t500\t2000\ndiff --git a/tests/queries/0_stateless/01710_aggregate_projection_with_normalized_states.sql b/tests/queries/0_stateless/01710_aggregate_projection_with_normalized_states.sql\nnew file mode 100644\nindex 000000000000..e023c0991b3c\n--- /dev/null\n+++ b/tests/queries/0_stateless/01710_aggregate_projection_with_normalized_states.sql\n@@ -0,0 +1,31 @@\n+DROP TABLE IF EXISTS r;\n+\n+select finalizeAggregation(cast(quantileState(0)(arrayJoin([1,2,3])) as AggregateFunction(quantile(1), UInt8)));\n+\n+CREATE TABLE r (\n+     x String,\n+     a LowCardinality(String),\n+     q AggregateFunction(quantilesTiming(0.5, 0.95, 0.99), Int64),\n+     s Int64,\n+     PROJECTION p\n+         (SELECT a, quantilesTimingMerge(0.5, 0.95, 0.99)(q), sum(s) GROUP BY a)\n+) Engine=SummingMergeTree order by (x, a);\n+\n+insert into r\n+select number%100 x,\n+       'x' a,\n+       quantilesTimingState(0.5, 0.95, 0.99)(number::Int64) q,\n+       sum(1) s\n+from numbers(1000)\n+group by x,a;\n+\n+SELECT\n+       ifNotFinite(quantilesTimingMerge(0.95)(q)[1],0) as d1,\n+       ifNotFinite(quantilesTimingMerge(0.99)(q)[1],0) as d2,\n+       ifNotFinite(quantilesTimingMerge(0.50)(q)[1],0) as d3,\n+       sum(s)\n+FROM cluster('test_cluster_two_shards', currentDatabase(), r)\n+WHERE a = 'x'\n+settings prefer_localhost_replica=0;\n+\n+DROP TABLE r;\n",
  "problem_statement": "Projection issue Block structure mismatch in AggregatingStep stream\nworked with 22.8: https://fiddle.clickhouse.com/bba44076-1961-4356-b59c-df7e26362245\r\nfails with 23.3: https://fiddle.clickhouse.com/731c266b-df63-437e-ac64-05a36422ad36\r\n\r\n```sql\r\nCREATE TABLE r (\r\n     x String,\r\n     a LowCardinality(String),\r\n     q AggregateFunction(quantilesTiming(0.5, 0.95, 0.99), Int64),\r\n     s Int64,\r\n     PROJECTION p \r\n         (SELECT a, quantilesTimingMerge(0.5, 0.95, 0.99)(q), sum(s) GROUP BY a)\r\n) Engine=SummingMergeTree order by (x,   a);\r\n\r\ninsert into r \r\nselect number%100 x,\r\n       'x' a, \r\n       quantilesTimingState(0.5, 0.95, 0.99)(number::Int64) q, \r\n       sum(1) s\r\nfrom numbers(1000)\r\ngroup by x,a;\r\n\r\nSELECT \r\n       ifNotFinite(quantilesTimingMerge(0.95)(q)[1],0) as d1, \r\n       ifNotFinite(quantilesTimingMerge(0.99)(q)[1],0) as d2,\r\n       ifNotFinite(quantilesTimingMerge(0.50)(q)[1],0) as d3,\r\n       sum(s)\r\nFROM cluster('test_cluster_two_shards', default, r)\r\nWHERE a = 'x' \r\nsettings prefer_localhost_replica=0\r\nformat PrettyCompact;\r\n\r\n\r\nDB::Exception: Received from 127.0.0.1:9000. DB::Exception: Block structure mismatch in AggregatingStep stream: different types:\r\nquantilesTimingMerge(0.99)(q) \r\n```\r\n\r\nWA: disable projection (`allow_experimental_projection_optimization=0`)\r\nhttps://fiddle.clickhouse.com/89156fe6-169d-444b-a8ab-4c07781d7d11\r\n\n",
  "hints_text": "cc @amosbird \nWorks with `query_plan_optimize_projection = 0`. Will investigate in the weekend.\nit did not use projection with 22.8\noriginal issue https://fiddle.clickhouse.com/4d174334-51e8-4378-a668-028146afe3ec\r\n\r\ninteresting, that this works and can be used as WA https://fiddle.clickhouse.com/c7211ac0-9b1a-460f-b016-76e923f51543\r\n\r\nTable quantileTiming(0.5)\r\nPROJECTION quantilesTimingMerge(0.5)\r\nQuery quantilesTimingMerge(0.5, 0.95, 0.99)",
  "created_at": "2023-09-09T18:44:45Z",
  "modified_files": [
    "src/Columns/ColumnAggregateFunction.cpp",
    "src/Columns/ColumnAggregateFunction.h",
    "src/DataTypes/DataTypeAggregateFunction.cpp",
    "src/DataTypes/DataTypeAggregateFunction.h",
    "src/Functions/FunctionsConversion.h",
    "src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01710_aggregate_projection_with_normalized_states.reference",
    "b/tests/queries/0_stateless/01710_aggregate_projection_with_normalized_states.sql"
  ]
}