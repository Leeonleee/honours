{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 58661,
  "instance_id": "ClickHouse__ClickHouse-58661",
  "issue_numbers": [
    "57326"
  ],
  "base_commit": "d3ede543bb529591cb76e5d9f9a5977493924181",
  "patch": "diff --git a/docs/en/operations/settings/settings.md b/docs/en/operations/settings/settings.md\nindex 3d6d776f4da6..1d74a63b972a 100644\n--- a/docs/en/operations/settings/settings.md\n+++ b/docs/en/operations/settings/settings.md\n@@ -2536,7 +2536,7 @@ Possible values:\n - 0 \u2014 Optimization disabled.\n - 1 \u2014 Optimization enabled.\n \n-Default value: `0`.\n+Default value: `1`.\n \n ## optimize_trivial_count_query {#optimize-trivial-count-query}\n \ndiff --git a/docs/ru/operations/settings/settings.md b/docs/ru/operations/settings/settings.md\nindex 3a70a0bac128..84bbf6c83d31 100644\n--- a/docs/ru/operations/settings/settings.md\n+++ b/docs/ru/operations/settings/settings.md\n@@ -2077,7 +2077,7 @@ SELECT * FROM test_table\n -   0 \u2014 \u043e\u043f\u0442\u0438\u043c\u0438\u0437\u0430\u0446\u0438\u044f \u043e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u0430.\n -   1 \u2014 \u043e\u043f\u0442\u0438\u043c\u0438\u0437\u0430\u0446\u0438\u044f \u0432\u043a\u043b\u044e\u0447\u0435\u043d\u0430.\n \n-\u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e: `0`.\n+\u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e: `1`.\n \n ## optimize_trivial_count_query {#optimize-trivial-count-query}\n \ndiff --git a/src/Analyzer/Passes/AggregateFunctionsArithmericOperationsPass.cpp b/src/Analyzer/Passes/AggregateFunctionsArithmericOperationsPass.cpp\nindex e6798a792ddc..098e2858abce 100644\n--- a/src/Analyzer/Passes/AggregateFunctionsArithmericOperationsPass.cpp\n+++ b/src/Analyzer/Passes/AggregateFunctionsArithmericOperationsPass.cpp\n@@ -9,6 +9,7 @@\n #include <Analyzer/InDepthQueryTreeVisitor.h>\n #include <Analyzer/ConstantNode.h>\n #include <Analyzer/FunctionNode.h>\n+#include <Analyzer/Utils.h>\n \n namespace DB\n {\n@@ -164,32 +165,15 @@ class AggregateFunctionsArithmericOperationsVisitor : public InDepthQueryTreeVis\n \n         auto aggregate_function_clone = aggregate_function->clone();\n         auto & aggregate_function_clone_typed = aggregate_function_clone->as<FunctionNode &>();\n+\n         aggregate_function_clone_typed.getArguments().getNodes() = { arithmetic_function_clone_argument };\n-        resolveAggregateFunctionNode(aggregate_function_clone_typed, arithmetic_function_clone_argument, result_aggregate_function_name);\n+        resolveAggregateFunctionNodeByName(aggregate_function_clone_typed, result_aggregate_function_name);\n \n         arithmetic_function_clone_arguments_nodes[arithmetic_function_argument_index] = std::move(aggregate_function_clone);\n-        resolveOrdinaryFunctionNode(arithmetic_function_clone_typed, arithmetic_function_clone_typed.getFunctionName());\n+        resolveOrdinaryFunctionNodeByName(arithmetic_function_clone_typed, arithmetic_function_clone_typed.getFunctionName(), getContext());\n \n         return arithmetic_function_clone;\n     }\n-\n-    void resolveOrdinaryFunctionNode(FunctionNode & function_node, const String & function_name) const\n-    {\n-        auto function = FunctionFactory::instance().get(function_name, getContext());\n-        function_node.resolveAsFunction(function->build(function_node.getArgumentColumns()));\n-    }\n-\n-    static void resolveAggregateFunctionNode(FunctionNode & function_node, const QueryTreeNodePtr & argument, const String & aggregate_function_name)\n-    {\n-        auto function_aggregate_function = function_node.getAggregateFunction();\n-\n-        AggregateFunctionProperties properties;\n-        auto action = NullsAction::EMPTY;\n-        auto aggregate_function = AggregateFunctionFactory::instance().get(\n-            aggregate_function_name, action, {argument->getResultType()}, function_aggregate_function->getParameters(), properties);\n-\n-        function_node.resolveAsAggregateFunction(std::move(aggregate_function));\n-    }\n };\n \n }\ndiff --git a/src/Analyzer/Passes/ComparisonTupleEliminationPass.cpp b/src/Analyzer/Passes/ComparisonTupleEliminationPass.cpp\nindex ebefc12ae536..180470952cd3 100644\n--- a/src/Analyzer/Passes/ComparisonTupleEliminationPass.cpp\n+++ b/src/Analyzer/Passes/ComparisonTupleEliminationPass.cpp\n@@ -11,6 +11,7 @@\n #include <Analyzer/InDepthQueryTreeVisitor.h>\n #include <Analyzer/ConstantNode.h>\n #include <Analyzer/FunctionNode.h>\n+#include <Analyzer/Utils.h>\n \n namespace DB\n {\n@@ -18,19 +19,18 @@ namespace DB\n namespace\n {\n \n-class ComparisonTupleEliminationPassVisitor : public InDepthQueryTreeVisitor<ComparisonTupleEliminationPassVisitor>\n+class ComparisonTupleEliminationPassVisitor : public InDepthQueryTreeVisitorWithContext<ComparisonTupleEliminationPassVisitor>\n {\n public:\n-    explicit ComparisonTupleEliminationPassVisitor(ContextPtr context_)\n-        : context(std::move(context_))\n-    {}\n+    using Base = InDepthQueryTreeVisitorWithContext<ComparisonTupleEliminationPassVisitor>;\n+    using Base::Base;\n \n     static bool needChildVisit(QueryTreeNodePtr &, QueryTreeNodePtr & child)\n     {\n         return child->getNodeType() != QueryTreeNodeType::TABLE_FUNCTION;\n     }\n \n-    void visitImpl(QueryTreeNodePtr & node) const\n+    void enterImpl(QueryTreeNodePtr & node) const\n     {\n         auto * function_node = node->as<FunctionNode>();\n         if (!function_node)\n@@ -171,13 +171,13 @@ class ComparisonTupleEliminationPassVisitor : public InDepthQueryTreeVisitor<Com\n     {\n         auto result_function = std::make_shared<FunctionNode>(\"and\");\n         result_function->getArguments().getNodes() = std::move(tuple_arguments_equals_functions);\n-        resolveOrdinaryFunctionNode(*result_function, result_function->getFunctionName());\n+        resolveOrdinaryFunctionNodeByName(*result_function, result_function->getFunctionName(), getContext());\n \n         if (comparison_function_name == \"notEquals\")\n         {\n             auto not_function = std::make_shared<FunctionNode>(\"not\");\n             not_function->getArguments().getNodes().push_back(std::move(result_function));\n-            resolveOrdinaryFunctionNode(*not_function, not_function->getFunctionName());\n+            resolveOrdinaryFunctionNodeByName(*not_function, not_function->getFunctionName(), getContext());\n             result_function = std::move(not_function);\n         }\n \n@@ -197,18 +197,10 @@ class ComparisonTupleEliminationPassVisitor : public InDepthQueryTreeVisitor<Com\n         comparison_function->getArguments().getNodes().push_back(std::move(lhs_argument));\n         comparison_function->getArguments().getNodes().push_back(std::move(rhs_argument));\n \n-        resolveOrdinaryFunctionNode(*comparison_function, comparison_function->getFunctionName());\n+        resolveOrdinaryFunctionNodeByName(*comparison_function, comparison_function->getFunctionName(), getContext());\n \n         return comparison_function;\n     }\n-\n-    void resolveOrdinaryFunctionNode(FunctionNode & function_node, const String & function_name) const\n-    {\n-        auto function = FunctionFactory::instance().get(function_name, context);\n-        function_node.resolveAsFunction(function->build(function_node.getArgumentColumns()));\n-    }\n-\n-    ContextPtr context;\n };\n \n }\ndiff --git a/src/Analyzer/Passes/CountDistinctPass.cpp b/src/Analyzer/Passes/CountDistinctPass.cpp\nindex 3307c440f425..23fde89a3480 100644\n--- a/src/Analyzer/Passes/CountDistinctPass.cpp\n+++ b/src/Analyzer/Passes/CountDistinctPass.cpp\n@@ -9,6 +9,7 @@\n #include <Analyzer/ColumnNode.h>\n #include <Analyzer/FunctionNode.h>\n #include <Analyzer/QueryNode.h>\n+#include <Analyzer/Utils.h>\n \n namespace DB\n {\n@@ -77,11 +78,9 @@ class CountDistinctVisitor : public InDepthQueryTreeVisitorWithContext<CountDist\n \n         /// Replace `countDistinct` of initial query into `count`\n         auto result_type = function_node->getResultType();\n-        AggregateFunctionProperties properties;\n-        auto action = NullsAction::EMPTY;\n-        auto aggregate_function = AggregateFunctionFactory::instance().get(\"count\", action, {}, {}, properties);\n-        function_node->resolveAsAggregateFunction(std::move(aggregate_function));\n+\n         function_node->getArguments().getNodes().clear();\n+        resolveAggregateFunctionNodeByName(*function_node, \"count\");\n     }\n };\n \ndiff --git a/src/Analyzer/Passes/FunctionToSubcolumnsPass.cpp b/src/Analyzer/Passes/FunctionToSubcolumnsPass.cpp\nindex 15ac8d642a4a..90051779a264 100644\n--- a/src/Analyzer/Passes/FunctionToSubcolumnsPass.cpp\n+++ b/src/Analyzer/Passes/FunctionToSubcolumnsPass.cpp\n@@ -4,6 +4,7 @@\n #include <DataTypes/DataTypeTuple.h>\n #include <DataTypes/DataTypeArray.h>\n #include <DataTypes/DataTypeMap.h>\n+#include <DataTypes/DataTypeVariant.h>\n \n #include <Storages/IStorage.h>\n \n@@ -16,6 +17,9 @@\n #include <Analyzer/ColumnNode.h>\n #include <Analyzer/FunctionNode.h>\n #include <Analyzer/TableNode.h>\n+#include <Analyzer/TableFunctionNode.h>\n+#include <Analyzer/Utils.h>\n+#include <Analyzer/JoinNode.h>\n \n namespace DB\n {\n@@ -23,202 +27,410 @@ namespace DB\n namespace\n {\n \n-class FunctionToSubcolumnsVisitor : public InDepthQueryTreeVisitorWithContext<FunctionToSubcolumnsVisitor>\n+struct ColumnContext\n+{\n+    NameAndTypePair column;\n+    QueryTreeNodePtr column_source;\n+    ContextPtr context;\n+};\n+\n+using NodeToSubcolumnTransformer = std::function<void(QueryTreeNodePtr &, FunctionNode &, ColumnContext &)>;\n+\n+void optimizeFunctionLength(QueryTreeNodePtr & node, FunctionNode &, ColumnContext & ctx)\n+{\n+    /// Replace `length(argument)` with `argument.size0`\n+    /// `argument` may be Array or Map.\n+\n+    NameAndTypePair column{ctx.column.name + \".size0\", std::make_shared<DataTypeUInt64>()};\n+    node = std::make_shared<ColumnNode>(column, ctx.column_source);\n+}\n+\n+template <bool positive>\n+void optimizeFunctionEmpty(QueryTreeNodePtr &, FunctionNode & function_node, ColumnContext & ctx)\n+{\n+    /// Replace `empty(argument)` with `equals(argument.size0, 0)` if positive\n+    /// Replace `notEmpty(argument)` with `notEquals(argument.size0, 0)` if not positive\n+    /// `argument` may be Array or Map.\n+\n+    NameAndTypePair column{ctx.column.name + \".size0\", std::make_shared<DataTypeUInt64>()};\n+    auto & function_arguments_nodes = function_node.getArguments().getNodes();\n+\n+    function_arguments_nodes.clear();\n+    function_arguments_nodes.push_back(std::make_shared<ColumnNode>(column, ctx.column_source));\n+    function_arguments_nodes.push_back(std::make_shared<ConstantNode>(static_cast<UInt64>(0)));\n+\n+    const auto * function_name = positive ? \"equals\" : \"notEquals\";\n+    resolveOrdinaryFunctionNodeByName(function_node, function_name, ctx.context);\n+}\n+\n+String getSubcolumnNameForElement(const Field & value, const DataTypeTuple & data_type_tuple)\n+{\n+    if (value.getType() == Field::Types::String)\n+        return value.get<const String &>();\n+\n+    if (value.getType() == Field::Types::UInt64)\n+        return data_type_tuple.getNameByPosition(value.get<UInt64>());\n+\n+    return \"\";\n+}\n+\n+String getSubcolumnNameForElement(const Field & value, const DataTypeVariant &)\n+{\n+    if (value.getType() == Field::Types::String)\n+        return value.get<const String &>();\n+\n+    return \"\";\n+}\n+\n+template <typename DataType>\n+void optimizeTupleOrVariantElement(QueryTreeNodePtr & node, FunctionNode & function_node, ColumnContext & ctx)\n+{\n+    /// Replace `tupleElement(tuple_argument, string_literal)`, `tupleElement(tuple_argument, integer_literal)` with `tuple_argument.column_name`.\n+    /// Replace `variantElement(variant_argument, string_literal)` with `variant_argument.column_name`.\n+\n+    auto & function_arguments_nodes = function_node.getArguments().getNodes();\n+    if (function_arguments_nodes.size() != 2)\n+        return;\n+\n+    const auto * second_argument_constant_node = function_arguments_nodes[1]->as<ConstantNode>();\n+    if (!second_argument_constant_node)\n+        return;\n+\n+    const auto & data_type_concrete = assert_cast<const DataType &>(*ctx.column.type);\n+    auto subcolumn_name = getSubcolumnNameForElement(second_argument_constant_node->getValue(), data_type_concrete);\n+\n+    if (subcolumn_name.empty())\n+        return;\n+\n+    NameAndTypePair column{ctx.column.name + \".\" + subcolumn_name, function_node.getResultType()};\n+    node = std::make_shared<ColumnNode>(column, ctx.column_source);\n+}\n+\n+std::map<std::pair<TypeIndex, String>, NodeToSubcolumnTransformer> node_transformers =\n+{\n+    {\n+        {TypeIndex::Array, \"length\"}, optimizeFunctionLength,\n+    },\n+    {\n+        {TypeIndex::Array, \"empty\"}, optimizeFunctionEmpty<true>,\n+    },\n+    {\n+        {TypeIndex::Array, \"notEmpty\"}, optimizeFunctionEmpty<false>,\n+    },\n+    {\n+        {TypeIndex::Map, \"length\"}, optimizeFunctionLength,\n+    },\n+    {\n+        {TypeIndex::Map, \"empty\"}, optimizeFunctionEmpty<true>,\n+    },\n+    {\n+        {TypeIndex::Map, \"notEmpty\"}, optimizeFunctionEmpty<false>,\n+    },\n+    {\n+        {TypeIndex::Map, \"mapKeys\"},\n+        [](QueryTreeNodePtr & node, FunctionNode & function_node, ColumnContext & ctx)\n+        {\n+            /// Replace `mapKeys(map_argument)` with `map_argument.keys`\n+            NameAndTypePair column{ctx.column.name + \".keys\", function_node.getResultType()};\n+            node = std::make_shared<ColumnNode>(column, ctx.column_source);\n+        },\n+    },\n+    {\n+        {TypeIndex::Map, \"mapValues\"},\n+        [](QueryTreeNodePtr & node, FunctionNode & function_node, ColumnContext & ctx)\n+        {\n+            /// Replace `mapValues(map_argument)` with `map_argument.values`\n+            NameAndTypePair column{ctx.column.name + \".values\", function_node.getResultType()};\n+            node = std::make_shared<ColumnNode>(column, ctx.column_source);\n+        },\n+    },\n+    {\n+        {TypeIndex::Map, \"mapContains\"},\n+        [](QueryTreeNodePtr &, FunctionNode & function_node, ColumnContext & ctx)\n+        {\n+            /// Replace `mapContains(map_argument, argument)` with `has(map_argument.keys, argument)`\n+            const auto & data_type_map = assert_cast<const DataTypeMap &>(*ctx.column.type);\n+\n+            NameAndTypePair column{ctx.column.name + \".keys\", std::make_shared<DataTypeArray>(data_type_map.getKeyType())};\n+            auto & function_arguments_nodes = function_node.getArguments().getNodes();\n+\n+            auto has_function_argument = std::make_shared<ColumnNode>(column, ctx.column_source);\n+            function_arguments_nodes[0] = std::move(has_function_argument);\n+\n+            resolveOrdinaryFunctionNodeByName(function_node, \"has\", ctx.context);\n+        },\n+    },\n+    {\n+        {TypeIndex::Nullable, \"count\"},\n+        [](QueryTreeNodePtr &, FunctionNode & function_node, ColumnContext & ctx)\n+        {\n+            /// Replace `count(nullable_argument)` with `sum(not(nullable_argument.null))`\n+            NameAndTypePair column{ctx.column.name + \".null\", std::make_shared<DataTypeUInt8>()};\n+            auto & function_arguments_nodes = function_node.getArguments().getNodes();\n+\n+            auto new_column_node = std::make_shared<ColumnNode>(column, ctx.column_source);\n+            auto function_node_not = std::make_shared<FunctionNode>(\"not\");\n+\n+            function_node_not->getArguments().getNodes().push_back(std::move(new_column_node));\n+            resolveOrdinaryFunctionNodeByName(*function_node_not, \"not\", ctx.context);\n+\n+            function_arguments_nodes = {std::move(function_node_not)};\n+            resolveAggregateFunctionNodeByName(function_node, \"sum\");\n+        },\n+    },\n+    {\n+        {TypeIndex::Nullable, \"isNull\"},\n+        [](QueryTreeNodePtr & node, FunctionNode &, ColumnContext & ctx)\n+        {\n+            /// Replace `isNull(nullable_argument)` with `nullable_argument.null`\n+            NameAndTypePair column{ctx.column.name + \".null\", std::make_shared<DataTypeUInt8>()};\n+            node = std::make_shared<ColumnNode>(column, ctx.column_source);\n+        },\n+    },\n+    {\n+        {TypeIndex::Nullable, \"isNotNull\"},\n+        [](QueryTreeNodePtr &, FunctionNode & function_node, ColumnContext & ctx)\n+        {\n+            /// Replace `isNotNull(nullable_argument)` with `not(nullable_argument.null)`\n+            NameAndTypePair column{ctx.column.name + \".null\", std::make_shared<DataTypeUInt8>()};\n+            auto & function_arguments_nodes = function_node.getArguments().getNodes();\n+\n+            function_arguments_nodes = {std::make_shared<ColumnNode>(column, ctx.column_source)};\n+            resolveOrdinaryFunctionNodeByName(function_node, \"not\", ctx.context);\n+        },\n+    },\n+    {\n+        {TypeIndex::Tuple, \"tupleElement\"}, optimizeTupleOrVariantElement<DataTypeTuple>,\n+    },\n+    {\n+        {TypeIndex::Variant, \"variantElement\"}, optimizeTupleOrVariantElement<DataTypeVariant>,\n+    },\n+};\n+\n+std::tuple<FunctionNode *, ColumnNode *, TableNode *> getTypedNodesForOptimization(const QueryTreeNodePtr & node)\n+{\n+    auto * function_node = node->as<FunctionNode>();\n+    if (!function_node)\n+        return {};\n+\n+    auto & function_arguments_nodes = function_node->getArguments().getNodes();\n+    if (function_arguments_nodes.empty() || function_arguments_nodes.size() > 2)\n+        return {};\n+\n+    auto * first_argument_column_node = function_arguments_nodes.front()->as<ColumnNode>();\n+    if (!first_argument_column_node || first_argument_column_node->getColumnName() == \"__grouping_set\")\n+        return {};\n+\n+    auto column_source = first_argument_column_node->getColumnSource();\n+    auto * table_node = column_source->as<TableNode>();\n+    if (!table_node)\n+        return {};\n+\n+    const auto & storage = table_node->getStorage();\n+    const auto & storage_snapshot = table_node->getStorageSnapshot();\n+    auto column = first_argument_column_node->getColumn();\n+\n+    if (!storage->supportsOptimizationToSubcolumns() || storage->isVirtualColumn(column.name, storage_snapshot->metadata))\n+        return {};\n+\n+    auto column_in_table = storage_snapshot->tryGetColumn(GetColumnsOptions::All, column.name);\n+    if (!column_in_table || !column_in_table->type->equals(*column.type))\n+        return {};\n+\n+    return std::make_tuple(function_node, first_argument_column_node, table_node);\n+}\n+\n+/// First pass collects info about identifiers to determine which identifiers are allowed to optimize.\n+class FunctionToSubcolumnsVisitorFirstPass : public InDepthQueryTreeVisitorWithContext<FunctionToSubcolumnsVisitorFirstPass>\n {\n public:\n-    using Base = InDepthQueryTreeVisitorWithContext<FunctionToSubcolumnsVisitor>;\n+    using Base = InDepthQueryTreeVisitorWithContext<FunctionToSubcolumnsVisitorFirstPass>;\n     using Base::Base;\n \n-    void enterImpl(QueryTreeNodePtr & node) const\n+    void enterImpl(const QueryTreeNodePtr & node)\n     {\n         if (!getSettings().optimize_functions_to_subcolumns)\n             return;\n \n-        auto * function_node = node->as<FunctionNode>();\n-        if (!function_node)\n+        if (auto * table_node = node->as<TableNode>())\n+        {\n+            enterImpl(*table_node);\n             return;\n+        }\n \n-        auto & function_arguments_nodes = function_node->getArguments().getNodes();\n-        size_t function_arguments_nodes_size = function_arguments_nodes.size();\n-\n-        if (function_arguments_nodes.empty() || function_arguments_nodes_size > 2)\n+        if (auto * column_node = node->as<ColumnNode>())\n+        {\n+            enterImpl(*column_node);\n             return;\n+        }\n \n-        auto * first_argument_column_node = function_arguments_nodes.front()->as<ColumnNode>();\n+        auto [function_node, first_argument_node, table_node] = getTypedNodesForOptimization(node);\n+        if (function_node && first_argument_node && table_node)\n+        {\n+            enterImpl(*function_node, *first_argument_node, *table_node);\n+            return;\n+        }\n \n-        if (!first_argument_column_node)\n+        if (const auto * join_node = node->as<JoinNode>())\n+        {\n+            can_wrap_result_columns_with_nullable |= getContext()->getSettingsRef().join_use_nulls;\n             return;\n+        }\n \n-        if (first_argument_column_node->getColumnName() == \"__grouping_set\")\n+        if (const auto * query_node = node->as<QueryNode>())\n+        {\n+            if (query_node->isGroupByWithCube() || query_node->isGroupByWithRollup() || query_node->isGroupByWithGroupingSets())\n+                can_wrap_result_columns_with_nullable |= getContext()->getSettingsRef().group_by_use_nulls;\n             return;\n+        }\n+    }\n \n-        auto column_source = first_argument_column_node->getColumnSource();\n-        auto * table_node = column_source->as<TableNode>();\n+    std::unordered_set<Identifier> getIdentifiersToOptimize() const\n+    {\n+        if (can_wrap_result_columns_with_nullable)\n+        {\n+            /// Do not optimize if we have JOIN with setting join_use_null.\n+            /// Do not optimize if we have GROUP BY WITH ROLLUP/CUBE/GROUPING SETS with setting group_by_use_nulls.\n+            /// It may change the behaviour if subcolumn can be converted\n+            /// to Nullable while the original column cannot (e.g. for Array type).\n+            return {};\n+        }\n \n-        if (!table_node)\n-            return;\n+        /// Do not optimize if full column is requested in other context.\n+        /// It doesn't make sense because it doesn't reduce amount of read data\n+        /// and optimized functions are not computation heavy. But introducing\n+        /// new identifier complicates query analysis and may break it.\n+        ///\n+        /// E.g. query:\n+        ///     SELECT n FROM table GROUP BY n HAVING isNotNull(n)\n+        /// may be optimized to incorrect query:\n+        ///     SELECT n FROM table GROUP BY n HAVING not(n.null)\n+        /// Will produce: `n.null` is not under aggregate function and not in GROUP BY keys)\n+        ///\n+        /// Do not optimize index columns (primary, min-max, secondary),\n+        /// because otherwise analysis of indexes may be broken.\n+        /// TODO: handle subcolumns in index analysis.\n+\n+        std::unordered_set<Identifier> identifiers_to_optimize;\n+        for (const auto & [identifier, count] : optimized_identifiers_count)\n+        {\n+            if (all_key_columns.contains(identifier))\n+                continue;\n \n-        const auto & storage = table_node->getStorage();\n-        if (!storage->supportsSubcolumns())\n-            return;\n+            auto it = identifiers_count.find(identifier);\n+            if (it != identifiers_count.end() && it->second == count)\n+                identifiers_to_optimize.insert(identifier);\n+        }\n \n-        auto column = first_argument_column_node->getColumn();\n-        WhichDataType column_type(column.type);\n+        return identifiers_to_optimize;\n+    }\n+\n+private:\n+    std::unordered_set<Identifier> all_key_columns;\n+    std::unordered_map<Identifier, UInt64> identifiers_count;\n+    std::unordered_map<Identifier, UInt64> optimized_identifiers_count;\n \n-        const auto & function_name = function_node->getFunctionName();\n+    NameSet processed_tables;\n+    bool can_wrap_result_columns_with_nullable = false;\n \n-        if (function_arguments_nodes_size == 1)\n+    void enterImpl(const TableNode & table_node)\n+    {\n+        auto table_name = table_node.getStorage()->getStorageID().getFullTableName();\n+        if (processed_tables.emplace(table_name).second)\n+            return;\n+\n+        auto add_key_columns = [&](const auto & key_columns)\n         {\n-            if (column_type.isArray())\n-            {\n-                if (function_name == \"length\")\n-                {\n-                    /// Replace `length(array_argument)` with `array_argument.size0`\n-                    column.name += \".size0\";\n-                    column.type = std::make_shared<DataTypeUInt64>();\n-\n-                    node = std::make_shared<ColumnNode>(column, column_source);\n-                }\n-                else if (function_name == \"empty\")\n-                {\n-                    /// Replace `empty(array_argument)` with `equals(array_argument.size0, 0)`\n-                    column.name += \".size0\";\n-                    column.type = std::make_shared<DataTypeUInt64>();\n-\n-                    function_arguments_nodes.clear();\n-                    function_arguments_nodes.push_back(std::make_shared<ColumnNode>(column, column_source));\n-                    function_arguments_nodes.push_back(std::make_shared<ConstantNode>(static_cast<UInt64>(0)));\n-\n-                    resolveOrdinaryFunctionNode(*function_node, \"equals\");\n-                }\n-                else if (function_name == \"notEmpty\")\n-                {\n-                    /// Replace `notEmpty(array_argument)` with `notEquals(array_argument.size0, 0)`\n-                    column.name += \".size0\";\n-                    column.type = std::make_shared<DataTypeUInt64>();\n-\n-                    function_arguments_nodes.clear();\n-                    function_arguments_nodes.push_back(std::make_shared<ColumnNode>(column, column_source));\n-                    function_arguments_nodes.push_back(std::make_shared<ConstantNode>(static_cast<UInt64>(0)));\n-\n-                    resolveOrdinaryFunctionNode(*function_node, \"notEquals\");\n-                }\n-            }\n-            else if (column_type.isNullable())\n-            {\n-                if (function_name == \"isNull\")\n-                {\n-                    /// Replace `isNull(nullable_argument)` with `nullable_argument.null`\n-                    column.name += \".null\";\n-                    column.type = std::make_shared<DataTypeUInt8>();\n-\n-                    node = std::make_shared<ColumnNode>(column, column_source);\n-                }\n-                else if (function_name == \"isNotNull\")\n-                {\n-                    /// Replace `isNotNull(nullable_argument)` with `not(nullable_argument.null)`\n-                    column.name += \".null\";\n-                    column.type = std::make_shared<DataTypeUInt8>();\n-\n-                    function_arguments_nodes = {std::make_shared<ColumnNode>(column, column_source)};\n-\n-                    resolveOrdinaryFunctionNode(*function_node, \"not\");\n-                }\n-            }\n-            else if (column_type.isMap())\n+            for (const auto & column_name : key_columns)\n             {\n-                if (function_name == \"mapKeys\")\n-                {\n-                    /// Replace `mapKeys(map_argument)` with `map_argument.keys`\n-                    column.name += \".keys\";\n-                    column.type = function_node->getResultType();\n-\n-                    node = std::make_shared<ColumnNode>(column, column_source);\n-                }\n-                else if (function_name == \"mapValues\")\n-                {\n-                    /// Replace `mapValues(map_argument)` with `map_argument.values`\n-                    column.name += \".values\";\n-                    column.type = function_node->getResultType();\n-\n-                    node = std::make_shared<ColumnNode>(column, column_source);\n-                }\n+                Identifier identifier({table_name, column_name});\n+                all_key_columns.insert(identifier);\n             }\n-        }\n-        else\n-        {\n-            const auto * second_argument_constant_node = function_arguments_nodes[1]->as<ConstantNode>();\n+        };\n \n-            if (function_name == \"tupleElement\" && column_type.isTuple() && second_argument_constant_node)\n-            {\n-                /** Replace `tupleElement(tuple_argument, string_literal)`, `tupleElement(tuple_argument, integer_literal)`\n-                  * with `tuple_argument.column_name`.\n-                  */\n-                const auto & tuple_element_constant_value = second_argument_constant_node->getValue();\n-                const auto & tuple_element_constant_value_type = tuple_element_constant_value.getType();\n-\n-                const auto & data_type_tuple = assert_cast<const DataTypeTuple &>(*column.type);\n-\n-                String subcolumn_name;\n-\n-                if (tuple_element_constant_value_type == Field::Types::String)\n-                {\n-                    subcolumn_name = tuple_element_constant_value.get<const String &>();\n-                }\n-                else if (tuple_element_constant_value_type == Field::Types::UInt64)\n-                {\n-                    auto tuple_column_index = tuple_element_constant_value.get<UInt64>();\n-                    subcolumn_name = data_type_tuple.getNameByPosition(tuple_column_index);\n-                }\n-                else\n-                {\n-                    return;\n-                }\n-\n-                column.name += '.';\n-                column.name += subcolumn_name;\n-                column.type = function_node->getResultType();\n-\n-                node = std::make_shared<ColumnNode>(column, column_source);\n-            }\n-            else if (function_name == \"variantElement\" && isVariant(column_type) && second_argument_constant_node)\n-            {\n-                /// Replace `variantElement(variant_argument, type_name)` with `variant_argument.type_name`.\n-                const auto & variant_element_constant_value = second_argument_constant_node->getValue();\n-                String subcolumn_name;\n+        const auto & metadata_snapshot = table_node.getStorageSnapshot()->metadata;\n+        const auto & primary_key_columns = metadata_snapshot->getColumnsRequiredForPrimaryKey();\n+        const auto & partition_key_columns = metadata_snapshot->getColumnsRequiredForPartitionKey();\n+\n+        add_key_columns(primary_key_columns);\n+        add_key_columns(partition_key_columns);\n+\n+        for (const auto & index : metadata_snapshot->getSecondaryIndices())\n+        {\n+            const auto & index_columns = index.expression->getRequiredColumns();\n+            add_key_columns(index_columns);\n+        }\n+    }\n \n-                if (variant_element_constant_value.getType() != Field::Types::String)\n-                    return;\n+    void enterImpl(const ColumnNode & column_node)\n+    {\n+        if (column_node.getColumnName() == \"__grouping_set\")\n+            return;\n \n-                subcolumn_name = variant_element_constant_value.get<const String &>();\n+        auto column_source = column_node.getColumnSource();\n+        auto * table_node = column_source->as<TableNode>();\n+        if (!table_node)\n+            return;\n \n-                column.name += '.';\n-                column.name += subcolumn_name;\n-                column.type = function_node->getResultType();\n+        auto table_name = table_node->getStorage()->getStorageID().getFullTableName();\n+        Identifier qualified_name({table_name, column_node.getColumnName()});\n \n-                node = std::make_shared<ColumnNode>(column, column_source);\n-            }\n-            else if (function_name == \"mapContains\" && column_type.isMap())\n-            {\n-                const auto & data_type_map = assert_cast<const DataTypeMap &>(*column.type);\n+        ++identifiers_count[qualified_name];\n+    }\n \n-                /// Replace `mapContains(map_argument, argument)` with `has(map_argument.keys, argument)`\n-                column.name += \".keys\";\n-                column.type = std::make_shared<DataTypeArray>(data_type_map.getKeyType());\n+    void enterImpl(const FunctionNode & function_node, const ColumnNode & first_argument_column_node, const TableNode & table_node)\n+    {\n+        /// For queries with FINAL converting function to subcolumn may alter\n+        /// special merging algorithms and produce wrong result of query.\n+        if (table_node.hasTableExpressionModifiers() && table_node.getTableExpressionModifiers()->hasFinal())\n+            return;\n \n-                auto has_function_argument = std::make_shared<ColumnNode>(column, column_source);\n-                function_arguments_nodes[0] = std::move(has_function_argument);\n+        const auto & column = first_argument_column_node.getColumn();\n+        auto table_name = table_node.getStorage()->getStorageID().getFullTableName();\n+        Identifier qualified_name({table_name, column.name});\n \n-                resolveOrdinaryFunctionNode(*function_node, \"has\");\n-            }\n-        }\n+        if (node_transformers.contains({column.type->getTypeId(), function_node.getFunctionName()}))\n+            ++optimized_identifiers_count[qualified_name];\n     }\n+};\n \n+/// Second pass optimizes functions to subcolumns for allowed identifiers.\n+class FunctionToSubcolumnsVisitorSecondPass : public InDepthQueryTreeVisitorWithContext<FunctionToSubcolumnsVisitorSecondPass>\n+{\n private:\n-    void resolveOrdinaryFunctionNode(FunctionNode & function_node, const String & function_name) const\n+    std::unordered_set<Identifier> identifiers_to_optimize;\n+\n+public:\n+    using Base = InDepthQueryTreeVisitorWithContext<FunctionToSubcolumnsVisitorSecondPass>;\n+    using Base::Base;\n+\n+    FunctionToSubcolumnsVisitorSecondPass(ContextPtr context_, std::unordered_set<Identifier> identifiers_to_optimize_)\n+        : Base(std::move(context_)), identifiers_to_optimize(std::move(identifiers_to_optimize_))\n+    {\n+    }\n+\n+    void enterImpl(QueryTreeNodePtr & node) const\n     {\n-        auto function = FunctionFactory::instance().get(function_name, getContext());\n-        function_node.resolveAsFunction(function->build(function_node.getArgumentColumns()));\n+        if (!getSettings().optimize_functions_to_subcolumns)\n+            return;\n+\n+        auto [function_node, first_argument_column_node, table_node] = getTypedNodesForOptimization(node);\n+        if (!function_node || !first_argument_column_node || !table_node)\n+            return;\n+\n+        auto column = first_argument_column_node->getColumn();\n+        auto table_name = table_node->getStorage()->getStorageID().getFullTableName();\n+\n+        Identifier qualified_name({table_name, column.name});\n+        if (!identifiers_to_optimize.contains(qualified_name))\n+            return;\n+\n+        auto transformer_it = node_transformers.find({column.type->getTypeId(), function_node->getFunctionName()});\n+        if (transformer_it != node_transformers.end())\n+        {\n+            ColumnContext ctx{std::move(column), first_argument_column_node->getColumnSource(), getContext()};\n+            transformer_it->second(node, *function_node, ctx);\n+        }\n     }\n };\n \n@@ -226,8 +438,15 @@ class FunctionToSubcolumnsVisitor : public InDepthQueryTreeVisitorWithContext<Fu\n \n void FunctionToSubcolumnsPass::run(QueryTreeNodePtr & query_tree_node, ContextPtr context)\n {\n-    FunctionToSubcolumnsVisitor visitor(context);\n-    visitor.visit(query_tree_node);\n+    FunctionToSubcolumnsVisitorFirstPass first_visitor(context);\n+    first_visitor.visit(query_tree_node);\n+    auto identifiers_to_optimize = first_visitor.getIdentifiersToOptimize();\n+\n+    if (identifiers_to_optimize.empty())\n+        return;\n+\n+    FunctionToSubcolumnsVisitorSecondPass second_visitor(std::move(context), std::move(identifiers_to_optimize));\n+    second_visitor.visit(query_tree_node);\n }\n \n }\ndiff --git a/src/Analyzer/Passes/NormalizeCountVariantsPass.cpp b/src/Analyzer/Passes/NormalizeCountVariantsPass.cpp\nindex e70e08e65f49..f9066b0363cf 100644\n--- a/src/Analyzer/Passes/NormalizeCountVariantsPass.cpp\n+++ b/src/Analyzer/Passes/NormalizeCountVariantsPass.cpp\n@@ -6,6 +6,7 @@\n #include <Analyzer/InDepthQueryTreeVisitor.h>\n #include <Analyzer/ConstantNode.h>\n #include <Analyzer/FunctionNode.h>\n+#include <Analyzer/Utils.h>\n #include <Interpreters/Context.h>\n #include <DataTypes/DataTypesNumber.h>\n \n@@ -47,25 +48,17 @@ class NormalizeCountVariantsVisitor : public InDepthQueryTreeVisitorWithContext<\n \n         if (function_node->getFunctionName() == \"count\" && !first_argument_constant_literal.isNull())\n         {\n-            resolveAsCountAggregateFunction(*function_node);\n             function_node->getArguments().getNodes().clear();\n+            resolveAggregateFunctionNodeByName(*function_node, \"count\");\n         }\n         else if (function_node->getFunctionName() == \"sum\" &&\n             first_argument_constant_literal.getType() == Field::Types::UInt64 &&\n             first_argument_constant_literal.get<UInt64>() == 1)\n         {\n-            resolveAsCountAggregateFunction(*function_node);\n             function_node->getArguments().getNodes().clear();\n+            resolveAggregateFunctionNodeByName(*function_node, \"count\");\n         }\n     }\n-private:\n-    static void resolveAsCountAggregateFunction(FunctionNode & function_node)\n-    {\n-        AggregateFunctionProperties properties;\n-        auto aggregate_function = AggregateFunctionFactory::instance().get(\"count\", NullsAction::EMPTY, {}, {}, properties);\n-\n-        function_node.resolveAsAggregateFunction(std::move(aggregate_function));\n-    }\n };\n \n }\ndiff --git a/src/Analyzer/Passes/OptimizeDateOrDateTimeConverterWithPreimagePass.cpp b/src/Analyzer/Passes/OptimizeDateOrDateTimeConverterWithPreimagePass.cpp\nindex 0c37749c7060..a8364f1ab7a4 100644\n--- a/src/Analyzer/Passes/OptimizeDateOrDateTimeConverterWithPreimagePass.cpp\n+++ b/src/Analyzer/Passes/OptimizeDateOrDateTimeConverterWithPreimagePass.cpp\n@@ -5,6 +5,7 @@\n #include <Analyzer/ColumnNode.h>\n #include <Analyzer/ConstantNode.h>\n #include <Analyzer/FunctionNode.h>\n+#include <Analyzer/Utils.h>\n #include <Analyzer/InDepthQueryTreeVisitor.h>\n #include <Common/DateLUT.h>\n #include <Common/DateLUTImpl.h>\ndiff --git a/src/Analyzer/Passes/RewriteAggregateFunctionWithIfPass.cpp b/src/Analyzer/Passes/RewriteAggregateFunctionWithIfPass.cpp\nindex 3500d8327ac6..05377f8514e5 100644\n--- a/src/Analyzer/Passes/RewriteAggregateFunctionWithIfPass.cpp\n+++ b/src/Analyzer/Passes/RewriteAggregateFunctionWithIfPass.cpp\n@@ -74,8 +74,7 @@ class RewriteAggregateFunctionWithIfVisitor : public InDepthQueryTreeVisitorWith\n \n                 new_arguments[1] = std::move(if_arguments_nodes[0]);\n                 function_arguments_nodes = std::move(new_arguments);\n-                resolveAsAggregateFunctionWithIf(\n-                    *function_node, {function_arguments_nodes[0]->getResultType(), function_arguments_nodes[1]->getResultType()});\n+                resolveAggregateFunctionNodeByName(*function_node, function_node->getFunctionName() + \"If\");\n             }\n         }\n         else if (first_const_node)\n@@ -104,27 +103,10 @@ class RewriteAggregateFunctionWithIfVisitor : public InDepthQueryTreeVisitorWith\n                 new_arguments[1] = std::move(not_function);\n \n                 function_arguments_nodes = std::move(new_arguments);\n-                resolveAsAggregateFunctionWithIf(\n-                    *function_node, {function_arguments_nodes[0]->getResultType(), function_arguments_nodes[1]->getResultType()});\n+                resolveAggregateFunctionNodeByName(*function_node, function_node->getFunctionName() + \"If\");\n             }\n         }\n     }\n-\n-private:\n-    static void resolveAsAggregateFunctionWithIf(FunctionNode & function_node, const DataTypes & argument_types)\n-    {\n-        auto result_type = function_node.getResultType();\n-\n-        AggregateFunctionProperties properties;\n-        auto aggregate_function = AggregateFunctionFactory::instance().get(\n-            function_node.getFunctionName() + \"If\",\n-            function_node.getNullsAction(),\n-            argument_types,\n-            function_node.getAggregateFunction()->getParameters(),\n-            properties);\n-\n-        function_node.resolveAsAggregateFunction(std::move(aggregate_function));\n-    }\n };\n \n }\ndiff --git a/src/Analyzer/Passes/RewriteSumFunctionWithSumAndCountPass.cpp b/src/Analyzer/Passes/RewriteSumFunctionWithSumAndCountPass.cpp\nindex 5646d26f7f60..524ee8077213 100644\n--- a/src/Analyzer/Passes/RewriteSumFunctionWithSumAndCountPass.cpp\n+++ b/src/Analyzer/Passes/RewriteSumFunctionWithSumAndCountPass.cpp\n@@ -73,23 +73,24 @@ class RewriteSumFunctionWithSumAndCountVisitor : public InDepthQueryTreeVisitorW\n \n         const auto lhs = std::make_shared<FunctionNode>(\"sum\");\n         lhs->getArguments().getNodes().push_back(func_plus_minus_nodes[column_id]);\n-        resolveAsAggregateFunctionNode(*lhs, column_type);\n+        resolveAggregateFunctionNodeByName(*lhs, lhs->getFunctionName());\n \n         const auto rhs_count = std::make_shared<FunctionNode>(\"count\");\n         rhs_count->getArguments().getNodes().push_back(func_plus_minus_nodes[column_id]);\n-        resolveAsAggregateFunctionNode(*rhs_count, column_type);\n+        resolveAggregateFunctionNodeByName(*rhs_count, rhs_count->getFunctionName());\n \n         const auto rhs = std::make_shared<FunctionNode>(\"multiply\");\n         rhs->getArguments().getNodes().push_back(func_plus_minus_nodes[literal_id]);\n         rhs->getArguments().getNodes().push_back(rhs_count);\n-        resolveOrdinaryFunctionNode(*rhs, rhs->getFunctionName());\n+        resolveOrdinaryFunctionNodeByName(*rhs, rhs->getFunctionName(), getContext());\n \n         auto new_node = std::make_shared<FunctionNode>(Poco::toLower(func_plus_minus_node->getFunctionName()));\n         if (column_id == 0)\n             new_node->getArguments().getNodes() = {lhs, rhs};\n         else if (column_id == 1)\n             new_node->getArguments().getNodes() = {rhs, lhs};\n-        resolveOrdinaryFunctionNode(*new_node, new_node->getFunctionName());\n+\n+        resolveOrdinaryFunctionNodeByName(*new_node, new_node->getFunctionName(), getContext());\n \n         if (!new_node)\n             return;\n@@ -100,28 +101,7 @@ class RewriteSumFunctionWithSumAndCountVisitor : public InDepthQueryTreeVisitorW\n             res = createCastFunction(res, function_node->getResultType(), getContext());\n \n         node = std::move(res);\n-\n-    }\n-\n-private:\n-    void resolveOrdinaryFunctionNode(FunctionNode & function_node, const String & function_name) const\n-    {\n-        const auto function = FunctionFactory::instance().get(function_name, getContext());\n-        function_node.resolveAsFunction(function->build(function_node.getArgumentColumns()));\n     }\n-\n-    static void resolveAsAggregateFunctionNode(FunctionNode & function_node, const DataTypePtr & argument_type)\n-    {\n-        AggregateFunctionProperties properties;\n-        const auto aggregate_function = AggregateFunctionFactory::instance().get(function_node.getFunctionName(),\n-            NullsAction::EMPTY,\n-            {argument_type},\n-            {},\n-            properties);\n-\n-        function_node.resolveAsAggregateFunction(aggregate_function);\n-    }\n-\n };\n \n }\ndiff --git a/src/Analyzer/Passes/SumIfToCountIfPass.cpp b/src/Analyzer/Passes/SumIfToCountIfPass.cpp\nindex 852cbe75c4ad..f52d724f3463 100644\n--- a/src/Analyzer/Passes/SumIfToCountIfPass.cpp\n+++ b/src/Analyzer/Passes/SumIfToCountIfPass.cpp\n@@ -5,6 +5,7 @@\n \n #include <AggregateFunctions/AggregateFunctionFactory.h>\n #include <AggregateFunctions/IAggregateFunction.h>\n+#include <Analyzer/Utils.h>\n \n #include <Functions/FunctionFactory.h>\n \n@@ -65,7 +66,8 @@ class SumIfToCountIfVisitor : public InDepthQueryTreeVisitorWithContext<SumIfToC\n             auto multiplier_node = function_node_arguments_nodes[0];\n             function_node_arguments_nodes[0] = std::move(function_node_arguments_nodes[1]);\n             function_node_arguments_nodes.resize(1);\n-            resolveAsCountIfAggregateFunction(*function_node, function_node_arguments_nodes[0]->getResultType());\n+\n+            resolveAggregateFunctionNodeByName(*function_node, \"countIf\");\n \n             if (constant_value_literal.get<UInt64>() != 1)\n             {\n@@ -115,7 +117,7 @@ class SumIfToCountIfVisitor : public InDepthQueryTreeVisitorWithContext<SumIfToC\n             function_node_arguments_nodes[0] = nested_if_function_arguments_nodes[0];\n             function_node_arguments_nodes.resize(1);\n \n-            resolveAsCountIfAggregateFunction(*function_node, function_node_arguments_nodes[0]->getResultType());\n+            resolveAggregateFunctionNodeByName(*function_node, \"countIf\");\n \n             if (if_true_condition_value != 1)\n             {\n@@ -144,7 +146,7 @@ class SumIfToCountIfVisitor : public InDepthQueryTreeVisitorWithContext<SumIfToC\n             function_node_arguments_nodes[0] = std::move(not_function);\n             function_node_arguments_nodes.resize(1);\n \n-            resolveAsCountIfAggregateFunction(*function_node, function_node_arguments_nodes[0]->getResultType());\n+            resolveAggregateFunctionNodeByName(*function_node, \"countIf\");\n \n             if (if_false_condition_value != 1)\n             {\n@@ -156,15 +158,6 @@ class SumIfToCountIfVisitor : public InDepthQueryTreeVisitorWithContext<SumIfToC\n     }\n \n private:\n-    static void resolveAsCountIfAggregateFunction(FunctionNode & function_node, const DataTypePtr & argument_type)\n-    {\n-        AggregateFunctionProperties properties;\n-        auto aggregate_function = AggregateFunctionFactory::instance().get(\n-            \"countIf\", NullsAction::EMPTY, {argument_type}, function_node.getAggregateFunction()->getParameters(), properties);\n-\n-        function_node.resolveAsAggregateFunction(std::move(aggregate_function));\n-    }\n-\n     QueryTreeNodePtr getMultiplyFunction(QueryTreeNodePtr left, QueryTreeNodePtr right)\n     {\n         auto multiply_function_node = std::make_shared<FunctionNode>(\"multiply\");\ndiff --git a/src/Analyzer/Passes/UniqInjectiveFunctionsEliminationPass.cpp b/src/Analyzer/Passes/UniqInjectiveFunctionsEliminationPass.cpp\nindex 91186db0e0cf..947952ac3a80 100644\n--- a/src/Analyzer/Passes/UniqInjectiveFunctionsEliminationPass.cpp\n+++ b/src/Analyzer/Passes/UniqInjectiveFunctionsEliminationPass.cpp\n@@ -7,6 +7,7 @@\n \n #include <Analyzer/InDepthQueryTreeVisitor.h>\n #include <Analyzer/FunctionNode.h>\n+#include <Analyzer/Utils.h>\n \n \n namespace DB\ndiff --git a/src/Analyzer/Passes/UniqToCountPass.cpp b/src/Analyzer/Passes/UniqToCountPass.cpp\nindex b801865c9a5a..83705f54b38e 100644\n--- a/src/Analyzer/Passes/UniqToCountPass.cpp\n+++ b/src/Analyzer/Passes/UniqToCountPass.cpp\n@@ -7,6 +7,7 @@\n #include <Analyzer/FunctionNode.h>\n #include <Analyzer/InDepthQueryTreeVisitor.h>\n #include <Analyzer/QueryNode.h>\n+#include <Analyzer/Utils.h>\n \n namespace DB\n {\n@@ -184,11 +185,8 @@ class UniqToCountVisitor : public InDepthQueryTreeVisitorWithContext<UniqToCount\n         /// Replace uniq of initial query to count\n         if (match_subquery_with_distinct() || match_subquery_with_group_by())\n         {\n-            AggregateFunctionProperties properties;\n-            auto aggregate_function = AggregateFunctionFactory::instance().get(\"count\", NullsAction::EMPTY, {}, {}, properties);\n-\n             function_node->getArguments().getNodes().clear();\n-            function_node->resolveAsAggregateFunction(std::move(aggregate_function));\n+            resolveAggregateFunctionNodeByName(*function_node, \"count\");\n         }\n     }\n };\ndiff --git a/src/Analyzer/Utils.cpp b/src/Analyzer/Utils.cpp\nindex 3c3489681f6a..cf4a3f77e348 100644\n--- a/src/Analyzer/Utils.cpp\n+++ b/src/Analyzer/Utils.cpp\n@@ -636,16 +636,16 @@ class CheckFunctionExistsVisitor : public ConstInDepthQueryTreeVisitor<CheckFunc\n     bool has_function = false;\n };\n \n-inline AggregateFunctionPtr resolveAggregateFunction(FunctionNode * function_node)\n+inline AggregateFunctionPtr resolveAggregateFunction(FunctionNode & function_node, const String & function_name)\n {\n     Array parameters;\n-    for (const auto & param : function_node->getParameters())\n+    for (const auto & param : function_node.getParameters())\n     {\n         auto * constant = param->as<ConstantNode>();\n         parameters.push_back(constant->getValue());\n     }\n \n-    const auto & function_node_argument_nodes = function_node->getArguments().getNodes();\n+    const auto & function_node_argument_nodes = function_node.getArguments().getNodes();\n \n     DataTypes argument_types;\n     argument_types.reserve(function_node_argument_nodes.size());\n@@ -655,7 +655,7 @@ inline AggregateFunctionPtr resolveAggregateFunction(FunctionNode * function_nod\n \n     AggregateFunctionProperties properties;\n     auto action = NullsAction::EMPTY;\n-    return AggregateFunctionFactory::instance().get(function_node->getFunctionName(), action, argument_types, parameters, properties);\n+    return AggregateFunctionFactory::instance().get(function_name, action, argument_types, parameters, properties);\n }\n \n }\n@@ -736,11 +736,11 @@ void rerunFunctionResolve(FunctionNode * function_node, ContextPtr context)\n     {\n         if (name == \"nothing\" || name == \"nothingUInt64\" || name == \"nothingNull\")\n             return;\n-        function_node->resolveAsAggregateFunction(resolveAggregateFunction(function_node));\n+        function_node->resolveAsAggregateFunction(resolveAggregateFunction(*function_node, function_node->getFunctionName()));\n     }\n     else if (function_node->isWindowFunction())\n     {\n-        function_node->resolveAsWindowFunction(resolveAggregateFunction(function_node));\n+        function_node->resolveAsWindowFunction(resolveAggregateFunction(*function_node, function_node->getFunctionName()));\n     }\n }\n \n@@ -793,6 +793,18 @@ QueryTreeNodePtr createCastFunction(QueryTreeNodePtr node, DataTypePtr result_ty\n     return function_node;\n }\n \n+void resolveOrdinaryFunctionNodeByName(FunctionNode & function_node, const String & function_name, const ContextPtr & context)\n+{\n+    auto function = FunctionFactory::instance().get(function_name, context);\n+    function_node.resolveAsFunction(function->build(function_node.getArgumentColumns()));\n+}\n+\n+void resolveAggregateFunctionNodeByName(FunctionNode & function_node, const String & function_name)\n+{\n+    auto aggregate_function = resolveAggregateFunction(function_node, function_name);\n+    function_node.resolveAsAggregateFunction(std::move(aggregate_function));\n+}\n+\n /** Returns:\n   * {_, false} - multiple sources\n   * {nullptr, true} - no sources (for constants)\ndiff --git a/src/Analyzer/Utils.h b/src/Analyzer/Utils.h\nindex f64b724abebd..f2e2c500384f 100644\n--- a/src/Analyzer/Utils.h\n+++ b/src/Analyzer/Utils.h\n@@ -112,6 +112,14 @@ NameSet collectIdentifiersFullNames(const QueryTreeNodePtr & node);\n /// Wrap node into `_CAST` function\n QueryTreeNodePtr createCastFunction(QueryTreeNodePtr node, DataTypePtr result_type, ContextPtr context);\n \n+/// Resolves function node as ordinary function with given name.\n+/// Arguments and parameters are taken from the node.\n+void resolveOrdinaryFunctionNodeByName(FunctionNode & function_node, const String & function_name, const ContextPtr & context);\n+\n+/// Resolves function node as aggregate function with given name.\n+/// Arguments and parameters are taken from the node.\n+void resolveAggregateFunctionNodeByName(FunctionNode & function_node, const String & function_name);\n+\n /// Checks that node has only one source and returns it\n QueryTreeNodePtr getExpressionSource(const QueryTreeNodePtr & node);\n \ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex d84e5b149f6f..357c486aa75b 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -623,7 +623,7 @@ class IColumn;\n     M(Bool, optimize_if_chain_to_multiif, false, \"Replace if(cond1, then1, if(cond2, ...)) chains to multiIf. Currently it's not beneficial for numeric types.\", 0) \\\n     M(Bool, optimize_multiif_to_if, true, \"Replace 'multiIf' with only one condition to 'if'.\", 0) \\\n     M(Bool, optimize_if_transform_strings_to_enum, false, \"Replaces string-type arguments in If and Transform to enum. Disabled by default cause it could make inconsistent change in distributed query that would lead to its fail.\", 0) \\\n-    M(Bool, optimize_functions_to_subcolumns, false, \"Transform functions to subcolumns, if possible, to reduce amount of read data. E.g. 'length(arr)' -> 'arr.size0', 'col IS NULL' -> 'col.null' \", 0) \\\n+    M(Bool, optimize_functions_to_subcolumns, true, \"Transform functions to subcolumns, if possible, to reduce amount of read data. E.g. 'length(arr)' -> 'arr.size0', 'col IS NULL' -> 'col.null' \", 0) \\\n     M(Bool, optimize_using_constraints, false, \"Use constraints for query optimization\", 0)                                                                                                                                           \\\n     M(Bool, optimize_substitute_columns, false, \"Use constraints for column substitution\", 0)                                                                                                                                         \\\n     M(Bool, optimize_append_index, false, \"Use constraints in order to append index condition (indexHint)\", 0) \\\ndiff --git a/src/Core/SettingsChangesHistory.cpp b/src/Core/SettingsChangesHistory.cpp\nindex 7719fe1e8372..f89788de923d 100644\n--- a/src/Core/SettingsChangesHistory.cpp\n+++ b/src/Core/SettingsChangesHistory.cpp\n@@ -58,6 +58,7 @@ String ClickHouseVersion::toString() const\n static std::initializer_list<std::pair<ClickHouseVersion, SettingsChangesHistory::SettingsChanges>> settings_changes_history_initializer =\n {\n     {\"24.7\", {{\"output_format_parquet_write_page_index\", false, true, \"Add a possibility to write page index into parquet files.\"},\n+              {\"optimize_functions_to_subcolumns\", false, true, \"Enable optimization by default\"},\n               {\"input_format_json_ignore_key_case\", false, false, \"Ignore json key case while read json field from string.\"},\n               {\"optimize_trivial_insert_select\", true, false, \"The optimization does not make sense in many cases.\"},\n               }},\ndiff --git a/src/DataTypes/DataTypeTuple.cpp b/src/DataTypes/DataTypeTuple.cpp\nindex a4c8ed1a241b..e96937d522d7 100644\n--- a/src/DataTypes/DataTypeTuple.cpp\n+++ b/src/DataTypes/DataTypeTuple.cpp\n@@ -32,7 +32,7 @@ namespace ErrorCodes\n     extern const int NOT_FOUND_COLUMN_IN_BLOCK;\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n     extern const int SIZES_OF_COLUMNS_IN_TUPLE_DOESNT_MATCH;\n-    extern const int ILLEGAL_INDEX;\n+    extern const int ARGUMENT_OUT_OF_BOUND;\n     extern const int LOGICAL_ERROR;\n }\n \n@@ -286,7 +286,7 @@ std::optional<size_t> DataTypeTuple::tryGetPositionByName(const String & name) c\n String DataTypeTuple::getNameByPosition(size_t i) const\n {\n     if (i == 0 || i > names.size())\n-        throw Exception(ErrorCodes::ILLEGAL_INDEX, \"Index of tuple element ({}) if out range ([1, {}])\", i, names.size());\n+        throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, \"Index of tuple element ({}) is out range ([1, {}])\", i, names.size());\n \n     return names[i - 1];\n }\ndiff --git a/src/Functions/array/FunctionsMapMiscellaneous.cpp b/src/Functions/array/FunctionsMapMiscellaneous.cpp\nindex 76c1ec18171c..c3586a571618 100644\n--- a/src/Functions/array/FunctionsMapMiscellaneous.cpp\n+++ b/src/Functions/array/FunctionsMapMiscellaneous.cpp\n@@ -51,6 +51,8 @@ class FunctionMapToArrayAdapter : public IFunction\n \n     bool isVariadic() const override { return impl.isVariadic(); }\n     size_t getNumberOfArguments() const override { return impl.getNumberOfArguments(); }\n+    bool useDefaultImplementationForNulls() const override { return impl.useDefaultImplementationForNulls(); }\n+    bool useDefaultImplementationForLowCardinalityColumns() const override { return impl.useDefaultImplementationForLowCardinalityColumns(); }\n     bool useDefaultImplementationForConstants() const override { return impl.useDefaultImplementationForConstants(); }\n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo &) const override  { return false; }\n \n@@ -184,7 +186,7 @@ struct MapToNestedAdapter : public MapAdapterBase<MapToNestedAdapter<Name, retur\n template <typename Name, size_t position>\n struct MapToSubcolumnAdapter\n {\n-    static_assert(position <= 1);\n+    static_assert(position <= 1, \"position of Map subcolumn must be 0 or 1\");\n \n     static void extractNestedTypes(DataTypes & types)\n     {\n@@ -357,7 +359,7 @@ struct NameMapValues { static constexpr auto name = \"mapValues\"; };\n using FunctionMapValues = FunctionMapToArrayAdapter<FunctionIdentity, MapToSubcolumnAdapter<NameMapValues, 1>, NameMapValues>;\n \n struct NameMapContains { static constexpr auto name = \"mapContains\"; };\n-using FunctionMapContains = FunctionMapToArrayAdapter<FunctionArrayIndex<HasAction, NameMapContains>, MapToSubcolumnAdapter<NameMapKeys, 0>, NameMapContains>;\n+using FunctionMapContains = FunctionMapToArrayAdapter<FunctionArrayIndex<HasAction, NameMapContains>, MapToSubcolumnAdapter<NameMapContains, 0>, NameMapContains>;\n \n struct NameMapFilter { static constexpr auto name = \"mapFilter\"; };\n using FunctionMapFilter = FunctionMapToArrayAdapter<FunctionArrayFilter, MapToNestedAdapter<NameMapFilter>, NameMapFilter>;\ndiff --git a/src/Interpreters/InterpreterExplainQuery.cpp b/src/Interpreters/InterpreterExplainQuery.cpp\nindex 3a06e1b2301b..7c7b4b3f95a1 100644\n--- a/src/Interpreters/InterpreterExplainQuery.cpp\n+++ b/src/Interpreters/InterpreterExplainQuery.cpp\n@@ -43,6 +43,7 @@ namespace ErrorCodes\n     extern const int UNKNOWN_SETTING;\n     extern const int LOGICAL_ERROR;\n     extern const int NOT_IMPLEMENTED;\n+    extern const int BAD_ARGUMENTS;\n }\n \n namespace\n@@ -170,6 +171,7 @@ struct QueryASTSettings\n struct QueryTreeSettings\n {\n     bool run_passes = true;\n+    bool dump_tree = true;\n     bool dump_passes = false;\n     bool dump_ast = false;\n     Int64 passes = -1;\n@@ -179,6 +181,7 @@ struct QueryTreeSettings\n     std::unordered_map<std::string, std::reference_wrapper<bool>> boolean_settings =\n     {\n         {\"run_passes\", run_passes},\n+        {\"dump_tree\", dump_tree},\n         {\"dump_passes\", dump_passes},\n         {\"dump_ast\", dump_ast}\n     };\n@@ -398,7 +401,11 @@ QueryPipeline InterpreterExplainQuery::executeImpl()\n                 throw Exception(ErrorCodes::INCORRECT_QUERY, \"Only SELECT is supported for EXPLAIN QUERY TREE query\");\n \n             auto settings = checkAndGetSettings<QueryTreeSettings>(ast.getSettings());\n+            if (!settings.dump_tree && !settings.dump_ast)\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Either 'dump_tree' or 'dump_ast' must be set for EXPLAIN QUERY TREE query\");\n+\n             auto query_tree = buildQueryTree(ast.getExplainedQuery(), getContext());\n+            bool need_newline = false;\n \n             if (settings.run_passes)\n             {\n@@ -410,23 +417,26 @@ QueryPipeline InterpreterExplainQuery::executeImpl()\n                 if (settings.dump_passes)\n                 {\n                     query_tree_pass_manager.dump(buf, pass_index);\n-                    if (pass_index > 0)\n-                        buf << '\\n';\n+                    need_newline = true;\n                 }\n \n                 query_tree_pass_manager.run(query_tree, pass_index);\n-\n-                query_tree->dumpTree(buf);\n             }\n-            else\n+\n+            if (settings.dump_tree)\n             {\n+                if (need_newline)\n+                    buf << \"\\n\\n\";\n+\n                 query_tree->dumpTree(buf);\n+                need_newline = true;\n             }\n \n             if (settings.dump_ast)\n             {\n-                buf << '\\n';\n-                buf << '\\n';\n+                if (need_newline)\n+                    buf << \"\\n\\n\";\n+\n                 query_tree->toAST()->format(IAST::FormatSettings(buf, false));\n             }\n \ndiff --git a/src/Interpreters/RewriteFunctionToSubcolumnVisitor.cpp b/src/Interpreters/RewriteFunctionToSubcolumnVisitor.cpp\ndeleted file mode 100644\nindex f02021997529..000000000000\n--- a/src/Interpreters/RewriteFunctionToSubcolumnVisitor.cpp\n+++ /dev/null\n@@ -1,157 +0,0 @@\n-#include <DataTypes/DataTypeTuple.h>\n-#include <DataTypes/NestedUtils.h>\n-#include <Interpreters/RewriteFunctionToSubcolumnVisitor.h>\n-#include <Parsers/ASTFunction.h>\n-#include <Parsers/ASTIdentifier.h>\n-#include <Parsers/ASTLiteral.h>\n-#include <Common/assert_cast.h>\n-\n-namespace DB\n-{\n-\n-namespace\n-{\n-\n-ASTPtr transformToSubcolumn(const String & name_in_storage, const String & subcolumn_name)\n-{\n-    return std::make_shared<ASTIdentifier>(Nested::concatenateName(name_in_storage, subcolumn_name));\n-}\n-\n-ASTPtr transformEmptyToSubcolumn(const String & name_in_storage, const String & subcolumn_name)\n-{\n-    auto ast = transformToSubcolumn(name_in_storage, subcolumn_name);\n-    return makeASTFunction(\"equals\", ast, std::make_shared<ASTLiteral>(0u));\n-}\n-\n-ASTPtr transformNotEmptyToSubcolumn(const String & name_in_storage, const String & subcolumn_name)\n-{\n-    auto ast = transformToSubcolumn(name_in_storage, subcolumn_name);\n-    return makeASTFunction(\"notEquals\", ast, std::make_shared<ASTLiteral>(0u));\n-}\n-\n-ASTPtr transformIsNotNullToSubcolumn(const String & name_in_storage, const String & subcolumn_name)\n-{\n-    auto ast = transformToSubcolumn(name_in_storage, subcolumn_name);\n-    return makeASTFunction(\"not\", ast);\n-}\n-\n-ASTPtr transformCountNullableToSubcolumn(const String & name_in_storage, const String & subcolumn_name)\n-{\n-    auto ast = transformToSubcolumn(name_in_storage, subcolumn_name);\n-    return makeASTFunction(\"sum\", makeASTFunction(\"not\", ast));\n-}\n-\n-ASTPtr transformMapContainsToSubcolumn(const String & name_in_storage, const String & subcolumn_name, const ASTPtr & arg)\n-{\n-    auto ast = transformToSubcolumn(name_in_storage, subcolumn_name);\n-    return makeASTFunction(\"has\", ast, arg);\n-}\n-\n-const std::unordered_map<String, std::tuple<TypeIndex, String, decltype(&transformToSubcolumn)>> unary_function_to_subcolumn =\n-{\n-    {\"length\",    {TypeIndex::Array, \"size0\", transformToSubcolumn}},\n-    {\"empty\",     {TypeIndex::Array, \"size0\", transformEmptyToSubcolumn}},\n-    {\"notEmpty\",  {TypeIndex::Array, \"size0\", transformNotEmptyToSubcolumn}},\n-    {\"isNull\",    {TypeIndex::Nullable, \"null\", transformToSubcolumn}},\n-    {\"isNotNull\", {TypeIndex::Nullable, \"null\", transformIsNotNullToSubcolumn}},\n-    {\"count\",     {TypeIndex::Nullable, \"null\", transformCountNullableToSubcolumn}},\n-    {\"mapKeys\",   {TypeIndex::Map, \"keys\", transformToSubcolumn}},\n-    {\"mapValues\", {TypeIndex::Map, \"values\", transformToSubcolumn}},\n-};\n-\n-const std::unordered_map<String, std::tuple<TypeIndex, String, decltype(&transformMapContainsToSubcolumn)>> binary_function_to_subcolumn\n-{\n-    {\"mapContains\", {TypeIndex::Map, \"keys\", transformMapContainsToSubcolumn}},\n-};\n-\n-}\n-\n-void RewriteFunctionToSubcolumnData::visit(ASTFunction & function, ASTPtr & ast) const\n-{\n-    const auto & arguments = function.arguments->children;\n-    if (arguments.empty() || arguments.size() > 2)\n-        return;\n-\n-    const auto * identifier = arguments[0]->as<ASTIdentifier>();\n-    if (!identifier)\n-        return;\n-\n-    const auto & columns = metadata_snapshot->getColumns();\n-    const auto & name_in_storage = identifier->name();\n-\n-    if (!columns.has(name_in_storage))\n-        return;\n-\n-    const auto & column_type = columns.get(name_in_storage).type;\n-    TypeIndex column_type_id = column_type->getTypeId();\n-    const auto & alias = function.tryGetAlias();\n-\n-    if (arguments.size() == 1)\n-    {\n-        auto it = unary_function_to_subcolumn.find(function.name);\n-        if (it != unary_function_to_subcolumn.end())\n-        {\n-            const auto & [type_id, subcolumn_name, transformer] = it->second;\n-            if (column_type_id == type_id)\n-            {\n-                ast = transformer(name_in_storage, subcolumn_name);\n-                ast->setAlias(alias);\n-            }\n-        }\n-    }\n-    else\n-    {\n-        if (function.name == \"tupleElement\" && column_type_id == TypeIndex::Tuple)\n-        {\n-            const auto * literal = arguments[1]->as<ASTLiteral>();\n-            if (!literal)\n-                return;\n-\n-            String subcolumn_name;\n-            auto value_type = literal->value.getType();\n-            if (value_type == Field::Types::UInt64)\n-            {\n-                const auto & type_tuple = assert_cast<const DataTypeTuple &>(*column_type);\n-                auto index = literal->value.get<UInt64>();\n-                subcolumn_name = type_tuple.getNameByPosition(index);\n-            }\n-            else if (value_type == Field::Types::String)\n-                subcolumn_name = literal->value.get<const String &>();\n-            else\n-                return;\n-\n-            ast = transformToSubcolumn(name_in_storage, subcolumn_name);\n-            ast->setAlias(alias);\n-        }\n-        else if (function.name == \"variantElement\" && column_type_id == TypeIndex::Variant)\n-        {\n-            const auto * literal = arguments[1]->as<ASTLiteral>();\n-            if (!literal)\n-                return;\n-\n-            String subcolumn_name;\n-            auto value_type = literal->value.getType();\n-            if (value_type != Field::Types::String)\n-                return;\n-\n-            subcolumn_name = literal->value.get<const String &>();\n-            ast = transformToSubcolumn(name_in_storage, subcolumn_name);\n-            ast->setAlias(alias);\n-        }\n-        else\n-        {\n-            auto it = binary_function_to_subcolumn.find(function.name);\n-            if (it != binary_function_to_subcolumn.end())\n-            {\n-                const auto & [type_id, subcolumn_name, transformer] = it->second;\n-                if (column_type_id == type_id)\n-                {\n-                    ast = transformer(name_in_storage, subcolumn_name, arguments[1]);\n-                    ast->setAlias(alias);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-}\ndiff --git a/src/Interpreters/RewriteFunctionToSubcolumnVisitor.h b/src/Interpreters/RewriteFunctionToSubcolumnVisitor.h\ndeleted file mode 100644\nindex 4d064bdee101..000000000000\n--- a/src/Interpreters/RewriteFunctionToSubcolumnVisitor.h\n+++ /dev/null\n@@ -1,25 +0,0 @@\n-#pragma once\n-\n-#include <Interpreters/InDepthNodeVisitor.h>\n-#include <Storages/StorageInMemoryMetadata.h>\n-\n-namespace DB\n-{\n-\n-class ASTFunction;\n-\n-/// Rewrites functions to subcolumns, if possible, to reduce amount of read data.\n-/// E.g. 'length(arr)' -> 'arr.size0', 'col IS NULL' -> 'col.null'\n-class RewriteFunctionToSubcolumnData\n-{\n-public:\n-    using TypeToVisit = ASTFunction;\n-    void visit(ASTFunction & function, ASTPtr & ast) const;\n-\n-    StorageMetadataPtr metadata_snapshot;\n-};\n-\n-using RewriteFunctionToSubcolumnMatcher = OneTypeMatcher<RewriteFunctionToSubcolumnData>;\n-using RewriteFunctionToSubcolumnVisitor = InDepthNodeVisitor<RewriteFunctionToSubcolumnMatcher, true>;\n-\n-}\ndiff --git a/src/Interpreters/TreeOptimizer.cpp b/src/Interpreters/TreeOptimizer.cpp\nindex c331c8640d60..b88d75cd5a28 100644\n--- a/src/Interpreters/TreeOptimizer.cpp\n+++ b/src/Interpreters/TreeOptimizer.cpp\n@@ -17,7 +17,6 @@\n #include <Interpreters/RewriteCountVariantsVisitor.h>\n #include <Interpreters/ConvertStringsToEnumVisitor.h>\n #include <Interpreters/ConvertFunctionOrLikeVisitor.h>\n-#include <Interpreters/RewriteFunctionToSubcolumnVisitor.h>\n #include <Interpreters/Context.h>\n #include <Interpreters/ExternalDictionariesLoader.h>\n #include <Interpreters/GatherFunctionQuantileVisitor.h>\n@@ -564,12 +563,6 @@ void transformIfStringsIntoEnum(ASTPtr & query)\n     ConvertStringsToEnumVisitor(convert_data).visit(query);\n }\n \n-void optimizeFunctionsToSubcolumns(ASTPtr & query, const StorageMetadataPtr & metadata_snapshot)\n-{\n-    RewriteFunctionToSubcolumnVisitor::Data data{metadata_snapshot};\n-    RewriteFunctionToSubcolumnVisitor(data).visit(query);\n-}\n-\n void optimizeOrLikeChain(ASTPtr & query)\n {\n     ConvertFunctionOrLikeVisitor::Data data = {};\n@@ -634,9 +627,6 @@ void TreeOptimizer::apply(ASTPtr & query, TreeRewriterResult & result,\n     if (!select_query)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Select analyze for not select asts.\");\n \n-    if (settings.optimize_functions_to_subcolumns && result.storage_snapshot && result.storage->supportsSubcolumns())\n-        optimizeFunctionsToSubcolumns(query, result.storage_snapshot->metadata);\n-\n     /// Move arithmetic operations out of aggregation functions\n     if (settings.optimize_arithmetic_operations_in_aggregate_functions)\n         optimizeAggregationFunctions(query);\ndiff --git a/src/Storages/IStorage.h b/src/Storages/IStorage.h\nindex 98afd844046f..6217470780dd 100644\n--- a/src/Storages/IStorage.h\n+++ b/src/Storages/IStorage.h\n@@ -165,6 +165,8 @@ class IStorage : public std::enable_shared_from_this<IStorage>, public TypePromo\n \n     /// Returns true if the storage supports reading of subcolumns of complex types.\n     virtual bool supportsSubcolumns() const { return false; }\n+    /// Returns true if storage supports optimizations of functions by reading subcolumns.\n+    virtual bool supportsOptimizationToSubcolumns() const { return supportsSubcolumns(); }\n \n     /// Returns true if the storage supports transactions for SELECT, INSERT and ALTER queries.\n     /// Storage may throw an exception later if some query kind is not fully supported.\ndiff --git a/src/Storages/IStorageCluster.h b/src/Storages/IStorageCluster.h\nindex f32832476726..893cf222556f 100644\n--- a/src/Storages/IStorageCluster.h\n+++ b/src/Storages/IStorageCluster.h\n@@ -37,7 +37,10 @@ class IStorageCluster : public IStorage\n \n     QueryProcessingStage::Enum getQueryProcessingStage(ContextPtr, QueryProcessingStage::Enum, const StorageSnapshotPtr &, SelectQueryInfo &) const override;\n \n-    bool isRemote() const override { return true; }\n+    bool isRemote() const final { return true; }\n+    bool supportsSubcolumns() const override  { return true; }\n+    bool supportsOptimizationToSubcolumns() const override { return false; }\n+    bool supportsTrivialCountOptimization(const StorageSnapshotPtr &, ContextPtr) const override { return true; }\n \n protected:\n     virtual void updateBeforeRead(const ContextPtr &) {}\ndiff --git a/src/Storages/ObjectStorage/StorageObjectStorageCluster.h b/src/Storages/ObjectStorage/StorageObjectStorageCluster.h\nindex 69fec2b3c77d..108aa1096161 100644\n--- a/src/Storages/ObjectStorage/StorageObjectStorageCluster.h\n+++ b/src/Storages/ObjectStorage/StorageObjectStorageCluster.h\n@@ -24,12 +24,6 @@ class StorageObjectStorageCluster : public IStorageCluster\n \n     std::string getName() const override;\n \n-    bool supportsSubcolumns() const override { return true; }\n-\n-    bool supportsDynamicSubcolumns() const override { return true; }\n-\n-    bool supportsTrivialCountOptimization(const StorageSnapshotPtr &, ContextPtr) const override { return true; }\n-\n     RemoteQueryExecutor::Extension getTaskIteratorExtension(\n         const ActionsDAG::Node * predicate, const ContextPtr & context) const override;\n \ndiff --git a/src/Storages/ObjectStorageQueue/StorageObjectStorageQueue.h b/src/Storages/ObjectStorageQueue/StorageObjectStorageQueue.h\nindex 758721674fe3..fc459c45f740 100644\n--- a/src/Storages/ObjectStorageQueue/StorageObjectStorageQueue.h\n+++ b/src/Storages/ObjectStorageQueue/StorageObjectStorageQueue.h\n@@ -79,6 +79,7 @@ class StorageObjectStorageQueue : public IStorage, WithContext\n     void drop() override;\n     bool supportsSubsetOfColumns(const ContextPtr & context_) const;\n     bool supportsSubcolumns() const override { return true; }\n+    bool supportsOptimizationToSubcolumns() const override { return false; }\n     bool supportsDynamicSubcolumns() const override { return true; }\n \n     std::shared_ptr<FileIterator> createFileIterator(ContextPtr local_context, const ActionsDAG::Node * predicate);\ndiff --git a/src/Storages/StorageFile.h b/src/Storages/StorageFile.h\nindex ac094aeb4896..f955889185ce 100644\n--- a/src/Storages/StorageFile.h\n+++ b/src/Storages/StorageFile.h\n@@ -89,6 +89,7 @@ class StorageFile final : public IStorage\n     bool supportsSubsetOfColumns(const ContextPtr & context) const;\n \n     bool supportsSubcolumns() const override { return true; }\n+    bool supportsOptimizationToSubcolumns() const override { return false; }\n \n     bool supportsDynamicSubcolumns() const override { return true; }\n \ndiff --git a/src/Storages/StorageFileCluster.h b/src/Storages/StorageFileCluster.h\nindex f5a4362901e8..9549f3a035c3 100644\n--- a/src/Storages/StorageFileCluster.h\n+++ b/src/Storages/StorageFileCluster.h\n@@ -27,15 +27,8 @@ class StorageFileCluster : public IStorageCluster\n         const ConstraintsDescription & constraints_);\n \n     std::string getName() const override { return \"FileCluster\"; }\n-\n     RemoteQueryExecutor::Extension getTaskIteratorExtension(const ActionsDAG::Node * predicate, const ContextPtr & context) const override;\n \n-    bool supportsSubcolumns() const override { return true; }\n-\n-    bool supportsDynamicSubcolumns() const override { return true; }\n-\n-    bool supportsTrivialCountOptimization(const StorageSnapshotPtr &, ContextPtr) const override { return true; }\n-\n private:\n     void updateQueryToSendIfNeeded(ASTPtr & query, const StorageSnapshotPtr & storage_snapshot, const ContextPtr & context) override;\n \ndiff --git a/src/Storages/StorageURL.h b/src/Storages/StorageURL.h\nindex 3090f8db12e8..fa7cc6eeeefb 100644\n--- a/src/Storages/StorageURL.h\n+++ b/src/Storages/StorageURL.h\n@@ -296,6 +296,7 @@ class StorageURL : public IStorageURLBase\n     }\n \n     bool supportsSubcolumns() const override { return true; }\n+    bool supportsOptimizationToSubcolumns() const override { return false; }\n \n     bool supportsDynamicSubcolumns() const override { return true; }\n \ndiff --git a/src/Storages/StorageURLCluster.h b/src/Storages/StorageURLCluster.h\nindex a6334e7430d7..31bffa062104 100644\n--- a/src/Storages/StorageURLCluster.h\n+++ b/src/Storages/StorageURLCluster.h\n@@ -30,15 +30,8 @@ class StorageURLCluster : public IStorageCluster\n         const StorageURL::Configuration & configuration_);\n \n     std::string getName() const override { return \"URLCluster\"; }\n-\n     RemoteQueryExecutor::Extension getTaskIteratorExtension(const ActionsDAG::Node * predicate, const ContextPtr & context) const override;\n \n-    bool supportsSubcolumns() const override { return true; }\n-\n-    bool supportsDynamicSubcolumns() const override { return true; }\n-\n-    bool supportsTrivialCountOptimization(const StorageSnapshotPtr &, ContextPtr) const override { return true; }\n-\n private:\n     void updateQueryToSendIfNeeded(ASTPtr & query, const StorageSnapshotPtr & storage_snapshot, const ContextPtr & context) override;\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01872_functions_to_subcolumns.reference b/tests/queries/0_stateless/01872_functions_to_subcolumns.reference\ndeleted file mode 100644\nindex a1cd31e2dc93..000000000000\n--- a/tests/queries/0_stateless/01872_functions_to_subcolumns.reference\n+++ /dev/null\n@@ -1,47 +0,0 @@\n-0\t0\t1\n-0\t1\t0\n-SELECT\n-    id IS NULL,\n-    `n.null`,\n-    NOT `n.null`\n-FROM t_func_to_subcolumns\n-3\t0\t1\t0\n-0\t1\t0\t\\N\n-SELECT\n-    `arr.size0`,\n-    `arr.size0` = 0,\n-    `arr.size0` != 0,\n-    empty(n)\n-FROM t_func_to_subcolumns\n-['foo','bar']\t[1,2]\n-[]\t[]\n-SELECT\n-    `m.keys`,\n-    `m.values`\n-FROM t_func_to_subcolumns\n-1\n-SELECT sum(NOT `n.null`)\n-FROM t_func_to_subcolumns\n-2\n-SELECT count(id)\n-FROM t_func_to_subcolumns\n-1\t0\t0\n-2\t1\t0\n-3\t0\t0\n-SELECT\n-    id,\n-    `n.null`,\n-    right.n IS NULL\n-FROM t_func_to_subcolumns AS left\n-ALL FULL OUTER JOIN\n-(\n-    SELECT\n-        1 AS id,\n-        \\'qqq\\' AS n\n-    UNION ALL\n-    SELECT\n-        3 AS id,\n-        \\'www\\'\n-) AS right USING (id)\n-0\t10\n-0\t20\ndiff --git a/tests/queries/0_stateless/01872_functions_to_subcolumns_analyzer.reference b/tests/queries/0_stateless/01872_functions_to_subcolumns_analyzer.reference\nnew file mode 100644\nindex 000000000000..32bacfba5ea3\n--- /dev/null\n+++ b/tests/queries/0_stateless/01872_functions_to_subcolumns_analyzer.reference\n@@ -0,0 +1,181 @@\n+0\t0\t1\n+0\t1\t0\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    isNull(id) UInt8\n+    isNull(n) UInt8\n+    isNotNull(n) UInt8\n+  PROJECTION\n+    LIST id: 1, nodes: 3\n+      CONSTANT id: 2, constant_value: UInt64_0, constant_value_type: UInt8\n+        EXPRESSION\n+          FUNCTION id: 3, function_name: isNull, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 4, nodes: 1\n+                COLUMN id: 5, column_name: id, result_type: UInt64, source_id: 6\n+      COLUMN id: 7, column_name: n.null, result_type: UInt8, source_id: 6\n+      FUNCTION id: 8, function_name: not, function_type: ordinary, result_type: UInt8\n+        ARGUMENTS\n+          LIST id: 9, nodes: 1\n+            COLUMN id: 10, column_name: n.null, result_type: UInt8, source_id: 6\n+  JOIN TREE\n+    TABLE id: 6, alias: __table1, table_name: default.t_func_to_subcolumns\n+\n+SELECT\n+    _CAST(0, \\'UInt8\\') AS `isNull(id)`,\n+    __table1.`n.null` AS `isNull(n)`,\n+    NOT __table1.`n.null` AS `isNotNull(n)`\n+FROM default.t_func_to_subcolumns AS __table1\n+3\t0\t1\t0\n+0\t1\t0\t\\N\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    length(arr) UInt64\n+    empty(arr) UInt8\n+    notEmpty(arr) UInt8\n+    empty(n) Nullable(UInt8)\n+  PROJECTION\n+    LIST id: 1, nodes: 4\n+      COLUMN id: 2, column_name: arr.size0, result_type: UInt64, source_id: 3\n+      FUNCTION id: 4, function_name: equals, function_type: ordinary, result_type: UInt8\n+        ARGUMENTS\n+          LIST id: 5, nodes: 2\n+            COLUMN id: 6, column_name: arr.size0, result_type: UInt64, source_id: 3\n+            CONSTANT id: 7, constant_value: UInt64_0, constant_value_type: UInt8\n+      FUNCTION id: 8, function_name: notEquals, function_type: ordinary, result_type: UInt8\n+        ARGUMENTS\n+          LIST id: 9, nodes: 2\n+            COLUMN id: 10, column_name: arr.size0, result_type: UInt64, source_id: 3\n+            CONSTANT id: 11, constant_value: UInt64_0, constant_value_type: UInt8\n+      FUNCTION id: 12, function_name: empty, function_type: ordinary, result_type: Nullable(UInt8)\n+        ARGUMENTS\n+          LIST id: 13, nodes: 1\n+            COLUMN id: 14, column_name: n, result_type: Nullable(String), source_id: 3\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.t_func_to_subcolumns\n+\n+SELECT\n+    __table1.`arr.size0` AS `length(arr)`,\n+    __table1.`arr.size0` = 0 AS `empty(arr)`,\n+    __table1.`arr.size0` != 0 AS `notEmpty(arr)`,\n+    empty(__table1.n) AS `empty(n)`\n+FROM default.t_func_to_subcolumns AS __table1\n+['foo','bar']\t[1,2]\n+[]\t[]\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    mapKeys(m) Array(String)\n+    mapValues(m) Array(UInt64)\n+  PROJECTION\n+    LIST id: 1, nodes: 2\n+      COLUMN id: 2, column_name: m.keys, result_type: Array(String), source_id: 3\n+      COLUMN id: 4, column_name: m.values, result_type: Array(UInt64), source_id: 3\n+  JOIN TREE\n+    TABLE id: 3, alias: __table1, table_name: default.t_func_to_subcolumns\n+\n+SELECT\n+    __table1.`m.keys` AS `mapKeys(m)`,\n+    __table1.`m.values` AS `mapValues(m)`\n+FROM default.t_func_to_subcolumns AS __table1\n+1\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count(n) UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: sum, function_type: aggregate, result_type: UInt64\n+        ARGUMENTS\n+          LIST id: 3, nodes: 1\n+            FUNCTION id: 4, function_name: not, function_type: ordinary, result_type: UInt8\n+              ARGUMENTS\n+                LIST id: 5, nodes: 1\n+                  COLUMN id: 6, column_name: n.null, result_type: UInt8, source_id: 7\n+  JOIN TREE\n+    TABLE id: 7, alias: __table1, table_name: default.t_func_to_subcolumns\n+\n+SELECT sum(NOT __table1.`n.null`) AS `count(n)`\n+FROM default.t_func_to_subcolumns AS __table1\n+2\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    count(id) UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      FUNCTION id: 2, function_name: count, function_type: aggregate, result_type: UInt64\n+        ARGUMENTS\n+          LIST id: 3, nodes: 1\n+            COLUMN id: 4, column_name: id, result_type: UInt64, source_id: 5\n+  JOIN TREE\n+    TABLE id: 5, alias: __table1, table_name: default.t_func_to_subcolumns\n+\n+SELECT count(__table1.id) AS `count(id)`\n+FROM default.t_func_to_subcolumns AS __table1\n+1\t0\t0\n+2\t1\t0\n+3\t0\t0\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    id UInt64\n+    isNull(n) UInt8\n+    isNull(right.n) UInt8\n+  PROJECTION\n+    LIST id: 1, nodes: 3\n+      COLUMN id: 2, column_name: id, result_type: UInt64, source_id: 3\n+      COLUMN id: 4, column_name: n.null, result_type: UInt8, source_id: 3\n+      CONSTANT id: 5, constant_value: UInt64_0, constant_value_type: UInt8\n+        EXPRESSION\n+          FUNCTION id: 6, function_name: isNull, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 7, nodes: 1\n+                COLUMN id: 8, column_name: n, result_type: String, source_id: 9\n+  JOIN TREE\n+    JOIN id: 10, strictness: ALL, kind: FULL\n+      LEFT TABLE EXPRESSION\n+        TABLE id: 3, alias: __table1, table_name: default.t_func_to_subcolumns\n+      RIGHT TABLE EXPRESSION\n+        UNION id: 9, alias: __table2, is_subquery: 1, union_mode: UNION_ALL\n+          QUERIES\n+            LIST id: 11, nodes: 2\n+              QUERY id: 12, alias: __table3\n+                PROJECTION COLUMNS\n+                  id UInt8\n+                PROJECTION\n+                  LIST id: 13, nodes: 1\n+                    CONSTANT id: 14, constant_value: UInt64_1, constant_value_type: UInt8\n+                JOIN TREE\n+                  TABLE id: 15, alias: __table4, table_name: system.one\n+              QUERY id: 16, alias: __table5\n+                PROJECTION COLUMNS\n+                  id UInt8\n+                PROJECTION\n+                  LIST id: 17, nodes: 1\n+                    CONSTANT id: 18, constant_value: UInt64_3, constant_value_type: UInt8\n+                JOIN TREE\n+                  TABLE id: 19, alias: __table6, table_name: system.one\n+      JOIN EXPRESSION\n+        LIST id: 20, nodes: 1\n+          COLUMN id: 21, column_name: id, result_type: UInt64, source_id: 10\n+            EXPRESSION\n+              LIST id: 22, nodes: 2\n+                COLUMN id: 23, column_name: id, result_type: UInt64, source_id: 3\n+                COLUMN id: 24, column_name: id, result_type: UInt8, source_id: 9\n+\n+SELECT\n+    __table1.id AS id,\n+    __table1.`n.null` AS `isNull(n)`,\n+    _CAST(0, \\'UInt8\\') AS `isNull(right.n)`\n+FROM default.t_func_to_subcolumns AS __table1\n+ALL FULL OUTER JOIN\n+(\n+    (\n+        SELECT 1 AS id\n+        FROM system.one AS __table4\n+    )\n+    UNION ALL\n+    (\n+        SELECT 3 AS id\n+        FROM system.one AS __table6\n+    )\n+) AS __table2 USING (id)\n+0\t10\n+0\t20\ndiff --git a/tests/queries/0_stateless/01872_functions_to_subcolumns.sql b/tests/queries/0_stateless/01872_functions_to_subcolumns_analyzer.sql\nsimilarity index 62%\nrename from tests/queries/0_stateless/01872_functions_to_subcolumns.sql\nrename to tests/queries/0_stateless/01872_functions_to_subcolumns_analyzer.sql\nindex 45f83bf20e57..b544f6829cf1 100644\n--- a/tests/queries/0_stateless/01872_functions_to_subcolumns.sql\n+++ b/tests/queries/0_stateless/01872_functions_to_subcolumns_analyzer.sql\n@@ -1,5 +1,6 @@\n DROP TABLE IF EXISTS t_func_to_subcolumns;\n \n+SET allow_experimental_analyzer = 1;\n SET optimize_functions_to_subcolumns = 1;\n \n CREATE TABLE t_func_to_subcolumns (id UInt64, arr Array(UInt64), n Nullable(String), m Map(String, UInt64))\n@@ -8,24 +9,24 @@ ENGINE = MergeTree ORDER BY tuple();\n INSERT INTO t_func_to_subcolumns VALUES (1, [1, 2, 3], 'abc', map('foo', 1, 'bar', 2)) (2, [], NULL, map());\n \n SELECT id IS NULL, n IS NULL, n IS NOT NULL FROM t_func_to_subcolumns;\n-EXPLAIN SYNTAX SELECT id IS NULL, n IS NULL, n IS NOT NULL FROM t_func_to_subcolumns;\n+EXPLAIN QUERY TREE dump_tree = 1, dump_ast = 1 SELECT id IS NULL, n IS NULL, n IS NOT NULL FROM t_func_to_subcolumns;\n \n SELECT length(arr), empty(arr), notEmpty(arr), empty(n) FROM t_func_to_subcolumns;\n-EXPLAIN SYNTAX SELECT length(arr), empty(arr), notEmpty(arr), empty(n) FROM t_func_to_subcolumns;\n+EXPLAIN QUERY TREE dump_tree = 1, dump_ast = 1 SELECT length(arr), empty(arr), notEmpty(arr), empty(n) FROM t_func_to_subcolumns;\n \n SELECT mapKeys(m), mapValues(m) FROM t_func_to_subcolumns;\n-EXPLAIN SYNTAX SELECT mapKeys(m), mapValues(m) FROM t_func_to_subcolumns;\n+EXPLAIN QUERY TREE dump_tree = 1, dump_ast = 1 SELECT mapKeys(m), mapValues(m) FROM t_func_to_subcolumns;\n \n SELECT count(n) FROM t_func_to_subcolumns;\n-EXPLAIN SYNTAX SELECT count(n) FROM t_func_to_subcolumns;\n+EXPLAIN QUERY TREE dump_tree = 1, dump_ast = 1 SELECT count(n) FROM t_func_to_subcolumns;\n \n SELECT count(id) FROM t_func_to_subcolumns;\n-EXPLAIN SYNTAX SELECT count(id) FROM t_func_to_subcolumns;\n+EXPLAIN QUERY TREE dump_tree = 1, dump_ast = 1 SELECT count(id) FROM t_func_to_subcolumns;\n \n SELECT id, left.n IS NULL, right.n IS NULL FROM t_func_to_subcolumns AS left\n FULL JOIN (SELECT 1 AS id, 'qqq' AS n UNION ALL SELECT 3 AS id, 'www') AS right USING(id);\n \n-EXPLAIN SYNTAX SELECT id, left.n IS NULL, right.n IS NULL FROM t_func_to_subcolumns AS left\n+EXPLAIN QUERY TREE dump_tree = 1, dump_ast = 1 SELECT id, left.n IS NULL, right.n IS NULL FROM t_func_to_subcolumns AS left\n FULL JOIN (SELECT 1 AS id, 'qqq' AS n UNION ALL SELECT 3 AS id, 'www') AS right USING(id);\n \n DROP TABLE t_func_to_subcolumns;\ndiff --git a/tests/queries/0_stateless/02115_map_contains.reference b/tests/queries/0_stateless/02115_map_contains.reference\ndeleted file mode 100644\nindex 975e9876237d..000000000000\n--- a/tests/queries/0_stateless/02115_map_contains.reference\n+++ /dev/null\n@@ -1,4 +0,0 @@\n-SELECT has(`m.keys`, \\'a\\')\n-FROM t_map_contains\n-1\n-0\ndiff --git a/tests/queries/0_stateless/02115_map_contains_analyzer.reference b/tests/queries/0_stateless/02115_map_contains_analyzer.reference\nnew file mode 100644\nindex 000000000000..7da5243e7270\n--- /dev/null\n+++ b/tests/queries/0_stateless/02115_map_contains_analyzer.reference\n@@ -0,0 +1,4 @@\n+SELECT has(__table1.`m.keys`, \\'a\\') AS `mapContains(m, \\'a\\')`\n+FROM default.t_map_contains AS __table1\n+1\n+0\ndiff --git a/tests/queries/0_stateless/02115_map_contains.sql b/tests/queries/0_stateless/02115_map_contains_analyzer.sql\nsimilarity index 70%\nrename from tests/queries/0_stateless/02115_map_contains.sql\nrename to tests/queries/0_stateless/02115_map_contains_analyzer.sql\nindex 3c7f21cb4f17..46e02eca4f05 100644\n--- a/tests/queries/0_stateless/02115_map_contains.sql\n+++ b/tests/queries/0_stateless/02115_map_contains_analyzer.sql\n@@ -5,8 +5,9 @@ CREATE TABLE t_map_contains (m Map(String, UInt32)) ENGINE = Memory;\n INSERT INTO t_map_contains VALUES (map('a', 1, 'b', 2)), (map('c', 3, 'd', 4));\n \n SET optimize_functions_to_subcolumns = 1;\n+SET allow_experimental_analyzer = 1;\n \n-EXPLAIN SYNTAX SELECT mapContains(m, 'a') FROM t_map_contains;\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT mapContains(m, 'a') FROM t_map_contains;\n SELECT mapContains(m, 'a') FROM t_map_contains;\n \n DROP TABLE t_map_contains;\ndiff --git a/tests/queries/0_stateless/02116_tuple_element.reference b/tests/queries/0_stateless/02116_tuple_element.reference\ndeleted file mode 100644\nindex 121b08d02f1f..000000000000\n--- a/tests/queries/0_stateless/02116_tuple_element.reference\n+++ /dev/null\n@@ -1,25 +0,0 @@\n-1\n-SELECT `t1.a`\n-FROM t_tuple_element\n-a\n-SELECT `t1.s`\n-FROM t_tuple_element\n-1\n-SELECT `t1.a`\n-FROM t_tuple_element\n-2\n-SELECT `t2.1`\n-FROM t_tuple_element\n-2\n-SELECT `t2.1`\n-FROM t_tuple_element\n-1\t2\n-WITH (1, 2) AS t\n-SELECT\n-    t.1,\n-    t.2\n-1\t2\n-WITH CAST(\\'(1, 2)\\', \\'Tuple(a UInt32, b UInt32)\\') AS t\n-SELECT\n-    t.1,\n-    tupleElement(t, \\'b\\')\ndiff --git a/tests/queries/0_stateless/02116_tuple_element_analyzer.reference b/tests/queries/0_stateless/02116_tuple_element_analyzer.reference\nnew file mode 100644\nindex 000000000000..22d48ffb2f37\n--- /dev/null\n+++ b/tests/queries/0_stateless/02116_tuple_element_analyzer.reference\n@@ -0,0 +1,25 @@\n+1\n+SELECT __table1.`t1.a` AS `tupleElement(t1, 1)`\n+FROM default.t_tuple_element AS __table1\n+a\n+SELECT __table1.`t1.s` AS `tupleElement(t1, 2)`\n+FROM default.t_tuple_element AS __table1\n+1\n+SELECT __table1.`t1.a` AS `tupleElement(t1, \\'a\\')`\n+FROM default.t_tuple_element AS __table1\n+2\n+SELECT __table1.`t2.1` AS `tupleElement(t2, 1)`\n+FROM default.t_tuple_element AS __table1\n+2\n+SELECT __table1.`t2.1` AS `tupleElement(t2, 1)`\n+FROM default.t_tuple_element AS __table1\n+1\t2\n+SELECT\n+    _CAST(1, \\'UInt8\\') AS `tupleElement(t, 1)`,\n+    _CAST(2, \\'UInt8\\') AS `tupleElement(t, 2)`\n+FROM system.one AS __table1\n+1\t2\n+SELECT\n+    _CAST(1, \\'UInt32\\') AS `tupleElement(t, 1)`,\n+    _CAST(2, \\'UInt32\\') AS `tupleElement(t, \\'b\\')`\n+FROM system.one AS __table1\ndiff --git a/tests/queries/0_stateless/02116_tuple_element.sql b/tests/queries/0_stateless/02116_tuple_element_analyzer.sql\nsimilarity index 60%\nrename from tests/queries/0_stateless/02116_tuple_element.sql\nrename to tests/queries/0_stateless/02116_tuple_element_analyzer.sql\nindex 64d9b9db331a..5aeb72c9ee47 100644\n--- a/tests/queries/0_stateless/02116_tuple_element.sql\n+++ b/tests/queries/0_stateless/02116_tuple_element_analyzer.sql\n@@ -4,39 +4,40 @@ CREATE TABLE t_tuple_element(t1 Tuple(a UInt32, s String), t2 Tuple(UInt32, Stri\n INSERT INTO t_tuple_element VALUES ((1, 'a'), (2, 'b'));\n \n SET optimize_functions_to_subcolumns = 1;\n+SET allow_experimental_analyzer = 1;\n \n SELECT t1.1 FROM t_tuple_element;\n-EXPLAIN SYNTAX SELECT t1.1 FROM t_tuple_element;\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT t1.1 FROM t_tuple_element;\n \n SELECT tupleElement(t1, 2) FROM t_tuple_element;\n-EXPLAIN SYNTAX SELECT tupleElement(t1, 2) FROM t_tuple_element;\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT tupleElement(t1, 2) FROM t_tuple_element;\n \n SELECT tupleElement(t1, 'a') FROM t_tuple_element;\n-EXPLAIN SYNTAX SELECT tupleElement(t1, 'a') FROM t_tuple_element;\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT tupleElement(t1, 'a') FROM t_tuple_element;\n \n SELECT tupleElement(number, 1) FROM numbers(1); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n SELECT tupleElement(t1) FROM t_tuple_element; -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n SELECT tupleElement(t1, 'b') FROM t_tuple_element; -- { serverError NOT_FOUND_COLUMN_IN_BLOCK, UNKNOWN_IDENTIFIER }\n-SELECT tupleElement(t1, 0) FROM t_tuple_element; -- { serverError ILLEGAL_INDEX, NOT_FOUND_COLUMN_IN_BLOCK }\n-SELECT tupleElement(t1, 3) FROM t_tuple_element; -- { serverError ILLEGAL_INDEX, NOT_FOUND_COLUMN_IN_BLOCK }\n-SELECT tupleElement(t1, materialize('a')) FROM t_tuple_element; -- { serverError ILLEGAL_TYPE_OF_ARGUMENT, NOT_FOUND_COLUMN_IN_BLOCK }\n+SELECT tupleElement(t1, 0) FROM t_tuple_element; -- { serverError ARGUMENT_OUT_OF_BOUND, NOT_FOUND_COLUMN_IN_BLOCK }\n+SELECT tupleElement(t1, 3) FROM t_tuple_element; -- { serverError ARGUMENT_OUT_OF_BOUND, NOT_FOUND_COLUMN_IN_BLOCK }\n+SELECT tupleElement(t1, materialize('a')) FROM t_tuple_element; -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n \n SELECT t2.1 FROM t_tuple_element;\n-EXPLAIN SYNTAX SELECT t2.1 FROM t_tuple_element;\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT t2.1 FROM t_tuple_element;\n \n SELECT tupleElement(t2, 1) FROM t_tuple_element;\n-EXPLAIN SYNTAX SELECT tupleElement(t2, 1) FROM t_tuple_element;\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT tupleElement(t2, 1) FROM t_tuple_element;\n \n SELECT tupleElement(t2) FROM t_tuple_element; -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n SELECT tupleElement(t2, 'a') FROM t_tuple_element; -- { serverError NOT_FOUND_COLUMN_IN_BLOCK, UNKNOWN_IDENTIFIER }\n-SELECT tupleElement(t2, 0) FROM t_tuple_element; -- { serverError ILLEGAL_INDEX, NOT_FOUND_COLUMN_IN_BLOCK }\n-SELECT tupleElement(t2, 3) FROM t_tuple_element; -- { serverError ILLEGAL_INDEX, NOT_FOUND_COLUMN_IN_BLOCK }\n-SELECT tupleElement(t2, materialize(1)) FROM t_tuple_element; -- { serverError ILLEGAL_TYPE_OF_ARGUMENT, NOT_FOUND_COLUMN_IN_BLOCK }\n+SELECT tupleElement(t2, 0) FROM t_tuple_element; -- { serverError ARGUMENT_OUT_OF_BOUND, NOT_FOUND_COLUMN_IN_BLOCK }\n+SELECT tupleElement(t2, 3) FROM t_tuple_element; -- { serverError ARGUMENT_OUT_OF_BOUND, NOT_FOUND_COLUMN_IN_BLOCK }\n+SELECT tupleElement(t2, materialize(1)) FROM t_tuple_element; -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n \n DROP TABLE t_tuple_element;\n \n WITH (1, 2) AS t SELECT t.1, t.2;\n-EXPLAIN SYNTAX WITH (1, 2) AS t SELECT t.1, t.2;\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 WITH (1, 2) AS t SELECT t.1, t.2;\n \n WITH (1, 2)::Tuple(a UInt32, b UInt32) AS t SELECT t.1, tupleElement(t, 'b');\n-EXPLAIN SYNTAX WITH (1, 2)::Tuple(a UInt32, b UInt32) AS t SELECT t.1, tupleElement(t, 'b');\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 WITH (1, 2)::Tuple(a UInt32, b UInt32) AS t SELECT t.1, tupleElement(t, 'b');\ndiff --git a/tests/queries/0_stateless/02286_tuple_numeric_identifier.sql b/tests/queries/0_stateless/02286_tuple_numeric_identifier.sql\nindex f723284ad619..151ff275f7b5 100644\n--- a/tests/queries/0_stateless/02286_tuple_numeric_identifier.sql\n+++ b/tests/queries/0_stateless/02286_tuple_numeric_identifier.sql\n@@ -12,9 +12,9 @@ SELECT * FROM t_tuple_numeric FORMAT JSONEachRow;\n SELECT `t`.`1`.`2`, `t`.`1`.`3`, `t`.`4` FROM t_tuple_numeric;\n SELECT t.1.1, t.1.2, t.2 FROM t_tuple_numeric;\n \n-SELECT t.1.3 FROM t_tuple_numeric; -- {serverError NOT_FOUND_COLUMN_IN_BLOCK}\n-SELECT t.4 FROM t_tuple_numeric; -- {serverError NOT_FOUND_COLUMN_IN_BLOCK}\n-SELECT `t`.`1`.`1`, `t`.`1`.`2`, `t`.`2` FROM t_tuple_numeric; -- {serverError UNKNOWN_IDENTIFIER}\n+SELECT t.1.3 FROM t_tuple_numeric; -- {serverError NOT_FOUND_COLUMN_IN_BLOCK, ARGUMENT_OUT_OF_BOUND}\n+SELECT t.4 FROM t_tuple_numeric; -- {serverError NOT_FOUND_COLUMN_IN_BLOCK, ARGUMENT_OUT_OF_BOUND}\n+SELECT `t`.`1`.`1`, `t`.`1`.`2`, `t`.`2` FROM t_tuple_numeric; -- {serverError UNKNOWN_IDENTIFIER, ARGUMENT_OUT_OF_BOUND}\n \n DROP TABLE t_tuple_numeric;\n \ndiff --git a/tests/queries/0_stateless/02971_functions_to_subcolumns_column_names.reference b/tests/queries/0_stateless/02971_functions_to_subcolumns_column_names.reference\nnew file mode 100644\nindex 000000000000..3389ea44074b\n--- /dev/null\n+++ b/tests/queries/0_stateless/02971_functions_to_subcolumns_column_names.reference\n@@ -0,0 +1,5 @@\n+SELECT\n+    __table1.`arr.size0` AS `length(arr)`,\n+    __table1.`n.null` AS `isNull(n)`\n+FROM default.t_column_names AS __table1\n+{\"length(arr)\":\"3\",\"isNull(n)\":0}\ndiff --git a/tests/queries/0_stateless/02971_functions_to_subcolumns_column_names.sql b/tests/queries/0_stateless/02971_functions_to_subcolumns_column_names.sql\nnew file mode 100644\nindex 000000000000..48e5232d18b3\n--- /dev/null\n+++ b/tests/queries/0_stateless/02971_functions_to_subcolumns_column_names.sql\n@@ -0,0 +1,13 @@\n+DROP TABLE IF EXISTS t_column_names;\n+\n+CREATE TABLE t_column_names (arr Array(UInt64), n Nullable(String)) ENGINE = Memory;\n+\n+INSERT INTO t_column_names VALUES ([1, 2, 3], 'foo');\n+\n+SET optimize_functions_to_subcolumns = 1;\n+SET allow_experimental_analyzer = 1;\n+\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT length(arr), isNull(n) FROM t_column_names;\n+SELECT length(arr), isNull(n) FROM t_column_names FORMAT JSONEachRow;\n+\n+DROP TABLE t_column_names;\ndiff --git a/tests/queries/0_stateless/02971_functions_to_subcolumns_map.reference b/tests/queries/0_stateless/02971_functions_to_subcolumns_map.reference\nnew file mode 100644\nindex 000000000000..9488291c8ffa\n--- /dev/null\n+++ b/tests/queries/0_stateless/02971_functions_to_subcolumns_map.reference\n@@ -0,0 +1,12 @@\n+SELECT __table1.`m.size0` AS `length(m)`\n+FROM default.t_func_to_subcolumns_map AS __table1\n+2\n+1\n+SELECT __table1.`m.size0` = 0 AS `empty(m)`\n+FROM default.t_func_to_subcolumns_map AS __table1\n+0\n+0\n+SELECT __table1.`m.size0` != 0 AS `notEmpty(m)`\n+FROM default.t_func_to_subcolumns_map AS __table1\n+1\n+1\ndiff --git a/tests/queries/0_stateless/02971_functions_to_subcolumns_map.sql b/tests/queries/0_stateless/02971_functions_to_subcolumns_map.sql\nnew file mode 100644\nindex 000000000000..e8a752a82d52\n--- /dev/null\n+++ b/tests/queries/0_stateless/02971_functions_to_subcolumns_map.sql\n@@ -0,0 +1,19 @@\n+DROP TABLE IF EXISTS t_func_to_subcolumns_map;\n+\n+CREATE TABLE t_func_to_subcolumns_map (id UInt64, m Map(String, UInt64)) ENGINE = MergeTree ORDER BY id;\n+\n+INSERT INTO t_func_to_subcolumns_map VALUES (1, map('aaa', 1, 'bbb', 2)) (2, map('ccc', 3));\n+\n+SET optimize_functions_to_subcolumns = 1;\n+SET allow_experimental_analyzer = 1;\n+\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT length(m) FROM t_func_to_subcolumns_map;\n+SELECT length(m) FROM t_func_to_subcolumns_map;\n+\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT empty(m) FROM t_func_to_subcolumns_map;\n+SELECT empty(m) FROM t_func_to_subcolumns_map;\n+\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT notEmpty(m) FROM t_func_to_subcolumns_map;\n+SELECT notEmpty(m) FROM t_func_to_subcolumns_map;\n+\n+DROP TABLE t_func_to_subcolumns_map;\ndiff --git a/tests/queries/0_stateless/02971_functions_to_subcolumns_variant.reference b/tests/queries/0_stateless/02971_functions_to_subcolumns_variant.reference\nnew file mode 100644\nindex 000000000000..04616738a159\n--- /dev/null\n+++ b/tests/queries/0_stateless/02971_functions_to_subcolumns_variant.reference\n@@ -0,0 +1,4 @@\n+SELECT __table1.`v.String` AS `variantElement(v, \\'String\\')`\n+FROM default.t_func_to_subcolumns_variant AS __table1\n+foo\n+\\N\ndiff --git a/tests/queries/0_stateless/02971_functions_to_subcolumns_variant.sql b/tests/queries/0_stateless/02971_functions_to_subcolumns_variant.sql\nnew file mode 100644\nindex 000000000000..511bcc445145\n--- /dev/null\n+++ b/tests/queries/0_stateless/02971_functions_to_subcolumns_variant.sql\n@@ -0,0 +1,15 @@\n+DROP TABLE IF EXISTS t_func_to_subcolumns_variant;\n+\n+SET allow_experimental_variant_type = 1;\n+\n+CREATE TABLE t_func_to_subcolumns_variant (id UInt64, v Variant(String, UInt64)) ENGINE = MergeTree ORDER BY id;\n+\n+INSERT INTO t_func_to_subcolumns_variant VALUES (1, 'foo') (2, 111);\n+\n+SET optimize_functions_to_subcolumns = 1;\n+SET allow_experimental_analyzer = 1;\n+\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT variantElement(v, 'String') FROM t_func_to_subcolumns_variant;\n+SELECT variantElement(v, 'String') FROM t_func_to_subcolumns_variant;\n+\n+DROP TABLE t_func_to_subcolumns_variant;\ndiff --git a/tests/queries/0_stateless/03003_functions_to_subcolumns_final.reference b/tests/queries/0_stateless/03003_functions_to_subcolumns_final.reference\nnew file mode 100644\nindex 000000000000..3051c1993631\n--- /dev/null\n+++ b/tests/queries/0_stateless/03003_functions_to_subcolumns_final.reference\n@@ -0,0 +1,25 @@\n+3\n+2\n+SELECT __table1.`arr.size0` AS `length(arr)`\n+FROM default.t_length_1 AS __table1\n+WHERE __table1.`arr.size0` IN (\n+    SELECT __table1.arr_length AS arr_length\n+    FROM default.t_length_2 AS __table1\n+)\n+2\n+SELECT __table1.`arr.size0` AS `length(arr)`\n+FROM default.t_length_1 AS __table1\n+WHERE __table1.`arr.size0` IN (\n+    SELECT __table1.arr_length AS arr_length\n+    FROM default.t_length_2 AS __table1\n+    FINAL\n+)\n+2\n+SELECT length(__table1.arr) AS `length(arr)`\n+FROM default.t_length_1 AS __table1\n+FINAL\n+WHERE length(__table1.arr) IN (\n+    SELECT __table1.arr_length AS arr_length\n+    FROM default.t_length_2 AS __table1\n+    FINAL\n+)\ndiff --git a/tests/queries/0_stateless/03003_functions_to_subcolumns_final.sql b/tests/queries/0_stateless/03003_functions_to_subcolumns_final.sql\nnew file mode 100644\nindex 000000000000..3fe29139c5fa\n--- /dev/null\n+++ b/tests/queries/0_stateless/03003_functions_to_subcolumns_final.sql\n@@ -0,0 +1,24 @@\n+DROP TABLE IF EXISTS t_length_1;\n+DROP TABLE IF EXISTS t_length_2;\n+\n+SET optimize_functions_to_subcolumns = 1;\n+SET allow_experimental_analyzer = 1;\n+SET optimize_on_insert = 0;\n+\n+CREATE TABLE t_length_1 (id UInt64, arr Array(UInt64)) ENGINE = ReplacingMergeTree ORDER BY id;\n+CREATE TABLE t_length_2 (id UInt64, arr_length UInt64) ENGINE = ReplacingMergeTree ORDER BY id;\n+\n+INSERT INTO t_length_1 VALUES (1, [1, 2, 3]), (2, [4, 5]);\n+INSERT INTO t_length_2 VALUES (1, 3), (1, 2), (2, 2);\n+\n+SELECT length(arr) FROM t_length_1 WHERE length(arr) in (SELECT arr_length FROM t_length_2);\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT length(arr) FROM t_length_1 WHERE length(arr) in (SELECT arr_length FROM t_length_2);\n+\n+SELECT length(arr) FROM t_length_1 WHERE length(arr) in (SELECT arr_length FROM t_length_2 FINAL);\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT length(arr) FROM t_length_1 WHERE length(arr) in (SELECT arr_length FROM t_length_2 FINAL);\n+\n+SELECT length(arr) FROM t_length_1 FINAL WHERE length(arr) in (SELECT arr_length FROM t_length_2 FINAL);\n+EXPLAIN QUERY TREE dump_tree = 0, dump_ast = 1 SELECT length(arr) FROM t_length_1 FINAL WHERE length(arr) in (SELECT arr_length FROM t_length_2 FINAL);\n+\n+DROP TABLE t_length_1;\n+DROP TABLE t_length_2;\ndiff --git a/tests/queries/0_stateless/03171_function_to_subcolumns_fuzzer.reference b/tests/queries/0_stateless/03171_function_to_subcolumns_fuzzer.reference\nnew file mode 100644\nindex 000000000000..1fc6683620c9\n--- /dev/null\n+++ b/tests/queries/0_stateless/03171_function_to_subcolumns_fuzzer.reference\n@@ -0,0 +1,9 @@\n+1\n+2\t1\n+3\t0\n+0\t450\n+1\t460\n+2\t470\n+3\t480\n+4\t490\n+\\N\t4950\ndiff --git a/tests/queries/0_stateless/03171_function_to_subcolumns_fuzzer.sql b/tests/queries/0_stateless/03171_function_to_subcolumns_fuzzer.sql\nnew file mode 100644\nindex 000000000000..f10019a78dda\n--- /dev/null\n+++ b/tests/queries/0_stateless/03171_function_to_subcolumns_fuzzer.sql\n@@ -0,0 +1,49 @@\n+SET optimize_functions_to_subcolumns = 1;\n+SET allow_experimental_analyzer = 1;\n+\n+DROP TABLE IF EXISTS t_func_to_subcolumns_map_2;\n+\n+CREATE TABLE t_func_to_subcolumns_map_2 (id UInt64, m Map(String, UInt64)) ENGINE = MergeTree ORDER BY id;\n+\n+INSERT INTO t_func_to_subcolumns_map_2 VALUES (1, map('aaa', 1, 'bbb', 2)) (2, map('ccc', 3));\n+\n+SELECT sum(mapContains(m, toNullable('aaa'))) FROM t_func_to_subcolumns_map_2;\n+\n+DROP TABLE t_func_to_subcolumns_map_2;\n+\n+DROP TABLE IF EXISTS t_func_to_subcolumns_join;\n+\n+CREATE TABLE t_func_to_subcolumns_join (id UInt64, arr Array(UInt64), n Nullable(String), m Map(String, UInt64))\n+ENGINE = MergeTree ORDER BY tuple();\n+\n+INSERT INTO t_func_to_subcolumns_join VALUES (1, [1, 2, 3], 'abc', map('foo', 1, 'bar', 2)) (2, [], NULL, map());\n+\n+SET join_use_nulls = 1;\n+\n+SELECT\n+    id,\n+    right.n IS NULL\n+FROM t_func_to_subcolumns_join AS left\n+FULL OUTER JOIN\n+(\n+    SELECT\n+        1 AS id,\n+        'qqq' AS n\n+    UNION ALL\n+    SELECT\n+        3 AS id,\n+        'www'\n+) AS right USING (id)\n+WHERE empty(arr);\n+\n+DROP TABLE t_func_to_subcolumns_join;\n+\n+DROP TABLE IF EXISTS t_func_to_subcolumns_use_nulls;\n+\n+CREATE TABLE t_func_to_subcolumns_use_nulls (arr Array(UInt64), v UInt64) ENGINE = MergeTree ORDER BY tuple();\n+\n+INSERT INTO t_func_to_subcolumns_use_nulls SELECT range(number % 10), number FROM numbers(100);\n+\n+SELECT length(arr) AS n, sum(v) FROM t_func_to_subcolumns_use_nulls GROUP BY n WITH ROLLUP HAVING n <= 4 OR isNull(n) ORDER BY n SETTINGS group_by_use_nulls = 1;\n+\n+DROP TABLE t_func_to_subcolumns_use_nulls;\n",
  "problem_statement": "optimize_functions_to_subcolumns: Can't adjust last granule because it has 113 rows, but try to subtract 41073 rows\nComes from https://github.com/ClickHouse/ClickHouse/pull/57315:\r\n\r\nReport: https://s3.amazonaws.com/clickhouse-test-reports/57315/ade60b5b45283adddfcf166d5a5c865c7a4da16f/stateful_tests__aarch64_.html\r\n\r\n```\r\n2023-11-28 06:16:57 [f792f6c66554] 2023.11.28 07:16:56.966026 [ 2828 ] {6b1377df-bd21-4ff5-a92a-4ed2100789fd} <Error> executeQuery: Code: 49. DB::Exception: Can't adjust last granule because it has 113 rows, but try to subtract 41073 rows.: While executing MergeTreeSelect(pool: ReadPool, algorithm: Thread). (LOGICAL_ERROR) (version 23.11.1.2032) (from [::1]:41868) (comment: 00083_array_filter.sql) (in query: SELECT sum(length(ParsedParams.Key1)) FROM test.hits WHERE notEmpty(ParsedParams.Key1);), Stack trace (when copying this message, always include the lines below):\r\n2023-11-28 06:16:57 \r\n2023-11-28 06:16:57 0. ./build_docker/./src/Common/Exception.cpp:97: DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0x000000000bad1a48 in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2023-11-28 06:16:57 1. DB::Exception::Exception<unsigned long&, unsigned long&>(int, FormatStringHelperImpl<std::type_identity<unsigned long&>::type, std::type_identity<unsigned long&>::type>, unsigned long&, unsigned long&) @ 0x0000000007dae080 in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2023-11-28 06:16:57 2. ./build_docker/./src/Storages/MergeTree/MergeTreeRangeReader.cpp:318: DB::MergeTreeRangeReader::read(unsigned long, DB::MarkRanges&) @ 0x0000000010a36c58 in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2023-11-28 06:16:57 3. ./build_docker/./src/Storages/MergeTree/MergeTreeReadTask.cpp:163: DB::MergeTreeReadTask::read(DB::MergeTreeReadTask::BlockSizeParams const&) @ 0x0000000010a39f54 in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2023-11-28 06:16:57 4. ./build_docker/./src/Storages/MergeTree/MergeTreeSelectProcessor.cpp:162: DB::MergeTreeSelectProcessor::read() @ 0x0000000010a28f14 in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2023-11-28 06:16:57 5. ./build_docker/./src/Storages/MergeTree/MergeTreeSource.cpp:181: DB::MergeTreeSource::tryGenerate() @ 0x000000001115a76c in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2023-11-28 06:16:57 6. ./contrib/llvm-project/libcxx/include/optional:344: DB::ISource::work() @ 0x0000000010d73e74 in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2023-11-28 06:16:57 7. ./build_docker/./src/Processors/Executors/ExecutionThreadContext.cpp:52: DB::ExecutionThreadContext::executeTask() @ 0x0000000010d87bec in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2023-11-28 06:16:57 8. ./build_docker/./src/Processors/Executors/PipelineExecutor.cpp:273: DB::PipelineExecutor::executeStepImpl(unsigned long, std::atomic<bool>*) @ 0x0000000010d80054 in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2023-11-28 06:16:57 9. ./build_docker/./src/Processors/Executors/PipelineExecutor.cpp:381: void std::__function::__policy_invoker<void ()>::__call_impl<std::__function::__default_alloc_func<DB::PipelineExecutor::spawnThreads()::$_0, void ()>>(std::__function::__policy_storage const*) @ 0x0000000010d8117c in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2023-11-28 06:16:57 10. ./base/base/../base/wide_integer_impl.h:809: ThreadPoolImpl<ThreadFromGlobalPoolImpl<false>>::worker(std::__list_iterator<ThreadFromGlobalPoolImpl<false>, void*>) @ 0x000000000bb99e2c in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2023-11-28 06:16:57 11. ./src/Common/ThreadPool.h:251: void std::__function::__policy_invoker<void ()>::__call_impl<std::__function::__default_alloc_func<ThreadFromGlobalPoolImpl<false>::ThreadFromGlobalPoolImpl<void ThreadPoolImpl<ThreadFromGlobalPoolImpl<false>>::scheduleImpl<void>(std::function<void ()>, Priority, std::optional<unsigned long>, bool)::'lambda0'()>(void&&)::'lambda'(), void ()>>(std::__function::__policy_storage const*) @ 0x000000000bb9d360 in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2023-11-28 06:16:57 12. ./base/base/../base/wide_integer_impl.h:809: void* std::__thread_proxy[abi:v15000]<std::tuple<std::unique_ptr<std::__thread_struct, std::default_delete<std::__thread_struct>>, void ThreadPoolImpl<std::thread>::scheduleImpl<void>(std::function<void ()>, Priority, std::optional<unsigned long>, bool)::'lambda0'()>>(void*) @ 0x000000000bb9bfb4 in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2023-11-28 06:16:57 13. ? @ 0x000000000007d5c8 in /usr/lib/aarch64-linux\r\n```\r\n\r\nReproducer:\r\n```\r\nclickhouse client --queries-file 00083_array_filter.sql --optimize_functions_to_subcolumns 1\r\n```\r\n\r\n\r\ncc @CurtizJ Do you think it's worth fixing it or should we drop the feature (before thinking on adding it to the analyzer)? It's never been enabled by default\n",
  "hints_text": "`00013_sorting_of_nested.sql` is also broken by `optimize_functions_to_subcolumns`:\r\n\r\n```\r\n/mnt/ch/ClickHouse/tests/queries/1_stateful $ ch_client_prod-01 --queries-file 00013_sorting_of_nested.sql --optimize_functions_to_subcolumns 0\r\n['\u041a\u043d\u043e\u043f\u043a\u0430']\r\n['pageParams','pageParams']\r\n['pageParams']\r\n['gen_time']\r\n['pageParams']\r\n['pageParams']\r\n['pageParams']\r\n['pageParams']\r\n['\u041f\u0440\u0430\u0432','gen_timestamp','\u041f\u0440\u0430\u0432','\u0414\u0435\u0439\u0441\u0442\u0432\u0438','affili','gen_timestamp','\u042d\u043a\u0441\u043f\u0435\u0440\u0438\u043c\u0435\u043d\u0442 \u043f\u0440\u043e \u043e\u0442\u0440\u044b\u0432 \u0441\u0447\u0435\u0442\u0447\u0438\u043a\u0430 \u0443 \u043f\u0430\u043f\u043e\u043a','\u041f\u0440\u043e\u0441\u043c\u043e\u0442\u0440 \u043f\u0438\u0441\u0435\u043c']\r\n['\u041c\u0430\u0440\u043a\u0430','gen_time','\u041c\u0430\u0440\u043a\u0430']\r\n/mnt/ch/ClickHouse/tests/queries/1_stateful $ ch_client_prod-01 --queries-file 00013_sorting_of_nested.sql --optimize_functions_to_subcolumns 1\r\n/mnt/ch/ClickHouse/tests/queries/1_stateful $\r\n```\nAnd `00078_group_by_arrays.sql` too:\r\n\r\n```\r\n/mnt/ch/ClickHouse/tests/queries/1_stateful $ ch_client_prod-01 --queries-file 00078_group_by_arrays.sql --optimize_functions_to_subcolumns 0\r\n[]      8001320\r\n[2028343]       218383\r\n[3337849]       26325\r\n[3278201]       26259\r\n[3122469,2402651,3172687,2165967,3580344,3385706,3892934,3011216,3849284,2233086,3815288,3559435,2729510,3705435,2354960,3002888,2895835,3062712,2921977,3334920,3047153,3587682,4170284,2433778,2874188,2934295,3605952,2442464,3942660,2342155,2634729,3315647,2721173,2510647,2115204,3549218,3898387,2671488,3704331,3091775,3374519]    24078\r\n[3916793]       15706\r\n[4028285]       14326\r\n[2287648]       11558\r\n[3482255]       9599\r\n[7415385]       8938\r\n[]      []      3929946\r\n[]      [2028343]       88062\r\n[14]    []      21709\r\n[6]     []      18019\r\n[76]    []      13936\r\n[1]     []      12855\r\n[119]   []      12368\r\n[22,1]  []      11949\r\n[5,4]   []      11550\r\n[5]     []      11530\r\n[]      []      3970023\r\n['css_link_href']       []      74739\r\n['gen_timestamp']       []      32442\r\n[]      [14]    22059\r\n['\u042d\u043a\u0441\u043f\u0435\u0440\u0438\u043c\u0435\u043d\u0442'] []      19158\r\n['\u041f\u043e\u0438\u0441\u043a']       []      18966\r\n['hasTemplates']        []      18378\r\n['errors']      []      18168\r\n['page(by type of visitors)']   []      14653\r\n[]      [6]     14350\r\n['index']       [4,5,3,103,10,1,42,51,3993,2817,2193,15,2]      1472\r\n['hasTemplates']        [7,6,101,14,3003,1,70,72,501,285,80,25,74]      1226\r\n['hasTemplates']        [3528,3274,14,72,925,3,47,19,11,2,9,10,42]      1187\r\n['Sex','\u041f\u0440\u043e\u0441\u043c\u043e\u0442\u0440\u0449\u0438\u043a','\u041d\u0435\u0440\u0430\u0431\u043e\u0442\u0430\u044e\u0449\u0438\u0439']    [5,76,4,753,2733,3674,6,84,265,10,82,112]       937\r\n['css_link_href']       [14]    881\r\n['hasTemplates']        [7,6,101,14,3003,1,70,501,72,285,80,25,74]      859\r\n['hasTemplates']        [3528,3274,14,72,925,47,3,19,11,9,2,10,103]     843\r\n['\u041f\u043e\u0438\u0441\u043a']       [3528,3274,14,72,925,47,3,19,11,9,2,10,103]     817\r\n['index']       [925,1,14,76,72,25,2,3993,3275,9,4,2193]        777\r\n['index']       [76,1,925,25,14,72,2,2193,9]    766\r\n/mnt/ch/ClickHouse/tests/queries/1_stateful $ ch_client_prod-01 --queries-file 00078_group_by_arrays.sql --optimize_functions_to_subcolumns 1\r\n[]      8001320\r\n[2028343]       218383\r\n[3337849]       26325\r\n[3278201]       26259\r\n[3122469,2402651,3172687,2165967,3580344,3385706,3892934,3011216,3849284,2233086,3815288,3559435,2729510,3705435,2354960,3002888,2895835,3062712,2921977,3334920,3047153,3587682,4170284,2433778,2874188,2934295,3605952,2442464,3942660,2342155,2634729,3315647,2721173,2510647,2115204,3549218,3898387,2671488,3704331,3091775,3374519]    24078\r\n[3916793]       15706\r\n[4028285]       14326\r\n[2287648]       11558\r\n[3482255]       9599\r\n[7415385]       8938\r\n[]      []      3929946\r\n[]      [2028343]       88062\r\n[14]    []      21709\r\n[6]     []      18019\r\n[76]    []      13936\r\n[1]     []      12855\r\n[119]   []      12368\r\n[22,1]  []      11949\r\n[5,4]   []      11550\r\n[5]     []      11530\r\n[]      []      3970023\r\n['css_link_href']       []      74739\r\n['gen_timestamp']       []      32442\r\n[]      [14]    22059\r\n['\u042d\u043a\u0441\u043f\u0435\u0440\u0438\u043c\u0435\u043d\u0442'] []      19158\r\n['\u041f\u043e\u0438\u0441\u043a']       []      18966\r\n['hasTemplates']        []      18378\r\n['errors']      []      18168\r\n['page(by type of visitors)']   []      14653\r\n[]      [6]     14350\r\n/mnt/ch/ClickHouse/tests/queries/1_stateful $ \r\n```\r\n\n> Do you think it's worth fixing it or should we drop the feature\r\n\r\nI think it's worth to fix it because it's a quite good optimization. There is a known bug with optimizing `length(nested.arr)` with `Nested` columns and that is why it's disabled by default. \r\n\r\n> before thinking on adding it to the analyzer\r\n\r\nI think it should be easier to fix this optimization in analyzer than in ast optimizer and as I know it's already added to analyzer.\nThank you, I didn't realize it was already ported to the analyzer. All 3 tests failed with the analyzer too, so it seems we've just ported the bad behaviour over.\r\n\r\nAt least the error thrown by the analyzer for `00083_array_filter.sql` is less scary:\r\n\r\n```\r\n/mnt/ch/ClickHouse/tests/queries/1_stateful $ ch_client_prod-01 --queries-file 00083_array_filter.sql --optimize_functions_to_subcolumns 1 --allow_experimental_analyzer 0\r\nReceived exception from server (version 23.11.1):\r\nCode: 49. DB::Exception: Received from clickhouse-01:49000. DB::Exception: Can't adjust last granule because it has 8065 rows, but try to subtract 65409 rows.: While executing MergeTreeSelect(pool: ReadPool, algorithm: Thread). (LOGICAL_ERROR)\r\n(query: SELECT sum(length(ParsedParams.Key1)) FROM test.hits WHERE notEmpty(ParsedParams.Key1);)\r\n\r\n\r\n/mnt/ch/ClickHouse/tests/queries/1_stateful $ ch_client_prod-01 --queries-file 00083_array_filter.sql --optimize_functions_to_subcolumns 1 --allow_experimental_analyzer 1\r\nReceived exception from server (version 23.11.1):\r\nCode: 43. DB::Exception: Received from clickhouse-01:49000. DB::Exception: Illegal types of arguments (Array(String), UInt8) of function notEquals. (ILLEGAL_TYPE_OF_ARGUMENT)\r\n(query: SELECT sum(length(ParsedParams.Key1)) FROM test.hits WHERE notEmpty(ParsedParams.Key1);)\r\n```\n`02911_join_on_nullsafe_optimization.sql`, `01030_incorrect_count_summing_merge_tree` and `02892_orc_filter_pushdown` are also failing with `optimize_functions_to_subcolumns`too.",
  "created_at": "2024-01-10T15:11:29Z"
}