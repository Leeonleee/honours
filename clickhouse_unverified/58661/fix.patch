diff --git a/docs/en/operations/settings/settings.md b/docs/en/operations/settings/settings.md
index 3d6d776f4da6..1d74a63b972a 100644
--- a/docs/en/operations/settings/settings.md
+++ b/docs/en/operations/settings/settings.md
@@ -2536,7 +2536,7 @@ Possible values:
 - 0 — Optimization disabled.
 - 1 — Optimization enabled.
 
-Default value: `0`.
+Default value: `1`.
 
 ## optimize_trivial_count_query {#optimize-trivial-count-query}
 
diff --git a/docs/ru/operations/settings/settings.md b/docs/ru/operations/settings/settings.md
index 3a70a0bac128..84bbf6c83d31 100644
--- a/docs/ru/operations/settings/settings.md
+++ b/docs/ru/operations/settings/settings.md
@@ -2077,7 +2077,7 @@ SELECT * FROM test_table
 -   0 — оптимизация отключена.
 -   1 — оптимизация включена.
 
-Значение по умолчанию: `0`.
+Значение по умолчанию: `1`.
 
 ## optimize_trivial_count_query {#optimize-trivial-count-query}
 
diff --git a/src/Analyzer/Passes/AggregateFunctionsArithmericOperationsPass.cpp b/src/Analyzer/Passes/AggregateFunctionsArithmericOperationsPass.cpp
index e6798a792ddc..098e2858abce 100644
--- a/src/Analyzer/Passes/AggregateFunctionsArithmericOperationsPass.cpp
+++ b/src/Analyzer/Passes/AggregateFunctionsArithmericOperationsPass.cpp
@@ -9,6 +9,7 @@
 #include <Analyzer/InDepthQueryTreeVisitor.h>
 #include <Analyzer/ConstantNode.h>
 #include <Analyzer/FunctionNode.h>
+#include <Analyzer/Utils.h>
 
 namespace DB
 {
@@ -164,32 +165,15 @@ class AggregateFunctionsArithmericOperationsVisitor : public InDepthQueryTreeVis
 
         auto aggregate_function_clone = aggregate_function->clone();
         auto & aggregate_function_clone_typed = aggregate_function_clone->as<FunctionNode &>();
+
         aggregate_function_clone_typed.getArguments().getNodes() = { arithmetic_function_clone_argument };
-        resolveAggregateFunctionNode(aggregate_function_clone_typed, arithmetic_function_clone_argument, result_aggregate_function_name);
+        resolveAggregateFunctionNodeByName(aggregate_function_clone_typed, result_aggregate_function_name);
 
         arithmetic_function_clone_arguments_nodes[arithmetic_function_argument_index] = std::move(aggregate_function_clone);
-        resolveOrdinaryFunctionNode(arithmetic_function_clone_typed, arithmetic_function_clone_typed.getFunctionName());
+        resolveOrdinaryFunctionNodeByName(arithmetic_function_clone_typed, arithmetic_function_clone_typed.getFunctionName(), getContext());
 
         return arithmetic_function_clone;
     }
-
-    void resolveOrdinaryFunctionNode(FunctionNode & function_node, const String & function_name) const
-    {
-        auto function = FunctionFactory::instance().get(function_name, getContext());
-        function_node.resolveAsFunction(function->build(function_node.getArgumentColumns()));
-    }
-
-    static void resolveAggregateFunctionNode(FunctionNode & function_node, const QueryTreeNodePtr & argument, const String & aggregate_function_name)
-    {
-        auto function_aggregate_function = function_node.getAggregateFunction();
-
-        AggregateFunctionProperties properties;
-        auto action = NullsAction::EMPTY;
-        auto aggregate_function = AggregateFunctionFactory::instance().get(
-            aggregate_function_name, action, {argument->getResultType()}, function_aggregate_function->getParameters(), properties);
-
-        function_node.resolveAsAggregateFunction(std::move(aggregate_function));
-    }
 };
 
 }
diff --git a/src/Analyzer/Passes/ComparisonTupleEliminationPass.cpp b/src/Analyzer/Passes/ComparisonTupleEliminationPass.cpp
index ebefc12ae536..180470952cd3 100644
--- a/src/Analyzer/Passes/ComparisonTupleEliminationPass.cpp
+++ b/src/Analyzer/Passes/ComparisonTupleEliminationPass.cpp
@@ -11,6 +11,7 @@
 #include <Analyzer/InDepthQueryTreeVisitor.h>
 #include <Analyzer/ConstantNode.h>
 #include <Analyzer/FunctionNode.h>
+#include <Analyzer/Utils.h>
 
 namespace DB
 {
@@ -18,19 +19,18 @@ namespace DB
 namespace
 {
 
-class ComparisonTupleEliminationPassVisitor : public InDepthQueryTreeVisitor<ComparisonTupleEliminationPassVisitor>
+class ComparisonTupleEliminationPassVisitor : public InDepthQueryTreeVisitorWithContext<ComparisonTupleEliminationPassVisitor>
 {
 public:
-    explicit ComparisonTupleEliminationPassVisitor(ContextPtr context_)
-        : context(std::move(context_))
-    {}
+    using Base = InDepthQueryTreeVisitorWithContext<ComparisonTupleEliminationPassVisitor>;
+    using Base::Base;
 
     static bool needChildVisit(QueryTreeNodePtr &, QueryTreeNodePtr & child)
     {
         return child->getNodeType() != QueryTreeNodeType::TABLE_FUNCTION;
     }
 
-    void visitImpl(QueryTreeNodePtr & node) const
+    void enterImpl(QueryTreeNodePtr & node) const
     {
         auto * function_node = node->as<FunctionNode>();
         if (!function_node)
@@ -171,13 +171,13 @@ class ComparisonTupleEliminationPassVisitor : public InDepthQueryTreeVisitor<Com
     {
         auto result_function = std::make_shared<FunctionNode>("and");
         result_function->getArguments().getNodes() = std::move(tuple_arguments_equals_functions);
-        resolveOrdinaryFunctionNode(*result_function, result_function->getFunctionName());
+        resolveOrdinaryFunctionNodeByName(*result_function, result_function->getFunctionName(), getContext());
 
         if (comparison_function_name == "notEquals")
         {
             auto not_function = std::make_shared<FunctionNode>("not");
             not_function->getArguments().getNodes().push_back(std::move(result_function));
-            resolveOrdinaryFunctionNode(*not_function, not_function->getFunctionName());
+            resolveOrdinaryFunctionNodeByName(*not_function, not_function->getFunctionName(), getContext());
             result_function = std::move(not_function);
         }
 
@@ -197,18 +197,10 @@ class ComparisonTupleEliminationPassVisitor : public InDepthQueryTreeVisitor<Com
         comparison_function->getArguments().getNodes().push_back(std::move(lhs_argument));
         comparison_function->getArguments().getNodes().push_back(std::move(rhs_argument));
 
-        resolveOrdinaryFunctionNode(*comparison_function, comparison_function->getFunctionName());
+        resolveOrdinaryFunctionNodeByName(*comparison_function, comparison_function->getFunctionName(), getContext());
 
         return comparison_function;
     }
-
-    void resolveOrdinaryFunctionNode(FunctionNode & function_node, const String & function_name) const
-    {
-        auto function = FunctionFactory::instance().get(function_name, context);
-        function_node.resolveAsFunction(function->build(function_node.getArgumentColumns()));
-    }
-
-    ContextPtr context;
 };
 
 }
diff --git a/src/Analyzer/Passes/CountDistinctPass.cpp b/src/Analyzer/Passes/CountDistinctPass.cpp
index 3307c440f425..23fde89a3480 100644
--- a/src/Analyzer/Passes/CountDistinctPass.cpp
+++ b/src/Analyzer/Passes/CountDistinctPass.cpp
@@ -9,6 +9,7 @@
 #include <Analyzer/ColumnNode.h>
 #include <Analyzer/FunctionNode.h>
 #include <Analyzer/QueryNode.h>
+#include <Analyzer/Utils.h>
 
 namespace DB
 {
@@ -77,11 +78,9 @@ class CountDistinctVisitor : public InDepthQueryTreeVisitorWithContext<CountDist
 
         /// Replace `countDistinct` of initial query into `count`
         auto result_type = function_node->getResultType();
-        AggregateFunctionProperties properties;
-        auto action = NullsAction::EMPTY;
-        auto aggregate_function = AggregateFunctionFactory::instance().get("count", action, {}, {}, properties);
-        function_node->resolveAsAggregateFunction(std::move(aggregate_function));
+
         function_node->getArguments().getNodes().clear();
+        resolveAggregateFunctionNodeByName(*function_node, "count");
     }
 };
 
diff --git a/src/Analyzer/Passes/FunctionToSubcolumnsPass.cpp b/src/Analyzer/Passes/FunctionToSubcolumnsPass.cpp
index 15ac8d642a4a..90051779a264 100644
--- a/src/Analyzer/Passes/FunctionToSubcolumnsPass.cpp
+++ b/src/Analyzer/Passes/FunctionToSubcolumnsPass.cpp
@@ -4,6 +4,7 @@
 #include <DataTypes/DataTypeTuple.h>
 #include <DataTypes/DataTypeArray.h>
 #include <DataTypes/DataTypeMap.h>
+#include <DataTypes/DataTypeVariant.h>
 
 #include <Storages/IStorage.h>
 
@@ -16,6 +17,9 @@
 #include <Analyzer/ColumnNode.h>
 #include <Analyzer/FunctionNode.h>
 #include <Analyzer/TableNode.h>
+#include <Analyzer/TableFunctionNode.h>
+#include <Analyzer/Utils.h>
+#include <Analyzer/JoinNode.h>
 
 namespace DB
 {
@@ -23,202 +27,410 @@ namespace DB
 namespace
 {
 
-class FunctionToSubcolumnsVisitor : public InDepthQueryTreeVisitorWithContext<FunctionToSubcolumnsVisitor>
+struct ColumnContext
+{
+    NameAndTypePair column;
+    QueryTreeNodePtr column_source;
+    ContextPtr context;
+};
+
+using NodeToSubcolumnTransformer = std::function<void(QueryTreeNodePtr &, FunctionNode &, ColumnContext &)>;
+
+void optimizeFunctionLength(QueryTreeNodePtr & node, FunctionNode &, ColumnContext & ctx)
+{
+    /// Replace `length(argument)` with `argument.size0`
+    /// `argument` may be Array or Map.
+
+    NameAndTypePair column{ctx.column.name + ".size0", std::make_shared<DataTypeUInt64>()};
+    node = std::make_shared<ColumnNode>(column, ctx.column_source);
+}
+
+template <bool positive>
+void optimizeFunctionEmpty(QueryTreeNodePtr &, FunctionNode & function_node, ColumnContext & ctx)
+{
+    /// Replace `empty(argument)` with `equals(argument.size0, 0)` if positive
+    /// Replace `notEmpty(argument)` with `notEquals(argument.size0, 0)` if not positive
+    /// `argument` may be Array or Map.
+
+    NameAndTypePair column{ctx.column.name + ".size0", std::make_shared<DataTypeUInt64>()};
+    auto & function_arguments_nodes = function_node.getArguments().getNodes();
+
+    function_arguments_nodes.clear();
+    function_arguments_nodes.push_back(std::make_shared<ColumnNode>(column, ctx.column_source));
+    function_arguments_nodes.push_back(std::make_shared<ConstantNode>(static_cast<UInt64>(0)));
+
+    const auto * function_name = positive ? "equals" : "notEquals";
+    resolveOrdinaryFunctionNodeByName(function_node, function_name, ctx.context);
+}
+
+String getSubcolumnNameForElement(const Field & value, const DataTypeTuple & data_type_tuple)
+{
+    if (value.getType() == Field::Types::String)
+        return value.get<const String &>();
+
+    if (value.getType() == Field::Types::UInt64)
+        return data_type_tuple.getNameByPosition(value.get<UInt64>());
+
+    return "";
+}
+
+String getSubcolumnNameForElement(const Field & value, const DataTypeVariant &)
+{
+    if (value.getType() == Field::Types::String)
+        return value.get<const String &>();
+
+    return "";
+}
+
+template <typename DataType>
+void optimizeTupleOrVariantElement(QueryTreeNodePtr & node, FunctionNode & function_node, ColumnContext & ctx)
+{
+    /// Replace `tupleElement(tuple_argument, string_literal)`, `tupleElement(tuple_argument, integer_literal)` with `tuple_argument.column_name`.
+    /// Replace `variantElement(variant_argument, string_literal)` with `variant_argument.column_name`.
+
+    auto & function_arguments_nodes = function_node.getArguments().getNodes();
+    if (function_arguments_nodes.size() != 2)
+        return;
+
+    const auto * second_argument_constant_node = function_arguments_nodes[1]->as<ConstantNode>();
+    if (!second_argument_constant_node)
+        return;
+
+    const auto & data_type_concrete = assert_cast<const DataType &>(*ctx.column.type);
+    auto subcolumn_name = getSubcolumnNameForElement(second_argument_constant_node->getValue(), data_type_concrete);
+
+    if (subcolumn_name.empty())
+        return;
+
+    NameAndTypePair column{ctx.column.name + "." + subcolumn_name, function_node.getResultType()};
+    node = std::make_shared<ColumnNode>(column, ctx.column_source);
+}
+
+std::map<std::pair<TypeIndex, String>, NodeToSubcolumnTransformer> node_transformers =
+{
+    {
+        {TypeIndex::Array, "length"}, optimizeFunctionLength,
+    },
+    {
+        {TypeIndex::Array, "empty"}, optimizeFunctionEmpty<true>,
+    },
+    {
+        {TypeIndex::Array, "notEmpty"}, optimizeFunctionEmpty<false>,
+    },
+    {
+        {TypeIndex::Map, "length"}, optimizeFunctionLength,
+    },
+    {
+        {TypeIndex::Map, "empty"}, optimizeFunctionEmpty<true>,
+    },
+    {
+        {TypeIndex::Map, "notEmpty"}, optimizeFunctionEmpty<false>,
+    },
+    {
+        {TypeIndex::Map, "mapKeys"},
+        [](QueryTreeNodePtr & node, FunctionNode & function_node, ColumnContext & ctx)
+        {
+            /// Replace `mapKeys(map_argument)` with `map_argument.keys`
+            NameAndTypePair column{ctx.column.name + ".keys", function_node.getResultType()};
+            node = std::make_shared<ColumnNode>(column, ctx.column_source);
+        },
+    },
+    {
+        {TypeIndex::Map, "mapValues"},
+        [](QueryTreeNodePtr & node, FunctionNode & function_node, ColumnContext & ctx)
+        {
+            /// Replace `mapValues(map_argument)` with `map_argument.values`
+            NameAndTypePair column{ctx.column.name + ".values", function_node.getResultType()};
+            node = std::make_shared<ColumnNode>(column, ctx.column_source);
+        },
+    },
+    {
+        {TypeIndex::Map, "mapContains"},
+        [](QueryTreeNodePtr &, FunctionNode & function_node, ColumnContext & ctx)
+        {
+            /// Replace `mapContains(map_argument, argument)` with `has(map_argument.keys, argument)`
+            const auto & data_type_map = assert_cast<const DataTypeMap &>(*ctx.column.type);
+
+            NameAndTypePair column{ctx.column.name + ".keys", std::make_shared<DataTypeArray>(data_type_map.getKeyType())};
+            auto & function_arguments_nodes = function_node.getArguments().getNodes();
+
+            auto has_function_argument = std::make_shared<ColumnNode>(column, ctx.column_source);
+            function_arguments_nodes[0] = std::move(has_function_argument);
+
+            resolveOrdinaryFunctionNodeByName(function_node, "has", ctx.context);
+        },
+    },
+    {
+        {TypeIndex::Nullable, "count"},
+        [](QueryTreeNodePtr &, FunctionNode & function_node, ColumnContext & ctx)
+        {
+            /// Replace `count(nullable_argument)` with `sum(not(nullable_argument.null))`
+            NameAndTypePair column{ctx.column.name + ".null", std::make_shared<DataTypeUInt8>()};
+            auto & function_arguments_nodes = function_node.getArguments().getNodes();
+
+            auto new_column_node = std::make_shared<ColumnNode>(column, ctx.column_source);
+            auto function_node_not = std::make_shared<FunctionNode>("not");
+
+            function_node_not->getArguments().getNodes().push_back(std::move(new_column_node));
+            resolveOrdinaryFunctionNodeByName(*function_node_not, "not", ctx.context);
+
+            function_arguments_nodes = {std::move(function_node_not)};
+            resolveAggregateFunctionNodeByName(function_node, "sum");
+        },
+    },
+    {
+        {TypeIndex::Nullable, "isNull"},
+        [](QueryTreeNodePtr & node, FunctionNode &, ColumnContext & ctx)
+        {
+            /// Replace `isNull(nullable_argument)` with `nullable_argument.null`
+            NameAndTypePair column{ctx.column.name + ".null", std::make_shared<DataTypeUInt8>()};
+            node = std::make_shared<ColumnNode>(column, ctx.column_source);
+        },
+    },
+    {
+        {TypeIndex::Nullable, "isNotNull"},
+        [](QueryTreeNodePtr &, FunctionNode & function_node, ColumnContext & ctx)
+        {
+            /// Replace `isNotNull(nullable_argument)` with `not(nullable_argument.null)`
+            NameAndTypePair column{ctx.column.name + ".null", std::make_shared<DataTypeUInt8>()};
+            auto & function_arguments_nodes = function_node.getArguments().getNodes();
+
+            function_arguments_nodes = {std::make_shared<ColumnNode>(column, ctx.column_source)};
+            resolveOrdinaryFunctionNodeByName(function_node, "not", ctx.context);
+        },
+    },
+    {
+        {TypeIndex::Tuple, "tupleElement"}, optimizeTupleOrVariantElement<DataTypeTuple>,
+    },
+    {
+        {TypeIndex::Variant, "variantElement"}, optimizeTupleOrVariantElement<DataTypeVariant>,
+    },
+};
+
+std::tuple<FunctionNode *, ColumnNode *, TableNode *> getTypedNodesForOptimization(const QueryTreeNodePtr & node)
+{
+    auto * function_node = node->as<FunctionNode>();
+    if (!function_node)
+        return {};
+
+    auto & function_arguments_nodes = function_node->getArguments().getNodes();
+    if (function_arguments_nodes.empty() || function_arguments_nodes.size() > 2)
+        return {};
+
+    auto * first_argument_column_node = function_arguments_nodes.front()->as<ColumnNode>();
+    if (!first_argument_column_node || first_argument_column_node->getColumnName() == "__grouping_set")
+        return {};
+
+    auto column_source = first_argument_column_node->getColumnSource();
+    auto * table_node = column_source->as<TableNode>();
+    if (!table_node)
+        return {};
+
+    const auto & storage = table_node->getStorage();
+    const auto & storage_snapshot = table_node->getStorageSnapshot();
+    auto column = first_argument_column_node->getColumn();
+
+    if (!storage->supportsOptimizationToSubcolumns() || storage->isVirtualColumn(column.name, storage_snapshot->metadata))
+        return {};
+
+    auto column_in_table = storage_snapshot->tryGetColumn(GetColumnsOptions::All, column.name);
+    if (!column_in_table || !column_in_table->type->equals(*column.type))
+        return {};
+
+    return std::make_tuple(function_node, first_argument_column_node, table_node);
+}
+
+/// First pass collects info about identifiers to determine which identifiers are allowed to optimize.
+class FunctionToSubcolumnsVisitorFirstPass : public InDepthQueryTreeVisitorWithContext<FunctionToSubcolumnsVisitorFirstPass>
 {
 public:
-    using Base = InDepthQueryTreeVisitorWithContext<FunctionToSubcolumnsVisitor>;
+    using Base = InDepthQueryTreeVisitorWithContext<FunctionToSubcolumnsVisitorFirstPass>;
     using Base::Base;
 
-    void enterImpl(QueryTreeNodePtr & node) const
+    void enterImpl(const QueryTreeNodePtr & node)
     {
         if (!getSettings().optimize_functions_to_subcolumns)
             return;
 
-        auto * function_node = node->as<FunctionNode>();
-        if (!function_node)
+        if (auto * table_node = node->as<TableNode>())
+        {
+            enterImpl(*table_node);
             return;
+        }
 
-        auto & function_arguments_nodes = function_node->getArguments().getNodes();
-        size_t function_arguments_nodes_size = function_arguments_nodes.size();
-
-        if (function_arguments_nodes.empty() || function_arguments_nodes_size > 2)
+        if (auto * column_node = node->as<ColumnNode>())
+        {
+            enterImpl(*column_node);
             return;
+        }
 
-        auto * first_argument_column_node = function_arguments_nodes.front()->as<ColumnNode>();
+        auto [function_node, first_argument_node, table_node] = getTypedNodesForOptimization(node);
+        if (function_node && first_argument_node && table_node)
+        {
+            enterImpl(*function_node, *first_argument_node, *table_node);
+            return;
+        }
 
-        if (!first_argument_column_node)
+        if (const auto * join_node = node->as<JoinNode>())
+        {
+            can_wrap_result_columns_with_nullable |= getContext()->getSettingsRef().join_use_nulls;
             return;
+        }
 
-        if (first_argument_column_node->getColumnName() == "__grouping_set")
+        if (const auto * query_node = node->as<QueryNode>())
+        {
+            if (query_node->isGroupByWithCube() || query_node->isGroupByWithRollup() || query_node->isGroupByWithGroupingSets())
+                can_wrap_result_columns_with_nullable |= getContext()->getSettingsRef().group_by_use_nulls;
             return;
+        }
+    }
 
-        auto column_source = first_argument_column_node->getColumnSource();
-        auto * table_node = column_source->as<TableNode>();
+    std::unordered_set<Identifier> getIdentifiersToOptimize() const
+    {
+        if (can_wrap_result_columns_with_nullable)
+        {
+            /// Do not optimize if we have JOIN with setting join_use_null.
+            /// Do not optimize if we have GROUP BY WITH ROLLUP/CUBE/GROUPING SETS with setting group_by_use_nulls.
+            /// It may change the behaviour if subcolumn can be converted
+            /// to Nullable while the original column cannot (e.g. for Array type).
+            return {};
+        }
 
-        if (!table_node)
-            return;
+        /// Do not optimize if full column is requested in other context.
+        /// It doesn't make sense because it doesn't reduce amount of read data
+        /// and optimized functions are not computation heavy. But introducing
+        /// new identifier complicates query analysis and may break it.
+        ///
+        /// E.g. query:
+        ///     SELECT n FROM table GROUP BY n HAVING isNotNull(n)
+        /// may be optimized to incorrect query:
+        ///     SELECT n FROM table GROUP BY n HAVING not(n.null)
+        /// Will produce: `n.null` is not under aggregate function and not in GROUP BY keys)
+        ///
+        /// Do not optimize index columns (primary, min-max, secondary),
+        /// because otherwise analysis of indexes may be broken.
+        /// TODO: handle subcolumns in index analysis.
+
+        std::unordered_set<Identifier> identifiers_to_optimize;
+        for (const auto & [identifier, count] : optimized_identifiers_count)
+        {
+            if (all_key_columns.contains(identifier))
+                continue;
 
-        const auto & storage = table_node->getStorage();
-        if (!storage->supportsSubcolumns())
-            return;
+            auto it = identifiers_count.find(identifier);
+            if (it != identifiers_count.end() && it->second == count)
+                identifiers_to_optimize.insert(identifier);
+        }
 
-        auto column = first_argument_column_node->getColumn();
-        WhichDataType column_type(column.type);
+        return identifiers_to_optimize;
+    }
+
+private:
+    std::unordered_set<Identifier> all_key_columns;
+    std::unordered_map<Identifier, UInt64> identifiers_count;
+    std::unordered_map<Identifier, UInt64> optimized_identifiers_count;
 
-        const auto & function_name = function_node->getFunctionName();
+    NameSet processed_tables;
+    bool can_wrap_result_columns_with_nullable = false;
 
-        if (function_arguments_nodes_size == 1)
+    void enterImpl(const TableNode & table_node)
+    {
+        auto table_name = table_node.getStorage()->getStorageID().getFullTableName();
+        if (processed_tables.emplace(table_name).second)
+            return;
+
+        auto add_key_columns = [&](const auto & key_columns)
         {
-            if (column_type.isArray())
-            {
-                if (function_name == "length")
-                {
-                    /// Replace `length(array_argument)` with `array_argument.size0`
-                    column.name += ".size0";
-                    column.type = std::make_shared<DataTypeUInt64>();
-
-                    node = std::make_shared<ColumnNode>(column, column_source);
-                }
-                else if (function_name == "empty")
-                {
-                    /// Replace `empty(array_argument)` with `equals(array_argument.size0, 0)`
-                    column.name += ".size0";
-                    column.type = std::make_shared<DataTypeUInt64>();
-
-                    function_arguments_nodes.clear();
-                    function_arguments_nodes.push_back(std::make_shared<ColumnNode>(column, column_source));
-                    function_arguments_nodes.push_back(std::make_shared<ConstantNode>(static_cast<UInt64>(0)));
-
-                    resolveOrdinaryFunctionNode(*function_node, "equals");
-                }
-                else if (function_name == "notEmpty")
-                {
-                    /// Replace `notEmpty(array_argument)` with `notEquals(array_argument.size0, 0)`
-                    column.name += ".size0";
-                    column.type = std::make_shared<DataTypeUInt64>();
-
-                    function_arguments_nodes.clear();
-                    function_arguments_nodes.push_back(std::make_shared<ColumnNode>(column, column_source));
-                    function_arguments_nodes.push_back(std::make_shared<ConstantNode>(static_cast<UInt64>(0)));
-
-                    resolveOrdinaryFunctionNode(*function_node, "notEquals");
-                }
-            }
-            else if (column_type.isNullable())
-            {
-                if (function_name == "isNull")
-                {
-                    /// Replace `isNull(nullable_argument)` with `nullable_argument.null`
-                    column.name += ".null";
-                    column.type = std::make_shared<DataTypeUInt8>();
-
-                    node = std::make_shared<ColumnNode>(column, column_source);
-                }
-                else if (function_name == "isNotNull")
-                {
-                    /// Replace `isNotNull(nullable_argument)` with `not(nullable_argument.null)`
-                    column.name += ".null";
-                    column.type = std::make_shared<DataTypeUInt8>();
-
-                    function_arguments_nodes = {std::make_shared<ColumnNode>(column, column_source)};
-
-                    resolveOrdinaryFunctionNode(*function_node, "not");
-                }
-            }
-            else if (column_type.isMap())
+            for (const auto & column_name : key_columns)
             {
-                if (function_name == "mapKeys")
-                {
-                    /// Replace `mapKeys(map_argument)` with `map_argument.keys`
-                    column.name += ".keys";
-                    column.type = function_node->getResultType();
-
-                    node = std::make_shared<ColumnNode>(column, column_source);
-                }
-                else if (function_name == "mapValues")
-                {
-                    /// Replace `mapValues(map_argument)` with `map_argument.values`
-                    column.name += ".values";
-                    column.type = function_node->getResultType();
-
-                    node = std::make_shared<ColumnNode>(column, column_source);
-                }
+                Identifier identifier({table_name, column_name});
+                all_key_columns.insert(identifier);
             }
-        }
-        else
-        {
-            const auto * second_argument_constant_node = function_arguments_nodes[1]->as<ConstantNode>();
+        };
 
-            if (function_name == "tupleElement" && column_type.isTuple() && second_argument_constant_node)
-            {
-                /** Replace `tupleElement(tuple_argument, string_literal)`, `tupleElement(tuple_argument, integer_literal)`
-                  * with `tuple_argument.column_name`.
-                  */
-                const auto & tuple_element_constant_value = second_argument_constant_node->getValue();
-                const auto & tuple_element_constant_value_type = tuple_element_constant_value.getType();
-
-                const auto & data_type_tuple = assert_cast<const DataTypeTuple &>(*column.type);
-
-                String subcolumn_name;
-
-                if (tuple_element_constant_value_type == Field::Types::String)
-                {
-                    subcolumn_name = tuple_element_constant_value.get<const String &>();
-                }
-                else if (tuple_element_constant_value_type == Field::Types::UInt64)
-                {
-                    auto tuple_column_index = tuple_element_constant_value.get<UInt64>();
-                    subcolumn_name = data_type_tuple.getNameByPosition(tuple_column_index);
-                }
-                else
-                {
-                    return;
-                }
-
-                column.name += '.';
-                column.name += subcolumn_name;
-                column.type = function_node->getResultType();
-
-                node = std::make_shared<ColumnNode>(column, column_source);
-            }
-            else if (function_name == "variantElement" && isVariant(column_type) && second_argument_constant_node)
-            {
-                /// Replace `variantElement(variant_argument, type_name)` with `variant_argument.type_name`.
-                const auto & variant_element_constant_value = second_argument_constant_node->getValue();
-                String subcolumn_name;
+        const auto & metadata_snapshot = table_node.getStorageSnapshot()->metadata;
+        const auto & primary_key_columns = metadata_snapshot->getColumnsRequiredForPrimaryKey();
+        const auto & partition_key_columns = metadata_snapshot->getColumnsRequiredForPartitionKey();
+
+        add_key_columns(primary_key_columns);
+        add_key_columns(partition_key_columns);
+
+        for (const auto & index : metadata_snapshot->getSecondaryIndices())
+        {
+            const auto & index_columns = index.expression->getRequiredColumns();
+            add_key_columns(index_columns);
+        }
+    }
 
-                if (variant_element_constant_value.getType() != Field::Types::String)
-                    return;
+    void enterImpl(const ColumnNode & column_node)
+    {
+        if (column_node.getColumnName() == "__grouping_set")
+            return;
 
-                subcolumn_name = variant_element_constant_value.get<const String &>();
+        auto column_source = column_node.getColumnSource();
+        auto * table_node = column_source->as<TableNode>();
+        if (!table_node)
+            return;
 
-                column.name += '.';
-                column.name += subcolumn_name;
-                column.type = function_node->getResultType();
+        auto table_name = table_node->getStorage()->getStorageID().getFullTableName();
+        Identifier qualified_name({table_name, column_node.getColumnName()});
 
-                node = std::make_shared<ColumnNode>(column, column_source);
-            }
-            else if (function_name == "mapContains" && column_type.isMap())
-            {
-                const auto & data_type_map = assert_cast<const DataTypeMap &>(*column.type);
+        ++identifiers_count[qualified_name];
+    }
 
-                /// Replace `mapContains(map_argument, argument)` with `has(map_argument.keys, argument)`
-                column.name += ".keys";
-                column.type = std::make_shared<DataTypeArray>(data_type_map.getKeyType());
+    void enterImpl(const FunctionNode & function_node, const ColumnNode & first_argument_column_node, const TableNode & table_node)
+    {
+        /// For queries with FINAL converting function to subcolumn may alter
+        /// special merging algorithms and produce wrong result of query.
+        if (table_node.hasTableExpressionModifiers() && table_node.getTableExpressionModifiers()->hasFinal())
+            return;
 
-                auto has_function_argument = std::make_shared<ColumnNode>(column, column_source);
-                function_arguments_nodes[0] = std::move(has_function_argument);
+        const auto & column = first_argument_column_node.getColumn();
+        auto table_name = table_node.getStorage()->getStorageID().getFullTableName();
+        Identifier qualified_name({table_name, column.name});
 
-                resolveOrdinaryFunctionNode(*function_node, "has");
-            }
-        }
+        if (node_transformers.contains({column.type->getTypeId(), function_node.getFunctionName()}))
+            ++optimized_identifiers_count[qualified_name];
     }
+};
 
+/// Second pass optimizes functions to subcolumns for allowed identifiers.
+class FunctionToSubcolumnsVisitorSecondPass : public InDepthQueryTreeVisitorWithContext<FunctionToSubcolumnsVisitorSecondPass>
+{
 private:
-    void resolveOrdinaryFunctionNode(FunctionNode & function_node, const String & function_name) const
+    std::unordered_set<Identifier> identifiers_to_optimize;
+
+public:
+    using Base = InDepthQueryTreeVisitorWithContext<FunctionToSubcolumnsVisitorSecondPass>;
+    using Base::Base;
+
+    FunctionToSubcolumnsVisitorSecondPass(ContextPtr context_, std::unordered_set<Identifier> identifiers_to_optimize_)
+        : Base(std::move(context_)), identifiers_to_optimize(std::move(identifiers_to_optimize_))
+    {
+    }
+
+    void enterImpl(QueryTreeNodePtr & node) const
     {
-        auto function = FunctionFactory::instance().get(function_name, getContext());
-        function_node.resolveAsFunction(function->build(function_node.getArgumentColumns()));
+        if (!getSettings().optimize_functions_to_subcolumns)
+            return;
+
+        auto [function_node, first_argument_column_node, table_node] = getTypedNodesForOptimization(node);
+        if (!function_node || !first_argument_column_node || !table_node)
+            return;
+
+        auto column = first_argument_column_node->getColumn();
+        auto table_name = table_node->getStorage()->getStorageID().getFullTableName();
+
+        Identifier qualified_name({table_name, column.name});
+        if (!identifiers_to_optimize.contains(qualified_name))
+            return;
+
+        auto transformer_it = node_transformers.find({column.type->getTypeId(), function_node->getFunctionName()});
+        if (transformer_it != node_transformers.end())
+        {
+            ColumnContext ctx{std::move(column), first_argument_column_node->getColumnSource(), getContext()};
+            transformer_it->second(node, *function_node, ctx);
+        }
     }
 };
 
@@ -226,8 +438,15 @@ class FunctionToSubcolumnsVisitor : public InDepthQueryTreeVisitorWithContext<Fu
 
 void FunctionToSubcolumnsPass::run(QueryTreeNodePtr & query_tree_node, ContextPtr context)
 {
-    FunctionToSubcolumnsVisitor visitor(context);
-    visitor.visit(query_tree_node);
+    FunctionToSubcolumnsVisitorFirstPass first_visitor(context);
+    first_visitor.visit(query_tree_node);
+    auto identifiers_to_optimize = first_visitor.getIdentifiersToOptimize();
+
+    if (identifiers_to_optimize.empty())
+        return;
+
+    FunctionToSubcolumnsVisitorSecondPass second_visitor(std::move(context), std::move(identifiers_to_optimize));
+    second_visitor.visit(query_tree_node);
 }
 
 }
diff --git a/src/Analyzer/Passes/NormalizeCountVariantsPass.cpp b/src/Analyzer/Passes/NormalizeCountVariantsPass.cpp
index e70e08e65f49..f9066b0363cf 100644
--- a/src/Analyzer/Passes/NormalizeCountVariantsPass.cpp
+++ b/src/Analyzer/Passes/NormalizeCountVariantsPass.cpp
@@ -6,6 +6,7 @@
 #include <Analyzer/InDepthQueryTreeVisitor.h>
 #include <Analyzer/ConstantNode.h>
 #include <Analyzer/FunctionNode.h>
+#include <Analyzer/Utils.h>
 #include <Interpreters/Context.h>
 #include <DataTypes/DataTypesNumber.h>
 
@@ -47,25 +48,17 @@ class NormalizeCountVariantsVisitor : public InDepthQueryTreeVisitorWithContext<
 
         if (function_node->getFunctionName() == "count" && !first_argument_constant_literal.isNull())
         {
-            resolveAsCountAggregateFunction(*function_node);
             function_node->getArguments().getNodes().clear();
+            resolveAggregateFunctionNodeByName(*function_node, "count");
         }
         else if (function_node->getFunctionName() == "sum" &&
             first_argument_constant_literal.getType() == Field::Types::UInt64 &&
             first_argument_constant_literal.get<UInt64>() == 1)
         {
-            resolveAsCountAggregateFunction(*function_node);
             function_node->getArguments().getNodes().clear();
+            resolveAggregateFunctionNodeByName(*function_node, "count");
         }
     }
-private:
-    static void resolveAsCountAggregateFunction(FunctionNode & function_node)
-    {
-        AggregateFunctionProperties properties;
-        auto aggregate_function = AggregateFunctionFactory::instance().get("count", NullsAction::EMPTY, {}, {}, properties);
-
-        function_node.resolveAsAggregateFunction(std::move(aggregate_function));
-    }
 };
 
 }
diff --git a/src/Analyzer/Passes/OptimizeDateOrDateTimeConverterWithPreimagePass.cpp b/src/Analyzer/Passes/OptimizeDateOrDateTimeConverterWithPreimagePass.cpp
index 0c37749c7060..a8364f1ab7a4 100644
--- a/src/Analyzer/Passes/OptimizeDateOrDateTimeConverterWithPreimagePass.cpp
+++ b/src/Analyzer/Passes/OptimizeDateOrDateTimeConverterWithPreimagePass.cpp
@@ -5,6 +5,7 @@
 #include <Analyzer/ColumnNode.h>
 #include <Analyzer/ConstantNode.h>
 #include <Analyzer/FunctionNode.h>
+#include <Analyzer/Utils.h>
 #include <Analyzer/InDepthQueryTreeVisitor.h>
 #include <Common/DateLUT.h>
 #include <Common/DateLUTImpl.h>
diff --git a/src/Analyzer/Passes/RewriteAggregateFunctionWithIfPass.cpp b/src/Analyzer/Passes/RewriteAggregateFunctionWithIfPass.cpp
index 3500d8327ac6..05377f8514e5 100644
--- a/src/Analyzer/Passes/RewriteAggregateFunctionWithIfPass.cpp
+++ b/src/Analyzer/Passes/RewriteAggregateFunctionWithIfPass.cpp
@@ -74,8 +74,7 @@ class RewriteAggregateFunctionWithIfVisitor : public InDepthQueryTreeVisitorWith
 
                 new_arguments[1] = std::move(if_arguments_nodes[0]);
                 function_arguments_nodes = std::move(new_arguments);
-                resolveAsAggregateFunctionWithIf(
-                    *function_node, {function_arguments_nodes[0]->getResultType(), function_arguments_nodes[1]->getResultType()});
+                resolveAggregateFunctionNodeByName(*function_node, function_node->getFunctionName() + "If");
             }
         }
         else if (first_const_node)
@@ -104,27 +103,10 @@ class RewriteAggregateFunctionWithIfVisitor : public InDepthQueryTreeVisitorWith
                 new_arguments[1] = std::move(not_function);
 
                 function_arguments_nodes = std::move(new_arguments);
-                resolveAsAggregateFunctionWithIf(
-                    *function_node, {function_arguments_nodes[0]->getResultType(), function_arguments_nodes[1]->getResultType()});
+                resolveAggregateFunctionNodeByName(*function_node, function_node->getFunctionName() + "If");
             }
         }
     }
-
-private:
-    static void resolveAsAggregateFunctionWithIf(FunctionNode & function_node, const DataTypes & argument_types)
-    {
-        auto result_type = function_node.getResultType();
-
-        AggregateFunctionProperties properties;
-        auto aggregate_function = AggregateFunctionFactory::instance().get(
-            function_node.getFunctionName() + "If",
-            function_node.getNullsAction(),
-            argument_types,
-            function_node.getAggregateFunction()->getParameters(),
-            properties);
-
-        function_node.resolveAsAggregateFunction(std::move(aggregate_function));
-    }
 };
 
 }
diff --git a/src/Analyzer/Passes/RewriteSumFunctionWithSumAndCountPass.cpp b/src/Analyzer/Passes/RewriteSumFunctionWithSumAndCountPass.cpp
index 5646d26f7f60..524ee8077213 100644
--- a/src/Analyzer/Passes/RewriteSumFunctionWithSumAndCountPass.cpp
+++ b/src/Analyzer/Passes/RewriteSumFunctionWithSumAndCountPass.cpp
@@ -73,23 +73,24 @@ class RewriteSumFunctionWithSumAndCountVisitor : public InDepthQueryTreeVisitorW
 
         const auto lhs = std::make_shared<FunctionNode>("sum");
         lhs->getArguments().getNodes().push_back(func_plus_minus_nodes[column_id]);
-        resolveAsAggregateFunctionNode(*lhs, column_type);
+        resolveAggregateFunctionNodeByName(*lhs, lhs->getFunctionName());
 
         const auto rhs_count = std::make_shared<FunctionNode>("count");
         rhs_count->getArguments().getNodes().push_back(func_plus_minus_nodes[column_id]);
-        resolveAsAggregateFunctionNode(*rhs_count, column_type);
+        resolveAggregateFunctionNodeByName(*rhs_count, rhs_count->getFunctionName());
 
         const auto rhs = std::make_shared<FunctionNode>("multiply");
         rhs->getArguments().getNodes().push_back(func_plus_minus_nodes[literal_id]);
         rhs->getArguments().getNodes().push_back(rhs_count);
-        resolveOrdinaryFunctionNode(*rhs, rhs->getFunctionName());
+        resolveOrdinaryFunctionNodeByName(*rhs, rhs->getFunctionName(), getContext());
 
         auto new_node = std::make_shared<FunctionNode>(Poco::toLower(func_plus_minus_node->getFunctionName()));
         if (column_id == 0)
             new_node->getArguments().getNodes() = {lhs, rhs};
         else if (column_id == 1)
             new_node->getArguments().getNodes() = {rhs, lhs};
-        resolveOrdinaryFunctionNode(*new_node, new_node->getFunctionName());
+
+        resolveOrdinaryFunctionNodeByName(*new_node, new_node->getFunctionName(), getContext());
 
         if (!new_node)
             return;
@@ -100,28 +101,7 @@ class RewriteSumFunctionWithSumAndCountVisitor : public InDepthQueryTreeVisitorW
             res = createCastFunction(res, function_node->getResultType(), getContext());
 
         node = std::move(res);
-
-    }
-
-private:
-    void resolveOrdinaryFunctionNode(FunctionNode & function_node, const String & function_name) const
-    {
-        const auto function = FunctionFactory::instance().get(function_name, getContext());
-        function_node.resolveAsFunction(function->build(function_node.getArgumentColumns()));
     }
-
-    static void resolveAsAggregateFunctionNode(FunctionNode & function_node, const DataTypePtr & argument_type)
-    {
-        AggregateFunctionProperties properties;
-        const auto aggregate_function = AggregateFunctionFactory::instance().get(function_node.getFunctionName(),
-            NullsAction::EMPTY,
-            {argument_type},
-            {},
-            properties);
-
-        function_node.resolveAsAggregateFunction(aggregate_function);
-    }
-
 };
 
 }
diff --git a/src/Analyzer/Passes/SumIfToCountIfPass.cpp b/src/Analyzer/Passes/SumIfToCountIfPass.cpp
index 852cbe75c4ad..f52d724f3463 100644
--- a/src/Analyzer/Passes/SumIfToCountIfPass.cpp
+++ b/src/Analyzer/Passes/SumIfToCountIfPass.cpp
@@ -5,6 +5,7 @@
 
 #include <AggregateFunctions/AggregateFunctionFactory.h>
 #include <AggregateFunctions/IAggregateFunction.h>
+#include <Analyzer/Utils.h>
 
 #include <Functions/FunctionFactory.h>
 
@@ -65,7 +66,8 @@ class SumIfToCountIfVisitor : public InDepthQueryTreeVisitorWithContext<SumIfToC
             auto multiplier_node = function_node_arguments_nodes[0];
             function_node_arguments_nodes[0] = std::move(function_node_arguments_nodes[1]);
             function_node_arguments_nodes.resize(1);
-            resolveAsCountIfAggregateFunction(*function_node, function_node_arguments_nodes[0]->getResultType());
+
+            resolveAggregateFunctionNodeByName(*function_node, "countIf");
 
             if (constant_value_literal.get<UInt64>() != 1)
             {
@@ -115,7 +117,7 @@ class SumIfToCountIfVisitor : public InDepthQueryTreeVisitorWithContext<SumIfToC
             function_node_arguments_nodes[0] = nested_if_function_arguments_nodes[0];
             function_node_arguments_nodes.resize(1);
 
-            resolveAsCountIfAggregateFunction(*function_node, function_node_arguments_nodes[0]->getResultType());
+            resolveAggregateFunctionNodeByName(*function_node, "countIf");
 
             if (if_true_condition_value != 1)
             {
@@ -144,7 +146,7 @@ class SumIfToCountIfVisitor : public InDepthQueryTreeVisitorWithContext<SumIfToC
             function_node_arguments_nodes[0] = std::move(not_function);
             function_node_arguments_nodes.resize(1);
 
-            resolveAsCountIfAggregateFunction(*function_node, function_node_arguments_nodes[0]->getResultType());
+            resolveAggregateFunctionNodeByName(*function_node, "countIf");
 
             if (if_false_condition_value != 1)
             {
@@ -156,15 +158,6 @@ class SumIfToCountIfVisitor : public InDepthQueryTreeVisitorWithContext<SumIfToC
     }
 
 private:
-    static void resolveAsCountIfAggregateFunction(FunctionNode & function_node, const DataTypePtr & argument_type)
-    {
-        AggregateFunctionProperties properties;
-        auto aggregate_function = AggregateFunctionFactory::instance().get(
-            "countIf", NullsAction::EMPTY, {argument_type}, function_node.getAggregateFunction()->getParameters(), properties);
-
-        function_node.resolveAsAggregateFunction(std::move(aggregate_function));
-    }
-
     QueryTreeNodePtr getMultiplyFunction(QueryTreeNodePtr left, QueryTreeNodePtr right)
     {
         auto multiply_function_node = std::make_shared<FunctionNode>("multiply");
diff --git a/src/Analyzer/Passes/UniqInjectiveFunctionsEliminationPass.cpp b/src/Analyzer/Passes/UniqInjectiveFunctionsEliminationPass.cpp
index 91186db0e0cf..947952ac3a80 100644
--- a/src/Analyzer/Passes/UniqInjectiveFunctionsEliminationPass.cpp
+++ b/src/Analyzer/Passes/UniqInjectiveFunctionsEliminationPass.cpp
@@ -7,6 +7,7 @@
 
 #include <Analyzer/InDepthQueryTreeVisitor.h>
 #include <Analyzer/FunctionNode.h>
+#include <Analyzer/Utils.h>
 
 
 namespace DB
diff --git a/src/Analyzer/Passes/UniqToCountPass.cpp b/src/Analyzer/Passes/UniqToCountPass.cpp
index b801865c9a5a..83705f54b38e 100644
--- a/src/Analyzer/Passes/UniqToCountPass.cpp
+++ b/src/Analyzer/Passes/UniqToCountPass.cpp
@@ -7,6 +7,7 @@
 #include <Analyzer/FunctionNode.h>
 #include <Analyzer/InDepthQueryTreeVisitor.h>
 #include <Analyzer/QueryNode.h>
+#include <Analyzer/Utils.h>
 
 namespace DB
 {
@@ -184,11 +185,8 @@ class UniqToCountVisitor : public InDepthQueryTreeVisitorWithContext<UniqToCount
         /// Replace uniq of initial query to count
         if (match_subquery_with_distinct() || match_subquery_with_group_by())
         {
-            AggregateFunctionProperties properties;
-            auto aggregate_function = AggregateFunctionFactory::instance().get("count", NullsAction::EMPTY, {}, {}, properties);
-
             function_node->getArguments().getNodes().clear();
-            function_node->resolveAsAggregateFunction(std::move(aggregate_function));
+            resolveAggregateFunctionNodeByName(*function_node, "count");
         }
     }
 };
diff --git a/src/Analyzer/Utils.cpp b/src/Analyzer/Utils.cpp
index 3c3489681f6a..cf4a3f77e348 100644
--- a/src/Analyzer/Utils.cpp
+++ b/src/Analyzer/Utils.cpp
@@ -636,16 +636,16 @@ class CheckFunctionExistsVisitor : public ConstInDepthQueryTreeVisitor<CheckFunc
     bool has_function = false;
 };
 
-inline AggregateFunctionPtr resolveAggregateFunction(FunctionNode * function_node)
+inline AggregateFunctionPtr resolveAggregateFunction(FunctionNode & function_node, const String & function_name)
 {
     Array parameters;
-    for (const auto & param : function_node->getParameters())
+    for (const auto & param : function_node.getParameters())
     {
         auto * constant = param->as<ConstantNode>();
         parameters.push_back(constant->getValue());
     }
 
-    const auto & function_node_argument_nodes = function_node->getArguments().getNodes();
+    const auto & function_node_argument_nodes = function_node.getArguments().getNodes();
 
     DataTypes argument_types;
     argument_types.reserve(function_node_argument_nodes.size());
@@ -655,7 +655,7 @@ inline AggregateFunctionPtr resolveAggregateFunction(FunctionNode * function_nod
 
     AggregateFunctionProperties properties;
     auto action = NullsAction::EMPTY;
-    return AggregateFunctionFactory::instance().get(function_node->getFunctionName(), action, argument_types, parameters, properties);
+    return AggregateFunctionFactory::instance().get(function_name, action, argument_types, parameters, properties);
 }
 
 }
@@ -736,11 +736,11 @@ void rerunFunctionResolve(FunctionNode * function_node, ContextPtr context)
     {
         if (name == "nothing" || name == "nothingUInt64" || name == "nothingNull")
             return;
-        function_node->resolveAsAggregateFunction(resolveAggregateFunction(function_node));
+        function_node->resolveAsAggregateFunction(resolveAggregateFunction(*function_node, function_node->getFunctionName()));
     }
     else if (function_node->isWindowFunction())
     {
-        function_node->resolveAsWindowFunction(resolveAggregateFunction(function_node));
+        function_node->resolveAsWindowFunction(resolveAggregateFunction(*function_node, function_node->getFunctionName()));
     }
 }
 
@@ -793,6 +793,18 @@ QueryTreeNodePtr createCastFunction(QueryTreeNodePtr node, DataTypePtr result_ty
     return function_node;
 }
 
+void resolveOrdinaryFunctionNodeByName(FunctionNode & function_node, const String & function_name, const ContextPtr & context)
+{
+    auto function = FunctionFactory::instance().get(function_name, context);
+    function_node.resolveAsFunction(function->build(function_node.getArgumentColumns()));
+}
+
+void resolveAggregateFunctionNodeByName(FunctionNode & function_node, const String & function_name)
+{
+    auto aggregate_function = resolveAggregateFunction(function_node, function_name);
+    function_node.resolveAsAggregateFunction(std::move(aggregate_function));
+}
+
 /** Returns:
   * {_, false} - multiple sources
   * {nullptr, true} - no sources (for constants)
diff --git a/src/Analyzer/Utils.h b/src/Analyzer/Utils.h
index f64b724abebd..f2e2c500384f 100644
--- a/src/Analyzer/Utils.h
+++ b/src/Analyzer/Utils.h
@@ -112,6 +112,14 @@ NameSet collectIdentifiersFullNames(const QueryTreeNodePtr & node);
 /// Wrap node into `_CAST` function
 QueryTreeNodePtr createCastFunction(QueryTreeNodePtr node, DataTypePtr result_type, ContextPtr context);
 
+/// Resolves function node as ordinary function with given name.
+/// Arguments and parameters are taken from the node.
+void resolveOrdinaryFunctionNodeByName(FunctionNode & function_node, const String & function_name, const ContextPtr & context);
+
+/// Resolves function node as aggregate function with given name.
+/// Arguments and parameters are taken from the node.
+void resolveAggregateFunctionNodeByName(FunctionNode & function_node, const String & function_name);
+
 /// Checks that node has only one source and returns it
 QueryTreeNodePtr getExpressionSource(const QueryTreeNodePtr & node);
 
diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index d84e5b149f6f..357c486aa75b 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -623,7 +623,7 @@ class IColumn;
     M(Bool, optimize_if_chain_to_multiif, false, "Replace if(cond1, then1, if(cond2, ...)) chains to multiIf. Currently it's not beneficial for numeric types.", 0) \
     M(Bool, optimize_multiif_to_if, true, "Replace 'multiIf' with only one condition to 'if'.", 0) \
     M(Bool, optimize_if_transform_strings_to_enum, false, "Replaces string-type arguments in If and Transform to enum. Disabled by default cause it could make inconsistent change in distributed query that would lead to its fail.", 0) \
-    M(Bool, optimize_functions_to_subcolumns, false, "Transform functions to subcolumns, if possible, to reduce amount of read data. E.g. 'length(arr)' -> 'arr.size0', 'col IS NULL' -> 'col.null' ", 0) \
+    M(Bool, optimize_functions_to_subcolumns, true, "Transform functions to subcolumns, if possible, to reduce amount of read data. E.g. 'length(arr)' -> 'arr.size0', 'col IS NULL' -> 'col.null' ", 0) \
     M(Bool, optimize_using_constraints, false, "Use constraints for query optimization", 0)                                                                                                                                           \
     M(Bool, optimize_substitute_columns, false, "Use constraints for column substitution", 0)                                                                                                                                         \
     M(Bool, optimize_append_index, false, "Use constraints in order to append index condition (indexHint)", 0) \
diff --git a/src/Core/SettingsChangesHistory.cpp b/src/Core/SettingsChangesHistory.cpp
index 7719fe1e8372..f89788de923d 100644
--- a/src/Core/SettingsChangesHistory.cpp
+++ b/src/Core/SettingsChangesHistory.cpp
@@ -58,6 +58,7 @@ String ClickHouseVersion::toString() const
 static std::initializer_list<std::pair<ClickHouseVersion, SettingsChangesHistory::SettingsChanges>> settings_changes_history_initializer =
 {
     {"24.7", {{"output_format_parquet_write_page_index", false, true, "Add a possibility to write page index into parquet files."},
+              {"optimize_functions_to_subcolumns", false, true, "Enable optimization by default"},
               {"input_format_json_ignore_key_case", false, false, "Ignore json key case while read json field from string."},
               {"optimize_trivial_insert_select", true, false, "The optimization does not make sense in many cases."},
               }},
diff --git a/src/DataTypes/DataTypeTuple.cpp b/src/DataTypes/DataTypeTuple.cpp
index a4c8ed1a241b..e96937d522d7 100644
--- a/src/DataTypes/DataTypeTuple.cpp
+++ b/src/DataTypes/DataTypeTuple.cpp
@@ -32,7 +32,7 @@ namespace ErrorCodes
     extern const int NOT_FOUND_COLUMN_IN_BLOCK;
     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
     extern const int SIZES_OF_COLUMNS_IN_TUPLE_DOESNT_MATCH;
-    extern const int ILLEGAL_INDEX;
+    extern const int ARGUMENT_OUT_OF_BOUND;
     extern const int LOGICAL_ERROR;
 }
 
@@ -286,7 +286,7 @@ std::optional<size_t> DataTypeTuple::tryGetPositionByName(const String & name) c
 String DataTypeTuple::getNameByPosition(size_t i) const
 {
     if (i == 0 || i > names.size())
-        throw Exception(ErrorCodes::ILLEGAL_INDEX, "Index of tuple element ({}) if out range ([1, {}])", i, names.size());
+        throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, "Index of tuple element ({}) is out range ([1, {}])", i, names.size());
 
     return names[i - 1];
 }
diff --git a/src/Functions/array/FunctionsMapMiscellaneous.cpp b/src/Functions/array/FunctionsMapMiscellaneous.cpp
index 76c1ec18171c..c3586a571618 100644
--- a/src/Functions/array/FunctionsMapMiscellaneous.cpp
+++ b/src/Functions/array/FunctionsMapMiscellaneous.cpp
@@ -51,6 +51,8 @@ class FunctionMapToArrayAdapter : public IFunction
 
     bool isVariadic() const override { return impl.isVariadic(); }
     size_t getNumberOfArguments() const override { return impl.getNumberOfArguments(); }
+    bool useDefaultImplementationForNulls() const override { return impl.useDefaultImplementationForNulls(); }
+    bool useDefaultImplementationForLowCardinalityColumns() const override { return impl.useDefaultImplementationForLowCardinalityColumns(); }
     bool useDefaultImplementationForConstants() const override { return impl.useDefaultImplementationForConstants(); }
     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo &) const override  { return false; }
 
@@ -184,7 +186,7 @@ struct MapToNestedAdapter : public MapAdapterBase<MapToNestedAdapter<Name, retur
 template <typename Name, size_t position>
 struct MapToSubcolumnAdapter
 {
-    static_assert(position <= 1);
+    static_assert(position <= 1, "position of Map subcolumn must be 0 or 1");
 
     static void extractNestedTypes(DataTypes & types)
     {
@@ -357,7 +359,7 @@ struct NameMapValues { static constexpr auto name = "mapValues"; };
 using FunctionMapValues = FunctionMapToArrayAdapter<FunctionIdentity, MapToSubcolumnAdapter<NameMapValues, 1>, NameMapValues>;
 
 struct NameMapContains { static constexpr auto name = "mapContains"; };
-using FunctionMapContains = FunctionMapToArrayAdapter<FunctionArrayIndex<HasAction, NameMapContains>, MapToSubcolumnAdapter<NameMapKeys, 0>, NameMapContains>;
+using FunctionMapContains = FunctionMapToArrayAdapter<FunctionArrayIndex<HasAction, NameMapContains>, MapToSubcolumnAdapter<NameMapContains, 0>, NameMapContains>;
 
 struct NameMapFilter { static constexpr auto name = "mapFilter"; };
 using FunctionMapFilter = FunctionMapToArrayAdapter<FunctionArrayFilter, MapToNestedAdapter<NameMapFilter>, NameMapFilter>;
diff --git a/src/Interpreters/InterpreterExplainQuery.cpp b/src/Interpreters/InterpreterExplainQuery.cpp
index 3a06e1b2301b..7c7b4b3f95a1 100644
--- a/src/Interpreters/InterpreterExplainQuery.cpp
+++ b/src/Interpreters/InterpreterExplainQuery.cpp
@@ -43,6 +43,7 @@ namespace ErrorCodes
     extern const int UNKNOWN_SETTING;
     extern const int LOGICAL_ERROR;
     extern const int NOT_IMPLEMENTED;
+    extern const int BAD_ARGUMENTS;
 }
 
 namespace
@@ -170,6 +171,7 @@ struct QueryASTSettings
 struct QueryTreeSettings
 {
     bool run_passes = true;
+    bool dump_tree = true;
     bool dump_passes = false;
     bool dump_ast = false;
     Int64 passes = -1;
@@ -179,6 +181,7 @@ struct QueryTreeSettings
     std::unordered_map<std::string, std::reference_wrapper<bool>> boolean_settings =
     {
         {"run_passes", run_passes},
+        {"dump_tree", dump_tree},
         {"dump_passes", dump_passes},
         {"dump_ast", dump_ast}
     };
@@ -398,7 +401,11 @@ QueryPipeline InterpreterExplainQuery::executeImpl()
                 throw Exception(ErrorCodes::INCORRECT_QUERY, "Only SELECT is supported for EXPLAIN QUERY TREE query");
 
             auto settings = checkAndGetSettings<QueryTreeSettings>(ast.getSettings());
+            if (!settings.dump_tree && !settings.dump_ast)
+                throw Exception(ErrorCodes::BAD_ARGUMENTS, "Either 'dump_tree' or 'dump_ast' must be set for EXPLAIN QUERY TREE query");
+
             auto query_tree = buildQueryTree(ast.getExplainedQuery(), getContext());
+            bool need_newline = false;
 
             if (settings.run_passes)
             {
@@ -410,23 +417,26 @@ QueryPipeline InterpreterExplainQuery::executeImpl()
                 if (settings.dump_passes)
                 {
                     query_tree_pass_manager.dump(buf, pass_index);
-                    if (pass_index > 0)
-                        buf << '
';
+                    need_newline = true;
                 }
 
                 query_tree_pass_manager.run(query_tree, pass_index);
-
-                query_tree->dumpTree(buf);
             }
-            else
+
+            if (settings.dump_tree)
             {
+                if (need_newline)
+                    buf << "

";
+
                 query_tree->dumpTree(buf);
+                need_newline = true;
             }
 
             if (settings.dump_ast)
             {
-                buf << '
';
-                buf << '
';
+                if (need_newline)
+                    buf << "

";
+
                 query_tree->toAST()->format(IAST::FormatSettings(buf, false));
             }
 
diff --git a/src/Interpreters/RewriteFunctionToSubcolumnVisitor.cpp b/src/Interpreters/RewriteFunctionToSubcolumnVisitor.cpp
deleted file mode 100644
index f02021997529..000000000000
--- a/src/Interpreters/RewriteFunctionToSubcolumnVisitor.cpp
+++ /dev/null
@@ -1,157 +0,0 @@
-#include <DataTypes/DataTypeTuple.h>
-#include <DataTypes/NestedUtils.h>
-#include <Interpreters/RewriteFunctionToSubcolumnVisitor.h>
-#include <Parsers/ASTFunction.h>
-#include <Parsers/ASTIdentifier.h>
-#include <Parsers/ASTLiteral.h>
-#include <Common/assert_cast.h>
-
-namespace DB
-{
-
-namespace
-{
-
-ASTPtr transformToSubcolumn(const String & name_in_storage, const String & subcolumn_name)
-{
-    return std::make_shared<ASTIdentifier>(Nested::concatenateName(name_in_storage, subcolumn_name));
-}
-
-ASTPtr transformEmptyToSubcolumn(const String & name_in_storage, const String & subcolumn_name)
-{
-    auto ast = transformToSubcolumn(name_in_storage, subcolumn_name);
-    return makeASTFunction("equals", ast, std::make_shared<ASTLiteral>(0u));
-}
-
-ASTPtr transformNotEmptyToSubcolumn(const String & name_in_storage, const String & subcolumn_name)
-{
-    auto ast = transformToSubcolumn(name_in_storage, subcolumn_name);
-    return makeASTFunction("notEquals", ast, std::make_shared<ASTLiteral>(0u));
-}
-
-ASTPtr transformIsNotNullToSubcolumn(const String & name_in_storage, const String & subcolumn_name)
-{
-    auto ast = transformToSubcolumn(name_in_storage, subcolumn_name);
-    return makeASTFunction("not", ast);
-}
-
-ASTPtr transformCountNullableToSubcolumn(const String & name_in_storage, const String & subcolumn_name)
-{
-    auto ast = transformToSubcolumn(name_in_storage, subcolumn_name);
-    return makeASTFunction("sum", makeASTFunction("not", ast));
-}
-
-ASTPtr transformMapContainsToSubcolumn(const String & name_in_storage, const String & subcolumn_name, const ASTPtr & arg)
-{
-    auto ast = transformToSubcolumn(name_in_storage, subcolumn_name);
-    return makeASTFunction("has", ast, arg);
-}
-
-const std::unordered_map<String, std::tuple<TypeIndex, String, decltype(&transformToSubcolumn)>> unary_function_to_subcolumn =
-{
-    {"length",    {TypeIndex::Array, "size0", transformToSubcolumn}},
-    {"empty",     {TypeIndex::Array, "size0", transformEmptyToSubcolumn}},
-    {"notEmpty",  {TypeIndex::Array, "size0", transformNotEmptyToSubcolumn}},
-    {"isNull",    {TypeIndex::Nullable, "null", transformToSubcolumn}},
-    {"isNotNull", {TypeIndex::Nullable, "null", transformIsNotNullToSubcolumn}},
-    {"count",     {TypeIndex::Nullable, "null", transformCountNullableToSubcolumn}},
-    {"mapKeys",   {TypeIndex::Map, "keys", transformToSubcolumn}},
-    {"mapValues", {TypeIndex::Map, "values", transformToSubcolumn}},
-};
-
-const std::unordered_map<String, std::tuple<TypeIndex, String, decltype(&transformMapContainsToSubcolumn)>> binary_function_to_subcolumn
-{
-    {"mapContains", {TypeIndex::Map, "keys", transformMapContainsToSubcolumn}},
-};
-
-}
-
-void RewriteFunctionToSubcolumnData::visit(ASTFunction & function, ASTPtr & ast) const
-{
-    const auto & arguments = function.arguments->children;
-    if (arguments.empty() || arguments.size() > 2)
-        return;
-
-    const auto * identifier = arguments[0]->as<ASTIdentifier>();
-    if (!identifier)
-        return;
-
-    const auto & columns = metadata_snapshot->getColumns();
-    const auto & name_in_storage = identifier->name();
-
-    if (!columns.has(name_in_storage))
-        return;
-
-    const auto & column_type = columns.get(name_in_storage).type;
-    TypeIndex column_type_id = column_type->getTypeId();
-    const auto & alias = function.tryGetAlias();
-
-    if (arguments.size() == 1)
-    {
-        auto it = unary_function_to_subcolumn.find(function.name);
-        if (it != unary_function_to_subcolumn.end())
-        {
-            const auto & [type_id, subcolumn_name, transformer] = it->second;
-            if (column_type_id == type_id)
-            {
-                ast = transformer(name_in_storage, subcolumn_name);
-                ast->setAlias(alias);
-            }
-        }
-    }
-    else
-    {
-        if (function.name == "tupleElement" && column_type_id == TypeIndex::Tuple)
-        {
-            const auto * literal = arguments[1]->as<ASTLiteral>();
-            if (!literal)
-                return;
-
-            String subcolumn_name;
-            auto value_type = literal->value.getType();
-            if (value_type == Field::Types::UInt64)
-            {
-                const auto & type_tuple = assert_cast<const DataTypeTuple &>(*column_type);
-                auto index = literal->value.get<UInt64>();
-                subcolumn_name = type_tuple.getNameByPosition(index);
-            }
-            else if (value_type == Field::Types::String)
-                subcolumn_name = literal->value.get<const String &>();
-            else
-                return;
-
-            ast = transformToSubcolumn(name_in_storage, subcolumn_name);
-            ast->setAlias(alias);
-        }
-        else if (function.name == "variantElement" && column_type_id == TypeIndex::Variant)
-        {
-            const auto * literal = arguments[1]->as<ASTLiteral>();
-            if (!literal)
-                return;
-
-            String subcolumn_name;
-            auto value_type = literal->value.getType();
-            if (value_type != Field::Types::String)
-                return;
-
-            subcolumn_name = literal->value.get<const String &>();
-            ast = transformToSubcolumn(name_in_storage, subcolumn_name);
-            ast->setAlias(alias);
-        }
-        else
-        {
-            auto it = binary_function_to_subcolumn.find(function.name);
-            if (it != binary_function_to_subcolumn.end())
-            {
-                const auto & [type_id, subcolumn_name, transformer] = it->second;
-                if (column_type_id == type_id)
-                {
-                    ast = transformer(name_in_storage, subcolumn_name, arguments[1]);
-                    ast->setAlias(alias);
-                }
-            }
-        }
-    }
-}
-
-}
diff --git a/src/Interpreters/RewriteFunctionToSubcolumnVisitor.h b/src/Interpreters/RewriteFunctionToSubcolumnVisitor.h
deleted file mode 100644
index 4d064bdee101..000000000000
--- a/src/Interpreters/RewriteFunctionToSubcolumnVisitor.h
+++ /dev/null
@@ -1,25 +0,0 @@
-#pragma once
-
-#include <Interpreters/InDepthNodeVisitor.h>
-#include <Storages/StorageInMemoryMetadata.h>
-
-namespace DB
-{
-
-class ASTFunction;
-
-/// Rewrites functions to subcolumns, if possible, to reduce amount of read data.
-/// E.g. 'length(arr)' -> 'arr.size0', 'col IS NULL' -> 'col.null'
-class RewriteFunctionToSubcolumnData
-{
-public:
-    using TypeToVisit = ASTFunction;
-    void visit(ASTFunction & function, ASTPtr & ast) const;
-
-    StorageMetadataPtr metadata_snapshot;
-};
-
-using RewriteFunctionToSubcolumnMatcher = OneTypeMatcher<RewriteFunctionToSubcolumnData>;
-using RewriteFunctionToSubcolumnVisitor = InDepthNodeVisitor<RewriteFunctionToSubcolumnMatcher, true>;
-
-}
diff --git a/src/Interpreters/TreeOptimizer.cpp b/src/Interpreters/TreeOptimizer.cpp
index c331c8640d60..b88d75cd5a28 100644
--- a/src/Interpreters/TreeOptimizer.cpp
+++ b/src/Interpreters/TreeOptimizer.cpp
@@ -17,7 +17,6 @@
 #include <Interpreters/RewriteCountVariantsVisitor.h>
 #include <Interpreters/ConvertStringsToEnumVisitor.h>
 #include <Interpreters/ConvertFunctionOrLikeVisitor.h>
-#include <Interpreters/RewriteFunctionToSubcolumnVisitor.h>
 #include <Interpreters/Context.h>
 #include <Interpreters/ExternalDictionariesLoader.h>
 #include <Interpreters/GatherFunctionQuantileVisitor.h>
@@ -564,12 +563,6 @@ void transformIfStringsIntoEnum(ASTPtr & query)
     ConvertStringsToEnumVisitor(convert_data).visit(query);
 }
 
-void optimizeFunctionsToSubcolumns(ASTPtr & query, const StorageMetadataPtr & metadata_snapshot)
-{
-    RewriteFunctionToSubcolumnVisitor::Data data{metadata_snapshot};
-    RewriteFunctionToSubcolumnVisitor(data).visit(query);
-}
-
 void optimizeOrLikeChain(ASTPtr & query)
 {
     ConvertFunctionOrLikeVisitor::Data data = {};
@@ -634,9 +627,6 @@ void TreeOptimizer::apply(ASTPtr & query, TreeRewriterResult & result,
     if (!select_query)
         throw Exception(ErrorCodes::LOGICAL_ERROR, "Select analyze for not select asts.");
 
-    if (settings.optimize_functions_to_subcolumns && result.storage_snapshot && result.storage->supportsSubcolumns())
-        optimizeFunctionsToSubcolumns(query, result.storage_snapshot->metadata);
-
     /// Move arithmetic operations out of aggregation functions
     if (settings.optimize_arithmetic_operations_in_aggregate_functions)
         optimizeAggregationFunctions(query);
diff --git a/src/Storages/IStorage.h b/src/Storages/IStorage.h
index 98afd844046f..6217470780dd 100644
--- a/src/Storages/IStorage.h
+++ b/src/Storages/IStorage.h
@@ -165,6 +165,8 @@ class IStorage : public std::enable_shared_from_this<IStorage>, public TypePromo
 
     /// Returns true if the storage supports reading of subcolumns of complex types.
     virtual bool supportsSubcolumns() const { return false; }
+    /// Returns true if storage supports optimizations of functions by reading subcolumns.
+    virtual bool supportsOptimizationToSubcolumns() const { return supportsSubcolumns(); }
 
     /// Returns true if the storage supports transactions for SELECT, INSERT and ALTER queries.
     /// Storage may throw an exception later if some query kind is not fully supported.
diff --git a/src/Storages/IStorageCluster.h b/src/Storages/IStorageCluster.h
index f32832476726..893cf222556f 100644
--- a/src/Storages/IStorageCluster.h
+++ b/src/Storages/IStorageCluster.h
@@ -37,7 +37,10 @@ class IStorageCluster : public IStorage
 
     QueryProcessingStage::Enum getQueryProcessingStage(ContextPtr, QueryProcessingStage::Enum, const StorageSnapshotPtr &, SelectQueryInfo &) const override;
 
-    bool isRemote() const override { return true; }
+    bool isRemote() const final { return true; }
+    bool supportsSubcolumns() const override  { return true; }
+    bool supportsOptimizationToSubcolumns() const override { return false; }
+    bool supportsTrivialCountOptimization(const StorageSnapshotPtr &, ContextPtr) const override { return true; }
 
 protected:
     virtual void updateBeforeRead(const ContextPtr &) {}
diff --git a/src/Storages/ObjectStorage/StorageObjectStorageCluster.h b/src/Storages/ObjectStorage/StorageObjectStorageCluster.h
index 69fec2b3c77d..108aa1096161 100644
--- a/src/Storages/ObjectStorage/StorageObjectStorageCluster.h
+++ b/src/Storages/ObjectStorage/StorageObjectStorageCluster.h
@@ -24,12 +24,6 @@ class StorageObjectStorageCluster : public IStorageCluster
 
     std::string getName() const override;
 
-    bool supportsSubcolumns() const override { return true; }
-
-    bool supportsDynamicSubcolumns() const override { return true; }
-
-    bool supportsTrivialCountOptimization(const StorageSnapshotPtr &, ContextPtr) const override { return true; }
-
     RemoteQueryExecutor::Extension getTaskIteratorExtension(
         const ActionsDAG::Node * predicate, const ContextPtr & context) const override;
 
diff --git a/src/Storages/ObjectStorageQueue/StorageObjectStorageQueue.h b/src/Storages/ObjectStorageQueue/StorageObjectStorageQueue.h
index 758721674fe3..fc459c45f740 100644
--- a/src/Storages/ObjectStorageQueue/StorageObjectStorageQueue.h
+++ b/src/Storages/ObjectStorageQueue/StorageObjectStorageQueue.h
@@ -79,6 +79,7 @@ class StorageObjectStorageQueue : public IStorage, WithContext
     void drop() override;
     bool supportsSubsetOfColumns(const ContextPtr & context_) const;
     bool supportsSubcolumns() const override { return true; }
+    bool supportsOptimizationToSubcolumns() const override { return false; }
     bool supportsDynamicSubcolumns() const override { return true; }
 
     std::shared_ptr<FileIterator> createFileIterator(ContextPtr local_context, const ActionsDAG::Node * predicate);
diff --git a/src/Storages/StorageFile.h b/src/Storages/StorageFile.h
index ac094aeb4896..f955889185ce 100644
--- a/src/Storages/StorageFile.h
+++ b/src/Storages/StorageFile.h
@@ -89,6 +89,7 @@ class StorageFile final : public IStorage
     bool supportsSubsetOfColumns(const ContextPtr & context) const;
 
     bool supportsSubcolumns() const override { return true; }
+    bool supportsOptimizationToSubcolumns() const override { return false; }
 
     bool supportsDynamicSubcolumns() const override { return true; }
 
diff --git a/src/Storages/StorageFileCluster.h b/src/Storages/StorageFileCluster.h
index f5a4362901e8..9549f3a035c3 100644
--- a/src/Storages/StorageFileCluster.h
+++ b/src/Storages/StorageFileCluster.h
@@ -27,15 +27,8 @@ class StorageFileCluster : public IStorageCluster
         const ConstraintsDescription & constraints_);
 
     std::string getName() const override { return "FileCluster"; }
-
     RemoteQueryExecutor::Extension getTaskIteratorExtension(const ActionsDAG::Node * predicate, const ContextPtr & context) const override;
 
-    bool supportsSubcolumns() const override { return true; }
-
-    bool supportsDynamicSubcolumns() const override { return true; }
-
-    bool supportsTrivialCountOptimization(const StorageSnapshotPtr &, ContextPtr) const override { return true; }
-
 private:
     void updateQueryToSendIfNeeded(ASTPtr & query, const StorageSnapshotPtr & storage_snapshot, const ContextPtr & context) override;
 
diff --git a/src/Storages/StorageURL.h b/src/Storages/StorageURL.h
index 3090f8db12e8..fa7cc6eeeefb 100644
--- a/src/Storages/StorageURL.h
+++ b/src/Storages/StorageURL.h
@@ -296,6 +296,7 @@ class StorageURL : public IStorageURLBase
     }
 
     bool supportsSubcolumns() const override { return true; }
+    bool supportsOptimizationToSubcolumns() const override { return false; }
 
     bool supportsDynamicSubcolumns() const override { return true; }
 
diff --git a/src/Storages/StorageURLCluster.h b/src/Storages/StorageURLCluster.h
index a6334e7430d7..31bffa062104 100644
--- a/src/Storages/StorageURLCluster.h
+++ b/src/Storages/StorageURLCluster.h
@@ -30,15 +30,8 @@ class StorageURLCluster : public IStorageCluster
         const StorageURL::Configuration & configuration_);
 
     std::string getName() const override { return "URLCluster"; }
-
     RemoteQueryExecutor::Extension getTaskIteratorExtension(const ActionsDAG::Node * predicate, const ContextPtr & context) const override;
 
-    bool supportsSubcolumns() const override { return true; }
-
-    bool supportsDynamicSubcolumns() const override { return true; }
-
-    bool supportsTrivialCountOptimization(const StorageSnapshotPtr &, ContextPtr) const override { return true; }
-
 private:
     void updateQueryToSendIfNeeded(ASTPtr & query, const StorageSnapshotPtr & storage_snapshot, const ContextPtr & context) override;
 
