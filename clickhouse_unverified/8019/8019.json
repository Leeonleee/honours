{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 8019,
  "instance_id": "ClickHouse__ClickHouse-8019",
  "issue_numbers": [
    "7082"
  ],
  "base_commit": "fa71bc7e875f84dc0cf5bab6fa49e207b97c3cd2",
  "patch": "diff --git a/dbms/src/Compression/CompressionCodecDoubleDelta.cpp b/dbms/src/Compression/CompressionCodecDoubleDelta.cpp\nindex 17eeba9a152f..dc4a5084c83e 100644\n--- a/dbms/src/Compression/CompressionCodecDoubleDelta.cpp\n+++ b/dbms/src/Compression/CompressionCodecDoubleDelta.cpp\n@@ -26,7 +26,7 @@ extern const int CANNOT_DECOMPRESS;\n namespace\n {\n \n-Int64 getMaxValueForByteSize(UInt8 byte_size)\n+inline Int64 getMaxValueForByteSize(Int8 byte_size)\n {\n     switch (byte_size)\n     {\n@@ -51,11 +51,56 @@ struct WriteSpec\n     const UInt8 data_bits;\n };\n \n-const std::array<UInt8, 5> DELTA_SIZES{7, 9, 12, 32, 64};\n+// delta size prefix and data lengths based on few high bits peeked from binary stream\n+static const WriteSpec WRITE_SPEC_LUT[32] = {\n+    // 0b0 - 1-bit prefix, no data to read\n+    /* 00000 */ {1, 0b0, 0},\n+    /* 00001 */ {1, 0b0, 0},\n+    /* 00010 */ {1, 0b0, 0},\n+    /* 00011 */ {1, 0b0, 0},\n+    /* 00100 */ {1, 0b0, 0},\n+    /* 00101 */ {1, 0b0, 0},\n+    /* 00110 */ {1, 0b0, 0},\n+    /* 00111 */ {1, 0b0, 0},\n+    /* 01000 */ {1, 0b0, 0},\n+    /* 01001 */ {1, 0b0, 0},\n+    /* 01010 */ {1, 0b0, 0},\n+    /* 01011 */ {1, 0b0, 0},\n+    /* 01100 */ {1, 0b0, 0},\n+    /* 01101 */ {1, 0b0, 0},\n+    /* 01110 */ {1, 0b0, 0},\n+    /* 01111 */ {1, 0b0, 0},\n+\n+    // 0b10 - 2 bit prefix, 7 bits of data\n+    /* 10000 */ {2, 0b10, 7},\n+    /* 10001 */ {2, 0b10, 7},\n+    /* 10010 */ {2, 0b10, 7},\n+    /* 10011 */ {2, 0b10, 7},\n+    /* 10100 */ {2, 0b10, 7},\n+    /* 10101 */ {2, 0b10, 7},\n+    /* 10110 */ {2, 0b10, 7},\n+    /* 10111 */ {2, 0b10, 7},\n+\n+    // 0b110 - 3 bit prefix, 9 bits of data\n+    /* 11000 */ {3, 0b110, 9},\n+    /* 11001 */ {3, 0b110, 9},\n+    /* 11010 */ {3, 0b110, 9},\n+    /* 11011 */ {3, 0b110, 9},\n+\n+    // 0b1110 - 4 bit prefix, 12 bits of data\n+    /* 11100 */ {4, 0b1110, 12},\n+    /* 11101 */ {4, 0b1110, 12},\n+\n+    // 5-bit prefixes\n+    /* 11110 */ {5, 0b11110, 32},\n+    /* 11111 */ {5, 0b11111, 64},\n+};\n+\n \n template <typename T>\n WriteSpec getDeltaWriteSpec(const T & value)\n {\n+    // TODO: to speed up things a bit by counting number of leading zeroes instead of doing lots of comparisons\n     if (value > -63 && value < 64)\n     {\n         return WriteSpec{2, 0b10, 7};\n@@ -107,14 +152,15 @@ UInt32 getCompressedDataSize(UInt8 data_bytes_size, UInt32 uncompressed_size)\n template <typename ValueType>\n UInt32 compressDataForType(const char * source, UInt32 source_size, char * dest)\n {\n-    // Since only unsinged int has granted 2-compliment overflow handling, we are doing math here on unsigned types.\n-    // To simplify and booletproof code, we operate enforce ValueType to be unsigned too.\n+    // Since only unsinged int has granted 2-complement overflow handling,\n+    // we are doing math here only on unsigned types.\n+    // To simplify and booletproof code, we enforce ValueType to be unsigned too.\n     static_assert(is_unsigned_v<ValueType>, \"ValueType must be unsigned.\");\n     using UnsignedDeltaType = ValueType;\n \n     // We use signed delta type to turn huge unsigned values into smaller signed:\n     // ffffffff => -1\n-    using SignedDeltaType = typename std::make_signed<UnsignedDeltaType>::type;\n+    using SignedDeltaType = typename std::make_signed_t<UnsignedDeltaType>;\n \n     if (source_size % sizeof(ValueType) != 0)\n         throw Exception(\"Cannot compress, data size \" + toString(source_size)\n@@ -149,8 +195,7 @@ UInt32 compressDataForType(const char * source, UInt32 source_size, char * dest)\n         prev_value = curr_value;\n     }\n \n-    WriteBuffer buffer(dest, getCompressedDataSize(sizeof(ValueType), source_size - sizeof(ValueType)*2));\n-    BitWriter writer(buffer);\n+    BitWriter writer(dest, getCompressedDataSize(sizeof(ValueType), source_size - sizeof(ValueType)*2));\n \n     int item = 2;\n     for (; source < source_end; source += sizeof(ValueType), ++item)\n@@ -170,7 +215,8 @@ UInt32 compressDataForType(const char * source, UInt32 source_size, char * dest)\n         else\n         {\n             const SignedDeltaType signed_dd = static_cast<SignedDeltaType>(double_delta);\n-            const auto sign = std::signbit(signed_dd);\n+            const auto sign = signed_dd < 0;\n+\n             // -1 shirnks dd down to fit into number of bits, and there can't be 0, so it is OK.\n             const auto abs_value = static_cast<UnsignedDeltaType>(std::abs(signed_dd) - 1);\n             const auto write_spec = getDeltaWriteSpec(signed_dd);\n@@ -183,7 +229,7 @@ UInt32 compressDataForType(const char * source, UInt32 source_size, char * dest)\n \n     writer.flush();\n \n-    return sizeof(items_count) + sizeof(prev_value) + sizeof(prev_delta) + buffer.count();\n+    return sizeof(items_count) + sizeof(prev_value) + sizeof(prev_delta) + writer.count() / 8;\n }\n \n template <typename ValueType>\n@@ -220,35 +266,28 @@ void decompressDataForType(const char * source, UInt32 source_size, char * dest)\n         dest += sizeof(prev_value);\n     }\n \n-    ReadBufferFromMemory buffer(source, source_size - sizeof(prev_value) - sizeof(prev_delta) - sizeof(items_count));\n-    BitReader reader(buffer);\n+    BitReader reader(source, source_size - sizeof(prev_value) - sizeof(prev_delta) - sizeof(items_count));\n \n     // since data is tightly packed, up to 1 bit per value, and last byte is padded with zeroes,\n     // we have to keep track of items to avoid reading more that there is.\n     for (UInt32 items_read = 2; items_read < items_count && !reader.eof(); ++items_read)\n     {\n         UnsignedDeltaType double_delta = 0;\n-        if (reader.readBit() == 1)\n-        {\n-            UInt8 i = 0;\n-            for (; i < sizeof(DELTA_SIZES) - 1; ++i)\n-            {\n-                const auto next_bit = reader.readBit();\n-                if (next_bit == 0)\n-                {\n-                    break;\n-                }\n-            }\n \n+        static_assert(sizeof(WRITE_SPEC_LUT)/sizeof(WRITE_SPEC_LUT[0]) == 32); // 5-bit prefix lookup table\n+        const auto write_spec = WRITE_SPEC_LUT[reader.peekByte() >> (8 - 5)]; // only 5 high bits of peeked byte value\n+\n+        reader.skipBufferedBits(write_spec.prefix_bits); // discard the prefix value, since we've already used it\n+        if (write_spec.data_bits != 0)\n+        {\n             const UInt8 sign = reader.readBit();\n-            SignedDeltaType signed_dd = static_cast<SignedDeltaType>(reader.readBits(DELTA_SIZES[i] - 1) + 1);\n+            SignedDeltaType signed_dd = static_cast<SignedDeltaType>(reader.readBits(write_spec.data_bits - 1) + 1);\n             if (sign)\n             {\n                 signed_dd *= -1;\n             }\n             double_delta = static_cast<UnsignedDeltaType>(signed_dd);\n         }\n-        // else if first bit is zero, no need to read more data.\n \n         const UnsignedDeltaType delta = double_delta + prev_delta;\n         const ValueType curr_value = prev_value + delta;\ndiff --git a/dbms/src/Compression/CompressionCodecDoubleDelta.h b/dbms/src/Compression/CompressionCodecDoubleDelta.h\nindex 19c072141155..6e2e3cdc89e3 100644\n--- a/dbms/src/Compression/CompressionCodecDoubleDelta.h\n+++ b/dbms/src/Compression/CompressionCodecDoubleDelta.h\n@@ -5,6 +5,92 @@\n namespace DB\n {\n \n+/** DoubleDelta column codec implementation.\n+ *\n+ * Based on Gorilla paper: http://www.vldb.org/pvldb/vol8/p1816-teller.pdf, which was extended\n+ * to support 64bit types. The drawback is 1 extra bit for 32-byte wide deltas: 5-bit prefix\n+ * instead of 4-bit prefix.\n+ *\n+ * This codec is best used against monotonic integer sequences with constant (or almost contant)\n+ * stride, like event timestamp for some monitoring application.\n+ *\n+ * Given input sequence a: [a0, a1, ... an]:\n+ *\n+ * First, write number of items (sizeof(int32)*8 bits):                n\n+ * Then write first item as is (sizeof(a[0])*8 bits):                  a[0]\n+ * Second item is written as delta (sizeof(a[0])*8 bits):              a[1] - a[0]\n+ * Loop over remaining items and calculate double delta:\n+ *   double_delta = a[i] - 2 * a[i - 1] + a[i - 2]\n+ *   Write it in compact binary form with `BitWriter`\n+ *   if double_delta == 0:\n+ *      write 1bit:                                                    0\n+ *   else if -63 < double_delta < 64:\n+ *      write 2 bit prefix:                                            10\n+ *      write sign bit (1 if signed):                                  x\n+ *      write 7-1 bits of abs(double_delta - 1):                       xxxxxx\n+ *   else if -255 < double_delta < 256:\n+ *      write 3 bit prefix:                                            110\n+ *      write sign bit (1 if signed):                                  x\n+ *      write 9-1 bits of abs(double_delta - 1):                       xxxxxxxx\n+ *   else if -2047 < double_delta < 2048:\n+ *      write 4 bit prefix:                                            1110\n+ *      write sign bit (1 if signed):                                  x\n+ *      write 12-1 bits of abs(double_delta - 1):                      xxxxxxxxxxx\n+ *   else if double_delta fits into 32-bit int:\n+ *      write 5 bit prefix:                                            11110\n+ *      write sign bit (1 if signed):                                  x\n+ *      write 32-1 bits of abs(double_delta - 1):                      xxxxxxxxxxx...\n+ *   else\n+ *      write 5 bit prefix:                                            11111\n+ *      write sign bit (1 if signed):                                  x\n+ *      write 64-1 bits of abs(double_delta - 1):                      xxxxxxxxxxx...\n+ *\n+ * @example sequence of UInt8 values [1, 2, 3, 4, 5, 6, 7, 8, 9 10] is encoded as (codec header is ommited):\n+ *\n+ * .- 4-byte little-endian sequence length (10 == 0xa)\n+ * |               .- 1 byte (sizeof(UInt8) a[0]                                            : 0x01\n+ * |               |   .- 1 byte of delta: a[1] - a[0] = 2 - 1 = 1                          : 0x01\n+ * |               |   |   .- 8 zero bits since double delta for remaining 8 elements was 0 : 0x00\n+ * v_______________v___v___v___\n+ * \\x0a\\x00\\x00\\x00\\x01\\x01\\x00\n+ *\n+ * @example sequence of Int16 values [-10, 10, -20, 20, -40, 40] is encoded as:\n+ *\n+ * .- 4-byte little endian sequence length = 6                                 : 0x00000006\n+ * |                .- 2 bytes (sizeof(Int16) a[0] as UInt16 = -10             : 0xfff6\n+ * |                |       .- 2 bytes of delta: a[1] - a[0] = 10 - (-10) = 20 : 0x0014\n+ * |                |       |       .- 4 encoded double deltas (see below)\n+ * v_______________ v______ v______ v______________________\n+ * \\x06\\x00\\x00\\x00\\xf6\\xff\\x14\\x00\\xb8\\xe2\\x2e\\xb1\\xe4\\x58\n+ *\n+ * 4 binary encoded double deltas (\\xb8\\xe2\\x2e\\xb1\\xe4\\x58):\n+ * double_delta (DD) = -20 - 2 * 10 + (-10) = -50\n+ * .- 2-bit prefix                                                         : 0b10\n+ * | .- sign-bit                                                           : 0b1\n+ * | |.- abs(DD - 1) = 49                                                  : 0b110001\n+ * | ||\n+ * | ||      DD = 20 - 2 * (-20) + 10 = 70\n+ * | ||      .- 3-bit prefix                                               : 0b110\n+ * | ||      |  .- sign bit                                                : 0b0\n+ * | ||      |  |.- abs(DD - 1) = 69                                       : 0b1000101\n+ * | ||      |  ||\n+ * | ||      |  ||        DD = -40 - 2 * 20 + (-20) = -100\n+ * | ||      |  ||        .- 3-bit prefix                                  : 0b110\n+ * | ||      |  ||        |    .- sign-bit                                 : 0b0\n+ * | ||      |  ||        |    |.- abs(DD - 1) = 99                        : 0b1100011\n+ * | ||      |  ||        |    ||\n+ * | ||      |  ||        |    ||       DD = 40 - 2 * (-40) + 20 = 140\n+ * | ||      |  ||        |    ||       .- 3-bit prefix                    : 0b110\n+ * | ||      |  ||        |    ||       |  .- sign bit                     : 0b0\n+ * | ||      |  ||        |    ||       |  |.- abs(DD - 1) = 139           : 0b10001011\n+ * | ||      |  ||        |    ||       |  ||\n+ * V_vv______V__vv________V____vv_______V__vv________,- padding bits\n+ * 10111000 11100010 00101110 10110001 11100100 01011000\n+ *\n+ * Please also see unit tests for:\n+ *   * Examples on what output `BitWriter` produces on predefined input.\n+ *   * Compatibility tests solidifying encoded binary output on set of predefined sequences.\n+ */\n class CompressionCodecDoubleDelta : public ICompressionCodec\n {\n public:\ndiff --git a/dbms/src/Compression/CompressionCodecGorilla.cpp b/dbms/src/Compression/CompressionCodecGorilla.cpp\nindex 574e40b06bf0..62e7a81aae95 100644\n--- a/dbms/src/Compression/CompressionCodecGorilla.cpp\n+++ b/dbms/src/Compression/CompressionCodecGorilla.cpp\n@@ -112,8 +112,7 @@ UInt32 compressDataForType(const char * source, UInt32 source_size, char * dest,\n         dest += sizeof(prev_value);\n     }\n \n-    WriteBuffer buffer(dest, dest_end - dest);\n-    BitWriter writer(buffer);\n+    BitWriter writer(dest, dest_end - dest);\n \n     while (source < source_end)\n     {\n@@ -148,7 +147,7 @@ UInt32 compressDataForType(const char * source, UInt32 source_size, char * dest,\n \n     writer.flush();\n \n-    return sizeof(items_count) + sizeof(prev_value) + buffer.count();\n+    return sizeof(items_count) + sizeof(prev_value) + writer.count() / 8;\n }\n \n template <typename T>\n@@ -174,8 +173,7 @@ void decompressDataForType(const char * source, UInt32 source_size, char * dest)\n         dest += sizeof(prev_value);\n     }\n \n-    ReadBufferFromMemory buffer(source, source_size - sizeof(items_count) - sizeof(prev_value));\n-    BitReader reader(buffer);\n+    BitReader reader(source, source_size - sizeof(items_count) - sizeof(prev_value));\n \n     binary_value_info prev_xored_info{0, 0, 0};\n \ndiff --git a/dbms/src/Compression/CompressionCodecGorilla.h b/dbms/src/Compression/CompressionCodecGorilla.h\nindex a3947434ad91..fee473cbe905 100644\n--- a/dbms/src/Compression/CompressionCodecGorilla.h\n+++ b/dbms/src/Compression/CompressionCodecGorilla.h\n@@ -5,6 +5,89 @@\n namespace DB\n {\n \n+/** Gorilla column codec implementation.\n+ *\n+ * Based on Gorilla paper: http://www.vldb.org/pvldb/vol8/p1816-teller.pdf\n+ *\n+ * This codec is best used against monotonic floating sequences, like CPU usage percentage\n+ * or any other gauge.\n+ *\n+ * Given input sequence a: [a0, a1, ... an]\n+ *\n+ * First, write number of items (sizeof(int32)*8 bits):                n\n+ * Then write first item as is (sizeof(a[0])*8 bits):                  a[0]\n+ * Loop over remaining items and calculate xor_diff:\n+ *   xor_diff = a[i] ^ a[i - 1] (e.g. 00000011'10110100)\n+ *   Write it in compact binary form with `BitWriter`\n+ *   if xor_diff == 0:\n+ *       write 1 bit:                                                  0\n+ *   else:\n+ *       calculate leading zero bits (lzb)\n+ *       and trailing zero bits (tzb) of xor_diff,\n+ *       compare to lzb and tzb of previous xor_diff\n+ *       (X = sizeof(a[i]) * 8, e.g. X = 16, lzb = 6, tzb = 2)\n+ *       if lzb >= prev_lzb && tzb >= prev_tzb:\n+ *           (e.g. prev_lzb=4, prev_tzb=1)\n+ *           write 2 bit prefix:                                       0b10\n+ *           write xor_diff >> prev_tzb (X - prev_lzb - prev_tzb bits):0b00111011010\n+ *           (where X = sizeof(a[i]) * 8, e.g. 16)\n+ *       else:\n+ *           write 2 bit prefix:                                       0b11\n+ *           write 5 bits of lzb:                                      0b00110\n+ *           write 6 bits of (X - lzb - tzb)=(16-6-2)=8:               0b001000\n+ *           write (X - lzb - tzb) non-zero bits of xor_diff:          0b11101101\n+ *           prev_lzb = lzb\n+ *           prev_tzb = tzb\n+ *\n+ * @example sequence of Float32 values [0.1, 0.1, 0.11, 0.2, 0.1] is encoded as:\n+ *\n+ * .- 4-byte little endian sequence length: 5                                 : 0x00000005\n+ * |                .- 4 byte (sizeof(Float32) a[0] as UInt32 : -10           : 0xcdcccc3d\n+ * |                |               .- 4 encoded xor diffs (see below)\n+ * v_______________ v______________ v__________________________________________________\n+ * \\x05\\x00\\x00\\x00\\xcd\\xcc\\xcc\\x3d\\x6a\\x5a\\xd8\\xb6\\x3c\\xcd\\x75\\xb1\\x6c\\x77\\x00\\x00\\x00\n+ *\n+ * 4 binary encoded xor diffs (\\x6a\\x5a\\xd8\\xb6\\x3c\\xcd\\x75\\xb1\\x6c\\x77\\x00\\x00\\x00):\n+ *\n+ * ...........................................\n+ * a[i-1]   = 00111101110011001100110011001101\n+ * a[i]     = 00111101110011001100110011001101\n+ * xor_diff = 00000000000000000000000000000000\n+ * .- 1-bit prefix                                                           : 0b0\n+ * |\n+ * | ...........................................\n+ * | a[i-1]   = 00111101110011001100110011001101\n+ * ! a[i]     = 00111101111000010100011110101110\n+ * | xor_diff = 00000000001011011000101101100011\n+ * | lzb = 10\n+ * | tzb = 0\n+ * |.- 2-bit prefix                                                          : 0b11\n+ * || .- lzb (10)                                                            : 0b1010\n+ * || |     .- data length (32-10-0): 22                                     : 0b010110\n+ * || |     |     .- data                                                    : 0b1011011000101101100011\n+ * || |     |     |\n+ * || |     |     |                        ...........................................\n+ * || |     |     |                        a[i-1]   = 00111101111000010100011110101110\n+ * || |     |     |                        a[i]     = 00111110010011001100110011001101\n+ * || |     |     |                        xor_diff = 00000011101011011000101101100011\n+ * || |     |     |                        .- 2-bit prefix                            : 0b11\n+ * || |     |     |                        | .- lzb = 6                               : 0b00110\n+ * || |     |     |                        | |     .- data length = (32 - 6) = 26     : 0b011010\n+ * || |     |     |                        | |     |      .- data                     : 0b11101011011000101101100011\n+ * || |     |     |                        | |     |      |\n+ * || |     |     |                        | |     |      |                            ...........................................\n+ * || |     |     |                        | |     |      |                            a[i-1]   = 00111110010011001100110011001101\n+ * || |     |     |                        | |     |      |                            a[i]     = 00111101110011001100110011001101\n+ * || |     |     |                        | |     |      |                            xor_diff = 00000011100000000000000000000000\n+ * || |     |     |                        | |     |      |                            .- 2-bit prefix                            : 0b10\n+ * || |     |     |                        | |     |      |                            | .- data                                  : 0b11100000000000000000000000\n+ * VV_v____ v_____v________________________V_v_____v______v____________________________V_v_____________________________\n+ * 01101010 01011010 11011000 10110110 00111100 11001101 01110101 10110001 01101100 01110111 00000000 00000000 00000000\n+ *\n+ * Please also see unit tests for:\n+ *   * Examples on what output `BitWriter` produces on predefined input.\n+ *   * Compatibility tests solidifying encoded binary output on set of predefined sequences.\n+ */\n class CompressionCodecGorilla : public ICompressionCodec\n {\n public:\ndiff --git a/dbms/src/IO/BitHelpers.h b/dbms/src/IO/BitHelpers.h\nindex 1947d9d99ba2..321fb4d254ee 100644\n--- a/dbms/src/IO/BitHelpers.h\n+++ b/dbms/src/IO/BitHelpers.h\n@@ -1,9 +1,10 @@\n #pragma once\n \n-#include <IO/ReadBuffer.h>\n-#include <IO/WriteBuffer.h>\n #include <Core/Types.h>\n #include <Common/BitHelpers.h>\n+#include <Common/Exception.h>\n+\n+#include <string.h>\n \n #if defined(__OpenBSD__) || defined(__FreeBSD__)\n #   include <sys/endian.h>\n@@ -14,9 +15,16 @@\n #   define be64toh(x) OSSwapBigToHostInt64(x)\n #endif\n \n+\n namespace DB\n {\n \n+namespace ErrorCodes\n+{\n+extern const int CANNOT_WRITE_AFTER_END_OF_BUFFER;\n+extern const int ATTEMPT_TO_READ_AFTER_EOF;\n+}\n+\n /** Reads data from underlying ReadBuffer bit by bit, max 64 bits at once.\n  *\n  * reads MSB bits first, imagine that you have a data:\n@@ -34,15 +42,20 @@ namespace DB\n \n class BitReader\n {\n-    ReadBuffer & buf;\n+    using BufferType = unsigned __int128;\n+\n+    const char * source_begin;\n+    const char * source_current;\n+    const char * source_end;\n \n-    UInt64 bits_buffer;\n+    BufferType bits_buffer;\n     UInt8 bits_count;\n-    static constexpr UInt8 BIT_BUFFER_SIZE = sizeof(bits_buffer) * 8;\n \n public:\n-    BitReader(ReadBuffer & buf_)\n-        : buf(buf_),\n+    BitReader(const char * begin, size_t size)\n+        : source_begin(begin),\n+          source_current(begin),\n+          source_end(begin + size),\n           bits_buffer(0),\n           bits_count(0)\n     {}\n@@ -50,44 +63,21 @@ class BitReader\n     ~BitReader()\n     {}\n \n-    inline UInt64 readBits(UInt8 bits)\n+    // reads bits_to_read high-bits from bits_buffer\n+    inline UInt64 readBits(UInt8 bits_to_read)\n     {\n-        UInt64 result = 0;\n-        bits = std::min(static_cast<UInt8>(sizeof(result) * 8), bits);\n+        if (bits_to_read > bits_count)\n+            fillBitBuffer();\n \n-        while (bits != 0)\n-        {\n-            if (bits_count == 0)\n-            {\n-                fillBuffer();\n-                if (bits_count == 0)\n-                {\n-                    // EOF.\n-                    break;\n-                }\n-            }\n-\n-            const auto to_read = std::min(bits, bits_count);\n-\n-            const UInt64 v = bits_buffer >> (bits_count - to_read);\n-            const UInt64 mask = maskLowBits<UInt64>(to_read);\n-            const UInt64 value = v & mask;\n-            result |= value;\n-\n-            // unset bits that were read\n-            bits_buffer &= ~(mask << (bits_count - to_read));\n-            bits_count -= to_read;\n-            bits -= to_read;\n-\n-            result <<= std::min(bits, BIT_BUFFER_SIZE);\n-        }\n-\n-        return result;\n+        return getBitsFromBitBuffer<CONSUME>(bits_to_read);\n     }\n \n-    inline UInt64 peekBits(UInt8 /*bits*/)\n+    inline UInt8 peekByte()\n     {\n-        return 0;\n+        if (bits_count < 8)\n+            fillBitBuffer();\n+\n+        return getBitsFromBitBuffer<PEEK>(8);\n     }\n \n     inline UInt8 readBit()\n@@ -95,34 +85,95 @@ class BitReader\n         return static_cast<UInt8>(readBits(1));\n     }\n \n+    // skip bits from bits_buffer\n+    inline void skipBufferedBits(UInt8 bits)\n+    {\n+        bits_buffer <<= bits;\n+        bits_count -= bits;\n+    }\n+\n+\n     inline bool eof() const\n     {\n-        return bits_count == 0 && buf.eof();\n+        return bits_count == 0 && source_current >= source_end;\n+    }\n+\n+    // number of bits that was already read by clients with readBits()\n+    inline UInt64 count() const\n+    {\n+        return (source_current - source_begin) * 8 - bits_count;\n+    }\n+\n+    inline UInt64 remaining() const\n+    {\n+        return (source_end - source_current) * 8 + bits_count;\n     }\n \n private:\n-    void fillBuffer()\n+    enum GetBitsMode {CONSUME, PEEK};\n+    // read data from internal buffer, if it has not enough bits, result is undefined.\n+    template <GetBitsMode mode>\n+    inline UInt64 getBitsFromBitBuffer(UInt8 bits_to_read)\n     {\n-        auto read = buf.read(reinterpret_cast<char *>(&bits_buffer), BIT_BUFFER_SIZE / 8);\n-        bits_buffer = be64toh(bits_buffer);\n-        bits_buffer >>= BIT_BUFFER_SIZE - read * 8;\n+        // push down the high-bits\n+        const UInt64 result = static_cast<UInt64>(bits_buffer >> (sizeof(bits_buffer) * 8 - bits_to_read));\n+\n+        if constexpr (mode == CONSUME)\n+        {\n+            // 'erase' high-bits that were have read\n+            skipBufferedBits(bits_to_read);\n+        }\n \n-        bits_count = static_cast<UInt8>(read) * 8;\n+        return result;\n+    }\n+\n+\n+    // Fills internal bits_buffer with data from source, reads at most 64 bits\n+    size_t fillBitBuffer()\n+    {\n+        const size_t available = source_end - source_current;\n+        const auto bytes_to_read = std::min<size_t>(64 / 8, available);\n+        if (available == 0)\n+        {\n+            if (bytes_to_read == 0)\n+                return 0;\n+\n+            throw Exception(\"Buffer is empty, but requested to read \"\n+                            + std::to_string(bytes_to_read) + \" more bytes.\",\n+                            ErrorCodes::ATTEMPT_TO_READ_AFTER_EOF);\n+        }\n+\n+        UInt64 tmp_buffer = 0;\n+        memcpy(&tmp_buffer, source_current, bytes_to_read);\n+        source_current += bytes_to_read;\n+\n+        tmp_buffer = be64toh(tmp_buffer);\n+\n+        bits_buffer |= BufferType(tmp_buffer) << ((sizeof(BufferType) - sizeof(tmp_buffer)) * 8 - bits_count);\n+        bits_count += static_cast<UInt8>(bytes_to_read) * 8;\n+\n+        return bytes_to_read;\n     }\n };\n \n class BitWriter\n {\n-    WriteBuffer & buf;\n+    using BufferType = unsigned __int128;\n \n-    UInt64 bits_buffer;\n+    char * dest_begin;\n+    char * dest_current;\n+    char * dest_end;\n+\n+    BufferType bits_buffer;\n     UInt8 bits_count;\n \n     static constexpr UInt8 BIT_BUFFER_SIZE = sizeof(bits_buffer) * 8;\n \n public:\n-    BitWriter(WriteBuffer & buf_)\n-        : buf(buf_),\n+    BitWriter(char * begin, size_t size)\n+        : dest_begin(begin),\n+          dest_current(begin),\n+          dest_end(begin + size),\n           bits_buffer(0),\n           bits_count(0)\n     {}\n@@ -132,54 +183,59 @@ class BitWriter\n         flush();\n     }\n \n-    inline void writeBits(UInt8 bits, UInt64 value)\n+    // write `bits_to_write` low-bits of `value` to the buffer\n+    inline void writeBits(UInt8 bits_to_write, UInt64 value)\n     {\n-        bits = std::min(static_cast<UInt8>(sizeof(value) * 8), bits);\n-\n-        while (bits > 0)\n+        UInt32 capacity = BIT_BUFFER_SIZE - bits_count;\n+        if (capacity < bits_to_write)\n         {\n-            auto v = value;\n-            auto to_write = bits;\n-\n-            const UInt8 capacity = BIT_BUFFER_SIZE - bits_count;\n-            if (capacity < bits)\n-            {\n-                v >>= bits - capacity;\n-                to_write = capacity;\n-            }\n-\n-            const UInt64 mask = maskLowBits<UInt64>(to_write);\n-            v &= mask;\n-\n-            bits_buffer <<= to_write;\n-            bits_buffer |= v;\n-            bits_count += to_write;\n-\n-            if (bits_count < BIT_BUFFER_SIZE)\n-                break;\n-\n             doFlush();\n-            bits -= to_write;\n+            capacity = BIT_BUFFER_SIZE - bits_count;\n         }\n+\n+//      write low bits of value as high bits of bits_buffer\n+        const UInt64 mask = maskLowBits<UInt64>(bits_to_write);\n+        BufferType v = value & mask;\n+        v <<= capacity - bits_to_write;\n+\n+        bits_buffer |= v;\n+        bits_count += bits_to_write;\n     }\n \n+    // flush contents of bits_buffer to the dest_current, partial bytes are completed with zeroes.\n     inline void flush()\n     {\n-        if (bits_count != 0)\n-        {\n-            bits_buffer <<= (BIT_BUFFER_SIZE - bits_count);\n+        bits_count = (bits_count + 8 - 1) & ~(8 - 1); // align UP to 8-bytes, so doFlush will write ALL data from bits_buffer\n+        while (bits_count != 0)\n             doFlush();\n-        }\n+    }\n+\n+    inline UInt64 count() const\n+    {\n+        return (dest_current - dest_begin) * 8 + bits_count;\n     }\n \n private:\n     void doFlush()\n     {\n-        bits_buffer = htobe64(bits_buffer);\n-        buf.write(reinterpret_cast<const char *>(&bits_buffer), (bits_count + 7) / 8);\n+        // write whole bytes to the dest_current, leaving partial bits in bits_buffer\n+        const size_t available = dest_end - dest_current;\n+        const size_t to_write = std::min<size_t>(sizeof(UInt64), bits_count / 8); // align to 8-bit boundary\n+\n+        if (available < to_write)\n+        {\n+            throw Exception(\"Can not write past end of buffer. Space available \"\n+                            + std::to_string(available) + \" bytes, required to write: \"\n+                            + std::to_string(to_write) + \".\",\n+                            ErrorCodes::CANNOT_WRITE_AFTER_END_OF_BUFFER);\n+        }\n+\n+        const auto tmp_buffer = htobe64(static_cast<UInt64>(bits_buffer >> (sizeof(bits_buffer) - sizeof(UInt64)) * 8));\n+        memcpy(dest_current, &tmp_buffer, to_write);\n+        dest_current += to_write;\n \n-        bits_count = 0;\n-        bits_buffer = 0;\n+        bits_buffer <<= to_write * 8;\n+        bits_count -= to_write * 8;\n     }\n };\n \n",
  "test_patch": "diff --git a/dbms/src/Compression/tests/gtest_compressionCodec.cpp b/dbms/src/Compression/tests/gtest_compressionCodec.cpp\nindex 32fff70d5647..95bef3b691e2 100644\n--- a/dbms/src/Compression/tests/gtest_compressionCodec.cpp\n+++ b/dbms/src/Compression/tests/gtest_compressionCodec.cpp\n@@ -1,6 +1,7 @@\n #include <Compression/CompressionFactory.h>\n \n #include <Common/PODArray.h>\n+#include <Common/Stopwatch.h>\n #include <Core/Types.h>\n #include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/IDataType.h>\n@@ -62,6 +63,32 @@ std::vector<T> operator+(std::vector<T> && left, std::vector<T> && right)\n namespace\n {\n \n+template <typename T>\n+struct AsHexStringHelper\n+{\n+    const T & container;\n+};\n+\n+template <typename T>\n+std::ostream & operator << (std::ostream & ostr, const AsHexStringHelper<T> & helper)\n+{\n+    ostr << std::hex;\n+    for (const auto & e : helper.container)\n+    {\n+        ostr << \"\\\\x\" << std::setw(2) << std::setfill('0') << (static_cast<unsigned int>(e) & 0xFF);\n+    }\n+\n+    return ostr;\n+}\n+\n+template <typename T>\n+AsHexStringHelper<T> AsHexString(const T & container)\n+{\n+    static_assert (sizeof(container[0]) == 1 && std::is_pod<std::decay_t<decltype(container[0])>>::value, \"Only works on containers of byte-size PODs.\");\n+\n+    return AsHexStringHelper<T>{container};\n+}\n+\n template <typename T>\n std::string bin(const T & value, size_t bits = sizeof(T)*8)\n {\n@@ -113,10 +140,71 @@ DataTypePtr makeDataType()\n \n #undef MAKE_DATA_TYPE\n \n-    assert(false && \"unsupported size\");\n+    assert(false && \"unknown datatype\");\n     return nullptr;\n }\n \n+template <typename T, typename Container>\n+class BinaryDataAsSequenceOfValuesIterator\n+{\n+    const Container & container;\n+    const void * data;\n+    const void * data_end;\n+\n+    T current_value;\n+\n+public:\n+    using Self = BinaryDataAsSequenceOfValuesIterator<T, Container>;\n+\n+    explicit BinaryDataAsSequenceOfValuesIterator(const Container & container_)\n+        : container(container_),\n+          data(&container[0]),\n+          data_end(reinterpret_cast<const char *>(data) + container.size()),\n+          current_value(T{})\n+    {\n+        static_assert(sizeof(container[0]) == 1 && std::is_pod<std::decay_t<decltype(container[0])>>::value, \"Only works on containers of byte-size PODs.\");\n+        read();\n+    }\n+\n+    const T & operator*() const\n+    {\n+        return current_value;\n+    }\n+\n+    size_t ItemsLeft() const\n+    {\n+        return reinterpret_cast<const char *>(data_end) - reinterpret_cast<const char *>(data);\n+    }\n+\n+    Self & operator++()\n+    {\n+        read();\n+        return *this;\n+    }\n+\n+    operator bool() const\n+    {\n+        return ItemsLeft() > 0;\n+    }\n+\n+private:\n+    void read()\n+    {\n+        if (!*this)\n+        {\n+            throw std::runtime_error(\"No more data to read\");\n+        }\n+\n+        current_value = unalignedLoad<T>(data);\n+        data = reinterpret_cast<const char *>(data) + sizeof(T);\n+    }\n+};\n+\n+template <typename T, typename Container>\n+BinaryDataAsSequenceOfValuesIterator<T, Container> AsSequenceOf(const Container & container)\n+{\n+    return BinaryDataAsSequenceOfValuesIterator<T, Container>(container);\n+}\n \n template <typename T, typename ContainerLeft, typename ContainerRight>\n ::testing::AssertionResult EqualByteContainersAs(const ContainerLeft & left, const ContainerRight & right)\n@@ -126,9 +214,6 @@ ::testing::AssertionResult EqualByteContainersAs(const ContainerLeft & left, con\n \n     ::testing::AssertionResult result = ::testing::AssertionSuccess();\n \n-    ReadBufferFromMemory left_read_buffer(left.data(), left.size());\n-    ReadBufferFromMemory right_read_buffer(right.data(), right.size());\n-\n     const auto l_size = left.size() / sizeof(T);\n     const auto r_size = right.size() / sizeof(T);\n     const auto size = std::min(l_size, r_size);\n@@ -137,16 +222,25 @@ ::testing::AssertionResult EqualByteContainersAs(const ContainerLeft & left, con\n     {\n         result = ::testing::AssertionFailure() << \"size mismatch\" << \" expected: \" << l_size << \" got:\" << r_size;\n     }\n+    if (l_size == 0 || r_size == 0)\n+    {\n+        return result;\n+    }\n+\n+    auto l = AsSequenceOf<T>(left);\n+    auto r = AsSequenceOf<T>(right);\n \n     const auto MAX_MISMATCHING_ITEMS = 5;\n     int mismatching_items = 0;\n-    for (int i = 0; i < size; ++i)\n-    {\n-        T left_value{};\n-        left_read_buffer.readStrict(reinterpret_cast<char*>(&left_value), sizeof(left_value));\n+    size_t i = 0;\n \n-        T right_value{};\n-        right_read_buffer.readStrict(reinterpret_cast<char*>(&right_value), sizeof(right_value));\n+    while (l && r)\n+    {\n+        const auto left_value = *l;\n+        const auto right_value = *r;\n+        ++l;\n+        ++r;\n+        ++i;\n \n         if (left_value != right_value)\n         {\n@@ -157,25 +251,47 @@ ::testing::AssertionResult EqualByteContainersAs(const ContainerLeft & left, con\n \n             if (++mismatching_items <= MAX_MISMATCHING_ITEMS)\n             {\n-                result << \"mismatching \" << sizeof(T) << \"-byte item #\" << i\n+                result << \"\\nmismatching \" << sizeof(T) << \"-byte item #\" << i\n                    << \"\\nexpected: \" << bin(left_value) << \" (0x\" << std::hex << left_value << \")\"\n-                   << \"\\ngot     : \" << bin(right_value) << \" (0x\" << std::hex << right_value << \")\"\n-                   << std::endl;\n+                   << \"\\ngot     : \" << bin(right_value) << \" (0x\" << std::hex << right_value << \")\";\n                 if (mismatching_items == MAX_MISMATCHING_ITEMS)\n                 {\n-                    result << \"...\" << std::endl;\n+                    result << \"\\n...\" << std::endl;\n                 }\n             }\n         }\n     }\n     if (mismatching_items > 0)\n     {\n-        result << \"\\ntotal mismatching items:\" << mismatching_items << \" of \" << size;\n+        result << \"total mismatching items:\" << mismatching_items << \" of \" << size;\n     }\n \n     return result;\n }\n \n+template <typename ContainerLeft, typename ContainerRight>\n+::testing::AssertionResult EqualByteContainers(UInt8 element_size, const ContainerLeft & left, const ContainerRight & right)\n+{\n+    switch (element_size)\n+    {\n+        case 1:\n+            return EqualByteContainersAs<UInt8>(left, right);\n+            break;\n+        case 2:\n+            return EqualByteContainersAs<UInt16>(left, right);\n+            break;\n+        case 4:\n+            return EqualByteContainersAs<UInt32>(left, right);\n+            break;\n+        case 8:\n+            return EqualByteContainersAs<UInt64>(left, right);\n+            break;\n+        default:\n+            assert(false && \"Invalid element_size\");\n+            return ::testing::AssertionFailure() << \"Invalid element_size: \" << element_size;\n+    }\n+}\n+\n struct Codec\n {\n     std::string codec_statement;\n@@ -214,20 +330,23 @@ struct CodecTestSequence\n     CodecTestSequence & operator=(const CodecTestSequence &) = default;\n     CodecTestSequence(CodecTestSequence &&) = default;\n     CodecTestSequence & operator=(CodecTestSequence &&) = default;\n-};\n \n-CodecTestSequence operator+(CodecTestSequence && left, CodecTestSequence && right)\n-{\n-    assert(left.data_type->equals(*right.data_type));\n+    CodecTestSequence & append(const CodecTestSequence & other)\n+    {\n+        assert(data_type->equals(*other.data_type));\n \n-    std::vector<char> data(std::move(left.serialized_data));\n-    data.insert(data.end(), right.serialized_data.begin(), right.serialized_data.end());\n+        serialized_data.insert(serialized_data.end(), other.serialized_data.begin(), other.serialized_data.end());\n+        if (!name.empty())\n+            name += \" + \";\n+        name += other.name;\n \n-    return CodecTestSequence{\n-        left.name + \" + \" + right.name,\n-        std::move(data),\n-        std::move(left.data_type)\n-    };\n+        return *this;\n+    }\n+};\n+\n+CodecTestSequence operator+(CodecTestSequence && left, const CodecTestSequence & right)\n+{\n+    return left.append(right);\n }\n \n template <typename T>\n@@ -288,17 +407,22 @@ CodecTestSequence makeSeq(Args && ... args)\n     };\n }\n \n-template <typename T, typename Generator>\n-CodecTestSequence generateSeq(Generator gen, const char* gen_name, size_t Begin = 0, size_t End = 10000)\n+template <typename T, typename Generator, typename B = int, typename E = int>\n+CodecTestSequence generateSeq(Generator gen, const char* gen_name, B Begin = 0, E End = 10000)\n {\n-    assert (End >= Begin);\n-\n+    const auto direction = std::signbit(End - Begin) ? -1 : 1;\n     std::vector<char> data(sizeof(T) * (End - Begin));\n     char * write_pos = data.data();\n \n-    for (size_t i = Begin; i < End; ++i)\n+    for (auto i = Begin; i < End; i += direction)\n     {\n         const T v = gen(static_cast<T>(i));\n+\n+//        if constexpr (debug_log_items)\n+//        {\n+//            std::cerr << \"#\" << i << \" \" << type_name<T>() << \"(\" << sizeof(T) << \" bytes) : \" << v << std::endl;\n+//        }\n+\n         unalignedStore<T>(write_pos, v);\n         write_pos += sizeof(v);\n     }\n@@ -310,6 +434,96 @@ CodecTestSequence generateSeq(Generator gen, const char* gen_name, size_t Begin\n     };\n }\n \n+struct NoOpTimer\n+{\n+    void start() {}\n+    void report(const char*) {}\n+};\n+\n+struct StopwatchTimer\n+{\n+    explicit StopwatchTimer(clockid_t clock_type, size_t estimated_marks = 32)\n+        : stopwatch(clock_type)\n+    {\n+        results.reserve(estimated_marks);\n+    }\n+\n+    void start()\n+    {\n+        stopwatch.restart();\n+    }\n+\n+    void report(const char * mark)\n+    {\n+        results.emplace_back(mark, stopwatch.elapsed());\n+    }\n+\n+    void stop()\n+    {\n+        stopwatch.stop();\n+    }\n+\n+    const std::vector<std::tuple<const char*, UInt64>> & getResults() const\n+    {\n+        return results;\n+    }\n+\n+private:\n+    Stopwatch stopwatch;\n+    std::vector<std::tuple<const char*, UInt64>> results;\n+};\n+\n+CompressionCodecPtr makeCodec(const std::string & codec_string, const DataTypePtr data_type)\n+{\n+    const std::string codec_statement = \"(\" + codec_string + \")\";\n+    Tokens tokens(codec_statement.begin().base(), codec_statement.end().base());\n+    IParser::Pos token_iterator(tokens);\n+\n+    Expected expected;\n+    ASTPtr codec_ast;\n+    ParserCodec parser;\n+\n+    parser.parse(token_iterator, codec_ast, expected);\n+\n+    return CompressionCodecFactory::instance().get(codec_ast, data_type);\n+}\n+\n+template <typename Timer>\n+void testTranscoding(Timer & timer, ICompressionCodec & codec, const CodecTestSequence & test_sequence, std::optional<double> expected_compression_ratio = std::optional<double>{})\n+{\n+    const auto & source_data = test_sequence.serialized_data;\n+\n+    const UInt32 encoded_max_size = codec.getCompressedReserveSize(source_data.size());\n+    PODArray<char> encoded(encoded_max_size);\n+\n+    timer.start();\n+\n+    const UInt32 encoded_size = codec.compress(source_data.data(), source_data.size(), encoded.data());\n+    timer.report(\"encoding\");\n+\n+    encoded.resize(encoded_size);\n+\n+    PODArray<char> decoded(source_data.size());\n+\n+    timer.start();\n+    const UInt32 decoded_size = codec.decompress(encoded.data(), encoded.size(), decoded.data());\n+    timer.report(\"decoding\");\n+\n+    decoded.resize(decoded_size);\n+\n+    ASSERT_TRUE(EqualByteContainers(test_sequence.data_type->getSizeOfValueInMemory(), source_data, decoded));\n+\n+    const auto header_size = codec.getHeaderSize();\n+    const auto compression_ratio = (encoded_size - header_size) / (source_data.size() * 1.0);\n+\n+    if (expected_compression_ratio)\n+    {\n+        ASSERT_LE(compression_ratio, *expected_compression_ratio)\n+                << \"\\n\\tdecoded size: \" << source_data.size()\n+                << \"\\n\\tencoded size: \" << encoded_size\n+                << \"(no header: \" << encoded_size - header_size << \")\";\n+    }\n+}\n \n class CodecTest : public ::testing::TestWithParam<std::tuple<Codec, CodecTestSequence>>\n {\n@@ -320,67 +534,18 @@ class CodecTest : public ::testing::TestWithParam<std::tuple<Codec, CodecTestSeq\n         CODEC_WITHOUT_DATA_TYPE,\n     };\n \n-    CompressionCodecPtr makeCodec(MakeCodecParam with_data_type) const\n+    CompressionCodecPtr makeCodec(MakeCodecParam with_data_type)\n     {\n         const auto & codec_string = std::get<0>(GetParam()).codec_statement;\n         const auto & data_type = with_data_type == CODEC_WITH_DATA_TYPE ? std::get<1>(GetParam()).data_type : nullptr;\n \n-        const std::string codec_statement = \"(\" + codec_string + \")\";\n-        Tokens tokens(codec_statement.begin().base(), codec_statement.end().base());\n-        IParser::Pos token_iterator(tokens);\n-\n-        Expected expected;\n-        ASTPtr codec_ast;\n-        ParserCodec parser;\n-\n-        parser.parse(token_iterator, codec_ast, expected);\n-\n-        return CompressionCodecFactory::instance().get(codec_ast, data_type);\n+        return ::makeCodec(codec_string, data_type);\n     }\n \n     void testTranscoding(ICompressionCodec & codec)\n     {\n-        const auto & test_sequence = std::get<1>(GetParam());\n-        const auto & source_data = test_sequence.serialized_data;\n-\n-        const UInt32 encoded_max_size = codec.getCompressedReserveSize(source_data.size());\n-        PODArray<char> encoded(encoded_max_size);\n-\n-        const UInt32 encoded_size = codec.compress(source_data.data(), source_data.size(), encoded.data());\n-        encoded.resize(encoded_size);\n-\n-        PODArray<char> decoded(source_data.size());\n-        const UInt32 decoded_size = codec.decompress(encoded.data(), encoded.size(), decoded.data());\n-        decoded.resize(decoded_size);\n-\n-        switch (test_sequence.data_type->getSizeOfValueInMemory())\n-        {\n-            case 1:\n-                ASSERT_TRUE(EqualByteContainersAs<UInt8>(source_data, decoded));\n-                break;\n-            case 2:\n-                ASSERT_TRUE(EqualByteContainersAs<UInt16>(source_data, decoded));\n-                break;\n-            case 4:\n-                ASSERT_TRUE(EqualByteContainersAs<UInt32>(source_data, decoded));\n-                break;\n-            case 8:\n-                ASSERT_TRUE(EqualByteContainersAs<UInt64>(source_data, decoded));\n-                break;\n-            default:\n-                FAIL() << \"Invalid test sequence data type: \" << test_sequence.data_type->getName();\n-        }\n-        const auto header_size = codec.getHeaderSize();\n-        const auto compression_ratio = (encoded_size - header_size) / (source_data.size() * 1.0);\n-\n-        const auto & codec_spec = std::get<0>(GetParam());\n-        if (codec_spec.expected_compression_ratio)\n-        {\n-            ASSERT_LE(compression_ratio, *codec_spec.expected_compression_ratio)\n-                    << \"\\n\\tdecoded size: \" << source_data.size()\n-                    << \"\\n\\tencoded size: \" << encoded_size\n-                    << \"(no header: \" << encoded_size - header_size << \")\";\n-        }\n+        NoOpTimer timer;\n+        ::testTranscoding(timer, codec, std::get<1>(GetParam()), std::get<0>(GetParam()).expected_compression_ratio);\n     }\n };\n \n@@ -396,10 +561,121 @@ TEST_P(CodecTest, TranscodingWithoutDataType)\n     testTranscoding(*codec);\n }\n \n+// Param is tuple-of-tuple to simplify instantiating with values, since typically group of cases test only one codec.\n+class CodecTest_Compatibility : public ::testing::TestWithParam<std::tuple<Codec, std::tuple<CodecTestSequence, std::string>>>\n+{};\n+\n+// Check that iput sequence when encoded matches the encoded string binary.\n+TEST_P(CodecTest_Compatibility, Encoding)\n+{\n+    const auto & codec_spec = std::get<0>(GetParam());\n+    const auto & [data_sequence, expected] = std::get<1>(GetParam());\n+    const auto codec = makeCodec(codec_spec.codec_statement, data_sequence.data_type);\n+\n+    const auto & source_data = data_sequence.serialized_data;\n+\n+    // Just encode the data with codec\n+    const UInt32 encoded_max_size = codec->getCompressedReserveSize(source_data.size());\n+    PODArray<char> encoded(encoded_max_size);\n+\n+    const UInt32 encoded_size = codec->compress(source_data.data(), source_data.size(), encoded.data());\n+    encoded.resize(encoded_size);\n+    SCOPED_TRACE(::testing::Message(\"encoded:  \") << AsHexString(encoded));\n+\n+    ASSERT_TRUE(EqualByteContainersAs<UInt8>(expected, encoded));\n+}\n+\n+// Check that binary string is exactly decoded into input sequence.\n+TEST_P(CodecTest_Compatibility, Decoding)\n+{\n+    const auto & codec_spec = std::get<0>(GetParam());\n+    const auto & [expected, encoded_data] = std::get<1>(GetParam());\n+    const auto codec = makeCodec(codec_spec.codec_statement, expected.data_type);\n+\n+    PODArray<char> decoded(expected.serialized_data.size());\n+    const UInt32 decoded_size = codec->decompress(encoded_data.c_str(), encoded_data.size(), decoded.data());\n+    decoded.resize(decoded_size);\n+\n+    ASSERT_TRUE(EqualByteContainers(expected.data_type->getSizeOfValueInMemory(), expected.serialized_data, decoded));\n+}\n+\n+class CodecTest_Performance : public ::testing::TestWithParam<std::tuple<Codec, CodecTestSequence>>\n+{};\n+\n+TEST_P(CodecTest_Performance, TranscodingWithDataType)\n+{\n+    const auto & [codec_spec, test_seq] = GetParam();\n+    const auto codec = ::makeCodec(codec_spec.codec_statement, test_seq.data_type);\n+\n+    const auto runs = 10;\n+    std::map<std::string, std::vector<UInt64>> results;\n+\n+    for (size_t i = 0; i < runs; ++i)\n+    {\n+        StopwatchTimer timer{CLOCK_THREAD_CPUTIME_ID};\n+        ::testTranscoding(timer, *codec, test_seq);\n+        timer.stop();\n+\n+        for (const auto & [label, value] : timer.getResults())\n+        {\n+            results[label].push_back(value);\n+        }\n+    }\n+\n+    auto computeMeanAndStdDev = [](const auto & values)\n+    {\n+        double mean{};\n+\n+        if (values.size() < 2)\n+            return std::make_tuple(mean, double{});\n+\n+        using ValueType = typename std::decay_t<decltype(values)>::value_type;\n+        std::vector<ValueType> tmp_v(std::begin(values), std::end(values));\n+        std::sort(tmp_v.begin(), tmp_v.end());\n+\n+        // remove min and max\n+        tmp_v.erase(tmp_v.begin());\n+        tmp_v.erase(tmp_v.end() - 1);\n+\n+        for (const auto & v : tmp_v)\n+        {\n+            mean += v;\n+        }\n+\n+        mean = mean / tmp_v.size();\n+        double std_dev = 0.0;\n+        for (const auto & v : tmp_v)\n+        {\n+            const auto d = (v - mean);\n+            std_dev += (d * d);\n+        }\n+        std_dev = std::sqrt(std_dev / tmp_v.size());\n+\n+        return std::make_tuple(mean, std_dev);\n+    };\n+\n+    std::cerr << codec_spec.codec_statement\n+              << \" \" << test_seq.data_type->getName()\n+              << \" (\" << test_seq.serialized_data.size() << \" bytes, \"\n+              << std::hex << CityHash_v1_0_2::CityHash64(test_seq.serialized_data.data(), test_seq.serialized_data.size()) << std::dec\n+              << \", average of \" << runs << \" runs, \u03bcs)\";\n+\n+    for (const auto & k : {\"encoding\", \"decoding\"})\n+    {\n+        const auto & values = results[k];\n+        const auto & [mean, std_dev] = computeMeanAndStdDev(values);\n+        // Ensure that Coefficient of variation is reasonably low, otherwise these numbers are meaningless\n+        EXPECT_GT(0.05, std_dev / mean);\n+        std::cerr << \"\\t\" << std::fixed << std::setprecision(1) << mean / 1000.0;\n+    }\n+\n+    std::cerr << std::endl;\n+}\n+\n ///////////////////////////////////////////////////////////////////////////////////////////////////\n // Here we use generators to produce test payload for codecs.\n // Generator is a callable that can produce infinite number of values,\n-// output value MUST be of the same type input value.\n+// output value MUST be of the same type as input value.\n ///////////////////////////////////////////////////////////////////////////////////////////////////\n \n auto SameValueGenerator = [](auto value)\n@@ -543,6 +819,23 @@ std::vector<CodecTestSequence> generatePyramidOfSequences(const size_t sequences\n     return sequences;\n };\n \n+// Just as if all sequences from generatePyramidOfSequences were appended to one-by-one to the first one.\n+template <typename T, typename Generator>\n+CodecTestSequence generatePyramidSequence(const size_t sequences_count, Generator && generator, const char* generator_name)\n+{\n+    CodecTestSequence sequence;\n+    sequence.data_type = makeDataType<T>();\n+    sequence.serialized_data.reserve(sequences_count * sequences_count * sizeof(T));\n+\n+    for (size_t i = 1; i < sequences_count; ++i)\n+    {\n+        std::string name = generator_name + std::string(\" from 0 to \") + std::to_string(i);\n+        sequence.append(generateSeq<T>(std::forward<decltype(generator)>(generator), name.c_str(), 0, i));\n+    }\n+\n+    return sequence;\n+};\n+\n \n // helper macro to produce human-friendly sequence name from generator\n #define G(generator) generator, #generator\n@@ -575,7 +868,7 @@ INSTANTIATE_TEST_CASE_P(SmallSequences,\n     ::testing::Combine(\n         DefaultCodecsToTest,\n         ::testing::ValuesIn(\n-                  generatePyramidOfSequences<Int8  >(42, G(SequentialGenerator(1)))\n+                  generatePyramidOfSequences<Int8 >(42, G(SequentialGenerator(1)))\n                 + generatePyramidOfSequences<Int16 >(42, G(SequentialGenerator(1)))\n                 + generatePyramidOfSequences<Int32 >(42, G(SequentialGenerator(1)))\n                 + generatePyramidOfSequences<Int64 >(42, G(SequentialGenerator(1)))\n@@ -609,7 +902,7 @@ INSTANTIATE_TEST_CASE_P(SameValueInt,\n     ::testing::Combine(\n         DefaultCodecsToTest,\n         ::testing::Values(\n-            generateSeq<Int8  >(G(SameValueGenerator(1000))),\n+            generateSeq<Int8>(G(SameValueGenerator(1000))),\n             generateSeq<Int16 >(G(SameValueGenerator(1000))),\n             generateSeq<Int32 >(G(SameValueGenerator(1000))),\n             generateSeq<Int64 >(G(SameValueGenerator(1000))),\n@@ -626,7 +919,7 @@ INSTANTIATE_TEST_CASE_P(SameNegativeValueInt,\n     ::testing::Combine(\n         DefaultCodecsToTest,\n         ::testing::Values(\n-            generateSeq<Int8  >(G(SameValueGenerator(-1000))),\n+            generateSeq<Int8>(G(SameValueGenerator(-1000))),\n             generateSeq<Int16 >(G(SameValueGenerator(-1000))),\n             generateSeq<Int32 >(G(SameValueGenerator(-1000))),\n             generateSeq<Int64 >(G(SameValueGenerator(-1000))),\n@@ -671,7 +964,7 @@ INSTANTIATE_TEST_CASE_P(SequentialInt,\n     ::testing::Combine(\n         DefaultCodecsToTest,\n         ::testing::Values(\n-            generateSeq<Int8  >(G(SequentialGenerator(1))),\n+            generateSeq<Int8>(G(SequentialGenerator(1))),\n             generateSeq<Int16 >(G(SequentialGenerator(1))),\n             generateSeq<Int32 >(G(SequentialGenerator(1))),\n             generateSeq<Int64 >(G(SequentialGenerator(1))),\n@@ -690,7 +983,7 @@ INSTANTIATE_TEST_CASE_P(SequentialReverseInt,\n     ::testing::Combine(\n         DefaultCodecsToTest,\n         ::testing::Values(\n-            generateSeq<Int8  >(G(SequentialGenerator(-1))),\n+            generateSeq<Int8>(G(SequentialGenerator(-1))),\n             generateSeq<Int16 >(G(SequentialGenerator(-1))),\n             generateSeq<Int32 >(G(SequentialGenerator(-1))),\n             generateSeq<Int64 >(G(SequentialGenerator(-1))),\n@@ -735,10 +1028,10 @@ INSTANTIATE_TEST_CASE_P(MonotonicInt,\n     ::testing::Combine(\n         DefaultCodecsToTest,\n         ::testing::Values(\n-            generateSeq<Int8  >(G(MonotonicGenerator(1, 5))),\n-            generateSeq<Int16 >(G(MonotonicGenerator(1, 5))),\n-            generateSeq<Int32 >(G(MonotonicGenerator(1, 5))),\n-            generateSeq<Int64 >(G(MonotonicGenerator(1, 5))),\n+            generateSeq<Int8>(G(MonotonicGenerator(1, 5))),\n+            generateSeq<Int16>(G(MonotonicGenerator(1, 5))),\n+            generateSeq<Int32>(G(MonotonicGenerator(1, 5))),\n+            generateSeq<Int64>(G(MonotonicGenerator(1, 5))),\n             generateSeq<UInt8 >(G(MonotonicGenerator(1, 5))),\n             generateSeq<UInt16>(G(MonotonicGenerator(1, 5))),\n             generateSeq<UInt32>(G(MonotonicGenerator(1, 5))),\n@@ -752,11 +1045,11 @@ INSTANTIATE_TEST_CASE_P(MonotonicReverseInt,\n     ::testing::Combine(\n         DefaultCodecsToTest,\n         ::testing::Values(\n-            generateSeq<Int8  >(G(MonotonicGenerator(-1, 5))),\n-            generateSeq<Int16 >(G(MonotonicGenerator(-1, 5))),\n-            generateSeq<Int32 >(G(MonotonicGenerator(-1, 5))),\n-            generateSeq<Int64 >(G(MonotonicGenerator(-1, 5))),\n-            generateSeq<UInt8 >(G(MonotonicGenerator(-1, 5))),\n+            generateSeq<Int8>(G(MonotonicGenerator(-1, 5))),\n+            generateSeq<Int16>(G(MonotonicGenerator(-1, 5))),\n+            generateSeq<Int32>(G(MonotonicGenerator(-1, 5))),\n+            generateSeq<Int64>(G(MonotonicGenerator(-1, 5))),\n+            generateSeq<UInt8>(G(MonotonicGenerator(-1, 5))),\n             generateSeq<UInt16>(G(MonotonicGenerator(-1, 5))),\n             generateSeq<UInt32>(G(MonotonicGenerator(-1, 5))),\n             generateSeq<UInt64>(G(MonotonicGenerator(-1, 5)))\n@@ -862,4 +1155,191 @@ INSTANTIATE_TEST_CASE_P(OverflowFloat,\n     ),\n );\n \n+template <typename ValueType>\n+auto DDCompatibilityTestSequence()\n+{\n+    // Generates sequences with double delta in given range.\n+    auto ddGenerator = [prev_delta = static_cast<Int64>(0), prev = static_cast<Int64>(0)](auto dd) mutable\n+    {\n+        const auto curr = dd + prev + prev_delta;\n+        prev = curr;\n+        prev_delta = dd + prev_delta;\n+        return curr;\n+    };\n+\n+    auto ret = generateSeq<ValueType>(G(SameValueGenerator(42)), 0, 3);\n+\n+    // These values are from DoubleDelta paper (and implementation) and represent points at which DD encoded length is changed.\n+    // DD value less that this point is encoded in shorter binary form (bigger - longer binary).\n+    const Int64 dd_corner_points[] = {-63, 64, -255, 256, -2047, 2048, std::numeric_limits<Int32>::min(), std::numeric_limits<Int32>::max()};\n+    for (const auto & p : dd_corner_points)\n+    {\n+        if (std::abs(p) > std::numeric_limits<ValueType>::max())\n+        {\n+            break;\n+        }\n+\n+        // - 4 is to allow DD value to settle before transitioning through important point,\n+        // since DD depends on 2 previous values of data, + 2 is arbitrary.\n+        ret.append(generateSeq<ValueType>(G(ddGenerator), p - 4, p + 2));\n+    }\n+\n+    return ret;\n+}\n+\n+#define BIN_STR(x) std::string{x, sizeof(x) - 1}\n+\n+INSTANTIATE_TEST_CASE_P(DoubleDelta,\n+    CodecTest_Compatibility,\n+    ::testing::Combine(\n+        ::testing::Values(Codec(\"DoubleDelta\")),\n+        ::testing::ValuesIn(std::initializer_list<std::tuple<CodecTestSequence, std::string>>{\n+            {\n+                DDCompatibilityTestSequence<Int8>(),\n+                BIN_STR(\"\\x94\\x21\\x00\\x00\\x00\\x0f\\x00\\x00\\x00\\x01\\x00\\x0f\\x00\\x00\\x00\\x2a\\x00\\x6b\\x65\\x5f\\x50\\x34\\xff\\x4f\\xaf\\xb1\\xaa\\xf4\\xf6\\x7d\\x87\\xf8\\x80\")\n+            },\n+            {\n+                DDCompatibilityTestSequence<UInt8>(),\n+                BIN_STR(\"\\x94\\x27\\x00\\x00\\x00\\x15\\x00\\x00\\x00\\x01\\x00\\x15\\x00\\x00\\x00\\x2a\\x00\\x6b\\x65\\x5f\\x50\\x34\\xff\\x4f\\xaf\\xb1\\xaa\\xf4\\xf6\\x7d\\x87\\xf8\\x81\\x8e\\xd0\\xca\\x02\\x01\\x01\")\n+            },\n+            {\n+                DDCompatibilityTestSequence<Int16>(),\n+                BIN_STR(\"\\x94\\x70\\x00\\x00\\x00\\x4e\\x00\\x00\\x00\\x02\\x00\\x27\\x00\\x00\\x00\\x2a\\x00\\x00\\x00\\x6b\\x65\\x5f\\x50\\x34\\xff\\x4f\\xaf\\xbc\\xe3\\x5d\\xa3\\xd3\\xd9\\xf6\\x1f\\xe2\\x07\\x7c\\x47\\x20\\x67\\x48\\x07\\x47\\xff\\x47\\xf6\\xfe\\xf8\\x00\\x00\\x70\\x6b\\xd0\\x00\\x02\\x83\\xd9\\xfb\\x9f\\xdc\\x1f\\xfc\\x20\\x1e\\x80\\x00\\x22\\xc8\\xf0\\x00\\x00\\x66\\x67\\xa0\\x00\\x02\\x00\\x3d\\x00\\x00\\x0f\\xff\\xe8\\x00\\x00\\x7f\\xee\\xff\\xdf\\x40\\x00\\x0f\\xf2\\x78\\x00\\x01\\x7f\\x83\\x9f\\xf7\\x9f\\xfb\\xc0\\x00\\x00\\xff\\xfe\\x00\\x00\\x08\\x00\")\n+            },\n+            {\n+                DDCompatibilityTestSequence<UInt16>(),\n+                BIN_STR(\"\\x94\\x70\\x00\\x00\\x00\\x4e\\x00\\x00\\x00\\x02\\x00\\x27\\x00\\x00\\x00\\x2a\\x00\\x00\\x00\\x6b\\x65\\x5f\\x50\\x34\\xff\\x4f\\xaf\\xbc\\xe3\\x5d\\xa3\\xd3\\xd9\\xf6\\x1f\\xe2\\x07\\x7c\\x47\\x20\\x67\\x48\\x07\\x47\\xff\\x47\\xf6\\xfe\\xf8\\x00\\x00\\x70\\x6b\\xd0\\x00\\x02\\x83\\xd9\\xfb\\x9f\\xdc\\x1f\\xfc\\x20\\x1e\\x80\\x00\\x22\\xc8\\xf0\\x00\\x00\\x66\\x67\\xa0\\x00\\x02\\x00\\x3d\\x00\\x00\\x0f\\xff\\xe8\\x00\\x00\\x7f\\xee\\xff\\xdf\\x40\\x00\\x0f\\xf2\\x78\\x00\\x01\\x7f\\x83\\x9f\\xf7\\x9f\\xfb\\xc0\\x00\\x00\\xff\\xfe\\x00\\x00\\x08\\x00\")\n+            },\n+            {\n+                DDCompatibilityTestSequence<Int32>(),\n+                BIN_STR(\"\\x94\\x74\\x00\\x00\\x00\\x9c\\x00\\x00\\x00\\x04\\x00\\x27\\x00\\x00\\x00\\x2a\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x6b\\x65\\x5f\\x50\\x34\\xff\\x4f\\xaf\\xbc\\xe3\\x5d\\xa3\\xd3\\xd9\\xf6\\x1f\\xe2\\x07\\x7c\\x47\\x20\\x67\\x48\\x07\\x47\\xff\\x47\\xf6\\xfe\\xf8\\x00\\x00\\x70\\x6b\\xd0\\x00\\x02\\x83\\xd9\\xfb\\x9f\\xdc\\x1f\\xfc\\x20\\x1e\\x80\\x00\\x22\\xc8\\xf0\\x00\\x00\\x66\\x67\\xa0\\x00\\x02\\x00\\x3d\\x00\\x00\\x0f\\xff\\xe8\\x00\\x00\\x7f\\xee\\xff\\xdf\\x00\\x00\\x70\\x0d\\x7a\\x00\\x02\\x80\\x7b\\x9f\\xf7\\x9f\\xfb\\xc0\\x00\\x00\\xff\\xfe\\x00\\x00\\x08\\x00\")\n+            },\n+            {\n+                DDCompatibilityTestSequence<UInt32>(),\n+                BIN_STR(\"\\x94\\xb5\\x00\\x00\\x00\\xcc\\x00\\x00\\x00\\x04\\x00\\x33\\x00\\x00\\x00\\x2a\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x6b\\x65\\x5f\\x50\\x34\\xff\\x4f\\xaf\\xbc\\xe3\\x5d\\xa3\\xd3\\xd9\\xf6\\x1f\\xe2\\x07\\x7c\\x47\\x20\\x67\\x48\\x07\\x47\\xff\\x47\\xf6\\xfe\\xf8\\x00\\x00\\x70\\x6b\\xd0\\x00\\x02\\x83\\xd9\\xfb\\x9f\\xdc\\x1f\\xfc\\x20\\x1e\\x80\\x00\\x22\\xc8\\xf0\\x00\\x00\\x66\\x67\\xa0\\x00\\x02\\x00\\x3d\\x00\\x00\\x0f\\xff\\xe8\\x00\\x00\\x7f\\xee\\xff\\xdf\\x00\\x00\\x70\\x0d\\x7a\\x00\\x02\\x80\\x7b\\x9f\\xf7\\x9f\\xfb\\xc0\\x00\\x00\\xff\\xfe\\x00\\x00\\x08\\x00\\xf3\\xff\\xf9\\x41\\xaf\\xbf\\xff\\xd6\\x0c\\xfc\\xff\\xff\\xff\\xfb\\xf0\\x00\\x00\\x00\\x07\\xff\\xff\\xff\\xef\\xc0\\x00\\x00\\x00\\x3f\\xff\\xff\\xff\\xfb\\xff\\xff\\xff\\xfa\\x69\\x74\\xf3\\xff\\xff\\xff\\xe7\\x9f\\xff\\xff\\xff\\x7e\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xfd\\xf8\\x00\\x00\\x00\\x07\\xff\\xff\\xff\\xf0\")\n+            },\n+            {\n+                DDCompatibilityTestSequence<Int64>(),\n+                BIN_STR(\"\\x94\\xd4\\x00\\x00\\x00\\x98\\x01\\x00\\x00\\x08\\x00\\x33\\x00\\x00\\x00\\x2a\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x6b\\x65\\x5f\\x50\\x34\\xff\\x4f\\xaf\\xbc\\xe3\\x5d\\xa3\\xd3\\xd9\\xf6\\x1f\\xe2\\x07\\x7c\\x47\\x20\\x67\\x48\\x07\\x47\\xff\\x47\\xf6\\xfe\\xf8\\x00\\x00\\x70\\x6b\\xd0\\x00\\x02\\x83\\xd9\\xfb\\x9f\\xdc\\x1f\\xfc\\x20\\x1e\\x80\\x00\\x22\\xc8\\xf0\\x00\\x00\\x66\\x67\\xa0\\x00\\x02\\x00\\x3d\\x00\\x00\\x0f\\xff\\xe8\\x00\\x00\\x7f\\xee\\xff\\xdf\\x00\\x00\\x70\\x0d\\x7a\\x00\\x02\\x80\\x7b\\x9f\\xf7\\x9f\\xfb\\xc0\\x00\\x00\\xff\\xfe\\x00\\x00\\x08\\x00\\xfc\\x00\\x00\\x00\\x04\\x00\\x06\\xbe\\x4f\\xbf\\xff\\xd6\\x0c\\xff\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x03\\xf8\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x0f\\xc0\\x00\\x00\\x00\\x3f\\xff\\xff\\xff\\xfb\\xff\\xff\\xff\\xfb\\xe0\\x00\\x00\\x01\\xc0\\x00\\x00\\x06\\x9f\\x80\\x00\\x00\\x0a\\x00\\x00\\x00\\x34\\xf3\\xff\\xff\\xff\\xe7\\x9f\\xff\\xff\\xff\\x7e\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xfd\\xf0\\x00\\x00\\x00\\x07\\xff\\xff\\xff\\xf0\")\n+            },\n+            {\n+                DDCompatibilityTestSequence<UInt64>(),\n+                BIN_STR(\"\\x94\\xd4\\x00\\x00\\x00\\x98\\x01\\x00\\x00\\x08\\x00\\x33\\x00\\x00\\x00\\x2a\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x6b\\x65\\x5f\\x50\\x34\\xff\\x4f\\xaf\\xbc\\xe3\\x5d\\xa3\\xd3\\xd9\\xf6\\x1f\\xe2\\x07\\x7c\\x47\\x20\\x67\\x48\\x07\\x47\\xff\\x47\\xf6\\xfe\\xf8\\x00\\x00\\x70\\x6b\\xd0\\x00\\x02\\x83\\xd9\\xfb\\x9f\\xdc\\x1f\\xfc\\x20\\x1e\\x80\\x00\\x22\\xc8\\xf0\\x00\\x00\\x66\\x67\\xa0\\x00\\x02\\x00\\x3d\\x00\\x00\\x0f\\xff\\xe8\\x00\\x00\\x7f\\xee\\xff\\xdf\\x00\\x00\\x70\\x0d\\x7a\\x00\\x02\\x80\\x7b\\x9f\\xf7\\x9f\\xfb\\xc0\\x00\\x00\\xff\\xfe\\x00\\x00\\x08\\x00\\xfc\\x00\\x00\\x00\\x04\\x00\\x06\\xbe\\x4f\\xbf\\xff\\xd6\\x0c\\xff\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x03\\xf8\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x0f\\xc0\\x00\\x00\\x00\\x3f\\xff\\xff\\xff\\xfb\\xff\\xff\\xff\\xfb\\xe0\\x00\\x00\\x01\\xc0\\x00\\x00\\x06\\x9f\\x80\\x00\\x00\\x0a\\x00\\x00\\x00\\x34\\xf3\\xff\\xff\\xff\\xe7\\x9f\\xff\\xff\\xff\\x7e\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xfd\\xf0\\x00\\x00\\x00\\x07\\xff\\xff\\xff\\xf0\")\n+            },\n+        })\n+    ),\n+);\n+\n+template <typename ValueType>\n+auto DDperformanceTestSequence()\n+{\n+    const auto times = 100'000;\n+    return DDCompatibilityTestSequence<ValueType>() * times // average case\n+        + generateSeq<ValueType>(G(MinMaxGenerator()), 0, times) // worst\n+        + generateSeq<ValueType>(G(SameValueGenerator(42)), 0, times); // best\n+}\n+\n+// prime numbers in ascending order with some random repitions hit all the cases of Gorilla.\n+auto PrimesWithMultiplierGenerator = [](int multiplier = 1)\n+{\n+    return [multiplier](auto i)\n+    {\n+        static const int vals[] = {\n+             2, 3, 5, 7, 11, 11, 13, 17, 19, 23, 29, 29, 31, 37, 41, 43,\n+            47, 47, 53, 59, 61, 61, 67, 71, 73, 79, 83, 89, 89, 97, 101, 103,\n+            107, 107, 109, 113, 113, 127, 127, 127\n+        };\n+        static const size_t count = sizeof(vals)/sizeof(vals[0]);\n+\n+        using T = decltype(i);\n+        return static_cast<T>(vals[i % count] * static_cast<T>(multiplier));\n+    };\n+};\n+\n+template <typename ValueType>\n+auto GCompatibilityTestSequence()\n+{\n+    // Also multiply result by some factor to test large values on types that can hold those.\n+    return generateSeq<ValueType>(G(PrimesWithMultiplierGenerator(intExp10(sizeof(ValueType)))), 0, 42);\n+}\n+\n+INSTANTIATE_TEST_CASE_P(Gorilla,\n+    CodecTest_Compatibility,\n+    ::testing::Combine(\n+        ::testing::Values(Codec(\"Gorilla\")),\n+        ::testing::ValuesIn(std::initializer_list<std::tuple<CodecTestSequence, std::string>>{\n+            {\n+                GCompatibilityTestSequence<Int8>(),\n+                BIN_STR(\"\\x95\\x35\\x00\\x00\\x00\\x2a\\x00\\x00\\x00\\x01\\x00\\x2a\\x00\\x00\\x00\\x14\\xe1\\xdd\\x25\\xe5\\x7b\\x29\\x86\\xee\\x2a\\x16\\x5a\\xc5\\x0b\\x23\\x75\\x1b\\x3c\\xb1\\x97\\x8b\\x5f\\xcb\\x43\\xd9\\xc5\\x48\\xab\\x23\\xaf\\x62\\x93\\x71\\x4a\\x73\\x0f\\xc6\\x0a\")\n+            },\n+            {\n+                GCompatibilityTestSequence<UInt8>(),\n+                BIN_STR(\"\\x95\\x35\\x00\\x00\\x00\\x2a\\x00\\x00\\x00\\x01\\x00\\x2a\\x00\\x00\\x00\\x14\\xe1\\xdd\\x25\\xe5\\x7b\\x29\\x86\\xee\\x2a\\x16\\x5a\\xc5\\x0b\\x23\\x75\\x1b\\x3c\\xb1\\x97\\x8b\\x5f\\xcb\\x43\\xd9\\xc5\\x48\\xab\\x23\\xaf\\x62\\x93\\x71\\x4a\\x73\\x0f\\xc6\\x0a\")\n+            },\n+            {\n+                GCompatibilityTestSequence<Int16>(),\n+                BIN_STR(\"\\x95\\x52\\x00\\x00\\x00\\x54\\x00\\x00\\x00\\x02\\x00\\x2a\\x00\\x00\\x00\\xc8\\x00\\xdc\\xfe\\x66\\xdb\\x1f\\x4e\\xa7\\xde\\xdc\\xd5\\xec\\x6e\\xf7\\x37\\x3a\\x23\\xe7\\x63\\xf5\\x6a\\x8e\\x99\\x37\\x34\\xf9\\xf8\\x2e\\x76\\x35\\x2d\\x51\\xbb\\x3b\\xc3\\x6d\\x13\\xbf\\x86\\x53\\x9e\\x25\\xe4\\xaf\\xaf\\x63\\xd5\\x6a\\x6e\\x76\\x35\\x3a\\x27\\xd3\\x0f\\x91\\xae\\x6b\\x33\\x57\\x6e\\x64\\xcc\\x55\\x81\\xe4\")\n+            },\n+            {\n+                GCompatibilityTestSequence<UInt16>(),\n+                BIN_STR(\"\\x95\\x52\\x00\\x00\\x00\\x54\\x00\\x00\\x00\\x02\\x00\\x2a\\x00\\x00\\x00\\xc8\\x00\\xdc\\xfe\\x66\\xdb\\x1f\\x4e\\xa7\\xde\\xdc\\xd5\\xec\\x6e\\xf7\\x37\\x3a\\x23\\xe7\\x63\\xf5\\x6a\\x8e\\x99\\x37\\x34\\xf9\\xf8\\x2e\\x76\\x35\\x2d\\x51\\xbb\\x3b\\xc3\\x6d\\x13\\xbf\\x86\\x53\\x9e\\x25\\xe4\\xaf\\xaf\\x63\\xd5\\x6a\\x6e\\x76\\x35\\x3a\\x27\\xd3\\x0f\\x91\\xae\\x6b\\x33\\x57\\x6e\\x64\\xcc\\x55\\x81\\xe4\")\n+            },\n+            {\n+                GCompatibilityTestSequence<Int32>(),\n+                BIN_STR(\"\\x95\\x65\\x00\\x00\\x00\\xa8\\x00\\x00\\x00\\x04\\x00\\x2a\\x00\\x00\\x00\\x20\\x4e\\x00\\x00\\xe4\\x57\\x63\\xc0\\xbb\\x67\\xbc\\xce\\x91\\x97\\x99\\x15\\x9e\\xe3\\x36\\x3f\\x89\\x5f\\x8e\\xf2\\xec\\x8e\\xd3\\xbf\\x75\\x43\\x58\\xc4\\x7e\\xcf\\x93\\x43\\x38\\xc6\\x91\\x36\\x1f\\xe7\\xb6\\x11\\x6f\\x02\\x73\\x46\\xef\\xe0\\xec\\x50\\xfb\\x79\\xcb\\x9c\\x14\\xfa\\x13\\xea\\x8d\\x66\\x43\\x48\\xa0\\xde\\x3a\\xcf\\xff\\x26\\xe0\\x5f\\x93\\xde\\x5e\\x7f\\x6e\\x36\\x5e\\xe6\\xb4\\x66\\x5d\\xb0\\x0e\\xc4\")\n+            },\n+            {\n+                GCompatibilityTestSequence<UInt32>(),\n+                BIN_STR(\"\\x95\\x65\\x00\\x00\\x00\\xa8\\x00\\x00\\x00\\x04\\x00\\x2a\\x00\\x00\\x00\\x20\\x4e\\x00\\x00\\xe4\\x57\\x63\\xc0\\xbb\\x67\\xbc\\xce\\x91\\x97\\x99\\x15\\x9e\\xe3\\x36\\x3f\\x89\\x5f\\x8e\\xf2\\xec\\x8e\\xd3\\xbf\\x75\\x43\\x58\\xc4\\x7e\\xcf\\x93\\x43\\x38\\xc6\\x91\\x36\\x1f\\xe7\\xb6\\x11\\x6f\\x02\\x73\\x46\\xef\\xe0\\xec\\x50\\xfb\\x79\\xcb\\x9c\\x14\\xfa\\x13\\xea\\x8d\\x66\\x43\\x48\\xa0\\xde\\x3a\\xcf\\xff\\x26\\xe0\\x5f\\x93\\xde\\x5e\\x7f\\x6e\\x36\\x5e\\xe6\\xb4\\x66\\x5d\\xb0\\x0e\\xc4\")\n+            },\n+            {\n+                GCompatibilityTestSequence<Int64>(),\n+                BIN_STR(\"\\x95\\x91\\x00\\x00\\x00\\x50\\x01\\x00\\x00\\x08\\x00\\x2a\\x00\\x00\\x00\\x00\\xc2\\xeb\\x0b\\x00\\x00\\x00\\x00\\xe3\\x2b\\xa0\\xa6\\x19\\x85\\x98\\xdc\\x45\\x74\\x74\\x43\\xc2\\x57\\x41\\x4c\\x6e\\x42\\x79\\xd9\\x8f\\x88\\xa5\\x05\\xf3\\xf1\\x94\\xa3\\x62\\x1e\\x02\\xdf\\x05\\x10\\xf1\\x15\\x97\\x35\\x2a\\x50\\x71\\x0f\\x09\\x6c\\x89\\xf7\\x65\\x1d\\x11\\xb7\\xcc\\x7d\\x0b\\x70\\xc1\\x86\\x88\\x48\\x47\\x87\\xb6\\x32\\x26\\xa7\\x86\\x87\\x88\\xd3\\x93\\x3d\\xfc\\x28\\x68\\x85\\x05\\x0b\\x13\\xc6\\x5f\\xd4\\x70\\xe1\\x5e\\x76\\xf1\\x9f\\xf3\\x33\\x2a\\x14\\x14\\x5e\\x40\\xc1\\x5c\\x28\\x3f\\xec\\x43\\x03\\x05\\x11\\x91\\xe8\\xeb\\x8e\\x0a\\x0e\\x27\\x21\\x55\\xcb\\x39\\xbc\\x6a\\xff\\x11\\x5d\\x81\\xa0\\xa6\\x10\")\n+            },\n+            {\n+                GCompatibilityTestSequence<UInt64>(),\n+                BIN_STR(\"\\x95\\x91\\x00\\x00\\x00\\x50\\x01\\x00\\x00\\x08\\x00\\x2a\\x00\\x00\\x00\\x00\\xc2\\xeb\\x0b\\x00\\x00\\x00\\x00\\xe3\\x2b\\xa0\\xa6\\x19\\x85\\x98\\xdc\\x45\\x74\\x74\\x43\\xc2\\x57\\x41\\x4c\\x6e\\x42\\x79\\xd9\\x8f\\x88\\xa5\\x05\\xf3\\xf1\\x94\\xa3\\x62\\x1e\\x02\\xdf\\x05\\x10\\xf1\\x15\\x97\\x35\\x2a\\x50\\x71\\x0f\\x09\\x6c\\x89\\xf7\\x65\\x1d\\x11\\xb7\\xcc\\x7d\\x0b\\x70\\xc1\\x86\\x88\\x48\\x47\\x87\\xb6\\x32\\x26\\xa7\\x86\\x87\\x88\\xd3\\x93\\x3d\\xfc\\x28\\x68\\x85\\x05\\x0b\\x13\\xc6\\x5f\\xd4\\x70\\xe1\\x5e\\x76\\xf1\\x9f\\xf3\\x33\\x2a\\x14\\x14\\x5e\\x40\\xc1\\x5c\\x28\\x3f\\xec\\x43\\x03\\x05\\x11\\x91\\xe8\\xeb\\x8e\\x0a\\x0e\\x27\\x21\\x55\\xcb\\x39\\xbc\\x6a\\xff\\x11\\x5d\\x81\\xa0\\xa6\\x10\")\n+            },\n+        })\n+    ),\n+);\n+\n+// These 'tests' try to measure performance of encoding and decoding and hence only make sence to be run locally,\n+// also they require pretty big data to run agains and generating this data slows down startup of unit test process.\n+// So un-comment only at your discretion.\n+\n+//INSTANTIATE_TEST_CASE_P(DoubleDelta,\n+//    CodecTest_Performance,\n+//    ::testing::Combine(\n+//        ::testing::Values(Codec(\"DoubleDelta\")),\n+//        ::testing::Values(\n+//            DDperformanceTestSequence<Int8 >(),\n+//            DDperformanceTestSequence<UInt8 >(),\n+//            DDperformanceTestSequence<Int16 >(),\n+//            DDperformanceTestSequence<UInt16>(),\n+//            DDperformanceTestSequence<Int32 >(),\n+//            DDperformanceTestSequence<UInt32>(),\n+//            DDperformanceTestSequence<Int64 >(),\n+//            DDperformanceTestSequence<UInt64>()\n+//        )\n+//    ),\n+//);\n+\n+//INSTANTIATE_TEST_CASE_P(Gorilla,\n+//    CodecTest_Performance,\n+//    ::testing::Combine(\n+//        ::testing::Values(Codec(\"Gorilla\")),\n+//        ::testing::Values(\n+//            generatePyramidSequence<Int8 >(42, G(PrimesWithMultiplierGenerator())) * 6'000,\n+//            generatePyramidSequence<UInt8 >(42, G(PrimesWithMultiplierGenerator())) * 6'000,\n+//            generatePyramidSequence<Int16 >(42, G(PrimesWithMultiplierGenerator())) * 6'000,\n+//            generatePyramidSequence<UInt16>(42, G(PrimesWithMultiplierGenerator())) * 6'000,\n+//            generatePyramidSequence<Int32 >(42, G(PrimesWithMultiplierGenerator())) * 6'000,\n+//            generatePyramidSequence<UInt32>(42, G(PrimesWithMultiplierGenerator())) * 6'000,\n+//            generatePyramidSequence<Int64 >(42, G(PrimesWithMultiplierGenerator())) * 6'000,\n+//            generatePyramidSequence<UInt64>(42, G(PrimesWithMultiplierGenerator())) * 6'000\n+//        )\n+//    ),\n+//);\n+\n }\ndiff --git a/dbms/src/IO/tests/gtest_bit_io.cpp b/dbms/src/IO/tests/gtest_bit_io.cpp\nindex 85df25807831..b44a17e02db6 100644\n--- a/dbms/src/IO/tests/gtest_bit_io.cpp\n+++ b/dbms/src/IO/tests/gtest_bit_io.cpp\n@@ -36,11 +36,11 @@ std::string bin(const T & value, size_t bits = sizeof(T)*8)\n             .to_string().substr(MAX_BITS - bits, bits);\n }\n \n+// gets N low bits of value\n template <typename T>\n T getBits(UInt8 bits, const T & value)\n {\n-    const T mask = ((static_cast<T>(1) << static_cast<T>(bits)) - 1);\n-    return value & mask;\n+    return value & maskLowBits<T>(bits);\n }\n \n template <typename T>\n@@ -83,12 +83,36 @@ std::string dumpContents(const T& container,\n     return sstr.str();\n }\n \n+template <typename ValueLeft, typename ValueRight>\n+::testing::AssertionResult BinaryEqual(const ValueLeft & left, const ValueRight & right)\n+{\n+//    ::testing::AssertionResult result = ::testing::AssertionSuccess();\n+    if (sizeof(left) != sizeof(right))\n+        return ::testing::AssertionFailure()\n+                << \"Sizes do not match, expected: \" << sizeof(left) << \" actual: \" << sizeof(right);\n+\n+    const auto size = std::min(sizeof(left), sizeof(right));\n+    if (memcmp(&left, &right, size) != 0)\n+    {\n+        const auto l_bits = left ? static_cast<size_t>(std::log2(left)) : 0;\n+        const auto r_bits = right ? static_cast<size_t>(std::log2(right)) : 0;\n+        const size_t bits = std::max(l_bits, r_bits) + 1;\n+\n+        return ::testing::AssertionFailure()\n+                << \"Values are binary different,\\n\"\n+                << \"\\texpected: 0b\" << bin(left, bits) << \" (\" << std::hex << left << \"),\\n\"\n+                << \"\\tactual  : 0b\" << bin(right, bits) << \" (\" <<std::hex << right << \").\";\n+    }\n+\n+    return ::testing::AssertionSuccess();\n+}\n+\n struct TestCaseParameter\n {\n     std::vector<std::pair<UInt8, UInt64>> bits_and_vals;\n     std::string expected_buffer_binary;\n \n-    explicit TestCaseParameter(std::vector<std::pair<UInt8, UInt64>> vals, std::string binary = std::string{})\n+    TestCaseParameter(std::vector<std::pair<UInt8, UInt64>> vals, std::string binary = std::string{})\n         : bits_and_vals(std::move(vals)),\n           expected_buffer_binary(binary)\n     {}\n@@ -114,8 +138,7 @@ TEST_P(BitIO, WriteAndRead)\n     PODArray<char> data(max_buffer_size);\n \n     {\n-        WriteBuffer write_buffer(data.data(), data.size());\n-        BitWriter writer(write_buffer);\n+        BitWriter writer(data.data(), data.size());\n         for (const auto & bv : bits_and_vals)\n         {\n             writer.writeBits(bv.first, bv.second);\n@@ -133,38 +156,73 @@ TEST_P(BitIO, WriteAndRead)\n             ASSERT_EQ(expected_buffer_binary, actual_buffer_binary);\n         }\n \n-        BitReader reader(read_buffer);\n+        BitReader reader(data.data(), data.size());\n \n+        int bitpos = 0;\n         int item = 0;\n         for (const auto & bv : bits_and_vals)\n         {\n             SCOPED_TRACE(::testing::Message()\n-                         << \"item #\" << item << \", width: \" << static_cast<UInt32>(bv.first)\n-                         << \", value: \" << bin(bv.second)\n-                         << \".\\n\\n\\nBuffer memory:\\n\" << dumpContents(data));\n+                         << \"item #\" << item << \" of \" << bits_and_vals.size() << \", width: \" << static_cast<UInt32>(bv.first)\n+                         << \", value: \" << bv.second << \"(\" << bin(bv.second) << \")\"\n+                         << \", at bit position: \" << std::dec << reader.count()\n+                         << \".\\nBuffer memory:\\n\" << dumpContents(data));\n \n-            //EXPECT_EQ(getBits(bv.first, bv.second), reader.peekBits(bv.first));\n-            EXPECT_EQ(getBits(bv.first, bv.second), reader.readBits(bv.first));\n+//            const UInt8 next_byte = getBits(bv.first, bv.second) &\n+            ASSERT_TRUE(BinaryEqual(getBits(bv.first, bv.second), reader.readBits(bv.first)));\n \n             ++item;\n+            bitpos += bv.first;\n         }\n     }\n }\n \n INSTANTIATE_TEST_CASE_P(Simple,\n-        BitIO,\n-        ::testing::Values(\n-            TestCaseParameter(\n-                {{9, 0xFFFFFFFF}, {9, 0x00}, {9, 0xFFFFFFFF}, {9, 0x00}, {9, 0xFFFFFFFF}},\n-                \"11111111 10000000 00111111 11100000 00001111 11111000 \"),\n-            TestCaseParameter(\n-                {{7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {3, 0xFFFF}},\n-                \"01111110 11111101 11111011 11110111 11101111 11011111 10111111 01111111 11000000 \"),\n-            TestCaseParameter({{33, 0xFF110d0b07050300}, {33, 0xAAEE29251f1d1713}}),\n-            TestCaseParameter({{33, BIT_PATTERN}, {33, BIT_PATTERN}}),\n-            TestCaseParameter({{24, 0xFFFFFFFF}},\n-                \"11111111 11111111 11111111 \")\n-),);\n+    BitIO,\n+    ::testing::ValuesIn(std::initializer_list<TestCaseParameter>{\n+        {\n+            {{9, 0xFFFFFFFF}, {9, 0x00}, {9, 0xFFFFFFFF}, {9, 0x00}, {9, 0xFFFFFFFF}},\n+            \"11111111 10000000 00111111 11100000 00001111 11111000 \"\n+        },\n+        {\n+            {{7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {3, 0xFFFF}},\n+            \"01111110 11111101 11111011 11110111 11101111 11011111 10111111 01111111 11000000 \"\n+        },\n+        {\n+            {{33, 0xFF110d0b07050300}, {33, 0xAAEE29251f1d1713}}\n+        },\n+        {\n+            {{33, BIT_PATTERN}, {33, BIT_PATTERN}}\n+        },\n+        {\n+            {{24, 0xFFFFFFFF}},\n+            \"11111111 11111111 11111111 \"\n+        },\n+        {\n+            // Note that we take only N lower bits of the number: {3, 0b01011} => 011\n+            {{5, 0b01010}, {3, 0b111}, {7, 0b11001100}, {6, 0}, {5, 0b11111111}, {4, 0}, {3, 0b101}, {2, 0}, {1, 0b11111111}},\n+            \"01010111 10011000 00000111 11000010 10010000 \"\n+        },\n+        {\n+            {{64, BIT_PATTERN}, {56, BIT_PATTERN} , {4, 0b1111}, {4, 0}, // 128\n+             {8, 0b11111111}, {64, BIT_PATTERN}, {48, BIT_PATTERN}, {8, 0}}, // 256\n+            \"11101011 11101111 10111010 11101111 10101111 10111010 11101011 10101001 \" // 64\n+            \"11101111 10111010 11101111 10101111 10111010 11101011 10101001 11110000 \" // 128\n+            \"11111111 11101011 11101111 10111010 11101111 10101111 10111010 11101011 \" // 192\n+            \"10101001 10111010 11101111 10101111 10111010 11101011 10101001 00000000 \" // 256\n+        },\n+        {\n+            {{64, BIT_PATTERN}, {56, BIT_PATTERN} , {5, 0b11111}, {3, 0}, // 128\n+             {8, 0b11111111}, {64, BIT_PATTERN}, {48, BIT_PATTERN}, {8, 0}, //256\n+             {32, BIT_PATTERN}, {12, 0xff}, {8, 0}, {12, 0xAEff}},\n+            \"11101011 11101111 10111010 11101111 10101111 10111010 11101011 10101001 \" // 64\n+            \"11101111 10111010 11101111 10101111 10111010 11101011 10101001 11111000 \" // 128\n+            \"11111111 11101011 11101111 10111010 11101111 10101111 10111010 11101011 \" // 192\n+            \"10101001 10111010 11101111 10101111 10111010 11101011 10101001 00000000 \" // 256\n+            \"10101111 10111010 11101011 10101001 00001111 11110000 00001110 11111111 \" // 320\n+        }\n+    }),\n+);\n \n TestCaseParameter primes_case(UInt8 repeat_times, UInt64 pattern)\n {\n",
  "problem_statement": "DoubleDelta codec is extremely slow\n\n",
  "hints_text": "",
  "created_at": "2019-12-04T04:21:12Z",
  "modified_files": [
    "dbms/src/Compression/CompressionCodecDoubleDelta.cpp",
    "dbms/src/Compression/CompressionCodecDoubleDelta.h",
    "dbms/src/Compression/CompressionCodecGorilla.cpp",
    "dbms/src/Compression/CompressionCodecGorilla.h",
    "dbms/src/IO/BitHelpers.h"
  ],
  "modified_test_files": [
    "dbms/src/Compression/tests/gtest_compressionCodec.cpp",
    "dbms/src/IO/tests/gtest_bit_io.cpp"
  ]
}