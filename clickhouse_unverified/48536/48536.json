{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 48536,
  "instance_id": "ClickHouse__ClickHouse-48536",
  "issue_numbers": [
    "26467"
  ],
  "base_commit": "9772e8e2214f076a254fc162d1e8ead8a8888b80",
  "patch": "diff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 2b880fb3418b..024d3f36fb7c 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -129,6 +129,7 @@ class IColumn;\n     \\\n     M(Bool, allow_suspicious_low_cardinality_types, false, \"In CREATE TABLE statement allows specifying LowCardinality modifier for types of small fixed size (8 or less). Enabling this may increase merge times and memory consumption.\", 0) \\\n     M(Bool, allow_suspicious_fixed_string_types, false, \"In CREATE TABLE statement allows creating columns of type FixedString(n) with n > 256. FixedString with length >= 256 is suspicious and most likely indicates misusage\", 0) \\\n+    M(Bool, allow_suspicious_indices, false, \"Reject primary/secondary indexes and sorting keys with identical expressions\", 0) \\\n     M(Bool, compile_expressions, true, \"Compile some scalar functions and operators to native code.\", 0) \\\n     M(UInt64, min_count_to_compile_expression, 3, \"The number of identical expressions before they are JIT-compiled\", 0) \\\n     M(Bool, compile_aggregate_expressions, false, \"Compile aggregate functions to native code. This feature has a bug and should not be used.\", 0) \\\ndiff --git a/src/Core/SettingsChangesHistory.h b/src/Core/SettingsChangesHistory.h\nindex eced3da2d59d..266d14f645b1 100644\n--- a/src/Core/SettingsChangesHistory.h\n+++ b/src/Core/SettingsChangesHistory.h\n@@ -80,6 +80,7 @@ namespace SettingsChangesHistory\n /// It's used to implement `compatibility` setting (see https://github.com/ClickHouse/ClickHouse/issues/35972)\n static std::map<ClickHouseVersion, SettingsChangesHistory::SettingsChanges> settings_changes_history =\n {\n+    {\"23.4\", {{\"allow_suspicious_indices\", true, false, \"If true, index can defined with identical expressions\"}}},\n     {\"23.4\", {{\"connect_timeout_with_failover_ms\", 50, 1000, \"Increase default connect timeout because of async connect\"},\n               {\"connect_timeout_with_failover_secure_ms\", 100, 1000, \"Increase default secure connect timeout because of async connect\"},\n               {\"hedged_connection_timeout_ms\", 100, 50, \"Start new connection in hedged requests after 50 ms instead of 100 to correspond with previous connect timeout\"}}},\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex f5f126602237..afde1cd2fcad 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -42,9 +42,13 @@\n #include <Interpreters/PartLog.h>\n #include <Interpreters/TransactionLog.h>\n #include <Interpreters/TreeRewriter.h>\n+#include <Interpreters/Context_fwd.h>\n #include <IO/S3Common.h>\n+#include <IO/WriteHelpers.h>\n #include <IO/Operators.h>\n #include <IO/WriteBufferFromString.h>\n+#include <Parsers/ASTExpressionList.h>\n+#include <Parsers/ASTIndexDeclaration.h>\n #include <Parsers/ASTFunction.h>\n #include <Parsers/ASTLiteral.h>\n #include <Parsers/ASTNameTypePair.h>\n@@ -54,6 +58,7 @@\n #include <Parsers/ExpressionListParsers.h>\n #include <Parsers/parseQuery.h>\n #include <Parsers/queryToString.h>\n+#include <Parsers/ASTAlterQuery.h>\n #include <Processors/Formats/IInputFormat.h>\n #include <Processors/QueryPlan/QueryIdHolder.h>\n #include <Processors/QueryPlan/ReadFromMergeTree.h>\n@@ -76,6 +81,7 @@\n \n #include <algorithm>\n #include <atomic>\n+#include <cmath>\n #include <chrono>\n #include <iomanip>\n #include <limits>\n@@ -173,6 +179,19 @@ namespace ErrorCodes\n     extern const int SOCKET_TIMEOUT;\n }\n \n+static void checkSuspiciousIndices(const ASTFunction * index_function)\n+{\n+    std::unordered_set<UInt64> unique_index_expression_hashes;\n+    for (const auto & child : index_function->arguments->children)\n+    {\n+        IAST::Hash hash = child->getTreeHash();\n+        UInt64 first_half_of_hash = hash.first;\n+\n+        if (!unique_index_expression_hashes.emplace(first_half_of_hash).second)\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                    \"Primary key or secondary index contains a duplicate expression. To suppress this exception, rerun the command with setting 'allow_suspicious_indices = 1'\");\n+    }\n+}\n \n static void checkSampleExpression(const StorageInMemoryMetadata & metadata, bool allow_sampling_expression_not_in_primary_key, bool check_sample_column_is_correct)\n {\n@@ -440,7 +459,10 @@ static void checkKeyExpression(const ExpressionActions & expr, const Block & sam\n }\n \n void MergeTreeData::checkProperties(\n-    const StorageInMemoryMetadata & new_metadata, const StorageInMemoryMetadata & old_metadata, bool attach) const\n+    const StorageInMemoryMetadata & new_metadata,\n+    const StorageInMemoryMetadata & old_metadata,\n+    bool attach,\n+    ContextPtr local_context) const\n {\n     if (!new_metadata.sorting_key.definition_ast)\n         throw Exception(ErrorCodes::BAD_ARGUMENTS, \"ORDER BY cannot be empty\");\n@@ -454,7 +476,13 @@ void MergeTreeData::checkProperties(\n         throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Primary key must be a prefix of the sorting key, but its length: \"\n             \"{} is greater than the sorting key length: {}\", primary_key_size, sorting_key_size);\n \n-    NameSet primary_key_columns_set;\n+    bool allow_suspicious_indices = getSettings()->allow_suspicious_indices;\n+    if (local_context)\n+        allow_suspicious_indices = local_context->getSettingsRef().allow_suspicious_indices;\n+\n+    if (!allow_suspicious_indices && !attach)\n+        if (const auto * index_function = typeid_cast<ASTFunction *>(new_sorting_key.definition_ast.get()))\n+            checkSuspiciousIndices(index_function);\n \n     for (size_t i = 0; i < sorting_key_size; ++i)\n     {\n@@ -468,9 +496,6 @@ void MergeTreeData::checkProperties(\n                                 \"Primary key must be a prefix of the sorting key, \"\n                                 \"but the column in the position {} is {}\", i, sorting_key_column +\", not \" + pk_column);\n \n-            if (!primary_key_columns_set.emplace(pk_column).second)\n-                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Primary key contains duplicate columns\");\n-\n         }\n     }\n \n@@ -531,6 +556,13 @@ void MergeTreeData::checkProperties(\n \n         for (const auto & index : new_metadata.secondary_indices)\n         {\n+            if (!allow_suspicious_indices && !attach)\n+            {\n+                const auto * index_ast = typeid_cast<const ASTIndexDeclaration *>(index.definition_ast.get());\n+                if (const auto * index_function = typeid_cast<const ASTFunction *>(index_ast->expr))\n+                    checkSuspiciousIndices(index_function);\n+            }\n+\n             MergeTreeIndexFactory::instance().validate(index, attach);\n \n             if (indices_names.find(index.name) != indices_names.end())\n@@ -556,9 +588,13 @@ void MergeTreeData::checkProperties(\n     checkKeyExpression(*new_sorting_key.expression, new_sorting_key.sample_block, \"Sorting\", allow_nullable_key);\n }\n \n-void MergeTreeData::setProperties(const StorageInMemoryMetadata & new_metadata, const StorageInMemoryMetadata & old_metadata, bool attach)\n+void MergeTreeData::setProperties(\n+    const StorageInMemoryMetadata & new_metadata,\n+    const StorageInMemoryMetadata & old_metadata,\n+    bool attach,\n+    ContextPtr local_context)\n {\n-    checkProperties(new_metadata, old_metadata, attach);\n+    checkProperties(new_metadata, old_metadata, attach, local_context);\n     setInMemoryMetadata(new_metadata);\n }\n \n@@ -990,7 +1026,6 @@ std::optional<UInt64> MergeTreeData::totalRowsByPartitionPredicateImpl(\n     return res;\n }\n \n-\n String MergeTreeData::MergingParams::getModeName() const\n {\n     switch (mode)\n@@ -3151,7 +3186,7 @@ void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, Context\n         }\n     }\n \n-    checkProperties(new_metadata, old_metadata);\n+    checkProperties(new_metadata, old_metadata, false, local_context);\n     checkTTLExpressions(new_metadata, old_metadata);\n \n     if (!columns_to_check_conversion.empty())\ndiff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h\nindex b03b7d4a71ee..42cbd311b868 100644\n--- a/src/Storages/MergeTree/MergeTreeData.h\n+++ b/src/Storages/MergeTree/MergeTreeData.h\n@@ -1218,9 +1218,9 @@ class MergeTreeData : public IStorage, public WithMutableContext\n     /// The same for clearOldTemporaryDirectories.\n     std::mutex clear_old_temporary_directories_mutex;\n \n-    void checkProperties(const StorageInMemoryMetadata & new_metadata, const StorageInMemoryMetadata & old_metadata, bool attach = false) const;\n+    void checkProperties(const StorageInMemoryMetadata & new_metadata, const StorageInMemoryMetadata & old_metadata, bool attach = false, ContextPtr local_context = nullptr) const;\n \n-    void setProperties(const StorageInMemoryMetadata & new_metadata, const StorageInMemoryMetadata & old_metadata, bool attach = false);\n+    void setProperties(const StorageInMemoryMetadata & new_metadata, const StorageInMemoryMetadata & old_metadata, bool attach = false, ContextPtr local_context = nullptr);\n \n     void checkPartitionKeyAndInitMinMax(const KeyDescription & new_partition_key);\n \ndiff --git a/src/Storages/MergeTree/MergeTreeSettings.h b/src/Storages/MergeTree/MergeTreeSettings.h\nindex ad55c9d47f3b..ba98fca2f508 100644\n--- a/src/Storages/MergeTree/MergeTreeSettings.h\n+++ b/src/Storages/MergeTree/MergeTreeSettings.h\n@@ -130,6 +130,7 @@ struct Settings;\n     M(UInt64, vertical_merge_algorithm_min_columns_to_activate, 11, \"Minimal amount of non-PK columns to activate Vertical merge algorithm.\", 0) \\\n     \\\n     /** Compatibility settings */ \\\n+    M(Bool, allow_suspicious_indices, false, \"Reject primary/secondary indexes and sorting keys with identical expressions\", 0) \\\n     M(Bool, compatibility_allow_sampling_expression_not_in_primary_key, false, \"Allow to create a table with sampling expression not in primary key. This is needed only to temporarily allow to run the server with wrong tables for backward compatibility.\", 0) \\\n     M(Bool, use_minimalistic_checksums_in_zookeeper, true, \"Use small format (dozens bytes) for part checksums in ZooKeeper instead of ordinary ones (dozens KB). Before enabling check that all replicas support new format.\", 0) \\\n     M(Bool, use_minimalistic_part_header_in_zookeeper, true, \"Store part header (checksums and columns) in a compact format and a single part znode instead of separate znodes (<part>/columns and <part>/checksums). This can dramatically reduce snapshot size in ZooKeeper. Before enabling check that all replicas support new format.\", 0) \\\ndiff --git a/src/Storages/StorageMergeTree.cpp b/src/Storages/StorageMergeTree.cpp\nindex 5513603bca69..61b096b66895 100644\n--- a/src/Storages/StorageMergeTree.cpp\n+++ b/src/Storages/StorageMergeTree.cpp\n@@ -348,7 +348,7 @@ void StorageMergeTree::alter(\n             changeSettings(new_metadata.settings_changes, table_lock_holder);\n             checkTTLExpressions(new_metadata, old_metadata);\n             /// Reinitialize primary key because primary key column types might have changed.\n-            setProperties(new_metadata, old_metadata);\n+            setProperties(new_metadata, old_metadata, false, local_context);\n \n             DatabaseCatalog::instance().getDatabase(table_id.database_name)->alterTable(local_context, table_id, new_metadata);\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02710_allow_suspicious_indices.reference b/tests/queries/0_stateless/02710_allow_suspicious_indices.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/02710_allow_suspicious_indices.sql b/tests/queries/0_stateless/02710_allow_suspicious_indices.sql\nnew file mode 100644\nindex 000000000000..78d52f7bc72d\n--- /dev/null\n+++ b/tests/queries/0_stateless/02710_allow_suspicious_indices.sql\n@@ -0,0 +1,22 @@\n+-- Check CREATE TABLE\n+\n+DROP TABLE IF EXISTS tbl;\n+CREATE TABLE tbl (id UInt32) ENGINE = MergeTree() ORDER BY (id + 1, id + 1);  -- { serverError BAD_ARGUMENTS }\n+CREATE TABLE tbl (id UInt32) ENGINE = MergeTree() ORDER BY (id + 1, id + 1) SETTINGS allow_suspicious_indices = 1;\n+\n+DROP TABLE IF EXISTS tbl;\n+CREATE TABLE tbl (id UInt32, INDEX idx (id + 1, id + 1) TYPE minmax) ENGINE = MergeTree() ORDER BY id;  -- { serverError BAD_ARGUMENTS }\n+CREATE TABLE tbl (id UInt32, INDEX idx (id + 1, id + 1) TYPE minmax) ENGINE = MergeTree() ORDER BY id SETTINGS allow_suspicious_indices = 1;\n+\n+-- Check ALTER TABLE\n+\n+DROP TABLE IF EXISTS tbl;\n+CREATE TABLE tbl (id1 UInt32) ENGINE = MergeTree() ORDER BY id1;\n+ALTER TABLE tbl ADD COLUMN `id2` UInt32, MODIFY ORDER BY (id1, id2, id2);  -- { serverError BAD_ARGUMENTS }\n+ALTER TABLE tbl ADD COLUMN `id2` UInt32, MODIFY ORDER BY (id1, id2, id1);  -- { serverError BAD_ARGUMENTS }\n+ALTER TABLE tbl ADD COLUMN `id2` UInt32, MODIFY ORDER BY (id1, id2, id2) SETTINGS allow_suspicious_indices = 1;\n+\n+DROP TABLE IF EXISTS tbl;\n+CREATE TABLE tbl (id UInt32) ENGINE = MergeTree() ORDER BY id;\n+ALTER TABLE tbl ADD INDEX idx (id+1, id, id+1) TYPE minmax;  -- { serverError BAD_ARGUMENTS }\n+ALTER TABLE tbl ADD INDEX idx (id+1, id, id+1) TYPE minmax SETTINGS allow_suspicious_indices = 1;\n",
  "problem_statement": "Add a setting `allow_suspicious_indices`.\nNot sure is UB or expected B.\r\n\r\n```sql\r\nCREATE TABLE test\r\n(\r\n    `a` Int64\r\n)\r\nENGINE = MergeTree\r\nPRIMARY KEY a\r\nORDER BY (a, a);\r\n\r\nALTER TABLE test\r\n    ADD COLUMN `b` Int64,     MODIFY ORDER BY (a, a, b, b, b);\r\n\r\nSHOW CREATE TABLE test;\r\n\r\nCREATE TABLE test\r\n(\r\n    `a` Int64,\r\n    `b` Int64\r\n)\r\nENGINE = MergeTree\r\nPRIMARY KEY a\r\nORDER BY (a, a, b, b, b)\r\nSETTINGS index_granularity = 8192\r\n```\r\n\n",
  "hints_text": "Add a setting `allow_suspicious_indices`.\r\nThe index is considered suspicious if it contains identical expressions.\r\nThis applies to: ORDER BY, PRIMARY KEY, and secondary indices.\r\n\r\nThe setting is checked on CREATE and ALTER queries but not on ATTACH query.\r\n\r\nIt should be 0 by default if `compatibility` is at least 22.10.\nMay I have a try ?\n@lingtaolf Thank you, this will be very helpful!\nThis task is available.",
  "created_at": "2023-04-07T10:58:05Z",
  "modified_files": [
    "src/Core/Settings.h",
    "src/Core/SettingsChangesHistory.h",
    "src/Storages/MergeTree/MergeTreeData.cpp",
    "src/Storages/MergeTree/MergeTreeData.h",
    "src/Storages/MergeTree/MergeTreeSettings.h",
    "src/Storages/StorageMergeTree.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02710_allow_suspicious_indices.sql"
  ]
}