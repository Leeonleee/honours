{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 9011,
  "instance_id": "ClickHouse__ClickHouse-9011",
  "issue_numbers": [
    "8971"
  ],
  "base_commit": "c902b27e25683aa143451b6ed52a3a1e502ad3f4",
  "patch": "diff --git a/dbms/src/Interpreters/InterpreterExplainQuery.cpp b/dbms/src/Interpreters/InterpreterExplainQuery.cpp\nindex fd97841a55d2..d6272a08f71a 100644\n--- a/dbms/src/Interpreters/InterpreterExplainQuery.cpp\n+++ b/dbms/src/Interpreters/InterpreterExplainQuery.cpp\n@@ -3,19 +3,91 @@\n #include <DataStreams/BlockIO.h>\n #include <DataStreams/OneBlockInputStream.h>\n #include <DataTypes/DataTypeString.h>\n+#include <Interpreters/InDepthNodeVisitor.h>\n+#include <Interpreters/IdentifierSemantic.h>\n+#include <Interpreters/getTableExpressions.h>\n #include <Interpreters/InterpreterSelectWithUnionQuery.h>\n-#include <Parsers/ASTExplainQuery.h>\n #include <Parsers/DumpASTNode.h>\n+#include <Parsers/ASTSubquery.h>\n #include <Parsers/queryToString.h>\n-#include <Common/typeid_cast.h>\n-#include <Core/Field.h>\n+#include <Parsers/ASTIdentifier.h>\n+#include <Parsers/ASTExplainQuery.h>\n+#include <Parsers/ASTTablesInSelectQuery.h>\n+#include <Parsers/ASTSelectWithUnionQuery.h>\n \n+#include <Core/Field.h>\n+#include <Common/typeid_cast.h>\n+#include <Storages/StorageView.h>\n #include <sstream>\n \n \n namespace DB\n {\n \n+namespace\n+{\n+    struct ExplainAnalyzedSyntaxMatcher\n+    {\n+        struct Data\n+        {\n+            bool analyzed = false;\n+            const Context & context;\n+        };\n+\n+        static bool needChildVisit(ASTPtr &, ASTPtr &) { return true; }\n+\n+        static void visit(ASTPtr & ast, Data & data)\n+        {\n+            if (auto * select_query = ast->as<ASTSelectQuery>())\n+                visit(*select_query, ast, data);\n+            if (auto * union_select_query = ast->as<ASTSelectWithUnionQuery>())\n+                visit(*union_select_query, ast, data);\n+        }\n+\n+        static void visit(ASTSelectQuery & select_query, ASTPtr &, Data & data)\n+        {\n+            if (!select_query.tables())\n+                return;\n+\n+            for (const auto & child : select_query.tables()->children)\n+            {\n+                auto * tables_element = child->as<ASTTablesInSelectQueryElement>();\n+\n+                if (tables_element && tables_element->table_expression)\n+                    visit(*tables_element->table_expression->as<ASTTableExpression>(), select_query, data);\n+            }\n+        }\n+\n+        static void visit(ASTSelectWithUnionQuery &, ASTPtr & node, Data & data)\n+        {\n+            if (!data.analyzed)\n+            {\n+                data.analyzed = true;\n+                InterpreterSelectWithUnionQuery interpreter(\n+                    node, data.context, SelectQueryOptions(QueryProcessingStage::FetchColumns).analyze().modify());\n+            }\n+        }\n+\n+        static void visit(ASTTableExpression & expression, ASTSelectQuery & select_query, Data & data)\n+        {\n+            if (data.context.getSettingsRef().enable_optimize_predicate_expression && expression.database_and_table_name)\n+            {\n+                if (const auto * identifier = expression.database_and_table_name->as<ASTIdentifier>())\n+                {\n+                    const auto & [database, table] = IdentifierSemantic::extractDatabaseAndTable(*identifier);\n+                    const auto & storage = data.context.getTable(database.empty() ? data.context.getCurrentDatabase() : database, table);\n+\n+                    if (auto * storage_view = dynamic_cast<StorageView *>(storage.get()))\n+                        storage_view->getRuntimeViewQuery(&select_query, data.context, true);\n+                }\n+            }\n+        }\n+    };\n+\n+    using ExplainAnalyzedSyntaxVisitor = InDepthNodeVisitor<ExplainAnalyzedSyntaxMatcher, true>;\n+\n+}\n+\n BlockIO InterpreterExplainQuery::execute()\n {\n     BlockIO res;\n@@ -52,10 +124,10 @@ BlockInputStreamPtr InterpreterExplainQuery::executeImpl()\n     }\n     else if (ast.getKind() == ASTExplainQuery::AnalyzedSyntax)\n     {\n-        InterpreterSelectWithUnionQuery interpreter(ast.children.at(0), context,\n-            SelectQueryOptions(QueryProcessingStage::FetchColumns).analyze().modify());\n+        ExplainAnalyzedSyntaxVisitor::Data data{.context = context};\n+        ExplainAnalyzedSyntaxVisitor(data).visit(query);\n \n-        interpreter.getQuery()->format(IAST::FormatSettings(ss, false));\n+        ast.children.at(0)->format(IAST::FormatSettings(ss, false));\n     }\n \n     res_columns[0]->insert(ss.str());\ndiff --git a/dbms/src/Storages/StorageView.cpp b/dbms/src/Storages/StorageView.cpp\nindex 8ac8a696ec75..47f74c8aad6f 100644\n--- a/dbms/src/Storages/StorageView.cpp\n+++ b/dbms/src/Storages/StorageView.cpp\n@@ -60,31 +60,7 @@ Pipes StorageView::read(\n     ASTPtr current_inner_query = inner_query;\n \n     if (context.getSettings().enable_optimize_predicate_expression)\n-    {\n-        auto new_inner_query = inner_query->clone();\n-        auto new_outer_query = query_info.query->clone();\n-        auto * new_outer_select = new_outer_query->as<ASTSelectQuery>();\n-\n-        replaceTableNameWithSubquery(new_outer_select, new_inner_query);\n-\n-        /// TODO: remove getTableExpressions and getTablesWithColumns\n-        {\n-            const auto & table_expressions = getTableExpressions(*new_outer_select);\n-            const auto & tables_with_columns = getDatabaseAndTablesWithColumnNames(table_expressions, context);\n-\n-            auto & settings = context.getSettingsRef();\n-            if (settings.joined_subquery_requires_alias && tables_with_columns.size() > 1)\n-            {\n-                for (auto & pr : tables_with_columns)\n-                    if (pr.table.table.empty() && pr.table.alias.empty())\n-                        throw Exception(\"Not unique subquery in FROM requires an alias (or joined_subquery_requires_alias=0 to disable restriction).\",\n-                            ErrorCodes::ALIAS_REQUIRED);\n-            }\n-\n-            if (PredicateExpressionsOptimizer(context, tables_with_columns, context.getSettings()).optimize(*new_outer_select))\n-                current_inner_query = new_inner_query;\n-        }\n-    }\n+        current_inner_query = getRuntimeViewQuery(*query_info.query->as<const ASTSelectQuery>(), context);\n \n     QueryPipeline pipeline;\n     InterpreterSelectWithUnionQuery interpreter(current_inner_query, context, {}, column_names);\n@@ -107,6 +83,41 @@ Pipes StorageView::read(\n     return pipes;\n }\n \n+ASTPtr StorageView::getRuntimeViewQuery(const ASTSelectQuery & outer_query, const Context & context)\n+{\n+    auto temp_outer_query = outer_query.clone();\n+    auto * new_outer_select = temp_outer_query->as<ASTSelectQuery>();\n+    return getRuntimeViewQuery(new_outer_select, context, false);\n+}\n+\n+\n+\n+ASTPtr StorageView::getRuntimeViewQuery(ASTSelectQuery * outer_query, const Context & context, bool normalize)\n+{\n+    auto runtime_view_query = inner_query->clone();\n+\n+    /// TODO: remove getTableExpressions and getTablesWithColumns\n+    {\n+        const auto & table_expressions = getTableExpressions(*outer_query);\n+        const auto & tables_with_columns = getDatabaseAndTablesWithColumnNames(table_expressions, context);\n+\n+        replaceTableNameWithSubquery(outer_query, runtime_view_query);\n+        if (context.getSettingsRef().joined_subquery_requires_alias && tables_with_columns.size() > 1)\n+        {\n+            for (auto & pr : tables_with_columns)\n+                if (pr.table.table.empty() && pr.table.alias.empty())\n+                    throw Exception(\"Not unique subquery in FROM requires an alias (or joined_subquery_requires_alias=0 to disable restriction).\",\n+                                    ErrorCodes::ALIAS_REQUIRED);\n+        }\n+\n+        if (PredicateExpressionsOptimizer(context, tables_with_columns, context.getSettings()).optimize(*outer_query) && normalize)\n+            InterpreterSelectWithUnionQuery(\n+                runtime_view_query, context, SelectQueryOptions(QueryProcessingStage::FetchColumns).analyze().modify(), {});\n+    }\n+\n+    return runtime_view_query;\n+}\n+\n void StorageView::replaceTableNameWithSubquery(ASTSelectQuery * select_query, ASTPtr & subquery)\n {\n     auto * select_element = select_query->tables()->children[0]->as<ASTTablesInSelectQueryElement>();\n@@ -123,6 +134,7 @@ void StorageView::replaceTableNameWithSubquery(ASTSelectQuery * select_query, AS\n     table_expression->database_and_table_name = {};\n     table_expression->subquery = std::make_shared<ASTSubquery>();\n     table_expression->subquery->children.push_back(subquery);\n+    table_expression->children.push_back(table_expression->subquery);\n     if (!alias.empty())\n         table_expression->subquery->setAlias(alias);\n }\ndiff --git a/dbms/src/Storages/StorageView.h b/dbms/src/Storages/StorageView.h\nindex 6b4bfd48ccc4..0e1e90ff612b 100644\n--- a/dbms/src/Storages/StorageView.h\n+++ b/dbms/src/Storages/StorageView.h\n@@ -29,6 +29,10 @@ class StorageView : public ext::shared_ptr_helper<StorageView>, public IStorage\n         size_t max_block_size,\n         unsigned num_streams) override;\n \n+    ASTPtr getRuntimeViewQuery(const ASTSelectQuery & outer_query, const Context & context);\n+\n+    ASTPtr getRuntimeViewQuery(ASTSelectQuery * outer_query, const Context & context, bool normalize);\n+\n private:\n     ASTPtr inner_query;\n \n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/01076_predicate_optimizer_with_view.reference b/dbms/tests/queries/0_stateless/01076_predicate_optimizer_with_view.reference\nnew file mode 100644\nindex 000000000000..1e92e7b85965\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01076_predicate_optimizer_with_view.reference\n@@ -0,0 +1,4 @@\n+SELECT \\n    date, \\n    id, \\n    name, \\n    value\\nFROM \\n(\\n    SELECT \\n        date, \\n        id, \\n        name, \\n        value\\n    FROM default.test\\n    WHERE id = 1\\n)\\nWHERE id = 1\n+SELECT \\n    date, \\n    id, \\n    name, \\n    value\\nFROM \\n(\\n    SELECT \\n        date, \\n        id, \\n        name, \\n        value\\n    FROM default.test\\n    WHERE id = 2\\n)\\nWHERE id = 2\n+SELECT id\\nFROM \\n(\\n    SELECT \\n        date, \\n        id, \\n        name, \\n        value\\n    FROM default.test\\n    WHERE id = 1\\n)\\nWHERE id = 1\n+SELECT id\\nFROM \\n(\\n    SELECT \\n        date, \\n        id, \\n        name, \\n        value\\n    FROM default.test\\n    WHERE id = 1\\n) AS s\\nWHERE id = 1\ndiff --git a/dbms/tests/queries/0_stateless/01076_predicate_optimizer_with_view.sql b/dbms/tests/queries/0_stateless/01076_predicate_optimizer_with_view.sql\nnew file mode 100644\nindex 000000000000..fa55a47e7687\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01076_predicate_optimizer_with_view.sql\n@@ -0,0 +1,19 @@\n+DROP TABLE IF EXISTS test;\n+DROP TABLE IF EXISTS test_view;\n+\n+CREATE TABLE test(date Date, id Int8, name String, value Int64) ENGINE = MergeTree(date, (id, date), 8192);\n+CREATE VIEW test_view AS SELECT * FROM test;\n+\n+SET enable_debug_queries = 1;\n+SET enable_optimize_predicate_expression = 1;\n+\n+-- Optimize predicate expression with view\n+ANALYZE SELECT * FROM test_view WHERE id = 1;\n+ANALYZE SELECT * FROM test_view WHERE id = 2;\n+ANALYZE SELECT id FROM test_view WHERE id  = 1;\n+ANALYZE SELECT s.id FROM test_view AS s WHERE s.id = 1;\n+\n+SELECT * FROM (SELECT toUInt64(b), sum(id) AS b FROM test) WHERE `toUInt64(sum(id))` = 3; -- { serverError 47 }\n+\n+DROP TABLE IF EXISTS test;\n+DROP TABLE IF EXISTS test_view;\ndiff --git a/dbms/tests/queries/bugs/00597_push_down_predicate.sql b/dbms/tests/queries/bugs/00597_push_down_predicate.sql\ndeleted file mode 100644\nindex 0de9522ab50e..000000000000\n--- a/dbms/tests/queries/bugs/00597_push_down_predicate.sql\n+++ /dev/null\n@@ -1,18 +0,0 @@\n-DROP TABLE IF EXISTS test.test;\n-DROP TABLE IF EXISTS test.test_view;\n-\n-CREATE TABLE test.test(date Date, id Int8, name String, value Int64) ENGINE = MergeTree(date, (id, date), 8192);\n-CREATE VIEW test.test_view AS SELECT * FROM test.test;\n-\n-SET enable_optimize_predicate_expression = 1;\n-SET enable_debug_queries = 1;\n-\n--- Optimize predicate expression with view\n--- TODO: simple view is not replaced with subquery inside syntax analyzer\n-ANALYZE SELECT * FROM test.test_view WHERE id = 1;\n-ANALYZE SELECT * FROM test.test_view WHERE id = 2;\n-ANALYZE SELECT id FROM test.test_view WHERE id  = 1;\n-ANALYZE SELECT s.id FROM test.test_view AS s WHERE s.id = 1;\n-\n--- TODO: this query shouldn't work, because the name `toUInt64(sum(id))` is undefined for user\n-SELECT * FROM (SELECT toUInt64(b), sum(id) AS b FROM test.test) WHERE `toUInt64(sum(id))` = 3;\n",
  "problem_statement": "Push down predicate for View doesn't work\nI have:\r\n1. table:\r\n`CREATE TABLE loadstat (`date` Date, `userId` String, `_id` String, `host` String) ENGINE = ReplacingMergeTree() PARTITION BY date ORDER BY (host, userId, _id) SETTINGS index_granularity = 8192`\r\n\r\n2. data:\r\n`INSERT INTO loadstat SELECT toDate(now() - (1000000 - number) * 1) AS date, toUUID(number % 1000) AS userId, toUUID(number), CONCAT('ya', toString(number % 1000), '.ru') FROM system.numbers LIMIT 1000000 SETTINGS max_partitions_per_insert_block = 100000`\r\n\r\n2. view for table:\r\n`CREATE VIEW loadstat_view (`date` Date, `userId` String, `_id` String, `host` String) AS SELECT * FROM loadstat ` \r\n\r\nWhen I do query for table:\r\n`SELECT \r\n    toStartOfMonth(date) AS dt, \r\n    count(*)\r\nFROM loadstat\r\nWHERE date >= '2020-01-29'\r\nGROUP BY dt\r\nORDER BY dt ASC`\r\nit works as expected:\r\n`2 rows in set. Elapsed: 0.008 sec. Processed 481.12 thousand rows, 962.23 KB (63.99 million rows/s., 127.98 MB/s.)` - Clickhouse uses predicate `date >= '2020-01-29'` for table.\r\n\r\nBut if I do query for view I get:\r\n`2 rows in set. Elapsed: 0.024 sec. Processed 1.00 million rows, 2.00 MB (41.20 million rows/s., 82.39 MB/s.) ` - I get full scan all table's data\r\n\r\nOptimizations `enable_optimize_predicate_expression` and `enable_optimize_predicate_expression_to_final_subquery` are enable.\r\n\r\nBefore update to 20.1.3.7 push down predicate used to work\n",
  "hints_text": "Related #6767 #6972",
  "created_at": "2020-02-05T11:45:02Z"
}