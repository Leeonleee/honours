{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 9163,
  "instance_id": "ClickHouse__ClickHouse-9163",
  "issue_numbers": [
    "9160"
  ],
  "base_commit": "d4381d797624adb268941530ed3e82fdb46bbf0d",
  "patch": "diff --git a/dbms/src/Common/OptimizedRegularExpression.cpp b/dbms/src/Common/OptimizedRegularExpression.cpp\nindex 3a2247094478..6c06a28c343f 100644\n--- a/dbms/src/Common/OptimizedRegularExpression.cpp\n+++ b/dbms/src/Common/OptimizedRegularExpression.cpp\n@@ -290,31 +290,44 @@ OptimizedRegularExpressionImpl<thread_safe>::OptimizedRegularExpressionImpl(cons\n                 throw DB::Exception(\"OptimizedRegularExpression: too many subpatterns in regexp: \" + regexp_, DB::ErrorCodes::CANNOT_COMPILE_REGEXP);\n         }\n     }\n+\n+    if (!required_substring.empty())\n+    {\n+        if (is_case_insensitive)\n+            case_insensitive_substring_searcher.emplace(required_substring.data(), required_substring.size());\n+        else\n+            case_sensitive_substring_searcher.emplace(required_substring.data(), required_substring.size());\n+    }\n }\n \n \n template <bool thread_safe>\n bool OptimizedRegularExpressionImpl<thread_safe>::match(const char * subject, size_t subject_size) const\n {\n+    const UInt8 * haystack = reinterpret_cast<const UInt8 *>(subject);\n+    const UInt8 * haystack_end = haystack + subject_size;\n+\n     if (is_trivial)\n     {\n         if (is_case_insensitive)\n-            return nullptr != strcasestr(subject, required_substring.data());\n+            return haystack_end != case_insensitive_substring_searcher->search(haystack, subject_size);\n         else\n-            return nullptr != strstr(subject, required_substring.data());\n+            return haystack_end != case_sensitive_substring_searcher->search(haystack, subject_size);\n     }\n     else\n     {\n         if (!required_substring.empty())\n         {\n-            const char * pos;\n             if (is_case_insensitive)\n-                pos = strcasestr(subject, required_substring.data());\n+            {\n+                if (haystack_end == case_insensitive_substring_searcher->search(haystack, subject_size))\n+                    return false;\n+            }\n             else\n-                pos = strstr(subject, required_substring.data());\n-\n-            if (nullptr == pos)\n-                return 0;\n+            {\n+                if (haystack_end == case_sensitive_substring_searcher->search(haystack, subject_size))\n+                    return false;\n+            }\n         }\n \n         return re2->Match(StringPieceType(subject, subject_size), 0, subject_size, RegexType::UNANCHORED, nullptr, 0);\n@@ -325,19 +338,22 @@ bool OptimizedRegularExpressionImpl<thread_safe>::match(const char * subject, si\n template <bool thread_safe>\n bool OptimizedRegularExpressionImpl<thread_safe>::match(const char * subject, size_t subject_size, Match & match) const\n {\n+    const UInt8 * haystack = reinterpret_cast<const UInt8 *>(subject);\n+    const UInt8 * haystack_end = haystack + subject_size;\n+\n     if (is_trivial)\n     {\n-        const char * pos;\n+        const UInt8 * pos;\n         if (is_case_insensitive)\n-            pos = strcasestr(subject, required_substring.data());\n+            pos = case_insensitive_substring_searcher->search(haystack, subject_size);\n         else\n-            pos = strstr(subject, required_substring.data());\n+            pos = case_sensitive_substring_searcher->search(haystack, subject_size);\n \n-        if (pos == nullptr)\n-            return 0;\n+        if (haystack_end == pos)\n+            return false;\n         else\n         {\n-            match.offset = pos - subject;\n+            match.offset = pos - haystack;\n             match.length = required_substring.size();\n             return 1;\n         }\n@@ -346,25 +362,25 @@ bool OptimizedRegularExpressionImpl<thread_safe>::match(const char * subject, si\n     {\n         if (!required_substring.empty())\n         {\n-            const char * pos;\n+            const UInt8 * pos;\n             if (is_case_insensitive)\n-                pos = strcasestr(subject, required_substring.data());\n+                pos = case_insensitive_substring_searcher->search(haystack, subject_size);\n             else\n-                pos = strstr(subject, required_substring.data());\n+                pos = case_sensitive_substring_searcher->search(haystack, subject_size);\n \n-            if (nullptr == pos)\n-                return 0;\n+            if (haystack_end == pos)\n+                return false;\n         }\n \n         StringPieceType piece;\n \n         if (!RegexType::PartialMatch(StringPieceType(subject, subject_size), *re2, &piece))\n-            return 0;\n+            return false;\n         else\n         {\n             match.offset = piece.data() - subject;\n             match.length = piece.length();\n-            return 1;\n+            return true;\n         }\n     }\n }\n@@ -373,6 +389,9 @@ bool OptimizedRegularExpressionImpl<thread_safe>::match(const char * subject, si\n template <bool thread_safe>\n unsigned OptimizedRegularExpressionImpl<thread_safe>::match(const char * subject, size_t subject_size, MatchVec & matches, unsigned limit) const\n {\n+    const UInt8 * haystack = reinterpret_cast<const UInt8 *>(subject);\n+    const UInt8 * haystack_end = haystack + subject_size;\n+\n     matches.clear();\n \n     if (limit == 0)\n@@ -383,18 +402,18 @@ unsigned OptimizedRegularExpressionImpl<thread_safe>::match(const char * subject\n \n     if (is_trivial)\n     {\n-        const char * pos;\n+        const UInt8 * pos;\n         if (is_case_insensitive)\n-            pos = strcasestr(subject, required_substring.data());\n+            pos = case_insensitive_substring_searcher->search(haystack, subject_size);\n         else\n-            pos = strstr(subject, required_substring.data());\n+            pos = case_sensitive_substring_searcher->search(haystack, subject_size);\n \n-        if (pos == nullptr)\n+        if (haystack_end == pos)\n             return 0;\n         else\n         {\n             Match match;\n-            match.offset = pos - subject;\n+            match.offset = pos - haystack;\n             match.length = required_substring.size();\n             matches.push_back(match);\n             return 1;\n@@ -404,17 +423,17 @@ unsigned OptimizedRegularExpressionImpl<thread_safe>::match(const char * subject\n     {\n         if (!required_substring.empty())\n         {\n-            const char * pos;\n+            const UInt8 * pos;\n             if (is_case_insensitive)\n-                pos = strcasestr(subject, required_substring.data());\n+                pos = case_insensitive_substring_searcher->search(haystack, subject_size);\n             else\n-                pos = strstr(subject, required_substring.data());\n+                pos = case_sensitive_substring_searcher->search(haystack, subject_size);\n \n-            if (nullptr == pos)\n+            if (haystack_end == pos)\n                 return 0;\n         }\n \n-        DB::PODArrayWithStackMemory<StringPieceType, sizeof(StringPieceType) * (MAX_SUBPATTERNS+1)> pieces(limit);\n+        DB::PODArrayWithStackMemory<StringPieceType, sizeof(StringPieceType) * (MAX_SUBPATTERNS + 1)> pieces(limit);\n \n         if (!re2->Match(StringPieceType(subject, subject_size), 0, subject_size, RegexType::UNANCHORED, pieces.data(), pieces.size()))\n             return 0;\ndiff --git a/dbms/src/Common/OptimizedRegularExpression.h b/dbms/src/Common/OptimizedRegularExpression.h\nindex ccbd8a517d2c..0c31558cecb9 100644\n--- a/dbms/src/Common/OptimizedRegularExpression.h\n+++ b/dbms/src/Common/OptimizedRegularExpression.h\n@@ -3,6 +3,8 @@\n #include <string>\n #include <vector>\n #include <memory>\n+#include <optional>\n+#include <Common/StringSearcher.h>\n #include <Common/config.h>\n #include <re2/re2.h>\n #if USE_RE2_ST\n@@ -101,6 +103,8 @@ class OptimizedRegularExpressionImpl\n     bool required_substring_is_prefix;\n     bool is_case_insensitive;\n     std::string required_substring;\n+    std::optional<DB::StringSearcher<true, true>> case_sensitive_substring_searcher;\n+    std::optional<DB::StringSearcher<false, true>> case_insensitive_substring_searcher;\n     std::unique_ptr<RegexType> re2;\n     unsigned number_of_subpatterns;\n };\ndiff --git a/dbms/src/Common/StringSearcher.h b/dbms/src/Common/StringSearcher.h\nindex d395e6f254a8..b399a256052c 100644\n--- a/dbms/src/Common/StringSearcher.h\n+++ b/dbms/src/Common/StringSearcher.h\n@@ -222,6 +222,8 @@ class StringSearcher<false, false> : private StringSearcherBase\n         return false;\n     }\n \n+    /** Returns haystack_end if not found.\n+      */\n     const UInt8 * search(const UInt8 * haystack, const UInt8 * const haystack_end) const\n     {\n         if (0 == needle_size)\ndiff --git a/dbms/src/DataStreams/IBlockInputStream.h b/dbms/src/DataStreams/IBlockInputStream.h\nindex 7ca415512983..095e41717cc5 100644\n--- a/dbms/src/DataStreams/IBlockInputStream.h\n+++ b/dbms/src/DataStreams/IBlockInputStream.h\n@@ -284,7 +284,7 @@ class IBlockInputStream : public TypePromotion<IBlockInputStream>\n     /// The approximate total number of rows to read. For progress bar.\n     size_t total_rows_approx = 0;\n \n-    /// The successors must implement this function.\n+    /// Derived classes must implement this function.\n     virtual Block readImpl() = 0;\n \n     /// Here you can do a preliminary initialization.\ndiff --git a/dbms/src/Functions/FunctionsStringRegex.cpp b/dbms/src/Functions/FunctionsStringRegex.cpp\nindex dc8bbc9a9372..ec515395c069 100644\n--- a/dbms/src/Functions/FunctionsStringRegex.cpp\n+++ b/dbms/src/Functions/FunctionsStringRegex.cpp\n@@ -89,6 +89,8 @@ inline bool likePatternIsStrstr(const String & pattern, String & res)\n template <bool like, bool revert = false>\n struct MatchImpl\n {\n+    static constexpr bool use_default_implementation_for_constants = true;\n+\n     using ResultType = UInt8;\n \n     static void vector_constant(\n@@ -240,12 +242,6 @@ struct MatchImpl\n         }\n     }\n \n-    static void constant_constant(const std::string & data, const std::string & pattern, UInt8 & res)\n-    {\n-        const auto & regexp = Regexps::get<like, true>(pattern);\n-        res = revert ^ regexp->match(data);\n-    }\n-\n     template <typename... Args>\n     static void vector_vector(Args &&...)\n     {\n@@ -846,29 +842,6 @@ struct ReplaceStringImpl\n #undef COPY_REST_OF_CURRENT_STRING\n         }\n     }\n-\n-    static void constant(const std::string & data, const std::string & needle, const std::string & replacement, std::string & res_data)\n-    {\n-        res_data = \"\";\n-        int replace_cnt = 0;\n-        for (size_t i = 0; i < data.size(); ++i)\n-        {\n-            bool match = true;\n-            if (i + needle.size() > data.size() || (replace_one && replace_cnt > 0))\n-                match = false;\n-            for (size_t j = 0; match && j < needle.size(); ++j)\n-                if (data[i + j] != needle[j])\n-                    match = false;\n-            if (match)\n-            {\n-                ++replace_cnt;\n-                res_data += replacement;\n-                i = i + needle.size() - 1;\n-            }\n-            else\n-                res_data += data[i];\n-        }\n-    }\n };\n \n \ndiff --git a/dbms/src/Functions/FunctionsStringSearch.cpp b/dbms/src/Functions/FunctionsStringSearch.cpp\nindex c39d536927ce..6c20cdaf0684 100644\n--- a/dbms/src/Functions/FunctionsStringSearch.cpp\n+++ b/dbms/src/Functions/FunctionsStringSearch.cpp\n@@ -146,6 +146,8 @@ struct PositionCaseInsensitiveUTF8\n template <typename Impl>\n struct PositionImpl\n {\n+    static constexpr bool use_default_implementation_for_constants = false;\n+\n     using ResultType = UInt64;\n \n     /// Find one substring in many strings.\n@@ -459,6 +461,8 @@ struct HasTokenImpl\n {\n     using ResultType = UInt8;\n \n+    static constexpr bool use_default_implementation_for_constants = true;\n+\n     static void vector_constant(\n         const ColumnString::Chars & data, const ColumnString::Offsets & offsets, const std::string & pattern, PaddedPODArray<UInt8> & res)\n     {\n@@ -499,13 +503,6 @@ struct HasTokenImpl\n             memset(&res[i], negate_result, (res.size() - i) * sizeof(res[0]));\n     }\n \n-    static void constant_constant(const std::string & data, const std::string & pattern, UInt8 & res)\n-    {\n-        TokenSearcher searcher(pattern.data(), pattern.size(), data.size());\n-        const auto found = searcher.search(data.c_str(), data.size()) != data.end().base();\n-        res = negate_result ^ found;\n-    }\n-\n     template <typename... Args>\n     static void vector_vector(Args &&...)\n     {\ndiff --git a/dbms/src/Functions/FunctionsStringSearch.h b/dbms/src/Functions/FunctionsStringSearch.h\nindex 03fdfe22b95b..8cbf92902ab1 100644\n--- a/dbms/src/Functions/FunctionsStringSearch.h\n+++ b/dbms/src/Functions/FunctionsStringSearch.h\n@@ -82,6 +82,15 @@ class FunctionsStringSearch : public IFunction\n \n     size_t getNumberOfArguments() const override { return 2; }\n \n+    bool useDefaultImplementationForConstants() const override { return Impl::use_default_implementation_for_constants; }\n+\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override\n+    {\n+        return Impl::use_default_implementation_for_constants\n+            ? ColumnNumbers{1, 2}\n+            : ColumnNumbers{};\n+    }\n+\n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n         if (!isString(arguments[0]))\n@@ -105,13 +114,16 @@ class FunctionsStringSearch : public IFunction\n         const ColumnConst * col_haystack_const = typeid_cast<const ColumnConst *>(&*column_haystack);\n         const ColumnConst * col_needle_const = typeid_cast<const ColumnConst *>(&*column_needle);\n \n-        if (col_haystack_const && col_needle_const)\n+        if constexpr (!Impl::use_default_implementation_for_constants)\n         {\n-            ResultType res{};\n-            Impl::constant_constant(col_haystack_const->getValue<String>(), col_needle_const->getValue<String>(), res);\n-            block.getByPosition(result).column\n-                = block.getByPosition(result).type->createColumnConst(col_haystack_const->size(), toField(res));\n-            return;\n+            if (col_haystack_const && col_needle_const)\n+            {\n+                ResultType res{};\n+                Impl::constant_constant(col_haystack_const->getValue<String>(), col_needle_const->getValue<String>(), res);\n+                block.getByPosition(result).column\n+                    = block.getByPosition(result).type->createColumnConst(col_haystack_const->size(), toField(res));\n+                return;\n+            }\n         }\n \n         auto col_res = ColumnVector<ResultType>::create();\ndiff --git a/dbms/src/Functions/FunctionsVisitParam.h b/dbms/src/Functions/FunctionsVisitParam.h\nindex 99d84f8bc6da..03dee724fd79 100644\n--- a/dbms/src/Functions/FunctionsVisitParam.h\n+++ b/dbms/src/Functions/FunctionsVisitParam.h\n@@ -78,6 +78,8 @@ struct ExtractParamImpl\n {\n     using ResultType = typename ParamExtractor::ResultType;\n \n+    static constexpr bool use_default_implementation_for_constants = true;\n+\n     /// It is assumed that `res` is the correct size and initialized with zeros.\n     static void vector_constant(const ColumnString::Chars & data, const ColumnString::Offsets & offsets,\n         std::string needle,\n@@ -119,19 +121,6 @@ struct ExtractParamImpl\n             memset(&res[i], 0, (res.size() - i) * sizeof(res[0]));\n     }\n \n-    static void constant_constant(const std::string & data, std::string needle, ResultType & res)\n-    {\n-        needle = \"\\\"\" + needle + \"\\\":\";\n-        size_t pos = data.find(needle);\n-        if (pos == std::string::npos)\n-            res = 0;\n-        else\n-            res = ParamExtractor::extract(\n-                reinterpret_cast<const UInt8 *>(data.data() + pos + needle.size()),\n-                reinterpret_cast<const UInt8 *>(data.data() + data.size())\n-            );\n-    }\n-\n     template <typename... Args> static void vector_vector(Args &&...)\n     {\n         throw Exception(\"Functions 'visitParamHas' and 'visitParamExtract*' doesn't support non-constant needle argument\", ErrorCodes::ILLEGAL_COLUMN);\ndiff --git a/dbms/src/IO/WriteBuffer.h b/dbms/src/IO/WriteBuffer.h\nindex 25c93b227e39..b8bf53e18fd9 100644\n--- a/dbms/src/IO/WriteBuffer.h\n+++ b/dbms/src/IO/WriteBuffer.h\n@@ -22,7 +22,7 @@ namespace ErrorCodes\n   * Unlike std::ostream, it provides access to the internal buffer,\n   *  and also allows you to manually manage the position inside the buffer.\n   *\n-  * The successors must implement the nextImpl() method.\n+  * Derived classes must implement the nextImpl() method.\n   */\n class WriteBuffer : public BufferBase\n {\n@@ -55,7 +55,7 @@ class WriteBuffer : public BufferBase\n         pos = working_buffer.begin();\n     }\n \n-    /** it is desirable in the successors to place the next() call in the destructor,\n+    /** it is desirable in the derived classes to place the next() call in the destructor,\n       * so that the last data is written\n       */\n     virtual ~WriteBuffer() {}\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/01083_match_zero_byte.reference b/dbms/tests/queries/0_stateless/01083_match_zero_byte.reference\nnew file mode 100644\nindex 000000000000..54ad37c27b0d\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01083_match_zero_byte.reference\n@@ -0,0 +1,264 @@\n+1\n+1\n+1\n+1\n+1\n+1\n+4 key=\"v\" \t10\tv\n+\\0 key=\"v\" \t10\tv\n+0\tv\n+1\tv\n+2\tv\n+3\tv\n+4\tv\n+5\tv\n+6\tv\n+7\tv\n+8\tv\n+9\tv\n+10\tv\n+11\tv\n+12\tv\n+13\tv\n+14\tv\n+15\tv\n+16\tv\n+17\tv\n+18\tv\n+19\tv\n+20\tv\n+21\tv\n+22\tv\n+23\tv\n+24\tv\n+25\tv\n+26\tv\n+27\tv\n+28\tv\n+29\tv\n+30\tv\n+31\tv\n+32\tv\n+33\tv\n+34\tv\n+35\tv\n+36\tv\n+37\tv\n+38\tv\n+39\tv\n+40\tv\n+41\tv\n+42\tv\n+43\tv\n+44\tv\n+45\tv\n+46\tv\n+47\tv\n+48\tv\n+49\tv\n+50\tv\n+51\tv\n+52\tv\n+53\tv\n+54\tv\n+55\tv\n+56\tv\n+57\tv\n+58\tv\n+59\tv\n+60\tv\n+61\tv\n+62\tv\n+63\tv\n+64\tv\n+65\tv\n+66\tv\n+67\tv\n+68\tv\n+69\tv\n+70\tv\n+71\tv\n+72\tv\n+73\tv\n+74\tv\n+75\tv\n+76\tv\n+77\tv\n+78\tv\n+79\tv\n+80\tv\n+81\tv\n+82\tv\n+83\tv\n+84\tv\n+85\tv\n+86\tv\n+87\tv\n+88\tv\n+89\tv\n+90\tv\n+91\tv\n+92\tv\n+93\tv\n+94\tv\n+95\tv\n+96\tv\n+97\tv\n+98\tv\n+99\tv\n+100\tv\n+101\tv\n+102\tv\n+103\tv\n+104\tv\n+105\tv\n+106\tv\n+107\tv\n+108\tv\n+109\tv\n+110\tv\n+111\tv\n+112\tv\n+113\tv\n+114\tv\n+115\tv\n+116\tv\n+117\tv\n+118\tv\n+119\tv\n+120\tv\n+121\tv\n+122\tv\n+123\tv\n+124\tv\n+125\tv\n+126\tv\n+127\tv\n+128\tv\n+129\tv\n+130\tv\n+131\tv\n+132\tv\n+133\tv\n+134\tv\n+135\tv\n+136\tv\n+137\tv\n+138\tv\n+139\tv\n+140\tv\n+141\tv\n+142\tv\n+143\tv\n+144\tv\n+145\tv\n+146\tv\n+147\tv\n+148\tv\n+149\tv\n+150\tv\n+151\tv\n+152\tv\n+153\tv\n+154\tv\n+155\tv\n+156\tv\n+157\tv\n+158\tv\n+159\tv\n+160\tv\n+161\tv\n+162\tv\n+163\tv\n+164\tv\n+165\tv\n+166\tv\n+167\tv\n+168\tv\n+169\tv\n+170\tv\n+171\tv\n+172\tv\n+173\tv\n+174\tv\n+175\tv\n+176\tv\n+177\tv\n+178\tv\n+179\tv\n+180\tv\n+181\tv\n+182\tv\n+183\tv\n+184\tv\n+185\tv\n+186\tv\n+187\tv\n+188\tv\n+189\tv\n+190\tv\n+191\tv\n+192\tv\n+193\tv\n+194\tv\n+195\tv\n+196\tv\n+197\tv\n+198\tv\n+199\tv\n+200\tv\n+201\tv\n+202\tv\n+203\tv\n+204\tv\n+205\tv\n+206\tv\n+207\tv\n+208\tv\n+209\tv\n+210\tv\n+211\tv\n+212\tv\n+213\tv\n+214\tv\n+215\tv\n+216\tv\n+217\tv\n+218\tv\n+219\tv\n+220\tv\n+221\tv\n+222\tv\n+223\tv\n+224\tv\n+225\tv\n+226\tv\n+227\tv\n+228\tv\n+229\tv\n+230\tv\n+231\tv\n+232\tv\n+233\tv\n+234\tv\n+235\tv\n+236\tv\n+237\tv\n+238\tv\n+239\tv\n+240\tv\n+241\tv\n+242\tv\n+243\tv\n+244\tv\n+245\tv\n+246\tv\n+247\tv\n+248\tv\n+249\tv\n+250\tv\n+251\tv\n+252\tv\n+253\tv\n+254\tv\n+255\tv\ndiff --git a/dbms/tests/queries/0_stateless/01083_match_zero_byte.sql b/dbms/tests/queries/0_stateless/01083_match_zero_byte.sql\nnew file mode 100644\nindex 000000000000..c3498bcd45c2\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01083_match_zero_byte.sql\n@@ -0,0 +1,17 @@\n+select match('a key=\"v\" ', 'key=\"(.*?)\"');\n+select match(materialize('a key=\"v\" '), 'key=\"(.*?)\"');\n+\n+select match('\\0 key=\"v\" ', 'key=\"(.*?)\"');\n+select match(materialize('\\0 key=\"v\" '), 'key=\"(.*?)\"');\n+\n+select multiMatchAny('\\0 key=\"v\" ', ['key=\"(.*?)\"']);\n+select multiMatchAny(materialize('\\0 key=\"v\" '), ['key=\"(.*?)\"']);\n+\n+select unhex('34') || ' key=\"v\" ' as haystack, length(haystack), extract( haystack, 'key=\"(.*?)\"') as needle;\n+-- works, result = v\n+\n+select unhex('00') || ' key=\"v\" ' as haystack, length(haystack), extract( haystack, 'key=\"(.*?)\"') as needle;\n+-- before fix: returns nothing (zero-byte in the begining of haystack)\n+\n+select number as char_code,  extract( char(char_code) || ' key=\"v\" ' as haystack, 'key=\"(.*?)\"') as needle from numbers(256);\n+-- every other chars codes (except of zero byte) works ok\n",
  "problem_statement": "zero-byte disturbs further regexp matching\n```\r\nselect unhex('34') || ' key=\"v\" ' as haystack, length(haystack), extract( haystack, 'key=\"(.*?)\"') as needle;\r\n-- works, result = v\r\n\r\nselect unhex('00') || ' key=\"v\" ' as haystack, length(haystack), extract( haystack, 'key=\"(.*?)\"') as needle;\r\n-- returns nothing (zero-byte in the begining of haystack)\r\n\r\nselect number as char_code,  extract( char(char_code) || ' key=\"v\" ' as haystack, 'key=\"(.*?)\"') as needle from numbers(256);\r\n-- every other chars codes (except of zero byte) works ok\r\n```\n",
  "hints_text": "It looks like the deficiency of `re2` library. **Upd: untrue.**\r\nIt also does not support zero bytes in regexp.\nIf use `hyperscan` instead of `re2`, everything is Ok:\r\n\r\n`select match('\\0 key=\"v\" ', 'key=\"(.*?)\"')`\r\n0\r\n\r\n`select multiMatchAny('\\0 key=\"v\" ', ['key=\"(.*?)\"'])`\r\n1",
  "created_at": "2020-02-17T18:55:22Z",
  "modified_files": [
    "dbms/src/Common/OptimizedRegularExpression.cpp",
    "dbms/src/Common/OptimizedRegularExpression.h",
    "dbms/src/Common/StringSearcher.h",
    "dbms/src/DataStreams/IBlockInputStream.h",
    "dbms/src/Functions/FunctionsStringRegex.cpp",
    "dbms/src/Functions/FunctionsStringSearch.cpp",
    "dbms/src/Functions/FunctionsStringSearch.h",
    "dbms/src/Functions/FunctionsVisitParam.h",
    "dbms/src/IO/WriteBuffer.h"
  ],
  "modified_test_files": [
    "b/dbms/tests/queries/0_stateless/01083_match_zero_byte.reference",
    "b/dbms/tests/queries/0_stateless/01083_match_zero_byte.sql"
  ]
}