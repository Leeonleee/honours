diff --git a/src/Common/ColumnsHashingImpl.h b/src/Common/ColumnsHashingImpl.h
index d68171a6566c..6b3cc24d870d 100644
--- a/src/Common/ColumnsHashingImpl.h
+++ b/src/Common/ColumnsHashingImpl.h
@@ -46,28 +46,45 @@ struct LastElementCacheStats
 namespace columns_hashing_impl
 {
 
-template <typename Value, bool consecutive_keys_optimization_>
-struct LastElementCache
+struct LastElementCacheBase
 {
-    static constexpr bool consecutive_keys_optimization = consecutive_keys_optimization_;
-
-    Value value;
     bool empty = true;
     bool found = false;
     UInt64 misses = 0;
 
-    bool check(const Value & value_) const { return value == value_; }
+    void onNewValue(bool is_found)
+    {
+        empty = false;
+        found = is_found;
+        ++misses;
+    }
+
+    bool hasOnlyOneValue() const { return found && misses == 1; }
+};
+
+template <typename Value, bool nullable> struct LastElementCache;
+
+template <typename Value>
+struct LastElementCache<Value, true> : public LastElementCacheBase
+{
+    Value value{};
+    bool is_null = false;
 
     template <typename Key>
-    bool check(const Key & key) const { return value.first == key; }
+    bool check(const Key & key) const { return !is_null && value.first == key; }
 
-    bool hasOnlyOneValue() const { return found && misses == 1; }
+    bool check(const Value & rhs) const { return !is_null && value == rhs; }
 };
 
-template <typename Data>
-struct LastElementCache<Data, false>
+template <typename Value>
+struct LastElementCache<Value, false> : public LastElementCacheBase
 {
-    static constexpr bool consecutive_keys_optimization = false;
+    Value value{};
+
+    template <typename Key>
+    bool check(const Key & key) const { return value.first == key; }
+
+    bool check(const Value & rhs) const { return value == rhs; }
 };
 
 template <typename Mapped>
@@ -161,7 +178,7 @@ class HashMethodBase
     using EmplaceResult = EmplaceResultImpl<Mapped>;
     using FindResult = FindResultImpl<Mapped, need_offset>;
     static constexpr bool has_mapped = !std::is_same_v<Mapped, void>;
-    using Cache = LastElementCache<Value, consecutive_keys_optimization>;
+    using Cache = LastElementCache<Value, nullable>;
 
     static HashMethodContextPtr createContext(const HashMethodContext::Settings &) { return nullptr; }
 
@@ -172,6 +189,15 @@ class HashMethodBase
         {
             if (isNullAt(row))
             {
+                if constexpr (consecutive_keys_optimization)
+                {
+                    if (!cache.is_null)
+                    {
+                        cache.onNewValue(true);
+                        cache.is_null = true;
+                    }
+                }
+
                 bool has_null_key = data.hasNullKeyData();
                 data.hasNullKeyData() = true;
 
@@ -193,10 +219,21 @@ class HashMethodBase
         {
             if (isNullAt(row))
             {
+                bool has_null_key = data.hasNullKeyData();
+
+                if constexpr (consecutive_keys_optimization)
+                {
+                    if (!cache.is_null)
+                    {
+                        cache.onNewValue(has_null_key);
+                        cache.is_null = true;
+                    }
+                }
+
                 if constexpr (has_mapped)
-                    return FindResult(&data.getNullKeyData(), data.hasNullKeyData(), 0);
+                    return FindResult(&data.getNullKeyData(), has_null_key, 0);
                 else
-                    return FindResult(data.hasNullKeyData(), 0);
+                    return FindResult(has_null_key, 0);
             }
         }
 
@@ -303,9 +340,10 @@ class HashMethodBase
 
         if constexpr (consecutive_keys_optimization)
         {
-            cache.found = true;
-            cache.empty = false;
-            ++cache.misses;
+            cache.onNewValue(true);
+
+            if constexpr (nullable)
+                cache.is_null = false;
 
             if constexpr (has_mapped)
             {
@@ -346,17 +384,16 @@ class HashMethodBase
 
         if constexpr (consecutive_keys_optimization)
         {
-            cache.found = it != nullptr;
-            cache.empty = false;
-            ++cache.misses;
+            cache.onNewValue(it != nullptr);
+
+            if constexpr (nullable)
+                cache.is_null = false;
 
             if constexpr (has_mapped)
             {
                 cache.value.first = key;
                 if (it)
-                {
                     cache.value.second = it->getMapped();
-                }
             }
             else
             {
