{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 61393,
  "instance_id": "ClickHouse__ClickHouse-61393",
  "issue_numbers": [
    "61313"
  ],
  "base_commit": "5e5a39d03994b44dbeab8bf0e20820faf2abae94",
  "patch": "diff --git a/src/Common/ColumnsHashingImpl.h b/src/Common/ColumnsHashingImpl.h\nindex d68171a6566c..6b3cc24d870d 100644\n--- a/src/Common/ColumnsHashingImpl.h\n+++ b/src/Common/ColumnsHashingImpl.h\n@@ -46,28 +46,45 @@ struct LastElementCacheStats\n namespace columns_hashing_impl\n {\n \n-template <typename Value, bool consecutive_keys_optimization_>\n-struct LastElementCache\n+struct LastElementCacheBase\n {\n-    static constexpr bool consecutive_keys_optimization = consecutive_keys_optimization_;\n-\n-    Value value;\n     bool empty = true;\n     bool found = false;\n     UInt64 misses = 0;\n \n-    bool check(const Value & value_) const { return value == value_; }\n+    void onNewValue(bool is_found)\n+    {\n+        empty = false;\n+        found = is_found;\n+        ++misses;\n+    }\n+\n+    bool hasOnlyOneValue() const { return found && misses == 1; }\n+};\n+\n+template <typename Value, bool nullable> struct LastElementCache;\n+\n+template <typename Value>\n+struct LastElementCache<Value, true> : public LastElementCacheBase\n+{\n+    Value value{};\n+    bool is_null = false;\n \n     template <typename Key>\n-    bool check(const Key & key) const { return value.first == key; }\n+    bool check(const Key & key) const { return !is_null && value.first == key; }\n \n-    bool hasOnlyOneValue() const { return found && misses == 1; }\n+    bool check(const Value & rhs) const { return !is_null && value == rhs; }\n };\n \n-template <typename Data>\n-struct LastElementCache<Data, false>\n+template <typename Value>\n+struct LastElementCache<Value, false> : public LastElementCacheBase\n {\n-    static constexpr bool consecutive_keys_optimization = false;\n+    Value value{};\n+\n+    template <typename Key>\n+    bool check(const Key & key) const { return value.first == key; }\n+\n+    bool check(const Value & rhs) const { return value == rhs; }\n };\n \n template <typename Mapped>\n@@ -161,7 +178,7 @@ class HashMethodBase\n     using EmplaceResult = EmplaceResultImpl<Mapped>;\n     using FindResult = FindResultImpl<Mapped, need_offset>;\n     static constexpr bool has_mapped = !std::is_same_v<Mapped, void>;\n-    using Cache = LastElementCache<Value, consecutive_keys_optimization>;\n+    using Cache = LastElementCache<Value, nullable>;\n \n     static HashMethodContextPtr createContext(const HashMethodContext::Settings &) { return nullptr; }\n \n@@ -172,6 +189,15 @@ class HashMethodBase\n         {\n             if (isNullAt(row))\n             {\n+                if constexpr (consecutive_keys_optimization)\n+                {\n+                    if (!cache.is_null)\n+                    {\n+                        cache.onNewValue(true);\n+                        cache.is_null = true;\n+                    }\n+                }\n+\n                 bool has_null_key = data.hasNullKeyData();\n                 data.hasNullKeyData() = true;\n \n@@ -193,10 +219,21 @@ class HashMethodBase\n         {\n             if (isNullAt(row))\n             {\n+                bool has_null_key = data.hasNullKeyData();\n+\n+                if constexpr (consecutive_keys_optimization)\n+                {\n+                    if (!cache.is_null)\n+                    {\n+                        cache.onNewValue(has_null_key);\n+                        cache.is_null = true;\n+                    }\n+                }\n+\n                 if constexpr (has_mapped)\n-                    return FindResult(&data.getNullKeyData(), data.hasNullKeyData(), 0);\n+                    return FindResult(&data.getNullKeyData(), has_null_key, 0);\n                 else\n-                    return FindResult(data.hasNullKeyData(), 0);\n+                    return FindResult(has_null_key, 0);\n             }\n         }\n \n@@ -303,9 +340,10 @@ class HashMethodBase\n \n         if constexpr (consecutive_keys_optimization)\n         {\n-            cache.found = true;\n-            cache.empty = false;\n-            ++cache.misses;\n+            cache.onNewValue(true);\n+\n+            if constexpr (nullable)\n+                cache.is_null = false;\n \n             if constexpr (has_mapped)\n             {\n@@ -346,17 +384,16 @@ class HashMethodBase\n \n         if constexpr (consecutive_keys_optimization)\n         {\n-            cache.found = it != nullptr;\n-            cache.empty = false;\n-            ++cache.misses;\n+            cache.onNewValue(it != nullptr);\n+\n+            if constexpr (nullable)\n+                cache.is_null = false;\n \n             if constexpr (has_mapped)\n             {\n                 cache.value.first = key;\n                 if (it)\n-                {\n                     cache.value.second = it->getMapped();\n-                }\n             }\n             else\n             {\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03009_consecutive_keys_nullable.reference b/tests/queries/0_stateless/03009_consecutive_keys_nullable.reference\nnew file mode 100644\nindex 000000000000..e1b9e0cba620\n--- /dev/null\n+++ b/tests/queries/0_stateless/03009_consecutive_keys_nullable.reference\n@@ -0,0 +1,16 @@\n+1\t2\t0\n+\\N\t1\t1\n+1\t2\t0\n+\\N\t1\t1\n+\\N\t3\t3\n+1\t3\t0\n+1\t2\t0\n+\\N\t1\t1\n+1\t1\t0\n+\\N\t2\t2\n+t_nullable_keys_1\t0\n+t_nullable_keys_2\t0\n+t_nullable_keys_3\t1\n+t_nullable_keys_4\t1\n+t_nullable_keys_5\t0\n+t_nullable_keys_6\t0\ndiff --git a/tests/queries/0_stateless/03009_consecutive_keys_nullable.sql b/tests/queries/0_stateless/03009_consecutive_keys_nullable.sql\nnew file mode 100644\nindex 000000000000..7650cf14a497\n--- /dev/null\n+++ b/tests/queries/0_stateless/03009_consecutive_keys_nullable.sql\n@@ -0,0 +1,56 @@\n+DROP TABLE IF EXISTS t_nullable_keys_1;\n+\n+CREATE TABLE t_nullable_keys_1 (x Nullable(Int64)) ENGINE = Memory;\n+INSERT INTO t_nullable_keys_1 VALUES (1), (1), (NULL);\n+SELECT x, count(), countIf(x IS NULL) FROM t_nullable_keys_1 GROUP BY x ORDER BY x;\n+\n+DROP TABLE t_nullable_keys_1;\n+\n+DROP TABLE IF EXISTS t_nullable_keys_2;\n+\n+CREATE TABLE t_nullable_keys_2 (x Nullable(Int64)) ENGINE = Memory;\n+INSERT INTO t_nullable_keys_2 VALUES (NULL), (1), (1);\n+SELECT x, count(), countIf(x IS NULL) FROM t_nullable_keys_2 GROUP BY x ORDER BY x;\n+\n+DROP TABLE t_nullable_keys_2;\n+\n+DROP TABLE IF EXISTS t_nullable_keys_3;\n+\n+CREATE TABLE t_nullable_keys_3 (x Nullable(Int64)) ENGINE = Memory;\n+INSERT INTO t_nullable_keys_3 VALUES (NULL), (NULL), (NULL);\n+SELECT x, count(), countIf(x IS NULL) FROM t_nullable_keys_3 GROUP BY x ORDER BY x;\n+\n+DROP TABLE t_nullable_keys_3;\n+\n+DROP TABLE IF EXISTS t_nullable_keys_4;\n+\n+CREATE TABLE t_nullable_keys_4 (x Nullable(Int64)) ENGINE = Memory;\n+INSERT INTO t_nullable_keys_4 VALUES (1), (1), (1);\n+SELECT x, count(), countIf(x IS NULL) FROM t_nullable_keys_4 GROUP BY x ORDER BY x;\n+\n+DROP TABLE t_nullable_keys_4;\n+\n+DROP TABLE IF EXISTS t_nullable_keys_5;\n+\n+CREATE TABLE t_nullable_keys_5 (x Nullable(Int64)) ENGINE = Memory;\n+INSERT INTO t_nullable_keys_5 VALUES (1), (NULL), (1);\n+SELECT x, count(), countIf(x IS NULL) FROM t_nullable_keys_5 GROUP BY x ORDER BY x;\n+\n+DROP TABLE t_nullable_keys_5;\n+\n+DROP TABLE IF EXISTS t_nullable_keys_6;\n+\n+CREATE TABLE t_nullable_keys_6 (x Nullable(Int64)) ENGINE = Memory;\n+INSERT INTO t_nullable_keys_6 VALUES (NULL), (1), (NULL);\n+SELECT x, count(), countIf(x IS NULL) FROM t_nullable_keys_6 GROUP BY x ORDER BY x;\n+\n+DROP TABLE t_nullable_keys_6;\n+\n+SYSTEM FLUSH LOGS;\n+\n+SELECT\n+    splitByChar('.', tables[1])[2] AS table,\n+    ProfileEvents['AggregationOptimizedEqualRangesOfKeys'] > 0\n+FROM system.query_log\n+WHERE type = 'QueryFinish' AND current_database = currentDatabase() AND query LIKE '%SELECT%FROM%t_nullable_keys_%'\n+ORDER BY table;\n",
  "problem_statement": "group by count with null values in the grouping key returns hard to understand result\n**Describe the unexpected behaviour**\r\n\r\nI'm having trouble understanding how nulls are handled when used as grouping keys. I can't tell if there's something I'm missing here, or if this is a bug in ClickHouse.\r\n\r\n**How to reproduce**\r\n\r\nClickHouse server version:\r\n\r\n```\r\nbce519d15486 :) select version();\r\n\r\nSELECT version()\r\n\r\nQuery id: ef482266-bbdb-4b62-ad14-3838c14c66cb\r\n\r\n\u250c\u2500version()\u2500\u2500\u2510\r\n\u2502 23.12.4.15 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.001 sec.\r\n```\r\n\r\nExample:\r\n\r\n```\r\nbce519d15486 :) CREATE OR REPLACE TABLE ibis_testing.topk (x Nullable(Int64)) ENGINE = Memory;\r\n\r\nCREATE OR REPLACE TABLE ibis_testing.topk\r\n(\r\n    `x` Nullable(Int64)\r\n)\r\nENGINE = Memory\r\n\r\nQuery id: 76f08dbb-380e-4336-b156-f71b992ca09e\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.006 sec.\r\n\r\nbce519d15486 :) INSERT INTO ibis_testing.topk VALUES (1), (1), (NULL);\r\n\r\nINSERT INTO ibis_testing.topk FORMAT Values\r\n\r\nQuery id: fec175db-566c-4019-8752-b36dcfc95f2c\r\n\r\nOk.\r\n\r\n3 rows in set. Elapsed: 0.002 sec.\r\n\r\nbce519d15486 :) select x, count(*), count(1), count(), countIf(x is null) from topk group by x;\r\n\r\nSELECT\r\n    x,\r\n    count(*),\r\n    count(1),\r\n    count(),\r\n    countIf(x IS NULL)\r\nFROM topk\r\nGROUP BY x\r\n\r\nQuery id: df3b4079-c6df-455f-ad2b-259612b42df6\r\n\r\n\u250c\u2500\u2500\u2500\u2500x\u2500\u252c\u2500count()\u2500\u252c\u2500count()\u2500\u252c\u2500count()\u2500\u252c\u2500countIf(isNull(x))\u2500\u2510\r\n\u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502       0 \u2502       0 \u2502       0 \u2502                  0 \u2502\r\n\u2502    1 \u2502       3 \u2502       3 \u2502       3 \u2502                  1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n2 rows in set. Elapsed: 0.002 sec.\r\n```\r\n\r\n**Expected behavior**\r\n\r\nI would expect the `count()` aggregations to return 1 for `NULL` and `2` for `1`, and the `countIf` aggregation to return `1` for `NULL` and `0` for `1`.\r\n\n",
  "hints_text": "https://clickhouse.com/docs/en/sql-reference/aggregate-functions#null-processing\r\n\r\n```\r\nDuring aggregation, all NULLs are skipped. If the aggregation has several parameters it will ignore any row in which one or more of the parameters are NULL.\r\n```\r\n\r\nIt's by design.\nRegardless of null skipping it seems incorrect to state that there three rows with the value `1` when that's simply not true.\r\n\r\nI'm not sure I understand what specifically in these results indicate that null skipping is by design, but maybe it's just me.\n> it will ignore any row in which one or more of the parameters are NULL.\r\n\r\nE.g., if this is true, then I would expect `null` to aggregate to 0 and `1` to aggregate to 2 when using count.\n> E.g., if this is true, then I would expect null to aggregate to 0 and 1 to aggregate to 2 when using count.\r\n\r\nYes, the documentation is lacking. There are some special cases, like `ANY RESPECT NULLS` where NULLs are used. But the default case is that any NULL argument is ignored.\r\n\r\nIn CH, count(), count(1), count(*) are all equivalent and return the count of all rows (doesn't check whether they are NULL or not). count(column) will only count where the column is not NULL since the NULLs will be ignored.\r\n\r\nHTH\nWOW\r\n\r\n>During aggregation, all NULLs are skipped. If the aggregation has several parameters it will ignore any row in which one or more of the parameters are NULL.\r\n\r\n\r\n@Algunenano this is about an aggregate function not about group by key.\r\n\r\nPSQL:\r\n\r\n```\r\nCREATE  TABLE topk(x int);\r\nINSERT INTO topk VALUES (1), (1), (NULL);\r\n\r\n\r\n\r\nSELECT\r\n   x,\r\n   count(*),\r\n   count(1),\r\n   count(*) filter (where x IS NULL)\r\nFROM topk\r\nGROUP BY x\r\n\r\n x | count | count | count\r\n---+-------+-------+-------\r\n   |     1 |     1 |     1\r\n 1 |     2 |     2 |     0\r\n```\r\n\r\nCH 22.8  https://fiddle.clickhouse.com/b1cee4e5-b254-4da2-bc31-51d8c3d3e698\r\n\r\n```\r\n+------+---------+---------+-----------------------+\r\n|    x | count() | count() | countIf(x, isNull(x)) |\r\n+------+---------+---------+-----------------------+\r\n|    1 |       2 |       2 |                     0 |\r\n+------+---------+---------+-----------------------+\r\n| NULL |       1 |       1 |                     0 |\r\n+------+---------+---------+-----------------------+\r\n```\r\n\r\nCH 23.8 https://fiddle.clickhouse.com/f08342c7-40b8-4bba-899c-cf0425bacb16\r\n\r\n```\r\n+------+---------+---------+-----------------------+\r\n|    x | count() | count() | countIf(x, isNull(x)) |\r\n+------+---------+---------+-----------------------+\r\n| NULL |       1 |       1 |                     0 |\r\n+------+---------+---------+-----------------------+\r\n|    1 |       2 |       2 |                     0 |\r\n+------+---------+---------+-----------------------+\r\n```\r\n\r\nCH 24.2 https://fiddle.clickhouse.com/4fa0e06f-2be9-48a4-9dea-2252488f0dfd\r\n\r\n```\r\n+------+---------+---------+-----------------------+\r\n|    x | count() | count() | countIf(x, isNull(x)) |\r\n+------+---------+---------+-----------------------+\r\n| NULL |       0 |       0 |                     0 |\r\n+------+---------+---------+-----------------------+\r\n|    1 |       3 |       3 |                     0 |\r\n+------+---------+---------+-----------------------+\r\n```\nBroken since 23.12.4.15\n@den-crane Thanks for figuring that out! I suppose we'll just ~pin that version of clickhouse for now in our CI~ xfail the test that exposes this problem.\nSeems it was broken in https://github.com/ClickHouse/ClickHouse/pull/57872 as removing the call to `addBatchSinglePlace` fixes it. cc @CurtizJ \nIt seems this is related to an optimization to use a faster aggregation method when we find only one key in the block, as we are ignoring NULLs. It does not happen if the block has more than 1 non NULL value.\nBWT `count(*) filter (where x IS NULL)` in my examples is incorrect by unrelated reason, it's another bug https://github.com/ClickHouse/ClickHouse/issues/61004 \r\nit's expanded into `countIf(x, x IS NULL)` instead of `countIf(x IS NULL)`",
  "created_at": "2024-03-14T16:49:44Z"
}