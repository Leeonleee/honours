{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 53754,
  "instance_id": "ClickHouse__ClickHouse-53754",
  "issue_numbers": [
    "53640"
  ],
  "base_commit": "bea651e828450a375b488790c1213f93377de346",
  "patch": "diff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp\nindex acedede579b4..4cb1ee2a9a9d 100644\n--- a/src/Interpreters/ExpressionAnalyzer.cpp\n+++ b/src/Interpreters/ExpressionAnalyzer.cpp\n@@ -1513,14 +1513,16 @@ ActionsDAGPtr SelectQueryExpressionAnalyzer::appendOrderBy(ExpressionActionsChai\n         for (const auto & child : select_query->select()->children)\n             select.insert(child->getAliasOrColumnName());\n \n+        NameSet required_by_interpolate;\n         /// collect columns required for interpolate expressions -\n         /// interpolate expression can use any available column\n-        auto find_columns = [&step, &select](IAST * function)\n+        auto find_columns = [&step, &select, &required_by_interpolate](IAST * function)\n         {\n-            auto f_impl = [&step, &select](IAST * fn, auto fi)\n+            auto f_impl = [&step, &select, &required_by_interpolate](IAST * fn, auto fi)\n             {\n                 if (auto * ident = fn->as<ASTIdentifier>())\n                 {\n+                    required_by_interpolate.insert(ident->getColumnName());\n                     /// exclude columns from select expression - they are already available\n                     if (!select.contains(ident->getColumnName()))\n                         step.addRequiredOutput(ident->getColumnName());\n@@ -1536,6 +1538,14 @@ ActionsDAGPtr SelectQueryExpressionAnalyzer::appendOrderBy(ExpressionActionsChai\n \n         for (const auto & interpolate : interpolate_list->children)\n             find_columns(interpolate->as<ASTInterpolateElement>()->expr.get());\n+\n+        if (!required_result_columns.empty())\n+        {\n+            NameSet required_result_columns_set(required_result_columns.begin(), required_result_columns.end());\n+            for (const auto & name : required_by_interpolate)\n+                if (!required_result_columns_set.contains(name))\n+                    required_result_columns.push_back(name);\n+        }\n     }\n \n     if (optimize_read_in_order)\ndiff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp\nindex 5b384a5f74b8..b71086f21885 100644\n--- a/src/Interpreters/TreeRewriter.cpp\n+++ b/src/Interpreters/TreeRewriter.cpp\n@@ -388,6 +388,44 @@ void removeUnneededColumnsFromSelectClause(ASTSelectQuery * select_query, const\n     else\n         return;\n \n+    NameSet required_by_interpolate;\n+\n+    if (select_query->interpolate())\n+    {\n+        auto & children = select_query->interpolate()->children;\n+        if (!children.empty())\n+        {\n+            NameToNameSetMap expressions;\n+\n+            auto interpolate_visitor = [](const ASTPtr ast, NameSet & columns) -> void\n+            {\n+                auto interpolate_visitor_impl = [](const ASTPtr node, NameSet & cols, auto self) -> void\n+                {\n+                    if (const auto * ident = node->as<ASTIdentifier>())\n+                        cols.insert(ident->name());\n+                    else if (const auto * func = node->as<ASTFunction>())\n+                        for (const auto & elem : func->arguments->children)\n+                            self(elem, cols, self);\n+                };\n+                interpolate_visitor_impl(ast, columns, interpolate_visitor_impl);\n+            };\n+\n+            for (const auto & elem : children)\n+            {\n+                if (auto * interpolate = elem->as<ASTInterpolateElement>())\n+                {\n+                    NameSet needed_columns;\n+                    interpolate_visitor(interpolate->expr, needed_columns);\n+                    expressions.emplace(interpolate->column, std::move(needed_columns));\n+                }\n+            }\n+\n+            for (const auto & name : required_result_columns)\n+                if (const auto it = expressions.find(name); it != expressions.end())\n+                    required_by_interpolate.insert(it->second.begin(), it->second.end());\n+        }\n+    }\n+\n     ASTs new_elements;\n     new_elements.reserve(elements.size());\n \n@@ -403,6 +441,11 @@ void removeUnneededColumnsFromSelectClause(ASTSelectQuery * select_query, const\n             new_elements.push_back(elem);\n             --it->second;\n         }\n+        else if (required_by_interpolate.contains(name))\n+        {\n+            /// Columns required by interpolate expression are not always in the required_result_columns\n+            new_elements.push_back(elem);\n+        }\n         else if (select_query->distinct || hasArrayJoin(elem))\n         {\n             /// ARRAY JOIN cannot be optimized out since it may change number of rows,\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02863_interpolate_subquery.reference b/tests/queries/0_stateless/02863_interpolate_subquery.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/02863_interpolate_subquery.sql b/tests/queries/0_stateless/02863_interpolate_subquery.sql\nnew file mode 100644\nindex 000000000000..4d8ba5f9cb26\n--- /dev/null\n+++ b/tests/queries/0_stateless/02863_interpolate_subquery.sql\n@@ -0,0 +1,7 @@\n+-- https://github.com/ClickHouse/ClickHouse/issues/53640\n+DROP TABLE IF EXISTS tab;\n+CREATE TABLE tab (i UInt32, a UInt32) ENGINE=Memory;\n+SELECT i, col1 FROM (\n+    SELECT i, a AS col1, a AS col2 FROM tab ORDER BY i WITH FILL INTERPOLATE (col1 AS col1+col2, col2)\n+);\n+DROP TABLE tab;\n",
  "problem_statement": "'Missing columns' exception when using INTERPOLATE in subquery\n**Describe what's wrong**\r\nIn scenarios where an interpolated value is dependent on a calculated column (also interpolated) on a subquery, every interpolated column must be referenced in the outer query, otherwise a `Missing columns` exception is thrown\r\n\r\n[Reproduction in fiddle](https://fiddle.clickhouse.com/bcb35723-614e-4a8b-bb1a-9d35d9cfb3d5)\r\n\r\n**Does it reproduce on recent release?**\r\n\r\nReproduces in lastest version\r\n\r\n**How to reproduce**\r\n\r\n```\r\n--create test table\r\ncreate table t1 (ts Date, num UInt32) engine=MergeTree() order by ts;\r\n\r\n--insert some random data a few times (since we will aggregate over date field\r\ninsert into t1 select toDate(now() - INTERVAL number DAY), rand(number) from numbers(100);\r\ninsert into t1 select toDate(now() - INTERVAL number DAY), rand(number) from numbers(100);\r\ninsert into t1 select toDate(now() - INTERVAL number DAY), rand(number) from numbers(100);\r\n\r\n--CTE with interpolated values (incl col2 - calculated based on col1)\r\nwith interpolated as (\r\n    select\r\n        ts as day,\r\n        sum(num) as col1,\r\n        exponentialMovingAverage(1)(col1, toUInt64(day)) over (\r\n            Rows between 7 preceding\r\n            and current row\r\n        ) as col2\r\n    from\r\n        t1\r\n    group by\r\n        day\r\n    order by\r\n        day asc with fill to toLastDayOfMonth(now()) step interval 1 day interpolate(col1 as (col1 + col2) / 2, col2 as col2)\r\n)\r\n\r\n--This one runs fine:\r\nselect * from interpolated;\r\n\r\n--This one returns an error 'Code: 47. DB::Exception: Missing columns: 'col2' while processing query'\r\nselect toStartOfMonth(day) as month, sum(col1) from interpolated group by month;\r\n\r\n--This one runs fine:\r\nselect toStartOfMonth(day) as month, sum(col1), any(col2) from interpolated group by month;\r\n```\r\n\r\n**Expected behavior**\r\n\r\nOuter query should execute without needing to select every interpolated field from subquery\r\n\n",
  "hints_text": "",
  "created_at": "2023-08-23T14:12:16Z"
}