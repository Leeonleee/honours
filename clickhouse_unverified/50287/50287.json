{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 50287,
  "instance_id": "ClickHouse__ClickHouse-50287",
  "issue_numbers": [
    "50283",
    "50269"
  ],
  "base_commit": "0e2156c77693ba0cfdd3c62b113f7f3a57ca2ffa",
  "patch": "diff --git a/src/Functions/FunctionsComparison.h b/src/Functions/FunctionsComparison.h\nindex a9c8bbaa183f..08bc350c1d42 100644\n--- a/src/Functions/FunctionsComparison.h\n+++ b/src/Functions/FunctionsComparison.h\n@@ -1230,8 +1230,11 @@ class FunctionComparison : public IFunction\n         /// The case when arguments are the same (tautological comparison). Return constant.\n         /// NOTE: Nullable types are special case.\n         /// (BTW, this function use default implementation for Nullable, so Nullable types cannot be here. Check just in case.)\n-        /// NOTE: We consider NaN comparison to be implementation specific (and in our implementation NaNs are sometimes equal sometimes not).\n-        if (left_type->equals(*right_type) && !left_type->isNullable() && !isTuple(left_type) && col_left_untyped == col_right_untyped)\n+        if (left_type->equals(*right_type) &&\n+            !left_type->isNullable() &&\n+            !isTuple(left_type) &&\n+            !WhichDataType(left_type).isFloat() &&\n+            col_left_untyped == col_right_untyped)\n         {\n             ColumnPtr result_column;\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02769_nan_equality_comparison.reference b/tests/queries/0_stateless/02769_nan_equality_comparison.reference\nnew file mode 100644\nindex 000000000000..a8ba06cfce6c\n--- /dev/null\n+++ b/tests/queries/0_stateless/02769_nan_equality_comparison.reference\n@@ -0,0 +1,10 @@\n+nan\t0\t0\t0\t0\n+nan\t0\t0\t0\t0\n+nan\tnan\t0\t0\t0\t0\n+--\n+--\n+nan\t1\t1\t1\t1\n+nan\t1\t1\t1\t1\n+nan\tnan\t1\t1\t1\t1\n+--\n+nan\ndiff --git a/tests/queries/0_stateless/02769_nan_equality_comparison.sql b/tests/queries/0_stateless/02769_nan_equality_comparison.sql\nnew file mode 100644\nindex 000000000000..6cce19a22046\n--- /dev/null\n+++ b/tests/queries/0_stateless/02769_nan_equality_comparison.sql\n@@ -0,0 +1,42 @@\n+SET compile_expressions = 1;\n+SET min_count_to_compile_expression = 0;\n+\n+SELECT nan AS value, value = value, value = materialize(value), materialize(value) = value, materialize(value) = materialize(value);\n+SELECT cast(nan, 'Float32') AS value, value = value, value = materialize(value), materialize(value) = value, materialize(value) = materialize(value);\n+SELECT nan AS lhs, cast(nan, 'Float32') AS rhs, lhs = rhs, lhs = materialize(rhs), materialize(lhs) = rhs, materialize(lhs) = materialize(rhs);\n+\n+SELECT '--';\n+\n+CREATE TABLE test_table\n+(\n+    id UInt32,\n+    value UInt32\n+) ENGINE = MergeTree ORDER BY id;\n+INSERT INTO test_table VALUES (76, 57);\n+\n+SELECT value FROM (SELECT stddevSamp(id) AS value FROM test_table) as subquery\n+WHERE ((value = value) AND (NOT (value = value)));\n+\n+DROP TABLE test_table;\n+\n+SELECT '--';\n+\n+SELECT nan AS value, value != value, value != materialize(value), materialize(value) != value, materialize(value) != materialize(value);\n+SELECT cast(nan, 'Float32') AS value, value != value, value != materialize(value), materialize(value) != value, materialize(value) != materialize(value);\n+SELECT nan AS lhs, cast(nan, 'Float32') AS rhs, lhs != rhs, lhs != materialize(rhs), materialize(lhs) != rhs, materialize(lhs) != materialize(rhs);\n+\n+SELECT '--';\n+\n+CREATE TABLE test_table\n+(\n+    id UInt32,\n+    value_1 UInt32,\n+    value_2 Float32\n+) ENGINE = MergeTree ORDER BY id;\n+INSERT INTO test_table VALUES (12000, 36, 77.94);\n+\n+SELECT value\n+FROM (SELECT (corr(value_1, value_1) OVER test_window) AS value FROM test_table WINDOW test_window AS (PARTITION BY value_2 ORDER BY id ASC)) as subquery\n+WHERE not (not (value <> value));\n+\n+DROP TABLE test_table;\n",
  "problem_statement": "Wrong result of SELECT statement with compile_expressions in recent commits (affected version: 21-23.5.1)\n**Describe what's wrong**\r\n\r\nThe SELECT statement with contradictory WHERE conditions should return empty results. However, it outputs one row.\r\n\r\n**Does it reproduce on recent release?**\r\n\r\nIt can be reproduced in the latest version.\r\n\r\n**How to reproduce**\r\n\r\nVersion: 23.5.1.1 (commit 3e6314675c6467bc4dd78f659bac862f7e9648f8)\r\n\r\nEasy reproduce in ClickHouse fiddle: https://fiddle.clickhouse.com/7b30dc3b-efea-4b23-937c-6fcb19893bbc\r\n\r\n_Set up database_\r\n\r\n```sql\r\ncreate table t1 (c6 UInt32, c7 UInt32, primary key(c6)) engine = MergeTree;\r\ninsert into t1 values (76, 57);\r\n```\r\n\r\n_bug-triggering query_\r\n\r\n```sql\r\nselect\r\n    c_5_c1470_1 as c_2_c1479_2\r\n  from\r\n    (select\r\n          stddevSamp(ref_10.c6) as c_5_c1470_1\r\n        from\r\n          t1 as ref_10) as subq_1\r\n  where ((subq_1.c_5_c1470_1 = subq_1.c_5_c1470_1)\r\n        and (not (subq_1.c_5_c1470_1 = subq_1.c_5_c1470_1)));\r\n```\r\n\r\n**Expected behavior**\r\n\r\nThe query must output empty because the conditions `(subq_1.c_5_c1470_1 = subq_1.c_5_c1470_1)` and `(not (subq_1.c_5_c1470_1 = subq_1.c_5_c1470_1))` are contradictory. \r\n\r\n**Actual behavior**\r\n\r\nIt outputs one row\r\n```\r\n+-------------+\r\n| c_2_c1479_2 |\r\n+-------------+\r\n|         nan |\r\n+-------------+\r\n```\r\n\r\n**Additional context**\r\n\r\n1. At the first several times, the query output an empty result. But after several tries, the results become incorrect, similar as #50039\r\n2. This bug still exists after the fix for https://github.com/ClickHouse/ClickHouse/issues/50039\r\n3. if `set compile_expressions = 0`, the bug disappears, so it should be also related to compile_expressions.\r\n4. The earliest reproducible version is 21 in fiddle: https://fiddle.clickhouse.com/617e1e6d-8e5c-41a7-acca-31c8bff38e04, which is different from #50269 (only head version).\r\n5. Before version 21, the query outputs empty (e.g. 21.12.4.1-alpine: https://fiddle.clickhouse.com/c16460b5-3011-4fa9-b641-c0266a227c14).\r\n\r\n\r\n\r\n\nWrong result of SELECT statement with compile_expressions in recent commits (head version)\n**Describe what's wrong**\r\n\r\nThe two semantically-equivalent SELECT statements should output the same results, but they did not.\r\n\r\n**Does it reproduce on recent release?**\r\n\r\nIt cannot be reproduced in the latest version, but it can be reproduced in the head version.\r\n\r\n**How to reproduce**\r\n\r\nVersion: 23.5.1.1 (commit 3e6314675c6467bc4dd78f659bac862f7e9648f8)\r\n\r\nEasy reproduce in ClickHouse fiddle: https://fiddle.clickhouse.com/184cce9d-1e87-4666-afc1-97d281cc11cd\r\n\r\n_Set up database_\r\n\r\n```sql\r\ncreate table t1 (pkey UInt32, c4 UInt32, c5 Float32, primary key(pkey)) engine = MergeTree;\r\ninsert into t1 values (12000, 36, 77.94);\r\n```\r\n\r\n_SELECT statement 1_\r\n\r\n```sql\r\nselect  \r\n  subq_1.c_4_c3362_6 as c_1_c3371_2\r\nfrom \r\n  (select  \r\n        corr(ref_0.c4,ref_0.c4) over w0 as c_4_c3362_6 \r\n      from \r\n        t1 as ref_0\r\n      window w0 as (partition by ref_0.c5 order by ref_0.pkey asc)\r\n  ) as subq_1\r\nwhere not (not (subq_1.c_4_c3362_6 <> subq_1.c_4_c3362_6));\r\n```\r\n\r\nAs `not (not (subq_1.c_4_c3362_6 <> subq_1.c_4_c3362_6))` can be replaced with `subq_1.c_4_c3362_6 <> subq_1.c_4_c3362_6`, I get the semantically-equivalent SELECT statement:\r\n\r\n_SELECT statement 2_\r\n\r\n```sql\r\nselect  \r\n  subq_1.c_4_c3362_6 as c_1_c3371_2\r\nfrom \r\n  (select  \r\n        corr(ref_0.c4,ref_0.c4) over w0 as c_4_c3362_6 \r\n      from \r\n        t1 as ref_0\r\n      window w0 as (partition by ref_0.c5 order by ref_0.pkey asc)\r\n  ) as subq_1\r\nwhere subq_1.c_4_c3362_6 <> subq_1.c_4_c3362_6;\r\n```\r\n\r\n**Expected behavior**\r\n\r\nThe two SELECT statements output the same results.\r\n\r\n**Actual behavior**\r\n\r\nThey are different.\r\n\r\nSELECT statement 1 outputs:\r\n```\r\n+-------------+\r\n| c_1_c3371_2 |\r\n+-------------+\r\n|         nan |\r\n+-------------+\r\n```\r\n\r\nSELECT statement 2 outputs an empty result.\r\n\r\n**Additional context**\r\n\r\n1. This bug can be triggered only in the head version, so it should be involved by recent commits.\r\n2. At the first several times, the SELECT statement 1 outputs an empty result. But after several tries, the results become incorrect, similar to #50039.\r\n3. if `set compile_expressions = 0`, the bug disappears, so it should be also related to compile_expressions.\r\n\r\n\r\n\r\n\n",
  "hints_text": "\n",
  "created_at": "2023-05-28T14:06:11Z"
}