{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 28530,
  "instance_id": "ClickHouse__ClickHouse-28530",
  "issue_numbers": [
    "28525"
  ],
  "base_commit": "027c5312438546b555acf720cf815a3b315cb48b",
  "patch": "diff --git a/src/Functions/FunctionsExternalDictionaries.h b/src/Functions/FunctionsExternalDictionaries.h\nindex 5f94a1e1f4bd..4f79b06b44a5 100644\n--- a/src/Functions/FunctionsExternalDictionaries.h\n+++ b/src/Functions/FunctionsExternalDictionaries.h\n@@ -321,21 +321,32 @@ class FunctionDictGetNoType final : public IFunction\n \n         Strings attribute_names = getAttributeNamesFromColumn(arguments[1].column, arguments[1].type);\n \n-        DataTypes types;\n-\n         auto dictionary_structure = helper.getDictionaryStructure(dictionary_name);\n \n+        DataTypes attribute_types;\n+        attribute_types.reserve(attribute_names.size());\n         for (auto & attribute_name : attribute_names)\n         {\n             /// We're extracting the return type from the dictionary's config, without loading the dictionary.\n-            auto attribute = dictionary_structure.getAttribute(attribute_name);\n-            types.emplace_back(attribute.type);\n+            const auto & attribute = dictionary_structure.getAttribute(attribute_name);\n+            attribute_types.emplace_back(attribute.type);\n         }\n \n-        if (types.size() > 1)\n-            return std::make_shared<DataTypeTuple>(types, attribute_names);\n+        bool key_is_nullable = arguments[2].type->isNullable();\n+        if (attribute_types.size() > 1)\n+        {\n+            if (key_is_nullable)\n+                throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Function {} support nullable key only for single dictionary attribute\", getName());\n+\n+            return std::make_shared<DataTypeTuple>(attribute_types, attribute_names);\n+        }\n         else\n-            return types.front();\n+        {\n+            if (key_is_nullable)\n+                return makeNullable(attribute_types.front());\n+            else\n+                return attribute_types.front();\n+        }\n     }\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n@@ -418,7 +429,9 @@ class FunctionDictGetNoType final : public IFunction\n                 default_cols = tuple_column->getColumnsCopy();\n             }\n             else\n+            {\n                 default_cols.emplace_back(result);\n+            }\n         }\n         else\n         {\n@@ -426,7 +439,16 @@ class FunctionDictGetNoType final : public IFunction\n                 default_cols.emplace_back(nullptr);\n         }\n \n-        const auto & key_col_with_type = arguments[2];\n+        auto key_col_with_type = arguments[2];\n+\n+        bool key_is_only_null = key_col_with_type.type->onlyNull();\n+        if (key_is_only_null)\n+            return result_type->createColumnConstWithDefaultValue(input_rows_count);\n+\n+        bool key_is_nullable = key_col_with_type.type->isNullable();\n+        if (key_is_nullable)\n+            key_col_with_type = columnGetNested(key_col_with_type);\n+\n         auto key_column = key_col_with_type.column;\n \n         Columns key_columns;\n@@ -482,7 +504,26 @@ class FunctionDictGetNoType final : public IFunction\n             key_types.emplace_back(range_col_type);\n         }\n \n-        return executeDictionaryRequest(dictionary, attribute_names, key_columns, key_types, result_type, default_cols);\n+        DataTypePtr attribute_type = result_type;\n+        if (key_is_nullable)\n+        {\n+            DataTypes attribute_types;\n+            attribute_types.reserve(attribute_names.size());\n+            for (auto & attribute_name : attribute_names)\n+            {\n+                const auto & attribute = dictionary->getStructure().getAttribute(attribute_name);\n+                attribute_types.emplace_back(attribute.type);\n+            }\n+\n+            attribute_type = attribute_types.front();\n+        }\n+\n+        auto result_column = executeDictionaryRequest(dictionary, attribute_names, key_columns, key_types, attribute_type, default_cols);\n+\n+        if (key_is_nullable)\n+            result_column = wrapInNullable(result_column, {arguments[2]}, result_type, input_rows_count);\n+\n+        return result_column;\n     }\n \n private:\n@@ -511,12 +552,14 @@ class FunctionDictGetNoType final : public IFunction\n             result = ColumnTuple::create(std::move(result_columns));\n         }\n         else\n+        {\n             result = dictionary->getColumn(\n                 attribute_names[0],\n                 result_type,\n                 key_columns,\n                 key_types,\n                 default_cols.front());\n+        }\n \n         return result;\n     }\n@@ -526,7 +569,9 @@ class FunctionDictGetNoType final : public IFunction\n         Strings attribute_names;\n \n         if (const auto * name_col = checkAndGetColumnConst<ColumnString>(column.get()))\n+        {\n             attribute_names.emplace_back(name_col->getValue<String>());\n+        }\n         else if (const auto * tuple_col_const = checkAndGetColumnConst<ColumnTuple>(column.get()))\n         {\n             const ColumnTuple & tuple_col = assert_cast<const ColumnTuple &>(tuple_col_const->getDataColumn());\n@@ -551,10 +596,12 @@ class FunctionDictGetNoType final : public IFunction\n             }\n         }\n         else\n+        {\n             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                 \"Illegal type {} of second argument of function {}, expected a const string or const tuple of const strings.\",\n                 type->getName(),\n                 getName());\n+        }\n \n         return attribute_names;\n     }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/2014_dict_get_nullable_key.reference b/tests/queries/0_stateless/2014_dict_get_nullable_key.reference\nnew file mode 100644\nindex 000000000000..08127d35829a\n--- /dev/null\n+++ b/tests/queries/0_stateless/2014_dict_get_nullable_key.reference\n@@ -0,0 +1,13 @@\n+Non nullable value only null key \n+\\N\n+Non nullable value nullable key\n+Test\n+\\N\n+\n+Nullable value only null key \n+\\N\n+Nullable value nullable key\n+Test\n+\\N\n+\\N\n+\\N\ndiff --git a/tests/queries/0_stateless/2014_dict_get_nullable_key.sql b/tests/queries/0_stateless/2014_dict_get_nullable_key.sql\nnew file mode 100644\nindex 000000000000..d6c058b285f8\n--- /dev/null\n+++ b/tests/queries/0_stateless/2014_dict_get_nullable_key.sql\n@@ -0,0 +1,29 @@\n+DROP TABLE IF EXISTS dictionary_non_nullable_source_table;\n+CREATE TABLE dictionary_non_nullable_source_table (id UInt64, value String) ENGINE=TinyLog;\n+INSERT INTO dictionary_non_nullable_source_table VALUES (0, 'Test');\n+\n+DROP DICTIONARY IF EXISTS test_dictionary_non_nullable;\n+CREATE DICTIONARY test_dictionary_non_nullable (id UInt64, value String) PRIMARY KEY id LAYOUT(DIRECT()) SOURCE(CLICKHOUSE(TABLE 'dictionary_non_nullable_source_table'));\n+\n+SELECT 'Non nullable value only null key ';\n+SELECT dictGet('test_dictionary_non_nullable', 'value', NULL);\n+SELECT 'Non nullable value nullable key';\n+SELECT dictGet('test_dictionary_non_nullable', 'value', arrayJoin([toUInt64(0), NULL, 1]));\n+\n+DROP DICTIONARY test_dictionary_non_nullable;\n+DROP TABLE dictionary_non_nullable_source_table;\n+\n+DROP TABLE IF EXISTS dictionary_nullable_source_table;\n+CREATE TABLE dictionary_nullable_source_table (id UInt64, value Nullable(String)) ENGINE=TinyLog;\n+INSERT INTO dictionary_nullable_source_table VALUES (0, 'Test'), (1, NULL);\n+\n+DROP DICTIONARY IF EXISTS test_dictionary_nullable;\n+CREATE DICTIONARY test_dictionary_nullable (id UInt64, value Nullable(String)) PRIMARY KEY id LAYOUT(DIRECT()) SOURCE(CLICKHOUSE(TABLE 'dictionary_nullable_source_table'));\n+\n+SELECT 'Nullable value only null key ';\n+SELECT dictGet('test_dictionary_nullable', 'value', NULL);\n+SELECT 'Nullable value nullable key';\n+SELECT dictGet('test_dictionary_nullable', 'value', arrayJoin([toUInt64(0), NULL, 1, 2]));\n+\n+DROP DICTIONARY test_dictionary_nullable;\n+DROP TABLE dictionary_nullable_source_table;\n",
  "problem_statement": "dictGet nullable argument stopped working\n```\r\nCREATE TABLE dictionary_nullable_source_table(    id UInt64,    value Int64) ENGINE=TinyLog;\r\nINSERT INTO dictionary_nullable_source_table VALUES (0, 0);\r\nDROP DICTIONARY IF EXISTS flat_dictionary;\r\nCREATE DICTIONARY flat_dictionary (  id UInt64,  value Int64 ) PRIMARY KEY id\r\nSOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() TABLE 'dictionary_nullable_source_table'))\r\nLIFETIME(MIN 1 MAX 1000)\r\nLAYOUT(FLAT());\r\nSELECT dictGet('flat_dictionary', 'value', Null);\r\n```\r\n\r\nOn 21.6 and older - returns Null. \r\nOn 21.7 and newer:\r\n```\r\nReceived exception from server (version 21.8.4):\r\nCode: 43. DB::Exception: Received from localhost:9000. DB::Exception: Third argument of function dictGet must be UInt64 when dictionary is simple. Actual type Nullable(Nothing).: While processing dictGet('flat_dictionary', 'value', NULL). Stack trace:\r\n\r\n0. DB::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int, bool) @ 0x8f9557a in /usr/bin/clickhouse\r\n1. DB::Exception::Exception<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >(int, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >&&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >&&) @ 0xa7b78de in /usr/bin/clickhouse\r\n2. DB::FunctionDictGetNoType<(DB::DictionaryGetFunctionType)0>::executeImpl(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0xb5da99c in /usr/bin/clickhouse\r\n3. DB::IFunction::executeImplDryRun(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0xb1266ca in /usr/bin/clickhouse\r\n4. DB::FunctionToExecutableFunctionAdaptor::executeDryRunImpl(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0xb12574e in /usr/bin/clickhouse\r\n5. DB::IExecutableFunction::executeWithoutLowCardinalityColumns(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0xfa6cd85 in /usr/bin/clickhouse\r\n6. DB::IExecutableFunction::defaultImplementationForConstantArguments(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0xfa6c772 in /usr/bin/clickhouse\r\n7. DB::IExecutableFunction::executeWithoutLowCardinalityColumns(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0xfa6cd45 in /usr/bin/clickhouse\r\n8. DB::IExecutableFunction::execute(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0xfa6d3b2 in /usr/bin/clickhouse\r\n9. DB::ActionsDAG::addFunction(std::__1::shared_ptr<DB::IFunctionOverloadResolver> const&, std::__1::vector<DB::ActionsDAG::Node const*, std::__1::allocator<DB::ActionsDAG::Node const*> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >) @ 0xff4629f in /usr/bin/clickhouse\r\n10. DB::ScopeStack::addFunction(std::__1::shared_ptr<DB::IFunctionOverloadResolver> const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >) @ 0x101bcdb2 in /usr/bin/clickhouse\r\n11. DB::ActionsMatcher::visit(DB::ASTFunction const&, std::__1::shared_ptr<DB::IAST> const&, DB::ActionsMatcher::Data&) @ 0x101c6f0c in /usr/bin/clickhouse\r\n12. DB::ActionsMatcher::visit(DB::ASTExpressionList&, std::__1::shared_ptr<DB::IAST> const&, DB::ActionsMatcher::Data&) @ 0x101cef7e in /usr/bin/clickhouse\r\n13. DB::InDepthNodeVisitor<DB::ActionsMatcher, true, std::__1::shared_ptr<DB::IAST> const>::visit(std::__1::shared_ptr<DB::IAST> const&) @ 0x1018e917 in /usr/bin/clickhouse\r\n14. DB::ExpressionAnalyzer::getRootActions(std::__1::shared_ptr<DB::IAST> const&, bool, std::__1::shared_ptr<DB::ActionsDAG>&, bool) @ 0x1018e605 in /usr/bin/clickhouse\r\n15. DB::SelectQueryExpressionAnalyzer::appendSelect(DB::ExpressionActionsChain&, bool) @ 0x1019bda8 in /usr/bin/clickhouse\r\n16. DB::ExpressionAnalysisResult::ExpressionAnalysisResult(DB::SelectQueryExpressionAnalyzer&, std::__1::shared_ptr<DB::StorageInMemoryMetadata const> const&, bool, bool, bool, std::__1::shared_ptr<DB::FilterDAGInfo> const&, DB::Block const&) @ 0x101a1422 in /usr/bin/clickhouse\r\n17. DB::InterpreterSelectQuery::getSampleBlockImpl() @ 0x103a97e6 in /usr/bin/clickhouse\r\n18. ? @ 0x103a236b in /usr/bin/clickhouse\r\n19. DB::InterpreterSelectQuery::InterpreterSelectQuery(std::__1::shared_ptr<DB::IAST> const&, std::__1::shared_ptr<DB::Context const>, std::__1::shared_ptr<DB::IBlockInputStream> const&, std::__1::optional<DB::Pipe>, std::__1::shared_ptr<DB::IStorage> const&, DB::SelectQueryOptions const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&, std::__1::shared_ptr<DB::StorageInMemoryMetadata const> const&) @ 0x1039c77f in /usr/bin/clickhouse\r\n20. DB::InterpreterSelectQuery::InterpreterSelectQuery(std::__1::shared_ptr<DB::IAST> const&, std::__1::shared_ptr<DB::Context const>, DB::SelectQueryOptions const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&) @ 0x1039af7e in /usr/bin/clickhouse\r\n21. DB::InterpreterSelectWithUnionQuery::InterpreterSelectWithUnionQuery(std::__1::shared_ptr<DB::IAST> const&, std::__1::shared_ptr<DB::Context const>, DB::SelectQueryOptions const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&) @ 0x10575909 in /usr/bin/clickhouse\r\n22. DB::InterpreterFactory::get(std::__1::shared_ptr<DB::IAST>&, std::__1::shared_ptr<DB::Context>, DB::SelectQueryOptions const&) @ 0x1017c2b7 in /usr/bin/clickhouse\r\n23. ? @ 0x10739886 in /usr/bin/clickhouse\r\n24. DB::executeQuery(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::shared_ptr<DB::Context>, bool, DB::QueryProcessingStage::Enum, bool) @ 0x107381c3 in /usr/bin/clickhouse\r\n25. DB::TCPHandler::runImpl() @ 0x10fcd88d in /usr/bin/clickhouse\r\n26. DB::TCPHandler::run() @ 0x10fe06d9 in /usr/bin/clickhouse\r\n27. Poco::Net::TCPServerConnection::start() @ 0x13b5730f in /usr/bin/clickhouse\r\n28. Poco::Net::TCPServerDispatcher::run() @ 0x13b58d9a in /usr/bin/clickhouse\r\n29. Poco::PooledThread::run() @ 0x13c8bc19 in /usr/bin/clickhouse\r\n30. Poco::ThreadImpl::runnableEntry(void*) @ 0x13c87eaa in /usr/bin/clickhouse\r\n31. start_thread @ 0x9609 in /usr/lib/x86_64-linux-gnu/libpthread-2.31.so\r\n```\n",
  "hints_text": "",
  "created_at": "2021-09-02T15:31:20Z"
}