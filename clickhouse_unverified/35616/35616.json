{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 35616,
  "instance_id": "ClickHouse__ClickHouse-35616",
  "issue_numbers": [
    "35548"
  ],
  "base_commit": "14e84ff6ef2cf6fafae24657bff97463709e3540",
  "patch": "diff --git a/src/Interpreters/HashJoin.cpp b/src/Interpreters/HashJoin.cpp\nindex e81db1427ef7..00568cfdf084 100644\n--- a/src/Interpreters/HashJoin.cpp\n+++ b/src/Interpreters/HashJoin.cpp\n@@ -962,18 +962,29 @@ class AddedColumns\n             /// If it's joinGetOrNull, we need to wrap not-nullable columns in StorageJoin.\n             for (size_t j = 0, size = right_indexes.size(); j < size; ++j)\n             {\n-                const auto & column = *block.getByPosition(right_indexes[j]).column;\n-                if (auto * nullable_col = typeid_cast<ColumnNullable *>(columns[j].get()); nullable_col && !column.isNullable())\n-                    nullable_col->insertFromNotNullable(column, row_num);\n+                auto column_from_block = block.getByPosition(right_indexes[j]);\n+                if (type_name[j].type->lowCardinality() != column_from_block.type->lowCardinality())\n+                {\n+                    JoinCommon::changeLowCardinalityInplace(column_from_block);\n+                }\n+\n+                if (auto * nullable_col = typeid_cast<ColumnNullable *>(columns[j].get());\n+                    nullable_col && !column_from_block.column->isNullable())\n+                    nullable_col->insertFromNotNullable(*column_from_block.column, row_num);\n                 else\n-                    columns[j]->insertFrom(column, row_num);\n+                    columns[j]->insertFrom(*column_from_block.column, row_num);\n             }\n         }\n         else\n         {\n             for (size_t j = 0, size = right_indexes.size(); j < size; ++j)\n             {\n-                columns[j]->insertFrom(*block.getByPosition(right_indexes[j]).column, row_num);\n+                auto column_from_block = block.getByPosition(right_indexes[j]);\n+                if (type_name[j].type->lowCardinality() != column_from_block.type->lowCardinality())\n+                {\n+                    JoinCommon::changeLowCardinalityInplace(column_from_block);\n+                }\n+                columns[j]->insertFrom(*column_from_block.column, row_num);\n             }\n         }\n     }\n@@ -1013,6 +1024,7 @@ class AddedColumns\n \n     void addColumn(const ColumnWithTypeAndName & src_column, const std::string & qualified_name)\n     {\n+\n         columns.push_back(src_column.column->cloneEmpty());\n         columns.back()->reserve(src_column.column->size());\n         type_name.emplace_back(src_column.type, src_column.name, qualified_name);\ndiff --git a/src/Interpreters/join_common.cpp b/src/Interpreters/join_common.cpp\nindex 478df653f3b2..47b792f81e95 100644\n--- a/src/Interpreters/join_common.cpp\n+++ b/src/Interpreters/join_common.cpp\n@@ -326,9 +326,10 @@ ColumnRawPtrMap materializeColumnsInplaceMap(Block & block, const Names & names)\n \n     for (const auto & column_name : names)\n     {\n-        auto & column = block.getByName(column_name).column;\n-        column = recursiveRemoveLowCardinality(column->convertToFullColumnIfConst());\n-        ptrs[column_name] = column.get();\n+        auto & column = block.getByName(column_name);\n+        column.column = recursiveRemoveLowCardinality(column.column->convertToFullColumnIfConst());\n+        column.type = recursiveRemoveLowCardinality(column.type);\n+        ptrs[column_name] = column.column.get();\n     }\n \n     return ptrs;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02244_lowcardinality_hash_join.reference b/tests/queries/0_stateless/02244_lowcardinality_hash_join.reference\nnew file mode 100644\nindex 000000000000..d89bbd39cdc5\n--- /dev/null\n+++ b/tests/queries/0_stateless/02244_lowcardinality_hash_join.reference\n@@ -0,0 +1,4 @@\n+x\tx\n+x\tx\n+x\tx\n+x\tx\ndiff --git a/tests/queries/0_stateless/02244_lowcardinality_hash_join.sql b/tests/queries/0_stateless/02244_lowcardinality_hash_join.sql\nnew file mode 100644\nindex 000000000000..f2a601adf067\n--- /dev/null\n+++ b/tests/queries/0_stateless/02244_lowcardinality_hash_join.sql\n@@ -0,0 +1,27 @@\n+-- Tags: no-parallel\n+DROP TABLE IF EXISTS lc_table;\n+\n+CREATE TABLE lc_table\n+(\n+    col LowCardinality(String)\n+) ENGINE=TinyLog;\n+\n+INSERT INTO lc_table VALUES('x');\n+\n+SELECT *\n+FROM lc_table\n+INNER JOIN lc_table AS lc_table2 ON lc_table.col = lc_table2.col;\n+\n+SELECT *\n+FROM lc_table\n+INNER JOIN lc_table AS lc_table2 ON CAST(lc_table.col AS String) = CAST(lc_table2.col AS String);\n+\n+SELECT *\n+FROM lc_table\n+INNER JOIN lc_table AS lc_table2 ON (lc_table.col = lc_table2.col) OR (lc_table.col = lc_table2.col);\n+\n+SELECT *\n+FROM lc_table\n+INNER JOIN lc_table AS lc_table2 ON (CAST(lc_table.col AS String) = CAST(lc_table2.col AS String)) OR (CAST(lc_table.col AS String) = CAST(lc_table2.col AS String));\n+\n+DROP TABLE IF EXISTS lc_table;\n",
  "problem_statement": "Unable to use LowCardinality column in JOIN ON condition containing OR operator\n**Describe what's wrong**\r\n\r\nIncluding a LowCardinality column in an `ON` clause containing an `OR` operator results in this exception:\r\n\r\n```\r\nDB::Exception: Expected ColumnLowCardinality, got String: While executing JoiningTransform. (ILLEGAL_COLUMN)\r\n```\r\n\r\n**Does it reproduce on recent release?**\r\n\r\n22.1.2\r\n\r\n**How to reproduce**\r\n\r\nMinimal repro case:\r\n\r\n```sql\r\nWITH t1 AS\r\n    (\r\n        SELECT toLowCardinality('x') AS col\r\n    )\r\nSELECT *\r\nFROM t1\r\nINNER JOIN t1 AS t2 ON (t1.col = t2.col) OR (t1.col = t2.col)\r\n```\r\n\r\nHowever, casting to String works:\r\n\r\n```sql\r\nWITH t1 AS\r\n    (\r\n        SELECT toLowCardinality('x') AS col\r\n    )\r\nSELECT *\r\nFROM t1\r\nINNER JOIN t1 AS t2 ON (CAST(t1.col AS String) = CAST(t2.col AS String)) OR (CAST(t1.col AS String) = CAST(t2.col AS String))\r\n```\r\n\r\nWithout `OR`, casting is not necessary:\r\n\r\n```sql\r\nWITH t1 AS\r\n    (\r\n        SELECT toLowCardinality('x') AS col\r\n    )\r\nSELECT *\r\nFROM t1\r\nINNER JOIN t1 AS t2 ON t1.col = t2.col\r\n```\r\n\r\n**Expected behavior**\r\n\r\nIt should not be necessary to use CAST when joining on a LowCardinality column with multiple `OR` expressions.\n",
  "hints_text": "@vdimir PTAL",
  "created_at": "2022-03-25T12:12:45Z",
  "modified_files": [
    "src/Interpreters/HashJoin.cpp",
    "src/Interpreters/join_common.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02244_lowcardinality_hash_join.reference",
    "b/tests/queries/0_stateless/02244_lowcardinality_hash_join.sql"
  ]
}