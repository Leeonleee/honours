{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 12173,
  "instance_id": "ClickHouse__ClickHouse-12173",
  "issue_numbers": [
    "7867"
  ],
  "base_commit": "66bed10ec1cfb6f80b87a1b84f2579d1bbeec50f",
  "patch": "diff --git a/programs/copier/Internals.cpp b/programs/copier/Internals.cpp\nindex 518395e3b7dd..12da07a772a9 100644\n--- a/programs/copier/Internals.cpp\n+++ b/programs/copier/Internals.cpp\n@@ -169,17 +169,6 @@ ASTPtr extractOrderBy(const ASTPtr & storage_ast)\n }\n \n \n-String createCommaSeparatedStringFrom(const Names & names)\n-{\n-    std::ostringstream ss;\n-    if (!names.empty())\n-    {\n-        std::copy(names.begin(), std::prev(names.end()), std::ostream_iterator<std::string>(ss, \", \"));\n-        ss << names.back();\n-    }\n-    return ss.str();\n-}\n-\n Names extractPrimaryKeyColumnNames(const ASTPtr & storage_ast)\n {\n     const auto sorting_key_ast = extractOrderBy(storage_ast);\ndiff --git a/programs/copier/Internals.h b/programs/copier/Internals.h\nindex b1a94e1a5ca0..b61b6d59629b 100644\n--- a/programs/copier/Internals.h\n+++ b/programs/copier/Internals.h\n@@ -40,6 +40,7 @@\n #include <Columns/ColumnString.h>\n #include <Columns/ColumnsNumber.h>\n #include <DataTypes/DataTypeString.h>\n+#include <DataTypes/NestedUtils.h>\n #include <Parsers/ParserCreateQuery.h>\n #include <Parsers/parseQuery.h>\n #include <Parsers/ParserQuery.h>\n@@ -197,8 +198,6 @@ ASTPtr extractPrimaryKey(const ASTPtr & storage_ast);\n \n ASTPtr extractOrderBy(const ASTPtr & storage_ast);\n \n-String createCommaSeparatedStringFrom(const Names & names);\n-\n Names extractPrimaryKeyColumnNames(const ASTPtr & storage_ast);\n \n String extractReplicatedTableZookeeperPath(const ASTPtr & storage_ast);\ndiff --git a/programs/copier/TaskTableAndShard.h b/programs/copier/TaskTableAndShard.h\nindex 32841e93a145..0ac533d92097 100644\n--- a/programs/copier/TaskTableAndShard.h\n+++ b/programs/copier/TaskTableAndShard.h\n@@ -268,7 +268,7 @@ inline TaskTable::TaskTable(TaskCluster & parent, const Poco::Util::AbstractConf\n         ParserStorage parser_storage;\n         engine_push_ast = parseQuery(parser_storage, engine_push_str, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n         engine_push_partition_key_ast = extractPartitionKey(engine_push_ast);\n-        primary_key_comma_separated = createCommaSeparatedStringFrom(extractPrimaryKeyColumnNames(engine_push_ast));\n+        primary_key_comma_separated = Nested::createCommaSeparatedStringFrom(extractPrimaryKeyColumnNames(engine_push_ast));\n         engine_push_zk_path = extractReplicatedTableZookeeperPath(engine_push_ast);\n     }\n \ndiff --git a/src/DataTypes/NestedUtils.cpp b/src/DataTypes/NestedUtils.cpp\nindex 5f8b9f877bf9..e365c73a845d 100644\n--- a/src/DataTypes/NestedUtils.cpp\n+++ b/src/DataTypes/NestedUtils.cpp\n@@ -70,6 +70,17 @@ std::pair<std::string, std::string> splitName(const std::string & name)\n     return {{ begin, first_end }, { second_begin, end }};\n }\n \n+std::string createCommaSeparatedStringFrom(const Names & names)\n+{\n+    std::ostringstream ss;\n+    if (!names.empty())\n+    {\n+        std::copy(names.begin(), std::prev(names.end()), std::ostream_iterator<std::string>(ss, \", \"));\n+        ss << names.back();\n+    }\n+    return ss.str();\n+}\n+\n \n std::string extractTableName(const std::string & nested_name)\n {\ndiff --git a/src/DataTypes/NestedUtils.h b/src/DataTypes/NestedUtils.h\nindex 3039fd7f118a..4be3e69edfdc 100644\n--- a/src/DataTypes/NestedUtils.h\n+++ b/src/DataTypes/NestedUtils.h\n@@ -13,6 +13,8 @@ namespace Nested\n \n     std::pair<std::string, std::string> splitName(const std::string & name);\n \n+    std::string createCommaSeparatedStringFrom(const Names & names);\n+\n     /// Returns the prefix of the name to the first '.'. Or the name is unchanged if there is no dot.\n     std::string extractTableName(const std::string & nested_name);\n \ndiff --git a/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp b/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp\nindex 3833e3288fda..bc0c0fef6dc2 100644\n--- a/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp\n+++ b/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp\n@@ -94,6 +94,12 @@ static bool isInPrimaryKey(const SortDescription & description, const std::strin\n     return false;\n }\n \n+static bool isInPartitionKey(const std::string & column_name, const Names & partition_key_columns)\n+{\n+    auto is_in_partition_key = std::find(partition_key_columns.begin(), partition_key_columns.end(), column_name);\n+    return is_in_partition_key != partition_key_columns.end();\n+}\n+\n /// Returns true if merge result is not empty\n static bool mergeMap(const SummingSortedAlgorithm::MapDescription & desc,\n                      Row & row, const ColumnRawPtrs & raw_columns, size_t row_number)\n@@ -181,7 +187,8 @@ static bool mergeMap(const SummingSortedAlgorithm::MapDescription & desc,\n static SummingSortedAlgorithm::ColumnsDefinition defineColumns(\n     const Block & header,\n     const SortDescription & description,\n-    const Names & column_names_to_sum)\n+    const Names & column_names_to_sum,\n+    const Names & partition_key_columns)\n {\n     size_t num_columns = header.columns();\n     SummingSortedAlgorithm::ColumnsDefinition def;\n@@ -223,8 +230,8 @@ static SummingSortedAlgorithm::ColumnsDefinition defineColumns(\n                 continue;\n             }\n \n-            /// Are they inside the PK?\n-            if (isInPrimaryKey(description, column.name, i))\n+            /// Are they inside the primary key or partiton key?\n+            if (isInPrimaryKey(description, column.name, i) ||  isInPartitionKey(column.name, partition_key_columns))\n             {\n                 def.column_numbers_not_to_aggregate.push_back(i);\n                 continue;\n@@ -617,9 +624,10 @@ SummingSortedAlgorithm::SummingSortedAlgorithm(\n     const Block & header, size_t num_inputs,\n     SortDescription description_,\n     const Names & column_names_to_sum,\n+    const Names & partition_key_columns,\n     size_t max_block_size)\n     : IMergingAlgorithmWithDelayedChunk(num_inputs, std::move(description_))\n-    , columns_definition(defineColumns(header, description, column_names_to_sum))\n+    , columns_definition(defineColumns(header, description, column_names_to_sum, partition_key_columns))\n     , merged_data(getMergedDataColumns(header, columns_definition), max_block_size, columns_definition)\n {\n }\ndiff --git a/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.h b/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.h\nindex a188a5fb538a..2a455ad4ceaf 100644\n--- a/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.h\n+++ b/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.h\n@@ -20,6 +20,8 @@ class SummingSortedAlgorithm final : public IMergingAlgorithmWithDelayedChunk\n         SortDescription description_,\n         /// List of columns to be summed. If empty, all numeric columns that are not in the description are taken.\n         const Names & column_names_to_sum,\n+        /// List of partition key columns. They have to be excluded.\n+        const Names & partition_key_columns,\n         size_t max_block_size);\n \n     void initialize(Inputs inputs) override;\ndiff --git a/src/Processors/Merges/SummingSortedTransform.h b/src/Processors/Merges/SummingSortedTransform.h\nindex 6fc226811326..22361bb1a448 100644\n--- a/src/Processors/Merges/SummingSortedTransform.h\n+++ b/src/Processors/Merges/SummingSortedTransform.h\n@@ -16,6 +16,7 @@ class SummingSortedTransform final : public IMergingTransform<SummingSortedAlgor\n         SortDescription description_,\n         /// List of columns to be summed. If empty, all numeric columns that are not in the description are taken.\n         const Names & column_names_to_sum,\n+        const Names & partition_key_columns,\n         size_t max_block_size)\n         : IMergingTransform(\n             num_inputs, header, header, true,\n@@ -23,6 +24,7 @@ class SummingSortedTransform final : public IMergingTransform<SummingSortedAlgor\n             num_inputs,\n             std::move(description_),\n             column_names_to_sum,\n+            partition_key_columns,\n             max_block_size)\n     {\n     }\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex 1adb245d9e15..79b3a9aff35a 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -169,7 +169,7 @@ MergeTreeData::MergeTreeData(\n     const auto settings = getSettings();\n \n     /// NOTE: using the same columns list as is read when performing actual merges.\n-    merging_params.check(metadata_.getColumns().getAllPhysical());\n+    merging_params.check(metadata_);\n \n     if (metadata_.sampling_key.definition_ast != nullptr)\n     {\n@@ -521,8 +521,10 @@ void MergeTreeData::checkStoragePolicy(const StoragePolicyPtr & new_storage_poli\n }\n \n \n-void MergeTreeData::MergingParams::check(const NamesAndTypesList & columns) const\n+void MergeTreeData::MergingParams::check(const StorageInMemoryMetadata & metadata) const\n {\n+    const auto columns = metadata.getColumns().getAllPhysical();\n+\n     if (!sign_column.empty() && mode != MergingParams::Collapsing && mode != MergingParams::VersionedCollapsing)\n         throw Exception(\"Sign column for MergeTree cannot be specified in modes except Collapsing or VersionedCollapsing.\",\n                         ErrorCodes::LOGICAL_ERROR);\n@@ -607,6 +609,21 @@ void MergeTreeData::MergingParams::check(const NamesAndTypesList & columns) cons\n                 throw Exception(\n                         \"Column \" + column_to_sum + \" listed in columns to sum does not exist in table declaration.\", ErrorCodes::NO_SUCH_COLUMN_IN_TABLE);\n         }\n+\n+        /// Check that summing columns are not in partition key.\n+        if (metadata.isPartitionKeyDefined())\n+        {\n+            auto partition_key_columns = metadata.getPartitionKey().column_names;\n+\n+            Names names_intersection;\n+            std::set_intersection(columns_to_sum.begin(), columns_to_sum.end(),\n+                                  partition_key_columns.begin(), partition_key_columns.end(),\n+                                  std::back_inserter(names_intersection));\n+\n+            if (!names_intersection.empty())\n+                throw Exception(\"Colums: \" + Nested::createCommaSeparatedStringFrom(names_intersection) +\n+                \" listed both in colums to sum and in partition key. That is not allowed.\", ErrorCodes::BAD_ARGUMENTS);\n+        }\n     }\n \n     if (mode == MergingParams::Replacing)\n@@ -638,7 +655,6 @@ String MergeTreeData::MergingParams::getModeName() const\n     __builtin_unreachable();\n }\n \n-\n Int64 MergeTreeData::getMaxBlockNumber() const\n {\n     auto lock = lockParts();\ndiff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h\nindex 8fcb879b3ff9..0038d2306a41 100644\n--- a/src/Storages/MergeTree/MergeTreeData.h\n+++ b/src/Storages/MergeTree/MergeTreeData.h\n@@ -301,7 +301,7 @@ class MergeTreeData : public IStorage\n         Graphite::Params graphite_params;\n \n         /// Check that needed columns are present and have correct types.\n-        void check(const NamesAndTypesList & columns) const;\n+        void check(const StorageInMemoryMetadata & metadata) const;\n \n         String getModeName() const;\n     };\ndiff --git a/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp b/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\nindex 00830dd78c24..52aa92d9f489 100644\n--- a/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\n@@ -739,6 +739,8 @@ MergeTreeData::MutableDataPartPtr MergeTreeDataMergerMutator::mergePartsToTempor\n     size_t sort_columns_size = sort_columns.size();\n     sort_description.reserve(sort_columns_size);\n \n+    Names partition_key_columns = metadata_snapshot->getPartitionKey().column_names;\n+\n     Block header = pipes.at(0).getHeader();\n     for (size_t i = 0; i < sort_columns_size; ++i)\n         sort_description.emplace_back(header.getPositionByName(sort_columns[i]), 1, 1);\n@@ -767,7 +769,7 @@ MergeTreeData::MutableDataPartPtr MergeTreeDataMergerMutator::mergePartsToTempor\n \n         case MergeTreeData::MergingParams::Summing:\n             merged_transform = std::make_unique<SummingSortedTransform>(\n-                header, pipes.size(), sort_description, data.merging_params.columns_to_sum, merge_block_size);\n+                header, pipes.size(), sort_description, data.merging_params.columns_to_sum, partition_key_columns, merge_block_size);\n             break;\n \n         case MergeTreeData::MergingParams::Aggregating:\ndiff --git a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\nindex 69e819a3cf57..4eee1f1fccb2 100644\n--- a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n@@ -1160,6 +1160,8 @@ Pipes MergeTreeDataSelectExecutor::spreadMarkRangesAmongStreamsFinal(\n     size_t sort_columns_size = sort_columns.size();\n     sort_description.reserve(sort_columns_size);\n \n+    Names partition_key_columns = metadata_snapshot->getPartitionKey().column_names;\n+\n     Block header = pipes.at(0).getHeader();\n     for (size_t i = 0; i < sort_columns_size; ++i)\n         sort_description.emplace_back(header.getPositionByName(sort_columns[i]), 1, 1);\n@@ -1180,7 +1182,7 @@ Pipes MergeTreeDataSelectExecutor::spreadMarkRangesAmongStreamsFinal(\n \n             case MergeTreeData::MergingParams::Summing:\n                 return std::make_shared<SummingSortedTransform>(header, pipes.size(),\n-                           sort_description, data.merging_params.columns_to_sum, max_block_size);\n+                           sort_description, data.merging_params.columns_to_sum, partition_key_columns, max_block_size);\n \n             case MergeTreeData::MergingParams::Aggregating:\n                 return std::make_shared<AggregatingSortedTransform>(header, pipes.size(),\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01373_summing_merge_tree_exclude_partition_key.reference b/tests/queries/0_stateless/01373_summing_merge_tree_exclude_partition_key.reference\nnew file mode 100644\nindex 000000000000..3732e9403cec\n--- /dev/null\n+++ b/tests/queries/0_stateless/01373_summing_merge_tree_exclude_partition_key.reference\n@@ -0,0 +1,20 @@\n+---\n+1000000\n+---\n+17\n+---\n+0\t17\n+---\n+0\t17\n+1\t17\n+2\t17\n+3\t17\n+4\t17\n+5\t17\n+6\t17\n+7\t17\n+8\t17\n+9\t17\n+10\t17\n+11\t17\n+12\t17\ndiff --git a/tests/queries/0_stateless/01373_summing_merge_tree_exclude_partition_key.sql b/tests/queries/0_stateless/01373_summing_merge_tree_exclude_partition_key.sql\nnew file mode 100644\nindex 000000000000..60c988a2e2f9\n--- /dev/null\n+++ b/tests/queries/0_stateless/01373_summing_merge_tree_exclude_partition_key.sql\n@@ -0,0 +1,26 @@\n+DROP TABLE IF EXISTS tt_01373;\n+\n+CREATE TABLE tt_01373\n+(a Int64, d Int64, val Int64) \n+ENGINE = SummingMergeTree PARTITION BY (a) ORDER BY (d);\n+\n+SYSTEM STOP MERGES;\n+\n+INSERT INTO tt_01373 SELECT number%13, number%17, 1 from numbers(1000000);\n+\n+SELECT '---';\n+SELECT count(*) FROM tt_01373;\n+\n+SELECT '---';\n+SELECT count(*) FROM tt_01373 FINAL;\n+\n+SELECT '---';\n+SELECT a, count() FROM tt_01373 FINAL GROUP BY a ORDER BY a;\n+\n+SYSTEM START MERGES;\n+\n+OPTIMIZE TABLE tt_01373 FINAL;\n+SELECT '---';\n+SELECT a, count() FROM tt_01373 GROUP BY a ORDER BY a;\n+\n+DROP TABLE IF EXISTS tt_01373;\ndiff --git a/tests/queries/0_stateless/01373_summing_merge_tree_explicit_columns_definition.reference b/tests/queries/0_stateless/01373_summing_merge_tree_explicit_columns_definition.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/01373_summing_merge_tree_explicit_columns_definition.sql b/tests/queries/0_stateless/01373_summing_merge_tree_explicit_columns_definition.sql\nnew file mode 100644\nindex 000000000000..cc456b3a2573\n--- /dev/null\n+++ b/tests/queries/0_stateless/01373_summing_merge_tree_explicit_columns_definition.sql\n@@ -0,0 +1,7 @@\n+DROP TABLE IF EXISTS tt_error_1373;\n+\n+CREATE TABLE tt_error_1373\n+( a   Int64, d   Int64, val Int64 ) \n+ENGINE = SummingMergeTree((a, val)) PARTITION BY (a) ORDER BY (d); -- { serverError 36 }\n+\n+DROP TABLE IF EXISTS tt_error_1373;\n\\ No newline at end of file\n",
  "problem_statement": "Discrepancy. SummingMergeTree sums partition key but does't update min_max\nIt was kinda unexpected that SummingMergeTree sums partition key columns.\r\n\r\nProbably CH have to forbid such schema on create table and raise an error.\r\nOr exclude partition key columns from sum list.\r\n```\r\nCREATE TABLE tt\r\n( a   Int64, d   Int64, val Int64 ) \r\nENGINE = SummingMergeTree PARTITION BY (a) ORDER BY (d);\r\n\r\ninsert into tt select number%13, number%17, 1 from numbers(1000000);\r\n\r\noptimize table tt final;\r\n\r\nselect a, count() from tt group by a;\r\n\u250c\u2500\u2500\u2500\u2500\u2500a\u2500\u252c\u2500count()\u2500\u2510\r\n\u2502     0 \u2502      17 \u2502\r\n\u2502 40725 \u2502      15 \u2502\r\n\u2502 18096 \u2502       2 \u2502\r\n\u2502 45240 \u2502       2 \u2502\r\n\u2502 13572 \u2502       2 \u2502\r\n\u2502 49775 \u2502      15 \u2502\r\n\u2502 54288 \u2502       2 \u2502\r\n\u2502 31668 \u2502       2 \u2502\r\n\u2502 40716 \u2502       2 \u2502\r\n\u2502  4524 \u2502       2 \u2502\r\n\u2502 36192 \u2502       2 \u2502\r\n\u2502 18100 \u2502      15 \u2502\r\n\u2502 13575 \u2502      15 \u2502\r\n\u2502  4525 \u2502      15 \u2502\r\n\u2502 22625 \u2502      15 \u2502\r\n\u2502 45250 \u2502      15 \u2502\r\n\u2502  9050 \u2502      15 \u2502\r\n\u2502 27150 \u2502      15 \u2502\r\n\u2502 54300 \u2502      15 \u2502\r\n\u2502 27144 \u2502       2 \u2502\r\n\u2502 49764 \u2502       2 \u2502\r\n\u2502 36200 \u2502      15 \u2502\r\n\u2502 22620 \u2502       2 \u2502\r\n\u2502  9048 \u2502       2 \u2502\r\n\u2502 31675 \u2502      15 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\r\nselect * from tt where a>13;\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.001 sec.\r\n```\n",
  "hints_text": "@nikitamikhaylov We should exclude all columns that are arguments of partition key expression from summing.\r\n\r\nIf the user explicitly specified that columns in the list of columns to sum - throw an exception.",
  "created_at": "2020-07-06T14:36:47Z"
}