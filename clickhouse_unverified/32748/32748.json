{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 32748,
  "instance_id": "ClickHouse__ClickHouse-32748",
  "issue_numbers": [
    "7102"
  ],
  "base_commit": "b84591d17a18410dd2672bf22d44a45f4f7d70ec",
  "patch": "diff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex c8f48f2ed1f9..48a41b65b6ea 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -1924,6 +1924,7 @@ void InterpreterSelectQuery::executeFetchColumns(QueryProcessingStage::Enum proc\n                 {\n                     query_info.projection->order_optimizer = std::make_shared<ReadInOrderOptimizer>(\n                         // TODO Do we need a projection variant for this field?\n+                        query,\n                         analysis_result.order_by_elements_actions,\n                         getSortDescription(query, context),\n                         query_info.syntax_analyzer_result);\n@@ -1931,7 +1932,10 @@ void InterpreterSelectQuery::executeFetchColumns(QueryProcessingStage::Enum proc\n                 else\n                 {\n                     query_info.order_optimizer = std::make_shared<ReadInOrderOptimizer>(\n-                        analysis_result.order_by_elements_actions, getSortDescription(query, context), query_info.syntax_analyzer_result);\n+                        query,\n+                        analysis_result.order_by_elements_actions,\n+                        getSortDescription(query, context),\n+                        query_info.syntax_analyzer_result);\n                 }\n             }\n             else\n@@ -1939,6 +1943,7 @@ void InterpreterSelectQuery::executeFetchColumns(QueryProcessingStage::Enum proc\n                 if (query_info.projection)\n                 {\n                     query_info.projection->order_optimizer = std::make_shared<ReadInOrderOptimizer>(\n+                        query,\n                         query_info.projection->group_by_elements_actions,\n                         getSortDescriptionFromGroupBy(query),\n                         query_info.syntax_analyzer_result);\n@@ -1946,7 +1951,10 @@ void InterpreterSelectQuery::executeFetchColumns(QueryProcessingStage::Enum proc\n                 else\n                 {\n                     query_info.order_optimizer = std::make_shared<ReadInOrderOptimizer>(\n-                        analysis_result.group_by_elements_actions, getSortDescriptionFromGroupBy(query), query_info.syntax_analyzer_result);\n+                        query,\n+                        analysis_result.group_by_elements_actions,\n+                        getSortDescriptionFromGroupBy(query),\n+                        query_info.syntax_analyzer_result);\n                 }\n             }\n \ndiff --git a/src/Interpreters/TreeCNFConverter.cpp b/src/Interpreters/TreeCNFConverter.cpp\nindex a55bacee5fad..149bddab11fb 100644\n--- a/src/Interpreters/TreeCNFConverter.cpp\n+++ b/src/Interpreters/TreeCNFConverter.cpp\n@@ -26,7 +26,7 @@ bool isLogicalFunction(const ASTFunction & func)\n size_t countAtoms(const ASTPtr & node)\n {\n     checkStackSize();\n-    if (node->as<ASTIdentifier>())\n+    if (node->as<ASTIdentifier>() || node->as<ASTLiteral>())\n         return 1;\n \n     const auto * func = node->as<ASTFunction>();\ndiff --git a/src/Processors/QueryPlan/ReadFromMergeTree.cpp b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\nindex eddbbb9138c0..3df9dc127f39 100644\n--- a/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n+++ b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n@@ -365,7 +365,6 @@ static ActionsDAGPtr createProjection(const Block & header)\n Pipe ReadFromMergeTree::spreadMarkRangesAmongStreamsWithOrder(\n     RangesInDataParts && parts_with_ranges,\n     const Names & column_names,\n-    const ActionsDAGPtr & sorting_key_prefix_expr,\n     ActionsDAGPtr & out_projection,\n     const InputOrderInfoPtr & input_order_info)\n {\n@@ -507,10 +506,19 @@ Pipe ReadFromMergeTree::spreadMarkRangesAmongStreamsWithOrder(\n \n     if (need_preliminary_merge)\n     {\n+        size_t fixed_prefix_size = input_order_info->order_key_fixed_prefix_descr.size();\n+        size_t prefix_size = fixed_prefix_size + input_order_info->order_key_prefix_descr.size();\n+\n+        auto order_key_prefix_ast = metadata_snapshot->getSortingKey().expression_list_ast->clone();\n+        order_key_prefix_ast->children.resize(prefix_size);\n+\n+        auto syntax_result = TreeRewriter(context).analyze(order_key_prefix_ast, metadata_snapshot->getColumns().getAllPhysical());\n+        auto sorting_key_prefix_expr = ExpressionAnalyzer(order_key_prefix_ast, syntax_result, context).getActionsDAG(false);\n+        const auto & sorting_columns = metadata_snapshot->getSortingKey().column_names;\n+\n         SortDescription sort_description;\n-        for (size_t j = 0; j < input_order_info->order_key_prefix_descr.size(); ++j)\n-            sort_description.emplace_back(metadata_snapshot->getSortingKey().column_names[j],\n-                                          input_order_info->direction, 1);\n+        for (size_t j = 0; j < prefix_size; ++j)\n+            sort_description.emplace_back(sorting_columns[j], input_order_info->direction);\n \n         auto sorting_key_expr = std::make_shared<ExpressionActions>(sorting_key_prefix_expr);\n \n@@ -1048,17 +1056,9 @@ void ReadFromMergeTree::initializePipeline(QueryPipelineBuilder & pipeline, cons\n     }\n     else if ((settings.optimize_read_in_order || settings.optimize_aggregation_in_order) && input_order_info)\n     {\n-        size_t prefix_size = input_order_info->order_key_prefix_descr.size();\n-        auto order_key_prefix_ast = metadata_snapshot->getSortingKey().expression_list_ast->clone();\n-        order_key_prefix_ast->children.resize(prefix_size);\n-\n-        auto syntax_result = TreeRewriter(context).analyze(order_key_prefix_ast, metadata_snapshot->getColumns().getAllPhysical());\n-        auto sorting_key_prefix_expr = ExpressionAnalyzer(order_key_prefix_ast, syntax_result, context).getActionsDAG(false);\n-\n         pipe = spreadMarkRangesAmongStreamsWithOrder(\n             std::move(result.parts_with_ranges),\n             column_names_to_read,\n-            sorting_key_prefix_expr,\n             result_projection,\n             input_order_info);\n     }\ndiff --git a/src/Processors/QueryPlan/ReadFromMergeTree.h b/src/Processors/QueryPlan/ReadFromMergeTree.h\nindex 0bdfa66bcc7a..0d07a3e2ea29 100644\n--- a/src/Processors/QueryPlan/ReadFromMergeTree.h\n+++ b/src/Processors/QueryPlan/ReadFromMergeTree.h\n@@ -173,7 +173,6 @@ class ReadFromMergeTree final : public ISourceStep\n     Pipe spreadMarkRangesAmongStreamsWithOrder(\n         RangesInDataParts && parts_with_ranges,\n         const Names & column_names,\n-        const ActionsDAGPtr & sorting_key_prefix_expr,\n         ActionsDAGPtr & out_projection,\n         const InputOrderInfoPtr & input_order_info);\n \ndiff --git a/src/Storages/ReadInOrderOptimizer.cpp b/src/Storages/ReadInOrderOptimizer.cpp\nindex bae24f97b286..9e46595e0fc0 100644\n--- a/src/Storages/ReadInOrderOptimizer.cpp\n+++ b/src/Storages/ReadInOrderOptimizer.cpp\n@@ -6,6 +6,8 @@\n #include <Interpreters/replaceAliasColumnsInQuery.h>\n #include <Functions/IFunction.h>\n #include <Interpreters/TableJoin.h>\n+#include <Parsers/ASTSelectQuery.h>\n+#include <Parsers/ASTFunction.h>\n \n namespace DB\n {\n@@ -15,13 +17,152 @@ namespace ErrorCodes\n     extern const int LOGICAL_ERROR;\n }\n \n+namespace\n+{\n+\n+ASTPtr getFixedPoint(const ASTPtr & ast)\n+{\n+    const auto * func = ast->as<ASTFunction>();\n+    if (!func || func->name != \"equals\")\n+        return nullptr;\n+\n+    const auto & lhs = func->arguments->children[0];\n+    const auto & rhs = func->arguments->children[1];\n+\n+    if (lhs->as<ASTLiteral>())\n+        return rhs;\n+\n+    if (rhs->as<ASTLiteral>())\n+        return lhs;\n+\n+    return nullptr;\n+}\n+\n+size_t calculateFixedPrefixSize(\n+    const ASTSelectQuery & query, const Names & sorting_key_columns)\n+{\n+    ASTPtr condition;\n+    if (query.where() && query.prewhere())\n+        condition = makeASTFunction(\"and\", query.where(), query.prewhere());\n+    else if (query.where())\n+        condition = query.where();\n+    else if (query.prewhere())\n+        condition = query.prewhere();\n+\n+    if (!condition)\n+        return 0;\n+\n+    /// Convert condition to CNF for more convenient analysis.\n+    auto cnf = TreeCNFConverter::tryConvertToCNF(condition);\n+    if (!cnf)\n+        return 0;\n+\n+    NameSet fixed_points;\n+\n+    /// If we met expression like 'column = x', where 'x' is literal,\n+    /// in clause of size 1 in CNF, then we can guarantee\n+    /// that in all filtered rows 'column' will be equal to 'x'.\n+    cnf->iterateGroups([&](const auto & group)\n+    {\n+        if (group.size() == 1 && !group.begin()->negative)\n+        {\n+            auto fixed_point = getFixedPoint(group.begin()->ast);\n+            if (fixed_point)\n+                fixed_points.insert(fixed_point->getColumnName());\n+        }\n+    });\n+\n+    size_t prefix_size = 0;\n+    for (const auto & column_name : sorting_key_columns)\n+    {\n+        if (!fixed_points.contains(column_name))\n+            break;\n+\n+        ++prefix_size;\n+    }\n+\n+    return prefix_size;\n+}\n+\n+/// Optimize in case of exact match with order key element\n+/// or in some simple cases when order key element is wrapped into monotonic function.\n+/// Returns on of {-1, 0, 1} - direction of the match. 0 means - doesn't match.\n+int matchSortDescriptionAndKey(\n+    const ExpressionActions::Actions & actions,\n+    const SortColumnDescription & sort_column,\n+    const String & sorting_key_column)\n+{\n+    /// If required order depend on collation, it cannot be matched with primary key order.\n+    /// Because primary keys cannot have collations.\n+    if (sort_column.collator)\n+        return 0;\n+\n+    int current_direction = sort_column.direction;\n+    /// For the path: order by (sort_column, ...)\n+    if (sort_column.column_name == sorting_key_column)\n+        return current_direction;\n+\n+    /// For the path: order by (function(sort_column), ...)\n+    /// Allow only one simple monotonic functions with one argument\n+    /// Why not allow multi monotonic functions?\n+    bool found_function = false;\n+\n+    for (const auto & action : actions)\n+    {\n+        if (action.node->type != ActionsDAG::ActionType::FUNCTION)\n+            continue;\n+\n+        if (found_function)\n+        {\n+            current_direction = 0;\n+            break;\n+        }\n+        else\n+        {\n+            found_function = true;\n+        }\n+\n+        if (action.node->children.size() != 1 || action.node->children.at(0)->result_name != sorting_key_column)\n+        {\n+            current_direction = 0;\n+            break;\n+        }\n+\n+        const auto & func = *action.node->function_base;\n+        if (!func.hasInformationAboutMonotonicity())\n+        {\n+            current_direction = 0;\n+            break;\n+        }\n+\n+        auto monotonicity = func.getMonotonicityForRange(*func.getArgumentTypes().at(0), {}, {});\n+        if (!monotonicity.is_monotonic)\n+        {\n+            current_direction = 0;\n+            break;\n+        }\n+        else if (!monotonicity.is_positive)\n+        {\n+            current_direction *= -1;\n+        }\n+    }\n+\n+    if (!found_function)\n+        current_direction = 0;\n+\n+    return current_direction;\n+}\n+\n+}\n \n ReadInOrderOptimizer::ReadInOrderOptimizer(\n+    const ASTSelectQuery & query_,\n     const ManyExpressionActions & elements_actions_,\n     const SortDescription & required_sort_description_,\n     const TreeRewriterResultPtr & syntax_result)\n     : elements_actions(elements_actions_)\n     , required_sort_description(required_sort_description_)\n+    , query(query_)\n {\n     if (elements_actions.size() != required_sort_description.size())\n         throw Exception(\"Sizes of sort description and actions are mismatched\", ErrorCodes::LOGICAL_ERROR);\n@@ -35,126 +176,88 @@ ReadInOrderOptimizer::ReadInOrderOptimizer(\n     array_join_result_to_source = syntax_result->array_join_result_to_source;\n }\n \n-InputOrderInfoPtr ReadInOrderOptimizer::getInputOrder(const StorageMetadataPtr & metadata_snapshot, ContextPtr context, UInt64 limit) const\n+InputOrderInfoPtr ReadInOrderOptimizer::getInputOrderImpl(\n+    const StorageMetadataPtr & metadata_snapshot,\n+    const SortDescription & description,\n+    const ManyExpressionActions & actions,\n+    UInt64 limit) const\n {\n-    Names sorting_key_columns = metadata_snapshot->getSortingKeyColumns();\n-    if (!metadata_snapshot->hasSortingKey())\n-        return {};\n+    auto sorting_key_columns = metadata_snapshot->getSortingKeyColumns();\n+    int read_direction = description.at(0).direction;\n+\n+    size_t fixed_prefix_size = calculateFixedPrefixSize(query, sorting_key_columns);\n+    size_t descr_prefix_size = std::min(description.size(), sorting_key_columns.size() - fixed_prefix_size);\n \n     SortDescription order_key_prefix_descr;\n-    int read_direction = required_sort_description.at(0).direction;\n+    order_key_prefix_descr.reserve(descr_prefix_size);\n+\n+    for (size_t i = 0; i < descr_prefix_size; ++i)\n+    {\n+        if (forbidden_columns.count(description[i].column_name))\n+            break;\n+\n+        int current_direction = matchSortDescriptionAndKey(\n+            actions[i]->getActions(), description[i], sorting_key_columns[i + fixed_prefix_size]);\n+\n+        if (!current_direction || (i > 0 && current_direction != read_direction))\n+            break;\n+\n+        if (i == 0)\n+            read_direction = current_direction;\n+\n+        order_key_prefix_descr.push_back(required_sort_description[i]);\n+    }\n+\n+    if (order_key_prefix_descr.empty())\n+        return {};\n+\n+    SortDescription order_key_fixed_prefix_descr;\n+    order_key_fixed_prefix_descr.reserve(fixed_prefix_size);\n+    for (size_t i = 0; i < fixed_prefix_size; ++i)\n+        order_key_fixed_prefix_descr.emplace_back(sorting_key_columns[i], read_direction);\n+\n+    return std::make_shared<InputOrderInfo>(\n+        std::move(order_key_fixed_prefix_descr),\n+        std::move(order_key_prefix_descr),\n+        read_direction, limit);\n+}\n+\n+InputOrderInfoPtr ReadInOrderOptimizer::getInputOrder(\n+    const StorageMetadataPtr & metadata_snapshot, ContextPtr context, UInt64 limit) const\n+{\n+    if (!metadata_snapshot->hasSortingKey())\n+        return {};\n \n-    size_t prefix_size = std::min(required_sort_description.size(), sorting_key_columns.size());\n     auto aliased_columns = metadata_snapshot->getColumns().getAliases();\n \n-    for (size_t i = 0; i < prefix_size; ++i)\n+    /// Replace alias column with proper expressions.\n+    /// Currently we only support alias column without any function wrapper,\n+    /// i.e.: `order by aliased_column` can have this optimization, but `order by function(aliased_column)` can not.\n+    /// This suits most cases.\n+    if (context->getSettingsRef().optimize_respect_aliases && !aliased_columns.empty())\n     {\n-        if (forbidden_columns.count(required_sort_description[i].column_name))\n-            break;\n+        SortDescription aliases_sort_description = required_sort_description;\n+        ManyExpressionActions aliases_actions = elements_actions;\n \n-        /// Optimize in case of exact match with order key element\n-        ///  or in some simple cases when order key element is wrapped into monotonic function.\n-        auto apply_order_judge = [&] (const ExpressionActions::Actions & actions, const String & sort_column)\n-        {\n-            /// If required order depend on collation, it cannot be matched with primary key order.\n-            /// Because primary keys cannot have collations.\n-            if (required_sort_description[i].collator)\n-                return false;\n-\n-            int current_direction = required_sort_description[i].direction;\n-            /// For the path: order by (sort_column, ...)\n-            if (sort_column == sorting_key_columns[i] && current_direction == read_direction)\n-            {\n-                return true;\n-            }\n-            /// For the path: order by (function(sort_column), ...)\n-            /// Allow only one simple monotonic functions with one argument\n-            /// Why not allow multi monotonic functions?\n-            else\n-            {\n-                bool found_function = false;\n-\n-                for (const auto & action : actions)\n-                {\n-                    if (action.node->type != ActionsDAG::ActionType::FUNCTION)\n-                    {\n-                        continue;\n-                    }\n-\n-                    if (found_function)\n-                    {\n-                        current_direction = 0;\n-                        break;\n-                    }\n-                    else\n-                        found_function = true;\n-\n-                    if (action.node->children.size() != 1 || action.node->children.at(0)->result_name != sorting_key_columns[i])\n-                    {\n-                        current_direction = 0;\n-                        break;\n-                    }\n-\n-                    const auto & func = *action.node->function_base;\n-                    if (!func.hasInformationAboutMonotonicity())\n-                    {\n-                        current_direction = 0;\n-                        break;\n-                    }\n-\n-                    auto monotonicity = func.getMonotonicityForRange(*func.getArgumentTypes().at(0), {}, {});\n-                    if (!monotonicity.is_monotonic)\n-                    {\n-                        current_direction = 0;\n-                        break;\n-                    }\n-                    else if (!monotonicity.is_positive)\n-                        current_direction *= -1;\n-                }\n-\n-                if (!found_function)\n-                    current_direction = 0;\n-\n-                if (!current_direction || (i > 0 && current_direction != read_direction))\n-                    return false;\n-\n-                if (i == 0)\n-                    read_direction = current_direction;\n-\n-                return true;\n-            }\n-        };\n-\n-        const auto & actions = elements_actions[i]->getActions();\n-        bool ok;\n-        /// check if it's alias column\n-        /// currently we only support alias column without any function wrapper\n-        /// ie: `order by aliased_column` can have this optimization, but `order by function(aliased_column)` can not.\n-        /// This suits most cases.\n-        if (context->getSettingsRef().optimize_respect_aliases && aliased_columns.contains(required_sort_description[i].column_name))\n+        for (size_t i = 0; i < required_sort_description.size(); ++i)\n         {\n+            if (!aliased_columns.contains(required_sort_description[i].column_name))\n+                continue;\n+\n             auto column_expr = metadata_snapshot->getColumns().get(required_sort_description[i].column_name).default_desc.expression->clone();\n             replaceAliasColumnsInQuery(column_expr, metadata_snapshot->getColumns(), array_join_result_to_source, context);\n \n             auto syntax_analyzer_result = TreeRewriter(context).analyze(column_expr, metadata_snapshot->getColumns().getAll());\n-            const auto expression_analyzer = ExpressionAnalyzer(column_expr, syntax_analyzer_result, context).getActions(true);\n-            const auto & alias_actions = expression_analyzer->getActions();\n+            auto expression_analyzer = ExpressionAnalyzer(column_expr, syntax_analyzer_result, context);\n \n-            ok = apply_order_judge(alias_actions, column_expr->getColumnName());\n+            aliases_sort_description[i].column_name = column_expr->getColumnName();\n+            aliases_actions[i] = expression_analyzer.getActions(true);\n         }\n-        else\n-            ok = apply_order_judge(actions, required_sort_description[i].column_name);\n \n-        if (ok)\n-            order_key_prefix_descr.push_back(required_sort_description[i]);\n-        else\n-            break;\n+        return getInputOrderImpl(metadata_snapshot, aliases_sort_description, aliases_actions, limit);\n     }\n \n-    if (order_key_prefix_descr.empty())\n-        return {};\n-\n-    return std::make_shared<InputOrderInfo>(std::move(order_key_prefix_descr), read_direction, limit);\n+    return getInputOrderImpl(metadata_snapshot, required_sort_description, elements_actions, limit);\n }\n \n }\ndiff --git a/src/Storages/ReadInOrderOptimizer.h b/src/Storages/ReadInOrderOptimizer.h\nindex 2686d0818559..fd8c9187ddb5 100644\n--- a/src/Storages/ReadInOrderOptimizer.h\n+++ b/src/Storages/ReadInOrderOptimizer.h\n@@ -18,6 +18,7 @@ class ReadInOrderOptimizer\n {\n public:\n     ReadInOrderOptimizer(\n+        const ASTSelectQuery & query,\n         const ManyExpressionActions & elements_actions,\n         const SortDescription & required_sort_description,\n         const TreeRewriterResultPtr & syntax_result);\n@@ -25,10 +26,17 @@ class ReadInOrderOptimizer\n     InputOrderInfoPtr getInputOrder(const StorageMetadataPtr & metadata_snapshot, ContextPtr context, UInt64 limit = 0) const;\n \n private:\n+    InputOrderInfoPtr getInputOrderImpl(\n+        const StorageMetadataPtr & metadata_snapshot,\n+        const SortDescription & description,\n+        const ManyExpressionActions & actions,\n+        UInt64 limit) const;\n+\n     /// Actions for every element of order expression to analyze functions for monotonicity\n     ManyExpressionActions elements_actions;\n     NameSet forbidden_columns;\n     NameToNameMap array_join_result_to_source;\n     SortDescription required_sort_description;\n+    const ASTSelectQuery & query;\n };\n }\ndiff --git a/src/Storages/SelectQueryInfo.h b/src/Storages/SelectQueryInfo.h\nindex e53f5adec529..a40bd7955d35 100644\n--- a/src/Storages/SelectQueryInfo.h\n+++ b/src/Storages/SelectQueryInfo.h\n@@ -87,19 +87,22 @@ struct FilterDAGInfo\n \n struct InputOrderInfo\n {\n+    SortDescription order_key_fixed_prefix_descr;\n     SortDescription order_key_prefix_descr;\n     int direction;\n     UInt64 limit;\n \n-    InputOrderInfo(const SortDescription & order_key_prefix_descr_, int direction_, UInt64 limit_)\n-        : order_key_prefix_descr(order_key_prefix_descr_), direction(direction_), limit(limit_) {}\n-\n-    bool operator ==(const InputOrderInfo & other) const\n+    InputOrderInfo(\n+        const SortDescription & order_key_fixed_prefix_descr_,\n+        const SortDescription & order_key_prefix_descr_,\n+        int direction_, UInt64 limit_)\n+        : order_key_fixed_prefix_descr(order_key_fixed_prefix_descr_)\n+        , order_key_prefix_descr(order_key_prefix_descr_)\n+        , direction(direction_), limit(limit_)\n     {\n-        return order_key_prefix_descr == other.order_key_prefix_descr && direction == other.direction;\n     }\n \n-    bool operator !=(const InputOrderInfo & other) const { return !(*this == other); }\n+    bool operator==(const InputOrderInfo &) const = default;\n };\n \n class IMergeTreeDataPart;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02149_read_in_order_fixed_prefix.reference b/tests/queries/0_stateless/02149_read_in_order_fixed_prefix.reference\nnew file mode 100644\nindex 000000000000..9e24b7c6ea6c\n--- /dev/null\n+++ b/tests/queries/0_stateless/02149_read_in_order_fixed_prefix.reference\n@@ -0,0 +1,155 @@\n+2020-10-01\t0\n+2020-10-01\t0\n+2020-10-01\t0\n+2020-10-01\t0\n+2020-10-01\t0\n+(Expression)\n+ExpressionTransform\n+  (Limit)\n+  Limit\n+    (Sorting)\n+    MergingSortedTransform 2 \u2192 1\n+      (Expression)\n+      ExpressionTransform \u00d7 2\n+        (SettingQuotaAndLimits)\n+          (ReadFromMergeTree)\n+          MergeTreeInOrder \u00d7 2 0 \u2192 1\n+2020-10-01\t9\n+2020-10-01\t9\n+2020-10-01\t9\n+2020-10-01\t9\n+2020-10-01\t9\n+(Expression)\n+ExpressionTransform\n+  (Limit)\n+  Limit\n+    (Sorting)\n+    MergingSortedTransform 2 \u2192 1\n+      (Expression)\n+      ExpressionTransform \u00d7 2\n+        (SettingQuotaAndLimits)\n+          (ReadFromMergeTree)\n+          ReverseTransform\n+            MergeTreeReverse 0 \u2192 1\n+              ReverseTransform\n+                MergeTreeReverse 0 \u2192 1\n+2020-10-01\t9\n+2020-10-01\t9\n+2020-10-01\t9\n+2020-10-01\t9\n+2020-10-01\t9\n+(Expression)\n+ExpressionTransform\n+  (Limit)\n+  Limit\n+    (Sorting)\n+    FinishSortingTransform\n+      PartialSortingTransform\n+        MergingSortedTransform 2 \u2192 1\n+          (Expression)\n+          ExpressionTransform \u00d7 2\n+            (SettingQuotaAndLimits)\n+              (ReadFromMergeTree)\n+              MergeTreeInOrder \u00d7 2 0 \u2192 1\n+2020-10-11\t0\n+2020-10-11\t0\n+2020-10-11\t0\n+2020-10-11\t0\n+2020-10-11\t0\n+(Expression)\n+ExpressionTransform\n+  (Limit)\n+  Limit\n+    (Sorting)\n+      (Expression)\n+      ExpressionTransform\n+        (Filter)\n+        FilterTransform\n+          (SettingQuotaAndLimits)\n+            (ReadFromMergeTree)\n+            MergeTreeInOrder 0 \u2192 1\n+2020-10-11\t0\t0\n+2020-10-11\t0\t10\n+2020-10-11\t0\t20\n+2020-10-11\t0\t30\n+2020-10-11\t0\t40\n+(Expression)\n+ExpressionTransform\n+  (Limit)\n+  Limit\n+    (Sorting)\n+    FinishSortingTransform\n+      PartialSortingTransform\n+        (Expression)\n+        ExpressionTransform\n+          (Filter)\n+          FilterTransform\n+            (SettingQuotaAndLimits)\n+              (ReadFromMergeTree)\n+              MergeTreeInOrder 0 \u2192 1\n+2020-10-12\t0\n+2020-10-12\t1\n+2020-10-12\t2\n+2020-10-12\t3\n+2020-10-12\t4\n+(Expression)\n+ExpressionTransform\n+  (Limit)\n+  Limit\n+    (Sorting)\n+      (Expression)\n+      ExpressionTransform\n+        (Filter)\n+        FilterTransform\n+          (SettingQuotaAndLimits)\n+            (ReadFromMergeTree)\n+            ReverseTransform\n+              MergeTreeReverse 0 \u2192 1\n+2020-10-12\t99999\n+2020-10-12\t99998\n+2020-10-12\t99997\n+2020-10-12\t99996\n+2020-10-12\t99995\n+1\t2\n+1\t2\n+1\t3\n+1\t3\n+1\t4\n+1\t4\n+========\n+1\t4\n+1\t4\n+1\t3\n+1\t3\n+1\t2\n+1\t2\n+(Expression)\n+ExpressionTransform\n+  (Limit)\n+  Limit\n+    (Sorting)\n+      (Expression)\n+      ExpressionTransform\n+        (SettingQuotaAndLimits)\n+          (ReadFromMergeTree)\n+          MergeTreeInOrder 0 \u2192 1\n+2020-10-10 00:00:00\t0.01\n+2020-10-10 00:00:00\t0.01\n+2020-10-10 00:00:00\t0.01\n+2020-10-10 00:00:00\t0.01\n+2020-10-10 00:00:00\t0.01\n+(Expression)\n+ExpressionTransform\n+  (Limit)\n+  Limit\n+    (Sorting)\n+      (Expression)\n+      ExpressionTransform\n+        (SettingQuotaAndLimits)\n+          (ReadFromMergeTree)\n+          MergeTreeInOrder 0 \u2192 1\n+2020-10-10 00:00:00\t0.01\n+2020-10-10 00:00:00\t0.01\n+2020-10-10 00:00:00\t0.01\n+2020-10-10 00:00:00\t0.01\n+2020-10-10 00:00:00\t0.01\ndiff --git a/tests/queries/0_stateless/02149_read_in_order_fixed_prefix.sql b/tests/queries/0_stateless/02149_read_in_order_fixed_prefix.sql\nnew file mode 100644\nindex 000000000000..7d0e9111d9c4\n--- /dev/null\n+++ b/tests/queries/0_stateless/02149_read_in_order_fixed_prefix.sql\n@@ -0,0 +1,58 @@\n+DROP TABLE IF EXISTS t_read_in_order;\n+\n+CREATE TABLE t_read_in_order(date Date, i UInt64, v UInt64)\n+ENGINE = MergeTree ORDER BY (date, i);\n+\n+INSERT INTO t_read_in_order SELECT '2020-10-10', number % 10, number FROM numbers(100000);\n+INSERT INTO t_read_in_order SELECT '2020-10-11', number % 10, number FROM numbers(100000);\n+\n+SELECT toStartOfMonth(date) as d, i FROM t_read_in_order ORDER BY d, i LIMIT 5;\n+EXPLAIN PIPELINE SELECT toStartOfMonth(date) as d, i FROM t_read_in_order ORDER BY d, i LIMIT 5;\n+\n+SELECT toStartOfMonth(date) as d, i FROM t_read_in_order ORDER BY d DESC, -i LIMIT 5;\n+EXPLAIN PIPELINE SELECT toStartOfMonth(date) as d, i FROM t_read_in_order ORDER BY d DESC, -i LIMIT 5;\n+\n+-- Here FinishSorting is used, because directions don't match.\n+SELECT toStartOfMonth(date) as d, i FROM t_read_in_order ORDER BY d, -i LIMIT 5;\n+EXPLAIN PIPELINE SELECT toStartOfMonth(date) as d, i FROM t_read_in_order ORDER BY d, -i LIMIT 5;\n+\n+SELECT date, i FROM t_read_in_order WHERE date = '2020-10-11' ORDER BY i LIMIT 5;\n+EXPLAIN PIPELINE SELECT date, i FROM t_read_in_order WHERE date = '2020-10-11' ORDER BY i LIMIT 5;\n+\n+SELECT * FROM t_read_in_order WHERE date = '2020-10-11' ORDER BY i, v LIMIT 5;\n+EXPLAIN PIPELINE SELECT * FROM t_read_in_order WHERE date = '2020-10-11' ORDER BY i, v LIMIT 5;\n+\n+INSERT INTO t_read_in_order SELECT '2020-10-12', number, number FROM numbers(100000);\n+\n+SELECT date, i FROM t_read_in_order WHERE date = '2020-10-12' ORDER BY i LIMIT 5;\n+\n+EXPLAIN PIPELINE SELECT date, i FROM t_read_in_order WHERE date = '2020-10-12' ORDER BY i DESC LIMIT 5;\n+SELECT date, i FROM t_read_in_order WHERE date = '2020-10-12' ORDER BY i DESC LIMIT 5;\n+\n+DROP TABLE IF EXISTS t_read_in_order;\n+\n+CREATE TABLE t_read_in_order(a UInt32, b UInt32)\n+ENGINE = MergeTree ORDER BY (a, b)\n+SETTINGS index_granularity = 3;\n+\n+SYSTEM STOP MERGES t_read_in_order;\n+\n+INSERT INTO t_read_in_order VALUES (0, 100), (1, 2), (1, 3), (1, 4), (2, 5);\n+INSERT INTO t_read_in_order VALUES (0, 100), (1, 2), (1, 3), (1, 4), (2, 5);\n+\n+SELECT a, b FROM t_read_in_order WHERE a = 1 ORDER BY b SETTINGS read_in_order_two_level_merge_threshold = 1;\n+SELECT '========';\n+SELECT a, b FROM t_read_in_order WHERE a = 1 ORDER BY b DESC SETTINGS read_in_order_two_level_merge_threshold = 1;\n+\n+DROP TABLE t_read_in_order;\n+\n+CREATE TABLE t_read_in_order(dt DateTime, d Decimal64(5), v UInt64)\n+ENGINE = MergeTree ORDER BY (toStartOfDay(dt), d);\n+\n+INSERT INTO t_read_in_order SELECT toDateTime('2020-10-10 00:00:00') + number, 1 / (number % 100 + 1), number FROM numbers(1000);\n+\n+EXPLAIN PIPELINE SELECT toStartOfDay(dt) as date, d FROM t_read_in_order ORDER BY date, round(d) LIMIT 5;\n+SELECT toStartOfDay(dt) as date, d FROM t_read_in_order ORDER BY date, round(d) LIMIT 5;\n+\n+EXPLAIN PIPELINE SELECT toStartOfDay(dt) as date, d FROM t_read_in_order ORDER BY date, round(d) LIMIT 5;\n+SELECT toStartOfDay(dt) as date, d FROM t_read_in_order WHERE date = '2020-10-10' ORDER BY round(d) LIMIT 5;\ndiff --git a/tests/queries/0_stateless/02149_read_in_order_fixed_prefix_negative.reference b/tests/queries/0_stateless/02149_read_in_order_fixed_prefix_negative.reference\nnew file mode 100644\nindex 000000000000..4a3cbec8ce3b\n--- /dev/null\n+++ b/tests/queries/0_stateless/02149_read_in_order_fixed_prefix_negative.reference\n@@ -0,0 +1,5 @@\n+MergeSorting\n+MergeSorting\n+MergeSorting\n+MergeSorting\n+MergeSorting\ndiff --git a/tests/queries/0_stateless/02149_read_in_order_fixed_prefix_negative.sh b/tests/queries/0_stateless/02149_read_in_order_fixed_prefix_negative.sh\nnew file mode 100755\nindex 000000000000..a2f297da5ad8\n--- /dev/null\n+++ b/tests/queries/0_stateless/02149_read_in_order_fixed_prefix_negative.sh\n@@ -0,0 +1,20 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+$CLICKHOUSE_CLIENT -q \"DROP TABLE IF EXISTS t_read_in_order_2\";\n+\n+$CLICKHOUSE_CLIENT -q \"CREATE TABLE t_read_in_order_2(date Date, i UInt64, v UInt64) ENGINE = MergeTree ORDER BY (date, i)\"\n+\n+$CLICKHOUSE_CLIENT -q \"INSERT INTO t_read_in_order_2 SELECT '2020-10-10', number % 10, number FROM numbers(100000)\"\n+$CLICKHOUSE_CLIENT -q \"INSERT INTO t_read_in_order_2 SELECT '2020-10-11', number % 10, number FROM numbers(100000)\"\n+\n+$CLICKHOUSE_CLIENT -q \"EXPLAIN PIPELINE SELECT date, i FROM t_read_in_order_2 WHERE date = '2020-10-11' OR date = '2020-10-12' ORDER BY i DESC LIMIT 10\" | grep -o \"MergeSorting\"\n+$CLICKHOUSE_CLIENT -q \"EXPLAIN PIPELINE SELECT date, i FROM t_read_in_order_2 WHERE date >= '2020-10-11' ORDER BY i DESC LIMIT 10\" | grep -o \"MergeSorting\"\n+$CLICKHOUSE_CLIENT -q \"EXPLAIN PIPELINE SELECT date, i FROM t_read_in_order_2 WHERE date = '2020-10-11' OR v = 100 ORDER BY i DESC LIMIT 10\" | grep -o \"MergeSorting\"\n+$CLICKHOUSE_CLIENT -q \"EXPLAIN PIPELINE SELECT date, i FROM t_read_in_order_2 WHERE date != '2020-10-11' ORDER BY i DESC LIMIT 10\" | grep -o \"MergeSorting\"\n+$CLICKHOUSE_CLIENT -q \"EXPLAIN PIPELINE SELECT date, i FROM t_read_in_order_2 WHERE NOT (date = '2020-10-11') ORDER BY i DESC LIMIT 10\" | grep -o \"MergeSorting\"\n+\n+$CLICKHOUSE_CLIENT -q \"DROP TABLE IF EXISTS t_read_in_order_2\";\n",
  "problem_statement": "optimize_read_in_order does not recognize that prefix is already sorted\ncreate table ORX( A Int64, B Int64, V Int64) Engine=MergeTree order by (A,B)\r\ninsert into ORX select 111, number, number from numbers(10000000)\r\n\r\nselect * from ORX where **A = 111 order by B** limit 3;\r\n3 rows in set. Elapsed: 0.232 sec. **Processed 10.00 million rows**\r\n\r\n\r\nselect * from ORX where **A = 111 order by A,B** limit 3;\r\n3 rows in set. Elapsed: 0.019 sec. **Processed 245.76 thousand rows,**\n",
  "hints_text": "no updates?",
  "created_at": "2021-12-14T12:59:09Z"
}