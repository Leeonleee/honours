{
  "repo": "duckdb/duckdb",
  "pull_number": 12736,
  "instance_id": "duckdb__duckdb-12736",
  "issue_numbers": [
    "11228"
  ],
  "base_commit": "4189e6d289008d17b6014d77bf3e28900d9f149d",
  "patch": "diff --git a/src/core_functions/scalar/string/printf.cpp b/src/core_functions/scalar/string/printf.cpp\nindex b71bedef066c..60c845096638 100644\n--- a/src/core_functions/scalar/string/printf.cpp\n+++ b/src/core_functions/scalar/string/printf.cpp\n@@ -27,15 +27,26 @@ unique_ptr<FunctionData> BindPrintfFunction(ClientContext &context, ScalarFuncti\n \tfor (idx_t i = 1; i < arguments.size(); i++) {\n \t\tswitch (arguments[i]->return_type.id()) {\n \t\tcase LogicalTypeId::BOOLEAN:\n+\t\t\tbound_function.arguments.emplace_back(LogicalType::BOOLEAN);\n+\t\t\tbreak;\n \t\tcase LogicalTypeId::TINYINT:\n \t\tcase LogicalTypeId::SMALLINT:\n \t\tcase LogicalTypeId::INTEGER:\n \t\tcase LogicalTypeId::BIGINT:\n+\t\t\tbound_function.arguments.emplace_back(LogicalType::BIGINT);\n+\t\t\tbreak;\n+\t\tcase LogicalTypeId::UTINYINT:\n+\t\tcase LogicalTypeId::USMALLINT:\n+\t\tcase LogicalTypeId::UINTEGER:\n+\t\tcase LogicalTypeId::UBIGINT:\n+\t\t\tbound_function.arguments.emplace_back(LogicalType::UBIGINT);\n+\t\t\tbreak;\n \t\tcase LogicalTypeId::FLOAT:\n \t\tcase LogicalTypeId::DOUBLE:\n+\t\t\tbound_function.arguments.emplace_back(LogicalType::DOUBLE);\n+\t\t\tbreak;\n \t\tcase LogicalTypeId::VARCHAR:\n-\t\t\t// these types are natively supported\n-\t\t\tbound_function.arguments.push_back(arguments[i]->return_type);\n+\t\t\tbound_function.arguments.push_back(LogicalType::VARCHAR);\n \t\t\tbreak;\n \t\tcase LogicalTypeId::DECIMAL:\n \t\t\t// decimal type: add cast to double\n@@ -105,28 +116,13 @@ static void PrintfFunction(DataChunk &args, ExpressionState &state, Vector &resu\n \t\t\t\tformat_args.emplace_back(duckdb_fmt::internal::make_arg<CTX>(arg_data[arg_idx]));\n \t\t\t\tbreak;\n \t\t\t}\n-\t\t\tcase LogicalTypeId::TINYINT: {\n-\t\t\t\tauto arg_data = FlatVector::GetData<int8_t>(col);\n-\t\t\t\tformat_args.emplace_back(duckdb_fmt::internal::make_arg<CTX>(arg_data[arg_idx]));\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tcase LogicalTypeId::SMALLINT: {\n-\t\t\t\tauto arg_data = FlatVector::GetData<int16_t>(col);\n-\t\t\t\tformat_args.emplace_back(duckdb_fmt::internal::make_arg<CTX>(arg_data[arg_idx]));\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tcase LogicalTypeId::INTEGER: {\n-\t\t\t\tauto arg_data = FlatVector::GetData<int32_t>(col);\n-\t\t\t\tformat_args.emplace_back(duckdb_fmt::internal::make_arg<CTX>(arg_data[arg_idx]));\n-\t\t\t\tbreak;\n-\t\t\t}\n \t\t\tcase LogicalTypeId::BIGINT: {\n \t\t\t\tauto arg_data = FlatVector::GetData<int64_t>(col);\n \t\t\t\tformat_args.emplace_back(duckdb_fmt::internal::make_arg<CTX>(arg_data[arg_idx]));\n \t\t\t\tbreak;\n \t\t\t}\n-\t\t\tcase LogicalTypeId::FLOAT: {\n-\t\t\t\tauto arg_data = FlatVector::GetData<float>(col);\n+\t\t\tcase LogicalTypeId::UBIGINT: {\n+\t\t\t\tauto arg_data = FlatVector::GetData<uint64_t>(col);\n \t\t\t\tformat_args.emplace_back(duckdb_fmt::internal::make_arg<CTX>(arg_data[arg_idx]));\n \t\t\t\tbreak;\n \t\t\t}\n",
  "test_patch": "diff --git a/test/sql/function/string/test_printf.test b/test/sql/function/string/test_printf.test\nindex 68e1934a771e..62eef89b9dc6 100644\n--- a/test/sql/function/string/test_printf.test\n+++ b/test/sql/function/string/test_printf.test\n@@ -78,6 +78,26 @@ SELECT printf('%s', 120381902481294715712::UHUGEINT)\n ----\n 120381902481294715712\n \n+query I\n+select printf('%x', 255::utinyint);\n+----\n+ff\n+\n+query I\n+select printf('%x', 65535::usmallint);\n+----\n+ffff\n+\n+query I\n+select printf('%x', 4294967295::uinteger);\n+----\n+ffffffff\n+\n+query I\n+select printf('%x', 18446744073709551615::ubigint);\n+----\n+ffffffffffffffff\n+\n # decimal\n query T\n SELECT printf('%.3f', '1.234'::DECIMAL)\n",
  "problem_statement": "format and printf unable to number-format unsigned numeric values\n### What happens?\n\nWhen given unsigned numeric types such as ubigint and uinteger, both printf and format print \"Error: Invalid Input Error: Invalid type specifier ... for formatting a value of type string\" when a numeric formatting specifier is applied.\r\n\r\nThe workaround is to convert the numeric value to a signed type which is big enough to hold the value first.\n\n### To Reproduce\n\n```\r\n$ duckdb\r\nv0.10.0 20b1486d11\r\nEnter \".help\" for usage hints.\r\nD select printf('%x', 123::ubigint);\r\nError: Invalid Input Error: Invalid type specifier \"x\" for formatting a value of type string\r\nD select format('{:x}', 123::ubigint);\r\nError: Invalid Input Error: Invalid type specifier \"x\" for formatting a value of type string\r\nD select printf('%x', 123::uinteger);\r\nError: Invalid Input Error: Invalid type specifier \"x\" for formatting a value of type string\r\nD select format('{:x}', 123::uinteger);\r\nError: Invalid Input Error: Invalid type specifier \"x\" for formatting a value of type string\r\nD select format('{:x}', 123::ubigint::int);\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 format('{:x}', CAST(CAST(123 AS UBIGINT) AS INTEGER)) \u2502\r\n\u2502                        varchar                        \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 7b                                                    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nD select printf('%d', 123::ubigint);\r\nError: Invalid Input Error: Invalid type specifier \"d\" for formatting a value of type string\r\n```\n\n### OS:\n\nOS X\n\n### DuckDB Version:\n\n0.10.0\n\n### DuckDB Client:\n\nduckdb CLI\n\n### Full Name:\n\nKeunwoo Lee\n\n### Affiliation:\n\nAirtable\n\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\n\nI have tested with a nightly build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2024-06-27T13:10:38Z",
  "modified_files": [
    "src/core_functions/scalar/string/printf.cpp"
  ],
  "modified_test_files": [
    "test/sql/function/string/test_printf.test"
  ]
}