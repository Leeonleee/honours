{
  "repo": "duckdb/duckdb",
  "pull_number": 3964,
  "instance_id": "duckdb__duckdb-3964",
  "issue_numbers": [
    "3942"
  ],
  "base_commit": "40005dbc5a66bca43e7bee6072ad1ca403e90a4c",
  "patch": "diff --git a/src/execution/operator/persistent/buffered_csv_reader.cpp b/src/execution/operator/persistent/buffered_csv_reader.cpp\nindex 70b47cc30850..6580ef5bccb9 100644\n--- a/src/execution/operator/persistent/buffered_csv_reader.cpp\n+++ b/src/execution/operator/persistent/buffered_csv_reader.cpp\n@@ -255,6 +255,22 @@ void BufferedCSVReaderOptions::SetDelimiter(const string &input) {\n \t}\n }\n \n+void BufferedCSVReaderOptions::SetDateFormat(LogicalTypeId type, const string &format, bool read_format) {\n+\tstring error;\n+\tif (read_format) {\n+\t\tauto &date_format = this->date_format[type];\n+\t\terror = StrTimeFormat::ParseFormatSpecifier(format, date_format);\n+\t\tdate_format.format_specifier = format;\n+\t} else {\n+\t\tauto &date_format = this->write_date_format[type];\n+\t\terror = StrTimeFormat::ParseFormatSpecifier(format, date_format);\n+\t}\n+\tif (!error.empty()) {\n+\t\tthrow InvalidInputException(\"Could not parse DATEFORMAT: %s\", error.c_str());\n+\t}\n+\thas_format[type] = true;\n+}\n+\n void BufferedCSVReaderOptions::SetReadOption(const string &loption, const Value &value,\n                                              vector<string> &expected_names) {\n \tif (SetBaseOption(loption, value)) {\n@@ -299,22 +315,10 @@ void BufferedCSVReaderOptions::SetReadOption(const string &loption, const Value\n \t\tforce_not_null = ParseColumnList(value, expected_names, loption);\n \t} else if (loption == \"date_format\" || loption == \"dateformat\") {\n \t\tstring format = ParseString(value, loption);\n-\t\tauto &date_format = this->date_format[LogicalTypeId::DATE];\n-\t\tstring error = StrTimeFormat::ParseFormatSpecifier(format, date_format);\n-\t\tdate_format.format_specifier = format;\n-\t\tif (!error.empty()) {\n-\t\t\tthrow InvalidInputException(\"Could not parse DATEFORMAT: %s\", error.c_str());\n-\t\t}\n-\t\thas_format[LogicalTypeId::DATE] = true;\n+\t\tSetDateFormat(LogicalTypeId::DATE, format, true);\n \t} else if (loption == \"timestamp_format\" || loption == \"timestampformat\") {\n \t\tstring format = ParseString(value, loption);\n-\t\tauto &timestamp_format = date_format[LogicalTypeId::TIMESTAMP];\n-\t\tstring error = StrTimeFormat::ParseFormatSpecifier(format, timestamp_format);\n-\t\ttimestamp_format.format_specifier = format;\n-\t\tif (!error.empty()) {\n-\t\t\tthrow InvalidInputException(\"Could not parse TIMESTAMPFORMAT: %s\", error.c_str());\n-\t\t}\n-\t\thas_format[LogicalTypeId::TIMESTAMP] = true;\n+\t\tSetDateFormat(LogicalTypeId::TIMESTAMP, format, true);\n \t} else if (loption == \"escape\") {\n \t\tescape = ParseString(value, loption);\n \t\thas_escape = true;\n@@ -332,6 +336,15 @@ void BufferedCSVReaderOptions::SetWriteOption(const string &loption, const Value\n \n \tif (loption == \"force_quote\") {\n \t\tforce_quote = ParseColumnList(value, names, loption);\n+\t} else if (loption == \"date_format\" || loption == \"dateformat\") {\n+\t\tstring format = ParseString(value, loption);\n+\t\tSetDateFormat(LogicalTypeId::DATE, format, false);\n+\t} else if (loption == \"timestamp_format\" || loption == \"timestampformat\") {\n+\t\tstring format = ParseString(value, loption);\n+\t\tif (StringUtil::Lower(format) == \"iso\") {\n+\t\t\tformat = \"%Y-%m-%dT%H:%M:%S.%fZ\";\n+\t\t}\n+\t\tSetDateFormat(LogicalTypeId::TIMESTAMP, format, false);\n \t} else {\n \t\tthrow BinderException(\"Unrecognized option CSV writer \\\"%s\\\"\", loption);\n \t}\ndiff --git a/src/function/scalar/date/strftime.cpp b/src/function/scalar/date/strftime.cpp\nindex d657dbacabb4..dde17103c042 100644\n--- a/src/function/scalar/date/strftime.cpp\n+++ b/src/function/scalar/date/strftime.cpp\n@@ -627,6 +627,25 @@ static unique_ptr<FunctionData> StrfTimeBindFunction(ClientContext &context, Sca\n \treturn make_unique<StrfTimeBindData>(format, format_string);\n }\n \n+void StrfTimeFormat::ConvertDateVector(Vector &input, Vector &result, idx_t count) {\n+\tD_ASSERT(input.GetType().id() == LogicalTypeId::DATE);\n+\tD_ASSERT(result.GetType().id() == LogicalTypeId::VARCHAR);\n+\tUnaryExecutor::ExecuteWithNulls<date_t, string_t>(input, result, count,\n+\t                                                  [&](date_t input, ValidityMask &mask, idx_t idx) {\n+\t\t                                                  if (Date::IsFinite(input)) {\n+\t\t\t                                                  dtime_t time(0);\n+\t\t\t                                                  idx_t len = GetLength(input, time, 0, nullptr);\n+\t\t\t                                                  string_t target = StringVector::EmptyString(result, len);\n+\t\t\t                                                  FormatString(input, time, target.GetDataWriteable());\n+\t\t\t                                                  target.Finalize();\n+\t\t\t                                                  return target;\n+\t\t                                                  } else {\n+\t\t\t                                                  mask.SetInvalid(idx);\n+\t\t\t                                                  return string_t();\n+\t\t                                                  }\n+\t                                                  });\n+}\n+\n template <bool REVERSED>\n static void StrfTimeFunctionDate(DataChunk &args, ExpressionState &state, Vector &result) {\n \tauto &func_expr = (BoundFunctionExpression &)state.expr;\n@@ -637,13 +656,21 @@ static void StrfTimeFunctionDate(DataChunk &args, ExpressionState &state, Vector\n \t\tConstantVector::SetNull(result, true);\n \t\treturn;\n \t}\n-\tUnaryExecutor::ExecuteWithNulls<date_t, string_t>(\n-\t    args.data[REVERSED ? 1 : 0], result, args.size(), [&](date_t input, ValidityMask &mask, idx_t idx) {\n-\t\t    if (Date::IsFinite(input)) {\n-\t\t\t    dtime_t time(0);\n-\t\t\t    idx_t len = info.format.GetLength(input, time, 0, nullptr);\n+\tinfo.format.ConvertDateVector(args.data[REVERSED ? 1 : 0], result, args.size());\n+}\n+\n+void StrfTimeFormat::ConvertTimestampVector(Vector &input, Vector &result, idx_t count) {\n+\tD_ASSERT(input.GetType().id() == LogicalTypeId::TIMESTAMP);\n+\tD_ASSERT(result.GetType().id() == LogicalTypeId::VARCHAR);\n+\tUnaryExecutor::ExecuteWithNulls<timestamp_t, string_t>(\n+\t    input, result, count, [&](timestamp_t input, ValidityMask &mask, idx_t idx) {\n+\t\t    if (Timestamp::IsFinite(input)) {\n+\t\t\t    date_t date;\n+\t\t\t    dtime_t time;\n+\t\t\t    Timestamp::Convert(input, date, time);\n+\t\t\t    idx_t len = GetLength(date, time, 0, nullptr);\n \t\t\t    string_t target = StringVector::EmptyString(result, len);\n-\t\t\t    info.format.FormatString(input, time, target.GetDataWriteable());\n+\t\t\t    FormatString(date, time, target.GetDataWriteable());\n \t\t\t    target.Finalize();\n \t\t\t    return target;\n \t\t    } else {\n@@ -663,23 +690,7 @@ static void StrfTimeFunctionTimestamp(DataChunk &args, ExpressionState &state, V\n \t\tConstantVector::SetNull(result, true);\n \t\treturn;\n \t}\n-\n-\tUnaryExecutor::ExecuteWithNulls<timestamp_t, string_t>(\n-\t    args.data[REVERSED ? 1 : 0], result, args.size(), [&](timestamp_t input, ValidityMask &mask, idx_t idx) {\n-\t\t    if (Timestamp::IsFinite(input)) {\n-\t\t\t    date_t date;\n-\t\t\t    dtime_t time;\n-\t\t\t    Timestamp::Convert(input, date, time);\n-\t\t\t    idx_t len = info.format.GetLength(date, time, 0, nullptr);\n-\t\t\t    string_t target = StringVector::EmptyString(result, len);\n-\t\t\t    info.format.FormatString(date, time, target.GetDataWriteable());\n-\t\t\t    target.Finalize();\n-\t\t\t    return target;\n-\t\t    } else {\n-\t\t\t    mask.SetInvalid(idx);\n-\t\t\t    return string_t();\n-\t\t    }\n-\t    });\n+\tinfo.format.ConvertTimestampVector(args.data[REVERSED ? 1 : 0], result, args.size());\n }\n \n void StrfTimeFun::RegisterFunction(BuiltinFunctions &set) {\ndiff --git a/src/function/table/copy_csv.cpp b/src/function/table/copy_csv.cpp\nindex 7b6f0dd12382..7c4b12541789 100644\n--- a/src/function/table/copy_csv.cpp\n+++ b/src/function/table/copy_csv.cpp\n@@ -314,6 +314,15 @@ static void WriteCSVSink(ClientContext &context, FunctionData &bind_data, Global\n \t\tif (csv_data.sql_types[col_idx].id() == LogicalTypeId::VARCHAR) {\n \t\t\t// VARCHAR, just create a reference\n \t\t\tcast_chunk.data[col_idx].Reference(input.data[col_idx]);\n+\t\t} else if (options.has_format[LogicalTypeId::DATE] && csv_data.sql_types[col_idx].id() == LogicalTypeId::DATE) {\n+\t\t\t// use the date format to cast the chunk\n+\t\t\tcsv_data.options.write_date_format[LogicalTypeId::DATE].ConvertDateVector(\n+\t\t\t    input.data[col_idx], cast_chunk.data[col_idx], input.size());\n+\t\t} else if (options.has_format[LogicalTypeId::TIMESTAMP] &&\n+\t\t           csv_data.sql_types[col_idx].id() == LogicalTypeId::TIMESTAMP) {\n+\t\t\t// use the timestamp format to cast the chunk\n+\t\t\tcsv_data.options.write_date_format[LogicalTypeId::TIMESTAMP].ConvertTimestampVector(\n+\t\t\t    input.data[col_idx], cast_chunk.data[col_idx], input.size());\n \t\t} else {\n \t\t\t// non varchar column, perform the cast\n \t\t\tVectorOperations::Cast(input.data[col_idx], cast_chunk.data[col_idx], input.size());\ndiff --git a/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp b/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp\nindex 937c178bb321..b518a1a7a8cf 100644\n--- a/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp\n+++ b/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp\n@@ -123,6 +123,9 @@ struct BufferedCSVReaderOptions {\n \n \t//! The date format to use (if any is specified)\n \tstd::map<LogicalTypeId, StrpTimeFormat> date_format = {{LogicalTypeId::DATE, {}}, {LogicalTypeId::TIMESTAMP, {}}};\n+\t//! The date format to use for writing (if any is specified)\n+\tstd::map<LogicalTypeId, StrfTimeFormat> write_date_format = {{LogicalTypeId::DATE, {}},\n+\t                                                             {LogicalTypeId::TIMESTAMP, {}}};\n \t//! Whether or not a type format is specified\n \tstd::map<LogicalTypeId, bool> has_format = {{LogicalTypeId::DATE, false}, {LogicalTypeId::TIMESTAMP, false}};\n \n@@ -137,6 +140,7 @@ struct BufferedCSVReaderOptions {\n \tvoid SetReadOption(const string &loption, const Value &value, vector<string> &expected_names);\n \n \tvoid SetWriteOption(const string &loption, const Value &value);\n+\tvoid SetDateFormat(LogicalTypeId type, const string &format, bool read_format);\n \n \tstd::string ToString() const;\n };\ndiff --git a/src/include/duckdb/function/scalar/strftime.hpp b/src/include/duckdb/function/scalar/strftime.hpp\nindex efe302732d6a..0d9c9de9c107 100644\n--- a/src/include/duckdb/function/scalar/strftime.hpp\n+++ b/src/include/duckdb/function/scalar/strftime.hpp\n@@ -91,6 +91,9 @@ struct StrfTimeFormat : public StrTimeFormat {\n \n \tDUCKDB_API static string Format(timestamp_t timestamp, const string &format);\n \n+\tDUCKDB_API void ConvertDateVector(Vector &input, Vector &result, idx_t count);\n+\tDUCKDB_API void ConvertTimestampVector(Vector &input, Vector &result, idx_t count);\n+\n protected:\n \t//! The variable-length specifiers. To determine total string size, these need to be checked.\n \tvector<StrTimeSpecifier> var_length_specifiers;\n",
  "test_patch": "diff --git a/test/sql/copy/csv/test_dateformat.test b/test/sql/copy/csv/test_dateformat.test\nindex d88c8d64f9bf..2a87c4ceba40 100644\n--- a/test/sql/copy/csv/test_dateformat.test\n+++ b/test/sql/copy/csv/test_dateformat.test\n@@ -27,6 +27,22 @@ SELECT * FROM dates ORDER BY d\n 2019-05-06\n 2019-06-05\n \n+# test dateformat on COPY TO\n+statement ok\n+CREATE TABLE new_dates (d DATE);\n+\n+statement ok\n+COPY dates TO '__TEST_DIR__/dateformat.csv' (HEADER 0, DATEFORMAT '%d/%m/%Y')\n+\n+statement ok\n+COPY new_dates FROM '__TEST_DIR__/dateformat.csv' (HEADER 0, DATEFORMAT '%d/%m/%Y')\n+\n+query I\n+SELECT * FROM new_dates ORDER BY 1\n+----\n+2019-05-06\n+2019-06-05\n+\n # timestamp format\n statement ok\n CREATE TABLE timestamps(t TIMESTAMP);\n@@ -40,6 +56,36 @@ SELECT * FROM timestamps\n ----\n 2003-06-30 12:03:10\n \n+# test timestamp format on COPY TO\n+statement ok\n+CREATE TABLE new_timestamps (t TIMESTAMP);\n+\n+statement ok\n+COPY timestamps TO '__TEST_DIR__/timestampformat.csv' (HEADER 0, TIMESTAMPFORMAT '%a %d, %B %Y, %I:%M:%S %p')\n+\n+statement ok\n+COPY new_timestamps FROM '__TEST_DIR__/timestampformat.csv' (HEADER 0, TIMESTAMPFORMAT '%a %d, %B %Y, %I:%M:%S %p')\n+\n+query I\n+SELECT * FROM new_timestamps ORDER BY 1\n+----\n+2003-06-30 12:03:10\n+\n+statement ok\n+DELETE FROM new_timestamps\n+\n+# test iso format in copy\n+statement ok\n+COPY timestamps TO '__TEST_DIR__/timestampformat.csv' (HEADER 0, TIMESTAMPFORMAT ISO)\n+\n+statement ok\n+COPY new_timestamps FROM '__TEST_DIR__/timestampformat.csv' (HEADER 0)\n+\n+query I\n+SELECT * FROM new_timestamps ORDER BY 1\n+----\n+2003-06-30 12:03:10\n+\n # incorrect date/timestamp format results in an error\n statement error\n COPY dates FROM 'test/sql/copy/csv/data/test/dateformat.csv' (HEADER 0, DATEFORMAT '%')\n",
  "problem_statement": "Write CSV with timestamp columns in ISO 8601 strings\nRight now, if I write a CSV with either `COPY` or `EXPORT DATABASE` statements, the only format I can get for timestamp columns is not ISO-8601 compliant, e.g. `2021-02-01 13:00:00`.  I'd like to be able to tell DuckDB to write the ISO-8601 format `2021-02-01T13:00:00Z`, instead.\r\n\r\nDocumentation for both `COPY` AND `EXPORT DATABASE` suggest I might be able to set a `TIMESTAMPFORMAT` option. But when I try this, I'm told that it is not yet implemented: `Not implemented Error: Unrecognized option for CSV: TIMESTAMPFORMAT`.\r\n\r\nI [chatted with `__Alex__` about this in Discord](https://discord.com/channels/909674491309850675/921073327009853451/989378834828767313), and he suggested I file this issue. Thanks!\n",
  "hints_text": "We should probably use the T there by default\n`TIMESTAMPFORMAT` is only supported for reading CSVs, we should implement this for writing as well.\r\n\r\n> We should probably use the T there by default\r\n\r\nPostgres does not, and I would follow them here, but we could certainly make a short-cut (e.g. `TIMESTAMPFORMAT 'iso'`).\nI think that both the middle `T` and the final `Z` are important for a fully valid ISO string.",
  "created_at": "2022-06-25T12:37:15Z",
  "modified_files": [
    "src/execution/operator/persistent/buffered_csv_reader.cpp",
    "src/function/scalar/date/strftime.cpp",
    "src/function/table/copy_csv.cpp",
    "src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp",
    "src/include/duckdb/function/scalar/strftime.hpp"
  ],
  "modified_test_files": [
    "test/sql/copy/csv/test_dateformat.test"
  ]
}