{
  "repo": "duckdb/duckdb",
  "pull_number": 9872,
  "instance_id": "duckdb__duckdb-9872",
  "issue_numbers": [
    "9870"
  ],
  "base_commit": "bc1bfd6f1b7abf9cee40ec30b32f744e968e3bc0",
  "patch": "diff --git a/src/optimizer/rule/regex_optimizations.cpp b/src/optimizer/rule/regex_optimizations.cpp\nindex d1f49121bb4f..00f332ea8d13 100644\n--- a/src/optimizer/rule/regex_optimizations.cpp\n+++ b/src/optimizer/rule/regex_optimizations.cpp\n@@ -143,13 +143,13 @@ unique_ptr<Expression> RegexOptimizationRule::Apply(LogicalOperator &op, vector<\n \n \tauto constant_value = ExpressionExecutor::EvaluateScalar(GetContext(), constant_expr);\n \tD_ASSERT(constant_value.type() == constant_expr.return_type);\n-\tauto patt_str = StringValue::Get(constant_value);\n \n \tduckdb_re2::RE2::Options parsed_options = regexp_bind_data.options;\n \n \tif (constant_expr.value.IsNull()) {\n \t\treturn make_uniq<BoundConstantExpression>(Value(root.return_type));\n \t}\n+\tauto patt_str = StringValue::Get(constant_value);\n \n \t// the constant_expr is a scalar expression that we have to fold\n \tif (!constant_expr.IsFoldable()) {\n",
  "test_patch": "diff --git a/test/sql/function/string/regex_search.test b/test/sql/function/string/regex_search.test\nindex 4637432f7f51..c107c1402301 100644\n--- a/test/sql/function/string/regex_search.test\n+++ b/test/sql/function/string/regex_search.test\n@@ -5,40 +5,49 @@\n statement ok\n PRAGMA enable_verification\n \n+statement ok\n+CREATE TABLE t0 as FROM VALUES('asdf') t(c0);\n+\n+# null\n+query I\n+SELECT regexp_matches(c0, NULL) from t0\n+----\n+NULL\n+\n # constant strings\n query T\n-SELECT regexp_matches('asdf', '.*sd.*')\n+SELECT regexp_matches(c0, '.*sd.*') from t0;\n ----\n 1\n \n query T\n-SELECT regexp_matches('asdf', '.*yu.*')\n+SELECT regexp_matches(c0, '.*yu.*') from t0;\n ----\n 0\n \n query T\n-SELECT regexp_matches('asdf', '')\n+SELECT regexp_matches(c0, '') from t0;\n ----\n 1\n \n # partial matches okay\n query T\n-SELECT regexp_matches('asdf', 'sd')\n+SELECT regexp_matches(c0, 'sd') from t0;\n ----\n 1\n \n query T\n-SELECT regexp_full_match('asdf', 'sd')\n+SELECT regexp_full_match(c0, 'sd') from t0;\n ----\n 0\n \n query T\n-SELECT regexp_full_match('asdf', '.sd.')\n+SELECT regexp_full_match(c0, '.sd.') from t0;\n ----\n 1\n \n query T\n-SELECT regexp_matches('asdf', '^sdf$')\n+SELECT regexp_matches(c0, '^sdf$') from t0;\n ----\n 0\n \n@@ -55,7 +64,7 @@ SELECT regexp_matches('', '.*')\n \n # NULLs\n query T\n-SELECT regexp_matches('asdf', CAST(NULL AS STRING))\n+SELECT regexp_matches(c0, CAST(NULL AS STRING)) from t0;\n ----\n NULL\n \n@@ -103,12 +112,12 @@ NULL\n # test regex_matches with options\n # case sensitivity\n query T\n-SELECT regexp_matches('asdf', '.*SD.*', 'i')\n+SELECT regexp_matches(c0, '.*SD.*', 'i') from t0;\n ----\n 1\n \n query T\n-SELECT regexp_matches('asdf', '.*SD.*', 'c')\n+SELECT regexp_matches(c0, '.*SD.*', 'c') from t0;\n ----\n 0\n \n@@ -138,13 +147,13 @@ world', '.*', 'n')\n \n # whitespace is ignored\n query T\n-SELECT regexp_matches('asdf', '.*SD.*', ' i \t')\n+SELECT regexp_matches(c0, '.*SD.*', ' i \t') from t0;\n ----\n 1\n \n # NULL in options is an error\n statement error\n-SELECT regexp_matches('asdf', '.*SD.*', NULL)\n+SELECT regexp_matches(c0, '.*SD.*', NULL) from t0;\n ----\n must not be NULL\n \n@@ -172,11 +181,11 @@ SELECT regexp_matches(v, 'h.*', v) FROM test ORDER BY v\n \n # throw on invalid options\n statement error\n-SELECT regexp_matches('asdf', '.*SD.*', 'q')\n+SELECT regexp_matches(c0, '.*SD.*', 'q') from t0;\n \n # can only use \"g\" with regexp replace\n statement error\n-SELECT regexp_matches('asdf', '.*SD.*', 'g')\n+SELECT regexp_matches(c0, '.*SD.*', 'g') from t0;\n \n # error in non-constant regex\n statement ok\n",
  "problem_statement": "Internal Error: Calling StringValue::Get on a NULL value\n### What happens?\n\nAn unexpected internal error happened: `Error: INTERNAL Error: Calling StringValue::Get on a NULL value`\n\n### To Reproduce\n\n```sql\r\nCREATE TABLE t0(c0 VARCHAR);\r\nSELECT REGEXP_MATCHES(c0, NULL) FROM t0;\r\n-- Error: INTERNAL Error: Calling StringValue::Get on a NULL value\r\n```\n\n### OS:\n\nubuntu 22.04\n\n### DuckDB Version:\n\nv0.9.3-dev1060 bc1bfd6f1b\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nSuyang Zhong\n\n### Affiliation:\n\nNUS\n\n### Have you tried this on the latest `main` branch?\n\nI have tested with a main build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2023-12-02T11:19:52Z",
  "modified_files": [
    "src/optimizer/rule/regex_optimizations.cpp"
  ],
  "modified_test_files": [
    "test/sql/function/string/regex_search.test"
  ]
}