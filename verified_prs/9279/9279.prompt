You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Cannot cast `TIMESTAMP_NS` to `date` using `::` syntax
### What happens?

A cast of the form `<TIMESTAMP_NS>::date` will result in an error, whereas `<TIMESTAMP>::date` works, as does `date_trunc('day', <TIMESTAMP_NS>)`.

### To Reproduce

Works:
```sql
with tbl as (
    select
        '2023-01-01 00:00:00'::TIMESTAMP
        as c1
)
select c1::date
from tbl
```

Also works:
```sql
with tbl as (
    select
        '2023-01-01 00:00:00'::TIMESTAMP_NS
        as c1
)
select date_trunc('day', c1)
from tbl
```

But this doesn't work:
```sql
with tbl as (
    select
        '2023-01-01 00:00:00'::TIMESTAMP_NS
        as c1
)
select c1::date
from tbl
```
```
Conversion Error: Unimplemented type for cast (TIMESTAMP_NS -> DATE)
```

### OS:

Linux

### DuckDB Version:

0.8.1.dev96

### DuckDB Client:

Any

### Full Name:

David Cortes

### Affiliation:

None

### Have you tried this on the latest `master` branch?

- [X] I agree

### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?

- [X] I agree

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/logo-dl/DuckDB_Logo-stacked.svg" height="120">
3: </div>
4: <br>
5: 
6: 
7: 
8: 
9: <p align="center">
10:   <a href="https://github.com/duckdb/duckdb/actions">
11:     <img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge">
12:   </a>
13:   <a href="https://discord.gg/tcvwpjfnZx">
14:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
15:   </a>
16:   <a href="https://github.com/duckdb/duckdb/releases/">
17:     <img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release">
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The detail of benchmarks is in our [Benchmark Guide](benchmark/README.md).
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
[end of README.md]
[start of src/common/operator/cast_operators.cpp]
1: #include "duckdb/common/operator/cast_operators.hpp"
2: #include "duckdb/common/hugeint.hpp"
3: #include "duckdb/common/operator/string_cast.hpp"
4: #include "duckdb/common/operator/numeric_cast.hpp"
5: #include "duckdb/common/operator/decimal_cast_operators.hpp"
6: #include "duckdb/common/operator/multiply.hpp"
7: 
8: #include "duckdb/common/exception.hpp"
9: #include "duckdb/common/limits.hpp"
10: #include "duckdb/common/string_util.hpp"
11: #include "duckdb/common/types/blob.hpp"
12: #include "duckdb/common/types/cast_helpers.hpp"
13: #include "duckdb/common/types/date.hpp"
14: #include "duckdb/common/types/decimal.hpp"
15: #include "duckdb/common/types/hugeint.hpp"
16: #include "duckdb/common/types/uuid.hpp"
17: #include "duckdb/common/types/interval.hpp"
18: #include "duckdb/common/types/time.hpp"
19: #include "duckdb/common/types/timestamp.hpp"
20: #include "duckdb/common/types/vector.hpp"
21: #include "duckdb/common/types.hpp"
22: #include "fast_float/fast_float.h"
23: #include "fmt/format.h"
24: #include "duckdb/common/types/bit.hpp"
25: 
26: #include <cctype>
27: #include <cmath>
28: #include <cstdlib>
29: 
30: namespace duckdb {
31: 
32: //===--------------------------------------------------------------------===//
33: // Cast bool -> Numeric
34: //===--------------------------------------------------------------------===//
35: template <>
36: bool TryCast::Operation(bool input, bool &result, bool strict) {
37: 	return NumericTryCast::Operation<bool, bool>(input, result, strict);
38: }
39: 
40: template <>
41: bool TryCast::Operation(bool input, int8_t &result, bool strict) {
42: 	return NumericTryCast::Operation<bool, int8_t>(input, result, strict);
43: }
44: 
45: template <>
46: bool TryCast::Operation(bool input, int16_t &result, bool strict) {
47: 	return NumericTryCast::Operation<bool, int16_t>(input, result, strict);
48: }
49: 
50: template <>
51: bool TryCast::Operation(bool input, int32_t &result, bool strict) {
52: 	return NumericTryCast::Operation<bool, int32_t>(input, result, strict);
53: }
54: 
55: template <>
56: bool TryCast::Operation(bool input, int64_t &result, bool strict) {
57: 	return NumericTryCast::Operation<bool, int64_t>(input, result, strict);
58: }
59: 
60: template <>
61: bool TryCast::Operation(bool input, hugeint_t &result, bool strict) {
62: 	return NumericTryCast::Operation<bool, hugeint_t>(input, result, strict);
63: }
64: 
65: template <>
66: bool TryCast::Operation(bool input, uint8_t &result, bool strict) {
67: 	return NumericTryCast::Operation<bool, uint8_t>(input, result, strict);
68: }
69: 
70: template <>
71: bool TryCast::Operation(bool input, uint16_t &result, bool strict) {
72: 	return NumericTryCast::Operation<bool, uint16_t>(input, result, strict);
73: }
74: 
75: template <>
76: bool TryCast::Operation(bool input, uint32_t &result, bool strict) {
77: 	return NumericTryCast::Operation<bool, uint32_t>(input, result, strict);
78: }
79: 
80: template <>
81: bool TryCast::Operation(bool input, uint64_t &result, bool strict) {
82: 	return NumericTryCast::Operation<bool, uint64_t>(input, result, strict);
83: }
84: 
85: template <>
86: bool TryCast::Operation(bool input, float &result, bool strict) {
87: 	return NumericTryCast::Operation<bool, float>(input, result, strict);
88: }
89: 
90: template <>
91: bool TryCast::Operation(bool input, double &result, bool strict) {
92: 	return NumericTryCast::Operation<bool, double>(input, result, strict);
93: }
94: 
95: //===--------------------------------------------------------------------===//
96: // Cast int8_t -> Numeric
97: //===--------------------------------------------------------------------===//
98: template <>
99: bool TryCast::Operation(int8_t input, bool &result, bool strict) {
100: 	return NumericTryCast::Operation<int8_t, bool>(input, result, strict);
101: }
102: 
103: template <>
104: bool TryCast::Operation(int8_t input, int8_t &result, bool strict) {
105: 	return NumericTryCast::Operation<int8_t, int8_t>(input, result, strict);
106: }
107: 
108: template <>
109: bool TryCast::Operation(int8_t input, int16_t &result, bool strict) {
110: 	return NumericTryCast::Operation<int8_t, int16_t>(input, result, strict);
111: }
112: 
113: template <>
114: bool TryCast::Operation(int8_t input, int32_t &result, bool strict) {
115: 	return NumericTryCast::Operation<int8_t, int32_t>(input, result, strict);
116: }
117: 
118: template <>
119: bool TryCast::Operation(int8_t input, int64_t &result, bool strict) {
120: 	return NumericTryCast::Operation<int8_t, int64_t>(input, result, strict);
121: }
122: 
123: template <>
124: bool TryCast::Operation(int8_t input, hugeint_t &result, bool strict) {
125: 	return NumericTryCast::Operation<int8_t, hugeint_t>(input, result, strict);
126: }
127: 
128: template <>
129: bool TryCast::Operation(int8_t input, uint8_t &result, bool strict) {
130: 	return NumericTryCast::Operation<int8_t, uint8_t>(input, result, strict);
131: }
132: 
133: template <>
134: bool TryCast::Operation(int8_t input, uint16_t &result, bool strict) {
135: 	return NumericTryCast::Operation<int8_t, uint16_t>(input, result, strict);
136: }
137: 
138: template <>
139: bool TryCast::Operation(int8_t input, uint32_t &result, bool strict) {
140: 	return NumericTryCast::Operation<int8_t, uint32_t>(input, result, strict);
141: }
142: 
143: template <>
144: bool TryCast::Operation(int8_t input, uint64_t &result, bool strict) {
145: 	return NumericTryCast::Operation<int8_t, uint64_t>(input, result, strict);
146: }
147: 
148: template <>
149: bool TryCast::Operation(int8_t input, float &result, bool strict) {
150: 	return NumericTryCast::Operation<int8_t, float>(input, result, strict);
151: }
152: 
153: template <>
154: bool TryCast::Operation(int8_t input, double &result, bool strict) {
155: 	return NumericTryCast::Operation<int8_t, double>(input, result, strict);
156: }
157: 
158: //===--------------------------------------------------------------------===//
159: // Cast int16_t -> Numeric
160: //===--------------------------------------------------------------------===//
161: template <>
162: bool TryCast::Operation(int16_t input, bool &result, bool strict) {
163: 	return NumericTryCast::Operation<int16_t, bool>(input, result, strict);
164: }
165: 
166: template <>
167: bool TryCast::Operation(int16_t input, int8_t &result, bool strict) {
168: 	return NumericTryCast::Operation<int16_t, int8_t>(input, result, strict);
169: }
170: 
171: template <>
172: bool TryCast::Operation(int16_t input, int16_t &result, bool strict) {
173: 	return NumericTryCast::Operation<int16_t, int16_t>(input, result, strict);
174: }
175: 
176: template <>
177: bool TryCast::Operation(int16_t input, int32_t &result, bool strict) {
178: 	return NumericTryCast::Operation<int16_t, int32_t>(input, result, strict);
179: }
180: 
181: template <>
182: bool TryCast::Operation(int16_t input, int64_t &result, bool strict) {
183: 	return NumericTryCast::Operation<int16_t, int64_t>(input, result, strict);
184: }
185: 
186: template <>
187: bool TryCast::Operation(int16_t input, hugeint_t &result, bool strict) {
188: 	return NumericTryCast::Operation<int16_t, hugeint_t>(input, result, strict);
189: }
190: 
191: template <>
192: bool TryCast::Operation(int16_t input, uint8_t &result, bool strict) {
193: 	return NumericTryCast::Operation<int16_t, uint8_t>(input, result, strict);
194: }
195: 
196: template <>
197: bool TryCast::Operation(int16_t input, uint16_t &result, bool strict) {
198: 	return NumericTryCast::Operation<int16_t, uint16_t>(input, result, strict);
199: }
200: 
201: template <>
202: bool TryCast::Operation(int16_t input, uint32_t &result, bool strict) {
203: 	return NumericTryCast::Operation<int16_t, uint32_t>(input, result, strict);
204: }
205: 
206: template <>
207: bool TryCast::Operation(int16_t input, uint64_t &result, bool strict) {
208: 	return NumericTryCast::Operation<int16_t, uint64_t>(input, result, strict);
209: }
210: 
211: template <>
212: bool TryCast::Operation(int16_t input, float &result, bool strict) {
213: 	return NumericTryCast::Operation<int16_t, float>(input, result, strict);
214: }
215: 
216: template <>
217: bool TryCast::Operation(int16_t input, double &result, bool strict) {
218: 	return NumericTryCast::Operation<int16_t, double>(input, result, strict);
219: }
220: 
221: //===--------------------------------------------------------------------===//
222: // Cast int32_t -> Numeric
223: //===--------------------------------------------------------------------===//
224: template <>
225: bool TryCast::Operation(int32_t input, bool &result, bool strict) {
226: 	return NumericTryCast::Operation<int32_t, bool>(input, result, strict);
227: }
228: 
229: template <>
230: bool TryCast::Operation(int32_t input, int8_t &result, bool strict) {
231: 	return NumericTryCast::Operation<int32_t, int8_t>(input, result, strict);
232: }
233: 
234: template <>
235: bool TryCast::Operation(int32_t input, int16_t &result, bool strict) {
236: 	return NumericTryCast::Operation<int32_t, int16_t>(input, result, strict);
237: }
238: 
239: template <>
240: bool TryCast::Operation(int32_t input, int32_t &result, bool strict) {
241: 	return NumericTryCast::Operation<int32_t, int32_t>(input, result, strict);
242: }
243: 
244: template <>
245: bool TryCast::Operation(int32_t input, int64_t &result, bool strict) {
246: 	return NumericTryCast::Operation<int32_t, int64_t>(input, result, strict);
247: }
248: 
249: template <>
250: bool TryCast::Operation(int32_t input, hugeint_t &result, bool strict) {
251: 	return NumericTryCast::Operation<int32_t, hugeint_t>(input, result, strict);
252: }
253: 
254: template <>
255: bool TryCast::Operation(int32_t input, uint8_t &result, bool strict) {
256: 	return NumericTryCast::Operation<int32_t, uint8_t>(input, result, strict);
257: }
258: 
259: template <>
260: bool TryCast::Operation(int32_t input, uint16_t &result, bool strict) {
261: 	return NumericTryCast::Operation<int32_t, uint16_t>(input, result, strict);
262: }
263: 
264: template <>
265: bool TryCast::Operation(int32_t input, uint32_t &result, bool strict) {
266: 	return NumericTryCast::Operation<int32_t, uint32_t>(input, result, strict);
267: }
268: 
269: template <>
270: bool TryCast::Operation(int32_t input, uint64_t &result, bool strict) {
271: 	return NumericTryCast::Operation<int32_t, uint64_t>(input, result, strict);
272: }
273: 
274: template <>
275: bool TryCast::Operation(int32_t input, float &result, bool strict) {
276: 	return NumericTryCast::Operation<int32_t, float>(input, result, strict);
277: }
278: 
279: template <>
280: bool TryCast::Operation(int32_t input, double &result, bool strict) {
281: 	return NumericTryCast::Operation<int32_t, double>(input, result, strict);
282: }
283: 
284: //===--------------------------------------------------------------------===//
285: // Cast int64_t -> Numeric
286: //===--------------------------------------------------------------------===//
287: template <>
288: bool TryCast::Operation(int64_t input, bool &result, bool strict) {
289: 	return NumericTryCast::Operation<int64_t, bool>(input, result, strict);
290: }
291: 
292: template <>
293: bool TryCast::Operation(int64_t input, int8_t &result, bool strict) {
294: 	return NumericTryCast::Operation<int64_t, int8_t>(input, result, strict);
295: }
296: 
297: template <>
298: bool TryCast::Operation(int64_t input, int16_t &result, bool strict) {
299: 	return NumericTryCast::Operation<int64_t, int16_t>(input, result, strict);
300: }
301: 
302: template <>
303: bool TryCast::Operation(int64_t input, int32_t &result, bool strict) {
304: 	return NumericTryCast::Operation<int64_t, int32_t>(input, result, strict);
305: }
306: 
307: template <>
308: bool TryCast::Operation(int64_t input, int64_t &result, bool strict) {
309: 	return NumericTryCast::Operation<int64_t, int64_t>(input, result, strict);
310: }
311: 
312: template <>
313: bool TryCast::Operation(int64_t input, hugeint_t &result, bool strict) {
314: 	return NumericTryCast::Operation<int64_t, hugeint_t>(input, result, strict);
315: }
316: 
317: template <>
318: bool TryCast::Operation(int64_t input, uint8_t &result, bool strict) {
319: 	return NumericTryCast::Operation<int64_t, uint8_t>(input, result, strict);
320: }
321: 
322: template <>
323: bool TryCast::Operation(int64_t input, uint16_t &result, bool strict) {
324: 	return NumericTryCast::Operation<int64_t, uint16_t>(input, result, strict);
325: }
326: 
327: template <>
328: bool TryCast::Operation(int64_t input, uint32_t &result, bool strict) {
329: 	return NumericTryCast::Operation<int64_t, uint32_t>(input, result, strict);
330: }
331: 
332: template <>
333: bool TryCast::Operation(int64_t input, uint64_t &result, bool strict) {
334: 	return NumericTryCast::Operation<int64_t, uint64_t>(input, result, strict);
335: }
336: 
337: template <>
338: bool TryCast::Operation(int64_t input, float &result, bool strict) {
339: 	return NumericTryCast::Operation<int64_t, float>(input, result, strict);
340: }
341: 
342: template <>
343: bool TryCast::Operation(int64_t input, double &result, bool strict) {
344: 	return NumericTryCast::Operation<int64_t, double>(input, result, strict);
345: }
346: 
347: //===--------------------------------------------------------------------===//
348: // Cast hugeint_t -> Numeric
349: //===--------------------------------------------------------------------===//
350: template <>
351: bool TryCast::Operation(hugeint_t input, bool &result, bool strict) {
352: 	return NumericTryCast::Operation<hugeint_t, bool>(input, result, strict);
353: }
354: 
355: template <>
356: bool TryCast::Operation(hugeint_t input, int8_t &result, bool strict) {
357: 	return NumericTryCast::Operation<hugeint_t, int8_t>(input, result, strict);
358: }
359: 
360: template <>
361: bool TryCast::Operation(hugeint_t input, int16_t &result, bool strict) {
362: 	return NumericTryCast::Operation<hugeint_t, int16_t>(input, result, strict);
363: }
364: 
365: template <>
366: bool TryCast::Operation(hugeint_t input, int32_t &result, bool strict) {
367: 	return NumericTryCast::Operation<hugeint_t, int32_t>(input, result, strict);
368: }
369: 
370: template <>
371: bool TryCast::Operation(hugeint_t input, int64_t &result, bool strict) {
372: 	return NumericTryCast::Operation<hugeint_t, int64_t>(input, result, strict);
373: }
374: 
375: template <>
376: bool TryCast::Operation(hugeint_t input, hugeint_t &result, bool strict) {
377: 	return NumericTryCast::Operation<hugeint_t, hugeint_t>(input, result, strict);
378: }
379: 
380: template <>
381: bool TryCast::Operation(hugeint_t input, uint8_t &result, bool strict) {
382: 	return NumericTryCast::Operation<hugeint_t, uint8_t>(input, result, strict);
383: }
384: 
385: template <>
386: bool TryCast::Operation(hugeint_t input, uint16_t &result, bool strict) {
387: 	return NumericTryCast::Operation<hugeint_t, uint16_t>(input, result, strict);
388: }
389: 
390: template <>
391: bool TryCast::Operation(hugeint_t input, uint32_t &result, bool strict) {
392: 	return NumericTryCast::Operation<hugeint_t, uint32_t>(input, result, strict);
393: }
394: 
395: template <>
396: bool TryCast::Operation(hugeint_t input, uint64_t &result, bool strict) {
397: 	return NumericTryCast::Operation<hugeint_t, uint64_t>(input, result, strict);
398: }
399: 
400: template <>
401: bool TryCast::Operation(hugeint_t input, float &result, bool strict) {
402: 	return NumericTryCast::Operation<hugeint_t, float>(input, result, strict);
403: }
404: 
405: template <>
406: bool TryCast::Operation(hugeint_t input, double &result, bool strict) {
407: 	return NumericTryCast::Operation<hugeint_t, double>(input, result, strict);
408: }
409: 
410: //===--------------------------------------------------------------------===//
411: // Cast uint8_t -> Numeric
412: //===--------------------------------------------------------------------===//
413: template <>
414: bool TryCast::Operation(uint8_t input, bool &result, bool strict) {
415: 	return NumericTryCast::Operation<uint8_t, bool>(input, result, strict);
416: }
417: 
418: template <>
419: bool TryCast::Operation(uint8_t input, int8_t &result, bool strict) {
420: 	return NumericTryCast::Operation<uint8_t, int8_t>(input, result, strict);
421: }
422: 
423: template <>
424: bool TryCast::Operation(uint8_t input, int16_t &result, bool strict) {
425: 	return NumericTryCast::Operation<uint8_t, int16_t>(input, result, strict);
426: }
427: 
428: template <>
429: bool TryCast::Operation(uint8_t input, int32_t &result, bool strict) {
430: 	return NumericTryCast::Operation<uint8_t, int32_t>(input, result, strict);
431: }
432: 
433: template <>
434: bool TryCast::Operation(uint8_t input, int64_t &result, bool strict) {
435: 	return NumericTryCast::Operation<uint8_t, int64_t>(input, result, strict);
436: }
437: 
438: template <>
439: bool TryCast::Operation(uint8_t input, hugeint_t &result, bool strict) {
440: 	return NumericTryCast::Operation<uint8_t, hugeint_t>(input, result, strict);
441: }
442: 
443: template <>
444: bool TryCast::Operation(uint8_t input, uint8_t &result, bool strict) {
445: 	return NumericTryCast::Operation<uint8_t, uint8_t>(input, result, strict);
446: }
447: 
448: template <>
449: bool TryCast::Operation(uint8_t input, uint16_t &result, bool strict) {
450: 	return NumericTryCast::Operation<uint8_t, uint16_t>(input, result, strict);
451: }
452: 
453: template <>
454: bool TryCast::Operation(uint8_t input, uint32_t &result, bool strict) {
455: 	return NumericTryCast::Operation<uint8_t, uint32_t>(input, result, strict);
456: }
457: 
458: template <>
459: bool TryCast::Operation(uint8_t input, uint64_t &result, bool strict) {
460: 	return NumericTryCast::Operation<uint8_t, uint64_t>(input, result, strict);
461: }
462: 
463: template <>
464: bool TryCast::Operation(uint8_t input, float &result, bool strict) {
465: 	return NumericTryCast::Operation<uint8_t, float>(input, result, strict);
466: }
467: 
468: template <>
469: bool TryCast::Operation(uint8_t input, double &result, bool strict) {
470: 	return NumericTryCast::Operation<uint8_t, double>(input, result, strict);
471: }
472: 
473: //===--------------------------------------------------------------------===//
474: // Cast uint16_t -> Numeric
475: //===--------------------------------------------------------------------===//
476: template <>
477: bool TryCast::Operation(uint16_t input, bool &result, bool strict) {
478: 	return NumericTryCast::Operation<uint16_t, bool>(input, result, strict);
479: }
480: 
481: template <>
482: bool TryCast::Operation(uint16_t input, int8_t &result, bool strict) {
483: 	return NumericTryCast::Operation<uint16_t, int8_t>(input, result, strict);
484: }
485: 
486: template <>
487: bool TryCast::Operation(uint16_t input, int16_t &result, bool strict) {
488: 	return NumericTryCast::Operation<uint16_t, int16_t>(input, result, strict);
489: }
490: 
491: template <>
492: bool TryCast::Operation(uint16_t input, int32_t &result, bool strict) {
493: 	return NumericTryCast::Operation<uint16_t, int32_t>(input, result, strict);
494: }
495: 
496: template <>
497: bool TryCast::Operation(uint16_t input, int64_t &result, bool strict) {
498: 	return NumericTryCast::Operation<uint16_t, int64_t>(input, result, strict);
499: }
500: 
501: template <>
502: bool TryCast::Operation(uint16_t input, hugeint_t &result, bool strict) {
503: 	return NumericTryCast::Operation<uint16_t, hugeint_t>(input, result, strict);
504: }
505: 
506: template <>
507: bool TryCast::Operation(uint16_t input, uint8_t &result, bool strict) {
508: 	return NumericTryCast::Operation<uint16_t, uint8_t>(input, result, strict);
509: }
510: 
511: template <>
512: bool TryCast::Operation(uint16_t input, uint16_t &result, bool strict) {
513: 	return NumericTryCast::Operation<uint16_t, uint16_t>(input, result, strict);
514: }
515: 
516: template <>
517: bool TryCast::Operation(uint16_t input, uint32_t &result, bool strict) {
518: 	return NumericTryCast::Operation<uint16_t, uint32_t>(input, result, strict);
519: }
520: 
521: template <>
522: bool TryCast::Operation(uint16_t input, uint64_t &result, bool strict) {
523: 	return NumericTryCast::Operation<uint16_t, uint64_t>(input, result, strict);
524: }
525: 
526: template <>
527: bool TryCast::Operation(uint16_t input, float &result, bool strict) {
528: 	return NumericTryCast::Operation<uint16_t, float>(input, result, strict);
529: }
530: 
531: template <>
532: bool TryCast::Operation(uint16_t input, double &result, bool strict) {
533: 	return NumericTryCast::Operation<uint16_t, double>(input, result, strict);
534: }
535: 
536: //===--------------------------------------------------------------------===//
537: // Cast uint32_t -> Numeric
538: //===--------------------------------------------------------------------===//
539: template <>
540: bool TryCast::Operation(uint32_t input, bool &result, bool strict) {
541: 	return NumericTryCast::Operation<uint32_t, bool>(input, result, strict);
542: }
543: 
544: template <>
545: bool TryCast::Operation(uint32_t input, int8_t &result, bool strict) {
546: 	return NumericTryCast::Operation<uint32_t, int8_t>(input, result, strict);
547: }
548: 
549: template <>
550: bool TryCast::Operation(uint32_t input, int16_t &result, bool strict) {
551: 	return NumericTryCast::Operation<uint32_t, int16_t>(input, result, strict);
552: }
553: 
554: template <>
555: bool TryCast::Operation(uint32_t input, int32_t &result, bool strict) {
556: 	return NumericTryCast::Operation<uint32_t, int32_t>(input, result, strict);
557: }
558: 
559: template <>
560: bool TryCast::Operation(uint32_t input, int64_t &result, bool strict) {
561: 	return NumericTryCast::Operation<uint32_t, int64_t>(input, result, strict);
562: }
563: 
564: template <>
565: bool TryCast::Operation(uint32_t input, hugeint_t &result, bool strict) {
566: 	return NumericTryCast::Operation<uint32_t, hugeint_t>(input, result, strict);
567: }
568: 
569: template <>
570: bool TryCast::Operation(uint32_t input, uint8_t &result, bool strict) {
571: 	return NumericTryCast::Operation<uint32_t, uint8_t>(input, result, strict);
572: }
573: 
574: template <>
575: bool TryCast::Operation(uint32_t input, uint16_t &result, bool strict) {
576: 	return NumericTryCast::Operation<uint32_t, uint16_t>(input, result, strict);
577: }
578: 
579: template <>
580: bool TryCast::Operation(uint32_t input, uint32_t &result, bool strict) {
581: 	return NumericTryCast::Operation<uint32_t, uint32_t>(input, result, strict);
582: }
583: 
584: template <>
585: bool TryCast::Operation(uint32_t input, uint64_t &result, bool strict) {
586: 	return NumericTryCast::Operation<uint32_t, uint64_t>(input, result, strict);
587: }
588: 
589: template <>
590: bool TryCast::Operation(uint32_t input, float &result, bool strict) {
591: 	return NumericTryCast::Operation<uint32_t, float>(input, result, strict);
592: }
593: 
594: template <>
595: bool TryCast::Operation(uint32_t input, double &result, bool strict) {
596: 	return NumericTryCast::Operation<uint32_t, double>(input, result, strict);
597: }
598: 
599: //===--------------------------------------------------------------------===//
600: // Cast uint64_t -> Numeric
601: //===--------------------------------------------------------------------===//
602: template <>
603: bool TryCast::Operation(uint64_t input, bool &result, bool strict) {
604: 	return NumericTryCast::Operation<uint64_t, bool>(input, result, strict);
605: }
606: 
607: template <>
608: bool TryCast::Operation(uint64_t input, int8_t &result, bool strict) {
609: 	return NumericTryCast::Operation<uint64_t, int8_t>(input, result, strict);
610: }
611: 
612: template <>
613: bool TryCast::Operation(uint64_t input, int16_t &result, bool strict) {
614: 	return NumericTryCast::Operation<uint64_t, int16_t>(input, result, strict);
615: }
616: 
617: template <>
618: bool TryCast::Operation(uint64_t input, int32_t &result, bool strict) {
619: 	return NumericTryCast::Operation<uint64_t, int32_t>(input, result, strict);
620: }
621: 
622: template <>
623: bool TryCast::Operation(uint64_t input, int64_t &result, bool strict) {
624: 	return NumericTryCast::Operation<uint64_t, int64_t>(input, result, strict);
625: }
626: 
627: template <>
628: bool TryCast::Operation(uint64_t input, hugeint_t &result, bool strict) {
629: 	return NumericTryCast::Operation<uint64_t, hugeint_t>(input, result, strict);
630: }
631: 
632: template <>
633: bool TryCast::Operation(uint64_t input, uint8_t &result, bool strict) {
634: 	return NumericTryCast::Operation<uint64_t, uint8_t>(input, result, strict);
635: }
636: 
637: template <>
638: bool TryCast::Operation(uint64_t input, uint16_t &result, bool strict) {
639: 	return NumericTryCast::Operation<uint64_t, uint16_t>(input, result, strict);
640: }
641: 
642: template <>
643: bool TryCast::Operation(uint64_t input, uint32_t &result, bool strict) {
644: 	return NumericTryCast::Operation<uint64_t, uint32_t>(input, result, strict);
645: }
646: 
647: template <>
648: bool TryCast::Operation(uint64_t input, uint64_t &result, bool strict) {
649: 	return NumericTryCast::Operation<uint64_t, uint64_t>(input, result, strict);
650: }
651: 
652: template <>
653: bool TryCast::Operation(uint64_t input, float &result, bool strict) {
654: 	return NumericTryCast::Operation<uint64_t, float>(input, result, strict);
655: }
656: 
657: template <>
658: bool TryCast::Operation(uint64_t input, double &result, bool strict) {
659: 	return NumericTryCast::Operation<uint64_t, double>(input, result, strict);
660: }
661: 
662: //===--------------------------------------------------------------------===//
663: // Cast float -> Numeric
664: //===--------------------------------------------------------------------===//
665: template <>
666: bool TryCast::Operation(float input, bool &result, bool strict) {
667: 	return NumericTryCast::Operation<float, bool>(input, result, strict);
668: }
669: 
670: template <>
671: bool TryCast::Operation(float input, int8_t &result, bool strict) {
672: 	return NumericTryCast::Operation<float, int8_t>(input, result, strict);
673: }
674: 
675: template <>
676: bool TryCast::Operation(float input, int16_t &result, bool strict) {
677: 	return NumericTryCast::Operation<float, int16_t>(input, result, strict);
678: }
679: 
680: template <>
681: bool TryCast::Operation(float input, int32_t &result, bool strict) {
682: 	return NumericTryCast::Operation<float, int32_t>(input, result, strict);
683: }
684: 
685: template <>
686: bool TryCast::Operation(float input, int64_t &result, bool strict) {
687: 	return NumericTryCast::Operation<float, int64_t>(input, result, strict);
688: }
689: 
690: template <>
691: bool TryCast::Operation(float input, hugeint_t &result, bool strict) {
692: 	return NumericTryCast::Operation<float, hugeint_t>(input, result, strict);
693: }
694: 
695: template <>
696: bool TryCast::Operation(float input, uint8_t &result, bool strict) {
697: 	return NumericTryCast::Operation<float, uint8_t>(input, result, strict);
698: }
699: 
700: template <>
701: bool TryCast::Operation(float input, uint16_t &result, bool strict) {
702: 	return NumericTryCast::Operation<float, uint16_t>(input, result, strict);
703: }
704: 
705: template <>
706: bool TryCast::Operation(float input, uint32_t &result, bool strict) {
707: 	return NumericTryCast::Operation<float, uint32_t>(input, result, strict);
708: }
709: 
710: template <>
711: bool TryCast::Operation(float input, uint64_t &result, bool strict) {
712: 	return NumericTryCast::Operation<float, uint64_t>(input, result, strict);
713: }
714: 
715: template <>
716: bool TryCast::Operation(float input, float &result, bool strict) {
717: 	return NumericTryCast::Operation<float, float>(input, result, strict);
718: }
719: 
720: template <>
721: bool TryCast::Operation(float input, double &result, bool strict) {
722: 	return NumericTryCast::Operation<float, double>(input, result, strict);
723: }
724: 
725: //===--------------------------------------------------------------------===//
726: // Cast double -> Numeric
727: //===--------------------------------------------------------------------===//
728: template <>
729: bool TryCast::Operation(double input, bool &result, bool strict) {
730: 	return NumericTryCast::Operation<double, bool>(input, result, strict);
731: }
732: 
733: template <>
734: bool TryCast::Operation(double input, int8_t &result, bool strict) {
735: 	return NumericTryCast::Operation<double, int8_t>(input, result, strict);
736: }
737: 
738: template <>
739: bool TryCast::Operation(double input, int16_t &result, bool strict) {
740: 	return NumericTryCast::Operation<double, int16_t>(input, result, strict);
741: }
742: 
743: template <>
744: bool TryCast::Operation(double input, int32_t &result, bool strict) {
745: 	return NumericTryCast::Operation<double, int32_t>(input, result, strict);
746: }
747: 
748: template <>
749: bool TryCast::Operation(double input, int64_t &result, bool strict) {
750: 	return NumericTryCast::Operation<double, int64_t>(input, result, strict);
751: }
752: 
753: template <>
754: bool TryCast::Operation(double input, hugeint_t &result, bool strict) {
755: 	return NumericTryCast::Operation<double, hugeint_t>(input, result, strict);
756: }
757: 
758: template <>
759: bool TryCast::Operation(double input, uint8_t &result, bool strict) {
760: 	return NumericTryCast::Operation<double, uint8_t>(input, result, strict);
761: }
762: 
763: template <>
764: bool TryCast::Operation(double input, uint16_t &result, bool strict) {
765: 	return NumericTryCast::Operation<double, uint16_t>(input, result, strict);
766: }
767: 
768: template <>
769: bool TryCast::Operation(double input, uint32_t &result, bool strict) {
770: 	return NumericTryCast::Operation<double, uint32_t>(input, result, strict);
771: }
772: 
773: template <>
774: bool TryCast::Operation(double input, uint64_t &result, bool strict) {
775: 	return NumericTryCast::Operation<double, uint64_t>(input, result, strict);
776: }
777: 
778: template <>
779: bool TryCast::Operation(double input, float &result, bool strict) {
780: 	return NumericTryCast::Operation<double, float>(input, result, strict);
781: }
782: 
783: template <>
784: bool TryCast::Operation(double input, double &result, bool strict) {
785: 	return NumericTryCast::Operation<double, double>(input, result, strict);
786: }
787: 
788: //===--------------------------------------------------------------------===//
789: // Cast String -> Numeric
790: //===--------------------------------------------------------------------===//
791: template <typename T>
792: struct IntegerCastData {
793: 	using Result = T;
794: 	Result result;
795: 	bool seen_decimal;
796: };
797: 
798: struct IntegerCastOperation {
799: 	template <class T, bool NEGATIVE>
800: 	static bool HandleDigit(T &state, uint8_t digit) {
801: 		using result_t = typename T::Result;
802: 		if (NEGATIVE) {
803: 			if (state.result < (NumericLimits<result_t>::Minimum() + digit) / 10) {
804: 				return false;
805: 			}
806: 			state.result = state.result * 10 - digit;
807: 		} else {
808: 			if (state.result > (NumericLimits<result_t>::Maximum() - digit) / 10) {
809: 				return false;
810: 			}
811: 			state.result = state.result * 10 + digit;
812: 		}
813: 		return true;
814: 	}
815: 
816: 	template <class T, bool NEGATIVE>
817: 	static bool HandleHexDigit(T &state, uint8_t digit) {
818: 		using result_t = typename T::Result;
819: 		if (state.result > (NumericLimits<result_t>::Maximum() - digit) / 16) {
820: 			return false;
821: 		}
822: 		state.result = state.result * 16 + digit;
823: 		return true;
824: 	}
825: 
826: 	template <class T, bool NEGATIVE>
827: 	static bool HandleBinaryDigit(T &state, uint8_t digit) {
828: 		using result_t = typename T::Result;
829: 		if (state.result > (NumericLimits<result_t>::Maximum() - digit) / 2) {
830: 			return false;
831: 		}
832: 		state.result = state.result * 2 + digit;
833: 		return true;
834: 	}
835: 
836: 	template <class T, bool NEGATIVE>
837: 	static bool HandleExponent(T &state, int32_t exponent) {
838: 		using result_t = typename T::Result;
839: 		double dbl_res = state.result * std::pow(10.0L, exponent);
840: 		if (dbl_res < (double)NumericLimits<result_t>::Minimum() ||
841: 		    dbl_res > (double)NumericLimits<result_t>::Maximum()) {
842: 			return false;
843: 		}
844: 		state.result = (result_t)std::nearbyint(dbl_res);
845: 		return true;
846: 	}
847: 
848: 	template <class T, bool NEGATIVE, bool ALLOW_EXPONENT>
849: 	static bool HandleDecimal(T &state, uint8_t digit) {
850: 		if (state.seen_decimal) {
851: 			return true;
852: 		}
853: 		state.seen_decimal = true;
854: 		// round the integer based on what is after the decimal point
855: 		// if digit >= 5, then we round up (or down in case of negative numbers)
856: 		auto increment = digit >= 5;
857: 		if (!increment) {
858: 			return true;
859: 		}
860: 		if (NEGATIVE) {
861: 			if (state.result == NumericLimits<typename T::Result>::Minimum()) {
862: 				return false;
863: 			}
864: 			state.result--;
865: 		} else {
866: 			if (state.result == NumericLimits<typename T::Result>::Maximum()) {
867: 				return false;
868: 			}
869: 			state.result++;
870: 		}
871: 		return true;
872: 	}
873: 
874: 	template <class T, bool NEGATIVE>
875: 	static bool Finalize(T &state) {
876: 		return true;
877: 	}
878: };
879: 
880: template <class T, bool NEGATIVE, bool ALLOW_EXPONENT, class OP = IntegerCastOperation, char decimal_separator = '.'>
881: static bool IntegerCastLoop(const char *buf, idx_t len, T &result, bool strict) {
882: 	idx_t start_pos;
883: 	if (NEGATIVE) {
884: 		start_pos = 1;
885: 	} else {
886: 		if (*buf == '+') {
887: 			if (strict) {
888: 				// leading plus is not allowed in strict mode
889: 				return false;
890: 			}
891: 			start_pos = 1;
892: 		} else {
893: 			start_pos = 0;
894: 		}
895: 	}
896: 	idx_t pos = start_pos;
897: 	while (pos < len) {
898: 		if (!StringUtil::CharacterIsDigit(buf[pos])) {
899: 			// not a digit!
900: 			if (buf[pos] == decimal_separator) {
901: 				if (strict) {
902: 					return false;
903: 				}
904: 				bool number_before_period = pos > start_pos;
905: 				// decimal point: we accept decimal values for integers as well
906: 				// we just truncate them
907: 				// make sure everything after the period is a number
908: 				pos++;
909: 				idx_t start_digit = pos;
910: 				while (pos < len) {
911: 					if (!StringUtil::CharacterIsDigit(buf[pos])) {
912: 						break;
913: 					}
914: 					if (!OP::template HandleDecimal<T, NEGATIVE, ALLOW_EXPONENT>(result, buf[pos] - '0')) {
915: 						return false;
916: 					}
917: 					pos++;
918: 				}
919: 				// make sure there is either (1) one number after the period, or (2) one number before the period
920: 				// i.e. we accept "1." and ".1" as valid numbers, but not "."
921: 				if (!(number_before_period || pos > start_digit)) {
922: 					return false;
923: 				}
924: 				if (pos >= len) {
925: 					break;
926: 				}
927: 			}
928: 			if (StringUtil::CharacterIsSpace(buf[pos])) {
929: 				// skip any trailing spaces
930: 				while (++pos < len) {
931: 					if (!StringUtil::CharacterIsSpace(buf[pos])) {
932: 						return false;
933: 					}
934: 				}
935: 				break;
936: 			}
937: 			if (ALLOW_EXPONENT) {
938: 				if (buf[pos] == 'e' || buf[pos] == 'E') {
939: 					if (pos == start_pos) {
940: 						return false;
941: 					}
942: 					pos++;
943: 					if (pos >= len) {
944: 						return false;
945: 					}
946: 					using ExponentData = IntegerCastData<int32_t>;
947: 					ExponentData exponent {0, false};
948: 					int negative = buf[pos] == '-';
949: 					if (negative) {
950: 						if (!IntegerCastLoop<ExponentData, true, false, IntegerCastOperation, decimal_separator>(
951: 						        buf + pos, len - pos, exponent, strict)) {
952: 							return false;
953: 						}
954: 					} else {
955: 						if (!IntegerCastLoop<ExponentData, false, false, IntegerCastOperation, decimal_separator>(
956: 						        buf + pos, len - pos, exponent, strict)) {
957: 							return false;
958: 						}
959: 					}
960: 					return OP::template HandleExponent<T, NEGATIVE>(result, exponent.result);
961: 				}
962: 			}
963: 			return false;
964: 		}
965: 		uint8_t digit = buf[pos++] - '0';
966: 		if (!OP::template HandleDigit<T, NEGATIVE>(result, digit)) {
967: 			return false;
968: 		}
969: 	}
970: 	if (!OP::template Finalize<T, NEGATIVE>(result)) {
971: 		return false;
972: 	}
973: 	return pos > start_pos;
974: }
975: 
976: template <class T, bool NEGATIVE, bool ALLOW_EXPONENT, class OP = IntegerCastOperation>
977: static bool IntegerHexCastLoop(const char *buf, idx_t len, T &result, bool strict) {
978: 	if (ALLOW_EXPONENT || NEGATIVE) {
979: 		return false;
980: 	}
981: 	idx_t start_pos = 1;
982: 	idx_t pos = start_pos;
983: 	char current_char;
984: 	while (pos < len) {
985: 		current_char = StringUtil::CharacterToLower(buf[pos]);
986: 		if (!StringUtil::CharacterIsHex(current_char)) {
987: 			return false;
988: 		}
989: 		uint8_t digit;
990: 		if (current_char >= 'a') {
991: 			digit = current_char - 'a' + 10;
992: 		} else {
993: 			digit = current_char - '0';
994: 		}
995: 		pos++;
996: 		if (!OP::template HandleHexDigit<T, NEGATIVE>(result, digit)) {
997: 			return false;
998: 		}
999: 	}
1000: 	if (!OP::template Finalize<T, NEGATIVE>(result)) {
1001: 		return false;
1002: 	}
1003: 	return pos > start_pos;
1004: }
1005: 
1006: template <class T, bool NEGATIVE, bool ALLOW_EXPONENT, class OP = IntegerCastOperation>
1007: static bool IntegerBinaryCastLoop(const char *buf, idx_t len, T &result, bool strict) {
1008: 	if (ALLOW_EXPONENT || NEGATIVE) {
1009: 		return false;
1010: 	}
1011: 	idx_t start_pos = 1;
1012: 	idx_t pos = start_pos;
1013: 	uint8_t digit;
1014: 	char current_char;
1015: 	while (pos < len) {
1016: 		current_char = buf[pos];
1017: 		if (current_char == '_' && pos > start_pos) {
1018: 			// skip underscore, if it is not the first character
1019: 			pos++;
1020: 			if (pos == len) {
1021: 				// we cant end on an underscore either
1022: 				return false;
1023: 			}
1024: 			continue;
1025: 		} else if (current_char == '0') {
1026: 			digit = 0;
1027: 		} else if (current_char == '1') {
1028: 			digit = 1;
1029: 		} else {
1030: 			return false;
1031: 		}
1032: 		pos++;
1033: 		if (!OP::template HandleBinaryDigit<T, NEGATIVE>(result, digit)) {
1034: 			return false;
1035: 		}
1036: 	}
1037: 	if (!OP::template Finalize<T, NEGATIVE>(result)) {
1038: 		return false;
1039: 	}
1040: 	return pos > start_pos;
1041: }
1042: 
1043: template <class T, bool IS_SIGNED = true, bool ALLOW_EXPONENT = true, class OP = IntegerCastOperation,
1044:           bool ZERO_INITIALIZE = true, char decimal_separator = '.'>
1045: static bool TryIntegerCast(const char *buf, idx_t len, T &result, bool strict) {
1046: 	// skip any spaces at the start
1047: 	while (len > 0 && StringUtil::CharacterIsSpace(*buf)) {
1048: 		buf++;
1049: 		len--;
1050: 	}
1051: 	if (len == 0) {
1052: 		return false;
1053: 	}
1054: 	if (ZERO_INITIALIZE) {
1055: 		memset(&result, 0, sizeof(T));
1056: 	}
1057: 	// if the number is negative, we set the negative flag and skip the negative sign
1058: 	if (*buf == '-') {
1059: 		if (!IS_SIGNED) {
1060: 			// Need to check if its not -0
1061: 			idx_t pos = 1;
1062: 			while (pos < len) {
1063: 				if (buf[pos++] != '0') {
1064: 					return false;
1065: 				}
1066: 			}
1067: 		}
1068: 		return IntegerCastLoop<T, true, ALLOW_EXPONENT, OP, decimal_separator>(buf, len, result, strict);
1069: 	}
1070: 	if (len > 1 && *buf == '0') {
1071: 		if (buf[1] == 'x' || buf[1] == 'X') {
1072: 			// If it starts with 0x or 0X, we parse it as a hex value
1073: 			buf++;
1074: 			len--;
1075: 			return IntegerHexCastLoop<T, false, false, OP>(buf, len, result, strict);
1076: 		} else if (buf[1] == 'b' || buf[1] == 'B') {
1077: 			// If it starts with 0b or 0B, we parse it as a binary value
1078: 			buf++;
1079: 			len--;
1080: 			return IntegerBinaryCastLoop<T, false, false, OP>(buf, len, result, strict);
1081: 		} else if (strict && StringUtil::CharacterIsDigit(buf[1])) {
1082: 			// leading zeros are not allowed in strict mode
1083: 			return false;
1084: 		}
1085: 	}
1086: 	return IntegerCastLoop<T, false, ALLOW_EXPONENT, OP, decimal_separator>(buf, len, result, strict);
1087: }
1088: 
1089: template <typename T, bool IS_SIGNED = true>
1090: static inline bool TrySimpleIntegerCast(const char *buf, idx_t len, T &result, bool strict) {
1091: 	IntegerCastData<T> data;
1092: 	if (TryIntegerCast<IntegerCastData<T>, IS_SIGNED>(buf, len, data, strict)) {
1093: 		result = data.result;
1094: 		return true;
1095: 	}
1096: 	return false;
1097: }
1098: 
1099: template <>
1100: bool TryCast::Operation(string_t input, bool &result, bool strict) {
1101: 	auto input_data = input.GetData();
1102: 	auto input_size = input.GetSize();
1103: 
1104: 	switch (input_size) {
1105: 	case 1: {
1106: 		char c = std::tolower(*input_data);
1107: 		if (c == 't' || (!strict && c == '1')) {
1108: 			result = true;
1109: 			return true;
1110: 		} else if (c == 'f' || (!strict && c == '0')) {
1111: 			result = false;
1112: 			return true;
1113: 		}
1114: 		return false;
1115: 	}
1116: 	case 4: {
1117: 		char t = std::tolower(input_data[0]);
1118: 		char r = std::tolower(input_data[1]);
1119: 		char u = std::tolower(input_data[2]);
1120: 		char e = std::tolower(input_data[3]);
1121: 		if (t == 't' && r == 'r' && u == 'u' && e == 'e') {
1122: 			result = true;
1123: 			return true;
1124: 		}
1125: 		return false;
1126: 	}
1127: 	case 5: {
1128: 		char f = std::tolower(input_data[0]);
1129: 		char a = std::tolower(input_data[1]);
1130: 		char l = std::tolower(input_data[2]);
1131: 		char s = std::tolower(input_data[3]);
1132: 		char e = std::tolower(input_data[4]);
1133: 		if (f == 'f' && a == 'a' && l == 'l' && s == 's' && e == 'e') {
1134: 			result = false;
1135: 			return true;
1136: 		}
1137: 		return false;
1138: 	}
1139: 	default:
1140: 		return false;
1141: 	}
1142: }
1143: template <>
1144: bool TryCast::Operation(string_t input, int8_t &result, bool strict) {
1145: 	return TrySimpleIntegerCast<int8_t>(input.GetData(), input.GetSize(), result, strict);
1146: }
1147: template <>
1148: bool TryCast::Operation(string_t input, int16_t &result, bool strict) {
1149: 	return TrySimpleIntegerCast<int16_t>(input.GetData(), input.GetSize(), result, strict);
1150: }
1151: template <>
1152: bool TryCast::Operation(string_t input, int32_t &result, bool strict) {
1153: 	return TrySimpleIntegerCast<int32_t>(input.GetData(), input.GetSize(), result, strict);
1154: }
1155: template <>
1156: bool TryCast::Operation(string_t input, int64_t &result, bool strict) {
1157: 	return TrySimpleIntegerCast<int64_t>(input.GetData(), input.GetSize(), result, strict);
1158: }
1159: 
1160: template <>
1161: bool TryCast::Operation(string_t input, uint8_t &result, bool strict) {
1162: 	return TrySimpleIntegerCast<uint8_t, false>(input.GetData(), input.GetSize(), result, strict);
1163: }
1164: template <>
1165: bool TryCast::Operation(string_t input, uint16_t &result, bool strict) {
1166: 	return TrySimpleIntegerCast<uint16_t, false>(input.GetData(), input.GetSize(), result, strict);
1167: }
1168: template <>
1169: bool TryCast::Operation(string_t input, uint32_t &result, bool strict) {
1170: 	return TrySimpleIntegerCast<uint32_t, false>(input.GetData(), input.GetSize(), result, strict);
1171: }
1172: template <>
1173: bool TryCast::Operation(string_t input, uint64_t &result, bool strict) {
1174: 	return TrySimpleIntegerCast<uint64_t, false>(input.GetData(), input.GetSize(), result, strict);
1175: }
1176: 
1177: template <class T, char decimal_separator = '.'>
1178: static bool TryDoubleCast(const char *buf, idx_t len, T &result, bool strict) {
1179: 	// skip any spaces at the start
1180: 	while (len > 0 && StringUtil::CharacterIsSpace(*buf)) {
1181: 		buf++;
1182: 		len--;
1183: 	}
1184: 	if (len == 0) {
1185: 		return false;
1186: 	}
1187: 	if (*buf == '+') {
1188: 		if (strict) {
1189: 			// plus is not allowed in strict mode
1190: 			return false;
1191: 		}
1192: 		buf++;
1193: 		len--;
1194: 	}
1195: 	if (strict && len >= 2) {
1196: 		if (buf[0] == '0' && StringUtil::CharacterIsDigit(buf[1])) {
1197: 			// leading zeros are not allowed in strict mode
1198: 			return false;
1199: 		}
1200: 	}
1201: 	auto endptr = buf + len;
1202: 	auto parse_result = duckdb_fast_float::from_chars(buf, buf + len, result, decimal_separator);
1203: 	if (parse_result.ec != std::errc()) {
1204: 		return false;
1205: 	}
1206: 	auto current_end = parse_result.ptr;
1207: 	if (!strict) {
1208: 		while (current_end < endptr && StringUtil::CharacterIsSpace(*current_end)) {
1209: 			current_end++;
1210: 		}
1211: 	}
1212: 	return current_end == endptr;
1213: }
1214: 
1215: template <>
1216: bool TryCast::Operation(string_t input, float &result, bool strict) {
1217: 	return TryDoubleCast<float>(input.GetData(), input.GetSize(), result, strict);
1218: }
1219: 
1220: template <>
1221: bool TryCast::Operation(string_t input, double &result, bool strict) {
1222: 	return TryDoubleCast<double>(input.GetData(), input.GetSize(), result, strict);
1223: }
1224: 
1225: template <>
1226: bool TryCastErrorMessageCommaSeparated::Operation(string_t input, float &result, string *error_message, bool strict) {
1227: 	if (!TryDoubleCast<float, ','>(input.GetData(), input.GetSize(), result, strict)) {
1228: 		HandleCastError::AssignError(StringUtil::Format("Could not cast string to float: \"%s\"", input.GetString()),
1229: 		                             error_message);
1230: 		return false;
1231: 	}
1232: 	return true;
1233: }
1234: 
1235: template <>
1236: bool TryCastErrorMessageCommaSeparated::Operation(string_t input, double &result, string *error_message, bool strict) {
1237: 	if (!TryDoubleCast<double, ','>(input.GetData(), input.GetSize(), result, strict)) {
1238: 		HandleCastError::AssignError(StringUtil::Format("Could not cast string to double: \"%s\"", input.GetString()),
1239: 		                             error_message);
1240: 		return false;
1241: 	}
1242: 	return true;
1243: }
1244: 
1245: //===--------------------------------------------------------------------===//
1246: // Cast From Date
1247: //===--------------------------------------------------------------------===//
1248: template <>
1249: bool TryCast::Operation(date_t input, date_t &result, bool strict) {
1250: 	result = input;
1251: 	return true;
1252: }
1253: 
1254: template <>
1255: bool TryCast::Operation(date_t input, timestamp_t &result, bool strict) {
1256: 	if (input == date_t::infinity()) {
1257: 		result = timestamp_t::infinity();
1258: 		return true;
1259: 	} else if (input == date_t::ninfinity()) {
1260: 		result = timestamp_t::ninfinity();
1261: 		return true;
1262: 	}
1263: 	return Timestamp::TryFromDatetime(input, Time::FromTime(0, 0, 0), result);
1264: }
1265: 
1266: //===--------------------------------------------------------------------===//
1267: // Cast From Time
1268: //===--------------------------------------------------------------------===//
1269: template <>
1270: bool TryCast::Operation(dtime_t input, dtime_t &result, bool strict) {
1271: 	result = input;
1272: 	return true;
1273: }
1274: 
1275: template <>
1276: bool TryCast::Operation(dtime_t input, dtime_tz_t &result, bool strict) {
1277: 	result = dtime_tz_t(input, 0);
1278: 	return true;
1279: }
1280: 
1281: //===--------------------------------------------------------------------===//
1282: // Cast From Time With Time Zone (Offset)
1283: //===--------------------------------------------------------------------===//
1284: template <>
1285: bool TryCast::Operation(dtime_tz_t input, dtime_tz_t &result, bool strict) {
1286: 	result = input;
1287: 	return true;
1288: }
1289: 
1290: template <>
1291: bool TryCast::Operation(dtime_tz_t input, dtime_t &result, bool strict) {
1292: 	result = input.time();
1293: 	return true;
1294: }
1295: 
1296: //===--------------------------------------------------------------------===//
1297: // Cast From Timestamps
1298: //===--------------------------------------------------------------------===//
1299: template <>
1300: bool TryCast::Operation(timestamp_t input, date_t &result, bool strict) {
1301: 	result = Timestamp::GetDate(input);
1302: 	return true;
1303: }
1304: 
1305: template <>
1306: bool TryCast::Operation(timestamp_t input, dtime_t &result, bool strict) {
1307: 	if (!Timestamp::IsFinite(input)) {
1308: 		return false;
1309: 	}
1310: 	result = Timestamp::GetTime(input);
1311: 	return true;
1312: }
1313: 
1314: template <>
1315: bool TryCast::Operation(timestamp_t input, timestamp_t &result, bool strict) {
1316: 	result = input;
1317: 	return true;
1318: }
1319: 
1320: template <>
1321: bool TryCast::Operation(timestamp_t input, dtime_tz_t &result, bool strict) {
1322: 	if (!Timestamp::IsFinite(input)) {
1323: 		return false;
1324: 	}
1325: 	result = dtime_tz_t(Timestamp::GetTime(input), 0);
1326: 	return true;
1327: }
1328: 
1329: //===--------------------------------------------------------------------===//
1330: // Cast from Interval
1331: //===--------------------------------------------------------------------===//
1332: template <>
1333: bool TryCast::Operation(interval_t input, interval_t &result, bool strict) {
1334: 	result = input;
1335: 	return true;
1336: }
1337: 
1338: //===--------------------------------------------------------------------===//
1339: // Non-Standard Timestamps
1340: //===--------------------------------------------------------------------===//
1341: template <>
1342: duckdb::string_t CastFromTimestampNS::Operation(duckdb::timestamp_t input, Vector &result) {
1343: 	return StringCast::Operation<timestamp_t>(Timestamp::FromEpochNanoSeconds(input.value), result);
1344: }
1345: template <>
1346: duckdb::string_t CastFromTimestampMS::Operation(duckdb::timestamp_t input, Vector &result) {
1347: 	return StringCast::Operation<timestamp_t>(Timestamp::FromEpochMs(input.value), result);
1348: }
1349: template <>
1350: duckdb::string_t CastFromTimestampSec::Operation(duckdb::timestamp_t input, Vector &result) {
1351: 	return StringCast::Operation<timestamp_t>(Timestamp::FromEpochSeconds(input.value), result);
1352: }
1353: 
1354: template <>
1355: timestamp_t CastTimestampUsToMs::Operation(timestamp_t input) {
1356: 	timestamp_t cast_timestamp(Timestamp::GetEpochMs(input));
1357: 	return cast_timestamp;
1358: }
1359: 
1360: template <>
1361: timestamp_t CastTimestampUsToNs::Operation(timestamp_t input) {
1362: 	timestamp_t cast_timestamp(Timestamp::GetEpochNanoSeconds(input));
1363: 	return cast_timestamp;
1364: }
1365: 
1366: template <>
1367: timestamp_t CastTimestampUsToSec::Operation(timestamp_t input) {
1368: 	timestamp_t cast_timestamp(Timestamp::GetEpochSeconds(input));
1369: 	return cast_timestamp;
1370: }
1371: template <>
1372: timestamp_t CastTimestampMsToUs::Operation(timestamp_t input) {
1373: 	return Timestamp::FromEpochMs(input.value);
1374: }
1375: 
1376: template <>
1377: timestamp_t CastTimestampMsToNs::Operation(timestamp_t input) {
1378: 	auto us = CastTimestampMsToUs::Operation<timestamp_t, timestamp_t>(input);
1379: 	return CastTimestampUsToNs::Operation<timestamp_t, timestamp_t>(us);
1380: }
1381: 
1382: template <>
1383: timestamp_t CastTimestampNsToUs::Operation(timestamp_t input) {
1384: 	return Timestamp::FromEpochNanoSeconds(input.value);
1385: }
1386: 
1387: template <>
1388: timestamp_t CastTimestampSecToUs::Operation(timestamp_t input) {
1389: 	return Timestamp::FromEpochSeconds(input.value);
1390: }
1391: 
1392: template <>
1393: timestamp_t CastTimestampSecToMs::Operation(timestamp_t input) {
1394: 	auto us = CastTimestampSecToUs::Operation<timestamp_t, timestamp_t>(input);
1395: 	return CastTimestampUsToMs::Operation<timestamp_t, timestamp_t>(us);
1396: }
1397: 
1398: template <>
1399: timestamp_t CastTimestampSecToNs::Operation(timestamp_t input) {
1400: 	auto us = CastTimestampSecToUs::Operation<timestamp_t, timestamp_t>(input);
1401: 	return CastTimestampUsToNs::Operation<timestamp_t, timestamp_t>(us);
1402: }
1403: 
1404: //===--------------------------------------------------------------------===//
1405: // Cast To Timestamp
1406: //===--------------------------------------------------------------------===//
1407: template <>
1408: bool TryCastToTimestampNS::Operation(string_t input, timestamp_t &result, bool strict) {
1409: 	if (!TryCast::Operation<string_t, timestamp_t>(input, result, strict)) {
1410: 		return false;
1411: 	}
1412: 	result = Timestamp::GetEpochNanoSeconds(result);
1413: 	return true;
1414: }
1415: 
1416: template <>
1417: bool TryCastToTimestampMS::Operation(string_t input, timestamp_t &result, bool strict) {
1418: 	if (!TryCast::Operation<string_t, timestamp_t>(input, result, strict)) {
1419: 		return false;
1420: 	}
1421: 	result = Timestamp::GetEpochMs(result);
1422: 	return true;
1423: }
1424: 
1425: template <>
1426: bool TryCastToTimestampSec::Operation(string_t input, timestamp_t &result, bool strict) {
1427: 	if (!TryCast::Operation<string_t, timestamp_t>(input, result, strict)) {
1428: 		return false;
1429: 	}
1430: 	result = Timestamp::GetEpochSeconds(result);
1431: 	return true;
1432: }
1433: 
1434: template <>
1435: bool TryCastToTimestampNS::Operation(date_t input, timestamp_t &result, bool strict) {
1436: 	if (!TryCast::Operation<date_t, timestamp_t>(input, result, strict)) {
1437: 		return false;
1438: 	}
1439: 	if (!TryMultiplyOperator::Operation(result.value, Interval::NANOS_PER_MICRO, result.value)) {
1440: 		return false;
1441: 	}
1442: 	return true;
1443: }
1444: 
1445: template <>
1446: bool TryCastToTimestampMS::Operation(date_t input, timestamp_t &result, bool strict) {
1447: 	if (!TryCast::Operation<date_t, timestamp_t>(input, result, strict)) {
1448: 		return false;
1449: 	}
1450: 	result.value /= Interval::MICROS_PER_MSEC;
1451: 	return true;
1452: }
1453: 
1454: template <>
1455: bool TryCastToTimestampSec::Operation(date_t input, timestamp_t &result, bool strict) {
1456: 	if (!TryCast::Operation<date_t, timestamp_t>(input, result, strict)) {
1457: 		return false;
1458: 	}
1459: 	result.value /= Interval::MICROS_PER_MSEC * Interval::MSECS_PER_SEC;
1460: 	return true;
1461: }
1462: 
1463: //===--------------------------------------------------------------------===//
1464: // Cast From Blob
1465: //===--------------------------------------------------------------------===//
1466: template <>
1467: string_t CastFromBlob::Operation(string_t input, Vector &vector) {
1468: 	idx_t result_size = Blob::GetStringSize(input);
1469: 
1470: 	string_t result = StringVector::EmptyString(vector, result_size);
1471: 	Blob::ToString(input, result.GetDataWriteable());
1472: 	result.Finalize();
1473: 
1474: 	return result;
1475: }
1476: 
1477: template <>
1478: string_t CastFromBlobToBit::Operation(string_t input, Vector &vector) {
1479: 	idx_t result_size = input.GetSize() + 1;
1480: 	if (result_size <= 1) {
1481: 		throw ConversionException("Cannot cast empty BLOB to BIT");
1482: 	}
1483: 	return StringVector::AddStringOrBlob(vector, Bit::BlobToBit(input));
1484: }
1485: 
1486: //===--------------------------------------------------------------------===//
1487: // Cast From Bit
1488: //===--------------------------------------------------------------------===//
1489: template <>
1490: string_t CastFromBitToString::Operation(string_t input, Vector &vector) {
1491: 
1492: 	idx_t result_size = Bit::BitLength(input);
1493: 	string_t result = StringVector::EmptyString(vector, result_size);
1494: 	Bit::ToString(input, result.GetDataWriteable());
1495: 	result.Finalize();
1496: 
1497: 	return result;
1498: }
1499: 
1500: //===--------------------------------------------------------------------===//
1501: // Cast From Pointer
1502: //===--------------------------------------------------------------------===//
1503: template <>
1504: string_t CastFromPointer::Operation(uintptr_t input, Vector &vector) {
1505: 	std::string s = duckdb_fmt::format("0x{:x}", input);
1506: 	return StringVector::AddString(vector, s);
1507: }
1508: 
1509: //===--------------------------------------------------------------------===//
1510: // Cast To Blob
1511: //===--------------------------------------------------------------------===//
1512: template <>
1513: bool TryCastToBlob::Operation(string_t input, string_t &result, Vector &result_vector, string *error_message,
1514:                               bool strict) {
1515: 	idx_t result_size;
1516: 	if (!Blob::TryGetBlobSize(input, result_size, error_message)) {
1517: 		return false;
1518: 	}
1519: 
1520: 	result = StringVector::EmptyString(result_vector, result_size);
1521: 	Blob::ToBlob(input, data_ptr_cast(result.GetDataWriteable()));
1522: 	result.Finalize();
1523: 	return true;
1524: }
1525: 
1526: //===--------------------------------------------------------------------===//
1527: // Cast To Bit
1528: //===--------------------------------------------------------------------===//
1529: template <>
1530: bool TryCastToBit::Operation(string_t input, string_t &result, Vector &result_vector, string *error_message,
1531:                              bool strict) {
1532: 	idx_t result_size;
1533: 	if (!Bit::TryGetBitStringSize(input, result_size, error_message)) {
1534: 		return false;
1535: 	}
1536: 
1537: 	result = StringVector::EmptyString(result_vector, result_size);
1538: 	Bit::ToBit(input, result);
1539: 	result.Finalize();
1540: 	return true;
1541: }
1542: 
1543: template <>
1544: bool CastFromBitToNumeric::Operation(string_t input, bool &result, bool strict) {
1545: 	D_ASSERT(input.GetSize() > 1);
1546: 
1547: 	uint8_t value;
1548: 	bool success = CastFromBitToNumeric::Operation(input, value, strict);
1549: 	result = (value > 0);
1550: 	return (success);
1551: }
1552: 
1553: template <>
1554: bool CastFromBitToNumeric::Operation(string_t input, hugeint_t &result, bool strict) {
1555: 	D_ASSERT(input.GetSize() > 1);
1556: 
1557: 	if (input.GetSize() - 1 > sizeof(hugeint_t)) {
1558: 		throw ConversionException("Bitstring doesn't fit inside of %s", GetTypeId<hugeint_t>());
1559: 	}
1560: 	Bit::BitToNumeric(input, result);
1561: 	if (result < NumericLimits<hugeint_t>::Minimum()) {
1562: 		throw ConversionException("Minimum limit for HUGEINT is %s", NumericLimits<hugeint_t>::Minimum().ToString());
1563: 	}
1564: 	return (true);
1565: }
1566: 
1567: //===--------------------------------------------------------------------===//
1568: // Cast From UUID
1569: //===--------------------------------------------------------------------===//
1570: template <>
1571: string_t CastFromUUID::Operation(hugeint_t input, Vector &vector) {
1572: 	string_t result = StringVector::EmptyString(vector, 36);
1573: 	UUID::ToString(input, result.GetDataWriteable());
1574: 	result.Finalize();
1575: 	return result;
1576: }
1577: 
1578: //===--------------------------------------------------------------------===//
1579: // Cast To UUID
1580: //===--------------------------------------------------------------------===//
1581: template <>
1582: bool TryCastToUUID::Operation(string_t input, hugeint_t &result, Vector &result_vector, string *error_message,
1583:                               bool strict) {
1584: 	return UUID::FromString(input.GetString(), result);
1585: }
1586: 
1587: //===--------------------------------------------------------------------===//
1588: // Cast To Date
1589: //===--------------------------------------------------------------------===//
1590: template <>
1591: bool TryCastErrorMessage::Operation(string_t input, date_t &result, string *error_message, bool strict) {
1592: 	if (!TryCast::Operation<string_t, date_t>(input, result, strict)) {
1593: 		HandleCastError::AssignError(Date::ConversionError(input), error_message);
1594: 		return false;
1595: 	}
1596: 	return true;
1597: }
1598: 
1599: template <>
1600: bool TryCast::Operation(string_t input, date_t &result, bool strict) {
1601: 	idx_t pos;
1602: 	bool special = false;
1603: 	return Date::TryConvertDate(input.GetData(), input.GetSize(), pos, result, special, strict);
1604: }
1605: 
1606: template <>
1607: date_t Cast::Operation(string_t input) {
1608: 	return Date::FromCString(input.GetData(), input.GetSize());
1609: }
1610: 
1611: //===--------------------------------------------------------------------===//
1612: // Cast To Time
1613: //===--------------------------------------------------------------------===//
1614: template <>
1615: bool TryCastErrorMessage::Operation(string_t input, dtime_t &result, string *error_message, bool strict) {
1616: 	if (!TryCast::Operation<string_t, dtime_t>(input, result, strict)) {
1617: 		HandleCastError::AssignError(Time::ConversionError(input), error_message);
1618: 		return false;
1619: 	}
1620: 	return true;
1621: }
1622: 
1623: template <>
1624: bool TryCast::Operation(string_t input, dtime_t &result, bool strict) {
1625: 	idx_t pos;
1626: 	return Time::TryConvertTime(input.GetData(), input.GetSize(), pos, result, strict);
1627: }
1628: 
1629: template <>
1630: dtime_t Cast::Operation(string_t input) {
1631: 	return Time::FromCString(input.GetData(), input.GetSize());
1632: }
1633: 
1634: //===--------------------------------------------------------------------===//
1635: // Cast To TimeTZ
1636: //===--------------------------------------------------------------------===//
1637: template <>
1638: bool TryCastErrorMessage::Operation(string_t input, dtime_tz_t &result, string *error_message, bool strict) {
1639: 	if (!TryCast::Operation<string_t, dtime_tz_t>(input, result, strict)) {
1640: 		HandleCastError::AssignError(Time::ConversionError(input), error_message);
1641: 		return false;
1642: 	}
1643: 	return true;
1644: }
1645: 
1646: template <>
1647: bool TryCast::Operation(string_t input, dtime_tz_t &result, bool strict) {
1648: 	idx_t pos;
1649: 	return Time::TryConvertTimeTZ(input.GetData(), input.GetSize(), pos, result, strict);
1650: }
1651: 
1652: template <>
1653: dtime_tz_t Cast::Operation(string_t input) {
1654: 	dtime_tz_t result;
1655: 	if (!TryCast::Operation(input, result, false)) {
1656: 		throw ConversionException(Time::ConversionError(input));
1657: 	}
1658: 	return result;
1659: }
1660: 
1661: //===--------------------------------------------------------------------===//
1662: // Cast To Timestamp
1663: //===--------------------------------------------------------------------===//
1664: template <>
1665: bool TryCastErrorMessage::Operation(string_t input, timestamp_t &result, string *error_message, bool strict) {
1666: 	auto cast_result = Timestamp::TryConvertTimestamp(input.GetData(), input.GetSize(), result);
1667: 	if (cast_result == TimestampCastResult::SUCCESS) {
1668: 		return true;
1669: 	}
1670: 	if (cast_result == TimestampCastResult::ERROR_INCORRECT_FORMAT) {
1671: 		HandleCastError::AssignError(Timestamp::ConversionError(input), error_message);
1672: 	} else {
1673: 		HandleCastError::AssignError(Timestamp::UnsupportedTimezoneError(input), error_message);
1674: 	}
1675: 	return false;
1676: }
1677: 
1678: template <>
1679: bool TryCast::Operation(string_t input, timestamp_t &result, bool strict) {
1680: 	return Timestamp::TryConvertTimestamp(input.GetData(), input.GetSize(), result) == TimestampCastResult::SUCCESS;
1681: }
1682: 
1683: template <>
1684: timestamp_t Cast::Operation(string_t input) {
1685: 	return Timestamp::FromCString(input.GetData(), input.GetSize());
1686: }
1687: 
1688: //===--------------------------------------------------------------------===//
1689: // Cast From Interval
1690: //===--------------------------------------------------------------------===//
1691: template <>
1692: bool TryCastErrorMessage::Operation(string_t input, interval_t &result, string *error_message, bool strict) {
1693: 	return Interval::FromCString(input.GetData(), input.GetSize(), result, error_message, strict);
1694: }
1695: 
1696: //===--------------------------------------------------------------------===//
1697: // Cast From Hugeint
1698: //===--------------------------------------------------------------------===//
1699: // parsing hugeint from string is done a bit differently for performance reasons
1700: // for other integer types we keep track of a single value
1701: // and multiply that value by 10 for every digit we read
1702: // however, for hugeints, multiplication is very expensive (>20X as expensive as for int64)
1703: // for that reason, we parse numbers first into an int64 value
1704: // when that value is full, we perform a HUGEINT multiplication to flush it into the hugeint
1705: // this takes the number of HUGEINT multiplications down from [0-38] to [0-2]
1706: struct HugeIntCastData {
1707: 	hugeint_t hugeint;
1708: 	int64_t intermediate;
1709: 	uint8_t digits;
1710: 	bool decimal;
1711: 
1712: 	bool Flush() {
1713: 		if (digits == 0 && intermediate == 0) {
1714: 			return true;
1715: 		}
1716: 		if (hugeint.lower != 0 || hugeint.upper != 0) {
1717: 			if (digits > 38) {
1718: 				return false;
1719: 			}
1720: 			if (!Hugeint::TryMultiply(hugeint, Hugeint::POWERS_OF_TEN[digits], hugeint)) {
1721: 				return false;
1722: 			}
1723: 		}
1724: 		if (!Hugeint::AddInPlace(hugeint, hugeint_t(intermediate))) {
1725: 			return false;
1726: 		}
1727: 		digits = 0;
1728: 		intermediate = 0;
1729: 		return true;
1730: 	}
1731: };
1732: 
1733: struct HugeIntegerCastOperation {
1734: 	template <class T, bool NEGATIVE>
1735: 	static bool HandleDigit(T &result, uint8_t digit) {
1736: 		if (NEGATIVE) {
1737: 			if (result.intermediate < (NumericLimits<int64_t>::Minimum() + digit) / 10) {
1738: 				// intermediate is full: need to flush it
1739: 				if (!result.Flush()) {
1740: 					return false;
1741: 				}
1742: 			}
1743: 			result.intermediate = result.intermediate * 10 - digit;
1744: 		} else {
1745: 			if (result.intermediate > (NumericLimits<int64_t>::Maximum() - digit) / 10) {
1746: 				if (!result.Flush()) {
1747: 					return false;
1748: 				}
1749: 			}
1750: 			result.intermediate = result.intermediate * 10 + digit;
1751: 		}
1752: 		result.digits++;
1753: 		return true;
1754: 	}
1755: 
1756: 	template <class T, bool NEGATIVE>
1757: 	static bool HandleHexDigit(T &result, uint8_t digit) {
1758: 		return false;
1759: 	}
1760: 
1761: 	template <class T, bool NEGATIVE>
1762: 	static bool HandleBinaryDigit(T &result, uint8_t digit) {
1763: 		if (result.intermediate > (NumericLimits<int64_t>::Maximum() - digit) / 2) {
1764: 			// intermediate is full: need to flush it
1765: 			if (!result.Flush()) {
1766: 				return false;
1767: 			}
1768: 		}
1769: 		result.intermediate = result.intermediate * 2 + digit;
1770: 		result.digits++;
1771: 		return true;
1772: 	}
1773: 
1774: 	template <class T, bool NEGATIVE>
1775: 	static bool HandleExponent(T &result, int32_t exponent) {
1776: 		if (!result.Flush()) {
1777: 			return false;
1778: 		}
1779: 		if (exponent < -38 || exponent > 38) {
1780: 			// out of range for exact exponent: use double and convert
1781: 			double dbl_res = Hugeint::Cast<double>(result.hugeint) * std::pow(10.0L, exponent);
1782: 			if (dbl_res < Hugeint::Cast<double>(NumericLimits<hugeint_t>::Minimum()) ||
1783: 			    dbl_res > Hugeint::Cast<double>(NumericLimits<hugeint_t>::Maximum())) {
1784: 				return false;
1785: 			}
1786: 			result.hugeint = Hugeint::Convert(dbl_res);
1787: 			return true;
1788: 		}
1789: 		if (exponent < 0) {
1790: 			// negative exponent: divide by power of 10
1791: 			result.hugeint = Hugeint::Divide(result.hugeint, Hugeint::POWERS_OF_TEN[-exponent]);
1792: 			return true;
1793: 		} else {
1794: 			// positive exponent: multiply by power of 10
1795: 			return Hugeint::TryMultiply(result.hugeint, Hugeint::POWERS_OF_TEN[exponent], result.hugeint);
1796: 		}
1797: 	}
1798: 
1799: 	template <class T, bool NEGATIVE, bool ALLOW_EXPONENT>
1800: 	static bool HandleDecimal(T &result, uint8_t digit) {
1801: 		// Integer casts round
1802: 		if (!result.decimal) {
1803: 			if (!result.Flush()) {
1804: 				return false;
1805: 			}
1806: 			if (NEGATIVE) {
1807: 				result.intermediate = -(digit >= 5);
1808: 			} else {
1809: 				result.intermediate = (digit >= 5);
1810: 			}
1811: 		}
1812: 		result.decimal = true;
1813: 
1814: 		return true;
1815: 	}
1816: 
1817: 	template <class T, bool NEGATIVE>
1818: 	static bool Finalize(T &result) {
1819: 		return result.Flush();
1820: 	}
1821: };
1822: 
1823: template <>
1824: bool TryCast::Operation(string_t input, hugeint_t &result, bool strict) {
1825: 	HugeIntCastData data;
1826: 	if (!TryIntegerCast<HugeIntCastData, true, true, HugeIntegerCastOperation>(input.GetData(), input.GetSize(), data,
1827: 	                                                                           strict)) {
1828: 		return false;
1829: 	}
1830: 	result = data.hugeint;
1831: 	return true;
1832: }
1833: 
1834: //===--------------------------------------------------------------------===//
1835: // Decimal String Cast
1836: //===--------------------------------------------------------------------===//
1837: 
1838: template <class TYPE>
1839: struct DecimalCastData {
1840: 	typedef TYPE type_t;
1841: 	TYPE result;
1842: 	uint8_t width;
1843: 	uint8_t scale;
1844: 	uint8_t digit_count;
1845: 	uint8_t decimal_count;
1846: 	//! Whether we have determined if the result should be rounded
1847: 	bool round_set;
1848: 	//! If the result should be rounded
1849: 	bool should_round;
1850: 	//! Only set when ALLOW_EXPONENT is enabled
1851: 	enum class ExponentType : uint8_t { NONE, POSITIVE, NEGATIVE };
1852: 	uint8_t excessive_decimals;
1853: 	ExponentType exponent_type;
1854: };
1855: 
1856: struct DecimalCastOperation {
1857: 	template <class T, bool NEGATIVE>
1858: 	static bool HandleDigit(T &state, uint8_t digit) {
1859: 		if (state.result == 0 && digit == 0) {
1860: 			// leading zero's don't count towards the digit count
1861: 			return true;
1862: 		}
1863: 		if (state.digit_count == state.width - state.scale) {
1864: 			// width of decimal type is exceeded!
1865: 			return false;
1866: 		}
1867: 		state.digit_count++;
1868: 		if (NEGATIVE) {
1869: 			if (state.result < (NumericLimits<typename T::type_t>::Minimum() / 10)) {
1870: 				return false;
1871: 			}
1872: 			state.result = state.result * 10 - digit;
1873: 		} else {
1874: 			if (state.result > (NumericLimits<typename T::type_t>::Maximum() / 10)) {
1875: 				return false;
1876: 			}
1877: 			state.result = state.result * 10 + digit;
1878: 		}
1879: 		return true;
1880: 	}
1881: 
1882: 	template <class T, bool NEGATIVE>
1883: 	static bool HandleHexDigit(T &state, uint8_t digit) {
1884: 		return false;
1885: 	}
1886: 
1887: 	template <class T, bool NEGATIVE>
1888: 	static bool HandleBinaryDigit(T &state, uint8_t digit) {
1889: 		return false;
1890: 	}
1891: 
1892: 	template <class T, bool NEGATIVE>
1893: 	static void RoundUpResult(T &state) {
1894: 		if (NEGATIVE) {
1895: 			state.result -= 1;
1896: 		} else {
1897: 			state.result += 1;
1898: 		}
1899: 	}
1900: 
1901: 	template <class T, bool NEGATIVE>
1902: 	static bool HandleExponent(T &state, int32_t exponent) {
1903: 		auto decimal_excess = (state.decimal_count > state.scale) ? state.decimal_count - state.scale : 0;
1904: 		if (exponent > 0) {
1905: 			state.exponent_type = T::ExponentType::POSITIVE;
1906: 			// Positive exponents need up to 'exponent' amount of digits
1907: 			// Everything beyond that amount needs to be truncated
1908: 			if (decimal_excess > exponent) {
1909: 				// We've allowed too many decimals
1910: 				state.excessive_decimals = decimal_excess - exponent;
1911: 				exponent = 0;
1912: 			} else {
1913: 				exponent -= decimal_excess;
1914: 			}
1915: 			D_ASSERT(exponent >= 0);
1916: 		} else if (exponent < 0) {
1917: 			state.exponent_type = T::ExponentType::NEGATIVE;
1918: 		}
1919: 		if (!Finalize<T, NEGATIVE>(state)) {
1920: 			return false;
1921: 		}
1922: 		if (exponent < 0) {
1923: 			bool round_up = false;
1924: 			for (idx_t i = 0; i < idx_t(-int64_t(exponent)); i++) {
1925: 				auto mod = state.result % 10;
1926: 				round_up = NEGATIVE ? mod <= -5 : mod >= 5;
1927: 				state.result /= 10;
1928: 				if (state.result == 0) {
1929: 					break;
1930: 				}
1931: 			}
1932: 			if (round_up) {
1933: 				RoundUpResult<T, NEGATIVE>(state);
1934: 			}
1935: 			return true;
1936: 		} else {
1937: 			// positive exponent: append 0's
1938: 			for (idx_t i = 0; i < idx_t(exponent); i++) {
1939: 				if (!HandleDigit<T, NEGATIVE>(state, 0)) {
1940: 					return false;
1941: 				}
1942: 			}
1943: 			return true;
1944: 		}
1945: 	}
1946: 
1947: 	template <class T, bool NEGATIVE, bool ALLOW_EXPONENT>
1948: 	static bool HandleDecimal(T &state, uint8_t digit) {
1949: 		if (state.decimal_count == state.scale && !state.round_set) {
1950: 			// Determine whether the last registered decimal should be rounded or not
1951: 			state.round_set = true;
1952: 			state.should_round = digit >= 5;
1953: 		}
1954: 		if (!ALLOW_EXPONENT && state.decimal_count == state.scale) {
1955: 			// we exceeded the amount of supported decimals
1956: 			// however, we don't throw an error here
1957: 			// we just truncate the decimal
1958: 			return true;
1959: 		}
1960: 		//! If we expect an exponent, we need to preserve the decimals
1961: 		//! But we don't want to overflow, so we prevent overflowing the result with this check
1962: 		if (state.digit_count + state.decimal_count >= DecimalWidth<decltype(state.result)>::max) {
1963: 			return true;
1964: 		}
1965: 		state.decimal_count++;
1966: 		if (NEGATIVE) {
1967: 			state.result = state.result * 10 - digit;
1968: 		} else {
1969: 			state.result = state.result * 10 + digit;
1970: 		}
1971: 		return true;
1972: 	}
1973: 
1974: 	template <class T, bool NEGATIVE>
1975: 	static bool TruncateExcessiveDecimals(T &state) {
1976: 		D_ASSERT(state.excessive_decimals);
1977: 		bool round_up = false;
1978: 		for (idx_t i = 0; i < state.excessive_decimals; i++) {
1979: 			auto mod = state.result % 10;
1980: 			round_up = NEGATIVE ? mod <= -5 : mod >= 5;
1981: 			state.result /= 10.0;
1982: 		}
1983: 		//! Only round up when exponents are involved
1984: 		if (state.exponent_type == T::ExponentType::POSITIVE && round_up) {
1985: 			RoundUpResult<T, NEGATIVE>(state);
1986: 		}
1987: 		D_ASSERT(state.decimal_count > state.scale);
1988: 		state.decimal_count = state.scale;
1989: 		return true;
1990: 	}
1991: 
1992: 	template <class T, bool NEGATIVE>
1993: 	static bool Finalize(T &state) {
1994: 		if (state.exponent_type != T::ExponentType::POSITIVE && state.decimal_count > state.scale) {
1995: 			//! Did not encounter an exponent, but ALLOW_EXPONENT was on
1996: 			state.excessive_decimals = state.decimal_count - state.scale;
1997: 		}
1998: 		if (state.excessive_decimals && !TruncateExcessiveDecimals<T, NEGATIVE>(state)) {
1999: 			return false;
2000: 		}
2001: 		if (state.exponent_type == T::ExponentType::NONE && state.round_set && state.should_round) {
2002: 			RoundUpResult<T, NEGATIVE>(state);
2003: 		}
2004: 		//  if we have not gotten exactly "scale" decimals, we need to multiply the result
2005: 		//  e.g. if we have a string "1.0" that is cast to a DECIMAL(9,3), the value needs to be 1000
2006: 		//  but we have only gotten the value "10" so far, so we multiply by 1000
2007: 		for (uint8_t i = state.decimal_count; i < state.scale; i++) {
2008: 			state.result *= 10;
2009: 		}
2010: 		return true;
2011: 	}
2012: };
2013: 
2014: template <class T, char decimal_separator = '.'>
2015: bool TryDecimalStringCast(string_t input, T &result, string *error_message, uint8_t width, uint8_t scale) {
2016: 	DecimalCastData<T> state;
2017: 	state.result = 0;
2018: 	state.width = width;
2019: 	state.scale = scale;
2020: 	state.digit_count = 0;
2021: 	state.decimal_count = 0;
2022: 	state.excessive_decimals = 0;
2023: 	state.exponent_type = DecimalCastData<T>::ExponentType::NONE;
2024: 	state.round_set = false;
2025: 	state.should_round = false;
2026: 	if (!TryIntegerCast<DecimalCastData<T>, true, true, DecimalCastOperation, false, decimal_separator>(
2027: 	        input.GetData(), input.GetSize(), state, false)) {
2028: 		string error = StringUtil::Format("Could not convert string \"%s\" to DECIMAL(%d,%d)", input.GetString(),
2029: 		                                  (int)width, (int)scale);
2030: 		HandleCastError::AssignError(error, error_message);
2031: 		return false;
2032: 	}
2033: 	result = state.result;
2034: 	return true;
2035: }
2036: 
2037: template <>
2038: bool TryCastToDecimal::Operation(string_t input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
2039: 	return TryDecimalStringCast<int16_t>(input, result, error_message, width, scale);
2040: }
2041: 
2042: template <>
2043: bool TryCastToDecimal::Operation(string_t input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
2044: 	return TryDecimalStringCast<int32_t>(input, result, error_message, width, scale);
2045: }
2046: 
2047: template <>
2048: bool TryCastToDecimal::Operation(string_t input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
2049: 	return TryDecimalStringCast<int64_t>(input, result, error_message, width, scale);
2050: }
2051: 
2052: template <>
2053: bool TryCastToDecimal::Operation(string_t input, hugeint_t &result, string *error_message, uint8_t width,
2054:                                  uint8_t scale) {
2055: 	return TryDecimalStringCast<hugeint_t>(input, result, error_message, width, scale);
2056: }
2057: 
2058: template <>
2059: bool TryCastToDecimalCommaSeparated::Operation(string_t input, int16_t &result, string *error_message, uint8_t width,
2060:                                                uint8_t scale) {
2061: 	return TryDecimalStringCast<int16_t, ','>(input, result, error_message, width, scale);
2062: }
2063: 
2064: template <>
2065: bool TryCastToDecimalCommaSeparated::Operation(string_t input, int32_t &result, string *error_message, uint8_t width,
2066:                                                uint8_t scale) {
2067: 	return TryDecimalStringCast<int32_t, ','>(input, result, error_message, width, scale);
2068: }
2069: 
2070: template <>
2071: bool TryCastToDecimalCommaSeparated::Operation(string_t input, int64_t &result, string *error_message, uint8_t width,
2072:                                                uint8_t scale) {
2073: 	return TryDecimalStringCast<int64_t, ','>(input, result, error_message, width, scale);
2074: }
2075: 
2076: template <>
2077: bool TryCastToDecimalCommaSeparated::Operation(string_t input, hugeint_t &result, string *error_message, uint8_t width,
2078:                                                uint8_t scale) {
2079: 	return TryDecimalStringCast<hugeint_t, ','>(input, result, error_message, width, scale);
2080: }
2081: 
2082: template <>
2083: string_t StringCastFromDecimal::Operation(int16_t input, uint8_t width, uint8_t scale, Vector &result) {
2084: 	return DecimalToString::Format<int16_t, uint16_t>(input, width, scale, result);
2085: }
2086: 
2087: template <>
2088: string_t StringCastFromDecimal::Operation(int32_t input, uint8_t width, uint8_t scale, Vector &result) {
2089: 	return DecimalToString::Format<int32_t, uint32_t>(input, width, scale, result);
2090: }
2091: 
2092: template <>
2093: string_t StringCastFromDecimal::Operation(int64_t input, uint8_t width, uint8_t scale, Vector &result) {
2094: 	return DecimalToString::Format<int64_t, uint64_t>(input, width, scale, result);
2095: }
2096: 
2097: template <>
2098: string_t StringCastFromDecimal::Operation(hugeint_t input, uint8_t width, uint8_t scale, Vector &result) {
2099: 	return HugeintToStringCast::FormatDecimal(input, width, scale, result);
2100: }
2101: 
2102: //===--------------------------------------------------------------------===//
2103: // Decimal Casts
2104: //===--------------------------------------------------------------------===//
2105: // Decimal <-> Bool
2106: //===--------------------------------------------------------------------===//
2107: template <class T, class OP = NumericHelper>
2108: bool TryCastBoolToDecimal(bool input, T &result, string *error_message, uint8_t width, uint8_t scale) {
2109: 	if (width > scale) {
2110: 		result = input ? OP::POWERS_OF_TEN[scale] : 0;
2111: 		return true;
2112: 	} else {
2113: 		return TryCast::Operation<bool, T>(input, result);
2114: 	}
2115: }
2116: 
2117: template <>
2118: bool TryCastToDecimal::Operation(bool input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
2119: 	return TryCastBoolToDecimal<int16_t>(input, result, error_message, width, scale);
2120: }
2121: 
2122: template <>
2123: bool TryCastToDecimal::Operation(bool input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
2124: 	return TryCastBoolToDecimal<int32_t>(input, result, error_message, width, scale);
2125: }
2126: 
2127: template <>
2128: bool TryCastToDecimal::Operation(bool input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
2129: 	return TryCastBoolToDecimal<int64_t>(input, result, error_message, width, scale);
2130: }
2131: 
2132: template <>
2133: bool TryCastToDecimal::Operation(bool input, hugeint_t &result, string *error_message, uint8_t width, uint8_t scale) {
2134: 	return TryCastBoolToDecimal<hugeint_t, Hugeint>(input, result, error_message, width, scale);
2135: }
2136: 
2137: template <>
2138: bool TryCastFromDecimal::Operation(int16_t input, bool &result, string *error_message, uint8_t width, uint8_t scale) {
2139: 	return TryCast::Operation<int16_t, bool>(input, result);
2140: }
2141: 
2142: template <>
2143: bool TryCastFromDecimal::Operation(int32_t input, bool &result, string *error_message, uint8_t width, uint8_t scale) {
2144: 	return TryCast::Operation<int32_t, bool>(input, result);
2145: }
2146: 
2147: template <>
2148: bool TryCastFromDecimal::Operation(int64_t input, bool &result, string *error_message, uint8_t width, uint8_t scale) {
2149: 	return TryCast::Operation<int64_t, bool>(input, result);
2150: }
2151: 
2152: template <>
2153: bool TryCastFromDecimal::Operation(hugeint_t input, bool &result, string *error_message, uint8_t width, uint8_t scale) {
2154: 	return TryCast::Operation<hugeint_t, bool>(input, result);
2155: }
2156: 
2157: //===--------------------------------------------------------------------===//
2158: // Numeric -> Decimal Cast
2159: //===--------------------------------------------------------------------===//
2160: struct SignedToDecimalOperator {
2161: 	template <class SRC, class DST>
2162: 	static bool Operation(SRC input, DST max_width) {
2163: 		return int64_t(input) >= int64_t(max_width) || int64_t(input) <= int64_t(-max_width);
2164: 	}
2165: };
2166: 
2167: struct UnsignedToDecimalOperator {
2168: 	template <class SRC, class DST>
2169: 	static bool Operation(SRC input, DST max_width) {
2170: 		return uint64_t(input) >= uint64_t(max_width);
2171: 	}
2172: };
2173: 
2174: template <class SRC, class DST, class OP = SignedToDecimalOperator>
2175: bool StandardNumericToDecimalCast(SRC input, DST &result, string *error_message, uint8_t width, uint8_t scale) {
2176: 	// check for overflow
2177: 	DST max_width = NumericHelper::POWERS_OF_TEN[width - scale];
2178: 	if (OP::template Operation<SRC, DST>(input, max_width)) {
2179: 		string error = StringUtil::Format("Could not cast value %d to DECIMAL(%d,%d)", input, width, scale);
2180: 		HandleCastError::AssignError(error, error_message);
2181: 		return false;
2182: 	}
2183: 	result = DST(input) * NumericHelper::POWERS_OF_TEN[scale];
2184: 	return true;
2185: }
2186: 
2187: template <class SRC>
2188: bool NumericToHugeDecimalCast(SRC input, hugeint_t &result, string *error_message, uint8_t width, uint8_t scale) {
2189: 	// check for overflow
2190: 	hugeint_t max_width = Hugeint::POWERS_OF_TEN[width - scale];
2191: 	hugeint_t hinput = Hugeint::Convert(input);
2192: 	if (hinput >= max_width || hinput <= -max_width) {
2193: 		string error = StringUtil::Format("Could not cast value %s to DECIMAL(%d,%d)", hinput.ToString(), width, scale);
2194: 		HandleCastError::AssignError(error, error_message);
2195: 		return false;
2196: 	}
2197: 	result = hinput * Hugeint::POWERS_OF_TEN[scale];
2198: 	return true;
2199: }
2200: 
2201: //===--------------------------------------------------------------------===//
2202: // Cast int8_t -> Decimal
2203: //===--------------------------------------------------------------------===//
2204: template <>
2205: bool TryCastToDecimal::Operation(int8_t input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
2206: 	return StandardNumericToDecimalCast<int8_t, int16_t>(input, result, error_message, width, scale);
2207: }
2208: template <>
2209: bool TryCastToDecimal::Operation(int8_t input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
2210: 	return StandardNumericToDecimalCast<int8_t, int32_t>(input, result, error_message, width, scale);
2211: }
2212: template <>
2213: bool TryCastToDecimal::Operation(int8_t input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
2214: 	return StandardNumericToDecimalCast<int8_t, int64_t>(input, result, error_message, width, scale);
2215: }
2216: template <>
2217: bool TryCastToDecimal::Operation(int8_t input, hugeint_t &result, string *error_message, uint8_t width, uint8_t scale) {
2218: 	return NumericToHugeDecimalCast<int8_t>(input, result, error_message, width, scale);
2219: }
2220: 
2221: //===--------------------------------------------------------------------===//
2222: // Cast int16_t -> Decimal
2223: //===--------------------------------------------------------------------===//
2224: template <>
2225: bool TryCastToDecimal::Operation(int16_t input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
2226: 	return StandardNumericToDecimalCast<int16_t, int16_t>(input, result, error_message, width, scale);
2227: }
2228: template <>
2229: bool TryCastToDecimal::Operation(int16_t input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
2230: 	return StandardNumericToDecimalCast<int16_t, int32_t>(input, result, error_message, width, scale);
2231: }
2232: template <>
2233: bool TryCastToDecimal::Operation(int16_t input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
2234: 	return StandardNumericToDecimalCast<int16_t, int64_t>(input, result, error_message, width, scale);
2235: }
2236: template <>
2237: bool TryCastToDecimal::Operation(int16_t input, hugeint_t &result, string *error_message, uint8_t width,
2238:                                  uint8_t scale) {
2239: 	return NumericToHugeDecimalCast<int16_t>(input, result, error_message, width, scale);
2240: }
2241: 
2242: //===--------------------------------------------------------------------===//
2243: // Cast int32_t -> Decimal
2244: //===--------------------------------------------------------------------===//
2245: template <>
2246: bool TryCastToDecimal::Operation(int32_t input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
2247: 	return StandardNumericToDecimalCast<int32_t, int16_t>(input, result, error_message, width, scale);
2248: }
2249: template <>
2250: bool TryCastToDecimal::Operation(int32_t input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
2251: 	return StandardNumericToDecimalCast<int32_t, int32_t>(input, result, error_message, width, scale);
2252: }
2253: template <>
2254: bool TryCastToDecimal::Operation(int32_t input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
2255: 	return StandardNumericToDecimalCast<int32_t, int64_t>(input, result, error_message, width, scale);
2256: }
2257: template <>
2258: bool TryCastToDecimal::Operation(int32_t input, hugeint_t &result, string *error_message, uint8_t width,
2259:                                  uint8_t scale) {
2260: 	return NumericToHugeDecimalCast<int32_t>(input, result, error_message, width, scale);
2261: }
2262: 
2263: //===--------------------------------------------------------------------===//
2264: // Cast int64_t -> Decimal
2265: //===--------------------------------------------------------------------===//
2266: template <>
2267: bool TryCastToDecimal::Operation(int64_t input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
2268: 	return StandardNumericToDecimalCast<int64_t, int16_t>(input, result, error_message, width, scale);
2269: }
2270: template <>
2271: bool TryCastToDecimal::Operation(int64_t input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
2272: 	return StandardNumericToDecimalCast<int64_t, int32_t>(input, result, error_message, width, scale);
2273: }
2274: template <>
2275: bool TryCastToDecimal::Operation(int64_t input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
2276: 	return StandardNumericToDecimalCast<int64_t, int64_t>(input, result, error_message, width, scale);
2277: }
2278: template <>
2279: bool TryCastToDecimal::Operation(int64_t input, hugeint_t &result, string *error_message, uint8_t width,
2280:                                  uint8_t scale) {
2281: 	return NumericToHugeDecimalCast<int64_t>(input, result, error_message, width, scale);
2282: }
2283: 
2284: //===--------------------------------------------------------------------===//
2285: // Cast uint8_t -> Decimal
2286: //===--------------------------------------------------------------------===//
2287: template <>
2288: bool TryCastToDecimal::Operation(uint8_t input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
2289: 	return StandardNumericToDecimalCast<uint8_t, int16_t, UnsignedToDecimalOperator>(input, result, error_message,
2290: 	                                                                                 width, scale);
2291: }
2292: template <>
2293: bool TryCastToDecimal::Operation(uint8_t input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
2294: 	return StandardNumericToDecimalCast<uint8_t, int32_t, UnsignedToDecimalOperator>(input, result, error_message,
2295: 	                                                                                 width, scale);
2296: }
2297: template <>
2298: bool TryCastToDecimal::Operation(uint8_t input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
2299: 	return StandardNumericToDecimalCast<uint8_t, int64_t, UnsignedToDecimalOperator>(input, result, error_message,
2300: 	                                                                                 width, scale);
2301: }
2302: template <>
2303: bool TryCastToDecimal::Operation(uint8_t input, hugeint_t &result, string *error_message, uint8_t width,
2304:                                  uint8_t scale) {
2305: 	return NumericToHugeDecimalCast<uint8_t>(input, result, error_message, width, scale);
2306: }
2307: 
2308: //===--------------------------------------------------------------------===//
2309: // Cast uint16_t -> Decimal
2310: //===--------------------------------------------------------------------===//
2311: template <>
2312: bool TryCastToDecimal::Operation(uint16_t input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
2313: 	return StandardNumericToDecimalCast<uint16_t, int16_t, UnsignedToDecimalOperator>(input, result, error_message,
2314: 	                                                                                  width, scale);
2315: }
2316: template <>
2317: bool TryCastToDecimal::Operation(uint16_t input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
2318: 	return StandardNumericToDecimalCast<uint16_t, int32_t, UnsignedToDecimalOperator>(input, result, error_message,
2319: 	                                                                                  width, scale);
2320: }
2321: template <>
2322: bool TryCastToDecimal::Operation(uint16_t input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
2323: 	return StandardNumericToDecimalCast<uint16_t, int64_t, UnsignedToDecimalOperator>(input, result, error_message,
2324: 	                                                                                  width, scale);
2325: }
2326: template <>
2327: bool TryCastToDecimal::Operation(uint16_t input, hugeint_t &result, string *error_message, uint8_t width,
2328:                                  uint8_t scale) {
2329: 	return NumericToHugeDecimalCast<uint16_t>(input, result, error_message, width, scale);
2330: }
2331: 
2332: //===--------------------------------------------------------------------===//
2333: // Cast uint32_t -> Decimal
2334: //===--------------------------------------------------------------------===//
2335: template <>
2336: bool TryCastToDecimal::Operation(uint32_t input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
2337: 	return StandardNumericToDecimalCast<uint32_t, int16_t, UnsignedToDecimalOperator>(input, result, error_message,
2338: 	                                                                                  width, scale);
2339: }
2340: template <>
2341: bool TryCastToDecimal::Operation(uint32_t input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
2342: 	return StandardNumericToDecimalCast<uint32_t, int32_t, UnsignedToDecimalOperator>(input, result, error_message,
2343: 	                                                                                  width, scale);
2344: }
2345: template <>
2346: bool TryCastToDecimal::Operation(uint32_t input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
2347: 	return StandardNumericToDecimalCast<uint32_t, int64_t, UnsignedToDecimalOperator>(input, result, error_message,
2348: 	                                                                                  width, scale);
2349: }
2350: template <>
2351: bool TryCastToDecimal::Operation(uint32_t input, hugeint_t &result, string *error_message, uint8_t width,
2352:                                  uint8_t scale) {
2353: 	return NumericToHugeDecimalCast<uint32_t>(input, result, error_message, width, scale);
2354: }
2355: 
2356: //===--------------------------------------------------------------------===//
2357: // Cast uint64_t -> Decimal
2358: //===--------------------------------------------------------------------===//
2359: template <>
2360: bool TryCastToDecimal::Operation(uint64_t input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
2361: 	return StandardNumericToDecimalCast<uint64_t, int16_t, UnsignedToDecimalOperator>(input, result, error_message,
2362: 	                                                                                  width, scale);
2363: }
2364: template <>
2365: bool TryCastToDecimal::Operation(uint64_t input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
2366: 	return StandardNumericToDecimalCast<uint64_t, int32_t, UnsignedToDecimalOperator>(input, result, error_message,
2367: 	                                                                                  width, scale);
2368: }
2369: template <>
2370: bool TryCastToDecimal::Operation(uint64_t input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
2371: 	return StandardNumericToDecimalCast<uint64_t, int64_t, UnsignedToDecimalOperator>(input, result, error_message,
2372: 	                                                                                  width, scale);
2373: }
2374: template <>
2375: bool TryCastToDecimal::Operation(uint64_t input, hugeint_t &result, string *error_message, uint8_t width,
2376:                                  uint8_t scale) {
2377: 	return NumericToHugeDecimalCast<uint64_t>(input, result, error_message, width, scale);
2378: }
2379: 
2380: //===--------------------------------------------------------------------===//
2381: // Hugeint -> Decimal Cast
2382: //===--------------------------------------------------------------------===//
2383: template <class DST>
2384: bool HugeintToDecimalCast(hugeint_t input, DST &result, string *error_message, uint8_t width, uint8_t scale) {
2385: 	// check for overflow
2386: 	hugeint_t max_width = Hugeint::POWERS_OF_TEN[width - scale];
2387: 	if (input >= max_width || input <= -max_width) {
2388: 		string error = StringUtil::Format("Could not cast value %s to DECIMAL(%d,%d)", input.ToString(), width, scale);
2389: 		HandleCastError::AssignError(error, error_message);
2390: 		return false;
2391: 	}
2392: 	result = Hugeint::Cast<DST>(input * Hugeint::POWERS_OF_TEN[scale]);
2393: 	return true;
2394: }
2395: 
2396: template <>
2397: bool TryCastToDecimal::Operation(hugeint_t input, int16_t &result, string *error_message, uint8_t width,
2398:                                  uint8_t scale) {
2399: 	return HugeintToDecimalCast<int16_t>(input, result, error_message, width, scale);
2400: }
2401: 
2402: template <>
2403: bool TryCastToDecimal::Operation(hugeint_t input, int32_t &result, string *error_message, uint8_t width,
2404:                                  uint8_t scale) {
2405: 	return HugeintToDecimalCast<int32_t>(input, result, error_message, width, scale);
2406: }
2407: 
2408: template <>
2409: bool TryCastToDecimal::Operation(hugeint_t input, int64_t &result, string *error_message, uint8_t width,
2410:                                  uint8_t scale) {
2411: 	return HugeintToDecimalCast<int64_t>(input, result, error_message, width, scale);
2412: }
2413: 
2414: template <>
2415: bool TryCastToDecimal::Operation(hugeint_t input, hugeint_t &result, string *error_message, uint8_t width,
2416:                                  uint8_t scale) {
2417: 	return HugeintToDecimalCast<hugeint_t>(input, result, error_message, width, scale);
2418: }
2419: 
2420: //===--------------------------------------------------------------------===//
2421: // Float/Double -> Decimal Cast
2422: //===--------------------------------------------------------------------===//
2423: template <class SRC, class DST>
2424: bool DoubleToDecimalCast(SRC input, DST &result, string *error_message, uint8_t width, uint8_t scale) {
2425: 	double value = input * NumericHelper::DOUBLE_POWERS_OF_TEN[scale];
2426: 	// Add the sign (-1, 0, 1) times a tiny value to fix floating point issues (issue 3091)
2427: 	double sign = (double(0) < value) - (value < double(0));
2428: 	value += 1e-9 * sign;
2429: 	if (value <= -NumericHelper::DOUBLE_POWERS_OF_TEN[width] || value >= NumericHelper::DOUBLE_POWERS_OF_TEN[width]) {
2430: 		string error = StringUtil::Format("Could not cast value %f to DECIMAL(%d,%d)", value, width, scale);
2431: 		HandleCastError::AssignError(error, error_message);
2432: 		return false;
2433: 	}
2434: 	result = Cast::Operation<SRC, DST>(value);
2435: 	return true;
2436: }
2437: 
2438: template <>
2439: bool TryCastToDecimal::Operation(float input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
2440: 	return DoubleToDecimalCast<float, int16_t>(input, result, error_message, width, scale);
2441: }
2442: 
2443: template <>
2444: bool TryCastToDecimal::Operation(float input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
2445: 	return DoubleToDecimalCast<float, int32_t>(input, result, error_message, width, scale);
2446: }
2447: 
2448: template <>
2449: bool TryCastToDecimal::Operation(float input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
2450: 	return DoubleToDecimalCast<float, int64_t>(input, result, error_message, width, scale);
2451: }
2452: 
2453: template <>
2454: bool TryCastToDecimal::Operation(float input, hugeint_t &result, string *error_message, uint8_t width, uint8_t scale) {
2455: 	return DoubleToDecimalCast<float, hugeint_t>(input, result, error_message, width, scale);
2456: }
2457: 
2458: template <>
2459: bool TryCastToDecimal::Operation(double input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
2460: 	return DoubleToDecimalCast<double, int16_t>(input, result, error_message, width, scale);
2461: }
2462: 
2463: template <>
2464: bool TryCastToDecimal::Operation(double input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
2465: 	return DoubleToDecimalCast<double, int32_t>(input, result, error_message, width, scale);
2466: }
2467: 
2468: template <>
2469: bool TryCastToDecimal::Operation(double input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
2470: 	return DoubleToDecimalCast<double, int64_t>(input, result, error_message, width, scale);
2471: }
2472: 
2473: template <>
2474: bool TryCastToDecimal::Operation(double input, hugeint_t &result, string *error_message, uint8_t width, uint8_t scale) {
2475: 	return DoubleToDecimalCast<double, hugeint_t>(input, result, error_message, width, scale);
2476: }
2477: 
2478: //===--------------------------------------------------------------------===//
2479: // Decimal -> Numeric Cast
2480: //===--------------------------------------------------------------------===//
2481: template <class SRC, class DST>
2482: bool TryCastDecimalToNumeric(SRC input, DST &result, string *error_message, uint8_t scale) {
2483: 	// Round away from 0.
2484: 	const auto power = NumericHelper::POWERS_OF_TEN[scale];
2485: 	// https://graphics.stanford.edu/~seander/bithacks.html#ConditionalNegate
2486: 	const auto fNegate = int64_t(input < 0);
2487: 	const auto rounding = ((power ^ -fNegate) + fNegate) / 2;
2488: 	const auto scaled_value = (input + rounding) / power;
2489: 	if (!TryCast::Operation<SRC, DST>(scaled_value, result)) {
2490: 		string error = StringUtil::Format("Failed to cast decimal value %d to type %s", scaled_value, GetTypeId<DST>());
2491: 		HandleCastError::AssignError(error, error_message);
2492: 		return false;
2493: 	}
2494: 	return true;
2495: }
2496: 
2497: template <class DST>
2498: bool TryCastHugeDecimalToNumeric(hugeint_t input, DST &result, string *error_message, uint8_t scale) {
2499: 	const auto power = Hugeint::POWERS_OF_TEN[scale];
2500: 	const auto rounding = ((input < 0) ? -power : power) / 2;
2501: 	auto scaled_value = (input + rounding) / power;
2502: 	if (!TryCast::Operation<hugeint_t, DST>(scaled_value, result)) {
2503: 		string error = StringUtil::Format("Failed to cast decimal value %s to type %s",
2504: 		                                  ConvertToString::Operation(scaled_value), GetTypeId<DST>());
2505: 		HandleCastError::AssignError(error, error_message);
2506: 		return false;
2507: 	}
2508: 	return true;
2509: }
2510: 
2511: //===--------------------------------------------------------------------===//
2512: // Cast Decimal -> int8_t
2513: //===--------------------------------------------------------------------===//
2514: template <>
2515: bool TryCastFromDecimal::Operation(int16_t input, int8_t &result, string *error_message, uint8_t width, uint8_t scale) {
2516: 	return TryCastDecimalToNumeric<int16_t, int8_t>(input, result, error_message, scale);
2517: }
2518: template <>
2519: bool TryCastFromDecimal::Operation(int32_t input, int8_t &result, string *error_message, uint8_t width, uint8_t scale) {
2520: 	return TryCastDecimalToNumeric<int32_t, int8_t>(input, result, error_message, scale);
2521: }
2522: template <>
2523: bool TryCastFromDecimal::Operation(int64_t input, int8_t &result, string *error_message, uint8_t width, uint8_t scale) {
2524: 	return TryCastDecimalToNumeric<int64_t, int8_t>(input, result, error_message, scale);
2525: }
2526: template <>
2527: bool TryCastFromDecimal::Operation(hugeint_t input, int8_t &result, string *error_message, uint8_t width,
2528:                                    uint8_t scale) {
2529: 	return TryCastHugeDecimalToNumeric<int8_t>(input, result, error_message, scale);
2530: }
2531: 
2532: //===--------------------------------------------------------------------===//
2533: // Cast Decimal -> int16_t
2534: //===--------------------------------------------------------------------===//
2535: template <>
2536: bool TryCastFromDecimal::Operation(int16_t input, int16_t &result, string *error_message, uint8_t width,
2537:                                    uint8_t scale) {
2538: 	return TryCastDecimalToNumeric<int16_t, int16_t>(input, result, error_message, scale);
2539: }
2540: template <>
2541: bool TryCastFromDecimal::Operation(int32_t input, int16_t &result, string *error_message, uint8_t width,
2542:                                    uint8_t scale) {
2543: 	return TryCastDecimalToNumeric<int32_t, int16_t>(input, result, error_message, scale);
2544: }
2545: template <>
2546: bool TryCastFromDecimal::Operation(int64_t input, int16_t &result, string *error_message, uint8_t width,
2547:                                    uint8_t scale) {
2548: 	return TryCastDecimalToNumeric<int64_t, int16_t>(input, result, error_message, scale);
2549: }
2550: template <>
2551: bool TryCastFromDecimal::Operation(hugeint_t input, int16_t &result, string *error_message, uint8_t width,
2552:                                    uint8_t scale) {
2553: 	return TryCastHugeDecimalToNumeric<int16_t>(input, result, error_message, scale);
2554: }
2555: 
2556: //===--------------------------------------------------------------------===//
2557: // Cast Decimal -> int32_t
2558: //===--------------------------------------------------------------------===//
2559: template <>
2560: bool TryCastFromDecimal::Operation(int16_t input, int32_t &result, string *error_message, uint8_t width,
2561:                                    uint8_t scale) {
2562: 	return TryCastDecimalToNumeric<int16_t, int32_t>(input, result, error_message, scale);
2563: }
2564: template <>
2565: bool TryCastFromDecimal::Operation(int32_t input, int32_t &result, string *error_message, uint8_t width,
2566:                                    uint8_t scale) {
2567: 	return TryCastDecimalToNumeric<int32_t, int32_t>(input, result, error_message, scale);
2568: }
2569: template <>
2570: bool TryCastFromDecimal::Operation(int64_t input, int32_t &result, string *error_message, uint8_t width,
2571:                                    uint8_t scale) {
2572: 	return TryCastDecimalToNumeric<int64_t, int32_t>(input, result, error_message, scale);
2573: }
2574: template <>
2575: bool TryCastFromDecimal::Operation(hugeint_t input, int32_t &result, string *error_message, uint8_t width,
2576:                                    uint8_t scale) {
2577: 	return TryCastHugeDecimalToNumeric<int32_t>(input, result, error_message, scale);
2578: }
2579: 
2580: //===--------------------------------------------------------------------===//
2581: // Cast Decimal -> int64_t
2582: //===--------------------------------------------------------------------===//
2583: template <>
2584: bool TryCastFromDecimal::Operation(int16_t input, int64_t &result, string *error_message, uint8_t width,
2585:                                    uint8_t scale) {
2586: 	return TryCastDecimalToNumeric<int16_t, int64_t>(input, result, error_message, scale);
2587: }
2588: template <>
2589: bool TryCastFromDecimal::Operation(int32_t input, int64_t &result, string *error_message, uint8_t width,
2590:                                    uint8_t scale) {
2591: 	return TryCastDecimalToNumeric<int32_t, int64_t>(input, result, error_message, scale);
2592: }
2593: template <>
2594: bool TryCastFromDecimal::Operation(int64_t input, int64_t &result, string *error_message, uint8_t width,
2595:                                    uint8_t scale) {
2596: 	return TryCastDecimalToNumeric<int64_t, int64_t>(input, result, error_message, scale);
2597: }
2598: template <>
2599: bool TryCastFromDecimal::Operation(hugeint_t input, int64_t &result, string *error_message, uint8_t width,
2600:                                    uint8_t scale) {
2601: 	return TryCastHugeDecimalToNumeric<int64_t>(input, result, error_message, scale);
2602: }
2603: 
2604: //===--------------------------------------------------------------------===//
2605: // Cast Decimal -> uint8_t
2606: //===--------------------------------------------------------------------===//
2607: template <>
2608: bool TryCastFromDecimal::Operation(int16_t input, uint8_t &result, string *error_message, uint8_t width,
2609:                                    uint8_t scale) {
2610: 	return TryCastDecimalToNumeric<int16_t, uint8_t>(input, result, error_message, scale);
2611: }
2612: template <>
2613: bool TryCastFromDecimal::Operation(int32_t input, uint8_t &result, string *error_message, uint8_t width,
2614:                                    uint8_t scale) {
2615: 	return TryCastDecimalToNumeric<int32_t, uint8_t>(input, result, error_message, scale);
2616: }
2617: template <>
2618: bool TryCastFromDecimal::Operation(int64_t input, uint8_t &result, string *error_message, uint8_t width,
2619:                                    uint8_t scale) {
2620: 	return TryCastDecimalToNumeric<int64_t, uint8_t>(input, result, error_message, scale);
2621: }
2622: template <>
2623: bool TryCastFromDecimal::Operation(hugeint_t input, uint8_t &result, string *error_message, uint8_t width,
2624:                                    uint8_t scale) {
2625: 	return TryCastHugeDecimalToNumeric<uint8_t>(input, result, error_message, scale);
2626: }
2627: 
2628: //===--------------------------------------------------------------------===//
2629: // Cast Decimal -> uint16_t
2630: //===--------------------------------------------------------------------===//
2631: template <>
2632: bool TryCastFromDecimal::Operation(int16_t input, uint16_t &result, string *error_message, uint8_t width,
2633:                                    uint8_t scale) {
2634: 	return TryCastDecimalToNumeric<int16_t, uint16_t>(input, result, error_message, scale);
2635: }
2636: template <>
2637: bool TryCastFromDecimal::Operation(int32_t input, uint16_t &result, string *error_message, uint8_t width,
2638:                                    uint8_t scale) {
2639: 	return TryCastDecimalToNumeric<int32_t, uint16_t>(input, result, error_message, scale);
2640: }
2641: template <>
2642: bool TryCastFromDecimal::Operation(int64_t input, uint16_t &result, string *error_message, uint8_t width,
2643:                                    uint8_t scale) {
2644: 	return TryCastDecimalToNumeric<int64_t, uint16_t>(input, result, error_message, scale);
2645: }
2646: template <>
2647: bool TryCastFromDecimal::Operation(hugeint_t input, uint16_t &result, string *error_message, uint8_t width,
2648:                                    uint8_t scale) {
2649: 	return TryCastHugeDecimalToNumeric<uint16_t>(input, result, error_message, scale);
2650: }
2651: 
2652: //===--------------------------------------------------------------------===//
2653: // Cast Decimal -> uint32_t
2654: //===--------------------------------------------------------------------===//
2655: template <>
2656: bool TryCastFromDecimal::Operation(int16_t input, uint32_t &result, string *error_message, uint8_t width,
2657:                                    uint8_t scale) {
2658: 	return TryCastDecimalToNumeric<int16_t, uint32_t>(input, result, error_message, scale);
2659: }
2660: template <>
2661: bool TryCastFromDecimal::Operation(int32_t input, uint32_t &result, string *error_message, uint8_t width,
2662:                                    uint8_t scale) {
2663: 	return TryCastDecimalToNumeric<int32_t, uint32_t>(input, result, error_message, scale);
2664: }
2665: template <>
2666: bool TryCastFromDecimal::Operation(int64_t input, uint32_t &result, string *error_message, uint8_t width,
2667:                                    uint8_t scale) {
2668: 	return TryCastDecimalToNumeric<int64_t, uint32_t>(input, result, error_message, scale);
2669: }
2670: template <>
2671: bool TryCastFromDecimal::Operation(hugeint_t input, uint32_t &result, string *error_message, uint8_t width,
2672:                                    uint8_t scale) {
2673: 	return TryCastHugeDecimalToNumeric<uint32_t>(input, result, error_message, scale);
2674: }
2675: 
2676: //===--------------------------------------------------------------------===//
2677: // Cast Decimal -> uint64_t
2678: //===--------------------------------------------------------------------===//
2679: template <>
2680: bool TryCastFromDecimal::Operation(int16_t input, uint64_t &result, string *error_message, uint8_t width,
2681:                                    uint8_t scale) {
2682: 	return TryCastDecimalToNumeric<int16_t, uint64_t>(input, result, error_message, scale);
2683: }
2684: template <>
2685: bool TryCastFromDecimal::Operation(int32_t input, uint64_t &result, string *error_message, uint8_t width,
2686:                                    uint8_t scale) {
2687: 	return TryCastDecimalToNumeric<int32_t, uint64_t>(input, result, error_message, scale);
2688: }
2689: template <>
2690: bool TryCastFromDecimal::Operation(int64_t input, uint64_t &result, string *error_message, uint8_t width,
2691:                                    uint8_t scale) {
2692: 	return TryCastDecimalToNumeric<int64_t, uint64_t>(input, result, error_message, scale);
2693: }
2694: template <>
2695: bool TryCastFromDecimal::Operation(hugeint_t input, uint64_t &result, string *error_message, uint8_t width,
2696:                                    uint8_t scale) {
2697: 	return TryCastHugeDecimalToNumeric<uint64_t>(input, result, error_message, scale);
2698: }
2699: 
2700: //===--------------------------------------------------------------------===//
2701: // Cast Decimal -> hugeint_t
2702: //===--------------------------------------------------------------------===//
2703: template <>
2704: bool TryCastFromDecimal::Operation(int16_t input, hugeint_t &result, string *error_message, uint8_t width,
2705:                                    uint8_t scale) {
2706: 	return TryCastDecimalToNumeric<int16_t, hugeint_t>(input, result, error_message, scale);
2707: }
2708: template <>
2709: bool TryCastFromDecimal::Operation(int32_t input, hugeint_t &result, string *error_message, uint8_t width,
2710:                                    uint8_t scale) {
2711: 	return TryCastDecimalToNumeric<int32_t, hugeint_t>(input, result, error_message, scale);
2712: }
2713: template <>
2714: bool TryCastFromDecimal::Operation(int64_t input, hugeint_t &result, string *error_message, uint8_t width,
2715:                                    uint8_t scale) {
2716: 	return TryCastDecimalToNumeric<int64_t, hugeint_t>(input, result, error_message, scale);
2717: }
2718: template <>
2719: bool TryCastFromDecimal::Operation(hugeint_t input, hugeint_t &result, string *error_message, uint8_t width,
2720:                                    uint8_t scale) {
2721: 	return TryCastHugeDecimalToNumeric<hugeint_t>(input, result, error_message, scale);
2722: }
2723: 
2724: //===--------------------------------------------------------------------===//
2725: // Decimal -> Float/Double Cast
2726: //===--------------------------------------------------------------------===//
2727: template <class SRC, class DST>
2728: bool TryCastDecimalToFloatingPoint(SRC input, DST &result, uint8_t scale) {
2729: 	result = Cast::Operation<SRC, DST>(input) / DST(NumericHelper::DOUBLE_POWERS_OF_TEN[scale]);
2730: 	return true;
2731: }
2732: 
2733: // DECIMAL -> FLOAT
2734: template <>
2735: bool TryCastFromDecimal::Operation(int16_t input, float &result, string *error_message, uint8_t width, uint8_t scale) {
2736: 	return TryCastDecimalToFloatingPoint<int16_t, float>(input, result, scale);
2737: }
2738: 
2739: template <>
2740: bool TryCastFromDecimal::Operation(int32_t input, float &result, string *error_message, uint8_t width, uint8_t scale) {
2741: 	return TryCastDecimalToFloatingPoint<int32_t, float>(input, result, scale);
2742: }
2743: 
2744: template <>
2745: bool TryCastFromDecimal::Operation(int64_t input, float &result, string *error_message, uint8_t width, uint8_t scale) {
2746: 	return TryCastDecimalToFloatingPoint<int64_t, float>(input, result, scale);
2747: }
2748: 
2749: template <>
2750: bool TryCastFromDecimal::Operation(hugeint_t input, float &result, string *error_message, uint8_t width,
2751:                                    uint8_t scale) {
2752: 	return TryCastDecimalToFloatingPoint<hugeint_t, float>(input, result, scale);
2753: }
2754: 
2755: // DECIMAL -> DOUBLE
2756: template <>
2757: bool TryCastFromDecimal::Operation(int16_t input, double &result, string *error_message, uint8_t width, uint8_t scale) {
2758: 	return TryCastDecimalToFloatingPoint<int16_t, double>(input, result, scale);
2759: }
2760: 
2761: template <>
2762: bool TryCastFromDecimal::Operation(int32_t input, double &result, string *error_message, uint8_t width, uint8_t scale) {
2763: 	return TryCastDecimalToFloatingPoint<int32_t, double>(input, result, scale);
2764: }
2765: 
2766: template <>
2767: bool TryCastFromDecimal::Operation(int64_t input, double &result, string *error_message, uint8_t width, uint8_t scale) {
2768: 	return TryCastDecimalToFloatingPoint<int64_t, double>(input, result, scale);
2769: }
2770: 
2771: template <>
2772: bool TryCastFromDecimal::Operation(hugeint_t input, double &result, string *error_message, uint8_t width,
2773:                                    uint8_t scale) {
2774: 	return TryCastDecimalToFloatingPoint<hugeint_t, double>(input, result, scale);
2775: }
2776: 
2777: } // namespace duckdb
[end of src/common/operator/cast_operators.cpp]
[start of src/function/cast/time_casts.cpp]
1: #include "duckdb/function/cast/default_casts.hpp"
2: #include "duckdb/function/cast/vector_cast_helpers.hpp"
3: #include "duckdb/common/operator/string_cast.hpp"
4: namespace duckdb {
5: 
6: BoundCastInfo DefaultCasts::DateCastSwitch(BindCastInput &input, const LogicalType &source, const LogicalType &target) {
7: 	// now switch on the result type
8: 	switch (target.id()) {
9: 	case LogicalTypeId::VARCHAR:
10: 		// date to varchar
11: 		return BoundCastInfo(&VectorCastHelpers::StringCast<date_t, duckdb::StringCast>);
12: 	case LogicalTypeId::TIMESTAMP:
13: 	case LogicalTypeId::TIMESTAMP_TZ:
14: 		// date to timestamp
15: 		return BoundCastInfo(&VectorCastHelpers::TryCastLoop<date_t, timestamp_t, duckdb::TryCast>);
16: 	case LogicalTypeId::TIMESTAMP_NS:
17: 		return BoundCastInfo(&VectorCastHelpers::TryCastLoop<date_t, timestamp_t, duckdb::TryCastToTimestampNS>);
18: 	case LogicalTypeId::TIMESTAMP_SEC:
19: 		return BoundCastInfo(&VectorCastHelpers::TryCastLoop<date_t, timestamp_t, duckdb::TryCastToTimestampSec>);
20: 	case LogicalTypeId::TIMESTAMP_MS:
21: 		return BoundCastInfo(&VectorCastHelpers::TryCastLoop<date_t, timestamp_t, duckdb::TryCastToTimestampMS>);
22: 	default:
23: 		return TryVectorNullCast;
24: 	}
25: }
26: 
27: BoundCastInfo DefaultCasts::TimeCastSwitch(BindCastInput &input, const LogicalType &source, const LogicalType &target) {
28: 	// now switch on the result type
29: 	switch (target.id()) {
30: 	case LogicalTypeId::VARCHAR:
31: 		// time to varchar
32: 		return BoundCastInfo(&VectorCastHelpers::StringCast<dtime_t, duckdb::StringCast>);
33: 	case LogicalTypeId::TIME_TZ:
34: 		// time to time with time zone
35: 		return BoundCastInfo(&VectorCastHelpers::TemplatedCastLoop<dtime_t, dtime_tz_t, duckdb::Cast>);
36: 	default:
37: 		return TryVectorNullCast;
38: 	}
39: }
40: 
41: BoundCastInfo DefaultCasts::TimeTzCastSwitch(BindCastInput &input, const LogicalType &source,
42:                                              const LogicalType &target) {
43: 	// now switch on the result type
44: 	switch (target.id()) {
45: 	case LogicalTypeId::VARCHAR:
46: 		// time with time zone to varchar
47: 		return BoundCastInfo(&VectorCastHelpers::StringCast<dtime_tz_t, duckdb::StringCastTZ>);
48: 	case LogicalTypeId::TIME:
49: 		// time with time zone to time
50: 		return BoundCastInfo(&VectorCastHelpers::TemplatedCastLoop<dtime_tz_t, dtime_t, duckdb::Cast>);
51: 	default:
52: 		return TryVectorNullCast;
53: 	}
54: }
55: 
56: BoundCastInfo DefaultCasts::TimestampCastSwitch(BindCastInput &input, const LogicalType &source,
57:                                                 const LogicalType &target) {
58: 	// now switch on the result type
59: 	switch (target.id()) {
60: 	case LogicalTypeId::VARCHAR:
61: 		// timestamp to varchar
62: 		return BoundCastInfo(&VectorCastHelpers::StringCast<timestamp_t, duckdb::StringCast>);
63: 	case LogicalTypeId::DATE:
64: 		// timestamp to date
65: 		return BoundCastInfo(&VectorCastHelpers::TemplatedCastLoop<timestamp_t, date_t, duckdb::Cast>);
66: 	case LogicalTypeId::TIME:
67: 		// timestamp to time
68: 		return BoundCastInfo(&VectorCastHelpers::TemplatedCastLoop<timestamp_t, dtime_t, duckdb::Cast>);
69: 	case LogicalTypeId::TIME_TZ:
70: 		// timestamp to time_tz
71: 		return BoundCastInfo(&VectorCastHelpers::TemplatedCastLoop<timestamp_t, dtime_tz_t, duckdb::Cast>);
72: 	case LogicalTypeId::TIMESTAMP_TZ:
73: 		// timestamp (us) to timestamp with time zone
74: 		return ReinterpretCast;
75: 	case LogicalTypeId::TIMESTAMP_NS:
76: 		// timestamp (us) to timestamp (ns)
77: 		return BoundCastInfo(
78: 		    &VectorCastHelpers::TemplatedCastLoop<timestamp_t, timestamp_t, duckdb::CastTimestampUsToNs>);
79: 	case LogicalTypeId::TIMESTAMP_MS:
80: 		// timestamp (us) to timestamp (ms)
81: 		return BoundCastInfo(
82: 		    &VectorCastHelpers::TemplatedCastLoop<timestamp_t, timestamp_t, duckdb::CastTimestampUsToMs>);
83: 	case LogicalTypeId::TIMESTAMP_SEC:
84: 		// timestamp (us) to timestamp (s)
85: 		return BoundCastInfo(
86: 		    &VectorCastHelpers::TemplatedCastLoop<timestamp_t, timestamp_t, duckdb::CastTimestampUsToSec>);
87: 	default:
88: 		return TryVectorNullCast;
89: 	}
90: }
91: 
92: BoundCastInfo DefaultCasts::TimestampTzCastSwitch(BindCastInput &input, const LogicalType &source,
93:                                                   const LogicalType &target) {
94: 	// now switch on the result type
95: 	switch (target.id()) {
96: 	case LogicalTypeId::VARCHAR:
97: 		// timestamp with time zone to varchar
98: 		return BoundCastInfo(&VectorCastHelpers::StringCast<timestamp_t, duckdb::StringCastTZ>);
99: 	case LogicalTypeId::TIME_TZ:
100: 		// timestamp with time zone to time with time zone.
101: 		return BoundCastInfo(&VectorCastHelpers::TemplatedCastLoop<timestamp_t, dtime_tz_t, duckdb::Cast>);
102: 	case LogicalTypeId::TIMESTAMP:
103: 		// timestamp with time zone to timestamp (us)
104: 		return ReinterpretCast;
105: 	default:
106: 		return TryVectorNullCast;
107: 	}
108: }
109: 
110: BoundCastInfo DefaultCasts::TimestampNsCastSwitch(BindCastInput &input, const LogicalType &source,
111:                                                   const LogicalType &target) {
112: 	// now switch on the result type
113: 	switch (target.id()) {
114: 	case LogicalTypeId::VARCHAR:
115: 		// timestamp (ns) to varchar
116: 		return BoundCastInfo(&VectorCastHelpers::StringCast<timestamp_t, duckdb::CastFromTimestampNS>);
117: 	case LogicalTypeId::TIMESTAMP:
118: 		// timestamp (ns) to timestamp (us)
119: 		return BoundCastInfo(
120: 		    &VectorCastHelpers::TemplatedCastLoop<timestamp_t, timestamp_t, duckdb::CastTimestampNsToUs>);
121: 	default:
122: 		return TryVectorNullCast;
123: 	}
124: }
125: 
126: BoundCastInfo DefaultCasts::TimestampMsCastSwitch(BindCastInput &input, const LogicalType &source,
127:                                                   const LogicalType &target) {
128: 	// now switch on the result type
129: 	switch (target.id()) {
130: 	case LogicalTypeId::VARCHAR:
131: 		// timestamp (ms) to varchar
132: 		return BoundCastInfo(&VectorCastHelpers::StringCast<timestamp_t, duckdb::CastFromTimestampMS>);
133: 	case LogicalTypeId::TIMESTAMP:
134: 		// timestamp (ms) to timestamp (us)
135: 		return BoundCastInfo(
136: 		    &VectorCastHelpers::TemplatedCastLoop<timestamp_t, timestamp_t, duckdb::CastTimestampMsToUs>);
137: 	case LogicalTypeId::TIMESTAMP_NS:
138: 		// timestamp (ms) to timestamp (ns)
139: 		return BoundCastInfo(
140: 		    &VectorCastHelpers::TemplatedCastLoop<timestamp_t, timestamp_t, duckdb::CastTimestampMsToNs>);
141: 	default:
142: 		return TryVectorNullCast;
143: 	}
144: }
145: 
146: BoundCastInfo DefaultCasts::TimestampSecCastSwitch(BindCastInput &input, const LogicalType &source,
147:                                                    const LogicalType &target) {
148: 	// now switch on the result type
149: 	switch (target.id()) {
150: 	case LogicalTypeId::VARCHAR:
151: 		// timestamp (sec) to varchar
152: 		return BoundCastInfo(&VectorCastHelpers::StringCast<timestamp_t, duckdb::CastFromTimestampSec>);
153: 	case LogicalTypeId::TIMESTAMP_MS:
154: 		// timestamp (s) to timestamp (ms)
155: 		return BoundCastInfo(
156: 		    &VectorCastHelpers::TemplatedCastLoop<timestamp_t, timestamp_t, duckdb::CastTimestampSecToMs>);
157: 	case LogicalTypeId::TIMESTAMP:
158: 		// timestamp (s) to timestamp (us)
159: 		return BoundCastInfo(
160: 		    &VectorCastHelpers::TemplatedCastLoop<timestamp_t, timestamp_t, duckdb::CastTimestampSecToUs>);
161: 	case LogicalTypeId::TIMESTAMP_NS:
162: 		// timestamp (s) to timestamp (ns)
163: 		return BoundCastInfo(
164: 		    &VectorCastHelpers::TemplatedCastLoop<timestamp_t, timestamp_t, duckdb::CastTimestampSecToNs>);
165: 	default:
166: 		return TryVectorNullCast;
167: 	}
168: }
169: BoundCastInfo DefaultCasts::IntervalCastSwitch(BindCastInput &input, const LogicalType &source,
170:                                                const LogicalType &target) {
171: 	// now switch on the result type
172: 	switch (target.id()) {
173: 	case LogicalTypeId::VARCHAR:
174: 		// time to varchar
175: 		return BoundCastInfo(&VectorCastHelpers::StringCast<interval_t, duckdb::StringCast>);
176: 	default:
177: 		return TryVectorNullCast;
178: 	}
179: }
180: 
181: } // namespace duckdb
[end of src/function/cast/time_casts.cpp]
[start of src/include/duckdb/common/operator/cast_operators.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/operator/cast_operators.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/assert.hpp"
12: #include "duckdb/common/constants.hpp"
13: #include "duckdb/common/hugeint.hpp"
14: #include "duckdb/common/limits.hpp"
15: #include "duckdb/common/exception.hpp"
16: #include "duckdb/common/typedefs.hpp"
17: #include "duckdb/common/types/string_type.hpp"
18: #include "duckdb/common/types.hpp"
19: #include "duckdb/common/operator/convert_to_string.hpp"
20: #include "duckdb/common/types/null_value.hpp"
21: #include "duckdb/common/types/bit.hpp"
22: #include "duckdb/common/types/vector.hpp"
23: 
24: namespace duckdb {
25: struct ValidityMask;
26: class Vector;
27: 
28: struct TryCast {
29: 	template <class SRC, class DST>
30: 	static inline bool Operation(SRC input, DST &result, bool strict = false) {
31: 		throw NotImplementedException("Unimplemented type for cast (%s -> %s)", GetTypeId<SRC>(), GetTypeId<DST>());
32: 	}
33: };
34: 
35: struct TryCastErrorMessage {
36: 	template <class SRC, class DST>
37: 	static inline bool Operation(SRC input, DST &result, string *error_message, bool strict = false) {
38: 		throw NotImplementedException("Unimplemented type for cast (%s -> %s)", GetTypeId<SRC>(), GetTypeId<DST>());
39: 	}
40: };
41: 
42: struct TryCastErrorMessageCommaSeparated {
43: 	template <class SRC, class DST>
44: 	static inline bool Operation(SRC input, DST &result, string *error_message, bool strict = false) {
45: 		throw NotImplementedException("Unimplemented type for cast (%s -> %s)", GetTypeId<SRC>(), GetTypeId<DST>());
46: 	}
47: };
48: 
49: template <class SRC, class DST>
50: static string CastExceptionText(SRC input) {
51: 	if (std::is_same<SRC, string_t>()) {
52: 		return "Could not convert string '" + ConvertToString::Operation<SRC>(input) + "' to " +
53: 		       TypeIdToString(GetTypeId<DST>());
54: 	}
55: 	if (TypeIsNumber<SRC>() && TypeIsNumber<DST>()) {
56: 		return "Type " + TypeIdToString(GetTypeId<SRC>()) + " with value " + ConvertToString::Operation<SRC>(input) +
57: 		       " can't be cast because the value is out of range for the destination type " +
58: 		       TypeIdToString(GetTypeId<DST>());
59: 	}
60: 	return "Type " + TypeIdToString(GetTypeId<SRC>()) + " with value " + ConvertToString::Operation<SRC>(input) +
61: 	       " can't be cast to the destination type " + TypeIdToString(GetTypeId<DST>());
62: }
63: 
64: struct Cast {
65: 	template <class SRC, class DST>
66: 	static inline DST Operation(SRC input) {
67: 		DST result;
68: 		if (!TryCast::Operation(input, result)) {
69: 			throw InvalidInputException(CastExceptionText<SRC, DST>(input));
70: 		}
71: 		return result;
72: 	}
73: };
74: 
75: struct HandleCastError {
76: 	static void AssignError(const string &error_message, string *error_message_ptr) {
77: 		if (!error_message_ptr) {
78: 			throw ConversionException(error_message);
79: 		}
80: 		if (error_message_ptr->empty()) {
81: 			*error_message_ptr = error_message;
82: 		}
83: 	}
84: };
85: 
86: //===--------------------------------------------------------------------===//
87: // Cast bool -> Numeric
88: //===--------------------------------------------------------------------===//
89: template <>
90: DUCKDB_API bool TryCast::Operation(bool input, bool &result, bool strict);
91: template <>
92: DUCKDB_API bool TryCast::Operation(bool input, int8_t &result, bool strict);
93: template <>
94: DUCKDB_API bool TryCast::Operation(bool input, int16_t &result, bool strict);
95: template <>
96: DUCKDB_API bool TryCast::Operation(bool input, int32_t &result, bool strict);
97: template <>
98: DUCKDB_API bool TryCast::Operation(bool input, int64_t &result, bool strict);
99: template <>
100: DUCKDB_API bool TryCast::Operation(bool input, hugeint_t &result, bool strict);
101: template <>
102: DUCKDB_API bool TryCast::Operation(bool input, uint8_t &result, bool strict);
103: template <>
104: DUCKDB_API bool TryCast::Operation(bool input, uint16_t &result, bool strict);
105: template <>
106: DUCKDB_API bool TryCast::Operation(bool input, uint32_t &result, bool strict);
107: template <>
108: DUCKDB_API bool TryCast::Operation(bool input, uint64_t &result, bool strict);
109: template <>
110: DUCKDB_API bool TryCast::Operation(bool input, float &result, bool strict);
111: template <>
112: DUCKDB_API bool TryCast::Operation(bool input, double &result, bool strict);
113: 
114: //===--------------------------------------------------------------------===//
115: // Cast int8_t -> Numeric
116: //===--------------------------------------------------------------------===//
117: template <>
118: DUCKDB_API bool TryCast::Operation(int8_t input, bool &result, bool strict);
119: template <>
120: DUCKDB_API bool TryCast::Operation(int8_t input, int8_t &result, bool strict);
121: template <>
122: DUCKDB_API bool TryCast::Operation(int8_t input, int16_t &result, bool strict);
123: template <>
124: DUCKDB_API bool TryCast::Operation(int8_t input, int32_t &result, bool strict);
125: template <>
126: DUCKDB_API bool TryCast::Operation(int8_t input, int64_t &result, bool strict);
127: template <>
128: DUCKDB_API bool TryCast::Operation(int8_t input, hugeint_t &result, bool strict);
129: template <>
130: DUCKDB_API bool TryCast::Operation(int8_t input, uint8_t &result, bool strict);
131: template <>
132: DUCKDB_API bool TryCast::Operation(int8_t input, uint16_t &result, bool strict);
133: template <>
134: DUCKDB_API bool TryCast::Operation(int8_t input, uint32_t &result, bool strict);
135: template <>
136: DUCKDB_API bool TryCast::Operation(int8_t input, uint64_t &result, bool strict);
137: template <>
138: DUCKDB_API bool TryCast::Operation(int8_t input, float &result, bool strict);
139: template <>
140: DUCKDB_API bool TryCast::Operation(int8_t input, double &result, bool strict);
141: 
142: //===--------------------------------------------------------------------===//
143: // Cast int16_t -> Numeric
144: //===--------------------------------------------------------------------===//
145: template <>
146: DUCKDB_API bool TryCast::Operation(int16_t input, bool &result, bool strict);
147: template <>
148: DUCKDB_API bool TryCast::Operation(int16_t input, int8_t &result, bool strict);
149: template <>
150: DUCKDB_API bool TryCast::Operation(int16_t input, int16_t &result, bool strict);
151: template <>
152: DUCKDB_API bool TryCast::Operation(int16_t input, int32_t &result, bool strict);
153: template <>
154: DUCKDB_API bool TryCast::Operation(int16_t input, int64_t &result, bool strict);
155: template <>
156: DUCKDB_API bool TryCast::Operation(int16_t input, hugeint_t &result, bool strict);
157: template <>
158: DUCKDB_API bool TryCast::Operation(int16_t input, uint8_t &result, bool strict);
159: template <>
160: DUCKDB_API bool TryCast::Operation(int16_t input, uint16_t &result, bool strict);
161: template <>
162: DUCKDB_API bool TryCast::Operation(int16_t input, uint32_t &result, bool strict);
163: template <>
164: DUCKDB_API bool TryCast::Operation(int16_t input, uint64_t &result, bool strict);
165: template <>
166: DUCKDB_API bool TryCast::Operation(int16_t input, float &result, bool strict);
167: template <>
168: DUCKDB_API bool TryCast::Operation(int16_t input, double &result, bool strict);
169: 
170: //===--------------------------------------------------------------------===//
171: // Cast int32_t -> Numeric
172: //===--------------------------------------------------------------------===//
173: template <>
174: DUCKDB_API bool TryCast::Operation(int32_t input, bool &result, bool strict);
175: template <>
176: DUCKDB_API bool TryCast::Operation(int32_t input, int8_t &result, bool strict);
177: template <>
178: DUCKDB_API bool TryCast::Operation(int32_t input, int16_t &result, bool strict);
179: template <>
180: DUCKDB_API bool TryCast::Operation(int32_t input, int32_t &result, bool strict);
181: template <>
182: DUCKDB_API bool TryCast::Operation(int32_t input, int64_t &result, bool strict);
183: template <>
184: DUCKDB_API bool TryCast::Operation(int32_t input, hugeint_t &result, bool strict);
185: template <>
186: DUCKDB_API bool TryCast::Operation(int32_t input, uint8_t &result, bool strict);
187: template <>
188: DUCKDB_API bool TryCast::Operation(int32_t input, uint16_t &result, bool strict);
189: template <>
190: DUCKDB_API bool TryCast::Operation(int32_t input, uint32_t &result, bool strict);
191: template <>
192: DUCKDB_API bool TryCast::Operation(int32_t input, uint64_t &result, bool strict);
193: template <>
194: DUCKDB_API bool TryCast::Operation(int32_t input, float &result, bool strict);
195: template <>
196: DUCKDB_API bool TryCast::Operation(int32_t input, double &result, bool strict);
197: 
198: //===--------------------------------------------------------------------===//
199: // Cast int64_t -> Numeric
200: //===--------------------------------------------------------------------===//
201: template <>
202: DUCKDB_API bool TryCast::Operation(int64_t input, bool &result, bool strict);
203: template <>
204: DUCKDB_API bool TryCast::Operation(int64_t input, int8_t &result, bool strict);
205: template <>
206: DUCKDB_API bool TryCast::Operation(int64_t input, int16_t &result, bool strict);
207: template <>
208: DUCKDB_API bool TryCast::Operation(int64_t input, int32_t &result, bool strict);
209: template <>
210: DUCKDB_API bool TryCast::Operation(int64_t input, int64_t &result, bool strict);
211: template <>
212: DUCKDB_API bool TryCast::Operation(int64_t input, hugeint_t &result, bool strict);
213: template <>
214: DUCKDB_API bool TryCast::Operation(int64_t input, uint8_t &result, bool strict);
215: template <>
216: DUCKDB_API bool TryCast::Operation(int64_t input, uint16_t &result, bool strict);
217: template <>
218: DUCKDB_API bool TryCast::Operation(int64_t input, uint32_t &result, bool strict);
219: template <>
220: DUCKDB_API bool TryCast::Operation(int64_t input, uint64_t &result, bool strict);
221: template <>
222: DUCKDB_API bool TryCast::Operation(int64_t input, float &result, bool strict);
223: template <>
224: DUCKDB_API bool TryCast::Operation(int64_t input, double &result, bool strict);
225: 
226: //===--------------------------------------------------------------------===//
227: // Cast hugeint_t -> Numeric
228: //===--------------------------------------------------------------------===//
229: template <>
230: DUCKDB_API bool TryCast::Operation(hugeint_t input, bool &result, bool strict);
231: template <>
232: DUCKDB_API bool TryCast::Operation(hugeint_t input, int8_t &result, bool strict);
233: template <>
234: DUCKDB_API bool TryCast::Operation(hugeint_t input, int16_t &result, bool strict);
235: template <>
236: DUCKDB_API bool TryCast::Operation(hugeint_t input, int32_t &result, bool strict);
237: template <>
238: DUCKDB_API bool TryCast::Operation(hugeint_t input, int64_t &result, bool strict);
239: template <>
240: DUCKDB_API bool TryCast::Operation(hugeint_t input, hugeint_t &result, bool strict);
241: template <>
242: DUCKDB_API bool TryCast::Operation(hugeint_t input, uint8_t &result, bool strict);
243: template <>
244: DUCKDB_API bool TryCast::Operation(hugeint_t input, uint16_t &result, bool strict);
245: template <>
246: DUCKDB_API bool TryCast::Operation(hugeint_t input, uint32_t &result, bool strict);
247: template <>
248: DUCKDB_API bool TryCast::Operation(hugeint_t input, uint64_t &result, bool strict);
249: template <>
250: DUCKDB_API bool TryCast::Operation(hugeint_t input, float &result, bool strict);
251: template <>
252: DUCKDB_API bool TryCast::Operation(hugeint_t input, double &result, bool strict);
253: 
254: //===--------------------------------------------------------------------===//
255: // Cast uint8_t -> Numeric
256: //===--------------------------------------------------------------------===//
257: template <>
258: DUCKDB_API bool TryCast::Operation(uint8_t input, bool &result, bool strict);
259: template <>
260: DUCKDB_API bool TryCast::Operation(uint8_t input, int8_t &result, bool strict);
261: template <>
262: DUCKDB_API bool TryCast::Operation(uint8_t input, int16_t &result, bool strict);
263: template <>
264: DUCKDB_API bool TryCast::Operation(uint8_t input, int32_t &result, bool strict);
265: template <>
266: DUCKDB_API bool TryCast::Operation(uint8_t input, int64_t &result, bool strict);
267: template <>
268: DUCKDB_API bool TryCast::Operation(uint8_t input, hugeint_t &result, bool strict);
269: template <>
270: DUCKDB_API bool TryCast::Operation(uint8_t input, uint8_t &result, bool strict);
271: template <>
272: DUCKDB_API bool TryCast::Operation(uint8_t input, uint16_t &result, bool strict);
273: template <>
274: DUCKDB_API bool TryCast::Operation(uint8_t input, uint32_t &result, bool strict);
275: template <>
276: DUCKDB_API bool TryCast::Operation(uint8_t input, uint64_t &result, bool strict);
277: template <>
278: DUCKDB_API bool TryCast::Operation(uint8_t input, float &result, bool strict);
279: template <>
280: DUCKDB_API bool TryCast::Operation(uint8_t input, double &result, bool strict);
281: 
282: //===--------------------------------------------------------------------===//
283: // Cast uint16_t -> Numeric
284: //===--------------------------------------------------------------------===//
285: template <>
286: DUCKDB_API bool TryCast::Operation(uint16_t input, bool &result, bool strict);
287: template <>
288: DUCKDB_API bool TryCast::Operation(uint16_t input, int8_t &result, bool strict);
289: template <>
290: DUCKDB_API bool TryCast::Operation(uint16_t input, int16_t &result, bool strict);
291: template <>
292: DUCKDB_API bool TryCast::Operation(uint16_t input, int32_t &result, bool strict);
293: template <>
294: DUCKDB_API bool TryCast::Operation(uint16_t input, int64_t &result, bool strict);
295: template <>
296: DUCKDB_API bool TryCast::Operation(uint16_t input, hugeint_t &result, bool strict);
297: template <>
298: DUCKDB_API bool TryCast::Operation(uint16_t input, uint8_t &result, bool strict);
299: template <>
300: DUCKDB_API bool TryCast::Operation(uint16_t input, uint16_t &result, bool strict);
301: template <>
302: DUCKDB_API bool TryCast::Operation(uint16_t input, uint32_t &result, bool strict);
303: template <>
304: DUCKDB_API bool TryCast::Operation(uint16_t input, uint64_t &result, bool strict);
305: template <>
306: DUCKDB_API bool TryCast::Operation(uint16_t input, float &result, bool strict);
307: template <>
308: DUCKDB_API bool TryCast::Operation(uint16_t input, double &result, bool strict);
309: 
310: //===--------------------------------------------------------------------===//
311: // Cast uint32_t -> Numeric
312: //===--------------------------------------------------------------------===//
313: template <>
314: DUCKDB_API bool TryCast::Operation(uint32_t input, bool &result, bool strict);
315: template <>
316: DUCKDB_API bool TryCast::Operation(uint32_t input, int8_t &result, bool strict);
317: template <>
318: DUCKDB_API bool TryCast::Operation(uint32_t input, int16_t &result, bool strict);
319: template <>
320: DUCKDB_API bool TryCast::Operation(uint32_t input, int32_t &result, bool strict);
321: template <>
322: DUCKDB_API bool TryCast::Operation(uint32_t input, int64_t &result, bool strict);
323: template <>
324: DUCKDB_API bool TryCast::Operation(uint32_t input, hugeint_t &result, bool strict);
325: template <>
326: DUCKDB_API bool TryCast::Operation(uint32_t input, uint8_t &result, bool strict);
327: template <>
328: DUCKDB_API bool TryCast::Operation(uint32_t input, uint16_t &result, bool strict);
329: template <>
330: DUCKDB_API bool TryCast::Operation(uint32_t input, uint32_t &result, bool strict);
331: template <>
332: DUCKDB_API bool TryCast::Operation(uint32_t input, uint64_t &result, bool strict);
333: template <>
334: DUCKDB_API bool TryCast::Operation(uint32_t input, float &result, bool strict);
335: template <>
336: DUCKDB_API bool TryCast::Operation(uint32_t input, double &result, bool strict);
337: 
338: //===--------------------------------------------------------------------===//
339: // Cast uint64_t -> Numeric
340: //===--------------------------------------------------------------------===//
341: template <>
342: DUCKDB_API bool TryCast::Operation(uint64_t input, bool &result, bool strict);
343: template <>
344: DUCKDB_API bool TryCast::Operation(uint64_t input, int8_t &result, bool strict);
345: template <>
346: DUCKDB_API bool TryCast::Operation(uint64_t input, int16_t &result, bool strict);
347: template <>
348: DUCKDB_API bool TryCast::Operation(uint64_t input, int32_t &result, bool strict);
349: template <>
350: DUCKDB_API bool TryCast::Operation(uint64_t input, int64_t &result, bool strict);
351: template <>
352: DUCKDB_API bool TryCast::Operation(uint64_t input, hugeint_t &result, bool strict);
353: template <>
354: DUCKDB_API bool TryCast::Operation(uint64_t input, uint8_t &result, bool strict);
355: template <>
356: DUCKDB_API bool TryCast::Operation(uint64_t input, uint16_t &result, bool strict);
357: template <>
358: DUCKDB_API bool TryCast::Operation(uint64_t input, uint32_t &result, bool strict);
359: template <>
360: DUCKDB_API bool TryCast::Operation(uint64_t input, uint64_t &result, bool strict);
361: template <>
362: DUCKDB_API bool TryCast::Operation(uint64_t input, float &result, bool strict);
363: template <>
364: DUCKDB_API bool TryCast::Operation(uint64_t input, double &result, bool strict);
365: 
366: //===--------------------------------------------------------------------===//
367: // Cast float -> Numeric
368: //===--------------------------------------------------------------------===//
369: template <>
370: DUCKDB_API bool TryCast::Operation(float input, bool &result, bool strict);
371: template <>
372: DUCKDB_API bool TryCast::Operation(float input, int8_t &result, bool strict);
373: template <>
374: DUCKDB_API bool TryCast::Operation(float input, int16_t &result, bool strict);
375: template <>
376: DUCKDB_API bool TryCast::Operation(float input, int32_t &result, bool strict);
377: template <>
378: DUCKDB_API bool TryCast::Operation(float input, int64_t &result, bool strict);
379: template <>
380: DUCKDB_API bool TryCast::Operation(float input, hugeint_t &result, bool strict);
381: template <>
382: DUCKDB_API bool TryCast::Operation(float input, uint8_t &result, bool strict);
383: template <>
384: DUCKDB_API bool TryCast::Operation(float input, uint16_t &result, bool strict);
385: template <>
386: DUCKDB_API bool TryCast::Operation(float input, uint32_t &result, bool strict);
387: template <>
388: DUCKDB_API bool TryCast::Operation(float input, uint64_t &result, bool strict);
389: template <>
390: DUCKDB_API bool TryCast::Operation(float input, float &result, bool strict);
391: template <>
392: DUCKDB_API bool TryCast::Operation(float input, double &result, bool strict);
393: 
394: //===--------------------------------------------------------------------===//
395: // Cast double -> Numeric
396: //===--------------------------------------------------------------------===//
397: template <>
398: DUCKDB_API bool TryCast::Operation(double input, bool &result, bool strict);
399: template <>
400: DUCKDB_API bool TryCast::Operation(double input, int8_t &result, bool strict);
401: template <>
402: DUCKDB_API bool TryCast::Operation(double input, int16_t &result, bool strict);
403: template <>
404: DUCKDB_API bool TryCast::Operation(double input, int32_t &result, bool strict);
405: template <>
406: DUCKDB_API bool TryCast::Operation(double input, int64_t &result, bool strict);
407: template <>
408: DUCKDB_API bool TryCast::Operation(double input, hugeint_t &result, bool strict);
409: template <>
410: DUCKDB_API bool TryCast::Operation(double input, uint8_t &result, bool strict);
411: template <>
412: DUCKDB_API bool TryCast::Operation(double input, uint16_t &result, bool strict);
413: template <>
414: DUCKDB_API bool TryCast::Operation(double input, uint32_t &result, bool strict);
415: template <>
416: DUCKDB_API bool TryCast::Operation(double input, uint64_t &result, bool strict);
417: template <>
418: DUCKDB_API bool TryCast::Operation(double input, float &result, bool strict);
419: template <>
420: DUCKDB_API bool TryCast::Operation(double input, double &result, bool strict);
421: 
422: //===--------------------------------------------------------------------===//
423: // String -> Numeric Casts
424: //===--------------------------------------------------------------------===//
425: template <>
426: DUCKDB_API bool TryCast::Operation(string_t input, bool &result, bool strict);
427: template <>
428: DUCKDB_API bool TryCast::Operation(string_t input, int8_t &result, bool strict);
429: template <>
430: DUCKDB_API bool TryCast::Operation(string_t input, int16_t &result, bool strict);
431: template <>
432: DUCKDB_API bool TryCast::Operation(string_t input, int32_t &result, bool strict);
433: template <>
434: DUCKDB_API bool TryCast::Operation(string_t input, int64_t &result, bool strict);
435: template <>
436: DUCKDB_API bool TryCast::Operation(string_t input, uint8_t &result, bool strict);
437: template <>
438: DUCKDB_API bool TryCast::Operation(string_t input, uint16_t &result, bool strict);
439: template <>
440: DUCKDB_API bool TryCast::Operation(string_t input, uint32_t &result, bool strict);
441: template <>
442: DUCKDB_API bool TryCast::Operation(string_t input, uint64_t &result, bool strict);
443: template <>
444: DUCKDB_API bool TryCast::Operation(string_t input, hugeint_t &result, bool strict);
445: template <>
446: DUCKDB_API bool TryCast::Operation(string_t input, float &result, bool strict);
447: template <>
448: DUCKDB_API bool TryCast::Operation(string_t input, double &result, bool strict);
449: template <>
450: DUCKDB_API bool TryCastErrorMessage::Operation(string_t input, float &result, string *error_message, bool strict);
451: template <>
452: DUCKDB_API bool TryCastErrorMessage::Operation(string_t input, double &result, string *error_message, bool strict);
453: template <>
454: DUCKDB_API bool TryCastErrorMessageCommaSeparated::Operation(string_t input, float &result, string *error_message,
455:                                                              bool strict);
456: template <>
457: DUCKDB_API bool TryCastErrorMessageCommaSeparated::Operation(string_t input, double &result, string *error_message,
458:                                                              bool strict);
459: 
460: //===--------------------------------------------------------------------===//
461: // Date Casts
462: //===--------------------------------------------------------------------===//
463: template <>
464: DUCKDB_API bool TryCast::Operation(date_t input, date_t &result, bool strict);
465: template <>
466: DUCKDB_API bool TryCast::Operation(date_t input, timestamp_t &result, bool strict);
467: 
468: //===--------------------------------------------------------------------===//
469: // Time Casts
470: //===--------------------------------------------------------------------===//
471: template <>
472: DUCKDB_API bool TryCast::Operation(dtime_t input, dtime_t &result, bool strict);
473: template <>
474: DUCKDB_API bool TryCast::Operation(dtime_t input, dtime_tz_t &result, bool strict);
475: 
476: //===--------------------------------------------------------------------===//
477: // Time With Time Zone Casts (Offset)
478: //===--------------------------------------------------------------------===//
479: template <>
480: DUCKDB_API bool TryCast::Operation(dtime_tz_t input, dtime_t &result, bool strict);
481: template <>
482: DUCKDB_API bool TryCast::Operation(dtime_tz_t input, dtime_tz_t &result, bool strict);
483: 
484: //===--------------------------------------------------------------------===//
485: // Timestamp Casts
486: //===--------------------------------------------------------------------===//
487: template <>
488: DUCKDB_API bool TryCast::Operation(timestamp_t input, date_t &result, bool strict);
489: template <>
490: DUCKDB_API bool TryCast::Operation(timestamp_t input, dtime_t &result, bool strict);
491: template <>
492: DUCKDB_API bool TryCast::Operation(timestamp_t input, dtime_tz_t &result, bool strict);
493: template <>
494: DUCKDB_API bool TryCast::Operation(timestamp_t input, timestamp_t &result, bool strict);
495: 
496: //===--------------------------------------------------------------------===//
497: // Interval Casts
498: //===--------------------------------------------------------------------===//
499: template <>
500: DUCKDB_API bool TryCast::Operation(interval_t input, interval_t &result, bool strict);
501: 
502: //===--------------------------------------------------------------------===//
503: // String -> Date Casts
504: //===--------------------------------------------------------------------===//
505: template <>
506: DUCKDB_API bool TryCastErrorMessage::Operation(string_t input, date_t &result, string *error_message, bool strict);
507: template <>
508: DUCKDB_API bool TryCast::Operation(string_t input, date_t &result, bool strict);
509: template <>
510: date_t Cast::Operation(string_t input);
511: //===--------------------------------------------------------------------===//
512: // String -> Time Casts
513: //===--------------------------------------------------------------------===//
514: template <>
515: DUCKDB_API bool TryCastErrorMessage::Operation(string_t input, dtime_t &result, string *error_message, bool strict);
516: template <>
517: DUCKDB_API bool TryCast::Operation(string_t input, dtime_t &result, bool strict);
518: template <>
519: dtime_t Cast::Operation(string_t input);
520: //===--------------------------------------------------------------------===//
521: // String -> TimeTZ Casts
522: //===--------------------------------------------------------------------===//
523: template <>
524: DUCKDB_API bool TryCastErrorMessage::Operation(string_t input, dtime_tz_t &result, string *error_message, bool strict);
525: template <>
526: DUCKDB_API bool TryCast::Operation(string_t input, dtime_tz_t &result, bool strict);
527: template <>
528: dtime_tz_t Cast::Operation(string_t input);
529: //===--------------------------------------------------------------------===//
530: // String -> Timestamp Casts
531: //===--------------------------------------------------------------------===//
532: template <>
533: DUCKDB_API bool TryCastErrorMessage::Operation(string_t input, timestamp_t &result, string *error_message, bool strict);
534: template <>
535: DUCKDB_API bool TryCast::Operation(string_t input, timestamp_t &result, bool strict);
536: template <>
537: timestamp_t Cast::Operation(string_t input);
538: //===--------------------------------------------------------------------===//
539: // String -> Interval Casts
540: //===--------------------------------------------------------------------===//
541: template <>
542: DUCKDB_API bool TryCastErrorMessage::Operation(string_t input, interval_t &result, string *error_message, bool strict);
543: 
544: //===--------------------------------------------------------------------===//
545: // string -> Non-Standard Timestamps
546: //===--------------------------------------------------------------------===//
547: struct TryCastToTimestampNS {
548: 	template <class SRC, class DST>
549: 	static inline bool Operation(SRC input, DST &result, bool strict = false) {
550: 		throw InternalException("Unsupported type for try cast to timestamp (ns)");
551: 	}
552: };
553: 
554: struct TryCastToTimestampMS {
555: 	template <class SRC, class DST>
556: 	static inline bool Operation(SRC input, DST &result, bool strict = false) {
557: 		throw InternalException("Unsupported type for try cast to timestamp (ms)");
558: 	}
559: };
560: 
561: struct TryCastToTimestampSec {
562: 	template <class SRC, class DST>
563: 	static inline bool Operation(SRC input, DST &result, bool strict = false) {
564: 		throw InternalException("Unsupported type for try cast to timestamp (s)");
565: 	}
566: };
567: 
568: template <>
569: DUCKDB_API bool TryCastToTimestampNS::Operation(string_t input, timestamp_t &result, bool strict);
570: template <>
571: DUCKDB_API bool TryCastToTimestampMS::Operation(string_t input, timestamp_t &result, bool strict);
572: template <>
573: DUCKDB_API bool TryCastToTimestampSec::Operation(string_t input, timestamp_t &result, bool strict);
574: 
575: template <>
576: DUCKDB_API bool TryCastToTimestampNS::Operation(date_t input, timestamp_t &result, bool strict);
577: template <>
578: DUCKDB_API bool TryCastToTimestampMS::Operation(date_t input, timestamp_t &result, bool strict);
579: template <>
580: DUCKDB_API bool TryCastToTimestampSec::Operation(date_t input, timestamp_t &result, bool strict);
581: 
582: //===--------------------------------------------------------------------===//
583: // Non-Standard Timestamps -> string/standard timestamp
584: //===--------------------------------------------------------------------===//
585: 
586: struct CastFromTimestampNS {
587: 	template <class SRC>
588: 	static inline string_t Operation(SRC input, Vector &result) {
589: 		throw duckdb::NotImplementedException("Cast to timestamp could not be performed!");
590: 	}
591: };
592: 
593: struct CastFromTimestampMS {
594: 	template <class SRC>
595: 	static inline string_t Operation(SRC input, Vector &result) {
596: 		throw duckdb::NotImplementedException("Cast to timestamp could not be performed!");
597: 	}
598: };
599: 
600: struct CastFromTimestampSec {
601: 	template <class SRC>
602: 	static inline string_t Operation(SRC input, Vector &result) {
603: 		throw duckdb::NotImplementedException("Cast to timestamp could not be performed!");
604: 	}
605: };
606: 
607: struct CastTimestampUsToMs {
608: 	template <class SRC, class DST>
609: 	static inline DST Operation(SRC input) {
610: 		throw duckdb::NotImplementedException("Cast to timestamp could not be performed!");
611: 	}
612: };
613: 
614: struct CastTimestampUsToNs {
615: 	template <class SRC, class DST>
616: 	static inline DST Operation(SRC input) {
617: 		throw duckdb::NotImplementedException("Cast to timestamp could not be performed!");
618: 	}
619: };
620: 
621: struct CastTimestampUsToSec {
622: 	template <class SRC, class DST>
623: 	static inline DST Operation(SRC input) {
624: 		throw duckdb::NotImplementedException("Cast to timestamp could not be performed!");
625: 	}
626: };
627: 
628: struct CastTimestampMsToUs {
629: 	template <class SRC, class DST>
630: 	static inline DST Operation(SRC input) {
631: 		throw duckdb::NotImplementedException("Cast to timestamp could not be performed!");
632: 	}
633: };
634: 
635: struct CastTimestampMsToNs {
636: 	template <class SRC, class DST>
637: 	static inline DST Operation(SRC input) {
638: 		throw duckdb::NotImplementedException("Cast to TIMESTAMP_NS could not be performed!");
639: 	}
640: };
641: 
642: struct CastTimestampNsToUs {
643: 	template <class SRC, class DST>
644: 	static inline DST Operation(SRC input) {
645: 		throw duckdb::NotImplementedException("Cast to timestamp could not be performed!");
646: 	}
647: };
648: 
649: struct CastTimestampSecToMs {
650: 	template <class SRC, class DST>
651: 	static inline DST Operation(SRC input) {
652: 		throw duckdb::NotImplementedException("Cast to TIMESTAMP_MS could not be performed!");
653: 	}
654: };
655: 
656: struct CastTimestampSecToUs {
657: 	template <class SRC, class DST>
658: 	static inline DST Operation(SRC input) {
659: 		throw duckdb::NotImplementedException("Cast to timestamp could not be performed!");
660: 	}
661: };
662: 
663: struct CastTimestampSecToNs {
664: 	template <class SRC, class DST>
665: 	static inline DST Operation(SRC input) {
666: 		throw duckdb::NotImplementedException("Cast to TIMESTAMP_NS could not be performed!");
667: 	}
668: };
669: 
670: template <>
671: duckdb::timestamp_t CastTimestampUsToMs::Operation(duckdb::timestamp_t input);
672: template <>
673: duckdb::timestamp_t CastTimestampUsToNs::Operation(duckdb::timestamp_t input);
674: template <>
675: duckdb::timestamp_t CastTimestampUsToSec::Operation(duckdb::timestamp_t input);
676: template <>
677: duckdb::timestamp_t CastTimestampMsToUs::Operation(duckdb::timestamp_t input);
678: template <>
679: duckdb::timestamp_t CastTimestampMsToNs::Operation(duckdb::timestamp_t input);
680: template <>
681: duckdb::timestamp_t CastTimestampNsToUs::Operation(duckdb::timestamp_t input);
682: template <>
683: duckdb::timestamp_t CastTimestampSecToMs::Operation(duckdb::timestamp_t input);
684: template <>
685: duckdb::timestamp_t CastTimestampSecToUs::Operation(duckdb::timestamp_t input);
686: template <>
687: duckdb::timestamp_t CastTimestampSecToNs::Operation(duckdb::timestamp_t input);
688: 
689: template <>
690: duckdb::string_t CastFromTimestampNS::Operation(duckdb::timestamp_t input, Vector &result);
691: template <>
692: duckdb::string_t CastFromTimestampMS::Operation(duckdb::timestamp_t input, Vector &result);
693: template <>
694: duckdb::string_t CastFromTimestampSec::Operation(duckdb::timestamp_t input, Vector &result);
695: 
696: //===--------------------------------------------------------------------===//
697: // Blobs
698: //===--------------------------------------------------------------------===//
699: struct CastFromBlob {
700: 	template <class SRC>
701: 	static inline string_t Operation(SRC input, Vector &result) {
702: 		throw duckdb::NotImplementedException("Cast from blob could not be performed!");
703: 	}
704: };
705: template <>
706: duckdb::string_t CastFromBlob::Operation(duckdb::string_t input, Vector &vector);
707: 
708: struct CastFromBlobToBit {
709: 	template <class SRC>
710: 	static inline string_t Operation(SRC input, Vector &result) {
711: 		throw NotImplementedException("Cast from blob could not be performed!");
712: 	}
713: };
714: template <>
715: string_t CastFromBlobToBit::Operation(string_t input, Vector &result);
716: 
717: struct TryCastToBlob {
718: 	template <class SRC, class DST>
719: 	static inline bool Operation(SRC input, DST &result, Vector &result_vector, string *error_message,
720: 	                             bool strict = false) {
721: 		throw InternalException("Unsupported type for try cast to blob");
722: 	}
723: };
724: template <>
725: bool TryCastToBlob::Operation(string_t input, string_t &result, Vector &result_vector, string *error_message,
726:                               bool strict);
727: 
728: //===--------------------------------------------------------------------===//
729: // Bits
730: //===--------------------------------------------------------------------===//
731: struct CastFromBitToString {
732: 	template <class SRC>
733: 	static inline string_t Operation(SRC input, Vector &result) {
734: 		throw duckdb::NotImplementedException("Cast from bit could not be performed!");
735: 	}
736: };
737: template <>
738: duckdb::string_t CastFromBitToString::Operation(duckdb::string_t input, Vector &vector);
739: 
740: struct CastFromBitToNumeric {
741: 	template <class SRC = string_t, class DST>
742: 	static inline bool Operation(SRC input, DST &result, bool strict = false) {
743: 		D_ASSERT(input.GetSize() > 1);
744: 
745: 		// TODO: Allow conversion if the significant bytes of the bitstring can be cast to the target type
746: 		// Currently only allows bitstring -> numeric if the full bitstring fits inside the numeric type
747: 		if (input.GetSize() - 1 > sizeof(DST)) {
748: 			throw ConversionException("Bitstring doesn't fit inside of %s", GetTypeId<DST>());
749: 		}
750: 		Bit::BitToNumeric(input, result);
751: 		return (true);
752: 	}
753: };
754: template <>
755: bool CastFromBitToNumeric::Operation(string_t input, bool &result, bool strict);
756: template <>
757: bool CastFromBitToNumeric::Operation(string_t input, hugeint_t &result, bool strict);
758: 
759: struct CastFromBitToBlob {
760: 	template <class SRC>
761: 	static inline string_t Operation(SRC input, Vector &result) {
762: 		D_ASSERT(input.GetSize() > 1);
763: 		return StringVector::AddStringOrBlob(result, Bit::BitToBlob(input));
764: 	}
765: };
766: 
767: struct TryCastToBit {
768: 	template <class SRC, class DST>
769: 	static inline bool Operation(SRC input, DST &result, Vector &result_vector, string *error_message,
770: 	                             bool strict = false) {
771: 		throw InternalException("Unsupported type for try cast to bit");
772: 	}
773: };
774: 
775: template <>
776: bool TryCastToBit::Operation(string_t input, string_t &result, Vector &result_vector, string *error_message,
777:                              bool strict);
778: 
779: //===--------------------------------------------------------------------===//
780: // UUID
781: //===--------------------------------------------------------------------===//
782: struct CastFromUUID {
783: 	template <class SRC>
784: 	static inline string_t Operation(SRC input, Vector &result) {
785: 		throw duckdb::NotImplementedException("Cast from uuid could not be performed!");
786: 	}
787: };
788: template <>
789: duckdb::string_t CastFromUUID::Operation(duckdb::hugeint_t input, Vector &vector);
790: 
791: struct TryCastToUUID {
792: 	template <class SRC, class DST>
793: 	static inline bool Operation(SRC input, DST &result, Vector &result_vector, string *error_message,
794: 	                             bool strict = false) {
795: 		throw InternalException("Unsupported type for try cast to uuid");
796: 	}
797: };
798: 
799: template <>
800: DUCKDB_API bool TryCastToUUID::Operation(string_t input, hugeint_t &result, Vector &result_vector,
801:                                          string *error_message, bool strict);
802: 
803: //===--------------------------------------------------------------------===//
804: // Pointers
805: //===--------------------------------------------------------------------===//
806: struct CastFromPointer {
807: 	template <class SRC>
808: 	static inline string_t Operation(SRC input, Vector &result) {
809: 		throw duckdb::NotImplementedException("Cast from pointer could not be performed!");
810: 	}
811: };
812: template <>
813: duckdb::string_t CastFromPointer::Operation(uintptr_t input, Vector &vector);
814: 
815: } // namespace duckdb
[end of src/include/duckdb/common/operator/cast_operators.hpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: