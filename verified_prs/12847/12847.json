{
  "repo": "duckdb/duckdb",
  "pull_number": 12847,
  "instance_id": "duckdb__duckdb-12847",
  "issue_numbers": [
    "12843"
  ],
  "base_commit": "6b0889c968cb36caf7f6e00ffcd295d75b9b6f25",
  "patch": "diff --git a/src/function/cast/union_casts.cpp b/src/function/cast/union_casts.cpp\nindex 10b79f01b467..72b171745a31 100644\n--- a/src/function/cast/union_casts.cpp\n+++ b/src/function/cast/union_casts.cpp\n@@ -171,7 +171,7 @@ unique_ptr<BoundCastData> BindUnionToUnionCast(BindCastInput &input, const Logic\n \t\t\tauto &target_member_name = UnionType::GetMemberName(target, target_idx);\n \n \t\t\t// found a matching member\n-\t\t\tif (source_member_name == target_member_name) {\n+\t\t\tif (StringUtil::CIEquals(source_member_name, target_member_name)) {\n \t\t\t\tauto &target_member_type = UnionType::GetMemberType(target, target_idx);\n \t\t\t\ttag_map[source_idx] = target_idx;\n \t\t\t\tmember_casts.push_back(input.GetCastFunction(source_member_type, target_member_type));\ndiff --git a/src/function/cast_rules.cpp b/src/function/cast_rules.cpp\nindex f6537e235e19..3c2eaf3e7580 100644\n--- a/src/function/cast_rules.cpp\n+++ b/src/function/cast_rules.cpp\n@@ -1,5 +1,7 @@\n #include \"duckdb/function/cast_rules.hpp\"\n+#include \"duckdb/common/helper.hpp\"\n #include \"duckdb/common/numeric_utils.hpp\"\n+#include \"duckdb/common/case_insensitive_map.hpp\"\n \n namespace duckdb {\n \n@@ -403,15 +405,17 @@ int64_t CastRules::ImplicitCast(const LogicalType &from, const LogicalType &to)\n \t\t// TODO: if we can access the expression we could resolve the size if the list is constant.\n \t\treturn ImplicitCast(ListType::GetChildType(from), ArrayType::GetChildType(to));\n \t}\n-\tif (from.id() == to.id()) {\n-\t\t// arguments match: do nothing\n-\t\treturn 0;\n-\t}\n-\n \tif (from.id() == LogicalTypeId::UNION && to.id() == LogicalTypeId::UNION) {\n+\t\t// Check that the target union type is fully resolved.\n+\t\tif (to.AuxInfo() == nullptr) {\n+\t\t\t// If not, try anyway and let the actual cast logic handle it.\n+\t\t\t// This is to allow passing unions into functions that take a generic union type (without specifying member\n+\t\t\t// types) as an argument.\n+\t\t\treturn 0;\n+\t\t}\n \t\t// Unions can be cast if the source tags are a subset of the target tags\n \t\t// in which case the most expensive cost is used\n-\t\tint cost = -1;\n+\t\tint64_t cost = -1;\n \t\tfor (idx_t from_member_idx = 0; from_member_idx < UnionType::GetMemberCount(from); from_member_idx++) {\n \t\t\tauto &from_member_name = UnionType::GetMemberName(from, from_member_idx);\n \n@@ -419,14 +423,12 @@ int64_t CastRules::ImplicitCast(const LogicalType &from, const LogicalType &to)\n \t\t\tfor (idx_t to_member_idx = 0; to_member_idx < UnionType::GetMemberCount(to); to_member_idx++) {\n \t\t\t\tauto &to_member_name = UnionType::GetMemberName(to, to_member_idx);\n \n-\t\t\t\tif (from_member_name == to_member_name) {\n+\t\t\t\tif (StringUtil::CIEquals(from_member_name, to_member_name)) {\n \t\t\t\t\tauto &from_member_type = UnionType::GetMemberType(from, from_member_idx);\n \t\t\t\t\tauto &to_member_type = UnionType::GetMemberType(to, to_member_idx);\n \n-\t\t\t\t\tint child_cost = NumericCast<int>(ImplicitCast(from_member_type, to_member_type));\n-\t\t\t\t\tif (child_cost > cost) {\n-\t\t\t\t\t\tcost = child_cost;\n-\t\t\t\t\t}\n+\t\t\t\t\tauto child_cost = ImplicitCast(from_member_type, to_member_type);\n+\t\t\t\t\tcost = MaxValue(cost, child_cost);\n \t\t\t\t\tfound = true;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n@@ -437,19 +439,92 @@ int64_t CastRules::ImplicitCast(const LogicalType &from, const LogicalType &to)\n \t\t}\n \t\treturn cost;\n \t}\n+\tif (from.id() == LogicalTypeId::STRUCT && to.id() == LogicalTypeId::STRUCT) {\n+\t\tif (to.AuxInfo() == nullptr) {\n+\t\t\t// If this struct is not fully resolved, we'll leave it to the actual cast logic to handle it.\n+\t\t\treturn 0;\n+\t\t}\n+\n+\t\tauto &source_children = StructType::GetChildTypes(from);\n+\t\tauto &target_children = StructType::GetChildTypes(to);\n+\n+\t\tif (source_children.size() != target_children.size()) {\n+\t\t\t// different number of children: not possible\n+\t\t\treturn -1;\n+\t\t}\n+\n+\t\tauto target_is_unnamed = StructType::IsUnnamed(to);\n+\t\tauto source_is_unnamed = StructType::IsUnnamed(from);\n+\t\tauto named_struct_cast = !source_is_unnamed && !target_is_unnamed;\n+\n+\t\tint64_t cost = -1;\n+\t\tif (named_struct_cast) {\n+\n+\t\t\t// Collect the target members in a map for easy lookup\n+\t\t\tcase_insensitive_map_t<idx_t> target_members;\n+\t\t\tfor (idx_t target_idx = 0; target_idx < target_children.size(); target_idx++) {\n+\t\t\t\tauto &target_name = target_children[target_idx].first;\n+\t\t\t\tif (target_members.find(target_name) != target_members.end()) {\n+\t\t\t\t\t// duplicate name in target struct\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n+\t\t\t\ttarget_members[target_name] = target_idx;\n+\t\t\t}\n+\t\t\t// Match the source members to the target members by name\n+\t\t\tfor (idx_t source_idx = 0; source_idx < source_children.size(); source_idx++) {\n+\t\t\t\tauto &source_child = source_children[source_idx];\n+\t\t\t\tauto entry = target_members.find(source_child.first);\n+\t\t\t\tif (entry == target_members.end()) {\n+\t\t\t\t\t// element in source struct was not found in target struct\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n+\t\t\t\tauto target_idx = entry->second;\n+\t\t\t\ttarget_members.erase(entry);\n+\t\t\t\tauto child_cost = ImplicitCast(source_child.second, target_children[target_idx].second);\n+\t\t\t\tif (child_cost == -1) {\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n+\t\t\t\tcost = MaxValue(cost, child_cost);\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// Match the source members to the target members by position\n+\t\t\tfor (idx_t i = 0; i < source_children.size(); i++) {\n+\t\t\t\tauto &source_child = source_children[i];\n+\t\t\t\tauto &target_child = target_children[i];\n+\t\t\t\tauto child_cost = ImplicitCast(source_child.second, target_child.second);\n+\t\t\t\tif (child_cost == -1) {\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n+\t\t\t\tcost = MaxValue(cost, child_cost);\n+\t\t\t}\n+\t\t}\n+\t\treturn cost;\n+\t}\n+\n+\tif (from.id() == to.id()) {\n+\t\t// arguments match: do nothing\n+\t\treturn 0;\n+\t}\n \n+\t// Special case: Anything can be cast to a union if the source type is a member of the union\n \tif (to.id() == LogicalTypeId::UNION) {\n \t\t// check that the union type is fully resolved.\n \t\tif (to.AuxInfo() == nullptr) {\n \t\t\treturn -1;\n \t\t}\n-\t\t// every type can be implicitly be cast to a union if the source type is a member of the union\n+\t\t// check if the union contains something castable from the source type\n+\t\t// in which case the least expensive (most specific) cast should be used\n+\t\tbool found = false;\n+\t\tauto cost = NumericLimits<int64_t>::Maximum();\n \t\tfor (idx_t i = 0; i < UnionType::GetMemberCount(to); i++) {\n-\t\t\tauto member = UnionType::GetMemberType(to, i);\n-\t\t\tif (from == member) {\n-\t\t\t\treturn 0;\n+\t\t\tauto target_member = UnionType::GetMemberType(to, i);\n+\t\t\tauto target_cost = ImplicitCast(from, target_member);\n+\t\t\tif (target_cost != -1) {\n+\t\t\t\tfound = true;\n+\t\t\t\tcost = MinValue(cost, target_cost);\n \t\t\t}\n \t\t}\n+\t\treturn found ? cost : -1;\n \t}\n \n \tswitch (from.id()) {\n",
  "test_patch": "diff --git a/test/sql/types/union/union_cast.test b/test/sql/types/union/union_cast.test\nindex 3dbed962b73e..aa50b9110cef 100644\n--- a/test/sql/types/union/union_cast.test\n+++ b/test/sql/types/union/union_cast.test\n@@ -205,3 +205,68 @@ select [\n [true]\n [true]\n \n+\n+# Struct member cast resolution\n+statement ok\n+CREATE TABLE t3 (id integer, u union(s1 struct(f1 varchar, f2 int), s2 struct(b1 varchar)));\n+\n+statement ok\n+INSERT INTO t3 VALUES (1, {b1: 'a'});\n+\n+statement ok\n+INSERT INTO t3 VALUES (2, row('s1', 2));\n+\n+statement ok\n+INSERT INTO t3 VALUES (3, {f1: 'c', f2: 3});\n+\n+statement ok\n+INSERT INTO t3 VALUES (4, row('s2'));\n+\n+query II rowsort\n+SELECT * FROM t3\n+----\n+1\t{'b1': a}\n+2\t{'f1': s1, 'f2': 2}\n+3\t{'f1': c, 'f2': 3}\n+4\t{'b1': s2}\n+\n+\n+# More union cast resolution checks\n+# Select the member with the lowest implicit cast cost\n+query I\n+SELECT union_tag(1::INTEGER::UNION(f1 VARCHAR, t DOUBLE, f2 BOOLEAN))\n+----\n+t\n+\n+query I\n+SELECT union_tag(1::INTEGER::UNION(t BIGINT, f1 STRUCT(i INTEGER), f2 BOOLEAN))\n+----\n+t\n+\n+query I\n+SELECT union_tag(1::FLOAT::UNION(f1 VARCHAR, f2 DOUBLE, t FLOAT))\n+----\n+t\n+\n+# This also works with nested unions, the value will slot into the union with the lowest cost\n+query I\n+SELECT union_tag(1::INTEGER::UNION(lu UNION(f1 VARCHAR, f2 BOOL), ru UNION(t BIGINT, f3 TINYINT)))\n+----\n+ru\n+\n+query I\n+SELECT union_tag((1::INTEGER::UNION(lu UNION(f1 VARCHAR, f2 BOOL), ru UNION(t BIGINT, f3 TINYINT))).ru);\n+----\n+t\n+\n+# Of course, this can also become ambiguos if there are multiple leaf types with the same cost\n+statement error\n+SELECT union_tag(1::INTEGER::UNION(lu UNION(f1 VARCHAR, t2 BIGINT), ru UNION(t2 BIGINT, f3 TINYINT)));\n+----\n+Conversion Error: Type INTEGER can't be cast as UNION(lu UNION(f1 VARCHAR, t2 BIGINT), ru UNION(t2 BIGINT, f3 TINYINT)). The cast is ambiguous\n+\n+# For union -> union casts, the name of the members are case insensitive when resolving the cast\n+query I\n+SELECT union_tag(1::INTEGER::UNION(f1 VARCHAR, t2 BIGINT)::UNION(F1 VARCHAR, T2 BIGINT, F3 TINYINT))\n+----\n+T2\n",
  "problem_statement": "Cannot insert into a UNION with two structs without using the `union_value` function\n### What happens?\r\n\r\nCannot insert into a UNION with two structs without using the `union_value` function.  Both unnamed and named structs don't work.\r\n\r\n### To Reproduce\r\n\r\n```\r\ncreate table t3 (id integer, u union(s1 struct(f1 string, f2 int), s2 struct(b1 string)));\r\n```\r\n```\r\nD insert into t3 values (1, row('a'));\r\nMismatch Type Error: Type STRUCT(VARCHAR) does not match with STRUCT(f1 VARCHAR, f2 INTEGER). Cannot cast STRUCTs of different size\r\nLINE 1: insert into t3 values (1, row('a'));\r\n                                  ^\r\nD insert into t3 values (1, row('a', 3));\r\nMismatch Type Error: Type STRUCT(VARCHAR, INTEGER) does not match with STRUCT(b1 VARCHAR). Cannot cast STRUCTs of different size\r\nLINE 1: insert into t3 values (1, row('a', 3));\r\n                                  ^\r\nD insert into t3 values (1, {b1: 'a'});\r\nMismatch Type Error: Type STRUCT(b1 VARCHAR) does not match with STRUCT(f1 VARCHAR, f2 INTEGER). Cannot cast STRUCTs of different size\r\nLINE 1: insert into t3 values (1, {b1: 'a'})\r\n                                   ^\r\n```\r\n\r\n### OS:\r\n\r\nMacOS\r\n\r\n### DuckDB Version:\r\n\r\n1.0\r\n\r\n### DuckDB Client:\r\n\r\nCLI\r\n\r\n### Full Name:\r\n\r\nRobert Yokota\r\n\r\n### Affiliation:\r\n\r\nConfluent\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2024-07-04T11:19:42Z",
  "modified_files": [
    "a/src/function/cast/union_casts.cpp",
    "a/src/function/cast_rules.cpp"
  ]
}