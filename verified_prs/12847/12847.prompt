You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Cannot insert into a UNION with two structs without using the `union_value` function
### What happens?

Cannot insert into a UNION with two structs without using the `union_value` function.  Both unnamed and named structs don't work.

### To Reproduce

```
create table t3 (id integer, u union(s1 struct(f1 string, f2 int), s2 struct(b1 string)));
```
```
D insert into t3 values (1, row('a'));
Mismatch Type Error: Type STRUCT(VARCHAR) does not match with STRUCT(f1 VARCHAR, f2 INTEGER). Cannot cast STRUCTs of different size
LINE 1: insert into t3 values (1, row('a'));
                                  ^
D insert into t3 values (1, row('a', 3));
Mismatch Type Error: Type STRUCT(VARCHAR, INTEGER) does not match with STRUCT(b1 VARCHAR). Cannot cast STRUCTs of different size
LINE 1: insert into t3 values (1, row('a', 3));
                                  ^
D insert into t3 values (1, {b1: 'a'});
Mismatch Type Error: Type STRUCT(b1 VARCHAR) does not match with STRUCT(f1 VARCHAR, f2 INTEGER). Cannot cast STRUCTs of different size
LINE 1: insert into t3 values (1, {b1: 'a'})
                                   ^
```

### OS:

MacOS

### DuckDB Version:

1.0

### DuckDB Client:

CLI

### Full Name:

Robert Yokota

### Affiliation:

Confluent

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://www.duckdb.org/docs/installation) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/function/cast/union_casts.cpp]
1: #include "duckdb/common/exception/conversion_exception.hpp"
2: #include "duckdb/common/numeric_utils.hpp"
3: #include "duckdb/function/cast/cast_function_set.hpp"
4: #include "duckdb/function/cast/default_casts.hpp"
5: #include "duckdb/function/cast/bound_cast_data.hpp"
6: 
7: #include <algorithm> // for std::sort
8: 
9: namespace duckdb {
10: 
11: //--------------------------------------------------------------------------------------------------
12: // ??? -> UNION
13: //--------------------------------------------------------------------------------------------------
14: // if the source can be implicitly cast to a member of the target union, the cast is valid
15: 
16: unique_ptr<BoundCastData> BindToUnionCast(BindCastInput &input, const LogicalType &source, const LogicalType &target) {
17: 	D_ASSERT(target.id() == LogicalTypeId::UNION);
18: 
19: 	vector<UnionBoundCastData> candidates;
20: 
21: 	for (idx_t member_idx = 0; member_idx < UnionType::GetMemberCount(target); member_idx++) {
22: 		auto member_type = UnionType::GetMemberType(target, member_idx);
23: 		auto member_name = UnionType::GetMemberName(target, member_idx);
24: 		auto member_cast_cost = input.function_set.ImplicitCastCost(source, member_type);
25: 		if (member_cast_cost != -1) {
26: 			auto member_cast_info = input.GetCastFunction(source, member_type);
27: 			candidates.emplace_back(member_idx, member_name, member_type, member_cast_cost,
28: 			                        std::move(member_cast_info));
29: 		}
30: 	};
31: 
32: 	// no possible casts found!
33: 	if (candidates.empty()) {
34: 		auto message = StringUtil::Format(
35: 		    "Type %s can't be cast as %s. %s can't be implicitly cast to any of the union member types: ",
36: 		    source.ToString(), target.ToString(), source.ToString());
37: 
38: 		auto member_count = UnionType::GetMemberCount(target);
39: 		for (idx_t member_idx = 0; member_idx < member_count; member_idx++) {
40: 			auto member_type = UnionType::GetMemberType(target, member_idx);
41: 			message += member_type.ToString();
42: 			if (member_idx < member_count - 1) {
43: 				message += ", ";
44: 			}
45: 		}
46: 		throw ConversionException(message);
47: 	}
48: 
49: 	// sort the candidate casts by cost
50: 	std::sort(candidates.begin(), candidates.end(), UnionBoundCastData::SortByCostAscending);
51: 
52: 	// select the lowest possible cost cast
53: 	auto &selected_cast = candidates[0];
54: 	auto selected_cost = candidates[0].cost;
55: 
56: 	// check if the cast is ambiguous (2 or more casts have the same cost)
57: 	if (candidates.size() > 1 && candidates[1].cost == selected_cost) {
58: 
59: 		// collect all the ambiguous types
60: 		auto message = StringUtil::Format(
61: 		    "Type %s can't be cast as %s. The cast is ambiguous, multiple possible members in target: ", source,
62: 		    target);
63: 		for (size_t i = 0; i < candidates.size(); i++) {
64: 			if (candidates[i].cost == selected_cost) {
65: 				message += StringUtil::Format("'%s (%s)'", candidates[i].name, candidates[i].type.ToString());
66: 				if (i < candidates.size() - 1) {
67: 					message += ", ";
68: 				}
69: 			}
70: 		}
71: 		message += ". Disambiguate the target type by using the 'union_value(<tag> := <arg>)' function to promote the "
72: 		           "source value to a single member union before casting.";
73: 		throw ConversionException(message);
74: 	}
75: 
76: 	// otherwise, return the selected cast
77: 	return make_uniq<UnionBoundCastData>(std::move(selected_cast));
78: }
79: 
80: unique_ptr<FunctionLocalState> InitToUnionLocalState(CastLocalStateParameters &parameters) {
81: 	auto &cast_data = parameters.cast_data->Cast<UnionBoundCastData>();
82: 	if (!cast_data.member_cast_info.init_local_state) {
83: 		return nullptr;
84: 	}
85: 	CastLocalStateParameters child_parameters(parameters, cast_data.member_cast_info.cast_data);
86: 	return cast_data.member_cast_info.init_local_state(child_parameters);
87: }
88: 
89: static bool ToUnionCast(Vector &source, Vector &result, idx_t count, CastParameters &parameters) {
90: 	D_ASSERT(result.GetType().id() == LogicalTypeId::UNION);
91: 	auto &cast_data = parameters.cast_data->Cast<UnionBoundCastData>();
92: 	auto &selected_member_vector = UnionVector::GetMember(result, cast_data.tag);
93: 
94: 	CastParameters child_parameters(parameters, cast_data.member_cast_info.cast_data, parameters.local_state);
95: 	if (!cast_data.member_cast_info.function(source, selected_member_vector, count, child_parameters)) {
96: 		return false;
97: 	}
98: 
99: 	// cast succeeded, create union vector
100: 	UnionVector::SetToMember(result, cast_data.tag, selected_member_vector, count, true);
101: 
102: 	result.Verify(count);
103: 
104: 	return true;
105: }
106: 
107: BoundCastInfo DefaultCasts::ImplicitToUnionCast(BindCastInput &input, const LogicalType &source,
108:                                                 const LogicalType &target) {
109: 
110: 	D_ASSERT(target.id() == LogicalTypeId::UNION);
111: 	if (StructToUnionCast::AllowImplicitCastFromStruct(source, target)) {
112: 		return StructToUnionCast::Bind(input, source, target);
113: 	}
114: 	auto cast_data = BindToUnionCast(input, source, target);
115: 	return BoundCastInfo(&ToUnionCast, std::move(cast_data), InitToUnionLocalState);
116: }
117: 
118: //--------------------------------------------------------------------------------------------------
119: // UNION -> UNION
120: //--------------------------------------------------------------------------------------------------
121: // if the source member tags is a subset of the target member tags, and all the source members can be
122: // implicitly cast to the corresponding target members, the cast is valid.
123: //
124: // VALID: 	UNION(A, B) 	-> 	UNION(A, B, C)
125: // VALID: 	UNION(A, B) 	-> 	UNION(A, C)		if B can be implicitly cast to C
126: //
127: // INVALID: UNION(A, B, C)	->	UNION(A, B)
128: // INVALID:	UNION(A, B) 	->	UNION(A, C)		if B can't be implicitly cast to C
129: // INVALID:	UNION(A, B, D) 	->	UNION(A, B, C)
130: 
131: struct UnionUnionBoundCastData : public BoundCastData {
132: 
133: 	// mapping from source member index to target member index
134: 	// these are always the same size as the source member count
135: 	// (since all source members must be present in the target)
136: 	vector<idx_t> tag_map;
137: 	vector<BoundCastInfo> member_casts;
138: 
139: 	LogicalType target_type;
140: 
141: 	UnionUnionBoundCastData(vector<idx_t> tag_map, vector<BoundCastInfo> member_casts, LogicalType target_type)
142: 	    : tag_map(std::move(tag_map)), member_casts(std::move(member_casts)), target_type(std::move(target_type)) {
143: 	}
144: 
145: public:
146: 	unique_ptr<BoundCastData> Copy() const override {
147: 		vector<BoundCastInfo> member_casts_copy;
148: 		for (auto &member_cast : member_casts) {
149: 			member_casts_copy.push_back(member_cast.Copy());
150: 		}
151: 		return make_uniq<UnionUnionBoundCastData>(tag_map, std::move(member_casts_copy), target_type);
152: 	}
153: };
154: 
155: unique_ptr<BoundCastData> BindUnionToUnionCast(BindCastInput &input, const LogicalType &source,
156:                                                const LogicalType &target) {
157: 	D_ASSERT(source.id() == LogicalTypeId::UNION);
158: 	D_ASSERT(target.id() == LogicalTypeId::UNION);
159: 
160: 	auto source_member_count = UnionType::GetMemberCount(source);
161: 
162: 	auto tag_map = vector<idx_t>(source_member_count);
163: 	auto member_casts = vector<BoundCastInfo>();
164: 
165: 	for (idx_t source_idx = 0; source_idx < source_member_count; source_idx++) {
166: 		auto &source_member_type = UnionType::GetMemberType(source, source_idx);
167: 		auto &source_member_name = UnionType::GetMemberName(source, source_idx);
168: 
169: 		bool found = false;
170: 		for (idx_t target_idx = 0; target_idx < UnionType::GetMemberCount(target); target_idx++) {
171: 			auto &target_member_name = UnionType::GetMemberName(target, target_idx);
172: 
173: 			// found a matching member
174: 			if (source_member_name == target_member_name) {
175: 				auto &target_member_type = UnionType::GetMemberType(target, target_idx);
176: 				tag_map[source_idx] = target_idx;
177: 				member_casts.push_back(input.GetCastFunction(source_member_type, target_member_type));
178: 				found = true;
179: 				break;
180: 			}
181: 		}
182: 		if (!found) {
183: 			// no matching member tag found in the target set
184: 			auto message =
185: 			    StringUtil::Format("Type %s can't be cast as %s. The member '%s' is not present in target union",
186: 			                       source.ToString(), target.ToString(), source_member_name);
187: 			throw ConversionException(message);
188: 		}
189: 	}
190: 
191: 	return make_uniq<UnionUnionBoundCastData>(tag_map, std::move(member_casts), target);
192: }
193: 
194: unique_ptr<FunctionLocalState> InitUnionToUnionLocalState(CastLocalStateParameters &parameters) {
195: 	auto &cast_data = parameters.cast_data->Cast<UnionUnionBoundCastData>();
196: 	auto result = make_uniq<StructCastLocalState>();
197: 
198: 	for (auto &entry : cast_data.member_casts) {
199: 		unique_ptr<FunctionLocalState> child_state;
200: 		if (entry.init_local_state) {
201: 			CastLocalStateParameters child_params(parameters, entry.cast_data);
202: 			child_state = entry.init_local_state(child_params);
203: 		}
204: 		result->local_states.push_back(std::move(child_state));
205: 	}
206: 	return std::move(result);
207: }
208: 
209: static bool UnionToUnionCast(Vector &source, Vector &result, idx_t count, CastParameters &parameters) {
210: 	auto &cast_data = parameters.cast_data->Cast<UnionUnionBoundCastData>();
211: 	auto &lstate = parameters.local_state->Cast<StructCastLocalState>();
212: 
213: 	auto source_member_count = UnionType::GetMemberCount(source.GetType());
214: 	auto target_member_count = UnionType::GetMemberCount(result.GetType());
215: 
216: 	auto target_member_is_mapped = vector<bool>(target_member_count);
217: 
218: 	// Perform the casts from source to target members
219: 	for (idx_t member_idx = 0; member_idx < source_member_count; member_idx++) {
220: 		auto target_member_idx = cast_data.tag_map[member_idx];
221: 
222: 		auto &source_member_vector = UnionVector::GetMember(source, member_idx);
223: 		auto &target_member_vector = UnionVector::GetMember(result, target_member_idx);
224: 		auto &member_cast = cast_data.member_casts[member_idx];
225: 
226: 		CastParameters child_parameters(parameters, member_cast.cast_data, lstate.local_states[member_idx]);
227: 		if (!member_cast.function(source_member_vector, target_member_vector, count, child_parameters)) {
228: 			return false;
229: 		}
230: 
231: 		target_member_is_mapped[target_member_idx] = true;
232: 	}
233: 
234: 	// All member casts succeeded!
235: 
236: 	// Set the unmapped target members to constant NULL.
237: 	// If we cast UNION(A, B) -> UNION(A, B, C) we need to invalidate C so that
238: 	// the invariants of the result union hold. (only member columns "selected"
239: 	// by the rowwise corresponding tag in the tag vector should be valid)
240: 	for (idx_t target_member_idx = 0; target_member_idx < target_member_count; target_member_idx++) {
241: 		if (!target_member_is_mapped[target_member_idx]) {
242: 			auto &target_member_vector = UnionVector::GetMember(result, target_member_idx);
243: 			target_member_vector.SetVectorType(VectorType::CONSTANT_VECTOR);
244: 			ConstantVector::SetNull(target_member_vector, true);
245: 		}
246: 	}
247: 
248: 	// Update the tags in the result vector
249: 	auto &source_tag_vector = UnionVector::GetTags(source);
250: 	auto &result_tag_vector = UnionVector::GetTags(result);
251: 
252: 	if (source.GetVectorType() == VectorType::CONSTANT_VECTOR) {
253: 		// Constant vector case optimization
254: 		result.SetVectorType(VectorType::CONSTANT_VECTOR);
255: 		if (ConstantVector::IsNull(source)) {
256: 			ConstantVector::SetNull(result, true);
257: 		} else {
258: 			// map the tag
259: 			auto source_tag = ConstantVector::GetData<union_tag_t>(source_tag_vector)[0];
260: 			auto mapped_tag = cast_data.tag_map[source_tag];
261: 			ConstantVector::GetData<union_tag_t>(result_tag_vector)[0] = UnsafeNumericCast<union_tag_t>(mapped_tag);
262: 		}
263: 	} else {
264: 		// Otherwise, use the unified vector format to access the source vector.
265: 
266: 		// Ensure that all the result members are flat vectors
267: 		// This is not always the case, e.g. when a member is cast using the default TryNullCast function
268: 		// the resulting member vector will be a constant null vector.
269: 		for (idx_t target_member_idx = 0; target_member_idx < target_member_count; target_member_idx++) {
270: 			UnionVector::GetMember(result, target_member_idx).Flatten(count);
271: 		}
272: 
273: 		// We assume that a union tag vector validity matches the union vector validity.
274: 		UnifiedVectorFormat source_tag_format;
275: 		source_tag_vector.ToUnifiedFormat(count, source_tag_format);
276: 
277: 		for (idx_t row_idx = 0; row_idx < count; row_idx++) {
278: 			auto source_row_idx = source_tag_format.sel->get_index(row_idx);
279: 			if (source_tag_format.validity.RowIsValid(source_row_idx)) {
280: 				// map the tag
281: 				auto source_tag = (UnifiedVectorFormat::GetData<union_tag_t>(source_tag_format))[source_row_idx];
282: 				auto target_tag = cast_data.tag_map[source_tag];
283: 				FlatVector::GetData<union_tag_t>(result_tag_vector)[row_idx] =
284: 				    UnsafeNumericCast<union_tag_t>(target_tag);
285: 			} else {
286: 
287: 				// Issue: The members of the result is not always flatvectors
288: 				// In the case of TryNullCast, the result member is constant.
289: 				FlatVector::SetNull(result, row_idx, true);
290: 			}
291: 		}
292: 	}
293: 
294: 	result.Verify(count);
295: 
296: 	return true;
297: }
298: 
299: static bool UnionToVarcharCast(Vector &source, Vector &result, idx_t count, CastParameters &parameters) {
300: 	auto constant = source.GetVectorType() == VectorType::CONSTANT_VECTOR;
301: 	// first cast all union members to varchar
302: 	auto &cast_data = parameters.cast_data->Cast<UnionUnionBoundCastData>();
303: 	Vector varchar_union(cast_data.target_type, count);
304: 
305: 	UnionToUnionCast(source, varchar_union, count, parameters);
306: 
307: 	// now construct the actual varchar vector
308: 	// varchar_union.Flatten(count);
309: 	auto &tag_vector = UnionVector::GetTags(varchar_union);
310: 	UnifiedVectorFormat tag_format;
311: 	tag_vector.ToUnifiedFormat(count, tag_format);
312: 
313: 	auto result_data = FlatVector::GetData<string_t>(result);
314: 
315: 	for (idx_t i = 0; i < count; i++) {
316: 		auto tag_idx = tag_format.sel->get_index(i);
317: 		if (!tag_format.validity.RowIsValid(tag_idx)) {
318: 			FlatVector::SetNull(result, i, true);
319: 			continue;
320: 		}
321: 
322: 		auto tag = UnifiedVectorFormat::GetData<union_tag_t>(tag_format)[tag_idx];
323: 		auto &member = UnionVector::GetMember(varchar_union, tag);
324: 		UnifiedVectorFormat member_vdata;
325: 		member.ToUnifiedFormat(count, member_vdata);
326: 		auto mapped_idx = member_vdata.sel->get_index(i);
327: 		auto member_valid = member_vdata.validity.RowIsValid(mapped_idx);
328: 		if (member_valid) {
329: 			auto member_str = (UnifiedVectorFormat::GetData<string_t>(member_vdata))[mapped_idx];
330: 			result_data[i] = StringVector::AddString(result, member_str);
331: 		} else {
332: 			result_data[i] = StringVector::AddString(result, "NULL");
333: 		}
334: 	}
335: 
336: 	if (constant) {
337: 		result.SetVectorType(VectorType::CONSTANT_VECTOR);
338: 	}
339: 
340: 	result.Verify(count);
341: 	return true;
342: }
343: 
344: BoundCastInfo DefaultCasts::UnionCastSwitch(BindCastInput &input, const LogicalType &source,
345:                                             const LogicalType &target) {
346: 	D_ASSERT(source.id() == LogicalTypeId::UNION);
347: 	switch (target.id()) {
348: 	case LogicalTypeId::VARCHAR: {
349: 		// bind a cast in which we convert all members to VARCHAR first
350: 		child_list_t<LogicalType> varchar_members;
351: 		for (idx_t member_idx = 0; member_idx < UnionType::GetMemberCount(source); member_idx++) {
352: 			varchar_members.push_back(make_pair(UnionType::GetMemberName(source, member_idx), LogicalType::VARCHAR));
353: 		}
354: 		auto varchar_type = LogicalType::UNION(std::move(varchar_members));
355: 		return BoundCastInfo(UnionToVarcharCast, BindUnionToUnionCast(input, source, varchar_type),
356: 		                     InitUnionToUnionLocalState);
357: 	}
358: 	case LogicalTypeId::UNION:
359: 		return BoundCastInfo(UnionToUnionCast, BindUnionToUnionCast(input, source, target), InitUnionToUnionLocalState);
360: 	default:
361: 		return TryVectorNullCast;
362: 	}
363: }
364: 
365: } // namespace duckdb
[end of src/function/cast/union_casts.cpp]
[start of src/function/cast_rules.cpp]
1: #include "duckdb/function/cast_rules.hpp"
2: #include "duckdb/common/numeric_utils.hpp"
3: 
4: namespace duckdb {
5: 
6: //! The target type determines the preferred implicit casts
7: static int64_t TargetTypeCost(const LogicalType &type) {
8: 	switch (type.id()) {
9: 	case LogicalTypeId::BIGINT:
10: 		return 101;
11: 	case LogicalTypeId::INTEGER:
12: 		return 102;
13: 	case LogicalTypeId::HUGEINT:
14: 		return 103;
15: 	case LogicalTypeId::DOUBLE:
16: 		return 104;
17: 	case LogicalTypeId::DECIMAL:
18: 		return 105;
19: 	case LogicalTypeId::TIMESTAMP_NS:
20: 		return 119;
21: 	case LogicalTypeId::TIMESTAMP:
22: 		return 120;
23: 	case LogicalTypeId::TIMESTAMP_MS:
24: 		return 121;
25: 	case LogicalTypeId::TIMESTAMP_SEC:
26: 		return 122;
27: 	case LogicalTypeId::TIMESTAMP_TZ:
28: 		return 123;
29: 	case LogicalTypeId::VARCHAR:
30: 		return 149;
31: 	case LogicalTypeId::STRUCT:
32: 	case LogicalTypeId::MAP:
33: 	case LogicalTypeId::LIST:
34: 	case LogicalTypeId::UNION:
35: 	case LogicalTypeId::ARRAY:
36: 		return 160;
37: 	case LogicalTypeId::ANY:
38: 		return int64_t(AnyType::GetCastScore(type));
39: 	default:
40: 		return 110;
41: 	}
42: }
43: 
44: static int64_t ImplicitCastTinyint(const LogicalType &to) {
45: 	switch (to.id()) {
46: 	case LogicalTypeId::SMALLINT:
47: 	case LogicalTypeId::INTEGER:
48: 	case LogicalTypeId::BIGINT:
49: 	case LogicalTypeId::HUGEINT:
50: 	case LogicalTypeId::FLOAT:
51: 	case LogicalTypeId::DOUBLE:
52: 	case LogicalTypeId::DECIMAL:
53: 		return TargetTypeCost(to);
54: 	default:
55: 		return -1;
56: 	}
57: }
58: 
59: static int64_t ImplicitCastSmallint(const LogicalType &to) {
60: 	switch (to.id()) {
61: 	case LogicalTypeId::INTEGER:
62: 	case LogicalTypeId::BIGINT:
63: 	case LogicalTypeId::HUGEINT:
64: 	case LogicalTypeId::FLOAT:
65: 	case LogicalTypeId::DOUBLE:
66: 	case LogicalTypeId::DECIMAL:
67: 		return TargetTypeCost(to);
68: 	default:
69: 		return -1;
70: 	}
71: }
72: 
73: static int64_t ImplicitCastInteger(const LogicalType &to) {
74: 	switch (to.id()) {
75: 	case LogicalTypeId::BIGINT:
76: 	case LogicalTypeId::HUGEINT:
77: 	case LogicalTypeId::FLOAT:
78: 	case LogicalTypeId::DOUBLE:
79: 	case LogicalTypeId::DECIMAL:
80: 		return TargetTypeCost(to);
81: 	default:
82: 		return -1;
83: 	}
84: }
85: 
86: static int64_t ImplicitCastBigint(const LogicalType &to) {
87: 	switch (to.id()) {
88: 	case LogicalTypeId::FLOAT:
89: 	case LogicalTypeId::DOUBLE:
90: 	case LogicalTypeId::HUGEINT:
91: 	case LogicalTypeId::DECIMAL:
92: 		return TargetTypeCost(to);
93: 	default:
94: 		return -1;
95: 	}
96: }
97: 
98: static int64_t ImplicitCastUTinyint(const LogicalType &to) {
99: 	switch (to.id()) {
100: 	case LogicalTypeId::USMALLINT:
101: 	case LogicalTypeId::UINTEGER:
102: 	case LogicalTypeId::UBIGINT:
103: 	case LogicalTypeId::SMALLINT:
104: 	case LogicalTypeId::INTEGER:
105: 	case LogicalTypeId::BIGINT:
106: 	case LogicalTypeId::HUGEINT:
107: 	case LogicalTypeId::UHUGEINT:
108: 	case LogicalTypeId::FLOAT:
109: 	case LogicalTypeId::DOUBLE:
110: 	case LogicalTypeId::DECIMAL:
111: 		return TargetTypeCost(to);
112: 	default:
113: 		return -1;
114: 	}
115: }
116: 
117: static int64_t ImplicitCastUSmallint(const LogicalType &to) {
118: 	switch (to.id()) {
119: 	case LogicalTypeId::UINTEGER:
120: 	case LogicalTypeId::UBIGINT:
121: 	case LogicalTypeId::INTEGER:
122: 	case LogicalTypeId::BIGINT:
123: 	case LogicalTypeId::HUGEINT:
124: 	case LogicalTypeId::UHUGEINT:
125: 	case LogicalTypeId::FLOAT:
126: 	case LogicalTypeId::DOUBLE:
127: 	case LogicalTypeId::DECIMAL:
128: 		return TargetTypeCost(to);
129: 	default:
130: 		return -1;
131: 	}
132: }
133: 
134: static int64_t ImplicitCastUInteger(const LogicalType &to) {
135: 	switch (to.id()) {
136: 
137: 	case LogicalTypeId::UBIGINT:
138: 	case LogicalTypeId::BIGINT:
139: 	case LogicalTypeId::UHUGEINT:
140: 	case LogicalTypeId::HUGEINT:
141: 	case LogicalTypeId::FLOAT:
142: 	case LogicalTypeId::DOUBLE:
143: 	case LogicalTypeId::DECIMAL:
144: 		return TargetTypeCost(to);
145: 	default:
146: 		return -1;
147: 	}
148: }
149: 
150: static int64_t ImplicitCastUBigint(const LogicalType &to) {
151: 	switch (to.id()) {
152: 	case LogicalTypeId::FLOAT:
153: 	case LogicalTypeId::DOUBLE:
154: 	case LogicalTypeId::UHUGEINT:
155: 	case LogicalTypeId::HUGEINT:
156: 	case LogicalTypeId::DECIMAL:
157: 		return TargetTypeCost(to);
158: 	default:
159: 		return -1;
160: 	}
161: }
162: 
163: static int64_t ImplicitCastFloat(const LogicalType &to) {
164: 	switch (to.id()) {
165: 	case LogicalTypeId::DOUBLE:
166: 		return TargetTypeCost(to);
167: 	default:
168: 		return -1;
169: 	}
170: }
171: 
172: static int64_t ImplicitCastDouble(const LogicalType &to) {
173: 	switch (to.id()) {
174: 	default:
175: 		return -1;
176: 	}
177: }
178: 
179: static int64_t ImplicitCastDecimal(const LogicalType &to) {
180: 	switch (to.id()) {
181: 	case LogicalTypeId::FLOAT:
182: 	case LogicalTypeId::DOUBLE:
183: 		return TargetTypeCost(to);
184: 	default:
185: 		return -1;
186: 	}
187: }
188: 
189: static int64_t ImplicitCastHugeint(const LogicalType &to) {
190: 	switch (to.id()) {
191: 	case LogicalTypeId::FLOAT:
192: 	case LogicalTypeId::DOUBLE:
193: 	case LogicalTypeId::DECIMAL:
194: 		return TargetTypeCost(to);
195: 	default:
196: 		return -1;
197: 	}
198: }
199: 
200: static int64_t ImplicitCastUhugeint(const LogicalType &to) {
201: 	switch (to.id()) {
202: 	case LogicalTypeId::FLOAT:
203: 	case LogicalTypeId::DOUBLE:
204: 	case LogicalTypeId::DECIMAL:
205: 		return TargetTypeCost(to);
206: 	default:
207: 		return -1;
208: 	}
209: }
210: 
211: static int64_t ImplicitCastDate(const LogicalType &to) {
212: 	switch (to.id()) {
213: 	case LogicalTypeId::TIMESTAMP:
214: 	case LogicalTypeId::TIMESTAMP_TZ:
215: 	case LogicalTypeId::TIMESTAMP_MS:
216: 	case LogicalTypeId::TIMESTAMP_NS:
217: 	case LogicalTypeId::TIMESTAMP_SEC:
218: 		return TargetTypeCost(to);
219: 	default:
220: 		return -1;
221: 	}
222: }
223: 
224: static int64_t ImplicitCastEnum(const LogicalType &to) {
225: 	switch (to.id()) {
226: 	case LogicalTypeId::VARCHAR:
227: 		return TargetTypeCost(to);
228: 	default:
229: 		return -1;
230: 	}
231: }
232: 
233: static int64_t ImplicitCastTimestampSec(const LogicalType &to) {
234: 	switch (to.id()) {
235: 	case LogicalTypeId::TIMESTAMP:
236: 	case LogicalTypeId::TIMESTAMP_MS:
237: 	case LogicalTypeId::TIMESTAMP_NS:
238: 		return TargetTypeCost(to);
239: 	default:
240: 		return -1;
241: 	}
242: }
243: 
244: static int64_t ImplicitCastTimestampMS(const LogicalType &to) {
245: 	switch (to.id()) {
246: 	case LogicalTypeId::TIMESTAMP:
247: 	case LogicalTypeId::TIMESTAMP_NS:
248: 		return TargetTypeCost(to);
249: 	default:
250: 		return -1;
251: 	}
252: }
253: 
254: static int64_t ImplicitCastTimestampNS(const LogicalType &to) {
255: 	switch (to.id()) {
256: 	case LogicalTypeId::TIMESTAMP:
257: 		// we allow casting ALL timestamps, including nanosecond ones, to TimestampNS
258: 		return TargetTypeCost(to);
259: 	default:
260: 		return -1;
261: 	}
262: }
263: 
264: static int64_t ImplicitCastTimestamp(const LogicalType &to) {
265: 	switch (to.id()) {
266: 	case LogicalTypeId::TIMESTAMP_NS:
267: 		return TargetTypeCost(to);
268: 	case LogicalTypeId::TIMESTAMP_TZ:
269: 		return TargetTypeCost(to);
270: 	default:
271: 		return -1;
272: 	}
273: }
274: 
275: bool LogicalTypeIsValid(const LogicalType &type) {
276: 	switch (type.id()) {
277: 	case LogicalTypeId::STRUCT:
278: 	case LogicalTypeId::UNION:
279: 	case LogicalTypeId::LIST:
280: 	case LogicalTypeId::MAP:
281: 	case LogicalTypeId::ARRAY:
282: 	case LogicalTypeId::DECIMAL:
283: 		// these types are only valid with auxiliary info
284: 		if (!type.AuxInfo()) {
285: 			return false;
286: 		}
287: 		break;
288: 	default:
289: 		break;
290: 	}
291: 	switch (type.id()) {
292: 	case LogicalTypeId::ANY:
293: 	case LogicalTypeId::INVALID:
294: 	case LogicalTypeId::UNKNOWN:
295: 		return false;
296: 	case LogicalTypeId::STRUCT: {
297: 		auto child_count = StructType::GetChildCount(type);
298: 		for (idx_t i = 0; i < child_count; i++) {
299: 			if (!LogicalTypeIsValid(StructType::GetChildType(type, i))) {
300: 				return false;
301: 			}
302: 		}
303: 		return true;
304: 	}
305: 	case LogicalTypeId::UNION: {
306: 		auto member_count = UnionType::GetMemberCount(type);
307: 		for (idx_t i = 0; i < member_count; i++) {
308: 			if (!LogicalTypeIsValid(UnionType::GetMemberType(type, i))) {
309: 				return false;
310: 			}
311: 		}
312: 		return true;
313: 	}
314: 	case LogicalTypeId::LIST:
315: 	case LogicalTypeId::MAP:
316: 		return LogicalTypeIsValid(ListType::GetChildType(type));
317: 	case LogicalTypeId::ARRAY:
318: 		return LogicalTypeIsValid(ArrayType::GetChildType(type));
319: 	default:
320: 		return true;
321: 	}
322: }
323: 
324: int64_t CastRules::ImplicitCast(const LogicalType &from, const LogicalType &to) {
325: 	if (from.id() == LogicalTypeId::SQLNULL || to.id() == LogicalTypeId::ANY) {
326: 		// NULL expression can be cast to anything
327: 		return TargetTypeCost(to);
328: 	}
329: 	if (from.id() == LogicalTypeId::UNKNOWN) {
330: 		// parameter expression can be cast to anything for no cost
331: 		return 0;
332: 	}
333: 	if (from.id() == LogicalTypeId::STRING_LITERAL) {
334: 		// string literals can be cast to any type for low cost as long as the type is valid
335: 		// i.e. we cannot cast to LIST(ANY) as we don't know what "ANY" should be
336: 		// we cannot cast to DECIMAL without precision/width specified
337: 		if (!LogicalTypeIsValid(to)) {
338: 			return -1;
339: 		}
340: 		if (to.id() == LogicalTypeId::VARCHAR && to.GetAlias().empty()) {
341: 			return 1;
342: 		}
343: 		return 20;
344: 	}
345: 	if (from.id() == LogicalTypeId::INTEGER_LITERAL) {
346: 		// the integer literal has an underlying type - this type always matches
347: 		if (IntegerLiteral::GetType(from).id() == to.id()) {
348: 			return 0;
349: 		}
350: 		// integer literals can be cast to any other integer type for a low cost, but only if the literal fits
351: 		if (IntegerLiteral::FitsInType(from, to)) {
352: 			// to avoid ties we prefer BIGINT, INT, ...
353: 			auto target_cost = TargetTypeCost(to);
354: 			if (target_cost < 100) {
355: 				throw InternalException("Integer literal implicit cast - TargetTypeCost should be >= 100");
356: 			}
357: 			return target_cost - 90;
358: 		}
359: 		// in any other case we use the casting rules of the preferred type of the literal
360: 		return CastRules::ImplicitCast(IntegerLiteral::GetType(from), to);
361: 	}
362: 	if (from.GetAlias() != to.GetAlias()) {
363: 		// if aliases are different, an implicit cast is not possible
364: 		return -1;
365: 	}
366: 	if (from.id() == LogicalTypeId::LIST && to.id() == LogicalTypeId::LIST) {
367: 		// Lists can be cast if their child types can be cast
368: 		auto child_cost = ImplicitCast(ListType::GetChildType(from), ListType::GetChildType(to));
369: 		if (child_cost >= 1) {
370: 			// subtract one from the cost because we prefer LIST[X] -> LIST[VARCHAR] over LIST[X] -> VARCHAR
371: 			child_cost--;
372: 		}
373: 		return child_cost;
374: 	}
375: 	if (from.id() == LogicalTypeId::ARRAY && to.id() == LogicalTypeId::ARRAY) {
376: 		// Arrays can be cast if their child types can be cast and the source and target has the same size
377: 		// or the target type has a unknown (any) size.
378: 		auto from_size = ArrayType::GetSize(from);
379: 		auto to_size = ArrayType::GetSize(to);
380: 		auto to_is_any_size = ArrayType::IsAnySize(to);
381: 		if (from_size == to_size || to_is_any_size) {
382: 			auto child_cost = ImplicitCast(ArrayType::GetChildType(from), ArrayType::GetChildType(to));
383: 			if (child_cost >= 100) {
384: 				// subtract one from the cost because we prefer ARRAY[X] -> ARRAY[VARCHAR] over ARRAY[X] -> VARCHAR
385: 				child_cost--;
386: 			}
387: 			return child_cost;
388: 		}
389: 		return -1; // Not possible if the sizes are different
390: 	}
391: 	if (from.id() == LogicalTypeId::ARRAY && to.id() == LogicalTypeId::LIST) {
392: 		// Arrays can be cast to lists for the cost of casting the child type
393: 		auto child_cost = ImplicitCast(ArrayType::GetChildType(from), ListType::GetChildType(to));
394: 		if (child_cost < 0) {
395: 			return -1;
396: 		}
397: 		// add 1 because we prefer ARRAY->ARRAY casts over ARRAY->LIST casts
398: 		return child_cost + 1;
399: 	}
400: 	if (from.id() == LogicalTypeId::LIST && (to.id() == LogicalTypeId::ARRAY && !ArrayType::IsAnySize(to))) {
401: 		// Lists can be cast to arrays for the cost of casting the child type, if the target size is known
402: 		// there is no way for us to resolve the size at bind-time without inspecting the list values.
403: 		// TODO: if we can access the expression we could resolve the size if the list is constant.
404: 		return ImplicitCast(ListType::GetChildType(from), ArrayType::GetChildType(to));
405: 	}
406: 	if (from.id() == to.id()) {
407: 		// arguments match: do nothing
408: 		return 0;
409: 	}
410: 
411: 	if (from.id() == LogicalTypeId::UNION && to.id() == LogicalTypeId::UNION) {
412: 		// Unions can be cast if the source tags are a subset of the target tags
413: 		// in which case the most expensive cost is used
414: 		int cost = -1;
415: 		for (idx_t from_member_idx = 0; from_member_idx < UnionType::GetMemberCount(from); from_member_idx++) {
416: 			auto &from_member_name = UnionType::GetMemberName(from, from_member_idx);
417: 
418: 			bool found = false;
419: 			for (idx_t to_member_idx = 0; to_member_idx < UnionType::GetMemberCount(to); to_member_idx++) {
420: 				auto &to_member_name = UnionType::GetMemberName(to, to_member_idx);
421: 
422: 				if (from_member_name == to_member_name) {
423: 					auto &from_member_type = UnionType::GetMemberType(from, from_member_idx);
424: 					auto &to_member_type = UnionType::GetMemberType(to, to_member_idx);
425: 
426: 					int child_cost = NumericCast<int>(ImplicitCast(from_member_type, to_member_type));
427: 					if (child_cost > cost) {
428: 						cost = child_cost;
429: 					}
430: 					found = true;
431: 					break;
432: 				}
433: 			}
434: 			if (!found) {
435: 				return -1;
436: 			}
437: 		}
438: 		return cost;
439: 	}
440: 
441: 	if (to.id() == LogicalTypeId::UNION) {
442: 		// check that the union type is fully resolved.
443: 		if (to.AuxInfo() == nullptr) {
444: 			return -1;
445: 		}
446: 		// every type can be implicitly be cast to a union if the source type is a member of the union
447: 		for (idx_t i = 0; i < UnionType::GetMemberCount(to); i++) {
448: 			auto member = UnionType::GetMemberType(to, i);
449: 			if (from == member) {
450: 				return 0;
451: 			}
452: 		}
453: 	}
454: 
455: 	switch (from.id()) {
456: 	case LogicalTypeId::TINYINT:
457: 		return ImplicitCastTinyint(to);
458: 	case LogicalTypeId::SMALLINT:
459: 		return ImplicitCastSmallint(to);
460: 	case LogicalTypeId::INTEGER:
461: 		return ImplicitCastInteger(to);
462: 	case LogicalTypeId::BIGINT:
463: 		return ImplicitCastBigint(to);
464: 	case LogicalTypeId::UTINYINT:
465: 		return ImplicitCastUTinyint(to);
466: 	case LogicalTypeId::USMALLINT:
467: 		return ImplicitCastUSmallint(to);
468: 	case LogicalTypeId::UINTEGER:
469: 		return ImplicitCastUInteger(to);
470: 	case LogicalTypeId::UBIGINT:
471: 		return ImplicitCastUBigint(to);
472: 	case LogicalTypeId::HUGEINT:
473: 		return ImplicitCastHugeint(to);
474: 	case LogicalTypeId::UHUGEINT:
475: 		return ImplicitCastUhugeint(to);
476: 	case LogicalTypeId::FLOAT:
477: 		return ImplicitCastFloat(to);
478: 	case LogicalTypeId::DOUBLE:
479: 		return ImplicitCastDouble(to);
480: 	case LogicalTypeId::DATE:
481: 		return ImplicitCastDate(to);
482: 	case LogicalTypeId::DECIMAL:
483: 		return ImplicitCastDecimal(to);
484: 	case LogicalTypeId::ENUM:
485: 		return ImplicitCastEnum(to);
486: 	case LogicalTypeId::TIMESTAMP_SEC:
487: 		return ImplicitCastTimestampSec(to);
488: 	case LogicalTypeId::TIMESTAMP_MS:
489: 		return ImplicitCastTimestampMS(to);
490: 	case LogicalTypeId::TIMESTAMP_NS:
491: 		return ImplicitCastTimestampNS(to);
492: 	case LogicalTypeId::TIMESTAMP:
493: 		return ImplicitCastTimestamp(to);
494: 	default:
495: 		return -1;
496: 	}
497: }
498: 
499: } // namespace duckdb
[end of src/function/cast_rules.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: