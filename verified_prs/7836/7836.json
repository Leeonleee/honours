{
  "repo": "duckdb/duckdb",
  "pull_number": 7836,
  "instance_id": "duckdb__duckdb-7836",
  "issue_numbers": [
    "7733"
  ],
  "base_commit": "ae0f13744b519f18f2d34a5b73f7439c21e7e6d9",
  "patch": "diff --git a/src/include/duckdb/optimizer/unnest_rewriter.hpp b/src/include/duckdb/optimizer/unnest_rewriter.hpp\nindex 4d6d9a93cd7a..d51a00800a67 100644\n--- a/src/include/duckdb/optimizer/unnest_rewriter.hpp\n+++ b/src/include/duckdb/optimizer/unnest_rewriter.hpp\n@@ -45,6 +45,8 @@ class UnnestRewriterPlanUpdater : LogicalOperatorVisitor {\n \n \t//! Contains all bindings that need to be updated\n \tvector<ReplaceBinding> replace_bindings;\n+\t//! Stores the table index of the former child of the LOGICAL_UNNEST\n+\tidx_t overwritten_tbl_idx;\n };\n \n //! The UnnestRewriter optimizer traverses the logical operator tree and rewrites duplicate\n@@ -79,6 +81,8 @@ class UnnestRewriter {\n \tvector<LHSBinding> lhs_bindings;\n \t//! Stores the table index of the former child of the LOGICAL_UNNEST\n \tidx_t overwritten_tbl_idx;\n+\t//! The number of distinct columns to unnest\n+\tidx_t distinct_unnest_count;\n };\n \n } // namespace duckdb\ndiff --git a/src/optimizer/unnest_rewriter.cpp b/src/optimizer/unnest_rewriter.cpp\nindex e14f11019a97..34836e664d25 100644\n--- a/src/optimizer/unnest_rewriter.cpp\n+++ b/src/optimizer/unnest_rewriter.cpp\n@@ -26,11 +26,7 @@ void UnnestRewriterPlanUpdater::VisitExpression(unique_ptr<Expression> *expressi\n \t\tfor (idx_t i = 0; i < replace_bindings.size(); i++) {\n \t\t\tif (bound_column_ref.binding == replace_bindings[i].old_binding) {\n \t\t\t\tbound_column_ref.binding = replace_bindings[i].new_binding;\n-\t\t\t}\n-\t\t\t// previously pointing to the LOGICAL_DELIM_GET\n-\t\t\tif (bound_column_ref.binding.table_index == replace_bindings[i].old_binding.table_index &&\n-\t\t\t    replace_bindings[i].old_binding.column_index == DConstants::INVALID_INDEX) {\n-\t\t\t\tbound_column_ref.binding = replace_bindings[i].new_binding;\n+\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t}\n@@ -49,6 +45,7 @@ unique_ptr<LogicalOperator> UnnestRewriter::Optimize(unique_ptr<LogicalOperator>\n \n \t\t// rearrange the logical operators\n \t\tif (RewriteCandidate(candidate)) {\n+\t\t\tupdater.overwritten_tbl_idx = overwritten_tbl_idx;\n \t\t\t// update the bindings of the BOUND_UNNEST expression\n \t\t\tUpdateBoundUnnestBindings(updater, candidate);\n \t\t\t// update the sequence of LOGICAL_PROJECTION(s)\n@@ -106,7 +103,6 @@ void UnnestRewriter::FindCandidates(unique_ptr<LogicalOperator> *op_ptr,\n \tif (curr_op->get()->type == LogicalOperatorType::LOGICAL_UNNEST) {\n \t\tcandidates.push_back(op_ptr);\n \t}\n-\treturn;\n }\n \n bool UnnestRewriter::RewriteCandidate(unique_ptr<LogicalOperator> *candidate) {\n@@ -147,6 +143,11 @@ bool UnnestRewriter::RewriteCandidate(unique_ptr<LogicalOperator> *candidate) {\n \tauto &unnest = curr_op->get()->Cast<LogicalUnnest>();\n \tD_ASSERT(unnest.children[0]->type == LogicalOperatorType::LOGICAL_DELIM_GET);\n \toverwritten_tbl_idx = unnest.children[0]->Cast<LogicalDelimGet>().table_index;\n+\n+\tD_ASSERT(!unnest.children.empty());\n+\tauto &delim_get = unnest.children[0]->Cast<LogicalDelimGet>();\n+\tD_ASSERT(delim_get.chunk_types.size() > 1);\n+\tdistinct_unnest_count = delim_get.chunk_types.size();\n \tunnest.children[0] = std::move(lhs_op);\n \n \t// replace the LOGICAL_DELIM_JOIN with its RHS child operator\n@@ -168,10 +169,11 @@ void UnnestRewriter::UpdateRHSBindings(unique_ptr<LogicalOperator> *plan_ptr, un\n \t\tD_ASSERT(curr_op->get()->type == LogicalOperatorType::LOGICAL_PROJECTION);\n \t\tauto &proj = curr_op->get()->Cast<LogicalProjection>();\n \n-\t\t// pop the two last expressions from all projections (delim_idx and UNNEST column)\n-\t\tD_ASSERT(proj.expressions.size() > 2);\n-\t\tproj.expressions.pop_back();\n-\t\tproj.expressions.pop_back();\n+\t\t// pop the unnest columns and the delim index\n+\t\tD_ASSERT(proj.expressions.size() > distinct_unnest_count);\n+\t\tfor (idx_t i = 0; i < distinct_unnest_count; i++) {\n+\t\t\tproj.expressions.pop_back();\n+\t\t}\n \n \t\t// store all shifted current bindings\n \t\tidx_t tbl_idx = proj.table_index;\n@@ -263,14 +265,23 @@ void UnnestRewriter::UpdateBoundUnnestBindings(UnnestRewriterPlanUpdater &update\n \tauto &unnest = curr_op->get()->Cast<LogicalUnnest>();\n \n \tD_ASSERT(unnest.children.size() == 1);\n-\tauto unnest_child_cols = unnest.children[0]->GetColumnBindings();\n-\tfor (idx_t delim_col_idx = 0; delim_col_idx < delim_columns.size(); delim_col_idx++) {\n-\t\tfor (idx_t child_col_idx = 0; child_col_idx < unnest_child_cols.size(); child_col_idx++) {\n-\t\t\tif (delim_columns[delim_col_idx].table_index == unnest_child_cols[child_col_idx].table_index) {\n-\t\t\t\tColumnBinding old_binding(overwritten_tbl_idx, DConstants::INVALID_INDEX);\n-\t\t\t\tupdater.replace_bindings.emplace_back(old_binding, delim_columns[delim_col_idx]);\n+\tauto unnest_cols = unnest.children[0]->GetColumnBindings();\n+\n+\tfor (idx_t i = 0; i < delim_columns.size(); i++) {\n+\t\tauto delim_binding = delim_columns[i];\n+\n+\t\tauto unnest_it = unnest_cols.begin();\n+\t\twhile (unnest_it != unnest_cols.end()) {\n+\t\t\tauto unnest_binding = *unnest_it;\n+\n+\t\t\tif (delim_binding.table_index == unnest_binding.table_index) {\n+\t\t\t\tunnest_binding.table_index = overwritten_tbl_idx;\n+\t\t\t\tunnest_binding.column_index++;\n+\t\t\t\tupdater.replace_bindings.emplace_back(unnest_binding, delim_binding);\n+\t\t\t\tunnest_cols.erase(unnest_it);\n \t\t\t\tbreak;\n \t\t\t}\n+\t\t\tunnest_it++;\n \t\t}\n \t}\n \n",
  "test_patch": "diff --git a/test/optimizer/unnest_rewriter.test b/test/optimizer/unnest_rewriter.test\nindex dfe8f5cc9ac6..f5821a41cabd 100644\n--- a/test/optimizer/unnest_rewriter.test\n+++ b/test/optimizer/unnest_rewriter.test\n@@ -147,4 +147,69 @@ ORDER BY foo, u2;\n 1\t[1.0, 2.0, 3.0]\t3.0\t3\n 2\t[4.0, 5.0, 6.0]\t4.0\t1\n 2\t[4.0, 5.0, 6.0]\t5.0\t2\n-2\t[4.0, 5.0, 6.0]\t6.0\t3\n\\ No newline at end of file\n+2\t[4.0, 5.0, 6.0]\t6.0\t3\n+\n+# test issue 7733\n+\n+statement ok\n+CREATE TABLE tbl_ints AS SELECT ARRAY[1, 2, 3] AS col_a, ARRAY[6] AS col_b;\n+\n+statement ok\n+INSERT INTO tbl_ints VALUES (ARRAY[4, 5], ARRAY[7, 8]);\n+\n+query II\n+SELECT new_a, new_b\n+FROM tbl_ints, LATERAL (SELECT UNNEST(col_a) new_a, UNNEST(col_b) new_b FROM tbl_ints) g\n+ORDER BY 1, 2\n+----\n+1\t6\n+1\t6\n+2\tNULL\n+2\tNULL\n+3\tNULL\n+3\tNULL\n+4\t7\n+4\t7\n+5\t8\n+5\t8\n+\n+query II\n+SELECT new_a, new_b\n+FROM tbl_ints, LATERAL (SELECT UNNEST(col_a) new_a, UNNEST(col_b) new_b) g\n+ORDER BY 1\n+----\n+1\t6\n+2\tNULL\n+3\tNULL\n+4\t7\n+5\t8\n+\n+statement ok\n+CREATE TABLE tbl_mix AS SELECT ARRAY[1, 2, 3] AS col_a, ARRAY['a'] AS col_b;\n+\n+statement ok\n+INSERT INTO tbl_mix VALUES (ARRAY[4, 5], ARRAY['b', 'c']);\n+\n+query IIII\n+SELECT * FROM tbl_mix, LATERAL (SELECT UNNEST(tbl_mix.col_a) new_a, UNNEST(tbl_mix.col_b) new_b) g\n+ORDER BY new_a;\n+----\n+[1, 2, 3]\t[a]\t1\ta\n+[1, 2, 3]\t[a]\t2\tNULL\n+[1, 2, 3]\t[a]\t3\tNULL\n+[4, 5]\t[b, c]\t4\tb\n+[4, 5]\t[b, c]\t5\tc\n+\n+# test issue 7792\n+\n+query III\n+WITH tbl AS (SELECT [{'a': 1, 'b': 'oh no!'}] AS c)\n+SELECT a, b, c FROM tbl, (SELECT UNNEST(c, recursive := TRUE));\n+----\n+1\toh no!\t[{'a': 1, 'b': oh no!}]\n+\n+query III\n+WITH tbl AS (SELECT [{'a': 1, 'b': 2}] as c)\n+SELECT a, b, c FROM tbl, (SELECT UNNEST(c, recursive := TRUE));\n+----\n+1\t2\t[{'a': 1, 'b': 2}]\n\\ No newline at end of file\n",
  "problem_statement": "Internal Binding Error on Lateral JOIN\n### What happens?\r\n\r\nRaised in #7732 by @l1t1, the following query results in an internal error:\r\n\r\n```sql\r\nWITH abc AS (\r\n     SELECT UNNEST([[1, 2, 3], [4, 5]]) AS A, UNNEST([[6], [7, 8]]) AS B\r\n )\r\n SELECT newa, newb\r\n FROM abc,\r\n lateral (select unnest(a) newa, unnest(b) newb );\r\n```\r\n\r\nError is \r\n\r\n```\r\nError: INTERNAL Error: Failed to bind column reference \"delim_index\" [23.0] (bindings: [1.0 15.0 15.1])\r\n```\r\n\r\n### To Reproduce\r\n\r\nSee above \r\n\r\n### OS:\r\n\r\nOSX\r\n\r\n### DuckDB Version:\r\n\r\ndev\r\n\r\n### DuckDB Client:\r\n\r\nCLI\r\n\r\n### Full Name:\r\n\r\nHannes M\u00fchleisen\r\n\r\n### Affiliation:\r\n\r\nDuckDB Labs\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\n",
  "hints_text": "",
  "created_at": "2023-06-06T08:55:03Z",
  "modified_files": [
    "src/include/duckdb/optimizer/unnest_rewriter.hpp",
    "src/optimizer/unnest_rewriter.cpp"
  ]
}