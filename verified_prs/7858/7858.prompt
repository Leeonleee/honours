You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
`Error: Binder Error: Referenced table "unnamed_subquery1" not found!` in UNPIVOT with a SELECT expression
### What happens?

When performing an UNPIVOT on a SELECT expression (rather than just a table name, as in the [examples](https://duckdb.org/docs/sql/statements/unpivot#unpivot-manually), duckdb gives the following error:
```
Error: Binder Error: Referenced table "unnamed_subquery1" not found!
Candidate tables: "unnamed_subquery8"
```

### To Reproduce

```sql
CREATE OR REPLACE TABLE monthly_sales(empid INT, dept TEXT, Jan INT, Feb INT, Mar INT, Apr INT, May INT, Jun INT);
INSERT INTO monthly_sales VALUES
(1, 'electronics', 1, 2, 3, 4, 5, 6),
(2, 'clothes', 10, 20, 30, 40, 50, 60),
(3, 'cars', 100, 200, 300, 400, 500, 600);

-- works as intended
UNPIVOT monthly_sales
    ON jan, feb, mar, apr, may, jun
    INTO
        NAME month
        VALUE sales;

-- complains about missing unnamed_subquery
UNPIVOT (SELECT * FROM monthly_sales)
    ON jan, feb, mar, apr, may, jun
    INTO
        NAME month
        VALUE sales;
```

### OS:

macOS 13.1 (arm64)

### DuckDB Version:

v0.8.0 e8e4cea5ec

### DuckDB Client:

CLI

### Full Name:

Jonathan Shi

### Affiliation:

Ponder Data

### Have you tried this on the latest `master` branch?

- [X] I agree

### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?

- [X] I agree
`Error: Binder Error: Referenced table "unnamed_subquery1" not found!` in UNPIVOT with a SELECT expression
### What happens?

When performing an UNPIVOT on a SELECT expression (rather than just a table name, as in the [examples](https://duckdb.org/docs/sql/statements/unpivot#unpivot-manually), duckdb gives the following error:
```
Error: Binder Error: Referenced table "unnamed_subquery1" not found!
Candidate tables: "unnamed_subquery8"
```

### To Reproduce

```sql
CREATE OR REPLACE TABLE monthly_sales(empid INT, dept TEXT, Jan INT, Feb INT, Mar INT, Apr INT, May INT, Jun INT);
INSERT INTO monthly_sales VALUES
(1, 'electronics', 1, 2, 3, 4, 5, 6),
(2, 'clothes', 10, 20, 30, 40, 50, 60),
(3, 'cars', 100, 200, 300, 400, 500, 600);

-- works as intended
UNPIVOT monthly_sales
    ON jan, feb, mar, apr, may, jun
    INTO
        NAME month
        VALUE sales;

-- complains about missing unnamed_subquery
UNPIVOT (SELECT * FROM monthly_sales)
    ON jan, feb, mar, apr, may, jun
    INTO
        NAME month
        VALUE sales;
```

### OS:

macOS 13.1 (arm64)

### DuckDB Version:

v0.8.0 e8e4cea5ec

### DuckDB Client:

CLI

### Full Name:

Jonathan Shi

### Affiliation:

Ponder Data

### Have you tried this on the latest `master` branch?

- [X] I agree

### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?

- [X] I agree

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=master" alt="Github Actions Badge">
9:   </a>
10:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
11:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
12:   </a>
13:   <a href="https://discord.gg/tcvwpjfnZx">
14:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
15:   </a>
16:   <a href="https://github.com/duckdb/duckdb/releases/">
17:     <img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release">
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The detail of benchmarks is in our [Benchmark Guide](benchmark/README.md).
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
[end of README.md]
[start of src/planner/binder/tableref/bind_pivot.cpp]
1: #include "duckdb/planner/binder.hpp"
2: #include "duckdb/parser/tableref/pivotref.hpp"
3: #include "duckdb/parser/tableref/subqueryref.hpp"
4: #include "duckdb/parser/query_node/select_node.hpp"
5: #include "duckdb/parser/expression/case_expression.hpp"
6: #include "duckdb/parser/expression/cast_expression.hpp"
7: #include "duckdb/parser/expression/columnref_expression.hpp"
8: #include "duckdb/parser/expression/comparison_expression.hpp"
9: #include "duckdb/parser/expression/conjunction_expression.hpp"
10: #include "duckdb/parser/expression/constant_expression.hpp"
11: #include "duckdb/parser/expression/function_expression.hpp"
12: #include "duckdb/planner/query_node/bound_select_node.hpp"
13: #include "duckdb/parser/expression/star_expression.hpp"
14: #include "duckdb/common/types/value_map.hpp"
15: #include "duckdb/parser/parsed_expression_iterator.hpp"
16: #include "duckdb/parser/expression/operator_expression.hpp"
17: #include "duckdb/planner/tableref/bound_subqueryref.hpp"
18: #include "duckdb/planner/tableref/bound_pivotref.hpp"
19: #include "duckdb/planner/expression/bound_aggregate_expression.hpp"
20: #include "duckdb/main/client_config.hpp"
21: 
22: namespace duckdb {
23: 
24: static void ConstructPivots(PivotRef &ref, vector<PivotValueElement> &pivot_values, idx_t pivot_idx = 0,
25:                             const PivotValueElement &current_value = PivotValueElement()) {
26: 	auto &pivot = ref.pivots[pivot_idx];
27: 	bool last_pivot = pivot_idx + 1 == ref.pivots.size();
28: 	for (auto &entry : pivot.entries) {
29: 		PivotValueElement new_value = current_value;
30: 		string name = entry.alias;
31: 		D_ASSERT(entry.values.size() == pivot.pivot_expressions.size());
32: 		for (idx_t v = 0; v < entry.values.size(); v++) {
33: 			auto &value = entry.values[v];
34: 			new_value.values.push_back(value);
35: 			if (entry.alias.empty()) {
36: 				if (name.empty()) {
37: 					name = value.ToString();
38: 				} else {
39: 					name += "_" + value.ToString();
40: 				}
41: 			}
42: 		}
43: 		if (!current_value.name.empty()) {
44: 			new_value.name = current_value.name + "_" + name;
45: 		} else {
46: 			new_value.name = std::move(name);
47: 		}
48: 		if (last_pivot) {
49: 			pivot_values.push_back(std::move(new_value));
50: 		} else {
51: 			// need to recurse
52: 			ConstructPivots(ref, pivot_values, pivot_idx + 1, new_value);
53: 		}
54: 	}
55: }
56: 
57: static void ExtractPivotExpressions(ParsedExpression &expr, case_insensitive_set_t &handled_columns) {
58: 	if (expr.type == ExpressionType::COLUMN_REF) {
59: 		auto &child_colref = expr.Cast<ColumnRefExpression>();
60: 		if (child_colref.IsQualified()) {
61: 			throw BinderException("PIVOT expression cannot contain qualified columns");
62: 		}
63: 		handled_columns.insert(child_colref.GetColumnName());
64: 	}
65: 	ParsedExpressionIterator::EnumerateChildren(
66: 	    expr, [&](ParsedExpression &child) { ExtractPivotExpressions(child, handled_columns); });
67: }
68: 
69: struct PivotBindState {
70: 	vector<string> internal_group_names;
71: 	vector<string> group_names;
72: 	vector<string> aggregate_names;
73: 	vector<string> internal_aggregate_names;
74: };
75: 
76: static unique_ptr<SelectNode> PivotInitialAggregate(PivotBindState &bind_state, PivotRef &ref,
77:                                                     vector<unique_ptr<ParsedExpression>> all_columns,
78:                                                     const case_insensitive_set_t &handled_columns) {
79: 	auto subquery_stage1 = make_uniq<SelectNode>();
80: 	subquery_stage1->from_table = std::move(ref.source);
81: 	if (ref.groups.empty()) {
82: 		// if rows are not specified any columns that are not pivoted/aggregated on are added to the GROUP BY clause
83: 		for (auto &entry : all_columns) {
84: 			if (entry->type != ExpressionType::COLUMN_REF) {
85: 				throw InternalException("Unexpected child of pivot source - not a ColumnRef");
86: 			}
87: 			auto &columnref = entry->Cast<ColumnRefExpression>();
88: 			if (handled_columns.find(columnref.GetColumnName()) == handled_columns.end()) {
89: 				// not handled - add to grouping set
90: 				subquery_stage1->groups.group_expressions.push_back(
91: 				    make_uniq<ConstantExpression>(Value::INTEGER(subquery_stage1->select_list.size() + 1)));
92: 				subquery_stage1->select_list.push_back(make_uniq<ColumnRefExpression>(columnref.GetColumnName()));
93: 			}
94: 		}
95: 	} else {
96: 		// if rows are specified only the columns mentioned in rows are added as groups
97: 		for (auto &row : ref.groups) {
98: 			subquery_stage1->groups.group_expressions.push_back(
99: 			    make_uniq<ConstantExpression>(Value::INTEGER(subquery_stage1->select_list.size() + 1)));
100: 			subquery_stage1->select_list.push_back(make_uniq<ColumnRefExpression>(row));
101: 		}
102: 	}
103: 	idx_t group_count = 0;
104: 	for (auto &expr : subquery_stage1->select_list) {
105: 		bind_state.group_names.push_back(expr->GetName());
106: 		if (expr->alias.empty()) {
107: 			expr->alias = "__internal_pivot_group" + std::to_string(++group_count);
108: 		}
109: 		bind_state.internal_group_names.push_back(expr->alias);
110: 	}
111: 	// group by all of the pivot values
112: 	idx_t pivot_count = 0;
113: 	for (auto &pivot_column : ref.pivots) {
114: 		for (auto &pivot_expr : pivot_column.pivot_expressions) {
115: 			if (pivot_expr->alias.empty()) {
116: 				pivot_expr->alias = "__internal_pivot_ref" + std::to_string(++pivot_count);
117: 			}
118: 			auto pivot_alias = pivot_expr->alias;
119: 			subquery_stage1->groups.group_expressions.push_back(
120: 			    make_uniq<ConstantExpression>(Value::INTEGER(subquery_stage1->select_list.size() + 1)));
121: 			subquery_stage1->select_list.push_back(std::move(pivot_expr));
122: 			pivot_expr = make_uniq<ColumnRefExpression>(std::move(pivot_alias));
123: 		}
124: 	}
125: 	idx_t aggregate_count = 0;
126: 	// finally add the aggregates
127: 	for (auto &aggregate : ref.aggregates) {
128: 		auto aggregate_alias = "__internal_pivot_aggregate" + std::to_string(++aggregate_count);
129: 		bind_state.aggregate_names.push_back(aggregate->alias);
130: 		bind_state.internal_aggregate_names.push_back(aggregate_alias);
131: 		aggregate->alias = std::move(aggregate_alias);
132: 		subquery_stage1->select_list.push_back(std::move(aggregate));
133: 	}
134: 	return subquery_stage1;
135: }
136: 
137: static unique_ptr<SelectNode> PivotListAggregate(PivotBindState &bind_state, PivotRef &ref,
138:                                                  unique_ptr<SelectNode> subquery_stage1) {
139: 	auto subquery_stage2 = make_uniq<SelectNode>();
140: 	// wrap the subquery of stage 1
141: 	auto subquery_select = make_uniq<SelectStatement>();
142: 	subquery_select->node = std::move(subquery_stage1);
143: 	auto subquery_ref = make_uniq<SubqueryRef>(std::move(subquery_select));
144: 
145: 	// add all of the groups
146: 	for (idx_t gr = 0; gr < bind_state.internal_group_names.size(); gr++) {
147: 		subquery_stage2->groups.group_expressions.push_back(
148: 		    make_uniq<ConstantExpression>(Value::INTEGER(subquery_stage2->select_list.size() + 1)));
149: 		auto group_reference = make_uniq<ColumnRefExpression>(bind_state.internal_group_names[gr]);
150: 		group_reference->alias = bind_state.internal_group_names[gr];
151: 		subquery_stage2->select_list.push_back(std::move(group_reference));
152: 	}
153: 
154: 	// construct the list aggregates
155: 	for (idx_t aggr = 0; aggr < bind_state.internal_aggregate_names.size(); aggr++) {
156: 		auto colref = make_uniq<ColumnRefExpression>(bind_state.internal_aggregate_names[aggr]);
157: 		vector<unique_ptr<ParsedExpression>> list_children;
158: 		list_children.push_back(std::move(colref));
159: 		auto aggregate = make_uniq<FunctionExpression>("list", std::move(list_children));
160: 		aggregate->alias = bind_state.internal_aggregate_names[aggr];
161: 		subquery_stage2->select_list.push_back(std::move(aggregate));
162: 	}
163: 	// construct the pivot list
164: 	auto pivot_name = "__internal_pivot_name";
165: 	unique_ptr<ParsedExpression> expr;
166: 	for (auto &pivot : ref.pivots) {
167: 		for (auto &pivot_expr : pivot.pivot_expressions) {
168: 			// coalesce(pivot::VARCHAR, 'NULL')
169: 			auto cast = make_uniq<CastExpression>(LogicalType::VARCHAR, std::move(pivot_expr));
170: 			vector<unique_ptr<ParsedExpression>> coalesce_children;
171: 			coalesce_children.push_back(std::move(cast));
172: 			coalesce_children.push_back(make_uniq<ConstantExpression>(Value("NULL")));
173: 			auto coalesce =
174: 			    make_uniq<OperatorExpression>(ExpressionType::OPERATOR_COALESCE, std::move(coalesce_children));
175: 
176: 			if (!expr) {
177: 				expr = std::move(coalesce);
178: 			} else {
179: 				// string concat
180: 				vector<unique_ptr<ParsedExpression>> concat_children;
181: 				concat_children.push_back(std::move(expr));
182: 				concat_children.push_back(make_uniq<ConstantExpression>(Value("_")));
183: 				concat_children.push_back(std::move(coalesce));
184: 				auto concat = make_uniq<FunctionExpression>("concat", std::move(concat_children));
185: 				expr = std::move(concat);
186: 			}
187: 		}
188: 	}
189: 	// list(coalesce)
190: 	vector<unique_ptr<ParsedExpression>> list_children;
191: 	list_children.push_back(std::move(expr));
192: 	auto aggregate = make_uniq<FunctionExpression>("list", std::move(list_children));
193: 
194: 	aggregate->alias = pivot_name;
195: 	subquery_stage2->select_list.push_back(std::move(aggregate));
196: 
197: 	subquery_stage2->from_table = std::move(subquery_ref);
198: 	return subquery_stage2;
199: }
200: 
201: static unique_ptr<SelectNode> PivotFinalOperator(PivotBindState &bind_state, PivotRef &ref,
202:                                                  unique_ptr<SelectNode> subquery,
203:                                                  vector<PivotValueElement> pivot_values) {
204: 	auto final_pivot_operator = make_uniq<SelectNode>();
205: 	// wrap the subquery of stage 1
206: 	auto subquery_select = make_uniq<SelectStatement>();
207: 	subquery_select->node = std::move(subquery);
208: 	auto subquery_ref = make_uniq<SubqueryRef>(std::move(subquery_select));
209: 
210: 	auto bound_pivot = make_uniq<PivotRef>();
211: 	bound_pivot->bound_pivot_values = std::move(pivot_values);
212: 	bound_pivot->bound_group_names = std::move(bind_state.group_names);
213: 	bound_pivot->bound_aggregate_names = std::move(bind_state.aggregate_names);
214: 	bound_pivot->source = std::move(subquery_ref);
215: 
216: 	final_pivot_operator->select_list.push_back(make_uniq<StarExpression>());
217: 	final_pivot_operator->from_table = std::move(bound_pivot);
218: 	return final_pivot_operator;
219: }
220: 
221: void ExtractPivotAggregates(BoundTableRef &node, vector<unique_ptr<Expression>> &aggregates) {
222: 	if (node.type != TableReferenceType::SUBQUERY) {
223: 		throw InternalException("Pivot - Expected a subquery");
224: 	}
225: 	auto &subq = node.Cast<BoundSubqueryRef>();
226: 	if (subq.subquery->type != QueryNodeType::SELECT_NODE) {
227: 		throw InternalException("Pivot - Expected a select node");
228: 	}
229: 	auto &select = subq.subquery->Cast<BoundSelectNode>();
230: 	if (select.from_table->type != TableReferenceType::SUBQUERY) {
231: 		throw InternalException("Pivot - Expected another subquery");
232: 	}
233: 	auto &subq2 = select.from_table->Cast<BoundSubqueryRef>();
234: 	if (subq2.subquery->type != QueryNodeType::SELECT_NODE) {
235: 		throw InternalException("Pivot - Expected another select node");
236: 	}
237: 	auto &select2 = subq2.subquery->Cast<BoundSelectNode>();
238: 	for (auto &aggr : select2.aggregates) {
239: 		aggregates.push_back(aggr->Copy());
240: 	}
241: }
242: 
243: unique_ptr<BoundTableRef> Binder::BindBoundPivot(PivotRef &ref) {
244: 	// bind the child table in a child binder
245: 	auto result = make_uniq<BoundPivotRef>();
246: 	result->bind_index = GenerateTableIndex();
247: 	result->child_binder = Binder::CreateBinder(context, this);
248: 	result->child = result->child_binder->Bind(*ref.source);
249: 
250: 	auto &aggregates = result->bound_pivot.aggregates;
251: 	ExtractPivotAggregates(*result->child, aggregates);
252: 	if (aggregates.size() != ref.bound_aggregate_names.size()) {
253: 		throw BinderException("Pivot aggregate count mismatch. Expected %llu aggregates but found %llu. Are all pivot "
254: 		                      "expressions aggregate functions?",
255: 		                      ref.bound_aggregate_names.size(), aggregates.size());
256: 	}
257: 
258: 	vector<string> child_names;
259: 	vector<LogicalType> child_types;
260: 	result->child_binder->bind_context.GetTypesAndNames(child_names, child_types);
261: 
262: 	vector<string> names;
263: 	vector<LogicalType> types;
264: 	// emit the groups
265: 	for (idx_t i = 0; i < ref.bound_group_names.size(); i++) {
266: 		names.push_back(ref.bound_group_names[i]);
267: 		types.push_back(child_types[i]);
268: 	}
269: 	// emit the pivot columns
270: 	for (auto &pivot_value : ref.bound_pivot_values) {
271: 		for (idx_t aggr_idx = 0; aggr_idx < ref.bound_aggregate_names.size(); aggr_idx++) {
272: 			auto &aggr = aggregates[aggr_idx];
273: 			auto &aggr_name = ref.bound_aggregate_names[aggr_idx];
274: 			auto name = pivot_value.name;
275: 			if (aggregates.size() > 1 || !aggr_name.empty()) {
276: 				// if there are multiple aggregates specified we add the name of the aggregate as well
277: 				name += "_" + (aggr_name.empty() ? aggr->GetName() : aggr_name);
278: 			}
279: 			string pivot_str;
280: 			for (auto &value : pivot_value.values) {
281: 				auto str = value.ToString();
282: 				if (pivot_str.empty()) {
283: 					pivot_str = std::move(str);
284: 				} else {
285: 					pivot_str += "_" + str;
286: 				}
287: 			}
288: 			result->bound_pivot.pivot_values.push_back(std::move(pivot_str));
289: 			names.push_back(std::move(name));
290: 			types.push_back(aggr->return_type);
291: 		}
292: 	}
293: 	result->bound_pivot.group_count = ref.bound_group_names.size();
294: 	result->bound_pivot.types = types;
295: 	auto subquery_alias = ref.alias.empty() ? "__unnamed_pivot" : ref.alias;
296: 	bind_context.AddGenericBinding(result->bind_index, subquery_alias, names, types);
297: 	MoveCorrelatedExpressions(*result->child_binder);
298: 	return std::move(result);
299: }
300: 
301: unique_ptr<SelectNode> Binder::BindPivot(PivotRef &ref, vector<unique_ptr<ParsedExpression>> all_columns) {
302: 	// keep track of the columns by which we pivot/aggregate
303: 	// any columns which are not pivoted/aggregated on are added to the GROUP BY clause
304: 	case_insensitive_set_t handled_columns;
305: 	// parse the aggregate, and extract the referenced columns from the aggregate
306: 	for (auto &aggr : ref.aggregates) {
307: 		if (aggr->type != ExpressionType::FUNCTION) {
308: 			throw BinderException(FormatError(*aggr, "Pivot expression must be an aggregate"));
309: 		}
310: 		if (aggr->HasSubquery()) {
311: 			throw BinderException(FormatError(*aggr, "Pivot expression cannot contain subqueries"));
312: 		}
313: 		if (aggr->IsWindow()) {
314: 			throw BinderException(FormatError(*aggr, "Pivot expression cannot contain window functions"));
315: 		}
316: 		ExtractPivotExpressions(*aggr, handled_columns);
317: 	}
318: 	value_set_t pivots;
319: 
320: 	// first add all pivots to the set of handled columns, and check for duplicates
321: 	idx_t total_pivots = 1;
322: 	for (auto &pivot : ref.pivots) {
323: 		if (!pivot.pivot_enum.empty()) {
324: 			auto type = Catalog::GetType(context, INVALID_CATALOG, INVALID_SCHEMA, pivot.pivot_enum);
325: 			if (type.id() != LogicalTypeId::ENUM) {
326: 				throw BinderException(
327: 				    FormatError(ref, StringUtil::Format("Pivot must reference an ENUM type: \"%s\" is of type \"%s\"",
328: 				                                        pivot.pivot_enum, type.ToString())));
329: 			}
330: 			auto enum_size = EnumType::GetSize(type);
331: 			for (idx_t i = 0; i < enum_size; i++) {
332: 				auto enum_value = EnumType::GetValue(Value::ENUM(i, type));
333: 				PivotColumnEntry entry;
334: 				entry.values.emplace_back(enum_value);
335: 				entry.alias = std::move(enum_value);
336: 				pivot.entries.push_back(std::move(entry));
337: 			}
338: 		}
339: 		total_pivots *= pivot.entries.size();
340: 		// add the pivoted column to the columns that have been handled
341: 		for (auto &pivot_name : pivot.pivot_expressions) {
342: 			ExtractPivotExpressions(*pivot_name, handled_columns);
343: 		}
344: 		value_set_t pivots;
345: 		for (auto &entry : pivot.entries) {
346: 			D_ASSERT(!entry.star_expr);
347: 			Value val;
348: 			if (entry.values.size() == 1) {
349: 				val = entry.values[0];
350: 			} else {
351: 				val = Value::LIST(LogicalType::VARCHAR, entry.values);
352: 			}
353: 			if (pivots.find(val) != pivots.end()) {
354: 				throw BinderException(FormatError(
355: 				    ref, StringUtil::Format("The value \"%s\" was specified multiple times in the IN clause",
356: 				                            val.ToString())));
357: 			}
358: 			if (entry.values.size() != pivot.pivot_expressions.size()) {
359: 				throw ParserException("PIVOT IN list - inconsistent amount of rows - expected %d but got %d",
360: 				                      pivot.pivot_expressions.size(), entry.values.size());
361: 			}
362: 			pivots.insert(val);
363: 		}
364: 	}
365: 	auto pivot_limit = ClientConfig::GetConfig(context).pivot_limit;
366: 	if (total_pivots >= pivot_limit) {
367: 		throw BinderException("Pivot column limit of %llu exceeded. Use SET pivot_limit=X to increase the limit.",
368: 		                      ClientConfig::GetConfig(context).pivot_limit);
369: 	}
370: 
371: 	// construct the required pivot values recursively
372: 	vector<PivotValueElement> pivot_values;
373: 	ConstructPivots(ref, pivot_values);
374: 
375: 	// pivots have three components
376: 	// - the pivots (i.e. future column names)
377: 	// - the groups (i.e. the future row names
378: 	// - the aggregates (i.e. the values of the pivot columns)
379: 
380: 	// executing a pivot statement happens in three stages
381: 	// 1) execute the query "SELECT {groups}, {pivots}, {aggregates} FROM {from_clause} GROUP BY {groups}, {pivots}
382: 	// this computes all values that are required in the final result, but not yet in the correct orientation
383: 	// 2) execute the query "SELECT {groups}, LIST({pivots}), LIST({aggregates}) FROM [Q1] GROUP BY {groups}
384: 	// this pushes all pivots and aggregates that belong to a specific group together in an aligned manner
385: 	// 3) push a PIVOT operator, that performs the actual pivoting of the values into the different columns
386: 
387: 	PivotBindState bind_state;
388: 	// Pivot Stage 1
389: 	// SELECT {groups}, {pivots}, {aggregates} FROM {from_clause} GROUP BY {groups}, {pivots}
390: 	auto subquery_stage1 = PivotInitialAggregate(bind_state, ref, std::move(all_columns), handled_columns);
391: 
392: 	// Pivot stage 2
393: 	// SELECT {groups}, LIST({pivots}), LIST({aggregates}) FROM [Q1] GROUP BY {groups}
394: 	auto subquery_stage2 = PivotListAggregate(bind_state, ref, std::move(subquery_stage1));
395: 
396: 	// Pivot stage 3
397: 	// construct the final pivot operator
398: 	auto pivot_node = PivotFinalOperator(bind_state, ref, std::move(subquery_stage2), std::move(pivot_values));
399: 	return pivot_node;
400: }
401: 
402: unique_ptr<SelectNode> Binder::BindUnpivot(Binder &child_binder, PivotRef &ref,
403:                                            vector<unique_ptr<ParsedExpression>> all_columns,
404:                                            unique_ptr<ParsedExpression> &where_clause) {
405: 	D_ASSERT(ref.groups.empty());
406: 	D_ASSERT(ref.pivots.size() == 1);
407: 
408: 	unique_ptr<ParsedExpression> expr;
409: 	auto select_node = make_uniq<SelectNode>();
410: 	select_node->from_table = std::move(ref.source);
411: 
412: 	// handle the pivot
413: 	auto &unpivot = ref.pivots[0];
414: 
415: 	// handle star expressions in any entries
416: 	vector<PivotColumnEntry> new_entries;
417: 	for (auto &entry : unpivot.entries) {
418: 		if (entry.star_expr) {
419: 			D_ASSERT(entry.values.empty());
420: 			vector<unique_ptr<ParsedExpression>> star_columns;
421: 			child_binder.ExpandStarExpression(std::move(entry.star_expr), star_columns);
422: 
423: 			for (auto &col : star_columns) {
424: 				if (col->type != ExpressionType::COLUMN_REF) {
425: 					throw InternalException("Unexpected child of unpivot star - not a ColumnRef");
426: 				}
427: 				auto &columnref = col->Cast<ColumnRefExpression>();
428: 				PivotColumnEntry new_entry;
429: 				new_entry.values.emplace_back(columnref.GetColumnName());
430: 				new_entry.alias = columnref.GetColumnName();
431: 				new_entries.push_back(std::move(new_entry));
432: 			}
433: 		} else {
434: 			new_entries.push_back(std::move(entry));
435: 		}
436: 	}
437: 	unpivot.entries = std::move(new_entries);
438: 
439: 	case_insensitive_set_t handled_columns;
440: 	case_insensitive_map_t<string> name_map;
441: 	for (auto &entry : unpivot.entries) {
442: 		for (auto &value : entry.values) {
443: 			handled_columns.insert(value.ToString());
444: 		}
445: 	}
446: 
447: 	for (auto &col_expr : all_columns) {
448: 		if (col_expr->type != ExpressionType::COLUMN_REF) {
449: 			throw InternalException("Unexpected child of pivot source - not a ColumnRef");
450: 		}
451: 		auto &columnref = col_expr->Cast<ColumnRefExpression>();
452: 		auto &column_name = columnref.GetColumnName();
453: 		auto entry = handled_columns.find(column_name);
454: 		if (entry == handled_columns.end()) {
455: 			// not handled - add to the set of regularly selected columns
456: 			select_node->select_list.push_back(std::move(col_expr));
457: 		} else {
458: 			name_map[column_name] = column_name;
459: 			handled_columns.erase(entry);
460: 		}
461: 	}
462: 	if (!handled_columns.empty()) {
463: 		for (auto &entry : handled_columns) {
464: 			throw BinderException("Column \"%s\" referenced in UNPIVOT but no matching entry was found in the table",
465: 			                      entry);
466: 		}
467: 	}
468: 	vector<Value> unpivot_names;
469: 	for (auto &entry : unpivot.entries) {
470: 		string generated_name;
471: 		for (auto &val : entry.values) {
472: 			auto name_entry = name_map.find(val.ToString());
473: 			if (name_entry == name_map.end()) {
474: 				throw InternalException("Unpivot - could not find column name in name map");
475: 			}
476: 			if (!generated_name.empty()) {
477: 				generated_name += "_";
478: 			}
479: 			generated_name += name_entry->second;
480: 		}
481: 		unpivot_names.emplace_back(!entry.alias.empty() ? entry.alias : generated_name);
482: 	}
483: 	vector<vector<unique_ptr<ParsedExpression>>> unpivot_expressions;
484: 	for (idx_t v_idx = 1; v_idx < unpivot.entries.size(); v_idx++) {
485: 		if (unpivot.entries[v_idx].values.size() != unpivot.entries[0].values.size()) {
486: 			throw BinderException(
487: 			    "UNPIVOT value count mismatch - entry has %llu values, but expected all entries to have %llu values",
488: 			    unpivot.entries[v_idx].values.size(), unpivot.entries[0].values.size());
489: 		}
490: 	}
491: 
492: 	for (idx_t v_idx = 0; v_idx < unpivot.entries[0].values.size(); v_idx++) {
493: 		vector<unique_ptr<ParsedExpression>> expressions;
494: 		expressions.reserve(unpivot.entries.size());
495: 		for (auto &entry : unpivot.entries) {
496: 			expressions.push_back(make_uniq<ColumnRefExpression>(entry.values[v_idx].ToString()));
497: 		}
498: 		unpivot_expressions.push_back(std::move(expressions));
499: 	}
500: 
501: 	// construct the UNNEST expression for the set of names (constant)
502: 	auto unpivot_list = Value::LIST(LogicalType::VARCHAR, std::move(unpivot_names));
503: 	auto unpivot_name_expr = make_uniq<ConstantExpression>(std::move(unpivot_list));
504: 	vector<unique_ptr<ParsedExpression>> unnest_name_children;
505: 	unnest_name_children.push_back(std::move(unpivot_name_expr));
506: 	auto unnest_name_expr = make_uniq<FunctionExpression>("unnest", std::move(unnest_name_children));
507: 	unnest_name_expr->alias = unpivot.unpivot_names[0];
508: 	select_node->select_list.push_back(std::move(unnest_name_expr));
509: 
510: 	// construct the UNNEST expression for the set of unpivoted columns
511: 	if (ref.unpivot_names.size() != unpivot_expressions.size()) {
512: 		throw BinderException("UNPIVOT name count mismatch - got %d names but %d expressions", ref.unpivot_names.size(),
513: 		                      unpivot_expressions.size());
514: 	}
515: 	for (idx_t i = 0; i < unpivot_expressions.size(); i++) {
516: 		auto list_expr = make_uniq<FunctionExpression>("list_value", std::move(unpivot_expressions[i]));
517: 		vector<unique_ptr<ParsedExpression>> unnest_val_children;
518: 		unnest_val_children.push_back(std::move(list_expr));
519: 		auto unnest_val_expr = make_uniq<FunctionExpression>("unnest", std::move(unnest_val_children));
520: 		auto unnest_name = i < ref.column_name_alias.size() ? ref.column_name_alias[i] : ref.unpivot_names[i];
521: 		unnest_val_expr->alias = unnest_name;
522: 		select_node->select_list.push_back(std::move(unnest_val_expr));
523: 		if (!ref.include_nulls) {
524: 			// if we are running with EXCLUDE NULLS we need to add an IS NOT NULL filter
525: 			auto colref = make_uniq<ColumnRefExpression>(unnest_name);
526: 			auto filter = make_uniq<OperatorExpression>(ExpressionType::OPERATOR_IS_NOT_NULL, std::move(colref));
527: 			if (where_clause) {
528: 				where_clause = make_uniq<ConjunctionExpression>(ExpressionType::CONJUNCTION_AND,
529: 				                                                std::move(where_clause), std::move(filter));
530: 			} else {
531: 				where_clause = std::move(filter);
532: 			}
533: 		}
534: 	}
535: 	return select_node;
536: }
537: 
538: unique_ptr<BoundTableRef> Binder::Bind(PivotRef &ref) {
539: 	if (!ref.source) {
540: 		throw InternalException("Pivot without a source!?");
541: 	}
542: 	if (!ref.bound_pivot_values.empty() || !ref.bound_group_names.empty() || !ref.bound_aggregate_names.empty()) {
543: 		// bound pivot
544: 		return BindBoundPivot(ref);
545: 	}
546: 
547: 	// bind the source of the pivot
548: 	// we need to do this to be able to expand star expressions
549: 	auto copied_source = ref.source->Copy();
550: 	auto star_binder = Binder::CreateBinder(context, this);
551: 	star_binder->Bind(*copied_source);
552: 
553: 	// figure out the set of column names that are in the source of the pivot
554: 	vector<unique_ptr<ParsedExpression>> all_columns;
555: 	star_binder->ExpandStarExpression(make_uniq<StarExpression>(), all_columns);
556: 
557: 	unique_ptr<SelectNode> select_node;
558: 	unique_ptr<ParsedExpression> where_clause;
559: 	if (!ref.aggregates.empty()) {
560: 		select_node = BindPivot(ref, std::move(all_columns));
561: 	} else {
562: 		select_node = BindUnpivot(*star_binder, ref, std::move(all_columns), where_clause);
563: 	}
564: 	// bind the generated select node
565: 	auto child_binder = Binder::CreateBinder(context, this);
566: 	auto bound_select_node = child_binder->BindNode(*select_node);
567: 	auto root_index = bound_select_node->GetRootIndex();
568: 	BoundQueryNode *bound_select_ptr = bound_select_node.get();
569: 
570: 	unique_ptr<BoundTableRef> result;
571: 	MoveCorrelatedExpressions(*child_binder);
572: 	result = make_uniq<BoundSubqueryRef>(std::move(child_binder), std::move(bound_select_node));
573: 	auto subquery_alias = ref.alias.empty() ? "__unnamed_pivot" : ref.alias;
574: 	SubqueryRef subquery_ref(nullptr, subquery_alias);
575: 	subquery_ref.column_name_alias = std::move(ref.column_name_alias);
576: 	if (where_clause) {
577: 		// if a WHERE clause was provided - bind a subquery holding the WHERE clause
578: 		// we need to bind a new subquery here because the WHERE clause has to be applied AFTER the unnest
579: 		child_binder = Binder::CreateBinder(context, this);
580: 		child_binder->bind_context.AddSubquery(root_index, subquery_ref.alias, subquery_ref, *bound_select_ptr);
581: 		auto where_query = make_uniq<SelectNode>();
582: 		where_query->select_list.push_back(make_uniq<StarExpression>());
583: 		where_query->where_clause = std::move(where_clause);
584: 		bound_select_node = child_binder->BindSelectNode(*where_query, std::move(result));
585: 		bound_select_ptr = bound_select_node.get();
586: 		root_index = bound_select_node->GetRootIndex();
587: 		result = make_uniq<BoundSubqueryRef>(std::move(child_binder), std::move(bound_select_node));
588: 	}
589: 	bind_context.AddSubquery(root_index, subquery_ref.alias, subquery_ref, *bound_select_ptr);
590: 	return result;
591: }
592: 
593: } // namespace duckdb
[end of src/planner/binder/tableref/bind_pivot.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: