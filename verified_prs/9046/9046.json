{
  "repo": "duckdb/duckdb",
  "pull_number": 9046,
  "instance_id": "duckdb__duckdb-9046",
  "issue_numbers": [
    "9002"
  ],
  "base_commit": "7ffdb9fd0e5e17d1638796c5352fbc839da4da5d",
  "patch": "diff --git a/src/core_functions/scalar/map/map.cpp b/src/core_functions/scalar/map/map.cpp\nindex b4c5669a73f2..c56d15f9dad6 100644\n--- a/src/core_functions/scalar/map/map.cpp\n+++ b/src/core_functions/scalar/map/map.cpp\n@@ -87,11 +87,24 @@ static bool ListEntriesEqual(Vector &keys, Vector &values, idx_t count) {\n \treturn true;\n }\n \n+static list_entry_t *GetBiggestList(Vector &key, Vector &value, idx_t &size) {\n+\tauto key_size = ListVector::GetListSize(key);\n+\tauto value_size = ListVector::GetListSize(value);\n+\tif (key_size > value_size) {\n+\t\tsize = key_size;\n+\t\treturn ListVector::GetData(key);\n+\t}\n+\tsize = value_size;\n+\treturn ListVector::GetData(value);\n+}\n+\n static void MapFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n \tD_ASSERT(result.GetType().id() == LogicalTypeId::MAP);\n \n-\tauto &key_vector = MapVector::GetKeys(result);\n-\tauto &value_vector = MapVector::GetValues(result);\n+\tauto count = args.size();\n+\n+\tauto &map_key_vector = MapVector::GetKeys(result);\n+\tauto &map_value_vector = MapVector::GetValues(result);\n \tauto result_data = ListVector::GetData(result);\n \n \tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n@@ -99,52 +112,73 @@ static void MapFunction(DataChunk &args, ExpressionState &state, Vector &result)\n \t\tListVector::SetListSize(result, 0);\n \t\tresult_data->offset = 0;\n \t\tresult_data->length = 0;\n-\t\tresult.Verify(args.size());\n+\t\tresult.Verify(count);\n \t\treturn;\n \t}\n \n-\tbool keys_are_const = args.data[0].GetVectorType() == VectorType::CONSTANT_VECTOR;\n-\tbool values_are_const = args.data[1].GetVectorType() == VectorType::CONSTANT_VECTOR;\n-\tif (!keys_are_const || !values_are_const) {\n-\t\tresult.SetVectorType(VectorType::FLAT_VECTOR);\n+\tD_ASSERT(args.ColumnCount() == 2);\n+\tauto &key_vector = args.data[0];\n+\tauto &value_vector = args.data[1];\n+\n+\tif (args.AllConstant()) {\n+\t\tauto key_data = ListVector::GetData(key_vector);\n+\t\tauto value_data = ListVector::GetData(value_vector);\n+\t\tauto key_entry = key_data[0];\n+\t\tauto value_entry = value_data[0];\n+\t\tif (key_entry != value_entry) {\n+\t\t\tthrow BinderException(\"Key and value list sizes don't match\");\n+\t\t}\n+\t\tresult_data[0] = key_entry;\n+\t\tListVector::SetListSize(result, ListVector::GetListSize(key_vector));\n+\t\tmap_key_vector.Reference(ListVector::GetEntry(key_vector));\n+\t\tmap_value_vector.Reference(ListVector::GetEntry(value_vector));\n+\t\tMapVector::MapConversionVerify(result, count);\n+\t\tresult.Verify(count);\n+\t\treturn;\n \t}\n \n-\tauto key_count = ListVector::GetListSize(args.data[0]);\n-\tauto value_count = ListVector::GetListSize(args.data[1]);\n-\tauto key_data = ListVector::GetData(args.data[0]);\n-\tauto value_data = ListVector::GetData(args.data[1]);\n-\tauto src_data = key_data;\n-\n-\tif (keys_are_const && !values_are_const) {\n-\t\tAlignVectorToReference(args.data[0], args.data[1], args.size(), key_vector);\n-\t\tsrc_data = value_data;\n-\t} else if (values_are_const && !keys_are_const) {\n-\t\tAlignVectorToReference(args.data[1], args.data[0], args.size(), value_vector);\n+\tresult.SetVectorType(VectorType::FLAT_VECTOR);\n+\n+\tif (key_vector.GetVectorType() == VectorType::CONSTANT_VECTOR) {\n+\t\tD_ASSERT(value_vector.GetVectorType() != VectorType::CONSTANT_VECTOR);\n+\t\tVector expanded_const(ListType::GetChildType(key_vector.GetType()), count);\n+\t\tAlignVectorToReference(key_vector, value_vector, count, expanded_const);\n+\t\tmap_key_vector.Reference(expanded_const);\n+\n+\t\tvalue_vector.Flatten(count);\n+\t\tmap_value_vector.Reference(ListVector::GetEntry(value_vector));\n+\t} else if (value_vector.GetVectorType() == VectorType::CONSTANT_VECTOR) {\n+\t\tD_ASSERT(key_vector.GetVectorType() != VectorType::CONSTANT_VECTOR);\n+\t\tVector expanded_const(ListType::GetChildType(value_vector.GetType()), count);\n+\t\tAlignVectorToReference(value_vector, key_vector, count, expanded_const);\n+\t\tmap_value_vector.Reference(expanded_const);\n+\n+\t\tkey_vector.Flatten(count);\n+\t\tmap_key_vector.Reference(ListVector::GetEntry(key_vector));\n \t} else {\n-\t\tif (!ListEntriesEqual(args.data[0], args.data[1], args.size())) {\n+\t\tkey_vector.Flatten(count);\n+\t\tvalue_vector.Flatten(count);\n+\n+\t\tif (!ListEntriesEqual(key_vector, value_vector, count)) {\n \t\t\tthrow InvalidInputException(\"Error in MAP creation: key list and value list do not align. i.e. different \"\n \t\t\t                            \"size or incompatible structure\");\n \t\t}\n+\n+\t\tmap_value_vector.Reference(ListVector::GetEntry(value_vector));\n+\t\tmap_key_vector.Reference(ListVector::GetEntry(key_vector));\n \t}\n \n-\tListVector::SetListSize(result, MaxValue(key_count, value_count));\n+\tidx_t list_size;\n+\tauto src_data = GetBiggestList(key_vector, value_vector, list_size);\n+\tListVector::SetListSize(result, list_size);\n \n \tresult_data = ListVector::GetData(result);\n-\tfor (idx_t i = 0; i < args.size(); i++) {\n+\tfor (idx_t i = 0; i < count; i++) {\n \t\tresult_data[i] = src_data[i];\n \t}\n \n-\t// check whether one of the vectors has already been referenced to an expanded vector in the case of const/non-const\n-\t// combination. If not, then referencing is still necessary\n-\tif (!(keys_are_const && !values_are_const)) {\n-\t\tkey_vector.Reference(ListVector::GetEntry(args.data[0]));\n-\t}\n-\tif (!(values_are_const && !keys_are_const)) {\n-\t\tvalue_vector.Reference(ListVector::GetEntry(args.data[1]));\n-\t}\n-\n-\tMapVector::MapConversionVerify(result, args.size());\n-\tresult.Verify(args.size());\n+\tMapVector::MapConversionVerify(result, count);\n+\tresult.Verify(count);\n }\n \n static unique_ptr<FunctionData> MapBind(ClientContext &context, ScalarFunction &bound_function,\n",
  "test_patch": "diff --git a/test/sql/types/nested/map/test_map_vector_types.test b/test/sql/types/nested/map/test_map_vector_types.test\nnew file mode 100644\nindex 000000000000..35d791cdf591\n--- /dev/null\n+++ b/test/sql/types/nested/map/test_map_vector_types.test\n@@ -0,0 +1,82 @@\n+# name: test/sql/types/nested/map/test_map_vector_types.test\n+# group: [map]\n+\n+statement ok\n+pragma enable_verification;\n+\n+statement ok\n+create macro input() as table\n+\tselect *\n+\tfrom test_vector_types(NULL::INTEGER[]) t(i) where [x for x in i if x IS NOT NULL] != [] offset 3;\n+\n+query I\n+select map(input, input) from input() t(input);\n+----\n+{-2147483648=-2147483648, 2147483647=2147483647}\n+{3=3, 5=5}\n+{7=7}\n+\n+statement ok\n+create table tbl (\n+\tnot_filtered bool,\n+\tkeys INTEGER[],\n+\tvals VARCHAR[]\n+);\n+\n+statement ok\n+insert into tbl select\n+\tcase when\n+\t\ti >= 500\n+\tthen\n+\t\ttrue\n+\telse\n+\t\tfalse\n+\tend as not_filtered,\n+\t[x for x in range(length)] keys,\n+\t['a' || i + x for x in range(length)] vals\n+\tfrom (\n+\t\tselect 1 + (random() * 5)::BIGINT as length, i from range(1000) t(i)\n+\t)\n+\n+# Because of the CONJUNCTION AND, this causes `v` to be constructed in the WHERE clause with a dictionary vector\n+# only some of the tuples pass the 'not_filtered' condition\n+# v[1] != val should never be true, by definition they're the same\n+query III\n+select\n+\tvals[1] as val,\n+\tkeys[1] as key,\n+\tmap(keys, vals)[key] as first_map_entry,\n+\t\tfrom tbl\n+\twhere\n+\t\tnot_filtered and first_map_entry[1] != val;\n+----\n+\n+statement ok\n+create table data as from (\n+  values\n+  ([1], [3]),\n+  ([2], [9]),\n+  ([3], [15]),\n+  ([4], [21]),\n+) as t(l, r);\n+\n+query III\n+select l[1], r[1], map(l, r) from data where r[1] != 3;\n+----\n+2\t9\t{2=9}\n+3\t15\t{3=15}\n+4\t21\t{4=21}\n+\n+query III\n+select l[1], r[1], map(l, r) from data where r[1] != 9;\n+----\n+1\t3\t{1=3}\n+3\t15\t{3=15}\n+4\t21\t{4=21}\n+\n+query III\n+select l[1], r[1], map(l, r) from data where r[1] != 15;\n+----\n+1\t3\t{1=3}\n+2\t9\t\t{2=9}\n+4\t21\t{4=21}\n",
  "problem_statement": "the map() returns wrong value\n### What happens?\n\nmap(list1,list2)[item of list1] return empty or wrong value of list2\n\n### To Reproduce\n\nsee https://github.com/duckdb/duckdb/discussions/8986\n\n### OS:\n\nwindows7 x64\n\n### DuckDB Version:\n\n0.8.1\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nlutao\n\n### Affiliation:\n\nstudy\n\n### Have you tried this on the latest `main` branch?\n\nI have tested with a main build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2023-09-22T11:35:42Z",
  "modified_files": [
    "src/core_functions/scalar/map/map.cpp"
  ],
  "modified_test_files": [
    "b/test/sql/types/nested/map/test_map_vector_types.test"
  ]
}