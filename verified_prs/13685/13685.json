{
  "repo": "duckdb/duckdb",
  "pull_number": 13685,
  "instance_id": "duckdb__duckdb-13685",
  "issue_numbers": [
    "11854"
  ],
  "base_commit": "01c5bed3c2235171f59527832b1d41fc4a669219",
  "patch": "diff --git a/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp b/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp\nindex 4f1e2c34abda..d70e65c7d202 100644\n--- a/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp\n@@ -23,6 +23,8 @@ class ColumnAliasBinder {\n \n \tbool BindAlias(ExpressionBinder &enclosing_binder, unique_ptr<ParsedExpression> &expr_ptr, idx_t depth,\n \t               bool root_expression, BindResult &result);\n+\t// Check if the column reference is an SELECT item alias.\n+\tbool QualifyColumnAlias(const ColumnRefExpression &colref);\n \n private:\n \tSelectBindState &bind_state;\ndiff --git a/src/include/duckdb/planner/expression_binder/where_binder.hpp b/src/include/duckdb/planner/expression_binder/where_binder.hpp\nindex e04651e1524d..20c4431204c6 100644\n--- a/src/include/duckdb/planner/expression_binder/where_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder/where_binder.hpp\n@@ -24,6 +24,7 @@ class WhereBinder : public ExpressionBinder {\n \t                          bool root_expression = false) override;\n \n \tstring UnsupportedAggregateMessage() override;\n+\tbool QualifyColumnAlias(const ColumnRefExpression &colref) override;\n \n private:\n \tBindResult BindColumnRef(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression);\ndiff --git a/src/planner/expression_binder/column_alias_binder.cpp b/src/planner/expression_binder/column_alias_binder.cpp\nindex fbe0f5a377fb..c4477f9e348a 100644\n--- a/src/planner/expression_binder/column_alias_binder.cpp\n+++ b/src/planner/expression_binder/column_alias_binder.cpp\n@@ -43,4 +43,11 @@ bool ColumnAliasBinder::BindAlias(ExpressionBinder &enclosing_binder, unique_ptr\n \treturn true;\n }\n \n+bool ColumnAliasBinder::QualifyColumnAlias(const ColumnRefExpression &colref) {\n+\tif (!colref.IsQualified()) {\n+\t\treturn bind_state.alias_map.find(colref.column_names[0]) != bind_state.alias_map.end();\n+\t}\n+\treturn false;\n+}\n+\n } // namespace duckdb\ndiff --git a/src/planner/expression_binder/where_binder.cpp b/src/planner/expression_binder/where_binder.cpp\nindex b8cf24ea27e0..9b25c7930b63 100644\n--- a/src/planner/expression_binder/where_binder.cpp\n+++ b/src/planner/expression_binder/where_binder.cpp\n@@ -43,4 +43,11 @@ string WhereBinder::UnsupportedAggregateMessage() {\n \treturn \"WHERE clause cannot contain aggregates!\";\n }\n \n+bool WhereBinder::QualifyColumnAlias(const ColumnRefExpression &colref) {\n+\tif (column_alias_binder) {\n+\t\treturn column_alias_binder->QualifyColumnAlias(colref);\n+\t}\n+\treturn false;\n+}\n+\n } // namespace duckdb\n",
  "test_patch": "diff --git a/test/sql/binder/test_function_chainging_alias.test b/test/sql/binder/test_function_chainging_alias.test\nindex b93a8b409e93..f5921416951b 100644\n--- a/test/sql/binder/test_function_chainging_alias.test\n+++ b/test/sql/binder/test_function_chainging_alias.test\n@@ -2,8 +2,6 @@\n # description: referencing an alias or a function chaining alias that exists earlier on\n # group: [binder]\n \n-#              in the SELECT clause (Issue #7190)\n-\n statement ok\n PRAGMA enable_verification\n \n@@ -91,3 +89,43 @@ query III\n EXECUTE v1('Hello World', 'test function chainging')\n ----\n [hello, world]\t[TEST, FUNCTION, CHAINGING]\t[hello, world, TEST, FUNCTION, CHAINGING]\n+\n+statement ok\n+INSERT INTO varchars VALUES ('Another longggggg String');\n+\n+# alias in where clause\n+query IIII\n+SELECT  v.split(' ') strings,\n+        strings.apply(x -> x.lower()).filter(x -> x[1] == 't' or x[1] == 'a') lower,\n+        strings.apply(x -> x.upper()).filter(x -> x[1] == 'T' or x[1] == 'A') upper,\n+        lower + upper  as mix_case_srings\n+FROM varchars\n+WHERE mix_case_srings[1] = 'test'\n+----\n+[Test, Function, Chainging, Alias]\t[test, alias]\t[TEST, ALIAS]\t[test, alias, TEST, ALIAS]\n+\n+\n+query IIII\n+SELECT  v.split(' ') strings,\n+        strings.apply(x -> x.lower()).filter(x -> x[1] == 't' or x[1] == 'a') lower,\n+        strings.apply(x -> x.upper()).filter(x -> x[1] == 'T' or x[1] == 'A') upper,\n+        lower + upper  as mix_case_srings\n+FROM varchars\n+WHERE mix_case_srings[1] = 'another'\n+----\n+[Another, longggggg, String]\t[another]\t[ANOTHER]\t[another, ANOTHER]\n+\n+# CTE with function chaining alias\n+query II\n+with test as (\n+    select 'woot' as my_column\n+)\n+from test\n+select \n+    my_column.substr(2) as partial_woot,\n+    partial_woot.substr(2) as more_partially_woot\n+where \n+    more_partially_woot = 'ot'\n+;\n+----\n+oot\tot\n\\ No newline at end of file\n",
  "problem_statement": "Combining function chaining and reusable aliases fails in where clause\n### What happens?\n\nHowdy folks! \r\n\r\nI found a small issue when combining 2 of my favorite friendly SQL features. \r\n\r\nIf I combine the use of function chaining and reusable aliases together in my select clause, then use that column in my where clause, I receive an error. \n\n### To Reproduce\n\nIt seems to be something to do with the combination of the two. Using just function chaining or just reusable aliases works correctly in the where clause. However, both together fails. \r\n\r\n```sql\r\n-- Fails\r\nwith test as (\r\n    select 'woot' as my_column\r\n)\r\nfrom test\r\nselect \r\n    my_column.substr(2) as partial_woot,\r\n    partial_woot.substr(2) as more_partially_woot\r\nwhere \r\n    more_partially_woot = 'ot'\r\n;\r\n```\r\n```sql\r\nCatalog Error: Scalar Function with name substr does not exist!\r\nDid you mean \"main.substr\"?\r\nLINE 7:     partial_woot.substr(2) as more_partially_woot\r\nwhere \r\n    more_partially_woot = 'ot'\r\n;...\r\n            ^\r\n```\r\n```sql\r\n-- Works: Multiple chains without reusable aliases\r\nwith test as (\r\n    select 'woot' as my_column\r\n)\r\nfrom test\r\nselect \r\n    my_column.substr(2) as partial_woot,\r\n    my_column.substr(2).substr(2) as more_partially_woot\r\nwhere \r\n    more_partially_woot = 'ot'\r\n;\r\n\r\n-- Works: Single chain and reusing the alias in the where clause only\r\nwith test as (\r\n    select 'woot' as my_column\r\n)\r\nfrom test\r\nselect \r\n    my_column.substr(2) as partial_woot,\r\nwhere \r\n    partial_woot = 'oot'\r\n;\r\n\r\n-- Works: Reusable aliases that don't use function chaining\r\nwith test as (\r\n    select 'woot' as my_column\r\n)\r\nfrom test\r\nselect \r\n    substr(my_column,2) as partial_woot,\r\n    substr(partial_woot,2) as more_partially_woot\r\nwhere \r\n    more_partially_woot = 'ot'\r\n;\r\n```\n\n### OS:\n\nMacOS\n\n### DuckDB Version:\n\n0.10.2, 0.10.3-dev388\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nAlex Monahan\n\n### Affiliation:\n\nDuckDB Labs and MotherDuck (lol at Oracle placeholder)\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a nightly build\n\n### Did you include all relevant data sets for reproducing the issue?\n\nNot applicable - the reproduction does not require a data set\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "This issue is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.\nWorth keeping open for sometime in the future!\nI have a similar issue which seems to be related to this one. Using function chaining in a macro produced the exact same error message. For example:\r\n```\r\nCREATE OR REPLACE TEMP MACRO\r\n    SINGLE_SPACE (VALUE) AS\r\nVALUE.REGEXP_REPLACE(' {2,}', ' ', 'g')\r\n;\r\nSELECT\r\n        SINGLE_SPACE('HELLO     THERE')\r\n    AS RESULT\r\n;\r\n```\r\n```\r\nCatalog Error: Scalar Function with name regexp_replace does not exist! Did you mean \"main.regexp_replace\"? LINE 3: AS RESULT\r\n```\n@chris-dailey  \r\n\r\n```sql \r\nCREATE OR REPLACE TEMP MACRO\r\n     SINGLE_SPACE (VALUE) AS\r\n (VALUE).REGEXP_REPLACE(' {2,}', ' ', 'g')\r\n ;\r\n\r\nSELECT SINGLE_SPACE('HELLO     THERE') AS RESULT ;\r\n```\r\n\r\nAdding parentheses around the `VALUE` .   This should work ! \n@Alex-Monahan  I have a patch fix this. I'll finish this weekend",
  "created_at": "2024-09-02T03:54:15Z",
  "modified_files": [
    "a/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp",
    "a/src/include/duckdb/planner/expression_binder/where_binder.hpp",
    "a/src/planner/expression_binder/column_alias_binder.cpp",
    "a/src/planner/expression_binder/where_binder.cpp"
  ]
}