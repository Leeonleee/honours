You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Selecting entire rows fails when the source table is named 'user'
### What happens?

If you select "entire rows" (as in `select foo from foo`), you generally get back each row as a struct. But if the table is named `user`, or if it's aliased to `user` in the query, you get the string `"duckdb"`—at least at the command line.

```sql
with x as (select 1) select foo from x foo;
```
```
┌─────────────────────┐
│         foo         │
│ struct("1" integer) │
├─────────────────────┤
│ {'1': 1}            │
└─────────────────────┘
```
```sql
with x as (select 1) select user from x user;
```
```
┌─────────┐
│  user   │
│ varchar │
├─────────┤
│ duckdb  │
└─────────┘
```

### To Reproduce

```sql
with x as (select 1) select user from x user;
```
```
┌─────────┐
│  user   │
│ varchar │
├─────────┤
│ duckdb  │
└─────────┘
```

### OS:

macos aarch64

### DuckDB Version:

0.9.2

### DuckDB Client:

CLI

### Full Name:

Joshua Gelbard

### Affiliation:

Ladder Financial Inc.

### Have you tried this on the latest `main` branch?

I have tested with a main build

### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?

- [X] Yes, I have
Selecting entire rows fails when the source table is named 'user'
### What happens?

If you select "entire rows" (as in `select foo from foo`), you generally get back each row as a struct. But if the table is named `user`, or if it's aliased to `user` in the query, you get the string `"duckdb"`—at least at the command line.

```sql
with x as (select 1) select foo from x foo;
```
```
┌─────────────────────┐
│         foo         │
│ struct("1" integer) │
├─────────────────────┤
│ {'1': 1}            │
└─────────────────────┘
```
```sql
with x as (select 1) select user from x user;
```
```
┌─────────┐
│  user   │
│ varchar │
├─────────┤
│ duckdb  │
└─────────┘
```

### To Reproduce

```sql
with x as (select 1) select user from x user;
```
```
┌─────────┐
│  user   │
│ varchar │
├─────────┤
│ duckdb  │
└─────────┘
```

### OS:

macos aarch64

### DuckDB Version:

0.9.2

### DuckDB Client:

CLI

### Full Name:

Joshua Gelbard

### Affiliation:

Ladder Financial Inc.

### Have you tried this on the latest `main` branch?

I have tested with a main build

### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/logo-dl/DuckDB_Logo-stacked.svg" height="120">
3: </div>
4: <br>
5: 
6: 
7: 
8: 
9: <p align="center">
10:   <a href="https://github.com/duckdb/duckdb/actions">
11:     <img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge">
12:   </a>
13:   <a href="https://discord.gg/tcvwpjfnZx">
14:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
15:   </a>
16:   <a href="https://github.com/duckdb/duckdb/releases/">
17:     <img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release">
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The detail of benchmarks is in our [Benchmark Guide](benchmark/README.md).
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
[end of README.md]
[start of src/planner/binder/expression/bind_columnref_expression.cpp]
1: #include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
2: #include "duckdb/common/string_util.hpp"
3: #include "duckdb/function/scalar/nested_functions.hpp"
4: #include "duckdb/parser/expression/columnref_expression.hpp"
5: #include "duckdb/parser/expression/constant_expression.hpp"
6: #include "duckdb/parser/expression/function_expression.hpp"
7: #include "duckdb/parser/expression/operator_expression.hpp"
8: #include "duckdb/parser/expression/positional_reference_expression.hpp"
9: #include "duckdb/parser/expression/subquery_expression.hpp"
10: #include "duckdb/parser/parsed_expression_iterator.hpp"
11: #include "duckdb/planner/binder.hpp"
12: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
13: #include "duckdb/planner/expression/bound_constant_expression.hpp"
14: #include "duckdb/planner/expression_binder.hpp"
15: #include "duckdb/planner/expression_binder/where_binder.hpp"
16: 
17: namespace duckdb {
18: 
19: string GetSQLValueFunctionName(const string &column_name) {
20: 	auto lcase = StringUtil::Lower(column_name);
21: 	if (lcase == "current_catalog") {
22: 		return "current_catalog";
23: 	} else if (lcase == "current_date") {
24: 		return "current_date";
25: 	} else if (lcase == "current_schema") {
26: 		return "current_schema";
27: 	} else if (lcase == "current_role") {
28: 		return "current_role";
29: 	} else if (lcase == "current_time") {
30: 		return "get_current_time";
31: 	} else if (lcase == "current_timestamp") {
32: 		return "get_current_timestamp";
33: 	} else if (lcase == "current_user") {
34: 		return "current_user";
35: 	} else if (lcase == "localtime") {
36: 		return "current_localtime";
37: 	} else if (lcase == "localtimestamp") {
38: 		return "current_localtimestamp";
39: 	} else if (lcase == "session_user") {
40: 		return "session_user";
41: 	} else if (lcase == "user") {
42: 		return "user";
43: 	}
44: 	return string();
45: }
46: 
47: unique_ptr<ParsedExpression> ExpressionBinder::GetSQLValueFunction(const string &column_name) {
48: 	auto value_function = GetSQLValueFunctionName(column_name);
49: 	if (value_function.empty()) {
50: 		return nullptr;
51: 	}
52: 
53: 	vector<unique_ptr<ParsedExpression>> children;
54: 	return make_uniq<FunctionExpression>(value_function, std::move(children));
55: }
56: 
57: unique_ptr<ParsedExpression> ExpressionBinder::QualifyColumnName(const string &column_name, ErrorData &error) {
58: 	auto using_binding = binder.bind_context.GetUsingBinding(column_name);
59: 	if (using_binding) {
60: 		// we are referencing a USING column
61: 		// check if we can refer to one of the base columns directly
62: 		unique_ptr<Expression> expression;
63: 		if (!using_binding->primary_binding.empty()) {
64: 			// we can! just assign the table name and re-bind
65: 			return binder.bind_context.CreateColumnReference(using_binding->primary_binding, column_name);
66: 		} else {
67: 			// we cannot! we need to bind this as COALESCE between all the relevant columns
68: 			auto coalesce = make_uniq<OperatorExpression>(ExpressionType::OPERATOR_COALESCE);
69: 			coalesce->children.reserve(using_binding->bindings.size());
70: 			for (auto &entry : using_binding->bindings) {
71: 				coalesce->children.push_back(make_uniq<ColumnRefExpression>(column_name, entry));
72: 			}
73: 			return std::move(coalesce);
74: 		}
75: 	}
76: 
77: 	// try binding as a lambda parameter
78: 	auto lambda_ref = LambdaRefExpression::FindMatchingBinding(lambda_bindings, column_name);
79: 	if (lambda_ref) {
80: 		return lambda_ref;
81: 	}
82: 
83: 	// find a table binding that contains this column name
84: 	string table_name = binder.bind_context.GetMatchingBinding(column_name);
85: 
86: 	// throw an error if a macro parameter name conflicts with a column name
87: 	auto is_macro_column = false;
88: 	if (binder.macro_binding && binder.macro_binding->HasMatchingBinding(column_name)) {
89: 		is_macro_column = true;
90: 		if (!table_name.empty()) {
91: 			throw BinderException("Conflicting column names for column " + column_name + "!");
92: 		}
93: 	}
94: 
95: 	// bind as a macro column
96: 	if (is_macro_column) {
97: 		D_ASSERT(!binder.macro_binding->alias.empty());
98: 		return make_uniq<ColumnRefExpression>(column_name, binder.macro_binding->alias);
99: 	}
100: 
101: 	// bind as a regular column
102: 	if (!table_name.empty()) {
103: 		return binder.bind_context.CreateColumnReference(table_name, column_name);
104: 	}
105: 
106: 	// column was not found - check if it is a SQL value function
107: 	auto value_function = GetSQLValueFunction(column_name);
108: 	if (value_function) {
109: 		return value_function;
110: 	}
111: 
112: 	// it's not, find candidates and error
113: 	auto similar_bindings = binder.bind_context.GetSimilarBindings(column_name);
114: 	error = ErrorData(BinderException::ColumnNotFound(column_name, similar_bindings));
115: 	return nullptr;
116: }
117: 
118: void ExpressionBinder::QualifyColumnNames(unique_ptr<ParsedExpression> &expr,
119:                                           vector<unordered_set<string>> &lambda_params,
120:                                           const bool within_function_expression) {
121: 
122: 	bool next_within_function_expression = false;
123: 	switch (expr->type) {
124: 	case ExpressionType::COLUMN_REF: {
125: 
126: 		auto &col_ref = expr->Cast<ColumnRefExpression>();
127: 
128: 		// don't qualify lambda parameters
129: 		if (LambdaExpression::IsLambdaParameter(lambda_params, col_ref.GetName())) {
130: 			return;
131: 		}
132: 
133: 		ErrorData error;
134: 		auto new_expr = QualifyColumnName(col_ref, error);
135: 
136: 		if (new_expr) {
137: 			if (!expr->alias.empty()) {
138: 				// Pre-existing aliases are added to the qualified column reference
139: 				new_expr->alias = expr->alias;
140: 			} else if (within_function_expression) {
141: 				// Qualifying the column reference may add an alias, but this needs to be removed within function
142: 				// expressions, because the alias here means a named parameter instead of a positional parameter
143: 				new_expr->alias = "";
144: 			}
145: 
146: 			// replace the expression with the qualified column reference
147: 			new_expr->query_location = col_ref.query_location;
148: 			expr = std::move(new_expr);
149: 		}
150: 		return;
151: 	}
152: 	case ExpressionType::POSITIONAL_REFERENCE: {
153: 		auto &ref = expr->Cast<PositionalReferenceExpression>();
154: 		if (ref.alias.empty()) {
155: 			string table_name, column_name;
156: 			auto error = binder.bind_context.BindColumn(ref, table_name, column_name);
157: 			if (error.empty()) {
158: 				ref.alias = column_name;
159: 			}
160: 		}
161: 		break;
162: 	}
163: 	case ExpressionType::FUNCTION: {
164: 		// special-handling for lambdas, which are inside function expressions,
165: 		auto &function = expr->Cast<FunctionExpression>();
166: 		if (IsLambdaFunction(function)) {
167: 			// special case
168: 			return QualifyColumnNamesInLambda(function, lambda_params);
169: 		}
170: 
171: 		next_within_function_expression = true;
172: 		break;
173: 	}
174: 	default: // fall through
175: 		break;
176: 	}
177: 
178: 	// recurse on the child expressions
179: 	ParsedExpressionIterator::EnumerateChildren(*expr, [&](unique_ptr<ParsedExpression> &child) {
180: 		QualifyColumnNames(child, lambda_params, next_within_function_expression);
181: 	});
182: }
183: 
184: void ExpressionBinder::QualifyColumnNamesInLambda(FunctionExpression &function,
185:                                                   vector<unordered_set<string>> &lambda_params) {
186: 
187: 	for (auto &child : function.children) {
188: 		if (child->expression_class != ExpressionClass::LAMBDA) {
189: 			// not a lambda expression
190: 			QualifyColumnNames(child, lambda_params, true);
191: 			continue;
192: 		}
193: 
194: 		// special-handling for LHS lambda parameters
195: 		// we do not qualify them, and we add them to the lambda_params vector
196: 		auto &lambda_expr = child->Cast<LambdaExpression>();
197: 		string error_message;
198: 		auto column_ref_expressions = lambda_expr.ExtractColumnRefExpressions(error_message);
199: 
200: 		if (!error_message.empty()) {
201: 			// possibly a JSON function, qualify both LHS and RHS
202: 			QualifyColumnNames(lambda_expr.lhs, lambda_params, true);
203: 			QualifyColumnNames(lambda_expr.expr, lambda_params, true);
204: 			continue;
205: 		}
206: 
207: 		// push this level
208: 		lambda_params.emplace_back();
209: 
210: 		// push the lambda parameter names
211: 		for (const auto &column_ref_expr : column_ref_expressions) {
212: 			const auto &column_ref = column_ref_expr.get().Cast<ColumnRefExpression>();
213: 			lambda_params.back().emplace(column_ref.GetName());
214: 		}
215: 
216: 		// only qualify in RHS
217: 		QualifyColumnNames(lambda_expr.expr, lambda_params, true);
218: 
219: 		// pop this level
220: 		lambda_params.pop_back();
221: 	}
222: }
223: 
224: void ExpressionBinder::QualifyColumnNames(Binder &binder, unique_ptr<ParsedExpression> &expr) {
225: 	WhereBinder where_binder(binder, binder.context);
226: 	vector<unordered_set<string>> lambda_params;
227: 	where_binder.QualifyColumnNames(expr, lambda_params);
228: }
229: 
230: unique_ptr<ParsedExpression> ExpressionBinder::CreateStructExtract(unique_ptr<ParsedExpression> base,
231:                                                                    const string &field_name) {
232: 
233: 	vector<unique_ptr<ParsedExpression>> children;
234: 	children.push_back(std::move(base));
235: 	children.push_back(make_uniq_base<ParsedExpression, ConstantExpression>(Value(field_name)));
236: 	auto extract_fun = make_uniq<OperatorExpression>(ExpressionType::STRUCT_EXTRACT, std::move(children));
237: 	return std::move(extract_fun);
238: }
239: 
240: unique_ptr<ParsedExpression> ExpressionBinder::CreateStructPack(ColumnRefExpression &col_ref) {
241: 
242: 	D_ASSERT(col_ref.column_names.size() <= 3);
243: 
244: 	// get a matching binding
245: 	ErrorData error;
246: 	auto &table_name = col_ref.column_names.back();
247: 	auto binding = binder.bind_context.GetBinding(table_name, error);
248: 
249: 	if (!binding) {
250: 		return nullptr;
251: 	}
252: 
253: 	if (col_ref.column_names.size() >= 2) {
254: 		// "schema_name.table_name"
255: 		auto catalog_entry = binding->GetStandardEntry();
256: 		if (!catalog_entry) {
257: 			return nullptr;
258: 		}
259: 
260: 		if (catalog_entry->name != table_name) {
261: 			return nullptr;
262: 		}
263: 
264: 		if (col_ref.column_names.size() == 2) {
265: 			auto &qualifier = col_ref.column_names[0];
266: 			if (catalog_entry->catalog.GetName() != qualifier && catalog_entry->schema.name != qualifier) {
267: 				return nullptr;
268: 			}
269: 
270: 		} else if (col_ref.column_names.size() == 3) {
271: 			auto &catalog_name = col_ref.column_names[0];
272: 			auto &schema_name = col_ref.column_names[1];
273: 			if (catalog_entry->catalog.GetName() != catalog_name || catalog_entry->schema.name != schema_name) {
274: 				return nullptr;
275: 			}
276: 
277: 		} else {
278: 			throw InternalException("Expected 2 or 3 column names for CreateStructPack");
279: 		}
280: 	}
281: 
282: 	// We found the table, now create the struct_pack expression
283: 	vector<unique_ptr<ParsedExpression>> child_expressions;
284: 	child_expressions.reserve(binding->names.size());
285: 	for (const auto &column_name : binding->names) {
286: 		child_expressions.push_back(make_uniq<ColumnRefExpression>(column_name, table_name));
287: 	}
288: 	return make_uniq<FunctionExpression>("struct_pack", std::move(child_expressions));
289: }
290: 
291: unique_ptr<ParsedExpression> ExpressionBinder::QualifyColumnNameWithManyDots(ColumnRefExpression &col_ref,
292:                                                                              ErrorData &error) {
293: 
294: 	// two or more dots (i.e. "part1.part2.part3.part4...")
295: 	// -> part1 is a catalog, part2 is a schema, part3 is a table, part4 is a column name, part 5 and beyond are
296: 	// struct fields
297: 	// -> part1 is a catalog, part2 is a table, part3 is a column name, part4 and beyond are struct fields
298: 	// -> part1 is a schema, part2 is a table, part3 is a column name, part4 and beyond are struct fields
299: 	// -> part1 is a table, part2 is a column name, part3 and beyond are struct fields
300: 	// -> part1 is a column, part2 and beyond are struct fields
301: 
302: 	// we always prefer the most top-level view
303: 	// i.e. in case of multiple resolution options, we resolve in order:
304: 	// -> 1. resolve "part1" as a catalog
305: 	// -> 2. resolve "part1" as a schema
306: 	// -> 3. resolve "part1" as a table
307: 	// -> 4. resolve "part1" as a column
308: 
309: 	unique_ptr<ParsedExpression> result_expr;
310: 	idx_t struct_extract_start;
311: 
312: 	// first check if part1 is a catalog
313: 	if (col_ref.column_names.size() > 3 &&
314: 	    binder.HasMatchingBinding(col_ref.column_names[0], col_ref.column_names[1], col_ref.column_names[2],
315: 	                              col_ref.column_names[3], error)) {
316: 		// part1 is a catalog - the column reference is "catalog.schema.table.column"
317: 		result_expr = binder.bind_context.CreateColumnReference(col_ref.column_names[0], col_ref.column_names[1],
318: 		                                                        col_ref.column_names[2], col_ref.column_names[3]);
319: 		struct_extract_start = 4;
320: 
321: 	} else if (binder.HasMatchingBinding(col_ref.column_names[0], INVALID_SCHEMA, col_ref.column_names[1],
322: 	                                     col_ref.column_names[2], error)) {
323: 		// part1 is a catalog - the column reference is "catalog.table.column"
324: 		result_expr = binder.bind_context.CreateColumnReference(col_ref.column_names[0], INVALID_SCHEMA,
325: 		                                                        col_ref.column_names[1], col_ref.column_names[2]);
326: 		struct_extract_start = 3;
327: 
328: 	} else if (binder.HasMatchingBinding(col_ref.column_names[0], col_ref.column_names[1], col_ref.column_names[2],
329: 	                                     error)) {
330: 		// part1 is a schema - the column reference is "schema.table.column"
331: 		// any additional fields are turned into struct_extract calls
332: 		result_expr = binder.bind_context.CreateColumnReference(col_ref.column_names[0], col_ref.column_names[1],
333: 		                                                        col_ref.column_names[2]);
334: 		struct_extract_start = 3;
335: 
336: 	} else if (binder.HasMatchingBinding(col_ref.column_names[0], col_ref.column_names[1], error)) {
337: 		// part1 is a table
338: 		// the column reference is "table.column"
339: 		// any additional fields are turned into struct_extract calls
340: 		result_expr = binder.bind_context.CreateColumnReference(col_ref.column_names[0], col_ref.column_names[1]);
341: 		struct_extract_start = 2;
342: 
343: 	} else {
344: 		// part1 could be a column
345: 		ErrorData col_error;
346: 		result_expr = QualifyColumnName(col_ref.column_names[0], col_error);
347: 		if (!result_expr) {
348: 			// it is not! Try creating an implicit struct_pack
349: 			return CreateStructPack(col_ref);
350: 		}
351: 		// it is! add the struct extract calls
352: 		struct_extract_start = 1;
353: 	}
354: 
355: 	// create a struct extract with all remaining column names
356: 	for (idx_t i = struct_extract_start; i < col_ref.column_names.size(); i++) {
357: 		result_expr = CreateStructExtract(std::move(result_expr), col_ref.column_names[i]);
358: 	}
359: 
360: 	return result_expr;
361: }
362: 
363: unique_ptr<ParsedExpression> ExpressionBinder::QualifyColumnName(ColumnRefExpression &col_ref, ErrorData &error) {
364: 
365: 	// try binding as a lambda parameter
366: 	if (!col_ref.IsQualified()) {
367: 		auto lambda_ref = LambdaRefExpression::FindMatchingBinding(lambda_bindings, col_ref.GetName());
368: 		if (lambda_ref) {
369: 			return lambda_ref;
370: 		}
371: 	}
372: 
373: 	idx_t column_parts = col_ref.column_names.size();
374: 
375: 	// column names can have an arbitrary amount of dots
376: 	// here is how the resolution works:
377: 	if (column_parts == 1) {
378: 		// no dots (i.e. "part1")
379: 		// -> part1 refers to a column
380: 		// check if we can qualify the column name with the table name
381: 		auto qualified_col_ref = QualifyColumnName(col_ref.GetColumnName(), error);
382: 		if (qualified_col_ref) {
383: 			// we could: return it
384: 			return qualified_col_ref;
385: 		}
386: 		// we could not! Try creating an implicit struct_pack
387: 		return CreateStructPack(col_ref);
388: 	}
389: 
390: 	if (column_parts == 2) {
391: 		// one dot (i.e. "part1.part2")
392: 		// EITHER:
393: 		// -> part1 is a table, part2 is a column
394: 		// -> part1 is a column, part2 is a property of that column (i.e. struct_extract)
395: 
396: 		// first check if part1 is a table, and part2 is a standard column name
397: 		if (binder.HasMatchingBinding(col_ref.column_names[0], col_ref.column_names[1], error)) {
398: 			// it is! return the column reference directly
399: 			return binder.bind_context.CreateColumnReference(col_ref.column_names[0], col_ref.column_names[1]);
400: 		}
401: 
402: 		// otherwise check if we can turn this into a struct extract
403: 		ErrorData other_error;
404: 		auto qualified_col_ref = QualifyColumnName(col_ref.column_names[0], other_error);
405: 		if (qualified_col_ref) {
406: 			// we could: create a struct extract
407: 			return CreateStructExtract(std::move(qualified_col_ref), col_ref.column_names[1]);
408: 		}
409: 		// we could not! Try creating an implicit struct_pack
410: 		return CreateStructPack(col_ref);
411: 	}
412: 
413: 	// three or more dots
414: 	return QualifyColumnNameWithManyDots(col_ref, error);
415: }
416: 
417: BindResult ExpressionBinder::BindExpression(LambdaRefExpression &lambda_ref, idx_t depth) {
418: 	D_ASSERT(lambda_bindings && lambda_ref.lambda_idx < lambda_bindings->size());
419: 	return (*lambda_bindings)[lambda_ref.lambda_idx].Bind(lambda_ref, depth);
420: }
421: 
422: BindResult ExpressionBinder::BindExpression(ColumnRefExpression &col_ref_p, idx_t depth) {
423: 
424: 	if (binder.GetBindingMode() == BindingMode::EXTRACT_NAMES) {
425: 		return BindResult(make_uniq<BoundConstantExpression>(Value(LogicalType::SQLNULL)));
426: 	}
427: 
428: 	ErrorData error;
429: 	auto expr = QualifyColumnName(col_ref_p, error);
430: 	if (!expr) {
431: 		error.AddQueryLocation(col_ref_p);
432: 		return BindResult(std::move(error));
433: 	}
434: 
435: 	expr->query_location = col_ref_p.query_location;
436: 
437: 	// the above QualifyColumName returns a generated expression for a generated
438: 	// column, and struct_extract for a struct, or a lambda reference expression,
439: 	// all of them are not column reference expressions, so we return here
440: 	if (expr->type != ExpressionType::COLUMN_REF) {
441: 		auto alias = expr->alias;
442: 		auto result = BindExpression(expr, depth);
443: 		if (result.expression) {
444: 			result.expression->alias = std::move(alias);
445: 		}
446: 		return result;
447: 	}
448: 
449: 	// the above QualifyColumnName returned an individual column reference
450: 	// expression, which we resolve to either a base table or a subquery expression,
451: 	// and if it was a macro parameter, then we let macro_binding bind it to the argument
452: 	BindResult result;
453: 	auto &col_ref = expr->Cast<ColumnRefExpression>();
454: 	D_ASSERT(col_ref.IsQualified());
455: 	auto &table_name = col_ref.GetTableName();
456: 
457: 	if (binder.macro_binding && table_name == binder.macro_binding->alias) {
458: 		result = binder.macro_binding->Bind(col_ref, depth);
459: 	} else {
460: 		result = binder.bind_context.BindColumn(col_ref, depth);
461: 	}
462: 
463: 	if (result.HasError()) {
464: 		result.error.AddQueryLocation(col_ref_p);
465: 		return result;
466: 	}
467: 
468: 	// we bound the column reference
469: 	BoundColumnReferenceInfo ref;
470: 	ref.name = col_ref.column_names.back();
471: 	ref.query_location = col_ref.query_location;
472: 	bound_columns.push_back(std::move(ref));
473: 	return result;
474: }
475: 
476: bool ExpressionBinder::QualifyColumnAlias(const ColumnRefExpression &col_ref) {
477: 	// only the BaseSelectBinder will have a valid column alias map,
478: 	// otherwise we return false
479: 	return false;
480: }
481: } // namespace duckdb
[end of src/planner/binder/expression/bind_columnref_expression.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: