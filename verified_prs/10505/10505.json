{
  "repo": "duckdb/duckdb",
  "pull_number": 10505,
  "instance_id": "duckdb__duckdb-10505",
  "issue_numbers": [
    "10363",
    "10363"
  ],
  "base_commit": "b92cb1ae39ec1460a118f95be469da1e23a95c08",
  "patch": "diff --git a/src/planner/binder/expression/bind_columnref_expression.cpp b/src/planner/binder/expression/bind_columnref_expression.cpp\nindex 20ec401d7917..f90b4e129bc6 100644\n--- a/src/planner/binder/expression/bind_columnref_expression.cpp\n+++ b/src/planner/binder/expression/bind_columnref_expression.cpp\n@@ -103,12 +103,6 @@ unique_ptr<ParsedExpression> ExpressionBinder::QualifyColumnName(const string &c\n \t\treturn binder.bind_context.CreateColumnReference(table_name, column_name);\n \t}\n \n-\t// column was not found - check if it is a SQL value function\n-\tauto value_function = GetSQLValueFunction(column_name);\n-\tif (value_function) {\n-\t\treturn value_function;\n-\t}\n-\n \t// it's not, find candidates and error\n \tauto similar_bindings = binder.bind_context.GetSimilarBindings(column_name);\n \terror = ErrorData(BinderException::ColumnNotFound(column_name, similar_bindings));\n@@ -420,7 +414,6 @@ BindResult ExpressionBinder::BindExpression(LambdaRefExpression &lambda_ref, idx\n }\n \n BindResult ExpressionBinder::BindExpression(ColumnRefExpression &col_ref_p, idx_t depth) {\n-\n \tif (binder.GetBindingMode() == BindingMode::EXTRACT_NAMES) {\n \t\treturn BindResult(make_uniq<BoundConstantExpression>(Value(LogicalType::SQLNULL)));\n \t}\n@@ -428,6 +421,13 @@ BindResult ExpressionBinder::BindExpression(ColumnRefExpression &col_ref_p, idx_\n \tErrorData error;\n \tauto expr = QualifyColumnName(col_ref_p, error);\n \tif (!expr) {\n+\t\tif (!col_ref_p.IsQualified()) {\n+\t\t\t// column was not found - check if it is a SQL value function\n+\t\t\tauto value_function = GetSQLValueFunction(col_ref_p.GetName());\n+\t\t\tif (value_function) {\n+\t\t\t\treturn BindExpression(value_function, depth);\n+\t\t\t}\n+\t\t}\n \t\terror.AddQueryLocation(col_ref_p);\n \t\treturn BindResult(std::move(error));\n \t}\n",
  "test_patch": "diff --git a/test/sql/parser/test_value_functions.test b/test/sql/parser/test_value_functions.test\nindex 6d3f44c2d22a..4ad0492d078d 100644\n--- a/test/sql/parser/test_value_functions.test\n+++ b/test/sql/parser/test_value_functions.test\n@@ -22,6 +22,12 @@ SELECT UsEr\n ----\n duckdb\n \n+# Issue #10363 - we also prefer table-as-struct over value functions\n+query I\n+SELECT user FROM (VALUES (42)) user(x)\n+----\n+{'x': 42}\n+\n # run all SQL value functions\n # need to run without verification since CURRENT_TIME etc break verification\n statement ok\n",
  "problem_statement": "Selecting entire rows fails when the source table is named 'user'\n### What happens?\r\n\r\nIf you select \"entire rows\" (as in `select foo from foo`), you generally get back each row as a struct. But if the table is named `user`, or if it's aliased to `user` in the query, you get the string `\"duckdb\"`\u2014at least at the command line.\r\n\r\n```sql\r\nwith x as (select 1) select foo from x foo;\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502         foo         \u2502\r\n\u2502 struct(\"1\" integer) \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 {'1': 1}            \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n```sql\r\nwith x as (select 1) select user from x user;\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  user   \u2502\r\n\u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 duckdb  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n### To Reproduce\r\n\r\n```sql\r\nwith x as (select 1) select user from x user;\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  user   \u2502\r\n\u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 duckdb  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n### OS:\r\n\r\nmacos aarch64\r\n\r\n### DuckDB Version:\r\n\r\n0.9.2\r\n\r\n### DuckDB Client:\r\n\r\nCLI\r\n\r\n### Full Name:\r\n\r\nJoshua Gelbard\r\n\r\n### Affiliation:\r\n\r\nLadder Financial Inc.\r\n\r\n### Have you tried this on the latest `main` branch?\r\n\r\nI have tested with a main build\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\nSelecting entire rows fails when the source table is named 'user'\n### What happens?\r\n\r\nIf you select \"entire rows\" (as in `select foo from foo`), you generally get back each row as a struct. But if the table is named `user`, or if it's aliased to `user` in the query, you get the string `\"duckdb\"`\u2014at least at the command line.\r\n\r\n```sql\r\nwith x as (select 1) select foo from x foo;\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502         foo         \u2502\r\n\u2502 struct(\"1\" integer) \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 {'1': 1}            \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n```sql\r\nwith x as (select 1) select user from x user;\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  user   \u2502\r\n\u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 duckdb  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n### To Reproduce\r\n\r\n```sql\r\nwith x as (select 1) select user from x user;\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  user   \u2502\r\n\u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 duckdb  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n### OS:\r\n\r\nmacos aarch64\r\n\r\n### DuckDB Version:\r\n\r\n0.9.2\r\n\r\n### DuckDB Client:\r\n\r\nCLI\r\n\r\n### Full Name:\r\n\r\nJoshua Gelbard\r\n\r\n### Affiliation:\r\n\r\nLadder Financial Inc.\r\n\r\n### Have you tried this on the latest `main` branch?\r\n\r\nI have tested with a main build\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "@joshgelbard Your queries makes me a bit confuse, I don't really understand your intention. However, hopefully the following explanations can help you.\r\nAbout the issue you raised \"But **if the table is named user** (1), or **if it's aliased to user in the query** (2), you get the string \"duckdb\"\u2014at least at the command line.\"\r\n\r\n(1) -> No, it not.\r\n```\r\nwith x as (select 1) select * from x user;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   1   \u2502\r\n\u2502 int32 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502     1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n(2) -> Not really, if your target table's schema has a \"user\" column it still works fine.\r\n```\r\nwith x as (select 1 as user) select user from x;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 user  \u2502\r\n\u2502 int32 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502     1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\nBut if there is no \"user\" column in the schema then it behaves like the \"SELECT USER\" query in standard SQL, it is used to get information about the currently logged-in user executing the statement.\r\n```\r\nselect user;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  user   \u2502\r\n\u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 duckdb  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nHi @tim365, thanks for taking a look at this.\r\n\r\n> Your queries makes me a bit confuse, I don't really understand your intention.\r\n\r\nSorry for not being clear about that. The intent of the report is to note some inconsistent behavior that looks like a bug.\r\n\r\nThis can be copied and pasted:\r\n\r\n```\r\nwith foo as (select 1) select foo from foo; -- {'1': 1} \r\nwith bar as (select 1) select bar from bar; -- {'1': 1} \r\nwith baz as (select 1) select baz from baz; -- {'1': 1} \r\nwith user as (select 1) select user from user; -- 'duckdb'\r\n```\r\n\r\nHere, the query author is trying to select \"the whole row\" as a struct. This seems to work, in general, but it stops working in the last example. That behavior seems surprising to me. Is that a bug, or is it a mistake to try this in the first place?\n@joshgelbard Your queries makes me a bit confuse, I don't really understand your intention. However, hopefully the following explanations can help you.\r\nAbout the issue you raised \"But **if the table is named user** (1), or **if it's aliased to user in the query** (2), you get the string \"duckdb\"\u2014at least at the command line.\"\r\n\r\n(1) -> No, it not.\r\n```\r\nwith x as (select 1) select * from x user;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   1   \u2502\r\n\u2502 int32 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502     1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n(2) -> Not really, if your target table's schema has a \"user\" column it still works fine.\r\n```\r\nwith x as (select 1 as user) select user from x;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 user  \u2502\r\n\u2502 int32 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502     1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\nBut if there is no \"user\" column in the schema then it behaves like the \"SELECT USER\" query in standard SQL, it is used to get information about the currently logged-in user executing the statement.\r\n```\r\nselect user;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  user   \u2502\r\n\u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 duckdb  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nHi @tim365, thanks for taking a look at this.\r\n\r\n> Your queries makes me a bit confuse, I don't really understand your intention.\r\n\r\nSorry for not being clear about that. The intent of the report is to note some inconsistent behavior that looks like a bug.\r\n\r\nThis can be copied and pasted:\r\n\r\n```\r\nwith foo as (select 1) select foo from foo; -- {'1': 1} \r\nwith bar as (select 1) select bar from bar; -- {'1': 1} \r\nwith baz as (select 1) select baz from baz; -- {'1': 1} \r\nwith user as (select 1) select user from user; -- 'duckdb'\r\n```\r\n\r\nHere, the query author is trying to select \"the whole row\" as a struct. This seems to work, in general, but it stops working in the last example. That behavior seems surprising to me. Is that a bug, or is it a mistake to try this in the first place?",
  "created_at": "2024-02-07T13:15:15Z",
  "modified_files": [
    "src/planner/binder/expression/bind_columnref_expression.cpp"
  ],
  "modified_test_files": [
    "test/sql/parser/test_value_functions.test"
  ]
}