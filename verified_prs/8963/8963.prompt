You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
EPOCH FROM 'TIMESTAMP with milliseconds' drops millisecond output
### What happens?

The milliseconds portion of the time is dropped when using EPOCH against a timestamp which has milliseconds provided. 


### To Reproduce

`SELECT EXTRACT(EPOCH FROM '2001-02-16 20:38:40.12-08'::TIMESTAMP);`
**Result: 982384720** 
Should be: **982384720.120000**

`SELECT EXTRACT(EPOCH FROM '2001-02-16 20:38:40.12'::TIMESTAMP);`
**Result: 982355920** 
Should be: **982355920.120000**

`SELECT EPOCH('2001-02-16 20:38:40.12'::TIMESTAMP);`
**Result: 982355920**
Should be: **982355920.120000**

Related info when comparing to PostgreSQL: https://www.postgresql.org/docs/15/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT under the epoch section.

Also "The extract function returns values of type numeric." in PostgreSQL and looks like DuckDB is returning BIGINT.

### OS:

Web

### DuckDB Version:

DuckDB Web Shell Database: v0.7.2-dev3783

### DuckDB Client:

Web

### Full Name:

Dwayne McMurchy

### Affiliation:

None

### Have you tried this on the latest `master` branch?

- [X] I agree

### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?

- [X] I agree

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: 
7: 
8: 
9: <p align="center">
10:   <a href="https://github.com/duckdb/duckdb/actions">
11:     <img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge">
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/main/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19:   <a href="https://github.com/duckdb/duckdb/releases/">
20:     <img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release">
21:   </a>
22: </p>
23: 
24: ## DuckDB
25: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
26: 
27: ## Installation
28: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
29: 
30: ## Data Import
31: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
32: 
33: ```sql
34: SELECT * FROM 'myfile.csv';
35: SELECT * FROM 'myfile.parquet';
36: ```
37: 
38: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
39: 
40: ## SQL Reference
41: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
42: 
43: ## Development
44: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The detail of benchmarks is in our [Benchmark Guide](benchmark/README.md).
45: 
46: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
[end of README.md]
[start of extension/icu/icu-datepart.cpp]
1: #include "include/icu-datepart.hpp"
2: #include "include/icu-datefunc.hpp"
3: 
4: #include "duckdb/common/enums/date_part_specifier.hpp"
5: #include "duckdb/common/types/date.hpp"
6: #include "duckdb/common/types/timestamp.hpp"
7: #include "duckdb/common/vector_operations/unary_executor.hpp"
8: #include "duckdb/common/vector_operations/binary_executor.hpp"
9: #include "duckdb/execution/expression_executor.hpp"
10: #include "duckdb/main/client_context.hpp"
11: #include "duckdb/parser/parsed_data/create_scalar_function_info.hpp"
12: #include "duckdb/planner/expression/bound_function_expression.hpp"
13: 
14: namespace duckdb {
15: 
16: struct ICUDatePart : public ICUDateFunc {
17: 	typedef int64_t (*part_bigint_t)(icu::Calendar *calendar, const uint64_t micros);
18: 	typedef double (*part_double_t)(icu::Calendar *calendar, const uint64_t micros);
19: 
20: 	// Date part adapters
21: 	static int64_t ExtractEra(icu::Calendar *calendar, const uint64_t micros) {
22: 		return ExtractField(calendar, UCAL_ERA);
23: 	}
24: 
25: 	static int64_t ExtractYear(icu::Calendar *calendar, const uint64_t micros) {
26: 		return ExtractField(calendar, UCAL_YEAR);
27: 	}
28: 
29: 	static int64_t ExtractDecade(icu::Calendar *calendar, const uint64_t micros) {
30: 		return ExtractYear(calendar, micros) / 10;
31: 	}
32: 
33: 	static int64_t ExtractCentury(icu::Calendar *calendar, const uint64_t micros) {
34: 		const auto era = ExtractEra(calendar, micros);
35: 		const auto cccc = ((ExtractYear(calendar, micros) - 1) / 100) + 1;
36: 		return era > 0 ? cccc : -cccc;
37: 	}
38: 
39: 	static int64_t ExtractMillenium(icu::Calendar *calendar, const uint64_t micros) {
40: 		const auto era = ExtractEra(calendar, micros);
41: 		const auto mmmm = ((ExtractYear(calendar, micros) - 1) / 1000) + 1;
42: 		return era > 0 ? mmmm : -mmmm;
43: 	}
44: 
45: 	static int64_t ExtractMonth(icu::Calendar *calendar, const uint64_t micros) {
46: 		return ExtractField(calendar, UCAL_MONTH) + 1;
47: 	}
48: 
49: 	static int64_t ExtractQuarter(icu::Calendar *calendar, const uint64_t micros) {
50: 		return ExtractField(calendar, UCAL_MONTH) / Interval::MONTHS_PER_QUARTER + 1;
51: 	}
52: 
53: 	static int64_t ExtractDay(icu::Calendar *calendar, const uint64_t micros) {
54: 		return ExtractField(calendar, UCAL_DATE);
55: 	}
56: 
57: 	static int64_t ExtractDayOfWeek(icu::Calendar *calendar, const uint64_t micros) {
58: 		// [Sun(0), Sat(6)]
59: 		return ExtractField(calendar, UCAL_DAY_OF_WEEK) - UCAL_SUNDAY;
60: 	}
61: 
62: 	static int64_t ExtractISODayOfWeek(icu::Calendar *calendar, const uint64_t micros) {
63: 		// [Mon(1), Sun(7)]
64: 		return 1 + (ExtractField(calendar, UCAL_DAY_OF_WEEK) + 7 - UCAL_MONDAY) % 7;
65: 	}
66: 
67: 	static int64_t ExtractWeek(icu::Calendar *calendar, const uint64_t micros) {
68: 		calendar->setFirstDayOfWeek(UCAL_MONDAY);
69: 		calendar->setMinimalDaysInFirstWeek(4);
70: 		return ExtractField(calendar, UCAL_WEEK_OF_YEAR);
71: 	}
72: 
73: 	static int64_t ExtractISOYear(icu::Calendar *calendar, const uint64_t micros) {
74: 		calendar->setFirstDayOfWeek(UCAL_MONDAY);
75: 		calendar->setMinimalDaysInFirstWeek(4);
76: 		return ExtractField(calendar, UCAL_YEAR_WOY);
77: 	}
78: 
79: 	static int64_t ExtractYearWeek(icu::Calendar *calendar, const uint64_t micros) {
80: 		calendar->setFirstDayOfWeek(UCAL_MONDAY);
81: 		calendar->setMinimalDaysInFirstWeek(4);
82: 		const auto iyyy = ExtractField(calendar, UCAL_YEAR_WOY);
83: 		const auto ww = ExtractField(calendar, UCAL_WEEK_OF_YEAR);
84: 		return iyyy * 100 + ((iyyy > 0) ? ww : -ww);
85: 	}
86: 
87: 	static int64_t ExtractDayOfYear(icu::Calendar *calendar, const uint64_t micros) {
88: 		return ExtractField(calendar, UCAL_DAY_OF_YEAR);
89: 	}
90: 
91: 	static int64_t ExtractHour(icu::Calendar *calendar, const uint64_t micros) {
92: 		return ExtractField(calendar, UCAL_HOUR_OF_DAY);
93: 	}
94: 
95: 	static int64_t ExtractMinute(icu::Calendar *calendar, const uint64_t micros) {
96: 		return ExtractField(calendar, UCAL_MINUTE);
97: 	}
98: 
99: 	static int64_t ExtractSecond(icu::Calendar *calendar, const uint64_t micros) {
100: 		return ExtractField(calendar, UCAL_SECOND);
101: 	}
102: 
103: 	static int64_t ExtractMillisecond(icu::Calendar *calendar, const uint64_t micros) {
104: 		return ExtractSecond(calendar, micros) * Interval::MSECS_PER_SEC + ExtractField(calendar, UCAL_MILLISECOND);
105: 	}
106: 
107: 	static int64_t ExtractMicrosecond(icu::Calendar *calendar, const uint64_t micros) {
108: 		return ExtractMillisecond(calendar, micros) * Interval::MICROS_PER_MSEC + micros;
109: 	}
110: 
111: 	static int64_t ExtractEpoch(icu::Calendar *calendar, const uint64_t micros) {
112: 		UErrorCode status = U_ZERO_ERROR;
113: 		//	Truncate
114: 		return calendar->getTime(status) / Interval::MSECS_PER_SEC;
115: 	}
116: 
117: 	static int64_t ExtractTimezone(icu::Calendar *calendar, const uint64_t micros) {
118: 		auto millis = ExtractField(calendar, UCAL_ZONE_OFFSET);
119: 		millis += ExtractField(calendar, UCAL_DST_OFFSET);
120: 		return millis / Interval::MSECS_PER_SEC;
121: 	}
122: 
123: 	static int64_t ExtractTimezoneHour(icu::Calendar *calendar, const uint64_t micros) {
124: 		auto secs = ExtractTimezone(calendar, micros);
125: 		return secs / Interval::SECS_PER_HOUR;
126: 	}
127: 
128: 	static int64_t ExtractTimezoneMinute(icu::Calendar *calendar, const uint64_t micros) {
129: 		auto secs = ExtractTimezone(calendar, micros);
130: 		return (secs % Interval::SECS_PER_HOUR) / Interval::SECS_PER_MINUTE;
131: 	}
132: 
133: 	//	PG uses doubles for JDs so we can only use them with other double types
134: 	static double ExtractJulianDay(icu::Calendar *calendar, const uint64_t micros) {
135: 		//	We need days + fraction
136: 		auto days = ExtractField(calendar, UCAL_JULIAN_DAY);
137: 		auto frac = ExtractHour(calendar, micros);
138: 
139: 		frac *= Interval::MINS_PER_HOUR;
140: 		frac += ExtractMinute(calendar, micros);
141: 
142: 		frac *= Interval::MICROS_PER_MINUTE;
143: 		frac += ExtractMicrosecond(calendar, micros);
144: 
145: 		double result = frac;
146: 		result /= Interval::MICROS_PER_DAY;
147: 		result += days;
148: 
149: 		return result;
150: 	}
151: 
152: 	static part_bigint_t PartCodeBigintFactory(DatePartSpecifier part) {
153: 		switch (part) {
154: 		case DatePartSpecifier::YEAR:
155: 			return ExtractYear;
156: 		case DatePartSpecifier::MONTH:
157: 			return ExtractMonth;
158: 		case DatePartSpecifier::DAY:
159: 			return ExtractDay;
160: 		case DatePartSpecifier::DECADE:
161: 			return ExtractDecade;
162: 		case DatePartSpecifier::CENTURY:
163: 			return ExtractCentury;
164: 		case DatePartSpecifier::MILLENNIUM:
165: 			return ExtractMillenium;
166: 		case DatePartSpecifier::MICROSECONDS:
167: 			return ExtractMicrosecond;
168: 		case DatePartSpecifier::MILLISECONDS:
169: 			return ExtractMillisecond;
170: 		case DatePartSpecifier::SECOND:
171: 			return ExtractSecond;
172: 		case DatePartSpecifier::MINUTE:
173: 			return ExtractMinute;
174: 		case DatePartSpecifier::HOUR:
175: 			return ExtractHour;
176: 		case DatePartSpecifier::DOW:
177: 			return ExtractDayOfWeek;
178: 		case DatePartSpecifier::ISODOW:
179: 			return ExtractISODayOfWeek;
180: 		case DatePartSpecifier::WEEK:
181: 			return ExtractWeek;
182: 		case DatePartSpecifier::ISOYEAR:
183: 			return ExtractISOYear;
184: 		case DatePartSpecifier::DOY:
185: 			return ExtractDayOfYear;
186: 		case DatePartSpecifier::QUARTER:
187: 			return ExtractQuarter;
188: 		case DatePartSpecifier::YEARWEEK:
189: 			return ExtractYearWeek;
190: 		case DatePartSpecifier::EPOCH:
191: 			return ExtractEpoch;
192: 		case DatePartSpecifier::ERA:
193: 			return ExtractEra;
194: 		case DatePartSpecifier::TIMEZONE:
195: 			return ExtractTimezone;
196: 		case DatePartSpecifier::TIMEZONE_HOUR:
197: 			return ExtractTimezoneHour;
198: 		case DatePartSpecifier::TIMEZONE_MINUTE:
199: 			return ExtractTimezoneMinute;
200: 		default:
201: 			throw Exception("Unsupported ICU BIGINT extractor");
202: 		}
203: 	}
204: 
205: 	static part_double_t PartCodeDoubleFactory(DatePartSpecifier part) {
206: 		switch (part) {
207: 		case DatePartSpecifier::JULIAN_DAY:
208: 			return ExtractJulianDay;
209: 		default:
210: 			throw Exception("Unsupported ICU DOUBLE extractor");
211: 		}
212: 	}
213: 
214: 	static date_t MakeLastDay(icu::Calendar *calendar, const uint64_t micros) {
215: 		// Set the calendar to midnight on the last day of the month
216: 		calendar->set(UCAL_MILLISECOND, 0);
217: 		calendar->set(UCAL_SECOND, 0);
218: 		calendar->set(UCAL_MINUTE, 0);
219: 		calendar->set(UCAL_HOUR_OF_DAY, 0);
220: 
221: 		UErrorCode status = U_ZERO_ERROR;
222: 		const auto dd = calendar->getActualMaximum(UCAL_DATE, status);
223: 		if (U_FAILURE(status)) {
224: 			throw Exception("Unable to extract ICU last day.");
225: 		}
226: 
227: 		calendar->set(UCAL_DATE, dd);
228: 
229: 		//	Offset to UTC
230: 		auto millis = calendar->getTime(status);
231: 		millis += ExtractField(calendar, UCAL_ZONE_OFFSET);
232: 		millis += ExtractField(calendar, UCAL_DST_OFFSET);
233: 
234: 		return Date::EpochToDate(millis / Interval::MSECS_PER_SEC);
235: 	}
236: 
237: 	static string_t MonthName(icu::Calendar *calendar, const uint64_t micros) {
238: 		const auto mm = ExtractMonth(calendar, micros) - 1;
239: 		if (mm == 12) {
240: 			return "Undecimber";
241: 		}
242: 		return Date::MONTH_NAMES[mm];
243: 	}
244: 
245: 	static string_t DayName(icu::Calendar *calendar, const uint64_t micros) {
246: 		return Date::DAY_NAMES[ExtractDayOfWeek(calendar, micros)];
247: 	}
248: 
249: 	template <typename RESULT_TYPE>
250: 	struct BindAdapterData : public BindData {
251: 		using result_t = RESULT_TYPE;
252: 		typedef result_t (*adapter_t)(icu::Calendar *calendar, const uint64_t micros);
253: 		using adapters_t = vector<adapter_t>;
254: 
255: 		BindAdapterData(ClientContext &context, adapter_t adapter_p) : BindData(context), adapters(1, adapter_p) {
256: 		}
257: 		BindAdapterData(ClientContext &context, adapters_t &adapters_p) : BindData(context), adapters(adapters_p) {
258: 		}
259: 		BindAdapterData(const BindAdapterData &other) : BindData(other), adapters(other.adapters) {
260: 		}
261: 
262: 		adapters_t adapters;
263: 
264: 		bool Equals(const FunctionData &other_p) const override {
265: 			const auto &other = (BindAdapterData &)other_p;
266: 			return BindData::Equals(other_p) && adapters == other.adapters;
267: 		}
268: 
269: 		duckdb::unique_ptr<FunctionData> Copy() const override {
270: 			return make_uniq<BindAdapterData>(*this);
271: 		}
272: 	};
273: 
274: 	template <typename INPUT_TYPE, typename RESULT_TYPE>
275: 	static void UnaryTimestampFunction(DataChunk &args, ExpressionState &state, Vector &result) {
276: 		using BIND_TYPE = BindAdapterData<RESULT_TYPE>;
277: 		D_ASSERT(args.ColumnCount() == 1);
278: 		auto &date_arg = args.data[0];
279: 
280: 		auto &func_expr = state.expr.Cast<BoundFunctionExpression>();
281: 		auto &info = (BIND_TYPE &)*func_expr.bind_info;
282: 		CalendarPtr calendar_ptr(info.calendar->clone());
283: 		auto calendar = calendar_ptr.get();
284: 
285: 		UnaryExecutor::ExecuteWithNulls<INPUT_TYPE, RESULT_TYPE>(date_arg, result, args.size(),
286: 		                                                         [&](INPUT_TYPE input, ValidityMask &mask, idx_t idx) {
287: 			                                                         if (Timestamp::IsFinite(input)) {
288: 				                                                         const auto micros = SetTime(calendar, input);
289: 				                                                         return info.adapters[0](calendar, micros);
290: 			                                                         } else {
291: 				                                                         mask.SetInvalid(idx);
292: 				                                                         return RESULT_TYPE();
293: 			                                                         }
294: 		                                                         });
295: 	}
296: 
297: 	template <typename INPUT_TYPE, typename RESULT_TYPE>
298: 	static void BinaryTimestampFunction(DataChunk &args, ExpressionState &state, Vector &result) {
299: 		using BIND_TYPE = BindAdapterData<int64_t>;
300: 		D_ASSERT(args.ColumnCount() == 2);
301: 		auto &part_arg = args.data[0];
302: 		auto &date_arg = args.data[1];
303: 
304: 		auto &func_expr = state.expr.Cast<BoundFunctionExpression>();
305: 		auto &info = func_expr.bind_info->Cast<BIND_TYPE>();
306: 		CalendarPtr calendar_ptr(info.calendar->clone());
307: 		auto calendar = calendar_ptr.get();
308: 
309: 		BinaryExecutor::ExecuteWithNulls<string_t, INPUT_TYPE, RESULT_TYPE>(
310: 		    part_arg, date_arg, result, args.size(),
311: 		    [&](string_t specifier, INPUT_TYPE input, ValidityMask &mask, idx_t idx) {
312: 			    if (Timestamp::IsFinite(input)) {
313: 				    const auto micros = SetTime(calendar, input);
314: 				    auto adapter = PartCodeBigintFactory(GetDatePartSpecifier(specifier.GetString()));
315: 				    return adapter(calendar, micros);
316: 			    } else {
317: 				    mask.SetInvalid(idx);
318: 				    return RESULT_TYPE(0);
319: 			    }
320: 		    });
321: 	}
322: 
323: 	struct BindStructData : public BindData {
324: 		using part_codes_t = vector<DatePartSpecifier>;
325: 		using bigints_t = vector<part_bigint_t>;
326: 		using doubles_t = vector<part_double_t>;
327: 
328: 		BindStructData(ClientContext &context, part_codes_t &part_codes_p, bigints_t &bigints_p, doubles_t &doubles_p)
329: 		    : BindData(context), part_codes(part_codes_p), bigints(bigints_p), doubles(doubles_p) {
330: 		}
331: 		BindStructData(const BindStructData &other)
332: 		    : BindData(other), part_codes(other.part_codes), bigints(other.bigints), doubles(other.doubles) {
333: 		}
334: 
335: 		part_codes_t part_codes;
336: 		bigints_t bigints;
337: 		doubles_t doubles;
338: 
339: 		bool Equals(const FunctionData &other_p) const override {
340: 			const auto &other = other_p.Cast<BindStructData>();
341: 			return BindData::Equals(other_p) && part_codes == other.part_codes && bigints == other.bigints &&
342: 			       doubles == other.doubles;
343: 		}
344: 
345: 		duckdb::unique_ptr<FunctionData> Copy() const override {
346: 			return make_uniq<BindStructData>(*this);
347: 		}
348: 	};
349: 
350: 	template <typename INPUT_TYPE>
351: 	static void StructFunction(DataChunk &args, ExpressionState &state, Vector &result) {
352: 		auto &func_expr = state.expr.Cast<BoundFunctionExpression>();
353: 		auto &info = func_expr.bind_info->Cast<BindStructData>();
354: 		CalendarPtr calendar_ptr(info.calendar->clone());
355: 		auto calendar = calendar_ptr.get();
356: 
357: 		D_ASSERT(args.ColumnCount() == 1);
358: 		const auto count = args.size();
359: 		Vector &input = args.data[0];
360: 
361: 		if (input.GetVectorType() == VectorType::CONSTANT_VECTOR) {
362: 			result.SetVectorType(VectorType::CONSTANT_VECTOR);
363: 
364: 			if (ConstantVector::IsNull(input)) {
365: 				ConstantVector::SetNull(result, true);
366: 			} else {
367: 				ConstantVector::SetNull(result, false);
368: 				auto tdata = ConstantVector::GetData<INPUT_TYPE>(input);
369: 				auto micros = SetTime(calendar, tdata[0]);
370: 				const auto is_finite = Timestamp::IsFinite(*tdata);
371: 				auto &child_entries = StructVector::GetEntries(result);
372: 				for (size_t col = 0; col < child_entries.size(); ++col) {
373: 					auto &child_entry = child_entries[col];
374: 					if (is_finite) {
375: 						ConstantVector::SetNull(*child_entry, false);
376: 						if (IsBigintDatepart(info.part_codes[col])) {
377: 							auto pdata = ConstantVector::GetData<int64_t>(*child_entry);
378: 							auto adapter = info.bigints[col];
379: 							pdata[0] = adapter(calendar, micros);
380: 						} else {
381: 							auto pdata = ConstantVector::GetData<double>(*child_entry);
382: 							auto adapter = info.doubles[col];
383: 							pdata[0] = adapter(calendar, micros);
384: 						}
385: 					} else {
386: 						ConstantVector::SetNull(*child_entry, true);
387: 					}
388: 				}
389: 			}
390: 		} else {
391: 			UnifiedVectorFormat rdata;
392: 			input.ToUnifiedFormat(count, rdata);
393: 
394: 			const auto &arg_valid = rdata.validity;
395: 			auto tdata = UnifiedVectorFormat::GetData<INPUT_TYPE>(rdata);
396: 
397: 			result.SetVectorType(VectorType::FLAT_VECTOR);
398: 			auto &child_entries = StructVector::GetEntries(result);
399: 			for (auto &child_entry : child_entries) {
400: 				child_entry->SetVectorType(VectorType::FLAT_VECTOR);
401: 			}
402: 
403: 			auto &res_valid = FlatVector::Validity(result);
404: 			for (idx_t i = 0; i < count; ++i) {
405: 				const auto idx = rdata.sel->get_index(i);
406: 				if (arg_valid.RowIsValid(idx)) {
407: 					res_valid.SetValid(i);
408: 					auto micros = SetTime(calendar, tdata[idx]);
409: 					const auto is_finite = Timestamp::IsFinite(tdata[idx]);
410: 					for (size_t col = 0; col < child_entries.size(); ++col) {
411: 						auto &child_entry = child_entries[col];
412: 						if (is_finite) {
413: 							FlatVector::Validity(*child_entry).SetValid(i);
414: 							if (IsBigintDatepart(info.part_codes[col])) {
415: 								auto pdata = ConstantVector::GetData<int64_t>(*child_entry);
416: 								auto adapter = info.bigints[col];
417: 								pdata[i] = adapter(calendar, micros);
418: 							} else {
419: 								auto pdata = ConstantVector::GetData<double>(*child_entry);
420: 								auto adapter = info.doubles[col];
421: 								pdata[i] = adapter(calendar, micros);
422: 							}
423: 						} else {
424: 							FlatVector::Validity(*child_entry).SetInvalid(i);
425: 						}
426: 					}
427: 				} else {
428: 					res_valid.SetInvalid(i);
429: 					for (auto &child_entry : child_entries) {
430: 						FlatVector::Validity(*child_entry).SetInvalid(i);
431: 					}
432: 				}
433: 			}
434: 		}
435: 
436: 		result.Verify(count);
437: 	}
438: 
439: 	template <typename BIND_TYPE>
440: 	static duckdb::unique_ptr<FunctionData> BindAdapter(ClientContext &context, ScalarFunction &bound_function,
441: 	                                                    vector<duckdb::unique_ptr<Expression>> &arguments,
442: 	                                                    typename BIND_TYPE::adapter_t adapter) {
443: 		return make_uniq<BIND_TYPE>(context, adapter);
444: 	}
445: 
446: 	static duckdb::unique_ptr<FunctionData> BindUnaryDatePart(ClientContext &context, ScalarFunction &bound_function,
447: 	                                                          vector<duckdb::unique_ptr<Expression>> &arguments) {
448: 		const auto part_code = GetDatePartSpecifier(bound_function.name);
449: 		if (IsBigintDatepart(part_code)) {
450: 			using data_t = BindAdapterData<int64_t>;
451: 			auto adapter = PartCodeBigintFactory(part_code);
452: 			return BindAdapter<data_t>(context, bound_function, arguments, adapter);
453: 		} else {
454: 			using data_t = BindAdapterData<double>;
455: 			auto adapter = PartCodeDoubleFactory(part_code);
456: 			return BindAdapter<data_t>(context, bound_function, arguments, adapter);
457: 		}
458: 	}
459: 
460: 	static duckdb::unique_ptr<FunctionData> BindBinaryDatePart(ClientContext &context, ScalarFunction &bound_function,
461: 	                                                           vector<duckdb::unique_ptr<Expression>> &arguments) {
462: 		//	If we are only looking for Julian Days, then patch in the unary function.
463: 		do {
464: 			if (arguments[0]->HasParameter() || !arguments[0]->IsFoldable()) {
465: 				break;
466: 			}
467: 
468: 			Value part_value = ExpressionExecutor::EvaluateScalar(context, *arguments[0]);
469: 			if (part_value.IsNull()) {
470: 				break;
471: 			}
472: 
473: 			const auto part_name = part_value.ToString();
474: 			const auto part_code = GetDatePartSpecifier(part_name);
475: 			if (IsBigintDatepart(part_code)) {
476: 				break;
477: 			}
478: 
479: 			arguments.erase(arguments.begin());
480: 			bound_function.arguments.erase(bound_function.arguments.begin());
481: 			bound_function.name = part_name;
482: 			bound_function.return_type = LogicalType::DOUBLE;
483: 			bound_function.function = UnaryTimestampFunction<timestamp_t, double>;
484: 
485: 			return BindUnaryDatePart(context, bound_function, arguments);
486: 		} while (false);
487: 
488: 		using data_t = BindAdapterData<int64_t>;
489: 		return BindAdapter<data_t>(context, bound_function, arguments, nullptr);
490: 	}
491: 
492: 	static duckdb::unique_ptr<FunctionData> BindStruct(ClientContext &context, ScalarFunction &bound_function,
493: 	                                                   vector<duckdb::unique_ptr<Expression>> &arguments) {
494: 		// collect names and deconflict, construct return type
495: 		if (arguments[0]->HasParameter()) {
496: 			throw ParameterNotResolvedException();
497: 		}
498: 		if (!arguments[0]->IsFoldable()) {
499: 			throw BinderException("%s can only take constant lists of part names", bound_function.name);
500: 		}
501: 
502: 		case_insensitive_set_t name_collision_set;
503: 		child_list_t<LogicalType> struct_children;
504: 		BindStructData::part_codes_t part_codes;
505: 		BindStructData::bigints_t bigints;
506: 		BindStructData::doubles_t doubles;
507: 
508: 		Value parts_list = ExpressionExecutor::EvaluateScalar(context, *arguments[0]);
509: 		if (parts_list.type().id() == LogicalTypeId::LIST) {
510: 			auto &list_children = ListValue::GetChildren(parts_list);
511: 			if (list_children.empty()) {
512: 				throw BinderException("%s requires non-empty lists of part names", bound_function.name);
513: 			}
514: 
515: 			bigints.resize(list_children.size(), nullptr);
516: 			doubles.resize(list_children.size(), nullptr);
517: 			for (size_t col = 0; col < list_children.size(); ++col) {
518: 				const auto &part_value = list_children[col];
519: 				if (part_value.IsNull()) {
520: 					throw BinderException("NULL struct entry name in %s", bound_function.name);
521: 				}
522: 				const auto part_name = part_value.ToString();
523: 				const auto part_code = GetDatePartSpecifier(part_name);
524: 				if (name_collision_set.find(part_name) != name_collision_set.end()) {
525: 					throw BinderException("Duplicate struct entry name \"%s\" in %s", part_name, bound_function.name);
526: 				}
527: 				name_collision_set.insert(part_name);
528: 				part_codes.emplace_back(part_code);
529: 				if (IsBigintDatepart(part_code)) {
530: 					bigints[col] = PartCodeBigintFactory(part_code);
531: 					struct_children.emplace_back(make_pair(part_name, LogicalType::BIGINT));
532: 				} else {
533: 					doubles[col] = PartCodeDoubleFactory(part_code);
534: 					struct_children.emplace_back(make_pair(part_name, LogicalType::DOUBLE));
535: 				}
536: 			}
537: 		} else {
538: 			throw BinderException("%s can only take constant lists of part names", bound_function.name);
539: 		}
540: 
541: 		Function::EraseArgument(bound_function, arguments, 0);
542: 		bound_function.return_type = LogicalType::STRUCT(std::move(struct_children));
543: 		return make_uniq<BindStructData>(context, part_codes, bigints, doubles);
544: 	}
545: 
546: 	static void SerializeFunction(Serializer &serializer, const optional_ptr<FunctionData> bind_data,
547: 	                              const ScalarFunction &function) {
548: 		throw NotImplementedException("FIXME: serialize icu-datepart");
549: 	}
550: 
551: 	static duckdb::unique_ptr<FunctionData> DeserializeFunction(Deserializer &deserializer,
552: 	                                                            ScalarFunction &bound_function) {
553: 		throw NotImplementedException("FIXME: serialize icu-datepart");
554: 	}
555: 
556: 	template <typename INPUT_TYPE, typename RESULT_TYPE>
557: 	static ScalarFunction GetUnaryPartCodeFunction(const LogicalType &temporal_type,
558: 	                                               const LogicalType &result_type = LogicalType::BIGINT) {
559: 		return ScalarFunction({temporal_type}, result_type, UnaryTimestampFunction<INPUT_TYPE, RESULT_TYPE>,
560: 		                      BindUnaryDatePart);
561: 	}
562: 
563: 	template <typename RESULT_TYPE = int64_t>
564: 	static void AddUnaryPartCodeFunctions(const string &name, ClientContext &context,
565: 	                                      const LogicalType &result_type = LogicalType::BIGINT) {
566: 		auto &catalog = Catalog::GetSystemCatalog(context);
567: 		ScalarFunctionSet set(name);
568: 		set.AddFunction(GetUnaryPartCodeFunction<timestamp_t, RESULT_TYPE>(LogicalType::TIMESTAMP_TZ, result_type));
569: 		CreateScalarFunctionInfo func_info(set);
570: 		catalog.AddFunction(context, func_info);
571: 	}
572: 
573: 	template <typename INPUT_TYPE, typename RESULT_TYPE>
574: 	static ScalarFunction GetBinaryPartCodeFunction(const LogicalType &temporal_type) {
575: 		return ScalarFunction({LogicalType::VARCHAR, temporal_type}, LogicalType::BIGINT,
576: 		                      BinaryTimestampFunction<INPUT_TYPE, RESULT_TYPE>, BindBinaryDatePart);
577: 	}
578: 
579: 	template <typename INPUT_TYPE>
580: 	static ScalarFunction GetStructFunction(const LogicalType &temporal_type) {
581: 		auto part_type = LogicalType::LIST(LogicalType::VARCHAR);
582: 		auto result_type = LogicalType::STRUCT({});
583: 		ScalarFunction result({part_type, temporal_type}, result_type, StructFunction<INPUT_TYPE>, BindStruct);
584: 		result.serialize = SerializeFunction;
585: 		result.deserialize = DeserializeFunction;
586: 		return result;
587: 	}
588: 
589: 	static void AddDatePartFunctions(const string &name, ClientContext &context) {
590: 		auto &catalog = Catalog::GetSystemCatalog(context);
591: 		ScalarFunctionSet set(name);
592: 		set.AddFunction(GetBinaryPartCodeFunction<timestamp_t, int64_t>(LogicalType::TIMESTAMP_TZ));
593: 		set.AddFunction(GetStructFunction<timestamp_t>(LogicalType::TIMESTAMP_TZ));
594: 		CreateScalarFunctionInfo func_info(set);
595: 		catalog.AddFunction(context, func_info);
596: 	}
597: 
598: 	static duckdb::unique_ptr<FunctionData> BindLastDate(ClientContext &context, ScalarFunction &bound_function,
599: 	                                                     vector<duckdb::unique_ptr<Expression>> &arguments) {
600: 		using data_t = BindAdapterData<date_t>;
601: 		return BindAdapter<data_t>(context, bound_function, arguments, MakeLastDay);
602: 	}
603: 
604: 	template <typename INPUT_TYPE>
605: 	static ScalarFunction GetLastDayFunction(const LogicalType &temporal_type) {
606: 		return ScalarFunction({temporal_type}, LogicalType::DATE, UnaryTimestampFunction<INPUT_TYPE, date_t>,
607: 		                      BindLastDate);
608: 	}
609: 	static void AddLastDayFunctions(const string &name, ClientContext &context) {
610: 		auto &catalog = Catalog::GetSystemCatalog(context);
611: 		ScalarFunctionSet set(name);
612: 		set.AddFunction(GetLastDayFunction<timestamp_t>(LogicalType::TIMESTAMP_TZ));
613: 		CreateScalarFunctionInfo func_info(set);
614: 		catalog.AddFunction(context, func_info);
615: 	}
616: 
617: 	static unique_ptr<FunctionData> BindMonthName(ClientContext &context, ScalarFunction &bound_function,
618: 	                                              vector<unique_ptr<Expression>> &arguments) {
619: 		using data_t = BindAdapterData<string_t>;
620: 		return BindAdapter<data_t>(context, bound_function, arguments, MonthName);
621: 	}
622: 
623: 	template <typename INPUT_TYPE>
624: 	static ScalarFunction GetMonthNameFunction(const LogicalType &temporal_type) {
625: 		return ScalarFunction({temporal_type}, LogicalType::VARCHAR, UnaryTimestampFunction<INPUT_TYPE, string_t>,
626: 		                      BindMonthName);
627: 	}
628: 	static void AddMonthNameFunctions(const string &name, ClientContext &context) {
629: 		auto &catalog = Catalog::GetSystemCatalog(context);
630: 		ScalarFunctionSet set(name);
631: 		set.AddFunction(GetMonthNameFunction<timestamp_t>(LogicalType::TIMESTAMP_TZ));
632: 		CreateScalarFunctionInfo func_info(set);
633: 		catalog.AddFunction(context, func_info);
634: 	}
635: 
636: 	static unique_ptr<FunctionData> BindDayName(ClientContext &context, ScalarFunction &bound_function,
637: 	                                            vector<unique_ptr<Expression>> &arguments) {
638: 		using data_t = BindAdapterData<string_t>;
639: 		return BindAdapter<data_t>(context, bound_function, arguments, DayName);
640: 	}
641: 
642: 	template <typename INPUT_TYPE>
643: 	static ScalarFunction GetDayNameFunction(const LogicalType &temporal_type) {
644: 		return ScalarFunction({temporal_type}, LogicalType::VARCHAR, UnaryTimestampFunction<INPUT_TYPE, string_t>,
645: 		                      BindDayName);
646: 	}
647: 	static void AddDayNameFunctions(const string &name, ClientContext &context) {
648: 		auto &catalog = Catalog::GetSystemCatalog(context);
649: 		ScalarFunctionSet set(name);
650: 		set.AddFunction(GetDayNameFunction<timestamp_t>(LogicalType::TIMESTAMP_TZ));
651: 		CreateScalarFunctionInfo func_info(set);
652: 		catalog.AddFunction(context, func_info);
653: 	}
654: };
655: 
656: void RegisterICUDatePartFunctions(ClientContext &context) {
657: 	// register the individual operators
658: 	ICUDatePart::AddUnaryPartCodeFunctions("era", context);
659: 	ICUDatePart::AddUnaryPartCodeFunctions("year", context);
660: 	ICUDatePart::AddUnaryPartCodeFunctions("month", context);
661: 	ICUDatePart::AddUnaryPartCodeFunctions("day", context);
662: 	ICUDatePart::AddUnaryPartCodeFunctions("decade", context);
663: 	ICUDatePart::AddUnaryPartCodeFunctions("century", context);
664: 	ICUDatePart::AddUnaryPartCodeFunctions("millennium", context);
665: 	ICUDatePart::AddUnaryPartCodeFunctions("microsecond", context);
666: 	ICUDatePart::AddUnaryPartCodeFunctions("millisecond", context);
667: 	ICUDatePart::AddUnaryPartCodeFunctions("second", context);
668: 	ICUDatePart::AddUnaryPartCodeFunctions("minute", context);
669: 	ICUDatePart::AddUnaryPartCodeFunctions("hour", context);
670: 	ICUDatePart::AddUnaryPartCodeFunctions("dayofweek", context);
671: 	ICUDatePart::AddUnaryPartCodeFunctions("isodow", context);
672: 	ICUDatePart::AddUnaryPartCodeFunctions("week", context); //  Note that WeekOperator is ISO-8601, not US
673: 	ICUDatePart::AddUnaryPartCodeFunctions("dayofyear", context);
674: 	ICUDatePart::AddUnaryPartCodeFunctions("quarter", context);
675: 	ICUDatePart::AddUnaryPartCodeFunctions("epoch", context);
676: 	ICUDatePart::AddUnaryPartCodeFunctions("isoyear", context);
677: 	ICUDatePart::AddUnaryPartCodeFunctions("timezone", context);
678: 	ICUDatePart::AddUnaryPartCodeFunctions("timezone_hour", context);
679: 	ICUDatePart::AddUnaryPartCodeFunctions("timezone_minute", context);
680: 
681: 	ICUDatePart::AddUnaryPartCodeFunctions<double>("julian", context, LogicalType::DOUBLE);
682: 
683: 	//  register combinations
684: 	ICUDatePart::AddUnaryPartCodeFunctions("yearweek", context); //  Note this is ISO year and week
685: 
686: 	//  register various aliases
687: 	ICUDatePart::AddUnaryPartCodeFunctions("dayofmonth", context);
688: 	ICUDatePart::AddUnaryPartCodeFunctions("weekday", context);
689: 	ICUDatePart::AddUnaryPartCodeFunctions("weekofyear", context);
690: 
691: 	//  register the last_day function
692: 	ICUDatePart::AddLastDayFunctions("last_day", context);
693: 
694: 	// register the dayname/monthname functions
695: 	ICUDatePart::AddMonthNameFunctions("monthname", context);
696: 	ICUDatePart::AddDayNameFunctions("dayname", context);
697: 
698: 	// finally the actual date_part function
699: 	ICUDatePart::AddDatePartFunctions("date_part", context);
700: 	ICUDatePart::AddDatePartFunctions("datepart", context);
701: }
702: 
703: } // namespace duckdb
[end of extension/icu/icu-datepart.cpp]
[start of src/common/enum_util.cpp]
1: //-------------------------------------------------------------------------
2: // This file is automatically generated by scripts/generate_enum_util.py
3: // Do not edit this file manually, your changes will be overwritten
4: // If you want to exclude an enum from serialization, add it to the blacklist in the script
5: //
6: // Note: The generated code will only work properly if the enum is a top level item in the duckdb namespace
7: // If the enum is nested in a class, or in another namespace, the generated code will not compile.
8: // You should move the enum to the duckdb namespace, manually write a specialization or add it to the blacklist
9: //-------------------------------------------------------------------------
10: 
11: 
12: #include "duckdb/common/enum_util.hpp"
13: #include "duckdb/catalog/catalog_entry/table_column_type.hpp"
14: #include "duckdb/common/enums/access_mode.hpp"
15: #include "duckdb/common/enums/aggregate_handling.hpp"
16: #include "duckdb/common/enums/catalog_type.hpp"
17: #include "duckdb/common/enums/compression_type.hpp"
18: #include "duckdb/common/enums/cte_materialize.hpp"
19: #include "duckdb/common/enums/date_part_specifier.hpp"
20: #include "duckdb/common/enums/debug_initialize.hpp"
21: #include "duckdb/common/enums/expression_type.hpp"
22: #include "duckdb/common/enums/file_compression_type.hpp"
23: #include "duckdb/common/enums/file_glob_options.hpp"
24: #include "duckdb/common/enums/filter_propagate_result.hpp"
25: #include "duckdb/common/enums/index_type.hpp"
26: #include "duckdb/common/enums/join_type.hpp"
27: #include "duckdb/common/enums/joinref_type.hpp"
28: #include "duckdb/common/enums/logical_operator_type.hpp"
29: #include "duckdb/common/enums/on_entry_not_found.hpp"
30: #include "duckdb/common/enums/operator_result_type.hpp"
31: #include "duckdb/common/enums/optimizer_type.hpp"
32: #include "duckdb/common/enums/order_preservation_type.hpp"
33: #include "duckdb/common/enums/order_type.hpp"
34: #include "duckdb/common/enums/output_type.hpp"
35: #include "duckdb/common/enums/pending_execution_result.hpp"
36: #include "duckdb/common/enums/physical_operator_type.hpp"
37: #include "duckdb/common/enums/profiler_format.hpp"
38: #include "duckdb/common/enums/relation_type.hpp"
39: #include "duckdb/common/enums/scan_options.hpp"
40: #include "duckdb/common/enums/set_operation_type.hpp"
41: #include "duckdb/common/enums/set_scope.hpp"
42: #include "duckdb/common/enums/set_type.hpp"
43: #include "duckdb/common/enums/statement_type.hpp"
44: #include "duckdb/common/enums/subquery_type.hpp"
45: #include "duckdb/common/enums/tableref_type.hpp"
46: #include "duckdb/common/enums/undo_flags.hpp"
47: #include "duckdb/common/enums/vector_type.hpp"
48: #include "duckdb/common/enums/wal_type.hpp"
49: #include "duckdb/common/enums/window_aggregation_mode.hpp"
50: #include "duckdb/common/exception_format_value.hpp"
51: #include "duckdb/common/extra_type_info.hpp"
52: #include "duckdb/common/file_buffer.hpp"
53: #include "duckdb/common/file_system.hpp"
54: #include "duckdb/common/printer.hpp"
55: #include "duckdb/common/sort/partition_state.hpp"
56: #include "duckdb/common/types.hpp"
57: #include "duckdb/common/types/column/column_data_scan_states.hpp"
58: #include "duckdb/common/types/column/partitioned_column_data.hpp"
59: #include "duckdb/common/types/conflict_manager.hpp"
60: #include "duckdb/common/types/hyperloglog.hpp"
61: #include "duckdb/common/types/row/partitioned_tuple_data.hpp"
62: #include "duckdb/common/types/row/tuple_data_states.hpp"
63: #include "duckdb/common/types/timestamp.hpp"
64: #include "duckdb/common/types/vector.hpp"
65: #include "duckdb/common/types/vector_buffer.hpp"
66: #include "duckdb/execution/index/art/art.hpp"
67: #include "duckdb/execution/index/art/node.hpp"
68: #include "duckdb/execution/operator/scan/csv/base_csv_reader.hpp"
69: #include "duckdb/execution/operator/scan/csv/csv_reader_options.hpp"
70: #include "duckdb/execution/operator/scan/csv/csv_state_machine.hpp"
71: #include "duckdb/execution/operator/scan/csv/quote_rules.hpp"
72: #include "duckdb/function/aggregate_state.hpp"
73: #include "duckdb/function/function.hpp"
74: #include "duckdb/function/macro_function.hpp"
75: #include "duckdb/function/scalar/compressed_materialization_functions.hpp"
76: #include "duckdb/function/scalar/strftime_format.hpp"
77: #include "duckdb/function/table/arrow/arrow_duck_schema.hpp"
78: #include "duckdb/main/appender.hpp"
79: #include "duckdb/main/capi/capi_internal.hpp"
80: #include "duckdb/main/config.hpp"
81: #include "duckdb/main/error_manager.hpp"
82: #include "duckdb/main/extension_helper.hpp"
83: #include "duckdb/main/query_result.hpp"
84: #include "duckdb/parallel/interrupt.hpp"
85: #include "duckdb/parallel/task.hpp"
86: #include "duckdb/parser/constraint.hpp"
87: #include "duckdb/parser/expression/parameter_expression.hpp"
88: #include "duckdb/parser/expression/window_expression.hpp"
89: #include "duckdb/parser/parsed_data/alter_info.hpp"
90: #include "duckdb/parser/parsed_data/alter_scalar_function_info.hpp"
91: #include "duckdb/parser/parsed_data/alter_table_function_info.hpp"
92: #include "duckdb/parser/parsed_data/alter_table_info.hpp"
93: #include "duckdb/parser/parsed_data/create_info.hpp"
94: #include "duckdb/parser/parsed_data/create_sequence_info.hpp"
95: #include "duckdb/parser/parsed_data/load_info.hpp"
96: #include "duckdb/parser/parsed_data/parse_info.hpp"
97: #include "duckdb/parser/parsed_data/pragma_info.hpp"
98: #include "duckdb/parser/parsed_data/sample_options.hpp"
99: #include "duckdb/parser/parsed_data/transaction_info.hpp"
100: #include "duckdb/parser/parser_extension.hpp"
101: #include "duckdb/parser/query_node.hpp"
102: #include "duckdb/parser/result_modifier.hpp"
103: #include "duckdb/parser/simplified_token.hpp"
104: #include "duckdb/parser/statement/explain_statement.hpp"
105: #include "duckdb/parser/statement/insert_statement.hpp"
106: #include "duckdb/planner/binder.hpp"
107: #include "duckdb/planner/bound_result_modifier.hpp"
108: #include "duckdb/planner/table_filter.hpp"
109: #include "duckdb/storage/buffer/block_handle.hpp"
110: #include "duckdb/storage/compression/bitpacking.hpp"
111: #include "duckdb/storage/magic_bytes.hpp"
112: #include "duckdb/storage/statistics/base_statistics.hpp"
113: #include "duckdb/storage/table/chunk_info.hpp"
114: #include "duckdb/storage/table/column_segment.hpp"
115: #include "duckdb/verification/statement_verifier.hpp"
116: 
117: namespace duckdb {
118: 
119: template<>
120: const char* EnumUtil::ToChars<AccessMode>(AccessMode value) {
121: 	switch(value) {
122: 	case AccessMode::UNDEFINED:
123: 		return "UNDEFINED";
124: 	case AccessMode::AUTOMATIC:
125: 		return "AUTOMATIC";
126: 	case AccessMode::READ_ONLY:
127: 		return "READ_ONLY";
128: 	case AccessMode::READ_WRITE:
129: 		return "READ_WRITE";
130: 	default:
131: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
132: 	}
133: }
134: 
135: template<>
136: AccessMode EnumUtil::FromString<AccessMode>(const char *value) {
137: 	if (StringUtil::Equals(value, "UNDEFINED")) {
138: 		return AccessMode::UNDEFINED;
139: 	}
140: 	if (StringUtil::Equals(value, "AUTOMATIC")) {
141: 		return AccessMode::AUTOMATIC;
142: 	}
143: 	if (StringUtil::Equals(value, "READ_ONLY")) {
144: 		return AccessMode::READ_ONLY;
145: 	}
146: 	if (StringUtil::Equals(value, "READ_WRITE")) {
147: 		return AccessMode::READ_WRITE;
148: 	}
149: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
150: }
151: 
152: template<>
153: const char* EnumUtil::ToChars<AggregateHandling>(AggregateHandling value) {
154: 	switch(value) {
155: 	case AggregateHandling::STANDARD_HANDLING:
156: 		return "STANDARD_HANDLING";
157: 	case AggregateHandling::NO_AGGREGATES_ALLOWED:
158: 		return "NO_AGGREGATES_ALLOWED";
159: 	case AggregateHandling::FORCE_AGGREGATES:
160: 		return "FORCE_AGGREGATES";
161: 	default:
162: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
163: 	}
164: }
165: 
166: template<>
167: AggregateHandling EnumUtil::FromString<AggregateHandling>(const char *value) {
168: 	if (StringUtil::Equals(value, "STANDARD_HANDLING")) {
169: 		return AggregateHandling::STANDARD_HANDLING;
170: 	}
171: 	if (StringUtil::Equals(value, "NO_AGGREGATES_ALLOWED")) {
172: 		return AggregateHandling::NO_AGGREGATES_ALLOWED;
173: 	}
174: 	if (StringUtil::Equals(value, "FORCE_AGGREGATES")) {
175: 		return AggregateHandling::FORCE_AGGREGATES;
176: 	}
177: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
178: }
179: 
180: template<>
181: const char* EnumUtil::ToChars<AggregateOrderDependent>(AggregateOrderDependent value) {
182: 	switch(value) {
183: 	case AggregateOrderDependent::ORDER_DEPENDENT:
184: 		return "ORDER_DEPENDENT";
185: 	case AggregateOrderDependent::NOT_ORDER_DEPENDENT:
186: 		return "NOT_ORDER_DEPENDENT";
187: 	default:
188: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
189: 	}
190: }
191: 
192: template<>
193: AggregateOrderDependent EnumUtil::FromString<AggregateOrderDependent>(const char *value) {
194: 	if (StringUtil::Equals(value, "ORDER_DEPENDENT")) {
195: 		return AggregateOrderDependent::ORDER_DEPENDENT;
196: 	}
197: 	if (StringUtil::Equals(value, "NOT_ORDER_DEPENDENT")) {
198: 		return AggregateOrderDependent::NOT_ORDER_DEPENDENT;
199: 	}
200: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
201: }
202: 
203: template<>
204: const char* EnumUtil::ToChars<AggregateType>(AggregateType value) {
205: 	switch(value) {
206: 	case AggregateType::NON_DISTINCT:
207: 		return "NON_DISTINCT";
208: 	case AggregateType::DISTINCT:
209: 		return "DISTINCT";
210: 	default:
211: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
212: 	}
213: }
214: 
215: template<>
216: AggregateType EnumUtil::FromString<AggregateType>(const char *value) {
217: 	if (StringUtil::Equals(value, "NON_DISTINCT")) {
218: 		return AggregateType::NON_DISTINCT;
219: 	}
220: 	if (StringUtil::Equals(value, "DISTINCT")) {
221: 		return AggregateType::DISTINCT;
222: 	}
223: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
224: }
225: 
226: template<>
227: const char* EnumUtil::ToChars<AlterForeignKeyType>(AlterForeignKeyType value) {
228: 	switch(value) {
229: 	case AlterForeignKeyType::AFT_ADD:
230: 		return "AFT_ADD";
231: 	case AlterForeignKeyType::AFT_DELETE:
232: 		return "AFT_DELETE";
233: 	default:
234: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
235: 	}
236: }
237: 
238: template<>
239: AlterForeignKeyType EnumUtil::FromString<AlterForeignKeyType>(const char *value) {
240: 	if (StringUtil::Equals(value, "AFT_ADD")) {
241: 		return AlterForeignKeyType::AFT_ADD;
242: 	}
243: 	if (StringUtil::Equals(value, "AFT_DELETE")) {
244: 		return AlterForeignKeyType::AFT_DELETE;
245: 	}
246: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
247: }
248: 
249: template<>
250: const char* EnumUtil::ToChars<AlterScalarFunctionType>(AlterScalarFunctionType value) {
251: 	switch(value) {
252: 	case AlterScalarFunctionType::INVALID:
253: 		return "INVALID";
254: 	case AlterScalarFunctionType::ADD_FUNCTION_OVERLOADS:
255: 		return "ADD_FUNCTION_OVERLOADS";
256: 	default:
257: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
258: 	}
259: }
260: 
261: template<>
262: AlterScalarFunctionType EnumUtil::FromString<AlterScalarFunctionType>(const char *value) {
263: 	if (StringUtil::Equals(value, "INVALID")) {
264: 		return AlterScalarFunctionType::INVALID;
265: 	}
266: 	if (StringUtil::Equals(value, "ADD_FUNCTION_OVERLOADS")) {
267: 		return AlterScalarFunctionType::ADD_FUNCTION_OVERLOADS;
268: 	}
269: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
270: }
271: 
272: template<>
273: const char* EnumUtil::ToChars<AlterTableFunctionType>(AlterTableFunctionType value) {
274: 	switch(value) {
275: 	case AlterTableFunctionType::INVALID:
276: 		return "INVALID";
277: 	case AlterTableFunctionType::ADD_FUNCTION_OVERLOADS:
278: 		return "ADD_FUNCTION_OVERLOADS";
279: 	default:
280: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
281: 	}
282: }
283: 
284: template<>
285: AlterTableFunctionType EnumUtil::FromString<AlterTableFunctionType>(const char *value) {
286: 	if (StringUtil::Equals(value, "INVALID")) {
287: 		return AlterTableFunctionType::INVALID;
288: 	}
289: 	if (StringUtil::Equals(value, "ADD_FUNCTION_OVERLOADS")) {
290: 		return AlterTableFunctionType::ADD_FUNCTION_OVERLOADS;
291: 	}
292: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
293: }
294: 
295: template<>
296: const char* EnumUtil::ToChars<AlterTableType>(AlterTableType value) {
297: 	switch(value) {
298: 	case AlterTableType::INVALID:
299: 		return "INVALID";
300: 	case AlterTableType::RENAME_COLUMN:
301: 		return "RENAME_COLUMN";
302: 	case AlterTableType::RENAME_TABLE:
303: 		return "RENAME_TABLE";
304: 	case AlterTableType::ADD_COLUMN:
305: 		return "ADD_COLUMN";
306: 	case AlterTableType::REMOVE_COLUMN:
307: 		return "REMOVE_COLUMN";
308: 	case AlterTableType::ALTER_COLUMN_TYPE:
309: 		return "ALTER_COLUMN_TYPE";
310: 	case AlterTableType::SET_DEFAULT:
311: 		return "SET_DEFAULT";
312: 	case AlterTableType::FOREIGN_KEY_CONSTRAINT:
313: 		return "FOREIGN_KEY_CONSTRAINT";
314: 	case AlterTableType::SET_NOT_NULL:
315: 		return "SET_NOT_NULL";
316: 	case AlterTableType::DROP_NOT_NULL:
317: 		return "DROP_NOT_NULL";
318: 	default:
319: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
320: 	}
321: }
322: 
323: template<>
324: AlterTableType EnumUtil::FromString<AlterTableType>(const char *value) {
325: 	if (StringUtil::Equals(value, "INVALID")) {
326: 		return AlterTableType::INVALID;
327: 	}
328: 	if (StringUtil::Equals(value, "RENAME_COLUMN")) {
329: 		return AlterTableType::RENAME_COLUMN;
330: 	}
331: 	if (StringUtil::Equals(value, "RENAME_TABLE")) {
332: 		return AlterTableType::RENAME_TABLE;
333: 	}
334: 	if (StringUtil::Equals(value, "ADD_COLUMN")) {
335: 		return AlterTableType::ADD_COLUMN;
336: 	}
337: 	if (StringUtil::Equals(value, "REMOVE_COLUMN")) {
338: 		return AlterTableType::REMOVE_COLUMN;
339: 	}
340: 	if (StringUtil::Equals(value, "ALTER_COLUMN_TYPE")) {
341: 		return AlterTableType::ALTER_COLUMN_TYPE;
342: 	}
343: 	if (StringUtil::Equals(value, "SET_DEFAULT")) {
344: 		return AlterTableType::SET_DEFAULT;
345: 	}
346: 	if (StringUtil::Equals(value, "FOREIGN_KEY_CONSTRAINT")) {
347: 		return AlterTableType::FOREIGN_KEY_CONSTRAINT;
348: 	}
349: 	if (StringUtil::Equals(value, "SET_NOT_NULL")) {
350: 		return AlterTableType::SET_NOT_NULL;
351: 	}
352: 	if (StringUtil::Equals(value, "DROP_NOT_NULL")) {
353: 		return AlterTableType::DROP_NOT_NULL;
354: 	}
355: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
356: }
357: 
358: template<>
359: const char* EnumUtil::ToChars<AlterType>(AlterType value) {
360: 	switch(value) {
361: 	case AlterType::INVALID:
362: 		return "INVALID";
363: 	case AlterType::ALTER_TABLE:
364: 		return "ALTER_TABLE";
365: 	case AlterType::ALTER_VIEW:
366: 		return "ALTER_VIEW";
367: 	case AlterType::ALTER_SEQUENCE:
368: 		return "ALTER_SEQUENCE";
369: 	case AlterType::CHANGE_OWNERSHIP:
370: 		return "CHANGE_OWNERSHIP";
371: 	case AlterType::ALTER_SCALAR_FUNCTION:
372: 		return "ALTER_SCALAR_FUNCTION";
373: 	case AlterType::ALTER_TABLE_FUNCTION:
374: 		return "ALTER_TABLE_FUNCTION";
375: 	default:
376: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
377: 	}
378: }
379: 
380: template<>
381: AlterType EnumUtil::FromString<AlterType>(const char *value) {
382: 	if (StringUtil::Equals(value, "INVALID")) {
383: 		return AlterType::INVALID;
384: 	}
385: 	if (StringUtil::Equals(value, "ALTER_TABLE")) {
386: 		return AlterType::ALTER_TABLE;
387: 	}
388: 	if (StringUtil::Equals(value, "ALTER_VIEW")) {
389: 		return AlterType::ALTER_VIEW;
390: 	}
391: 	if (StringUtil::Equals(value, "ALTER_SEQUENCE")) {
392: 		return AlterType::ALTER_SEQUENCE;
393: 	}
394: 	if (StringUtil::Equals(value, "CHANGE_OWNERSHIP")) {
395: 		return AlterType::CHANGE_OWNERSHIP;
396: 	}
397: 	if (StringUtil::Equals(value, "ALTER_SCALAR_FUNCTION")) {
398: 		return AlterType::ALTER_SCALAR_FUNCTION;
399: 	}
400: 	if (StringUtil::Equals(value, "ALTER_TABLE_FUNCTION")) {
401: 		return AlterType::ALTER_TABLE_FUNCTION;
402: 	}
403: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
404: }
405: 
406: template<>
407: const char* EnumUtil::ToChars<AlterViewType>(AlterViewType value) {
408: 	switch(value) {
409: 	case AlterViewType::INVALID:
410: 		return "INVALID";
411: 	case AlterViewType::RENAME_VIEW:
412: 		return "RENAME_VIEW";
413: 	default:
414: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
415: 	}
416: }
417: 
418: template<>
419: AlterViewType EnumUtil::FromString<AlterViewType>(const char *value) {
420: 	if (StringUtil::Equals(value, "INVALID")) {
421: 		return AlterViewType::INVALID;
422: 	}
423: 	if (StringUtil::Equals(value, "RENAME_VIEW")) {
424: 		return AlterViewType::RENAME_VIEW;
425: 	}
426: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
427: }
428: 
429: template<>
430: const char* EnumUtil::ToChars<AppenderType>(AppenderType value) {
431: 	switch(value) {
432: 	case AppenderType::LOGICAL:
433: 		return "LOGICAL";
434: 	case AppenderType::PHYSICAL:
435: 		return "PHYSICAL";
436: 	default:
437: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
438: 	}
439: }
440: 
441: template<>
442: AppenderType EnumUtil::FromString<AppenderType>(const char *value) {
443: 	if (StringUtil::Equals(value, "LOGICAL")) {
444: 		return AppenderType::LOGICAL;
445: 	}
446: 	if (StringUtil::Equals(value, "PHYSICAL")) {
447: 		return AppenderType::PHYSICAL;
448: 	}
449: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
450: }
451: 
452: template<>
453: const char* EnumUtil::ToChars<ArrowDateTimeType>(ArrowDateTimeType value) {
454: 	switch(value) {
455: 	case ArrowDateTimeType::MILLISECONDS:
456: 		return "MILLISECONDS";
457: 	case ArrowDateTimeType::MICROSECONDS:
458: 		return "MICROSECONDS";
459: 	case ArrowDateTimeType::NANOSECONDS:
460: 		return "NANOSECONDS";
461: 	case ArrowDateTimeType::SECONDS:
462: 		return "SECONDS";
463: 	case ArrowDateTimeType::DAYS:
464: 		return "DAYS";
465: 	case ArrowDateTimeType::MONTHS:
466: 		return "MONTHS";
467: 	case ArrowDateTimeType::MONTH_DAY_NANO:
468: 		return "MONTH_DAY_NANO";
469: 	default:
470: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
471: 	}
472: }
473: 
474: template<>
475: ArrowDateTimeType EnumUtil::FromString<ArrowDateTimeType>(const char *value) {
476: 	if (StringUtil::Equals(value, "MILLISECONDS")) {
477: 		return ArrowDateTimeType::MILLISECONDS;
478: 	}
479: 	if (StringUtil::Equals(value, "MICROSECONDS")) {
480: 		return ArrowDateTimeType::MICROSECONDS;
481: 	}
482: 	if (StringUtil::Equals(value, "NANOSECONDS")) {
483: 		return ArrowDateTimeType::NANOSECONDS;
484: 	}
485: 	if (StringUtil::Equals(value, "SECONDS")) {
486: 		return ArrowDateTimeType::SECONDS;
487: 	}
488: 	if (StringUtil::Equals(value, "DAYS")) {
489: 		return ArrowDateTimeType::DAYS;
490: 	}
491: 	if (StringUtil::Equals(value, "MONTHS")) {
492: 		return ArrowDateTimeType::MONTHS;
493: 	}
494: 	if (StringUtil::Equals(value, "MONTH_DAY_NANO")) {
495: 		return ArrowDateTimeType::MONTH_DAY_NANO;
496: 	}
497: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
498: }
499: 
500: template<>
501: const char* EnumUtil::ToChars<ArrowVariableSizeType>(ArrowVariableSizeType value) {
502: 	switch(value) {
503: 	case ArrowVariableSizeType::FIXED_SIZE:
504: 		return "FIXED_SIZE";
505: 	case ArrowVariableSizeType::NORMAL:
506: 		return "NORMAL";
507: 	case ArrowVariableSizeType::SUPER_SIZE:
508: 		return "SUPER_SIZE";
509: 	default:
510: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
511: 	}
512: }
513: 
514: template<>
515: ArrowVariableSizeType EnumUtil::FromString<ArrowVariableSizeType>(const char *value) {
516: 	if (StringUtil::Equals(value, "FIXED_SIZE")) {
517: 		return ArrowVariableSizeType::FIXED_SIZE;
518: 	}
519: 	if (StringUtil::Equals(value, "NORMAL")) {
520: 		return ArrowVariableSizeType::NORMAL;
521: 	}
522: 	if (StringUtil::Equals(value, "SUPER_SIZE")) {
523: 		return ArrowVariableSizeType::SUPER_SIZE;
524: 	}
525: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
526: }
527: 
528: template<>
529: const char* EnumUtil::ToChars<BindingMode>(BindingMode value) {
530: 	switch(value) {
531: 	case BindingMode::STANDARD_BINDING:
532: 		return "STANDARD_BINDING";
533: 	case BindingMode::EXTRACT_NAMES:
534: 		return "EXTRACT_NAMES";
535: 	default:
536: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
537: 	}
538: }
539: 
540: template<>
541: BindingMode EnumUtil::FromString<BindingMode>(const char *value) {
542: 	if (StringUtil::Equals(value, "STANDARD_BINDING")) {
543: 		return BindingMode::STANDARD_BINDING;
544: 	}
545: 	if (StringUtil::Equals(value, "EXTRACT_NAMES")) {
546: 		return BindingMode::EXTRACT_NAMES;
547: 	}
548: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
549: }
550: 
551: template<>
552: const char* EnumUtil::ToChars<BitpackingMode>(BitpackingMode value) {
553: 	switch(value) {
554: 	case BitpackingMode::INVALID:
555: 		return "INVALID";
556: 	case BitpackingMode::AUTO:
557: 		return "AUTO";
558: 	case BitpackingMode::CONSTANT:
559: 		return "CONSTANT";
560: 	case BitpackingMode::CONSTANT_DELTA:
561: 		return "CONSTANT_DELTA";
562: 	case BitpackingMode::DELTA_FOR:
563: 		return "DELTA_FOR";
564: 	case BitpackingMode::FOR:
565: 		return "FOR";
566: 	default:
567: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
568: 	}
569: }
570: 
571: template<>
572: BitpackingMode EnumUtil::FromString<BitpackingMode>(const char *value) {
573: 	if (StringUtil::Equals(value, "INVALID")) {
574: 		return BitpackingMode::INVALID;
575: 	}
576: 	if (StringUtil::Equals(value, "AUTO")) {
577: 		return BitpackingMode::AUTO;
578: 	}
579: 	if (StringUtil::Equals(value, "CONSTANT")) {
580: 		return BitpackingMode::CONSTANT;
581: 	}
582: 	if (StringUtil::Equals(value, "CONSTANT_DELTA")) {
583: 		return BitpackingMode::CONSTANT_DELTA;
584: 	}
585: 	if (StringUtil::Equals(value, "DELTA_FOR")) {
586: 		return BitpackingMode::DELTA_FOR;
587: 	}
588: 	if (StringUtil::Equals(value, "FOR")) {
589: 		return BitpackingMode::FOR;
590: 	}
591: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
592: }
593: 
594: template<>
595: const char* EnumUtil::ToChars<BlockState>(BlockState value) {
596: 	switch(value) {
597: 	case BlockState::BLOCK_UNLOADED:
598: 		return "BLOCK_UNLOADED";
599: 	case BlockState::BLOCK_LOADED:
600: 		return "BLOCK_LOADED";
601: 	default:
602: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
603: 	}
604: }
605: 
606: template<>
607: BlockState EnumUtil::FromString<BlockState>(const char *value) {
608: 	if (StringUtil::Equals(value, "BLOCK_UNLOADED")) {
609: 		return BlockState::BLOCK_UNLOADED;
610: 	}
611: 	if (StringUtil::Equals(value, "BLOCK_LOADED")) {
612: 		return BlockState::BLOCK_LOADED;
613: 	}
614: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
615: }
616: 
617: template<>
618: const char* EnumUtil::ToChars<CAPIResultSetType>(CAPIResultSetType value) {
619: 	switch(value) {
620: 	case CAPIResultSetType::CAPI_RESULT_TYPE_NONE:
621: 		return "CAPI_RESULT_TYPE_NONE";
622: 	case CAPIResultSetType::CAPI_RESULT_TYPE_MATERIALIZED:
623: 		return "CAPI_RESULT_TYPE_MATERIALIZED";
624: 	case CAPIResultSetType::CAPI_RESULT_TYPE_STREAMING:
625: 		return "CAPI_RESULT_TYPE_STREAMING";
626: 	case CAPIResultSetType::CAPI_RESULT_TYPE_DEPRECATED:
627: 		return "CAPI_RESULT_TYPE_DEPRECATED";
628: 	default:
629: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
630: 	}
631: }
632: 
633: template<>
634: CAPIResultSetType EnumUtil::FromString<CAPIResultSetType>(const char *value) {
635: 	if (StringUtil::Equals(value, "CAPI_RESULT_TYPE_NONE")) {
636: 		return CAPIResultSetType::CAPI_RESULT_TYPE_NONE;
637: 	}
638: 	if (StringUtil::Equals(value, "CAPI_RESULT_TYPE_MATERIALIZED")) {
639: 		return CAPIResultSetType::CAPI_RESULT_TYPE_MATERIALIZED;
640: 	}
641: 	if (StringUtil::Equals(value, "CAPI_RESULT_TYPE_STREAMING")) {
642: 		return CAPIResultSetType::CAPI_RESULT_TYPE_STREAMING;
643: 	}
644: 	if (StringUtil::Equals(value, "CAPI_RESULT_TYPE_DEPRECATED")) {
645: 		return CAPIResultSetType::CAPI_RESULT_TYPE_DEPRECATED;
646: 	}
647: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
648: }
649: 
650: template<>
651: const char* EnumUtil::ToChars<CSVState>(CSVState value) {
652: 	switch(value) {
653: 	case CSVState::STANDARD:
654: 		return "STANDARD";
655: 	case CSVState::DELIMITER:
656: 		return "DELIMITER";
657: 	case CSVState::RECORD_SEPARATOR:
658: 		return "RECORD_SEPARATOR";
659: 	case CSVState::CARRIAGE_RETURN:
660: 		return "CARRIAGE_RETURN";
661: 	case CSVState::QUOTED:
662: 		return "QUOTED";
663: 	case CSVState::UNQUOTED:
664: 		return "UNQUOTED";
665: 	case CSVState::ESCAPE:
666: 		return "ESCAPE";
667: 	case CSVState::EMPTY_LINE:
668: 		return "EMPTY_LINE";
669: 	case CSVState::INVALID:
670: 		return "INVALID";
671: 	default:
672: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
673: 	}
674: }
675: 
676: template<>
677: CSVState EnumUtil::FromString<CSVState>(const char *value) {
678: 	if (StringUtil::Equals(value, "STANDARD")) {
679: 		return CSVState::STANDARD;
680: 	}
681: 	if (StringUtil::Equals(value, "DELIMITER")) {
682: 		return CSVState::DELIMITER;
683: 	}
684: 	if (StringUtil::Equals(value, "RECORD_SEPARATOR")) {
685: 		return CSVState::RECORD_SEPARATOR;
686: 	}
687: 	if (StringUtil::Equals(value, "CARRIAGE_RETURN")) {
688: 		return CSVState::CARRIAGE_RETURN;
689: 	}
690: 	if (StringUtil::Equals(value, "QUOTED")) {
691: 		return CSVState::QUOTED;
692: 	}
693: 	if (StringUtil::Equals(value, "UNQUOTED")) {
694: 		return CSVState::UNQUOTED;
695: 	}
696: 	if (StringUtil::Equals(value, "ESCAPE")) {
697: 		return CSVState::ESCAPE;
698: 	}
699: 	if (StringUtil::Equals(value, "EMPTY_LINE")) {
700: 		return CSVState::EMPTY_LINE;
701: 	}
702: 	if (StringUtil::Equals(value, "INVALID")) {
703: 		return CSVState::INVALID;
704: 	}
705: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
706: }
707: 
708: template<>
709: const char* EnumUtil::ToChars<CTEMaterialize>(CTEMaterialize value) {
710: 	switch(value) {
711: 	case CTEMaterialize::CTE_MATERIALIZE_DEFAULT:
712: 		return "CTE_MATERIALIZE_DEFAULT";
713: 	case CTEMaterialize::CTE_MATERIALIZE_ALWAYS:
714: 		return "CTE_MATERIALIZE_ALWAYS";
715: 	case CTEMaterialize::CTE_MATERIALIZE_NEVER:
716: 		return "CTE_MATERIALIZE_NEVER";
717: 	default:
718: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
719: 	}
720: }
721: 
722: template<>
723: CTEMaterialize EnumUtil::FromString<CTEMaterialize>(const char *value) {
724: 	if (StringUtil::Equals(value, "CTE_MATERIALIZE_DEFAULT")) {
725: 		return CTEMaterialize::CTE_MATERIALIZE_DEFAULT;
726: 	}
727: 	if (StringUtil::Equals(value, "CTE_MATERIALIZE_ALWAYS")) {
728: 		return CTEMaterialize::CTE_MATERIALIZE_ALWAYS;
729: 	}
730: 	if (StringUtil::Equals(value, "CTE_MATERIALIZE_NEVER")) {
731: 		return CTEMaterialize::CTE_MATERIALIZE_NEVER;
732: 	}
733: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
734: }
735: 
736: template<>
737: const char* EnumUtil::ToChars<CatalogType>(CatalogType value) {
738: 	switch(value) {
739: 	case CatalogType::INVALID:
740: 		return "INVALID";
741: 	case CatalogType::TABLE_ENTRY:
742: 		return "TABLE_ENTRY";
743: 	case CatalogType::SCHEMA_ENTRY:
744: 		return "SCHEMA_ENTRY";
745: 	case CatalogType::VIEW_ENTRY:
746: 		return "VIEW_ENTRY";
747: 	case CatalogType::INDEX_ENTRY:
748: 		return "INDEX_ENTRY";
749: 	case CatalogType::PREPARED_STATEMENT:
750: 		return "PREPARED_STATEMENT";
751: 	case CatalogType::SEQUENCE_ENTRY:
752: 		return "SEQUENCE_ENTRY";
753: 	case CatalogType::COLLATION_ENTRY:
754: 		return "COLLATION_ENTRY";
755: 	case CatalogType::TYPE_ENTRY:
756: 		return "TYPE_ENTRY";
757: 	case CatalogType::DATABASE_ENTRY:
758: 		return "DATABASE_ENTRY";
759: 	case CatalogType::TABLE_FUNCTION_ENTRY:
760: 		return "TABLE_FUNCTION_ENTRY";
761: 	case CatalogType::SCALAR_FUNCTION_ENTRY:
762: 		return "SCALAR_FUNCTION_ENTRY";
763: 	case CatalogType::AGGREGATE_FUNCTION_ENTRY:
764: 		return "AGGREGATE_FUNCTION_ENTRY";
765: 	case CatalogType::PRAGMA_FUNCTION_ENTRY:
766: 		return "PRAGMA_FUNCTION_ENTRY";
767: 	case CatalogType::COPY_FUNCTION_ENTRY:
768: 		return "COPY_FUNCTION_ENTRY";
769: 	case CatalogType::MACRO_ENTRY:
770: 		return "MACRO_ENTRY";
771: 	case CatalogType::TABLE_MACRO_ENTRY:
772: 		return "TABLE_MACRO_ENTRY";
773: 	case CatalogType::UPDATED_ENTRY:
774: 		return "UPDATED_ENTRY";
775: 	case CatalogType::DELETED_ENTRY:
776: 		return "DELETED_ENTRY";
777: 	default:
778: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
779: 	}
780: }
781: 
782: template<>
783: CatalogType EnumUtil::FromString<CatalogType>(const char *value) {
784: 	if (StringUtil::Equals(value, "INVALID")) {
785: 		return CatalogType::INVALID;
786: 	}
787: 	if (StringUtil::Equals(value, "TABLE_ENTRY")) {
788: 		return CatalogType::TABLE_ENTRY;
789: 	}
790: 	if (StringUtil::Equals(value, "SCHEMA_ENTRY")) {
791: 		return CatalogType::SCHEMA_ENTRY;
792: 	}
793: 	if (StringUtil::Equals(value, "VIEW_ENTRY")) {
794: 		return CatalogType::VIEW_ENTRY;
795: 	}
796: 	if (StringUtil::Equals(value, "INDEX_ENTRY")) {
797: 		return CatalogType::INDEX_ENTRY;
798: 	}
799: 	if (StringUtil::Equals(value, "PREPARED_STATEMENT")) {
800: 		return CatalogType::PREPARED_STATEMENT;
801: 	}
802: 	if (StringUtil::Equals(value, "SEQUENCE_ENTRY")) {
803: 		return CatalogType::SEQUENCE_ENTRY;
804: 	}
805: 	if (StringUtil::Equals(value, "COLLATION_ENTRY")) {
806: 		return CatalogType::COLLATION_ENTRY;
807: 	}
808: 	if (StringUtil::Equals(value, "TYPE_ENTRY")) {
809: 		return CatalogType::TYPE_ENTRY;
810: 	}
811: 	if (StringUtil::Equals(value, "DATABASE_ENTRY")) {
812: 		return CatalogType::DATABASE_ENTRY;
813: 	}
814: 	if (StringUtil::Equals(value, "TABLE_FUNCTION_ENTRY")) {
815: 		return CatalogType::TABLE_FUNCTION_ENTRY;
816: 	}
817: 	if (StringUtil::Equals(value, "SCALAR_FUNCTION_ENTRY")) {
818: 		return CatalogType::SCALAR_FUNCTION_ENTRY;
819: 	}
820: 	if (StringUtil::Equals(value, "AGGREGATE_FUNCTION_ENTRY")) {
821: 		return CatalogType::AGGREGATE_FUNCTION_ENTRY;
822: 	}
823: 	if (StringUtil::Equals(value, "PRAGMA_FUNCTION_ENTRY")) {
824: 		return CatalogType::PRAGMA_FUNCTION_ENTRY;
825: 	}
826: 	if (StringUtil::Equals(value, "COPY_FUNCTION_ENTRY")) {
827: 		return CatalogType::COPY_FUNCTION_ENTRY;
828: 	}
829: 	if (StringUtil::Equals(value, "MACRO_ENTRY")) {
830: 		return CatalogType::MACRO_ENTRY;
831: 	}
832: 	if (StringUtil::Equals(value, "TABLE_MACRO_ENTRY")) {
833: 		return CatalogType::TABLE_MACRO_ENTRY;
834: 	}
835: 	if (StringUtil::Equals(value, "UPDATED_ENTRY")) {
836: 		return CatalogType::UPDATED_ENTRY;
837: 	}
838: 	if (StringUtil::Equals(value, "DELETED_ENTRY")) {
839: 		return CatalogType::DELETED_ENTRY;
840: 	}
841: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
842: }
843: 
844: template<>
845: const char* EnumUtil::ToChars<CheckpointAbort>(CheckpointAbort value) {
846: 	switch(value) {
847: 	case CheckpointAbort::NO_ABORT:
848: 		return "NO_ABORT";
849: 	case CheckpointAbort::DEBUG_ABORT_BEFORE_TRUNCATE:
850: 		return "DEBUG_ABORT_BEFORE_TRUNCATE";
851: 	case CheckpointAbort::DEBUG_ABORT_BEFORE_HEADER:
852: 		return "DEBUG_ABORT_BEFORE_HEADER";
853: 	case CheckpointAbort::DEBUG_ABORT_AFTER_FREE_LIST_WRITE:
854: 		return "DEBUG_ABORT_AFTER_FREE_LIST_WRITE";
855: 	default:
856: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
857: 	}
858: }
859: 
860: template<>
861: CheckpointAbort EnumUtil::FromString<CheckpointAbort>(const char *value) {
862: 	if (StringUtil::Equals(value, "NO_ABORT")) {
863: 		return CheckpointAbort::NO_ABORT;
864: 	}
865: 	if (StringUtil::Equals(value, "DEBUG_ABORT_BEFORE_TRUNCATE")) {
866: 		return CheckpointAbort::DEBUG_ABORT_BEFORE_TRUNCATE;
867: 	}
868: 	if (StringUtil::Equals(value, "DEBUG_ABORT_BEFORE_HEADER")) {
869: 		return CheckpointAbort::DEBUG_ABORT_BEFORE_HEADER;
870: 	}
871: 	if (StringUtil::Equals(value, "DEBUG_ABORT_AFTER_FREE_LIST_WRITE")) {
872: 		return CheckpointAbort::DEBUG_ABORT_AFTER_FREE_LIST_WRITE;
873: 	}
874: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
875: }
876: 
877: template<>
878: const char* EnumUtil::ToChars<ChunkInfoType>(ChunkInfoType value) {
879: 	switch(value) {
880: 	case ChunkInfoType::CONSTANT_INFO:
881: 		return "CONSTANT_INFO";
882: 	case ChunkInfoType::VECTOR_INFO:
883: 		return "VECTOR_INFO";
884: 	case ChunkInfoType::EMPTY_INFO:
885: 		return "EMPTY_INFO";
886: 	default:
887: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
888: 	}
889: }
890: 
891: template<>
892: ChunkInfoType EnumUtil::FromString<ChunkInfoType>(const char *value) {
893: 	if (StringUtil::Equals(value, "CONSTANT_INFO")) {
894: 		return ChunkInfoType::CONSTANT_INFO;
895: 	}
896: 	if (StringUtil::Equals(value, "VECTOR_INFO")) {
897: 		return ChunkInfoType::VECTOR_INFO;
898: 	}
899: 	if (StringUtil::Equals(value, "EMPTY_INFO")) {
900: 		return ChunkInfoType::EMPTY_INFO;
901: 	}
902: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
903: }
904: 
905: template<>
906: const char* EnumUtil::ToChars<ColumnDataAllocatorType>(ColumnDataAllocatorType value) {
907: 	switch(value) {
908: 	case ColumnDataAllocatorType::BUFFER_MANAGER_ALLOCATOR:
909: 		return "BUFFER_MANAGER_ALLOCATOR";
910: 	case ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR:
911: 		return "IN_MEMORY_ALLOCATOR";
912: 	case ColumnDataAllocatorType::HYBRID:
913: 		return "HYBRID";
914: 	default:
915: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
916: 	}
917: }
918: 
919: template<>
920: ColumnDataAllocatorType EnumUtil::FromString<ColumnDataAllocatorType>(const char *value) {
921: 	if (StringUtil::Equals(value, "BUFFER_MANAGER_ALLOCATOR")) {
922: 		return ColumnDataAllocatorType::BUFFER_MANAGER_ALLOCATOR;
923: 	}
924: 	if (StringUtil::Equals(value, "IN_MEMORY_ALLOCATOR")) {
925: 		return ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR;
926: 	}
927: 	if (StringUtil::Equals(value, "HYBRID")) {
928: 		return ColumnDataAllocatorType::HYBRID;
929: 	}
930: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
931: }
932: 
933: template<>
934: const char* EnumUtil::ToChars<ColumnDataScanProperties>(ColumnDataScanProperties value) {
935: 	switch(value) {
936: 	case ColumnDataScanProperties::INVALID:
937: 		return "INVALID";
938: 	case ColumnDataScanProperties::ALLOW_ZERO_COPY:
939: 		return "ALLOW_ZERO_COPY";
940: 	case ColumnDataScanProperties::DISALLOW_ZERO_COPY:
941: 		return "DISALLOW_ZERO_COPY";
942: 	default:
943: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
944: 	}
945: }
946: 
947: template<>
948: ColumnDataScanProperties EnumUtil::FromString<ColumnDataScanProperties>(const char *value) {
949: 	if (StringUtil::Equals(value, "INVALID")) {
950: 		return ColumnDataScanProperties::INVALID;
951: 	}
952: 	if (StringUtil::Equals(value, "ALLOW_ZERO_COPY")) {
953: 		return ColumnDataScanProperties::ALLOW_ZERO_COPY;
954: 	}
955: 	if (StringUtil::Equals(value, "DISALLOW_ZERO_COPY")) {
956: 		return ColumnDataScanProperties::DISALLOW_ZERO_COPY;
957: 	}
958: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
959: }
960: 
961: template<>
962: const char* EnumUtil::ToChars<ColumnSegmentType>(ColumnSegmentType value) {
963: 	switch(value) {
964: 	case ColumnSegmentType::TRANSIENT:
965: 		return "TRANSIENT";
966: 	case ColumnSegmentType::PERSISTENT:
967: 		return "PERSISTENT";
968: 	default:
969: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
970: 	}
971: }
972: 
973: template<>
974: ColumnSegmentType EnumUtil::FromString<ColumnSegmentType>(const char *value) {
975: 	if (StringUtil::Equals(value, "TRANSIENT")) {
976: 		return ColumnSegmentType::TRANSIENT;
977: 	}
978: 	if (StringUtil::Equals(value, "PERSISTENT")) {
979: 		return ColumnSegmentType::PERSISTENT;
980: 	}
981: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
982: }
983: 
984: template<>
985: const char* EnumUtil::ToChars<CompressedMaterializationDirection>(CompressedMaterializationDirection value) {
986: 	switch(value) {
987: 	case CompressedMaterializationDirection::INVALID:
988: 		return "INVALID";
989: 	case CompressedMaterializationDirection::COMPRESS:
990: 		return "COMPRESS";
991: 	case CompressedMaterializationDirection::DECOMPRESS:
992: 		return "DECOMPRESS";
993: 	default:
994: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
995: 	}
996: }
997: 
998: template<>
999: CompressedMaterializationDirection EnumUtil::FromString<CompressedMaterializationDirection>(const char *value) {
1000: 	if (StringUtil::Equals(value, "INVALID")) {
1001: 		return CompressedMaterializationDirection::INVALID;
1002: 	}
1003: 	if (StringUtil::Equals(value, "COMPRESS")) {
1004: 		return CompressedMaterializationDirection::COMPRESS;
1005: 	}
1006: 	if (StringUtil::Equals(value, "DECOMPRESS")) {
1007: 		return CompressedMaterializationDirection::DECOMPRESS;
1008: 	}
1009: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1010: }
1011: 
1012: template<>
1013: const char* EnumUtil::ToChars<CompressionType>(CompressionType value) {
1014: 	switch(value) {
1015: 	case CompressionType::COMPRESSION_AUTO:
1016: 		return "COMPRESSION_AUTO";
1017: 	case CompressionType::COMPRESSION_UNCOMPRESSED:
1018: 		return "COMPRESSION_UNCOMPRESSED";
1019: 	case CompressionType::COMPRESSION_CONSTANT:
1020: 		return "COMPRESSION_CONSTANT";
1021: 	case CompressionType::COMPRESSION_RLE:
1022: 		return "COMPRESSION_RLE";
1023: 	case CompressionType::COMPRESSION_DICTIONARY:
1024: 		return "COMPRESSION_DICTIONARY";
1025: 	case CompressionType::COMPRESSION_PFOR_DELTA:
1026: 		return "COMPRESSION_PFOR_DELTA";
1027: 	case CompressionType::COMPRESSION_BITPACKING:
1028: 		return "COMPRESSION_BITPACKING";
1029: 	case CompressionType::COMPRESSION_FSST:
1030: 		return "COMPRESSION_FSST";
1031: 	case CompressionType::COMPRESSION_CHIMP:
1032: 		return "COMPRESSION_CHIMP";
1033: 	case CompressionType::COMPRESSION_PATAS:
1034: 		return "COMPRESSION_PATAS";
1035: 	case CompressionType::COMPRESSION_COUNT:
1036: 		return "COMPRESSION_COUNT";
1037: 	default:
1038: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1039: 	}
1040: }
1041: 
1042: template<>
1043: CompressionType EnumUtil::FromString<CompressionType>(const char *value) {
1044: 	if (StringUtil::Equals(value, "COMPRESSION_AUTO")) {
1045: 		return CompressionType::COMPRESSION_AUTO;
1046: 	}
1047: 	if (StringUtil::Equals(value, "COMPRESSION_UNCOMPRESSED")) {
1048: 		return CompressionType::COMPRESSION_UNCOMPRESSED;
1049: 	}
1050: 	if (StringUtil::Equals(value, "COMPRESSION_CONSTANT")) {
1051: 		return CompressionType::COMPRESSION_CONSTANT;
1052: 	}
1053: 	if (StringUtil::Equals(value, "COMPRESSION_RLE")) {
1054: 		return CompressionType::COMPRESSION_RLE;
1055: 	}
1056: 	if (StringUtil::Equals(value, "COMPRESSION_DICTIONARY")) {
1057: 		return CompressionType::COMPRESSION_DICTIONARY;
1058: 	}
1059: 	if (StringUtil::Equals(value, "COMPRESSION_PFOR_DELTA")) {
1060: 		return CompressionType::COMPRESSION_PFOR_DELTA;
1061: 	}
1062: 	if (StringUtil::Equals(value, "COMPRESSION_BITPACKING")) {
1063: 		return CompressionType::COMPRESSION_BITPACKING;
1064: 	}
1065: 	if (StringUtil::Equals(value, "COMPRESSION_FSST")) {
1066: 		return CompressionType::COMPRESSION_FSST;
1067: 	}
1068: 	if (StringUtil::Equals(value, "COMPRESSION_CHIMP")) {
1069: 		return CompressionType::COMPRESSION_CHIMP;
1070: 	}
1071: 	if (StringUtil::Equals(value, "COMPRESSION_PATAS")) {
1072: 		return CompressionType::COMPRESSION_PATAS;
1073: 	}
1074: 	if (StringUtil::Equals(value, "COMPRESSION_COUNT")) {
1075: 		return CompressionType::COMPRESSION_COUNT;
1076: 	}
1077: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1078: }
1079: 
1080: template<>
1081: const char* EnumUtil::ToChars<ConflictManagerMode>(ConflictManagerMode value) {
1082: 	switch(value) {
1083: 	case ConflictManagerMode::SCAN:
1084: 		return "SCAN";
1085: 	case ConflictManagerMode::THROW:
1086: 		return "THROW";
1087: 	default:
1088: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1089: 	}
1090: }
1091: 
1092: template<>
1093: ConflictManagerMode EnumUtil::FromString<ConflictManagerMode>(const char *value) {
1094: 	if (StringUtil::Equals(value, "SCAN")) {
1095: 		return ConflictManagerMode::SCAN;
1096: 	}
1097: 	if (StringUtil::Equals(value, "THROW")) {
1098: 		return ConflictManagerMode::THROW;
1099: 	}
1100: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1101: }
1102: 
1103: template<>
1104: const char* EnumUtil::ToChars<ConstraintType>(ConstraintType value) {
1105: 	switch(value) {
1106: 	case ConstraintType::INVALID:
1107: 		return "INVALID";
1108: 	case ConstraintType::NOT_NULL:
1109: 		return "NOT_NULL";
1110: 	case ConstraintType::CHECK:
1111: 		return "CHECK";
1112: 	case ConstraintType::UNIQUE:
1113: 		return "UNIQUE";
1114: 	case ConstraintType::FOREIGN_KEY:
1115: 		return "FOREIGN_KEY";
1116: 	default:
1117: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1118: 	}
1119: }
1120: 
1121: template<>
1122: ConstraintType EnumUtil::FromString<ConstraintType>(const char *value) {
1123: 	if (StringUtil::Equals(value, "INVALID")) {
1124: 		return ConstraintType::INVALID;
1125: 	}
1126: 	if (StringUtil::Equals(value, "NOT_NULL")) {
1127: 		return ConstraintType::NOT_NULL;
1128: 	}
1129: 	if (StringUtil::Equals(value, "CHECK")) {
1130: 		return ConstraintType::CHECK;
1131: 	}
1132: 	if (StringUtil::Equals(value, "UNIQUE")) {
1133: 		return ConstraintType::UNIQUE;
1134: 	}
1135: 	if (StringUtil::Equals(value, "FOREIGN_KEY")) {
1136: 		return ConstraintType::FOREIGN_KEY;
1137: 	}
1138: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1139: }
1140: 
1141: template<>
1142: const char* EnumUtil::ToChars<DataFileType>(DataFileType value) {
1143: 	switch(value) {
1144: 	case DataFileType::FILE_DOES_NOT_EXIST:
1145: 		return "FILE_DOES_NOT_EXIST";
1146: 	case DataFileType::DUCKDB_FILE:
1147: 		return "DUCKDB_FILE";
1148: 	case DataFileType::SQLITE_FILE:
1149: 		return "SQLITE_FILE";
1150: 	case DataFileType::PARQUET_FILE:
1151: 		return "PARQUET_FILE";
1152: 	default:
1153: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1154: 	}
1155: }
1156: 
1157: template<>
1158: DataFileType EnumUtil::FromString<DataFileType>(const char *value) {
1159: 	if (StringUtil::Equals(value, "FILE_DOES_NOT_EXIST")) {
1160: 		return DataFileType::FILE_DOES_NOT_EXIST;
1161: 	}
1162: 	if (StringUtil::Equals(value, "DUCKDB_FILE")) {
1163: 		return DataFileType::DUCKDB_FILE;
1164: 	}
1165: 	if (StringUtil::Equals(value, "SQLITE_FILE")) {
1166: 		return DataFileType::SQLITE_FILE;
1167: 	}
1168: 	if (StringUtil::Equals(value, "PARQUET_FILE")) {
1169: 		return DataFileType::PARQUET_FILE;
1170: 	}
1171: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1172: }
1173: 
1174: template<>
1175: const char* EnumUtil::ToChars<DatePartSpecifier>(DatePartSpecifier value) {
1176: 	switch(value) {
1177: 	case DatePartSpecifier::YEAR:
1178: 		return "YEAR";
1179: 	case DatePartSpecifier::MONTH:
1180: 		return "MONTH";
1181: 	case DatePartSpecifier::DAY:
1182: 		return "DAY";
1183: 	case DatePartSpecifier::DECADE:
1184: 		return "DECADE";
1185: 	case DatePartSpecifier::CENTURY:
1186: 		return "CENTURY";
1187: 	case DatePartSpecifier::MILLENNIUM:
1188: 		return "MILLENNIUM";
1189: 	case DatePartSpecifier::MICROSECONDS:
1190: 		return "MICROSECONDS";
1191: 	case DatePartSpecifier::MILLISECONDS:
1192: 		return "MILLISECONDS";
1193: 	case DatePartSpecifier::SECOND:
1194: 		return "SECOND";
1195: 	case DatePartSpecifier::MINUTE:
1196: 		return "MINUTE";
1197: 	case DatePartSpecifier::HOUR:
1198: 		return "HOUR";
1199: 	case DatePartSpecifier::EPOCH:
1200: 		return "EPOCH";
1201: 	case DatePartSpecifier::DOW:
1202: 		return "DOW";
1203: 	case DatePartSpecifier::ISODOW:
1204: 		return "ISODOW";
1205: 	case DatePartSpecifier::WEEK:
1206: 		return "WEEK";
1207: 	case DatePartSpecifier::ISOYEAR:
1208: 		return "ISOYEAR";
1209: 	case DatePartSpecifier::QUARTER:
1210: 		return "QUARTER";
1211: 	case DatePartSpecifier::DOY:
1212: 		return "DOY";
1213: 	case DatePartSpecifier::YEARWEEK:
1214: 		return "YEARWEEK";
1215: 	case DatePartSpecifier::ERA:
1216: 		return "ERA";
1217: 	case DatePartSpecifier::TIMEZONE:
1218: 		return "TIMEZONE";
1219: 	case DatePartSpecifier::TIMEZONE_HOUR:
1220: 		return "TIMEZONE_HOUR";
1221: 	case DatePartSpecifier::TIMEZONE_MINUTE:
1222: 		return "TIMEZONE_MINUTE";
1223: 	case DatePartSpecifier::JULIAN_DAY:
1224: 		return "JULIAN_DAY";
1225: 	default:
1226: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1227: 	}
1228: }
1229: 
1230: template<>
1231: DatePartSpecifier EnumUtil::FromString<DatePartSpecifier>(const char *value) {
1232: 	if (StringUtil::Equals(value, "YEAR")) {
1233: 		return DatePartSpecifier::YEAR;
1234: 	}
1235: 	if (StringUtil::Equals(value, "MONTH")) {
1236: 		return DatePartSpecifier::MONTH;
1237: 	}
1238: 	if (StringUtil::Equals(value, "DAY")) {
1239: 		return DatePartSpecifier::DAY;
1240: 	}
1241: 	if (StringUtil::Equals(value, "DECADE")) {
1242: 		return DatePartSpecifier::DECADE;
1243: 	}
1244: 	if (StringUtil::Equals(value, "CENTURY")) {
1245: 		return DatePartSpecifier::CENTURY;
1246: 	}
1247: 	if (StringUtil::Equals(value, "MILLENNIUM")) {
1248: 		return DatePartSpecifier::MILLENNIUM;
1249: 	}
1250: 	if (StringUtil::Equals(value, "MICROSECONDS")) {
1251: 		return DatePartSpecifier::MICROSECONDS;
1252: 	}
1253: 	if (StringUtil::Equals(value, "MILLISECONDS")) {
1254: 		return DatePartSpecifier::MILLISECONDS;
1255: 	}
1256: 	if (StringUtil::Equals(value, "SECOND")) {
1257: 		return DatePartSpecifier::SECOND;
1258: 	}
1259: 	if (StringUtil::Equals(value, "MINUTE")) {
1260: 		return DatePartSpecifier::MINUTE;
1261: 	}
1262: 	if (StringUtil::Equals(value, "HOUR")) {
1263: 		return DatePartSpecifier::HOUR;
1264: 	}
1265: 	if (StringUtil::Equals(value, "EPOCH")) {
1266: 		return DatePartSpecifier::EPOCH;
1267: 	}
1268: 	if (StringUtil::Equals(value, "DOW")) {
1269: 		return DatePartSpecifier::DOW;
1270: 	}
1271: 	if (StringUtil::Equals(value, "ISODOW")) {
1272: 		return DatePartSpecifier::ISODOW;
1273: 	}
1274: 	if (StringUtil::Equals(value, "WEEK")) {
1275: 		return DatePartSpecifier::WEEK;
1276: 	}
1277: 	if (StringUtil::Equals(value, "ISOYEAR")) {
1278: 		return DatePartSpecifier::ISOYEAR;
1279: 	}
1280: 	if (StringUtil::Equals(value, "QUARTER")) {
1281: 		return DatePartSpecifier::QUARTER;
1282: 	}
1283: 	if (StringUtil::Equals(value, "DOY")) {
1284: 		return DatePartSpecifier::DOY;
1285: 	}
1286: 	if (StringUtil::Equals(value, "YEARWEEK")) {
1287: 		return DatePartSpecifier::YEARWEEK;
1288: 	}
1289: 	if (StringUtil::Equals(value, "ERA")) {
1290: 		return DatePartSpecifier::ERA;
1291: 	}
1292: 	if (StringUtil::Equals(value, "TIMEZONE")) {
1293: 		return DatePartSpecifier::TIMEZONE;
1294: 	}
1295: 	if (StringUtil::Equals(value, "TIMEZONE_HOUR")) {
1296: 		return DatePartSpecifier::TIMEZONE_HOUR;
1297: 	}
1298: 	if (StringUtil::Equals(value, "TIMEZONE_MINUTE")) {
1299: 		return DatePartSpecifier::TIMEZONE_MINUTE;
1300: 	}
1301: 	if (StringUtil::Equals(value, "JULIAN_DAY")) {
1302: 		return DatePartSpecifier::JULIAN_DAY;
1303: 	}
1304: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1305: }
1306: 
1307: template<>
1308: const char* EnumUtil::ToChars<DebugInitialize>(DebugInitialize value) {
1309: 	switch(value) {
1310: 	case DebugInitialize::NO_INITIALIZE:
1311: 		return "NO_INITIALIZE";
1312: 	case DebugInitialize::DEBUG_ZERO_INITIALIZE:
1313: 		return "DEBUG_ZERO_INITIALIZE";
1314: 	case DebugInitialize::DEBUG_ONE_INITIALIZE:
1315: 		return "DEBUG_ONE_INITIALIZE";
1316: 	default:
1317: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1318: 	}
1319: }
1320: 
1321: template<>
1322: DebugInitialize EnumUtil::FromString<DebugInitialize>(const char *value) {
1323: 	if (StringUtil::Equals(value, "NO_INITIALIZE")) {
1324: 		return DebugInitialize::NO_INITIALIZE;
1325: 	}
1326: 	if (StringUtil::Equals(value, "DEBUG_ZERO_INITIALIZE")) {
1327: 		return DebugInitialize::DEBUG_ZERO_INITIALIZE;
1328: 	}
1329: 	if (StringUtil::Equals(value, "DEBUG_ONE_INITIALIZE")) {
1330: 		return DebugInitialize::DEBUG_ONE_INITIALIZE;
1331: 	}
1332: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1333: }
1334: 
1335: template<>
1336: const char* EnumUtil::ToChars<DefaultOrderByNullType>(DefaultOrderByNullType value) {
1337: 	switch(value) {
1338: 	case DefaultOrderByNullType::INVALID:
1339: 		return "INVALID";
1340: 	case DefaultOrderByNullType::NULLS_FIRST:
1341: 		return "NULLS_FIRST";
1342: 	case DefaultOrderByNullType::NULLS_LAST:
1343: 		return "NULLS_LAST";
1344: 	case DefaultOrderByNullType::NULLS_FIRST_ON_ASC_LAST_ON_DESC:
1345: 		return "NULLS_FIRST_ON_ASC_LAST_ON_DESC";
1346: 	case DefaultOrderByNullType::NULLS_LAST_ON_ASC_FIRST_ON_DESC:
1347: 		return "NULLS_LAST_ON_ASC_FIRST_ON_DESC";
1348: 	default:
1349: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1350: 	}
1351: }
1352: 
1353: template<>
1354: DefaultOrderByNullType EnumUtil::FromString<DefaultOrderByNullType>(const char *value) {
1355: 	if (StringUtil::Equals(value, "INVALID")) {
1356: 		return DefaultOrderByNullType::INVALID;
1357: 	}
1358: 	if (StringUtil::Equals(value, "NULLS_FIRST")) {
1359: 		return DefaultOrderByNullType::NULLS_FIRST;
1360: 	}
1361: 	if (StringUtil::Equals(value, "NULLS_LAST")) {
1362: 		return DefaultOrderByNullType::NULLS_LAST;
1363: 	}
1364: 	if (StringUtil::Equals(value, "NULLS_FIRST_ON_ASC_LAST_ON_DESC")) {
1365: 		return DefaultOrderByNullType::NULLS_FIRST_ON_ASC_LAST_ON_DESC;
1366: 	}
1367: 	if (StringUtil::Equals(value, "NULLS_LAST_ON_ASC_FIRST_ON_DESC")) {
1368: 		return DefaultOrderByNullType::NULLS_LAST_ON_ASC_FIRST_ON_DESC;
1369: 	}
1370: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1371: }
1372: 
1373: template<>
1374: const char* EnumUtil::ToChars<DistinctType>(DistinctType value) {
1375: 	switch(value) {
1376: 	case DistinctType::DISTINCT:
1377: 		return "DISTINCT";
1378: 	case DistinctType::DISTINCT_ON:
1379: 		return "DISTINCT_ON";
1380: 	default:
1381: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1382: 	}
1383: }
1384: 
1385: template<>
1386: DistinctType EnumUtil::FromString<DistinctType>(const char *value) {
1387: 	if (StringUtil::Equals(value, "DISTINCT")) {
1388: 		return DistinctType::DISTINCT;
1389: 	}
1390: 	if (StringUtil::Equals(value, "DISTINCT_ON")) {
1391: 		return DistinctType::DISTINCT_ON;
1392: 	}
1393: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1394: }
1395: 
1396: template<>
1397: const char* EnumUtil::ToChars<ErrorType>(ErrorType value) {
1398: 	switch(value) {
1399: 	case ErrorType::UNSIGNED_EXTENSION:
1400: 		return "UNSIGNED_EXTENSION";
1401: 	case ErrorType::INVALIDATED_TRANSACTION:
1402: 		return "INVALIDATED_TRANSACTION";
1403: 	case ErrorType::INVALIDATED_DATABASE:
1404: 		return "INVALIDATED_DATABASE";
1405: 	case ErrorType::ERROR_COUNT:
1406: 		return "ERROR_COUNT";
1407: 	case ErrorType::INVALID:
1408: 		return "INVALID";
1409: 	default:
1410: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1411: 	}
1412: }
1413: 
1414: template<>
1415: ErrorType EnumUtil::FromString<ErrorType>(const char *value) {
1416: 	if (StringUtil::Equals(value, "UNSIGNED_EXTENSION")) {
1417: 		return ErrorType::UNSIGNED_EXTENSION;
1418: 	}
1419: 	if (StringUtil::Equals(value, "INVALIDATED_TRANSACTION")) {
1420: 		return ErrorType::INVALIDATED_TRANSACTION;
1421: 	}
1422: 	if (StringUtil::Equals(value, "INVALIDATED_DATABASE")) {
1423: 		return ErrorType::INVALIDATED_DATABASE;
1424: 	}
1425: 	if (StringUtil::Equals(value, "ERROR_COUNT")) {
1426: 		return ErrorType::ERROR_COUNT;
1427: 	}
1428: 	if (StringUtil::Equals(value, "INVALID")) {
1429: 		return ErrorType::INVALID;
1430: 	}
1431: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1432: }
1433: 
1434: template<>
1435: const char* EnumUtil::ToChars<ExceptionFormatValueType>(ExceptionFormatValueType value) {
1436: 	switch(value) {
1437: 	case ExceptionFormatValueType::FORMAT_VALUE_TYPE_DOUBLE:
1438: 		return "FORMAT_VALUE_TYPE_DOUBLE";
1439: 	case ExceptionFormatValueType::FORMAT_VALUE_TYPE_INTEGER:
1440: 		return "FORMAT_VALUE_TYPE_INTEGER";
1441: 	case ExceptionFormatValueType::FORMAT_VALUE_TYPE_STRING:
1442: 		return "FORMAT_VALUE_TYPE_STRING";
1443: 	default:
1444: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1445: 	}
1446: }
1447: 
1448: template<>
1449: ExceptionFormatValueType EnumUtil::FromString<ExceptionFormatValueType>(const char *value) {
1450: 	if (StringUtil::Equals(value, "FORMAT_VALUE_TYPE_DOUBLE")) {
1451: 		return ExceptionFormatValueType::FORMAT_VALUE_TYPE_DOUBLE;
1452: 	}
1453: 	if (StringUtil::Equals(value, "FORMAT_VALUE_TYPE_INTEGER")) {
1454: 		return ExceptionFormatValueType::FORMAT_VALUE_TYPE_INTEGER;
1455: 	}
1456: 	if (StringUtil::Equals(value, "FORMAT_VALUE_TYPE_STRING")) {
1457: 		return ExceptionFormatValueType::FORMAT_VALUE_TYPE_STRING;
1458: 	}
1459: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1460: }
1461: 
1462: template<>
1463: const char* EnumUtil::ToChars<ExplainOutputType>(ExplainOutputType value) {
1464: 	switch(value) {
1465: 	case ExplainOutputType::ALL:
1466: 		return "ALL";
1467: 	case ExplainOutputType::OPTIMIZED_ONLY:
1468: 		return "OPTIMIZED_ONLY";
1469: 	case ExplainOutputType::PHYSICAL_ONLY:
1470: 		return "PHYSICAL_ONLY";
1471: 	default:
1472: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1473: 	}
1474: }
1475: 
1476: template<>
1477: ExplainOutputType EnumUtil::FromString<ExplainOutputType>(const char *value) {
1478: 	if (StringUtil::Equals(value, "ALL")) {
1479: 		return ExplainOutputType::ALL;
1480: 	}
1481: 	if (StringUtil::Equals(value, "OPTIMIZED_ONLY")) {
1482: 		return ExplainOutputType::OPTIMIZED_ONLY;
1483: 	}
1484: 	if (StringUtil::Equals(value, "PHYSICAL_ONLY")) {
1485: 		return ExplainOutputType::PHYSICAL_ONLY;
1486: 	}
1487: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1488: }
1489: 
1490: template<>
1491: const char* EnumUtil::ToChars<ExplainType>(ExplainType value) {
1492: 	switch(value) {
1493: 	case ExplainType::EXPLAIN_STANDARD:
1494: 		return "EXPLAIN_STANDARD";
1495: 	case ExplainType::EXPLAIN_ANALYZE:
1496: 		return "EXPLAIN_ANALYZE";
1497: 	default:
1498: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1499: 	}
1500: }
1501: 
1502: template<>
1503: ExplainType EnumUtil::FromString<ExplainType>(const char *value) {
1504: 	if (StringUtil::Equals(value, "EXPLAIN_STANDARD")) {
1505: 		return ExplainType::EXPLAIN_STANDARD;
1506: 	}
1507: 	if (StringUtil::Equals(value, "EXPLAIN_ANALYZE")) {
1508: 		return ExplainType::EXPLAIN_ANALYZE;
1509: 	}
1510: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1511: }
1512: 
1513: template<>
1514: const char* EnumUtil::ToChars<ExpressionClass>(ExpressionClass value) {
1515: 	switch(value) {
1516: 	case ExpressionClass::INVALID:
1517: 		return "INVALID";
1518: 	case ExpressionClass::AGGREGATE:
1519: 		return "AGGREGATE";
1520: 	case ExpressionClass::CASE:
1521: 		return "CASE";
1522: 	case ExpressionClass::CAST:
1523: 		return "CAST";
1524: 	case ExpressionClass::COLUMN_REF:
1525: 		return "COLUMN_REF";
1526: 	case ExpressionClass::COMPARISON:
1527: 		return "COMPARISON";
1528: 	case ExpressionClass::CONJUNCTION:
1529: 		return "CONJUNCTION";
1530: 	case ExpressionClass::CONSTANT:
1531: 		return "CONSTANT";
1532: 	case ExpressionClass::DEFAULT:
1533: 		return "DEFAULT";
1534: 	case ExpressionClass::FUNCTION:
1535: 		return "FUNCTION";
1536: 	case ExpressionClass::OPERATOR:
1537: 		return "OPERATOR";
1538: 	case ExpressionClass::STAR:
1539: 		return "STAR";
1540: 	case ExpressionClass::SUBQUERY:
1541: 		return "SUBQUERY";
1542: 	case ExpressionClass::WINDOW:
1543: 		return "WINDOW";
1544: 	case ExpressionClass::PARAMETER:
1545: 		return "PARAMETER";
1546: 	case ExpressionClass::COLLATE:
1547: 		return "COLLATE";
1548: 	case ExpressionClass::LAMBDA:
1549: 		return "LAMBDA";
1550: 	case ExpressionClass::POSITIONAL_REFERENCE:
1551: 		return "POSITIONAL_REFERENCE";
1552: 	case ExpressionClass::BETWEEN:
1553: 		return "BETWEEN";
1554: 	case ExpressionClass::BOUND_AGGREGATE:
1555: 		return "BOUND_AGGREGATE";
1556: 	case ExpressionClass::BOUND_CASE:
1557: 		return "BOUND_CASE";
1558: 	case ExpressionClass::BOUND_CAST:
1559: 		return "BOUND_CAST";
1560: 	case ExpressionClass::BOUND_COLUMN_REF:
1561: 		return "BOUND_COLUMN_REF";
1562: 	case ExpressionClass::BOUND_COMPARISON:
1563: 		return "BOUND_COMPARISON";
1564: 	case ExpressionClass::BOUND_CONJUNCTION:
1565: 		return "BOUND_CONJUNCTION";
1566: 	case ExpressionClass::BOUND_CONSTANT:
1567: 		return "BOUND_CONSTANT";
1568: 	case ExpressionClass::BOUND_DEFAULT:
1569: 		return "BOUND_DEFAULT";
1570: 	case ExpressionClass::BOUND_FUNCTION:
1571: 		return "BOUND_FUNCTION";
1572: 	case ExpressionClass::BOUND_OPERATOR:
1573: 		return "BOUND_OPERATOR";
1574: 	case ExpressionClass::BOUND_PARAMETER:
1575: 		return "BOUND_PARAMETER";
1576: 	case ExpressionClass::BOUND_REF:
1577: 		return "BOUND_REF";
1578: 	case ExpressionClass::BOUND_SUBQUERY:
1579: 		return "BOUND_SUBQUERY";
1580: 	case ExpressionClass::BOUND_WINDOW:
1581: 		return "BOUND_WINDOW";
1582: 	case ExpressionClass::BOUND_BETWEEN:
1583: 		return "BOUND_BETWEEN";
1584: 	case ExpressionClass::BOUND_UNNEST:
1585: 		return "BOUND_UNNEST";
1586: 	case ExpressionClass::BOUND_LAMBDA:
1587: 		return "BOUND_LAMBDA";
1588: 	case ExpressionClass::BOUND_LAMBDA_REF:
1589: 		return "BOUND_LAMBDA_REF";
1590: 	case ExpressionClass::BOUND_EXPRESSION:
1591: 		return "BOUND_EXPRESSION";
1592: 	default:
1593: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1594: 	}
1595: }
1596: 
1597: template<>
1598: ExpressionClass EnumUtil::FromString<ExpressionClass>(const char *value) {
1599: 	if (StringUtil::Equals(value, "INVALID")) {
1600: 		return ExpressionClass::INVALID;
1601: 	}
1602: 	if (StringUtil::Equals(value, "AGGREGATE")) {
1603: 		return ExpressionClass::AGGREGATE;
1604: 	}
1605: 	if (StringUtil::Equals(value, "CASE")) {
1606: 		return ExpressionClass::CASE;
1607: 	}
1608: 	if (StringUtil::Equals(value, "CAST")) {
1609: 		return ExpressionClass::CAST;
1610: 	}
1611: 	if (StringUtil::Equals(value, "COLUMN_REF")) {
1612: 		return ExpressionClass::COLUMN_REF;
1613: 	}
1614: 	if (StringUtil::Equals(value, "COMPARISON")) {
1615: 		return ExpressionClass::COMPARISON;
1616: 	}
1617: 	if (StringUtil::Equals(value, "CONJUNCTION")) {
1618: 		return ExpressionClass::CONJUNCTION;
1619: 	}
1620: 	if (StringUtil::Equals(value, "CONSTANT")) {
1621: 		return ExpressionClass::CONSTANT;
1622: 	}
1623: 	if (StringUtil::Equals(value, "DEFAULT")) {
1624: 		return ExpressionClass::DEFAULT;
1625: 	}
1626: 	if (StringUtil::Equals(value, "FUNCTION")) {
1627: 		return ExpressionClass::FUNCTION;
1628: 	}
1629: 	if (StringUtil::Equals(value, "OPERATOR")) {
1630: 		return ExpressionClass::OPERATOR;
1631: 	}
1632: 	if (StringUtil::Equals(value, "STAR")) {
1633: 		return ExpressionClass::STAR;
1634: 	}
1635: 	if (StringUtil::Equals(value, "SUBQUERY")) {
1636: 		return ExpressionClass::SUBQUERY;
1637: 	}
1638: 	if (StringUtil::Equals(value, "WINDOW")) {
1639: 		return ExpressionClass::WINDOW;
1640: 	}
1641: 	if (StringUtil::Equals(value, "PARAMETER")) {
1642: 		return ExpressionClass::PARAMETER;
1643: 	}
1644: 	if (StringUtil::Equals(value, "COLLATE")) {
1645: 		return ExpressionClass::COLLATE;
1646: 	}
1647: 	if (StringUtil::Equals(value, "LAMBDA")) {
1648: 		return ExpressionClass::LAMBDA;
1649: 	}
1650: 	if (StringUtil::Equals(value, "POSITIONAL_REFERENCE")) {
1651: 		return ExpressionClass::POSITIONAL_REFERENCE;
1652: 	}
1653: 	if (StringUtil::Equals(value, "BETWEEN")) {
1654: 		return ExpressionClass::BETWEEN;
1655: 	}
1656: 	if (StringUtil::Equals(value, "BOUND_AGGREGATE")) {
1657: 		return ExpressionClass::BOUND_AGGREGATE;
1658: 	}
1659: 	if (StringUtil::Equals(value, "BOUND_CASE")) {
1660: 		return ExpressionClass::BOUND_CASE;
1661: 	}
1662: 	if (StringUtil::Equals(value, "BOUND_CAST")) {
1663: 		return ExpressionClass::BOUND_CAST;
1664: 	}
1665: 	if (StringUtil::Equals(value, "BOUND_COLUMN_REF")) {
1666: 		return ExpressionClass::BOUND_COLUMN_REF;
1667: 	}
1668: 	if (StringUtil::Equals(value, "BOUND_COMPARISON")) {
1669: 		return ExpressionClass::BOUND_COMPARISON;
1670: 	}
1671: 	if (StringUtil::Equals(value, "BOUND_CONJUNCTION")) {
1672: 		return ExpressionClass::BOUND_CONJUNCTION;
1673: 	}
1674: 	if (StringUtil::Equals(value, "BOUND_CONSTANT")) {
1675: 		return ExpressionClass::BOUND_CONSTANT;
1676: 	}
1677: 	if (StringUtil::Equals(value, "BOUND_DEFAULT")) {
1678: 		return ExpressionClass::BOUND_DEFAULT;
1679: 	}
1680: 	if (StringUtil::Equals(value, "BOUND_FUNCTION")) {
1681: 		return ExpressionClass::BOUND_FUNCTION;
1682: 	}
1683: 	if (StringUtil::Equals(value, "BOUND_OPERATOR")) {
1684: 		return ExpressionClass::BOUND_OPERATOR;
1685: 	}
1686: 	if (StringUtil::Equals(value, "BOUND_PARAMETER")) {
1687: 		return ExpressionClass::BOUND_PARAMETER;
1688: 	}
1689: 	if (StringUtil::Equals(value, "BOUND_REF")) {
1690: 		return ExpressionClass::BOUND_REF;
1691: 	}
1692: 	if (StringUtil::Equals(value, "BOUND_SUBQUERY")) {
1693: 		return ExpressionClass::BOUND_SUBQUERY;
1694: 	}
1695: 	if (StringUtil::Equals(value, "BOUND_WINDOW")) {
1696: 		return ExpressionClass::BOUND_WINDOW;
1697: 	}
1698: 	if (StringUtil::Equals(value, "BOUND_BETWEEN")) {
1699: 		return ExpressionClass::BOUND_BETWEEN;
1700: 	}
1701: 	if (StringUtil::Equals(value, "BOUND_UNNEST")) {
1702: 		return ExpressionClass::BOUND_UNNEST;
1703: 	}
1704: 	if (StringUtil::Equals(value, "BOUND_LAMBDA")) {
1705: 		return ExpressionClass::BOUND_LAMBDA;
1706: 	}
1707: 	if (StringUtil::Equals(value, "BOUND_LAMBDA_REF")) {
1708: 		return ExpressionClass::BOUND_LAMBDA_REF;
1709: 	}
1710: 	if (StringUtil::Equals(value, "BOUND_EXPRESSION")) {
1711: 		return ExpressionClass::BOUND_EXPRESSION;
1712: 	}
1713: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1714: }
1715: 
1716: template<>
1717: const char* EnumUtil::ToChars<ExpressionType>(ExpressionType value) {
1718: 	switch(value) {
1719: 	case ExpressionType::INVALID:
1720: 		return "INVALID";
1721: 	case ExpressionType::OPERATOR_CAST:
1722: 		return "OPERATOR_CAST";
1723: 	case ExpressionType::OPERATOR_NOT:
1724: 		return "OPERATOR_NOT";
1725: 	case ExpressionType::OPERATOR_IS_NULL:
1726: 		return "OPERATOR_IS_NULL";
1727: 	case ExpressionType::OPERATOR_IS_NOT_NULL:
1728: 		return "OPERATOR_IS_NOT_NULL";
1729: 	case ExpressionType::COMPARE_EQUAL:
1730: 		return "COMPARE_EQUAL";
1731: 	case ExpressionType::COMPARE_NOTEQUAL:
1732: 		return "COMPARE_NOTEQUAL";
1733: 	case ExpressionType::COMPARE_LESSTHAN:
1734: 		return "COMPARE_LESSTHAN";
1735: 	case ExpressionType::COMPARE_GREATERTHAN:
1736: 		return "COMPARE_GREATERTHAN";
1737: 	case ExpressionType::COMPARE_LESSTHANOREQUALTO:
1738: 		return "COMPARE_LESSTHANOREQUALTO";
1739: 	case ExpressionType::COMPARE_GREATERTHANOREQUALTO:
1740: 		return "COMPARE_GREATERTHANOREQUALTO";
1741: 	case ExpressionType::COMPARE_IN:
1742: 		return "COMPARE_IN";
1743: 	case ExpressionType::COMPARE_NOT_IN:
1744: 		return "COMPARE_NOT_IN";
1745: 	case ExpressionType::COMPARE_DISTINCT_FROM:
1746: 		return "COMPARE_DISTINCT_FROM";
1747: 	case ExpressionType::COMPARE_BETWEEN:
1748: 		return "COMPARE_BETWEEN";
1749: 	case ExpressionType::COMPARE_NOT_BETWEEN:
1750: 		return "COMPARE_NOT_BETWEEN";
1751: 	case ExpressionType::COMPARE_NOT_DISTINCT_FROM:
1752: 		return "COMPARE_NOT_DISTINCT_FROM";
1753: 	case ExpressionType::CONJUNCTION_AND:
1754: 		return "CONJUNCTION_AND";
1755: 	case ExpressionType::CONJUNCTION_OR:
1756: 		return "CONJUNCTION_OR";
1757: 	case ExpressionType::VALUE_CONSTANT:
1758: 		return "VALUE_CONSTANT";
1759: 	case ExpressionType::VALUE_PARAMETER:
1760: 		return "VALUE_PARAMETER";
1761: 	case ExpressionType::VALUE_TUPLE:
1762: 		return "VALUE_TUPLE";
1763: 	case ExpressionType::VALUE_TUPLE_ADDRESS:
1764: 		return "VALUE_TUPLE_ADDRESS";
1765: 	case ExpressionType::VALUE_NULL:
1766: 		return "VALUE_NULL";
1767: 	case ExpressionType::VALUE_VECTOR:
1768: 		return "VALUE_VECTOR";
1769: 	case ExpressionType::VALUE_SCALAR:
1770: 		return "VALUE_SCALAR";
1771: 	case ExpressionType::VALUE_DEFAULT:
1772: 		return "VALUE_DEFAULT";
1773: 	case ExpressionType::AGGREGATE:
1774: 		return "AGGREGATE";
1775: 	case ExpressionType::BOUND_AGGREGATE:
1776: 		return "BOUND_AGGREGATE";
1777: 	case ExpressionType::GROUPING_FUNCTION:
1778: 		return "GROUPING_FUNCTION";
1779: 	case ExpressionType::WINDOW_AGGREGATE:
1780: 		return "WINDOW_AGGREGATE";
1781: 	case ExpressionType::WINDOW_RANK:
1782: 		return "WINDOW_RANK";
1783: 	case ExpressionType::WINDOW_RANK_DENSE:
1784: 		return "WINDOW_RANK_DENSE";
1785: 	case ExpressionType::WINDOW_NTILE:
1786: 		return "WINDOW_NTILE";
1787: 	case ExpressionType::WINDOW_PERCENT_RANK:
1788: 		return "WINDOW_PERCENT_RANK";
1789: 	case ExpressionType::WINDOW_CUME_DIST:
1790: 		return "WINDOW_CUME_DIST";
1791: 	case ExpressionType::WINDOW_ROW_NUMBER:
1792: 		return "WINDOW_ROW_NUMBER";
1793: 	case ExpressionType::WINDOW_FIRST_VALUE:
1794: 		return "WINDOW_FIRST_VALUE";
1795: 	case ExpressionType::WINDOW_LAST_VALUE:
1796: 		return "WINDOW_LAST_VALUE";
1797: 	case ExpressionType::WINDOW_LEAD:
1798: 		return "WINDOW_LEAD";
1799: 	case ExpressionType::WINDOW_LAG:
1800: 		return "WINDOW_LAG";
1801: 	case ExpressionType::WINDOW_NTH_VALUE:
1802: 		return "WINDOW_NTH_VALUE";
1803: 	case ExpressionType::FUNCTION:
1804: 		return "FUNCTION";
1805: 	case ExpressionType::BOUND_FUNCTION:
1806: 		return "BOUND_FUNCTION";
1807: 	case ExpressionType::CASE_EXPR:
1808: 		return "CASE_EXPR";
1809: 	case ExpressionType::OPERATOR_NULLIF:
1810: 		return "OPERATOR_NULLIF";
1811: 	case ExpressionType::OPERATOR_COALESCE:
1812: 		return "OPERATOR_COALESCE";
1813: 	case ExpressionType::ARRAY_EXTRACT:
1814: 		return "ARRAY_EXTRACT";
1815: 	case ExpressionType::ARRAY_SLICE:
1816: 		return "ARRAY_SLICE";
1817: 	case ExpressionType::STRUCT_EXTRACT:
1818: 		return "STRUCT_EXTRACT";
1819: 	case ExpressionType::ARRAY_CONSTRUCTOR:
1820: 		return "ARRAY_CONSTRUCTOR";
1821: 	case ExpressionType::ARROW:
1822: 		return "ARROW";
1823: 	case ExpressionType::SUBQUERY:
1824: 		return "SUBQUERY";
1825: 	case ExpressionType::STAR:
1826: 		return "STAR";
1827: 	case ExpressionType::TABLE_STAR:
1828: 		return "TABLE_STAR";
1829: 	case ExpressionType::PLACEHOLDER:
1830: 		return "PLACEHOLDER";
1831: 	case ExpressionType::COLUMN_REF:
1832: 		return "COLUMN_REF";
1833: 	case ExpressionType::FUNCTION_REF:
1834: 		return "FUNCTION_REF";
1835: 	case ExpressionType::TABLE_REF:
1836: 		return "TABLE_REF";
1837: 	case ExpressionType::CAST:
1838: 		return "CAST";
1839: 	case ExpressionType::BOUND_REF:
1840: 		return "BOUND_REF";
1841: 	case ExpressionType::BOUND_COLUMN_REF:
1842: 		return "BOUND_COLUMN_REF";
1843: 	case ExpressionType::BOUND_UNNEST:
1844: 		return "BOUND_UNNEST";
1845: 	case ExpressionType::COLLATE:
1846: 		return "COLLATE";
1847: 	case ExpressionType::LAMBDA:
1848: 		return "LAMBDA";
1849: 	case ExpressionType::POSITIONAL_REFERENCE:
1850: 		return "POSITIONAL_REFERENCE";
1851: 	case ExpressionType::BOUND_LAMBDA_REF:
1852: 		return "BOUND_LAMBDA_REF";
1853: 	default:
1854: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1855: 	}
1856: }
1857: 
1858: template<>
1859: ExpressionType EnumUtil::FromString<ExpressionType>(const char *value) {
1860: 	if (StringUtil::Equals(value, "INVALID")) {
1861: 		return ExpressionType::INVALID;
1862: 	}
1863: 	if (StringUtil::Equals(value, "OPERATOR_CAST")) {
1864: 		return ExpressionType::OPERATOR_CAST;
1865: 	}
1866: 	if (StringUtil::Equals(value, "OPERATOR_NOT")) {
1867: 		return ExpressionType::OPERATOR_NOT;
1868: 	}
1869: 	if (StringUtil::Equals(value, "OPERATOR_IS_NULL")) {
1870: 		return ExpressionType::OPERATOR_IS_NULL;
1871: 	}
1872: 	if (StringUtil::Equals(value, "OPERATOR_IS_NOT_NULL")) {
1873: 		return ExpressionType::OPERATOR_IS_NOT_NULL;
1874: 	}
1875: 	if (StringUtil::Equals(value, "COMPARE_EQUAL")) {
1876: 		return ExpressionType::COMPARE_EQUAL;
1877: 	}
1878: 	if (StringUtil::Equals(value, "COMPARE_NOTEQUAL")) {
1879: 		return ExpressionType::COMPARE_NOTEQUAL;
1880: 	}
1881: 	if (StringUtil::Equals(value, "COMPARE_LESSTHAN")) {
1882: 		return ExpressionType::COMPARE_LESSTHAN;
1883: 	}
1884: 	if (StringUtil::Equals(value, "COMPARE_GREATERTHAN")) {
1885: 		return ExpressionType::COMPARE_GREATERTHAN;
1886: 	}
1887: 	if (StringUtil::Equals(value, "COMPARE_LESSTHANOREQUALTO")) {
1888: 		return ExpressionType::COMPARE_LESSTHANOREQUALTO;
1889: 	}
1890: 	if (StringUtil::Equals(value, "COMPARE_GREATERTHANOREQUALTO")) {
1891: 		return ExpressionType::COMPARE_GREATERTHANOREQUALTO;
1892: 	}
1893: 	if (StringUtil::Equals(value, "COMPARE_IN")) {
1894: 		return ExpressionType::COMPARE_IN;
1895: 	}
1896: 	if (StringUtil::Equals(value, "COMPARE_NOT_IN")) {
1897: 		return ExpressionType::COMPARE_NOT_IN;
1898: 	}
1899: 	if (StringUtil::Equals(value, "COMPARE_DISTINCT_FROM")) {
1900: 		return ExpressionType::COMPARE_DISTINCT_FROM;
1901: 	}
1902: 	if (StringUtil::Equals(value, "COMPARE_BETWEEN")) {
1903: 		return ExpressionType::COMPARE_BETWEEN;
1904: 	}
1905: 	if (StringUtil::Equals(value, "COMPARE_NOT_BETWEEN")) {
1906: 		return ExpressionType::COMPARE_NOT_BETWEEN;
1907: 	}
1908: 	if (StringUtil::Equals(value, "COMPARE_NOT_DISTINCT_FROM")) {
1909: 		return ExpressionType::COMPARE_NOT_DISTINCT_FROM;
1910: 	}
1911: 	if (StringUtil::Equals(value, "CONJUNCTION_AND")) {
1912: 		return ExpressionType::CONJUNCTION_AND;
1913: 	}
1914: 	if (StringUtil::Equals(value, "CONJUNCTION_OR")) {
1915: 		return ExpressionType::CONJUNCTION_OR;
1916: 	}
1917: 	if (StringUtil::Equals(value, "VALUE_CONSTANT")) {
1918: 		return ExpressionType::VALUE_CONSTANT;
1919: 	}
1920: 	if (StringUtil::Equals(value, "VALUE_PARAMETER")) {
1921: 		return ExpressionType::VALUE_PARAMETER;
1922: 	}
1923: 	if (StringUtil::Equals(value, "VALUE_TUPLE")) {
1924: 		return ExpressionType::VALUE_TUPLE;
1925: 	}
1926: 	if (StringUtil::Equals(value, "VALUE_TUPLE_ADDRESS")) {
1927: 		return ExpressionType::VALUE_TUPLE_ADDRESS;
1928: 	}
1929: 	if (StringUtil::Equals(value, "VALUE_NULL")) {
1930: 		return ExpressionType::VALUE_NULL;
1931: 	}
1932: 	if (StringUtil::Equals(value, "VALUE_VECTOR")) {
1933: 		return ExpressionType::VALUE_VECTOR;
1934: 	}
1935: 	if (StringUtil::Equals(value, "VALUE_SCALAR")) {
1936: 		return ExpressionType::VALUE_SCALAR;
1937: 	}
1938: 	if (StringUtil::Equals(value, "VALUE_DEFAULT")) {
1939: 		return ExpressionType::VALUE_DEFAULT;
1940: 	}
1941: 	if (StringUtil::Equals(value, "AGGREGATE")) {
1942: 		return ExpressionType::AGGREGATE;
1943: 	}
1944: 	if (StringUtil::Equals(value, "BOUND_AGGREGATE")) {
1945: 		return ExpressionType::BOUND_AGGREGATE;
1946: 	}
1947: 	if (StringUtil::Equals(value, "GROUPING_FUNCTION")) {
1948: 		return ExpressionType::GROUPING_FUNCTION;
1949: 	}
1950: 	if (StringUtil::Equals(value, "WINDOW_AGGREGATE")) {
1951: 		return ExpressionType::WINDOW_AGGREGATE;
1952: 	}
1953: 	if (StringUtil::Equals(value, "WINDOW_RANK")) {
1954: 		return ExpressionType::WINDOW_RANK;
1955: 	}
1956: 	if (StringUtil::Equals(value, "WINDOW_RANK_DENSE")) {
1957: 		return ExpressionType::WINDOW_RANK_DENSE;
1958: 	}
1959: 	if (StringUtil::Equals(value, "WINDOW_NTILE")) {
1960: 		return ExpressionType::WINDOW_NTILE;
1961: 	}
1962: 	if (StringUtil::Equals(value, "WINDOW_PERCENT_RANK")) {
1963: 		return ExpressionType::WINDOW_PERCENT_RANK;
1964: 	}
1965: 	if (StringUtil::Equals(value, "WINDOW_CUME_DIST")) {
1966: 		return ExpressionType::WINDOW_CUME_DIST;
1967: 	}
1968: 	if (StringUtil::Equals(value, "WINDOW_ROW_NUMBER")) {
1969: 		return ExpressionType::WINDOW_ROW_NUMBER;
1970: 	}
1971: 	if (StringUtil::Equals(value, "WINDOW_FIRST_VALUE")) {
1972: 		return ExpressionType::WINDOW_FIRST_VALUE;
1973: 	}
1974: 	if (StringUtil::Equals(value, "WINDOW_LAST_VALUE")) {
1975: 		return ExpressionType::WINDOW_LAST_VALUE;
1976: 	}
1977: 	if (StringUtil::Equals(value, "WINDOW_LEAD")) {
1978: 		return ExpressionType::WINDOW_LEAD;
1979: 	}
1980: 	if (StringUtil::Equals(value, "WINDOW_LAG")) {
1981: 		return ExpressionType::WINDOW_LAG;
1982: 	}
1983: 	if (StringUtil::Equals(value, "WINDOW_NTH_VALUE")) {
1984: 		return ExpressionType::WINDOW_NTH_VALUE;
1985: 	}
1986: 	if (StringUtil::Equals(value, "FUNCTION")) {
1987: 		return ExpressionType::FUNCTION;
1988: 	}
1989: 	if (StringUtil::Equals(value, "BOUND_FUNCTION")) {
1990: 		return ExpressionType::BOUND_FUNCTION;
1991: 	}
1992: 	if (StringUtil::Equals(value, "CASE_EXPR")) {
1993: 		return ExpressionType::CASE_EXPR;
1994: 	}
1995: 	if (StringUtil::Equals(value, "OPERATOR_NULLIF")) {
1996: 		return ExpressionType::OPERATOR_NULLIF;
1997: 	}
1998: 	if (StringUtil::Equals(value, "OPERATOR_COALESCE")) {
1999: 		return ExpressionType::OPERATOR_COALESCE;
2000: 	}
2001: 	if (StringUtil::Equals(value, "ARRAY_EXTRACT")) {
2002: 		return ExpressionType::ARRAY_EXTRACT;
2003: 	}
2004: 	if (StringUtil::Equals(value, "ARRAY_SLICE")) {
2005: 		return ExpressionType::ARRAY_SLICE;
2006: 	}
2007: 	if (StringUtil::Equals(value, "STRUCT_EXTRACT")) {
2008: 		return ExpressionType::STRUCT_EXTRACT;
2009: 	}
2010: 	if (StringUtil::Equals(value, "ARRAY_CONSTRUCTOR")) {
2011: 		return ExpressionType::ARRAY_CONSTRUCTOR;
2012: 	}
2013: 	if (StringUtil::Equals(value, "ARROW")) {
2014: 		return ExpressionType::ARROW;
2015: 	}
2016: 	if (StringUtil::Equals(value, "SUBQUERY")) {
2017: 		return ExpressionType::SUBQUERY;
2018: 	}
2019: 	if (StringUtil::Equals(value, "STAR")) {
2020: 		return ExpressionType::STAR;
2021: 	}
2022: 	if (StringUtil::Equals(value, "TABLE_STAR")) {
2023: 		return ExpressionType::TABLE_STAR;
2024: 	}
2025: 	if (StringUtil::Equals(value, "PLACEHOLDER")) {
2026: 		return ExpressionType::PLACEHOLDER;
2027: 	}
2028: 	if (StringUtil::Equals(value, "COLUMN_REF")) {
2029: 		return ExpressionType::COLUMN_REF;
2030: 	}
2031: 	if (StringUtil::Equals(value, "FUNCTION_REF")) {
2032: 		return ExpressionType::FUNCTION_REF;
2033: 	}
2034: 	if (StringUtil::Equals(value, "TABLE_REF")) {
2035: 		return ExpressionType::TABLE_REF;
2036: 	}
2037: 	if (StringUtil::Equals(value, "CAST")) {
2038: 		return ExpressionType::CAST;
2039: 	}
2040: 	if (StringUtil::Equals(value, "BOUND_REF")) {
2041: 		return ExpressionType::BOUND_REF;
2042: 	}
2043: 	if (StringUtil::Equals(value, "BOUND_COLUMN_REF")) {
2044: 		return ExpressionType::BOUND_COLUMN_REF;
2045: 	}
2046: 	if (StringUtil::Equals(value, "BOUND_UNNEST")) {
2047: 		return ExpressionType::BOUND_UNNEST;
2048: 	}
2049: 	if (StringUtil::Equals(value, "COLLATE")) {
2050: 		return ExpressionType::COLLATE;
2051: 	}
2052: 	if (StringUtil::Equals(value, "LAMBDA")) {
2053: 		return ExpressionType::LAMBDA;
2054: 	}
2055: 	if (StringUtil::Equals(value, "POSITIONAL_REFERENCE")) {
2056: 		return ExpressionType::POSITIONAL_REFERENCE;
2057: 	}
2058: 	if (StringUtil::Equals(value, "BOUND_LAMBDA_REF")) {
2059: 		return ExpressionType::BOUND_LAMBDA_REF;
2060: 	}
2061: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2062: }
2063: 
2064: template<>
2065: const char* EnumUtil::ToChars<ExtensionLoadResult>(ExtensionLoadResult value) {
2066: 	switch(value) {
2067: 	case ExtensionLoadResult::LOADED_EXTENSION:
2068: 		return "LOADED_EXTENSION";
2069: 	case ExtensionLoadResult::EXTENSION_UNKNOWN:
2070: 		return "EXTENSION_UNKNOWN";
2071: 	case ExtensionLoadResult::NOT_LOADED:
2072: 		return "NOT_LOADED";
2073: 	default:
2074: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2075: 	}
2076: }
2077: 
2078: template<>
2079: ExtensionLoadResult EnumUtil::FromString<ExtensionLoadResult>(const char *value) {
2080: 	if (StringUtil::Equals(value, "LOADED_EXTENSION")) {
2081: 		return ExtensionLoadResult::LOADED_EXTENSION;
2082: 	}
2083: 	if (StringUtil::Equals(value, "EXTENSION_UNKNOWN")) {
2084: 		return ExtensionLoadResult::EXTENSION_UNKNOWN;
2085: 	}
2086: 	if (StringUtil::Equals(value, "NOT_LOADED")) {
2087: 		return ExtensionLoadResult::NOT_LOADED;
2088: 	}
2089: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2090: }
2091: 
2092: template<>
2093: const char* EnumUtil::ToChars<ExtraTypeInfoType>(ExtraTypeInfoType value) {
2094: 	switch(value) {
2095: 	case ExtraTypeInfoType::INVALID_TYPE_INFO:
2096: 		return "INVALID_TYPE_INFO";
2097: 	case ExtraTypeInfoType::GENERIC_TYPE_INFO:
2098: 		return "GENERIC_TYPE_INFO";
2099: 	case ExtraTypeInfoType::DECIMAL_TYPE_INFO:
2100: 		return "DECIMAL_TYPE_INFO";
2101: 	case ExtraTypeInfoType::STRING_TYPE_INFO:
2102: 		return "STRING_TYPE_INFO";
2103: 	case ExtraTypeInfoType::LIST_TYPE_INFO:
2104: 		return "LIST_TYPE_INFO";
2105: 	case ExtraTypeInfoType::STRUCT_TYPE_INFO:
2106: 		return "STRUCT_TYPE_INFO";
2107: 	case ExtraTypeInfoType::ENUM_TYPE_INFO:
2108: 		return "ENUM_TYPE_INFO";
2109: 	case ExtraTypeInfoType::USER_TYPE_INFO:
2110: 		return "USER_TYPE_INFO";
2111: 	case ExtraTypeInfoType::AGGREGATE_STATE_TYPE_INFO:
2112: 		return "AGGREGATE_STATE_TYPE_INFO";
2113: 	default:
2114: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2115: 	}
2116: }
2117: 
2118: template<>
2119: ExtraTypeInfoType EnumUtil::FromString<ExtraTypeInfoType>(const char *value) {
2120: 	if (StringUtil::Equals(value, "INVALID_TYPE_INFO")) {
2121: 		return ExtraTypeInfoType::INVALID_TYPE_INFO;
2122: 	}
2123: 	if (StringUtil::Equals(value, "GENERIC_TYPE_INFO")) {
2124: 		return ExtraTypeInfoType::GENERIC_TYPE_INFO;
2125: 	}
2126: 	if (StringUtil::Equals(value, "DECIMAL_TYPE_INFO")) {
2127: 		return ExtraTypeInfoType::DECIMAL_TYPE_INFO;
2128: 	}
2129: 	if (StringUtil::Equals(value, "STRING_TYPE_INFO")) {
2130: 		return ExtraTypeInfoType::STRING_TYPE_INFO;
2131: 	}
2132: 	if (StringUtil::Equals(value, "LIST_TYPE_INFO")) {
2133: 		return ExtraTypeInfoType::LIST_TYPE_INFO;
2134: 	}
2135: 	if (StringUtil::Equals(value, "STRUCT_TYPE_INFO")) {
2136: 		return ExtraTypeInfoType::STRUCT_TYPE_INFO;
2137: 	}
2138: 	if (StringUtil::Equals(value, "ENUM_TYPE_INFO")) {
2139: 		return ExtraTypeInfoType::ENUM_TYPE_INFO;
2140: 	}
2141: 	if (StringUtil::Equals(value, "USER_TYPE_INFO")) {
2142: 		return ExtraTypeInfoType::USER_TYPE_INFO;
2143: 	}
2144: 	if (StringUtil::Equals(value, "AGGREGATE_STATE_TYPE_INFO")) {
2145: 		return ExtraTypeInfoType::AGGREGATE_STATE_TYPE_INFO;
2146: 	}
2147: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2148: }
2149: 
2150: template<>
2151: const char* EnumUtil::ToChars<FileBufferType>(FileBufferType value) {
2152: 	switch(value) {
2153: 	case FileBufferType::BLOCK:
2154: 		return "BLOCK";
2155: 	case FileBufferType::MANAGED_BUFFER:
2156: 		return "MANAGED_BUFFER";
2157: 	case FileBufferType::TINY_BUFFER:
2158: 		return "TINY_BUFFER";
2159: 	default:
2160: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2161: 	}
2162: }
2163: 
2164: template<>
2165: FileBufferType EnumUtil::FromString<FileBufferType>(const char *value) {
2166: 	if (StringUtil::Equals(value, "BLOCK")) {
2167: 		return FileBufferType::BLOCK;
2168: 	}
2169: 	if (StringUtil::Equals(value, "MANAGED_BUFFER")) {
2170: 		return FileBufferType::MANAGED_BUFFER;
2171: 	}
2172: 	if (StringUtil::Equals(value, "TINY_BUFFER")) {
2173: 		return FileBufferType::TINY_BUFFER;
2174: 	}
2175: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2176: }
2177: 
2178: template<>
2179: const char* EnumUtil::ToChars<FileCompressionType>(FileCompressionType value) {
2180: 	switch(value) {
2181: 	case FileCompressionType::AUTO_DETECT:
2182: 		return "AUTO_DETECT";
2183: 	case FileCompressionType::UNCOMPRESSED:
2184: 		return "UNCOMPRESSED";
2185: 	case FileCompressionType::GZIP:
2186: 		return "GZIP";
2187: 	case FileCompressionType::ZSTD:
2188: 		return "ZSTD";
2189: 	default:
2190: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2191: 	}
2192: }
2193: 
2194: template<>
2195: FileCompressionType EnumUtil::FromString<FileCompressionType>(const char *value) {
2196: 	if (StringUtil::Equals(value, "AUTO_DETECT")) {
2197: 		return FileCompressionType::AUTO_DETECT;
2198: 	}
2199: 	if (StringUtil::Equals(value, "UNCOMPRESSED")) {
2200: 		return FileCompressionType::UNCOMPRESSED;
2201: 	}
2202: 	if (StringUtil::Equals(value, "GZIP")) {
2203: 		return FileCompressionType::GZIP;
2204: 	}
2205: 	if (StringUtil::Equals(value, "ZSTD")) {
2206: 		return FileCompressionType::ZSTD;
2207: 	}
2208: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2209: }
2210: 
2211: template<>
2212: const char* EnumUtil::ToChars<FileGlobOptions>(FileGlobOptions value) {
2213: 	switch(value) {
2214: 	case FileGlobOptions::DISALLOW_EMPTY:
2215: 		return "DISALLOW_EMPTY";
2216: 	case FileGlobOptions::ALLOW_EMPTY:
2217: 		return "ALLOW_EMPTY";
2218: 	default:
2219: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2220: 	}
2221: }
2222: 
2223: template<>
2224: FileGlobOptions EnumUtil::FromString<FileGlobOptions>(const char *value) {
2225: 	if (StringUtil::Equals(value, "DISALLOW_EMPTY")) {
2226: 		return FileGlobOptions::DISALLOW_EMPTY;
2227: 	}
2228: 	if (StringUtil::Equals(value, "ALLOW_EMPTY")) {
2229: 		return FileGlobOptions::ALLOW_EMPTY;
2230: 	}
2231: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2232: }
2233: 
2234: template<>
2235: const char* EnumUtil::ToChars<FileLockType>(FileLockType value) {
2236: 	switch(value) {
2237: 	case FileLockType::NO_LOCK:
2238: 		return "NO_LOCK";
2239: 	case FileLockType::READ_LOCK:
2240: 		return "READ_LOCK";
2241: 	case FileLockType::WRITE_LOCK:
2242: 		return "WRITE_LOCK";
2243: 	default:
2244: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2245: 	}
2246: }
2247: 
2248: template<>
2249: FileLockType EnumUtil::FromString<FileLockType>(const char *value) {
2250: 	if (StringUtil::Equals(value, "NO_LOCK")) {
2251: 		return FileLockType::NO_LOCK;
2252: 	}
2253: 	if (StringUtil::Equals(value, "READ_LOCK")) {
2254: 		return FileLockType::READ_LOCK;
2255: 	}
2256: 	if (StringUtil::Equals(value, "WRITE_LOCK")) {
2257: 		return FileLockType::WRITE_LOCK;
2258: 	}
2259: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2260: }
2261: 
2262: template<>
2263: const char* EnumUtil::ToChars<FilterPropagateResult>(FilterPropagateResult value) {
2264: 	switch(value) {
2265: 	case FilterPropagateResult::NO_PRUNING_POSSIBLE:
2266: 		return "NO_PRUNING_POSSIBLE";
2267: 	case FilterPropagateResult::FILTER_ALWAYS_TRUE:
2268: 		return "FILTER_ALWAYS_TRUE";
2269: 	case FilterPropagateResult::FILTER_ALWAYS_FALSE:
2270: 		return "FILTER_ALWAYS_FALSE";
2271: 	case FilterPropagateResult::FILTER_TRUE_OR_NULL:
2272: 		return "FILTER_TRUE_OR_NULL";
2273: 	case FilterPropagateResult::FILTER_FALSE_OR_NULL:
2274: 		return "FILTER_FALSE_OR_NULL";
2275: 	default:
2276: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2277: 	}
2278: }
2279: 
2280: template<>
2281: FilterPropagateResult EnumUtil::FromString<FilterPropagateResult>(const char *value) {
2282: 	if (StringUtil::Equals(value, "NO_PRUNING_POSSIBLE")) {
2283: 		return FilterPropagateResult::NO_PRUNING_POSSIBLE;
2284: 	}
2285: 	if (StringUtil::Equals(value, "FILTER_ALWAYS_TRUE")) {
2286: 		return FilterPropagateResult::FILTER_ALWAYS_TRUE;
2287: 	}
2288: 	if (StringUtil::Equals(value, "FILTER_ALWAYS_FALSE")) {
2289: 		return FilterPropagateResult::FILTER_ALWAYS_FALSE;
2290: 	}
2291: 	if (StringUtil::Equals(value, "FILTER_TRUE_OR_NULL")) {
2292: 		return FilterPropagateResult::FILTER_TRUE_OR_NULL;
2293: 	}
2294: 	if (StringUtil::Equals(value, "FILTER_FALSE_OR_NULL")) {
2295: 		return FilterPropagateResult::FILTER_FALSE_OR_NULL;
2296: 	}
2297: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2298: }
2299: 
2300: template<>
2301: const char* EnumUtil::ToChars<ForeignKeyType>(ForeignKeyType value) {
2302: 	switch(value) {
2303: 	case ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE:
2304: 		return "FK_TYPE_PRIMARY_KEY_TABLE";
2305: 	case ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE:
2306: 		return "FK_TYPE_FOREIGN_KEY_TABLE";
2307: 	case ForeignKeyType::FK_TYPE_SELF_REFERENCE_TABLE:
2308: 		return "FK_TYPE_SELF_REFERENCE_TABLE";
2309: 	default:
2310: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2311: 	}
2312: }
2313: 
2314: template<>
2315: ForeignKeyType EnumUtil::FromString<ForeignKeyType>(const char *value) {
2316: 	if (StringUtil::Equals(value, "FK_TYPE_PRIMARY_KEY_TABLE")) {
2317: 		return ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE;
2318: 	}
2319: 	if (StringUtil::Equals(value, "FK_TYPE_FOREIGN_KEY_TABLE")) {
2320: 		return ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE;
2321: 	}
2322: 	if (StringUtil::Equals(value, "FK_TYPE_SELF_REFERENCE_TABLE")) {
2323: 		return ForeignKeyType::FK_TYPE_SELF_REFERENCE_TABLE;
2324: 	}
2325: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2326: }
2327: 
2328: template<>
2329: const char* EnumUtil::ToChars<FunctionNullHandling>(FunctionNullHandling value) {
2330: 	switch(value) {
2331: 	case FunctionNullHandling::DEFAULT_NULL_HANDLING:
2332: 		return "DEFAULT_NULL_HANDLING";
2333: 	case FunctionNullHandling::SPECIAL_HANDLING:
2334: 		return "SPECIAL_HANDLING";
2335: 	default:
2336: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2337: 	}
2338: }
2339: 
2340: template<>
2341: FunctionNullHandling EnumUtil::FromString<FunctionNullHandling>(const char *value) {
2342: 	if (StringUtil::Equals(value, "DEFAULT_NULL_HANDLING")) {
2343: 		return FunctionNullHandling::DEFAULT_NULL_HANDLING;
2344: 	}
2345: 	if (StringUtil::Equals(value, "SPECIAL_HANDLING")) {
2346: 		return FunctionNullHandling::SPECIAL_HANDLING;
2347: 	}
2348: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2349: }
2350: 
2351: template<>
2352: const char* EnumUtil::ToChars<FunctionSideEffects>(FunctionSideEffects value) {
2353: 	switch(value) {
2354: 	case FunctionSideEffects::NO_SIDE_EFFECTS:
2355: 		return "NO_SIDE_EFFECTS";
2356: 	case FunctionSideEffects::HAS_SIDE_EFFECTS:
2357: 		return "HAS_SIDE_EFFECTS";
2358: 	default:
2359: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2360: 	}
2361: }
2362: 
2363: template<>
2364: FunctionSideEffects EnumUtil::FromString<FunctionSideEffects>(const char *value) {
2365: 	if (StringUtil::Equals(value, "NO_SIDE_EFFECTS")) {
2366: 		return FunctionSideEffects::NO_SIDE_EFFECTS;
2367: 	}
2368: 	if (StringUtil::Equals(value, "HAS_SIDE_EFFECTS")) {
2369: 		return FunctionSideEffects::HAS_SIDE_EFFECTS;
2370: 	}
2371: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2372: }
2373: 
2374: template<>
2375: const char* EnumUtil::ToChars<HLLStorageType>(HLLStorageType value) {
2376: 	switch(value) {
2377: 	case HLLStorageType::UNCOMPRESSED:
2378: 		return "UNCOMPRESSED";
2379: 	default:
2380: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2381: 	}
2382: }
2383: 
2384: template<>
2385: HLLStorageType EnumUtil::FromString<HLLStorageType>(const char *value) {
2386: 	if (StringUtil::Equals(value, "UNCOMPRESSED")) {
2387: 		return HLLStorageType::UNCOMPRESSED;
2388: 	}
2389: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2390: }
2391: 
2392: template<>
2393: const char* EnumUtil::ToChars<IndexConstraintType>(IndexConstraintType value) {
2394: 	switch(value) {
2395: 	case IndexConstraintType::NONE:
2396: 		return "NONE";
2397: 	case IndexConstraintType::UNIQUE:
2398: 		return "UNIQUE";
2399: 	case IndexConstraintType::PRIMARY:
2400: 		return "PRIMARY";
2401: 	case IndexConstraintType::FOREIGN:
2402: 		return "FOREIGN";
2403: 	default:
2404: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2405: 	}
2406: }
2407: 
2408: template<>
2409: IndexConstraintType EnumUtil::FromString<IndexConstraintType>(const char *value) {
2410: 	if (StringUtil::Equals(value, "NONE")) {
2411: 		return IndexConstraintType::NONE;
2412: 	}
2413: 	if (StringUtil::Equals(value, "UNIQUE")) {
2414: 		return IndexConstraintType::UNIQUE;
2415: 	}
2416: 	if (StringUtil::Equals(value, "PRIMARY")) {
2417: 		return IndexConstraintType::PRIMARY;
2418: 	}
2419: 	if (StringUtil::Equals(value, "FOREIGN")) {
2420: 		return IndexConstraintType::FOREIGN;
2421: 	}
2422: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2423: }
2424: 
2425: template<>
2426: const char* EnumUtil::ToChars<IndexType>(IndexType value) {
2427: 	switch(value) {
2428: 	case IndexType::INVALID:
2429: 		return "INVALID";
2430: 	case IndexType::ART:
2431: 		return "ART";
2432: 	case IndexType::EXTENSION:
2433: 		return "EXTENSION";
2434: 	default:
2435: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2436: 	}
2437: }
2438: 
2439: template<>
2440: IndexType EnumUtil::FromString<IndexType>(const char *value) {
2441: 	if (StringUtil::Equals(value, "INVALID")) {
2442: 		return IndexType::INVALID;
2443: 	}
2444: 	if (StringUtil::Equals(value, "ART")) {
2445: 		return IndexType::ART;
2446: 	}
2447: 	if (StringUtil::Equals(value, "EXTENSION")) {
2448: 		return IndexType::EXTENSION;
2449: 	}
2450: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2451: }
2452: 
2453: template<>
2454: const char* EnumUtil::ToChars<InsertColumnOrder>(InsertColumnOrder value) {
2455: 	switch(value) {
2456: 	case InsertColumnOrder::INSERT_BY_POSITION:
2457: 		return "INSERT_BY_POSITION";
2458: 	case InsertColumnOrder::INSERT_BY_NAME:
2459: 		return "INSERT_BY_NAME";
2460: 	default:
2461: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2462: 	}
2463: }
2464: 
2465: template<>
2466: InsertColumnOrder EnumUtil::FromString<InsertColumnOrder>(const char *value) {
2467: 	if (StringUtil::Equals(value, "INSERT_BY_POSITION")) {
2468: 		return InsertColumnOrder::INSERT_BY_POSITION;
2469: 	}
2470: 	if (StringUtil::Equals(value, "INSERT_BY_NAME")) {
2471: 		return InsertColumnOrder::INSERT_BY_NAME;
2472: 	}
2473: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2474: }
2475: 
2476: template<>
2477: const char* EnumUtil::ToChars<InterruptMode>(InterruptMode value) {
2478: 	switch(value) {
2479: 	case InterruptMode::NO_INTERRUPTS:
2480: 		return "NO_INTERRUPTS";
2481: 	case InterruptMode::TASK:
2482: 		return "TASK";
2483: 	case InterruptMode::BLOCKING:
2484: 		return "BLOCKING";
2485: 	default:
2486: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2487: 	}
2488: }
2489: 
2490: template<>
2491: InterruptMode EnumUtil::FromString<InterruptMode>(const char *value) {
2492: 	if (StringUtil::Equals(value, "NO_INTERRUPTS")) {
2493: 		return InterruptMode::NO_INTERRUPTS;
2494: 	}
2495: 	if (StringUtil::Equals(value, "TASK")) {
2496: 		return InterruptMode::TASK;
2497: 	}
2498: 	if (StringUtil::Equals(value, "BLOCKING")) {
2499: 		return InterruptMode::BLOCKING;
2500: 	}
2501: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2502: }
2503: 
2504: template<>
2505: const char* EnumUtil::ToChars<JoinRefType>(JoinRefType value) {
2506: 	switch(value) {
2507: 	case JoinRefType::REGULAR:
2508: 		return "REGULAR";
2509: 	case JoinRefType::NATURAL:
2510: 		return "NATURAL";
2511: 	case JoinRefType::CROSS:
2512: 		return "CROSS";
2513: 	case JoinRefType::POSITIONAL:
2514: 		return "POSITIONAL";
2515: 	case JoinRefType::ASOF:
2516: 		return "ASOF";
2517: 	case JoinRefType::DEPENDENT:
2518: 		return "DEPENDENT";
2519: 	default:
2520: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2521: 	}
2522: }
2523: 
2524: template<>
2525: JoinRefType EnumUtil::FromString<JoinRefType>(const char *value) {
2526: 	if (StringUtil::Equals(value, "REGULAR")) {
2527: 		return JoinRefType::REGULAR;
2528: 	}
2529: 	if (StringUtil::Equals(value, "NATURAL")) {
2530: 		return JoinRefType::NATURAL;
2531: 	}
2532: 	if (StringUtil::Equals(value, "CROSS")) {
2533: 		return JoinRefType::CROSS;
2534: 	}
2535: 	if (StringUtil::Equals(value, "POSITIONAL")) {
2536: 		return JoinRefType::POSITIONAL;
2537: 	}
2538: 	if (StringUtil::Equals(value, "ASOF")) {
2539: 		return JoinRefType::ASOF;
2540: 	}
2541: 	if (StringUtil::Equals(value, "DEPENDENT")) {
2542: 		return JoinRefType::DEPENDENT;
2543: 	}
2544: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2545: }
2546: 
2547: template<>
2548: const char* EnumUtil::ToChars<JoinType>(JoinType value) {
2549: 	switch(value) {
2550: 	case JoinType::INVALID:
2551: 		return "INVALID";
2552: 	case JoinType::LEFT:
2553: 		return "LEFT";
2554: 	case JoinType::RIGHT:
2555: 		return "RIGHT";
2556: 	case JoinType::INNER:
2557: 		return "INNER";
2558: 	case JoinType::OUTER:
2559: 		return "FULL";
2560: 	case JoinType::SEMI:
2561: 		return "SEMI";
2562: 	case JoinType::ANTI:
2563: 		return "ANTI";
2564: 	case JoinType::MARK:
2565: 		return "MARK";
2566: 	case JoinType::SINGLE:
2567: 		return "SINGLE";
2568: 	default:
2569: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2570: 	}
2571: }
2572: 
2573: template<>
2574: JoinType EnumUtil::FromString<JoinType>(const char *value) {
2575: 	if (StringUtil::Equals(value, "INVALID")) {
2576: 		return JoinType::INVALID;
2577: 	}
2578: 	if (StringUtil::Equals(value, "LEFT")) {
2579: 		return JoinType::LEFT;
2580: 	}
2581: 	if (StringUtil::Equals(value, "RIGHT")) {
2582: 		return JoinType::RIGHT;
2583: 	}
2584: 	if (StringUtil::Equals(value, "INNER")) {
2585: 		return JoinType::INNER;
2586: 	}
2587: 	if (StringUtil::Equals(value, "FULL")) {
2588: 		return JoinType::OUTER;
2589: 	}
2590: 	if (StringUtil::Equals(value, "SEMI")) {
2591: 		return JoinType::SEMI;
2592: 	}
2593: 	if (StringUtil::Equals(value, "ANTI")) {
2594: 		return JoinType::ANTI;
2595: 	}
2596: 	if (StringUtil::Equals(value, "MARK")) {
2597: 		return JoinType::MARK;
2598: 	}
2599: 	if (StringUtil::Equals(value, "SINGLE")) {
2600: 		return JoinType::SINGLE;
2601: 	}
2602: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2603: }
2604: 
2605: template<>
2606: const char* EnumUtil::ToChars<KeywordCategory>(KeywordCategory value) {
2607: 	switch(value) {
2608: 	case KeywordCategory::KEYWORD_RESERVED:
2609: 		return "KEYWORD_RESERVED";
2610: 	case KeywordCategory::KEYWORD_UNRESERVED:
2611: 		return "KEYWORD_UNRESERVED";
2612: 	case KeywordCategory::KEYWORD_TYPE_FUNC:
2613: 		return "KEYWORD_TYPE_FUNC";
2614: 	case KeywordCategory::KEYWORD_COL_NAME:
2615: 		return "KEYWORD_COL_NAME";
2616: 	default:
2617: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2618: 	}
2619: }
2620: 
2621: template<>
2622: KeywordCategory EnumUtil::FromString<KeywordCategory>(const char *value) {
2623: 	if (StringUtil::Equals(value, "KEYWORD_RESERVED")) {
2624: 		return KeywordCategory::KEYWORD_RESERVED;
2625: 	}
2626: 	if (StringUtil::Equals(value, "KEYWORD_UNRESERVED")) {
2627: 		return KeywordCategory::KEYWORD_UNRESERVED;
2628: 	}
2629: 	if (StringUtil::Equals(value, "KEYWORD_TYPE_FUNC")) {
2630: 		return KeywordCategory::KEYWORD_TYPE_FUNC;
2631: 	}
2632: 	if (StringUtil::Equals(value, "KEYWORD_COL_NAME")) {
2633: 		return KeywordCategory::KEYWORD_COL_NAME;
2634: 	}
2635: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2636: }
2637: 
2638: template<>
2639: const char* EnumUtil::ToChars<LoadType>(LoadType value) {
2640: 	switch(value) {
2641: 	case LoadType::LOAD:
2642: 		return "LOAD";
2643: 	case LoadType::INSTALL:
2644: 		return "INSTALL";
2645: 	case LoadType::FORCE_INSTALL:
2646: 		return "FORCE_INSTALL";
2647: 	default:
2648: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2649: 	}
2650: }
2651: 
2652: template<>
2653: LoadType EnumUtil::FromString<LoadType>(const char *value) {
2654: 	if (StringUtil::Equals(value, "LOAD")) {
2655: 		return LoadType::LOAD;
2656: 	}
2657: 	if (StringUtil::Equals(value, "INSTALL")) {
2658: 		return LoadType::INSTALL;
2659: 	}
2660: 	if (StringUtil::Equals(value, "FORCE_INSTALL")) {
2661: 		return LoadType::FORCE_INSTALL;
2662: 	}
2663: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2664: }
2665: 
2666: template<>
2667: const char* EnumUtil::ToChars<LogicalOperatorType>(LogicalOperatorType value) {
2668: 	switch(value) {
2669: 	case LogicalOperatorType::LOGICAL_INVALID:
2670: 		return "LOGICAL_INVALID";
2671: 	case LogicalOperatorType::LOGICAL_PROJECTION:
2672: 		return "LOGICAL_PROJECTION";
2673: 	case LogicalOperatorType::LOGICAL_FILTER:
2674: 		return "LOGICAL_FILTER";
2675: 	case LogicalOperatorType::LOGICAL_AGGREGATE_AND_GROUP_BY:
2676: 		return "LOGICAL_AGGREGATE_AND_GROUP_BY";
2677: 	case LogicalOperatorType::LOGICAL_WINDOW:
2678: 		return "LOGICAL_WINDOW";
2679: 	case LogicalOperatorType::LOGICAL_UNNEST:
2680: 		return "LOGICAL_UNNEST";
2681: 	case LogicalOperatorType::LOGICAL_LIMIT:
2682: 		return "LOGICAL_LIMIT";
2683: 	case LogicalOperatorType::LOGICAL_ORDER_BY:
2684: 		return "LOGICAL_ORDER_BY";
2685: 	case LogicalOperatorType::LOGICAL_TOP_N:
2686: 		return "LOGICAL_TOP_N";
2687: 	case LogicalOperatorType::LOGICAL_COPY_TO_FILE:
2688: 		return "LOGICAL_COPY_TO_FILE";
2689: 	case LogicalOperatorType::LOGICAL_DISTINCT:
2690: 		return "LOGICAL_DISTINCT";
2691: 	case LogicalOperatorType::LOGICAL_SAMPLE:
2692: 		return "LOGICAL_SAMPLE";
2693: 	case LogicalOperatorType::LOGICAL_LIMIT_PERCENT:
2694: 		return "LOGICAL_LIMIT_PERCENT";
2695: 	case LogicalOperatorType::LOGICAL_PIVOT:
2696: 		return "LOGICAL_PIVOT";
2697: 	case LogicalOperatorType::LOGICAL_GET:
2698: 		return "LOGICAL_GET";
2699: 	case LogicalOperatorType::LOGICAL_CHUNK_GET:
2700: 		return "LOGICAL_CHUNK_GET";
2701: 	case LogicalOperatorType::LOGICAL_DELIM_GET:
2702: 		return "LOGICAL_DELIM_GET";
2703: 	case LogicalOperatorType::LOGICAL_EXPRESSION_GET:
2704: 		return "LOGICAL_EXPRESSION_GET";
2705: 	case LogicalOperatorType::LOGICAL_DUMMY_SCAN:
2706: 		return "LOGICAL_DUMMY_SCAN";
2707: 	case LogicalOperatorType::LOGICAL_EMPTY_RESULT:
2708: 		return "LOGICAL_EMPTY_RESULT";
2709: 	case LogicalOperatorType::LOGICAL_CTE_REF:
2710: 		return "LOGICAL_CTE_REF";
2711: 	case LogicalOperatorType::LOGICAL_JOIN:
2712: 		return "LOGICAL_JOIN";
2713: 	case LogicalOperatorType::LOGICAL_DELIM_JOIN:
2714: 		return "LOGICAL_DELIM_JOIN";
2715: 	case LogicalOperatorType::LOGICAL_COMPARISON_JOIN:
2716: 		return "LOGICAL_COMPARISON_JOIN";
2717: 	case LogicalOperatorType::LOGICAL_ANY_JOIN:
2718: 		return "LOGICAL_ANY_JOIN";
2719: 	case LogicalOperatorType::LOGICAL_CROSS_PRODUCT:
2720: 		return "LOGICAL_CROSS_PRODUCT";
2721: 	case LogicalOperatorType::LOGICAL_POSITIONAL_JOIN:
2722: 		return "LOGICAL_POSITIONAL_JOIN";
2723: 	case LogicalOperatorType::LOGICAL_ASOF_JOIN:
2724: 		return "LOGICAL_ASOF_JOIN";
2725: 	case LogicalOperatorType::LOGICAL_DEPENDENT_JOIN:
2726: 		return "LOGICAL_DEPENDENT_JOIN";
2727: 	case LogicalOperatorType::LOGICAL_UNION:
2728: 		return "LOGICAL_UNION";
2729: 	case LogicalOperatorType::LOGICAL_EXCEPT:
2730: 		return "LOGICAL_EXCEPT";
2731: 	case LogicalOperatorType::LOGICAL_INTERSECT:
2732: 		return "LOGICAL_INTERSECT";
2733: 	case LogicalOperatorType::LOGICAL_RECURSIVE_CTE:
2734: 		return "LOGICAL_RECURSIVE_CTE";
2735: 	case LogicalOperatorType::LOGICAL_MATERIALIZED_CTE:
2736: 		return "LOGICAL_MATERIALIZED_CTE";
2737: 	case LogicalOperatorType::LOGICAL_INSERT:
2738: 		return "LOGICAL_INSERT";
2739: 	case LogicalOperatorType::LOGICAL_DELETE:
2740: 		return "LOGICAL_DELETE";
2741: 	case LogicalOperatorType::LOGICAL_UPDATE:
2742: 		return "LOGICAL_UPDATE";
2743: 	case LogicalOperatorType::LOGICAL_ALTER:
2744: 		return "LOGICAL_ALTER";
2745: 	case LogicalOperatorType::LOGICAL_CREATE_TABLE:
2746: 		return "LOGICAL_CREATE_TABLE";
2747: 	case LogicalOperatorType::LOGICAL_CREATE_INDEX:
2748: 		return "LOGICAL_CREATE_INDEX";
2749: 	case LogicalOperatorType::LOGICAL_CREATE_SEQUENCE:
2750: 		return "LOGICAL_CREATE_SEQUENCE";
2751: 	case LogicalOperatorType::LOGICAL_CREATE_VIEW:
2752: 		return "LOGICAL_CREATE_VIEW";
2753: 	case LogicalOperatorType::LOGICAL_CREATE_SCHEMA:
2754: 		return "LOGICAL_CREATE_SCHEMA";
2755: 	case LogicalOperatorType::LOGICAL_CREATE_MACRO:
2756: 		return "LOGICAL_CREATE_MACRO";
2757: 	case LogicalOperatorType::LOGICAL_DROP:
2758: 		return "LOGICAL_DROP";
2759: 	case LogicalOperatorType::LOGICAL_PRAGMA:
2760: 		return "LOGICAL_PRAGMA";
2761: 	case LogicalOperatorType::LOGICAL_TRANSACTION:
2762: 		return "LOGICAL_TRANSACTION";
2763: 	case LogicalOperatorType::LOGICAL_CREATE_TYPE:
2764: 		return "LOGICAL_CREATE_TYPE";
2765: 	case LogicalOperatorType::LOGICAL_ATTACH:
2766: 		return "LOGICAL_ATTACH";
2767: 	case LogicalOperatorType::LOGICAL_DETACH:
2768: 		return "LOGICAL_DETACH";
2769: 	case LogicalOperatorType::LOGICAL_EXPLAIN:
2770: 		return "LOGICAL_EXPLAIN";
2771: 	case LogicalOperatorType::LOGICAL_SHOW:
2772: 		return "LOGICAL_SHOW";
2773: 	case LogicalOperatorType::LOGICAL_PREPARE:
2774: 		return "LOGICAL_PREPARE";
2775: 	case LogicalOperatorType::LOGICAL_EXECUTE:
2776: 		return "LOGICAL_EXECUTE";
2777: 	case LogicalOperatorType::LOGICAL_EXPORT:
2778: 		return "LOGICAL_EXPORT";
2779: 	case LogicalOperatorType::LOGICAL_VACUUM:
2780: 		return "LOGICAL_VACUUM";
2781: 	case LogicalOperatorType::LOGICAL_SET:
2782: 		return "LOGICAL_SET";
2783: 	case LogicalOperatorType::LOGICAL_LOAD:
2784: 		return "LOGICAL_LOAD";
2785: 	case LogicalOperatorType::LOGICAL_RESET:
2786: 		return "LOGICAL_RESET";
2787: 	case LogicalOperatorType::LOGICAL_EXTENSION_OPERATOR:
2788: 		return "LOGICAL_EXTENSION_OPERATOR";
2789: 	default:
2790: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2791: 	}
2792: }
2793: 
2794: template<>
2795: LogicalOperatorType EnumUtil::FromString<LogicalOperatorType>(const char *value) {
2796: 	if (StringUtil::Equals(value, "LOGICAL_INVALID")) {
2797: 		return LogicalOperatorType::LOGICAL_INVALID;
2798: 	}
2799: 	if (StringUtil::Equals(value, "LOGICAL_PROJECTION")) {
2800: 		return LogicalOperatorType::LOGICAL_PROJECTION;
2801: 	}
2802: 	if (StringUtil::Equals(value, "LOGICAL_FILTER")) {
2803: 		return LogicalOperatorType::LOGICAL_FILTER;
2804: 	}
2805: 	if (StringUtil::Equals(value, "LOGICAL_AGGREGATE_AND_GROUP_BY")) {
2806: 		return LogicalOperatorType::LOGICAL_AGGREGATE_AND_GROUP_BY;
2807: 	}
2808: 	if (StringUtil::Equals(value, "LOGICAL_WINDOW")) {
2809: 		return LogicalOperatorType::LOGICAL_WINDOW;
2810: 	}
2811: 	if (StringUtil::Equals(value, "LOGICAL_UNNEST")) {
2812: 		return LogicalOperatorType::LOGICAL_UNNEST;
2813: 	}
2814: 	if (StringUtil::Equals(value, "LOGICAL_LIMIT")) {
2815: 		return LogicalOperatorType::LOGICAL_LIMIT;
2816: 	}
2817: 	if (StringUtil::Equals(value, "LOGICAL_ORDER_BY")) {
2818: 		return LogicalOperatorType::LOGICAL_ORDER_BY;
2819: 	}
2820: 	if (StringUtil::Equals(value, "LOGICAL_TOP_N")) {
2821: 		return LogicalOperatorType::LOGICAL_TOP_N;
2822: 	}
2823: 	if (StringUtil::Equals(value, "LOGICAL_COPY_TO_FILE")) {
2824: 		return LogicalOperatorType::LOGICAL_COPY_TO_FILE;
2825: 	}
2826: 	if (StringUtil::Equals(value, "LOGICAL_DISTINCT")) {
2827: 		return LogicalOperatorType::LOGICAL_DISTINCT;
2828: 	}
2829: 	if (StringUtil::Equals(value, "LOGICAL_SAMPLE")) {
2830: 		return LogicalOperatorType::LOGICAL_SAMPLE;
2831: 	}
2832: 	if (StringUtil::Equals(value, "LOGICAL_LIMIT_PERCENT")) {
2833: 		return LogicalOperatorType::LOGICAL_LIMIT_PERCENT;
2834: 	}
2835: 	if (StringUtil::Equals(value, "LOGICAL_PIVOT")) {
2836: 		return LogicalOperatorType::LOGICAL_PIVOT;
2837: 	}
2838: 	if (StringUtil::Equals(value, "LOGICAL_GET")) {
2839: 		return LogicalOperatorType::LOGICAL_GET;
2840: 	}
2841: 	if (StringUtil::Equals(value, "LOGICAL_CHUNK_GET")) {
2842: 		return LogicalOperatorType::LOGICAL_CHUNK_GET;
2843: 	}
2844: 	if (StringUtil::Equals(value, "LOGICAL_DELIM_GET")) {
2845: 		return LogicalOperatorType::LOGICAL_DELIM_GET;
2846: 	}
2847: 	if (StringUtil::Equals(value, "LOGICAL_EXPRESSION_GET")) {
2848: 		return LogicalOperatorType::LOGICAL_EXPRESSION_GET;
2849: 	}
2850: 	if (StringUtil::Equals(value, "LOGICAL_DUMMY_SCAN")) {
2851: 		return LogicalOperatorType::LOGICAL_DUMMY_SCAN;
2852: 	}
2853: 	if (StringUtil::Equals(value, "LOGICAL_EMPTY_RESULT")) {
2854: 		return LogicalOperatorType::LOGICAL_EMPTY_RESULT;
2855: 	}
2856: 	if (StringUtil::Equals(value, "LOGICAL_CTE_REF")) {
2857: 		return LogicalOperatorType::LOGICAL_CTE_REF;
2858: 	}
2859: 	if (StringUtil::Equals(value, "LOGICAL_JOIN")) {
2860: 		return LogicalOperatorType::LOGICAL_JOIN;
2861: 	}
2862: 	if (StringUtil::Equals(value, "LOGICAL_DELIM_JOIN")) {
2863: 		return LogicalOperatorType::LOGICAL_DELIM_JOIN;
2864: 	}
2865: 	if (StringUtil::Equals(value, "LOGICAL_COMPARISON_JOIN")) {
2866: 		return LogicalOperatorType::LOGICAL_COMPARISON_JOIN;
2867: 	}
2868: 	if (StringUtil::Equals(value, "LOGICAL_ANY_JOIN")) {
2869: 		return LogicalOperatorType::LOGICAL_ANY_JOIN;
2870: 	}
2871: 	if (StringUtil::Equals(value, "LOGICAL_CROSS_PRODUCT")) {
2872: 		return LogicalOperatorType::LOGICAL_CROSS_PRODUCT;
2873: 	}
2874: 	if (StringUtil::Equals(value, "LOGICAL_POSITIONAL_JOIN")) {
2875: 		return LogicalOperatorType::LOGICAL_POSITIONAL_JOIN;
2876: 	}
2877: 	if (StringUtil::Equals(value, "LOGICAL_ASOF_JOIN")) {
2878: 		return LogicalOperatorType::LOGICAL_ASOF_JOIN;
2879: 	}
2880: 	if (StringUtil::Equals(value, "LOGICAL_DEPENDENT_JOIN")) {
2881: 		return LogicalOperatorType::LOGICAL_DEPENDENT_JOIN;
2882: 	}
2883: 	if (StringUtil::Equals(value, "LOGICAL_UNION")) {
2884: 		return LogicalOperatorType::LOGICAL_UNION;
2885: 	}
2886: 	if (StringUtil::Equals(value, "LOGICAL_EXCEPT")) {
2887: 		return LogicalOperatorType::LOGICAL_EXCEPT;
2888: 	}
2889: 	if (StringUtil::Equals(value, "LOGICAL_INTERSECT")) {
2890: 		return LogicalOperatorType::LOGICAL_INTERSECT;
2891: 	}
2892: 	if (StringUtil::Equals(value, "LOGICAL_RECURSIVE_CTE")) {
2893: 		return LogicalOperatorType::LOGICAL_RECURSIVE_CTE;
2894: 	}
2895: 	if (StringUtil::Equals(value, "LOGICAL_MATERIALIZED_CTE")) {
2896: 		return LogicalOperatorType::LOGICAL_MATERIALIZED_CTE;
2897: 	}
2898: 	if (StringUtil::Equals(value, "LOGICAL_INSERT")) {
2899: 		return LogicalOperatorType::LOGICAL_INSERT;
2900: 	}
2901: 	if (StringUtil::Equals(value, "LOGICAL_DELETE")) {
2902: 		return LogicalOperatorType::LOGICAL_DELETE;
2903: 	}
2904: 	if (StringUtil::Equals(value, "LOGICAL_UPDATE")) {
2905: 		return LogicalOperatorType::LOGICAL_UPDATE;
2906: 	}
2907: 	if (StringUtil::Equals(value, "LOGICAL_ALTER")) {
2908: 		return LogicalOperatorType::LOGICAL_ALTER;
2909: 	}
2910: 	if (StringUtil::Equals(value, "LOGICAL_CREATE_TABLE")) {
2911: 		return LogicalOperatorType::LOGICAL_CREATE_TABLE;
2912: 	}
2913: 	if (StringUtil::Equals(value, "LOGICAL_CREATE_INDEX")) {
2914: 		return LogicalOperatorType::LOGICAL_CREATE_INDEX;
2915: 	}
2916: 	if (StringUtil::Equals(value, "LOGICAL_CREATE_SEQUENCE")) {
2917: 		return LogicalOperatorType::LOGICAL_CREATE_SEQUENCE;
2918: 	}
2919: 	if (StringUtil::Equals(value, "LOGICAL_CREATE_VIEW")) {
2920: 		return LogicalOperatorType::LOGICAL_CREATE_VIEW;
2921: 	}
2922: 	if (StringUtil::Equals(value, "LOGICAL_CREATE_SCHEMA")) {
2923: 		return LogicalOperatorType::LOGICAL_CREATE_SCHEMA;
2924: 	}
2925: 	if (StringUtil::Equals(value, "LOGICAL_CREATE_MACRO")) {
2926: 		return LogicalOperatorType::LOGICAL_CREATE_MACRO;
2927: 	}
2928: 	if (StringUtil::Equals(value, "LOGICAL_DROP")) {
2929: 		return LogicalOperatorType::LOGICAL_DROP;
2930: 	}
2931: 	if (StringUtil::Equals(value, "LOGICAL_PRAGMA")) {
2932: 		return LogicalOperatorType::LOGICAL_PRAGMA;
2933: 	}
2934: 	if (StringUtil::Equals(value, "LOGICAL_TRANSACTION")) {
2935: 		return LogicalOperatorType::LOGICAL_TRANSACTION;
2936: 	}
2937: 	if (StringUtil::Equals(value, "LOGICAL_CREATE_TYPE")) {
2938: 		return LogicalOperatorType::LOGICAL_CREATE_TYPE;
2939: 	}
2940: 	if (StringUtil::Equals(value, "LOGICAL_ATTACH")) {
2941: 		return LogicalOperatorType::LOGICAL_ATTACH;
2942: 	}
2943: 	if (StringUtil::Equals(value, "LOGICAL_DETACH")) {
2944: 		return LogicalOperatorType::LOGICAL_DETACH;
2945: 	}
2946: 	if (StringUtil::Equals(value, "LOGICAL_EXPLAIN")) {
2947: 		return LogicalOperatorType::LOGICAL_EXPLAIN;
2948: 	}
2949: 	if (StringUtil::Equals(value, "LOGICAL_SHOW")) {
2950: 		return LogicalOperatorType::LOGICAL_SHOW;
2951: 	}
2952: 	if (StringUtil::Equals(value, "LOGICAL_PREPARE")) {
2953: 		return LogicalOperatorType::LOGICAL_PREPARE;
2954: 	}
2955: 	if (StringUtil::Equals(value, "LOGICAL_EXECUTE")) {
2956: 		return LogicalOperatorType::LOGICAL_EXECUTE;
2957: 	}
2958: 	if (StringUtil::Equals(value, "LOGICAL_EXPORT")) {
2959: 		return LogicalOperatorType::LOGICAL_EXPORT;
2960: 	}
2961: 	if (StringUtil::Equals(value, "LOGICAL_VACUUM")) {
2962: 		return LogicalOperatorType::LOGICAL_VACUUM;
2963: 	}
2964: 	if (StringUtil::Equals(value, "LOGICAL_SET")) {
2965: 		return LogicalOperatorType::LOGICAL_SET;
2966: 	}
2967: 	if (StringUtil::Equals(value, "LOGICAL_LOAD")) {
2968: 		return LogicalOperatorType::LOGICAL_LOAD;
2969: 	}
2970: 	if (StringUtil::Equals(value, "LOGICAL_RESET")) {
2971: 		return LogicalOperatorType::LOGICAL_RESET;
2972: 	}
2973: 	if (StringUtil::Equals(value, "LOGICAL_EXTENSION_OPERATOR")) {
2974: 		return LogicalOperatorType::LOGICAL_EXTENSION_OPERATOR;
2975: 	}
2976: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2977: }
2978: 
2979: template<>
2980: const char* EnumUtil::ToChars<LogicalTypeId>(LogicalTypeId value) {
2981: 	switch(value) {
2982: 	case LogicalTypeId::INVALID:
2983: 		return "INVALID";
2984: 	case LogicalTypeId::SQLNULL:
2985: 		return "NULL";
2986: 	case LogicalTypeId::UNKNOWN:
2987: 		return "UNKNOWN";
2988: 	case LogicalTypeId::ANY:
2989: 		return "ANY";
2990: 	case LogicalTypeId::USER:
2991: 		return "USER";
2992: 	case LogicalTypeId::BOOLEAN:
2993: 		return "BOOLEAN";
2994: 	case LogicalTypeId::TINYINT:
2995: 		return "TINYINT";
2996: 	case LogicalTypeId::SMALLINT:
2997: 		return "SMALLINT";
2998: 	case LogicalTypeId::INTEGER:
2999: 		return "INTEGER";
3000: 	case LogicalTypeId::BIGINT:
3001: 		return "BIGINT";
3002: 	case LogicalTypeId::DATE:
3003: 		return "DATE";
3004: 	case LogicalTypeId::TIME:
3005: 		return "TIME";
3006: 	case LogicalTypeId::TIMESTAMP_SEC:
3007: 		return "TIMESTAMP_S";
3008: 	case LogicalTypeId::TIMESTAMP_MS:
3009: 		return "TIMESTAMP_MS";
3010: 	case LogicalTypeId::TIMESTAMP:
3011: 		return "TIMESTAMP";
3012: 	case LogicalTypeId::TIMESTAMP_NS:
3013: 		return "TIMESTAMP_NS";
3014: 	case LogicalTypeId::DECIMAL:
3015: 		return "DECIMAL";
3016: 	case LogicalTypeId::FLOAT:
3017: 		return "FLOAT";
3018: 	case LogicalTypeId::DOUBLE:
3019: 		return "DOUBLE";
3020: 	case LogicalTypeId::CHAR:
3021: 		return "CHAR";
3022: 	case LogicalTypeId::VARCHAR:
3023: 		return "VARCHAR";
3024: 	case LogicalTypeId::BLOB:
3025: 		return "BLOB";
3026: 	case LogicalTypeId::INTERVAL:
3027: 		return "INTERVAL";
3028: 	case LogicalTypeId::UTINYINT:
3029: 		return "UTINYINT";
3030: 	case LogicalTypeId::USMALLINT:
3031: 		return "USMALLINT";
3032: 	case LogicalTypeId::UINTEGER:
3033: 		return "UINTEGER";
3034: 	case LogicalTypeId::UBIGINT:
3035: 		return "UBIGINT";
3036: 	case LogicalTypeId::TIMESTAMP_TZ:
3037: 		return "TIMESTAMP WITH TIME ZONE";
3038: 	case LogicalTypeId::TIME_TZ:
3039: 		return "TIME WITH TIME ZONE";
3040: 	case LogicalTypeId::BIT:
3041: 		return "BIT";
3042: 	case LogicalTypeId::HUGEINT:
3043: 		return "HUGEINT";
3044: 	case LogicalTypeId::POINTER:
3045: 		return "POINTER";
3046: 	case LogicalTypeId::VALIDITY:
3047: 		return "VALIDITY";
3048: 	case LogicalTypeId::UUID:
3049: 		return "UUID";
3050: 	case LogicalTypeId::STRUCT:
3051: 		return "STRUCT";
3052: 	case LogicalTypeId::LIST:
3053: 		return "LIST";
3054: 	case LogicalTypeId::MAP:
3055: 		return "MAP";
3056: 	case LogicalTypeId::TABLE:
3057: 		return "TABLE";
3058: 	case LogicalTypeId::ENUM:
3059: 		return "ENUM";
3060: 	case LogicalTypeId::AGGREGATE_STATE:
3061: 		return "AGGREGATE_STATE";
3062: 	case LogicalTypeId::LAMBDA:
3063: 		return "LAMBDA";
3064: 	case LogicalTypeId::UNION:
3065: 		return "UNION";
3066: 	default:
3067: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3068: 	}
3069: }
3070: 
3071: template<>
3072: LogicalTypeId EnumUtil::FromString<LogicalTypeId>(const char *value) {
3073: 	if (StringUtil::Equals(value, "INVALID")) {
3074: 		return LogicalTypeId::INVALID;
3075: 	}
3076: 	if (StringUtil::Equals(value, "NULL")) {
3077: 		return LogicalTypeId::SQLNULL;
3078: 	}
3079: 	if (StringUtil::Equals(value, "UNKNOWN")) {
3080: 		return LogicalTypeId::UNKNOWN;
3081: 	}
3082: 	if (StringUtil::Equals(value, "ANY")) {
3083: 		return LogicalTypeId::ANY;
3084: 	}
3085: 	if (StringUtil::Equals(value, "USER")) {
3086: 		return LogicalTypeId::USER;
3087: 	}
3088: 	if (StringUtil::Equals(value, "BOOLEAN")) {
3089: 		return LogicalTypeId::BOOLEAN;
3090: 	}
3091: 	if (StringUtil::Equals(value, "TINYINT")) {
3092: 		return LogicalTypeId::TINYINT;
3093: 	}
3094: 	if (StringUtil::Equals(value, "SMALLINT")) {
3095: 		return LogicalTypeId::SMALLINT;
3096: 	}
3097: 	if (StringUtil::Equals(value, "INTEGER")) {
3098: 		return LogicalTypeId::INTEGER;
3099: 	}
3100: 	if (StringUtil::Equals(value, "BIGINT")) {
3101: 		return LogicalTypeId::BIGINT;
3102: 	}
3103: 	if (StringUtil::Equals(value, "DATE")) {
3104: 		return LogicalTypeId::DATE;
3105: 	}
3106: 	if (StringUtil::Equals(value, "TIME")) {
3107: 		return LogicalTypeId::TIME;
3108: 	}
3109: 	if (StringUtil::Equals(value, "TIMESTAMP_S")) {
3110: 		return LogicalTypeId::TIMESTAMP_SEC;
3111: 	}
3112: 	if (StringUtil::Equals(value, "TIMESTAMP_MS")) {
3113: 		return LogicalTypeId::TIMESTAMP_MS;
3114: 	}
3115: 	if (StringUtil::Equals(value, "TIMESTAMP")) {
3116: 		return LogicalTypeId::TIMESTAMP;
3117: 	}
3118: 	if (StringUtil::Equals(value, "TIMESTAMP_NS")) {
3119: 		return LogicalTypeId::TIMESTAMP_NS;
3120: 	}
3121: 	if (StringUtil::Equals(value, "DECIMAL")) {
3122: 		return LogicalTypeId::DECIMAL;
3123: 	}
3124: 	if (StringUtil::Equals(value, "FLOAT")) {
3125: 		return LogicalTypeId::FLOAT;
3126: 	}
3127: 	if (StringUtil::Equals(value, "DOUBLE")) {
3128: 		return LogicalTypeId::DOUBLE;
3129: 	}
3130: 	if (StringUtil::Equals(value, "CHAR")) {
3131: 		return LogicalTypeId::CHAR;
3132: 	}
3133: 	if (StringUtil::Equals(value, "VARCHAR")) {
3134: 		return LogicalTypeId::VARCHAR;
3135: 	}
3136: 	if (StringUtil::Equals(value, "BLOB")) {
3137: 		return LogicalTypeId::BLOB;
3138: 	}
3139: 	if (StringUtil::Equals(value, "INTERVAL")) {
3140: 		return LogicalTypeId::INTERVAL;
3141: 	}
3142: 	if (StringUtil::Equals(value, "UTINYINT")) {
3143: 		return LogicalTypeId::UTINYINT;
3144: 	}
3145: 	if (StringUtil::Equals(value, "USMALLINT")) {
3146: 		return LogicalTypeId::USMALLINT;
3147: 	}
3148: 	if (StringUtil::Equals(value, "UINTEGER")) {
3149: 		return LogicalTypeId::UINTEGER;
3150: 	}
3151: 	if (StringUtil::Equals(value, "UBIGINT")) {
3152: 		return LogicalTypeId::UBIGINT;
3153: 	}
3154: 	if (StringUtil::Equals(value, "TIMESTAMP WITH TIME ZONE")) {
3155: 		return LogicalTypeId::TIMESTAMP_TZ;
3156: 	}
3157: 	if (StringUtil::Equals(value, "TIME WITH TIME ZONE")) {
3158: 		return LogicalTypeId::TIME_TZ;
3159: 	}
3160: 	if (StringUtil::Equals(value, "BIT")) {
3161: 		return LogicalTypeId::BIT;
3162: 	}
3163: 	if (StringUtil::Equals(value, "HUGEINT")) {
3164: 		return LogicalTypeId::HUGEINT;
3165: 	}
3166: 	if (StringUtil::Equals(value, "POINTER")) {
3167: 		return LogicalTypeId::POINTER;
3168: 	}
3169: 	if (StringUtil::Equals(value, "VALIDITY")) {
3170: 		return LogicalTypeId::VALIDITY;
3171: 	}
3172: 	if (StringUtil::Equals(value, "UUID")) {
3173: 		return LogicalTypeId::UUID;
3174: 	}
3175: 	if (StringUtil::Equals(value, "STRUCT")) {
3176: 		return LogicalTypeId::STRUCT;
3177: 	}
3178: 	if (StringUtil::Equals(value, "LIST")) {
3179: 		return LogicalTypeId::LIST;
3180: 	}
3181: 	if (StringUtil::Equals(value, "MAP")) {
3182: 		return LogicalTypeId::MAP;
3183: 	}
3184: 	if (StringUtil::Equals(value, "TABLE")) {
3185: 		return LogicalTypeId::TABLE;
3186: 	}
3187: 	if (StringUtil::Equals(value, "ENUM")) {
3188: 		return LogicalTypeId::ENUM;
3189: 	}
3190: 	if (StringUtil::Equals(value, "AGGREGATE_STATE")) {
3191: 		return LogicalTypeId::AGGREGATE_STATE;
3192: 	}
3193: 	if (StringUtil::Equals(value, "LAMBDA")) {
3194: 		return LogicalTypeId::LAMBDA;
3195: 	}
3196: 	if (StringUtil::Equals(value, "UNION")) {
3197: 		return LogicalTypeId::UNION;
3198: 	}
3199: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3200: }
3201: 
3202: template<>
3203: const char* EnumUtil::ToChars<LookupResultType>(LookupResultType value) {
3204: 	switch(value) {
3205: 	case LookupResultType::LOOKUP_MISS:
3206: 		return "LOOKUP_MISS";
3207: 	case LookupResultType::LOOKUP_HIT:
3208: 		return "LOOKUP_HIT";
3209: 	case LookupResultType::LOOKUP_NULL:
3210: 		return "LOOKUP_NULL";
3211: 	default:
3212: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3213: 	}
3214: }
3215: 
3216: template<>
3217: LookupResultType EnumUtil::FromString<LookupResultType>(const char *value) {
3218: 	if (StringUtil::Equals(value, "LOOKUP_MISS")) {
3219: 		return LookupResultType::LOOKUP_MISS;
3220: 	}
3221: 	if (StringUtil::Equals(value, "LOOKUP_HIT")) {
3222: 		return LookupResultType::LOOKUP_HIT;
3223: 	}
3224: 	if (StringUtil::Equals(value, "LOOKUP_NULL")) {
3225: 		return LookupResultType::LOOKUP_NULL;
3226: 	}
3227: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3228: }
3229: 
3230: template<>
3231: const char* EnumUtil::ToChars<MacroType>(MacroType value) {
3232: 	switch(value) {
3233: 	case MacroType::VOID_MACRO:
3234: 		return "VOID_MACRO";
3235: 	case MacroType::TABLE_MACRO:
3236: 		return "TABLE_MACRO";
3237: 	case MacroType::SCALAR_MACRO:
3238: 		return "SCALAR_MACRO";
3239: 	default:
3240: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3241: 	}
3242: }
3243: 
3244: template<>
3245: MacroType EnumUtil::FromString<MacroType>(const char *value) {
3246: 	if (StringUtil::Equals(value, "VOID_MACRO")) {
3247: 		return MacroType::VOID_MACRO;
3248: 	}
3249: 	if (StringUtil::Equals(value, "TABLE_MACRO")) {
3250: 		return MacroType::TABLE_MACRO;
3251: 	}
3252: 	if (StringUtil::Equals(value, "SCALAR_MACRO")) {
3253: 		return MacroType::SCALAR_MACRO;
3254: 	}
3255: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3256: }
3257: 
3258: template<>
3259: const char* EnumUtil::ToChars<MapInvalidReason>(MapInvalidReason value) {
3260: 	switch(value) {
3261: 	case MapInvalidReason::VALID:
3262: 		return "VALID";
3263: 	case MapInvalidReason::NULL_KEY_LIST:
3264: 		return "NULL_KEY_LIST";
3265: 	case MapInvalidReason::NULL_KEY:
3266: 		return "NULL_KEY";
3267: 	case MapInvalidReason::DUPLICATE_KEY:
3268: 		return "DUPLICATE_KEY";
3269: 	default:
3270: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3271: 	}
3272: }
3273: 
3274: template<>
3275: MapInvalidReason EnumUtil::FromString<MapInvalidReason>(const char *value) {
3276: 	if (StringUtil::Equals(value, "VALID")) {
3277: 		return MapInvalidReason::VALID;
3278: 	}
3279: 	if (StringUtil::Equals(value, "NULL_KEY_LIST")) {
3280: 		return MapInvalidReason::NULL_KEY_LIST;
3281: 	}
3282: 	if (StringUtil::Equals(value, "NULL_KEY")) {
3283: 		return MapInvalidReason::NULL_KEY;
3284: 	}
3285: 	if (StringUtil::Equals(value, "DUPLICATE_KEY")) {
3286: 		return MapInvalidReason::DUPLICATE_KEY;
3287: 	}
3288: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3289: }
3290: 
3291: template<>
3292: const char* EnumUtil::ToChars<NType>(NType value) {
3293: 	switch(value) {
3294: 	case NType::PREFIX:
3295: 		return "PREFIX";
3296: 	case NType::LEAF:
3297: 		return "LEAF";
3298: 	case NType::NODE_4:
3299: 		return "NODE_4";
3300: 	case NType::NODE_16:
3301: 		return "NODE_16";
3302: 	case NType::NODE_48:
3303: 		return "NODE_48";
3304: 	case NType::NODE_256:
3305: 		return "NODE_256";
3306: 	case NType::LEAF_INLINED:
3307: 		return "LEAF_INLINED";
3308: 	default:
3309: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3310: 	}
3311: }
3312: 
3313: template<>
3314: NType EnumUtil::FromString<NType>(const char *value) {
3315: 	if (StringUtil::Equals(value, "PREFIX")) {
3316: 		return NType::PREFIX;
3317: 	}
3318: 	if (StringUtil::Equals(value, "LEAF")) {
3319: 		return NType::LEAF;
3320: 	}
3321: 	if (StringUtil::Equals(value, "NODE_4")) {
3322: 		return NType::NODE_4;
3323: 	}
3324: 	if (StringUtil::Equals(value, "NODE_16")) {
3325: 		return NType::NODE_16;
3326: 	}
3327: 	if (StringUtil::Equals(value, "NODE_48")) {
3328: 		return NType::NODE_48;
3329: 	}
3330: 	if (StringUtil::Equals(value, "NODE_256")) {
3331: 		return NType::NODE_256;
3332: 	}
3333: 	if (StringUtil::Equals(value, "LEAF_INLINED")) {
3334: 		return NType::LEAF_INLINED;
3335: 	}
3336: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3337: }
3338: 
3339: template<>
3340: const char* EnumUtil::ToChars<NewLineIdentifier>(NewLineIdentifier value) {
3341: 	switch(value) {
3342: 	case NewLineIdentifier::SINGLE:
3343: 		return "SINGLE";
3344: 	case NewLineIdentifier::CARRY_ON:
3345: 		return "CARRY_ON";
3346: 	case NewLineIdentifier::MIX:
3347: 		return "MIX";
3348: 	case NewLineIdentifier::NOT_SET:
3349: 		return "NOT_SET";
3350: 	default:
3351: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3352: 	}
3353: }
3354: 
3355: template<>
3356: NewLineIdentifier EnumUtil::FromString<NewLineIdentifier>(const char *value) {
3357: 	if (StringUtil::Equals(value, "SINGLE")) {
3358: 		return NewLineIdentifier::SINGLE;
3359: 	}
3360: 	if (StringUtil::Equals(value, "CARRY_ON")) {
3361: 		return NewLineIdentifier::CARRY_ON;
3362: 	}
3363: 	if (StringUtil::Equals(value, "MIX")) {
3364: 		return NewLineIdentifier::MIX;
3365: 	}
3366: 	if (StringUtil::Equals(value, "NOT_SET")) {
3367: 		return NewLineIdentifier::NOT_SET;
3368: 	}
3369: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3370: }
3371: 
3372: template<>
3373: const char* EnumUtil::ToChars<OnConflictAction>(OnConflictAction value) {
3374: 	switch(value) {
3375: 	case OnConflictAction::THROW:
3376: 		return "THROW";
3377: 	case OnConflictAction::NOTHING:
3378: 		return "NOTHING";
3379: 	case OnConflictAction::UPDATE:
3380: 		return "UPDATE";
3381: 	case OnConflictAction::REPLACE:
3382: 		return "REPLACE";
3383: 	default:
3384: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3385: 	}
3386: }
3387: 
3388: template<>
3389: OnConflictAction EnumUtil::FromString<OnConflictAction>(const char *value) {
3390: 	if (StringUtil::Equals(value, "THROW")) {
3391: 		return OnConflictAction::THROW;
3392: 	}
3393: 	if (StringUtil::Equals(value, "NOTHING")) {
3394: 		return OnConflictAction::NOTHING;
3395: 	}
3396: 	if (StringUtil::Equals(value, "UPDATE")) {
3397: 		return OnConflictAction::UPDATE;
3398: 	}
3399: 	if (StringUtil::Equals(value, "REPLACE")) {
3400: 		return OnConflictAction::REPLACE;
3401: 	}
3402: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3403: }
3404: 
3405: template<>
3406: const char* EnumUtil::ToChars<OnCreateConflict>(OnCreateConflict value) {
3407: 	switch(value) {
3408: 	case OnCreateConflict::ERROR_ON_CONFLICT:
3409: 		return "ERROR_ON_CONFLICT";
3410: 	case OnCreateConflict::IGNORE_ON_CONFLICT:
3411: 		return "IGNORE_ON_CONFLICT";
3412: 	case OnCreateConflict::REPLACE_ON_CONFLICT:
3413: 		return "REPLACE_ON_CONFLICT";
3414: 	case OnCreateConflict::ALTER_ON_CONFLICT:
3415: 		return "ALTER_ON_CONFLICT";
3416: 	default:
3417: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3418: 	}
3419: }
3420: 
3421: template<>
3422: OnCreateConflict EnumUtil::FromString<OnCreateConflict>(const char *value) {
3423: 	if (StringUtil::Equals(value, "ERROR_ON_CONFLICT")) {
3424: 		return OnCreateConflict::ERROR_ON_CONFLICT;
3425: 	}
3426: 	if (StringUtil::Equals(value, "IGNORE_ON_CONFLICT")) {
3427: 		return OnCreateConflict::IGNORE_ON_CONFLICT;
3428: 	}
3429: 	if (StringUtil::Equals(value, "REPLACE_ON_CONFLICT")) {
3430: 		return OnCreateConflict::REPLACE_ON_CONFLICT;
3431: 	}
3432: 	if (StringUtil::Equals(value, "ALTER_ON_CONFLICT")) {
3433: 		return OnCreateConflict::ALTER_ON_CONFLICT;
3434: 	}
3435: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3436: }
3437: 
3438: template<>
3439: const char* EnumUtil::ToChars<OnEntryNotFound>(OnEntryNotFound value) {
3440: 	switch(value) {
3441: 	case OnEntryNotFound::THROW_EXCEPTION:
3442: 		return "THROW_EXCEPTION";
3443: 	case OnEntryNotFound::RETURN_NULL:
3444: 		return "RETURN_NULL";
3445: 	default:
3446: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3447: 	}
3448: }
3449: 
3450: template<>
3451: OnEntryNotFound EnumUtil::FromString<OnEntryNotFound>(const char *value) {
3452: 	if (StringUtil::Equals(value, "THROW_EXCEPTION")) {
3453: 		return OnEntryNotFound::THROW_EXCEPTION;
3454: 	}
3455: 	if (StringUtil::Equals(value, "RETURN_NULL")) {
3456: 		return OnEntryNotFound::RETURN_NULL;
3457: 	}
3458: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3459: }
3460: 
3461: template<>
3462: const char* EnumUtil::ToChars<OperatorFinalizeResultType>(OperatorFinalizeResultType value) {
3463: 	switch(value) {
3464: 	case OperatorFinalizeResultType::HAVE_MORE_OUTPUT:
3465: 		return "HAVE_MORE_OUTPUT";
3466: 	case OperatorFinalizeResultType::FINISHED:
3467: 		return "FINISHED";
3468: 	default:
3469: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3470: 	}
3471: }
3472: 
3473: template<>
3474: OperatorFinalizeResultType EnumUtil::FromString<OperatorFinalizeResultType>(const char *value) {
3475: 	if (StringUtil::Equals(value, "HAVE_MORE_OUTPUT")) {
3476: 		return OperatorFinalizeResultType::HAVE_MORE_OUTPUT;
3477: 	}
3478: 	if (StringUtil::Equals(value, "FINISHED")) {
3479: 		return OperatorFinalizeResultType::FINISHED;
3480: 	}
3481: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3482: }
3483: 
3484: template<>
3485: const char* EnumUtil::ToChars<OperatorResultType>(OperatorResultType value) {
3486: 	switch(value) {
3487: 	case OperatorResultType::NEED_MORE_INPUT:
3488: 		return "NEED_MORE_INPUT";
3489: 	case OperatorResultType::HAVE_MORE_OUTPUT:
3490: 		return "HAVE_MORE_OUTPUT";
3491: 	case OperatorResultType::FINISHED:
3492: 		return "FINISHED";
3493: 	case OperatorResultType::BLOCKED:
3494: 		return "BLOCKED";
3495: 	default:
3496: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3497: 	}
3498: }
3499: 
3500: template<>
3501: OperatorResultType EnumUtil::FromString<OperatorResultType>(const char *value) {
3502: 	if (StringUtil::Equals(value, "NEED_MORE_INPUT")) {
3503: 		return OperatorResultType::NEED_MORE_INPUT;
3504: 	}
3505: 	if (StringUtil::Equals(value, "HAVE_MORE_OUTPUT")) {
3506: 		return OperatorResultType::HAVE_MORE_OUTPUT;
3507: 	}
3508: 	if (StringUtil::Equals(value, "FINISHED")) {
3509: 		return OperatorResultType::FINISHED;
3510: 	}
3511: 	if (StringUtil::Equals(value, "BLOCKED")) {
3512: 		return OperatorResultType::BLOCKED;
3513: 	}
3514: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3515: }
3516: 
3517: template<>
3518: const char* EnumUtil::ToChars<OptimizerType>(OptimizerType value) {
3519: 	switch(value) {
3520: 	case OptimizerType::INVALID:
3521: 		return "INVALID";
3522: 	case OptimizerType::EXPRESSION_REWRITER:
3523: 		return "EXPRESSION_REWRITER";
3524: 	case OptimizerType::FILTER_PULLUP:
3525: 		return "FILTER_PULLUP";
3526: 	case OptimizerType::FILTER_PUSHDOWN:
3527: 		return "FILTER_PUSHDOWN";
3528: 	case OptimizerType::REGEX_RANGE:
3529: 		return "REGEX_RANGE";
3530: 	case OptimizerType::IN_CLAUSE:
3531: 		return "IN_CLAUSE";
3532: 	case OptimizerType::JOIN_ORDER:
3533: 		return "JOIN_ORDER";
3534: 	case OptimizerType::DELIMINATOR:
3535: 		return "DELIMINATOR";
3536: 	case OptimizerType::UNNEST_REWRITER:
3537: 		return "UNNEST_REWRITER";
3538: 	case OptimizerType::UNUSED_COLUMNS:
3539: 		return "UNUSED_COLUMNS";
3540: 	case OptimizerType::STATISTICS_PROPAGATION:
3541: 		return "STATISTICS_PROPAGATION";
3542: 	case OptimizerType::COMMON_SUBEXPRESSIONS:
3543: 		return "COMMON_SUBEXPRESSIONS";
3544: 	case OptimizerType::COMMON_AGGREGATE:
3545: 		return "COMMON_AGGREGATE";
3546: 	case OptimizerType::COLUMN_LIFETIME:
3547: 		return "COLUMN_LIFETIME";
3548: 	case OptimizerType::TOP_N:
3549: 		return "TOP_N";
3550: 	case OptimizerType::COMPRESSED_MATERIALIZATION:
3551: 		return "COMPRESSED_MATERIALIZATION";
3552: 	case OptimizerType::DUPLICATE_GROUPS:
3553: 		return "DUPLICATE_GROUPS";
3554: 	case OptimizerType::REORDER_FILTER:
3555: 		return "REORDER_FILTER";
3556: 	case OptimizerType::EXTENSION:
3557: 		return "EXTENSION";
3558: 	default:
3559: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3560: 	}
3561: }
3562: 
3563: template<>
3564: OptimizerType EnumUtil::FromString<OptimizerType>(const char *value) {
3565: 	if (StringUtil::Equals(value, "INVALID")) {
3566: 		return OptimizerType::INVALID;
3567: 	}
3568: 	if (StringUtil::Equals(value, "EXPRESSION_REWRITER")) {
3569: 		return OptimizerType::EXPRESSION_REWRITER;
3570: 	}
3571: 	if (StringUtil::Equals(value, "FILTER_PULLUP")) {
3572: 		return OptimizerType::FILTER_PULLUP;
3573: 	}
3574: 	if (StringUtil::Equals(value, "FILTER_PUSHDOWN")) {
3575: 		return OptimizerType::FILTER_PUSHDOWN;
3576: 	}
3577: 	if (StringUtil::Equals(value, "REGEX_RANGE")) {
3578: 		return OptimizerType::REGEX_RANGE;
3579: 	}
3580: 	if (StringUtil::Equals(value, "IN_CLAUSE")) {
3581: 		return OptimizerType::IN_CLAUSE;
3582: 	}
3583: 	if (StringUtil::Equals(value, "JOIN_ORDER")) {
3584: 		return OptimizerType::JOIN_ORDER;
3585: 	}
3586: 	if (StringUtil::Equals(value, "DELIMINATOR")) {
3587: 		return OptimizerType::DELIMINATOR;
3588: 	}
3589: 	if (StringUtil::Equals(value, "UNNEST_REWRITER")) {
3590: 		return OptimizerType::UNNEST_REWRITER;
3591: 	}
3592: 	if (StringUtil::Equals(value, "UNUSED_COLUMNS")) {
3593: 		return OptimizerType::UNUSED_COLUMNS;
3594: 	}
3595: 	if (StringUtil::Equals(value, "STATISTICS_PROPAGATION")) {
3596: 		return OptimizerType::STATISTICS_PROPAGATION;
3597: 	}
3598: 	if (StringUtil::Equals(value, "COMMON_SUBEXPRESSIONS")) {
3599: 		return OptimizerType::COMMON_SUBEXPRESSIONS;
3600: 	}
3601: 	if (StringUtil::Equals(value, "COMMON_AGGREGATE")) {
3602: 		return OptimizerType::COMMON_AGGREGATE;
3603: 	}
3604: 	if (StringUtil::Equals(value, "COLUMN_LIFETIME")) {
3605: 		return OptimizerType::COLUMN_LIFETIME;
3606: 	}
3607: 	if (StringUtil::Equals(value, "TOP_N")) {
3608: 		return OptimizerType::TOP_N;
3609: 	}
3610: 	if (StringUtil::Equals(value, "COMPRESSED_MATERIALIZATION")) {
3611: 		return OptimizerType::COMPRESSED_MATERIALIZATION;
3612: 	}
3613: 	if (StringUtil::Equals(value, "DUPLICATE_GROUPS")) {
3614: 		return OptimizerType::DUPLICATE_GROUPS;
3615: 	}
3616: 	if (StringUtil::Equals(value, "REORDER_FILTER")) {
3617: 		return OptimizerType::REORDER_FILTER;
3618: 	}
3619: 	if (StringUtil::Equals(value, "EXTENSION")) {
3620: 		return OptimizerType::EXTENSION;
3621: 	}
3622: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3623: }
3624: 
3625: template<>
3626: const char* EnumUtil::ToChars<OrderByNullType>(OrderByNullType value) {
3627: 	switch(value) {
3628: 	case OrderByNullType::INVALID:
3629: 		return "INVALID";
3630: 	case OrderByNullType::ORDER_DEFAULT:
3631: 		return "ORDER_DEFAULT";
3632: 	case OrderByNullType::NULLS_FIRST:
3633: 		return "NULLS_FIRST";
3634: 	case OrderByNullType::NULLS_LAST:
3635: 		return "NULLS_LAST";
3636: 	default:
3637: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3638: 	}
3639: }
3640: 
3641: template<>
3642: OrderByNullType EnumUtil::FromString<OrderByNullType>(const char *value) {
3643: 	if (StringUtil::Equals(value, "INVALID")) {
3644: 		return OrderByNullType::INVALID;
3645: 	}
3646: 	if (StringUtil::Equals(value, "ORDER_DEFAULT") || StringUtil::Equals(value, "DEFAULT")) {
3647: 		return OrderByNullType::ORDER_DEFAULT;
3648: 	}
3649: 	if (StringUtil::Equals(value, "NULLS_FIRST") || StringUtil::Equals(value, "NULLS FIRST")) {
3650: 		return OrderByNullType::NULLS_FIRST;
3651: 	}
3652: 	if (StringUtil::Equals(value, "NULLS_LAST") || StringUtil::Equals(value, "NULLS LAST")) {
3653: 		return OrderByNullType::NULLS_LAST;
3654: 	}
3655: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3656: }
3657: 
3658: template<>
3659: const char* EnumUtil::ToChars<OrderPreservationType>(OrderPreservationType value) {
3660: 	switch(value) {
3661: 	case OrderPreservationType::NO_ORDER:
3662: 		return "NO_ORDER";
3663: 	case OrderPreservationType::INSERTION_ORDER:
3664: 		return "INSERTION_ORDER";
3665: 	case OrderPreservationType::FIXED_ORDER:
3666: 		return "FIXED_ORDER";
3667: 	default:
3668: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3669: 	}
3670: }
3671: 
3672: template<>
3673: OrderPreservationType EnumUtil::FromString<OrderPreservationType>(const char *value) {
3674: 	if (StringUtil::Equals(value, "NO_ORDER")) {
3675: 		return OrderPreservationType::NO_ORDER;
3676: 	}
3677: 	if (StringUtil::Equals(value, "INSERTION_ORDER")) {
3678: 		return OrderPreservationType::INSERTION_ORDER;
3679: 	}
3680: 	if (StringUtil::Equals(value, "FIXED_ORDER")) {
3681: 		return OrderPreservationType::FIXED_ORDER;
3682: 	}
3683: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3684: }
3685: 
3686: template<>
3687: const char* EnumUtil::ToChars<OrderType>(OrderType value) {
3688: 	switch(value) {
3689: 	case OrderType::INVALID:
3690: 		return "INVALID";
3691: 	case OrderType::ORDER_DEFAULT:
3692: 		return "ORDER_DEFAULT";
3693: 	case OrderType::ASCENDING:
3694: 		return "ASCENDING";
3695: 	case OrderType::DESCENDING:
3696: 		return "DESCENDING";
3697: 	default:
3698: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3699: 	}
3700: }
3701: 
3702: template<>
3703: OrderType EnumUtil::FromString<OrderType>(const char *value) {
3704: 	if (StringUtil::Equals(value, "INVALID")) {
3705: 		return OrderType::INVALID;
3706: 	}
3707: 	if (StringUtil::Equals(value, "ORDER_DEFAULT") || StringUtil::Equals(value, "DEFAULT")) {
3708: 		return OrderType::ORDER_DEFAULT;
3709: 	}
3710: 	if (StringUtil::Equals(value, "ASCENDING") || StringUtil::Equals(value, "ASC")) {
3711: 		return OrderType::ASCENDING;
3712: 	}
3713: 	if (StringUtil::Equals(value, "DESCENDING") || StringUtil::Equals(value, "DESC")) {
3714: 		return OrderType::DESCENDING;
3715: 	}
3716: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3717: }
3718: 
3719: template<>
3720: const char* EnumUtil::ToChars<OutputStream>(OutputStream value) {
3721: 	switch(value) {
3722: 	case OutputStream::STREAM_STDOUT:
3723: 		return "STREAM_STDOUT";
3724: 	case OutputStream::STREAM_STDERR:
3725: 		return "STREAM_STDERR";
3726: 	default:
3727: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3728: 	}
3729: }
3730: 
3731: template<>
3732: OutputStream EnumUtil::FromString<OutputStream>(const char *value) {
3733: 	if (StringUtil::Equals(value, "STREAM_STDOUT")) {
3734: 		return OutputStream::STREAM_STDOUT;
3735: 	}
3736: 	if (StringUtil::Equals(value, "STREAM_STDERR")) {
3737: 		return OutputStream::STREAM_STDERR;
3738: 	}
3739: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3740: }
3741: 
3742: template<>
3743: const char* EnumUtil::ToChars<ParseInfoType>(ParseInfoType value) {
3744: 	switch(value) {
3745: 	case ParseInfoType::ALTER_INFO:
3746: 		return "ALTER_INFO";
3747: 	case ParseInfoType::ATTACH_INFO:
3748: 		return "ATTACH_INFO";
3749: 	case ParseInfoType::COPY_INFO:
3750: 		return "COPY_INFO";
3751: 	case ParseInfoType::CREATE_INFO:
3752: 		return "CREATE_INFO";
3753: 	case ParseInfoType::DETACH_INFO:
3754: 		return "DETACH_INFO";
3755: 	case ParseInfoType::DROP_INFO:
3756: 		return "DROP_INFO";
3757: 	case ParseInfoType::BOUND_EXPORT_DATA:
3758: 		return "BOUND_EXPORT_DATA";
3759: 	case ParseInfoType::LOAD_INFO:
3760: 		return "LOAD_INFO";
3761: 	case ParseInfoType::PRAGMA_INFO:
3762: 		return "PRAGMA_INFO";
3763: 	case ParseInfoType::SHOW_SELECT_INFO:
3764: 		return "SHOW_SELECT_INFO";
3765: 	case ParseInfoType::TRANSACTION_INFO:
3766: 		return "TRANSACTION_INFO";
3767: 	case ParseInfoType::VACUUM_INFO:
3768: 		return "VACUUM_INFO";
3769: 	default:
3770: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3771: 	}
3772: }
3773: 
3774: template<>
3775: ParseInfoType EnumUtil::FromString<ParseInfoType>(const char *value) {
3776: 	if (StringUtil::Equals(value, "ALTER_INFO")) {
3777: 		return ParseInfoType::ALTER_INFO;
3778: 	}
3779: 	if (StringUtil::Equals(value, "ATTACH_INFO")) {
3780: 		return ParseInfoType::ATTACH_INFO;
3781: 	}
3782: 	if (StringUtil::Equals(value, "COPY_INFO")) {
3783: 		return ParseInfoType::COPY_INFO;
3784: 	}
3785: 	if (StringUtil::Equals(value, "CREATE_INFO")) {
3786: 		return ParseInfoType::CREATE_INFO;
3787: 	}
3788: 	if (StringUtil::Equals(value, "DETACH_INFO")) {
3789: 		return ParseInfoType::DETACH_INFO;
3790: 	}
3791: 	if (StringUtil::Equals(value, "DROP_INFO")) {
3792: 		return ParseInfoType::DROP_INFO;
3793: 	}
3794: 	if (StringUtil::Equals(value, "BOUND_EXPORT_DATA")) {
3795: 		return ParseInfoType::BOUND_EXPORT_DATA;
3796: 	}
3797: 	if (StringUtil::Equals(value, "LOAD_INFO")) {
3798: 		return ParseInfoType::LOAD_INFO;
3799: 	}
3800: 	if (StringUtil::Equals(value, "PRAGMA_INFO")) {
3801: 		return ParseInfoType::PRAGMA_INFO;
3802: 	}
3803: 	if (StringUtil::Equals(value, "SHOW_SELECT_INFO")) {
3804: 		return ParseInfoType::SHOW_SELECT_INFO;
3805: 	}
3806: 	if (StringUtil::Equals(value, "TRANSACTION_INFO")) {
3807: 		return ParseInfoType::TRANSACTION_INFO;
3808: 	}
3809: 	if (StringUtil::Equals(value, "VACUUM_INFO")) {
3810: 		return ParseInfoType::VACUUM_INFO;
3811: 	}
3812: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3813: }
3814: 
3815: template<>
3816: const char* EnumUtil::ToChars<ParserExtensionResultType>(ParserExtensionResultType value) {
3817: 	switch(value) {
3818: 	case ParserExtensionResultType::PARSE_SUCCESSFUL:
3819: 		return "PARSE_SUCCESSFUL";
3820: 	case ParserExtensionResultType::DISPLAY_ORIGINAL_ERROR:
3821: 		return "DISPLAY_ORIGINAL_ERROR";
3822: 	case ParserExtensionResultType::DISPLAY_EXTENSION_ERROR:
3823: 		return "DISPLAY_EXTENSION_ERROR";
3824: 	default:
3825: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3826: 	}
3827: }
3828: 
3829: template<>
3830: ParserExtensionResultType EnumUtil::FromString<ParserExtensionResultType>(const char *value) {
3831: 	if (StringUtil::Equals(value, "PARSE_SUCCESSFUL")) {
3832: 		return ParserExtensionResultType::PARSE_SUCCESSFUL;
3833: 	}
3834: 	if (StringUtil::Equals(value, "DISPLAY_ORIGINAL_ERROR")) {
3835: 		return ParserExtensionResultType::DISPLAY_ORIGINAL_ERROR;
3836: 	}
3837: 	if (StringUtil::Equals(value, "DISPLAY_EXTENSION_ERROR")) {
3838: 		return ParserExtensionResultType::DISPLAY_EXTENSION_ERROR;
3839: 	}
3840: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3841: }
3842: 
3843: template<>
3844: const char* EnumUtil::ToChars<ParserMode>(ParserMode value) {
3845: 	switch(value) {
3846: 	case ParserMode::PARSING:
3847: 		return "PARSING";
3848: 	case ParserMode::SNIFFING_DATATYPES:
3849: 		return "SNIFFING_DATATYPES";
3850: 	case ParserMode::PARSING_HEADER:
3851: 		return "PARSING_HEADER";
3852: 	default:
3853: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3854: 	}
3855: }
3856: 
3857: template<>
3858: ParserMode EnumUtil::FromString<ParserMode>(const char *value) {
3859: 	if (StringUtil::Equals(value, "PARSING")) {
3860: 		return ParserMode::PARSING;
3861: 	}
3862: 	if (StringUtil::Equals(value, "SNIFFING_DATATYPES")) {
3863: 		return ParserMode::SNIFFING_DATATYPES;
3864: 	}
3865: 	if (StringUtil::Equals(value, "PARSING_HEADER")) {
3866: 		return ParserMode::PARSING_HEADER;
3867: 	}
3868: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3869: }
3870: 
3871: template<>
3872: const char* EnumUtil::ToChars<PartitionSortStage>(PartitionSortStage value) {
3873: 	switch(value) {
3874: 	case PartitionSortStage::INIT:
3875: 		return "INIT";
3876: 	case PartitionSortStage::SCAN:
3877: 		return "SCAN";
3878: 	case PartitionSortStage::PREPARE:
3879: 		return "PREPARE";
3880: 	case PartitionSortStage::MERGE:
3881: 		return "MERGE";
3882: 	case PartitionSortStage::SORTED:
3883: 		return "SORTED";
3884: 	default:
3885: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3886: 	}
3887: }
3888: 
3889: template<>
3890: PartitionSortStage EnumUtil::FromString<PartitionSortStage>(const char *value) {
3891: 	if (StringUtil::Equals(value, "INIT")) {
3892: 		return PartitionSortStage::INIT;
3893: 	}
3894: 	if (StringUtil::Equals(value, "SCAN")) {
3895: 		return PartitionSortStage::SCAN;
3896: 	}
3897: 	if (StringUtil::Equals(value, "PREPARE")) {
3898: 		return PartitionSortStage::PREPARE;
3899: 	}
3900: 	if (StringUtil::Equals(value, "MERGE")) {
3901: 		return PartitionSortStage::MERGE;
3902: 	}
3903: 	if (StringUtil::Equals(value, "SORTED")) {
3904: 		return PartitionSortStage::SORTED;
3905: 	}
3906: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3907: }
3908: 
3909: template<>
3910: const char* EnumUtil::ToChars<PartitionedColumnDataType>(PartitionedColumnDataType value) {
3911: 	switch(value) {
3912: 	case PartitionedColumnDataType::INVALID:
3913: 		return "INVALID";
3914: 	case PartitionedColumnDataType::RADIX:
3915: 		return "RADIX";
3916: 	case PartitionedColumnDataType::HIVE:
3917: 		return "HIVE";
3918: 	default:
3919: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3920: 	}
3921: }
3922: 
3923: template<>
3924: PartitionedColumnDataType EnumUtil::FromString<PartitionedColumnDataType>(const char *value) {
3925: 	if (StringUtil::Equals(value, "INVALID")) {
3926: 		return PartitionedColumnDataType::INVALID;
3927: 	}
3928: 	if (StringUtil::Equals(value, "RADIX")) {
3929: 		return PartitionedColumnDataType::RADIX;
3930: 	}
3931: 	if (StringUtil::Equals(value, "HIVE")) {
3932: 		return PartitionedColumnDataType::HIVE;
3933: 	}
3934: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3935: }
3936: 
3937: template<>
3938: const char* EnumUtil::ToChars<PartitionedTupleDataType>(PartitionedTupleDataType value) {
3939: 	switch(value) {
3940: 	case PartitionedTupleDataType::INVALID:
3941: 		return "INVALID";
3942: 	case PartitionedTupleDataType::RADIX:
3943: 		return "RADIX";
3944: 	default:
3945: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3946: 	}
3947: }
3948: 
3949: template<>
3950: PartitionedTupleDataType EnumUtil::FromString<PartitionedTupleDataType>(const char *value) {
3951: 	if (StringUtil::Equals(value, "INVALID")) {
3952: 		return PartitionedTupleDataType::INVALID;
3953: 	}
3954: 	if (StringUtil::Equals(value, "RADIX")) {
3955: 		return PartitionedTupleDataType::RADIX;
3956: 	}
3957: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3958: }
3959: 
3960: template<>
3961: const char* EnumUtil::ToChars<PendingExecutionResult>(PendingExecutionResult value) {
3962: 	switch(value) {
3963: 	case PendingExecutionResult::RESULT_READY:
3964: 		return "RESULT_READY";
3965: 	case PendingExecutionResult::RESULT_NOT_READY:
3966: 		return "RESULT_NOT_READY";
3967: 	case PendingExecutionResult::EXECUTION_ERROR:
3968: 		return "EXECUTION_ERROR";
3969: 	case PendingExecutionResult::NO_TASKS_AVAILABLE:
3970: 		return "NO_TASKS_AVAILABLE";
3971: 	default:
3972: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3973: 	}
3974: }
3975: 
3976: template<>
3977: PendingExecutionResult EnumUtil::FromString<PendingExecutionResult>(const char *value) {
3978: 	if (StringUtil::Equals(value, "RESULT_READY")) {
3979: 		return PendingExecutionResult::RESULT_READY;
3980: 	}
3981: 	if (StringUtil::Equals(value, "RESULT_NOT_READY")) {
3982: 		return PendingExecutionResult::RESULT_NOT_READY;
3983: 	}
3984: 	if (StringUtil::Equals(value, "EXECUTION_ERROR")) {
3985: 		return PendingExecutionResult::EXECUTION_ERROR;
3986: 	}
3987: 	if (StringUtil::Equals(value, "NO_TASKS_AVAILABLE")) {
3988: 		return PendingExecutionResult::NO_TASKS_AVAILABLE;
3989: 	}
3990: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3991: }
3992: 
3993: template<>
3994: const char* EnumUtil::ToChars<PhysicalOperatorType>(PhysicalOperatorType value) {
3995: 	switch(value) {
3996: 	case PhysicalOperatorType::INVALID:
3997: 		return "INVALID";
3998: 	case PhysicalOperatorType::ORDER_BY:
3999: 		return "ORDER_BY";
4000: 	case PhysicalOperatorType::LIMIT:
4001: 		return "LIMIT";
4002: 	case PhysicalOperatorType::STREAMING_LIMIT:
4003: 		return "STREAMING_LIMIT";
4004: 	case PhysicalOperatorType::LIMIT_PERCENT:
4005: 		return "LIMIT_PERCENT";
4006: 	case PhysicalOperatorType::TOP_N:
4007: 		return "TOP_N";
4008: 	case PhysicalOperatorType::WINDOW:
4009: 		return "WINDOW";
4010: 	case PhysicalOperatorType::UNNEST:
4011: 		return "UNNEST";
4012: 	case PhysicalOperatorType::UNGROUPED_AGGREGATE:
4013: 		return "UNGROUPED_AGGREGATE";
4014: 	case PhysicalOperatorType::HASH_GROUP_BY:
4015: 		return "HASH_GROUP_BY";
4016: 	case PhysicalOperatorType::PERFECT_HASH_GROUP_BY:
4017: 		return "PERFECT_HASH_GROUP_BY";
4018: 	case PhysicalOperatorType::FILTER:
4019: 		return "FILTER";
4020: 	case PhysicalOperatorType::PROJECTION:
4021: 		return "PROJECTION";
4022: 	case PhysicalOperatorType::COPY_TO_FILE:
4023: 		return "COPY_TO_FILE";
4024: 	case PhysicalOperatorType::BATCH_COPY_TO_FILE:
4025: 		return "BATCH_COPY_TO_FILE";
4026: 	case PhysicalOperatorType::FIXED_BATCH_COPY_TO_FILE:
4027: 		return "FIXED_BATCH_COPY_TO_FILE";
4028: 	case PhysicalOperatorType::RESERVOIR_SAMPLE:
4029: 		return "RESERVOIR_SAMPLE";
4030: 	case PhysicalOperatorType::STREAMING_SAMPLE:
4031: 		return "STREAMING_SAMPLE";
4032: 	case PhysicalOperatorType::STREAMING_WINDOW:
4033: 		return "STREAMING_WINDOW";
4034: 	case PhysicalOperatorType::PIVOT:
4035: 		return "PIVOT";
4036: 	case PhysicalOperatorType::TABLE_SCAN:
4037: 		return "TABLE_SCAN";
4038: 	case PhysicalOperatorType::DUMMY_SCAN:
4039: 		return "DUMMY_SCAN";
4040: 	case PhysicalOperatorType::COLUMN_DATA_SCAN:
4041: 		return "COLUMN_DATA_SCAN";
4042: 	case PhysicalOperatorType::CHUNK_SCAN:
4043: 		return "CHUNK_SCAN";
4044: 	case PhysicalOperatorType::RECURSIVE_CTE_SCAN:
4045: 		return "RECURSIVE_CTE_SCAN";
4046: 	case PhysicalOperatorType::CTE_SCAN:
4047: 		return "CTE_SCAN";
4048: 	case PhysicalOperatorType::DELIM_SCAN:
4049: 		return "DELIM_SCAN";
4050: 	case PhysicalOperatorType::EXPRESSION_SCAN:
4051: 		return "EXPRESSION_SCAN";
4052: 	case PhysicalOperatorType::POSITIONAL_SCAN:
4053: 		return "POSITIONAL_SCAN";
4054: 	case PhysicalOperatorType::BLOCKWISE_NL_JOIN:
4055: 		return "BLOCKWISE_NL_JOIN";
4056: 	case PhysicalOperatorType::NESTED_LOOP_JOIN:
4057: 		return "NESTED_LOOP_JOIN";
4058: 	case PhysicalOperatorType::HASH_JOIN:
4059: 		return "HASH_JOIN";
4060: 	case PhysicalOperatorType::CROSS_PRODUCT:
4061: 		return "CROSS_PRODUCT";
4062: 	case PhysicalOperatorType::PIECEWISE_MERGE_JOIN:
4063: 		return "PIECEWISE_MERGE_JOIN";
4064: 	case PhysicalOperatorType::IE_JOIN:
4065: 		return "IE_JOIN";
4066: 	case PhysicalOperatorType::DELIM_JOIN:
4067: 		return "DELIM_JOIN";
4068: 	case PhysicalOperatorType::INDEX_JOIN:
4069: 		return "INDEX_JOIN";
4070: 	case PhysicalOperatorType::POSITIONAL_JOIN:
4071: 		return "POSITIONAL_JOIN";
4072: 	case PhysicalOperatorType::ASOF_JOIN:
4073: 		return "ASOF_JOIN";
4074: 	case PhysicalOperatorType::UNION:
4075: 		return "UNION";
4076: 	case PhysicalOperatorType::RECURSIVE_CTE:
4077: 		return "RECURSIVE_CTE";
4078: 	case PhysicalOperatorType::CTE:
4079: 		return "CTE";
4080: 	case PhysicalOperatorType::INSERT:
4081: 		return "INSERT";
4082: 	case PhysicalOperatorType::BATCH_INSERT:
4083: 		return "BATCH_INSERT";
4084: 	case PhysicalOperatorType::DELETE_OPERATOR:
4085: 		return "DELETE_OPERATOR";
4086: 	case PhysicalOperatorType::UPDATE:
4087: 		return "UPDATE";
4088: 	case PhysicalOperatorType::CREATE_TABLE:
4089: 		return "CREATE_TABLE";
4090: 	case PhysicalOperatorType::CREATE_TABLE_AS:
4091: 		return "CREATE_TABLE_AS";
4092: 	case PhysicalOperatorType::BATCH_CREATE_TABLE_AS:
4093: 		return "BATCH_CREATE_TABLE_AS";
4094: 	case PhysicalOperatorType::CREATE_INDEX:
4095: 		return "CREATE_INDEX";
4096: 	case PhysicalOperatorType::ALTER:
4097: 		return "ALTER";
4098: 	case PhysicalOperatorType::CREATE_SEQUENCE:
4099: 		return "CREATE_SEQUENCE";
4100: 	case PhysicalOperatorType::CREATE_VIEW:
4101: 		return "CREATE_VIEW";
4102: 	case PhysicalOperatorType::CREATE_SCHEMA:
4103: 		return "CREATE_SCHEMA";
4104: 	case PhysicalOperatorType::CREATE_MACRO:
4105: 		return "CREATE_MACRO";
4106: 	case PhysicalOperatorType::DROP:
4107: 		return "DROP";
4108: 	case PhysicalOperatorType::PRAGMA:
4109: 		return "PRAGMA";
4110: 	case PhysicalOperatorType::TRANSACTION:
4111: 		return "TRANSACTION";
4112: 	case PhysicalOperatorType::CREATE_TYPE:
4113: 		return "CREATE_TYPE";
4114: 	case PhysicalOperatorType::ATTACH:
4115: 		return "ATTACH";
4116: 	case PhysicalOperatorType::DETACH:
4117: 		return "DETACH";
4118: 	case PhysicalOperatorType::EXPLAIN:
4119: 		return "EXPLAIN";
4120: 	case PhysicalOperatorType::EXPLAIN_ANALYZE:
4121: 		return "EXPLAIN_ANALYZE";
4122: 	case PhysicalOperatorType::EMPTY_RESULT:
4123: 		return "EMPTY_RESULT";
4124: 	case PhysicalOperatorType::EXECUTE:
4125: 		return "EXECUTE";
4126: 	case PhysicalOperatorType::PREPARE:
4127: 		return "PREPARE";
4128: 	case PhysicalOperatorType::VACUUM:
4129: 		return "VACUUM";
4130: 	case PhysicalOperatorType::EXPORT:
4131: 		return "EXPORT";
4132: 	case PhysicalOperatorType::SET:
4133: 		return "SET";
4134: 	case PhysicalOperatorType::LOAD:
4135: 		return "LOAD";
4136: 	case PhysicalOperatorType::INOUT_FUNCTION:
4137: 		return "INOUT_FUNCTION";
4138: 	case PhysicalOperatorType::RESULT_COLLECTOR:
4139: 		return "RESULT_COLLECTOR";
4140: 	case PhysicalOperatorType::RESET:
4141: 		return "RESET";
4142: 	case PhysicalOperatorType::EXTENSION:
4143: 		return "EXTENSION";
4144: 	default:
4145: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4146: 	}
4147: }
4148: 
4149: template<>
4150: PhysicalOperatorType EnumUtil::FromString<PhysicalOperatorType>(const char *value) {
4151: 	if (StringUtil::Equals(value, "INVALID")) {
4152: 		return PhysicalOperatorType::INVALID;
4153: 	}
4154: 	if (StringUtil::Equals(value, "ORDER_BY")) {
4155: 		return PhysicalOperatorType::ORDER_BY;
4156: 	}
4157: 	if (StringUtil::Equals(value, "LIMIT")) {
4158: 		return PhysicalOperatorType::LIMIT;
4159: 	}
4160: 	if (StringUtil::Equals(value, "STREAMING_LIMIT")) {
4161: 		return PhysicalOperatorType::STREAMING_LIMIT;
4162: 	}
4163: 	if (StringUtil::Equals(value, "LIMIT_PERCENT")) {
4164: 		return PhysicalOperatorType::LIMIT_PERCENT;
4165: 	}
4166: 	if (StringUtil::Equals(value, "TOP_N")) {
4167: 		return PhysicalOperatorType::TOP_N;
4168: 	}
4169: 	if (StringUtil::Equals(value, "WINDOW")) {
4170: 		return PhysicalOperatorType::WINDOW;
4171: 	}
4172: 	if (StringUtil::Equals(value, "UNNEST")) {
4173: 		return PhysicalOperatorType::UNNEST;
4174: 	}
4175: 	if (StringUtil::Equals(value, "UNGROUPED_AGGREGATE")) {
4176: 		return PhysicalOperatorType::UNGROUPED_AGGREGATE;
4177: 	}
4178: 	if (StringUtil::Equals(value, "HASH_GROUP_BY")) {
4179: 		return PhysicalOperatorType::HASH_GROUP_BY;
4180: 	}
4181: 	if (StringUtil::Equals(value, "PERFECT_HASH_GROUP_BY")) {
4182: 		return PhysicalOperatorType::PERFECT_HASH_GROUP_BY;
4183: 	}
4184: 	if (StringUtil::Equals(value, "FILTER")) {
4185: 		return PhysicalOperatorType::FILTER;
4186: 	}
4187: 	if (StringUtil::Equals(value, "PROJECTION")) {
4188: 		return PhysicalOperatorType::PROJECTION;
4189: 	}
4190: 	if (StringUtil::Equals(value, "COPY_TO_FILE")) {
4191: 		return PhysicalOperatorType::COPY_TO_FILE;
4192: 	}
4193: 	if (StringUtil::Equals(value, "BATCH_COPY_TO_FILE")) {
4194: 		return PhysicalOperatorType::BATCH_COPY_TO_FILE;
4195: 	}
4196: 	if (StringUtil::Equals(value, "FIXED_BATCH_COPY_TO_FILE")) {
4197: 		return PhysicalOperatorType::FIXED_BATCH_COPY_TO_FILE;
4198: 	}
4199: 	if (StringUtil::Equals(value, "RESERVOIR_SAMPLE")) {
4200: 		return PhysicalOperatorType::RESERVOIR_SAMPLE;
4201: 	}
4202: 	if (StringUtil::Equals(value, "STREAMING_SAMPLE")) {
4203: 		return PhysicalOperatorType::STREAMING_SAMPLE;
4204: 	}
4205: 	if (StringUtil::Equals(value, "STREAMING_WINDOW")) {
4206: 		return PhysicalOperatorType::STREAMING_WINDOW;
4207: 	}
4208: 	if (StringUtil::Equals(value, "PIVOT")) {
4209: 		return PhysicalOperatorType::PIVOT;
4210: 	}
4211: 	if (StringUtil::Equals(value, "TABLE_SCAN")) {
4212: 		return PhysicalOperatorType::TABLE_SCAN;
4213: 	}
4214: 	if (StringUtil::Equals(value, "DUMMY_SCAN")) {
4215: 		return PhysicalOperatorType::DUMMY_SCAN;
4216: 	}
4217: 	if (StringUtil::Equals(value, "COLUMN_DATA_SCAN")) {
4218: 		return PhysicalOperatorType::COLUMN_DATA_SCAN;
4219: 	}
4220: 	if (StringUtil::Equals(value, "CHUNK_SCAN")) {
4221: 		return PhysicalOperatorType::CHUNK_SCAN;
4222: 	}
4223: 	if (StringUtil::Equals(value, "RECURSIVE_CTE_SCAN")) {
4224: 		return PhysicalOperatorType::RECURSIVE_CTE_SCAN;
4225: 	}
4226: 	if (StringUtil::Equals(value, "CTE_SCAN")) {
4227: 		return PhysicalOperatorType::CTE_SCAN;
4228: 	}
4229: 	if (StringUtil::Equals(value, "DELIM_SCAN")) {
4230: 		return PhysicalOperatorType::DELIM_SCAN;
4231: 	}
4232: 	if (StringUtil::Equals(value, "EXPRESSION_SCAN")) {
4233: 		return PhysicalOperatorType::EXPRESSION_SCAN;
4234: 	}
4235: 	if (StringUtil::Equals(value, "POSITIONAL_SCAN")) {
4236: 		return PhysicalOperatorType::POSITIONAL_SCAN;
4237: 	}
4238: 	if (StringUtil::Equals(value, "BLOCKWISE_NL_JOIN")) {
4239: 		return PhysicalOperatorType::BLOCKWISE_NL_JOIN;
4240: 	}
4241: 	if (StringUtil::Equals(value, "NESTED_LOOP_JOIN")) {
4242: 		return PhysicalOperatorType::NESTED_LOOP_JOIN;
4243: 	}
4244: 	if (StringUtil::Equals(value, "HASH_JOIN")) {
4245: 		return PhysicalOperatorType::HASH_JOIN;
4246: 	}
4247: 	if (StringUtil::Equals(value, "CROSS_PRODUCT")) {
4248: 		return PhysicalOperatorType::CROSS_PRODUCT;
4249: 	}
4250: 	if (StringUtil::Equals(value, "PIECEWISE_MERGE_JOIN")) {
4251: 		return PhysicalOperatorType::PIECEWISE_MERGE_JOIN;
4252: 	}
4253: 	if (StringUtil::Equals(value, "IE_JOIN")) {
4254: 		return PhysicalOperatorType::IE_JOIN;
4255: 	}
4256: 	if (StringUtil::Equals(value, "DELIM_JOIN")) {
4257: 		return PhysicalOperatorType::DELIM_JOIN;
4258: 	}
4259: 	if (StringUtil::Equals(value, "INDEX_JOIN")) {
4260: 		return PhysicalOperatorType::INDEX_JOIN;
4261: 	}
4262: 	if (StringUtil::Equals(value, "POSITIONAL_JOIN")) {
4263: 		return PhysicalOperatorType::POSITIONAL_JOIN;
4264: 	}
4265: 	if (StringUtil::Equals(value, "ASOF_JOIN")) {
4266: 		return PhysicalOperatorType::ASOF_JOIN;
4267: 	}
4268: 	if (StringUtil::Equals(value, "UNION")) {
4269: 		return PhysicalOperatorType::UNION;
4270: 	}
4271: 	if (StringUtil::Equals(value, "RECURSIVE_CTE")) {
4272: 		return PhysicalOperatorType::RECURSIVE_CTE;
4273: 	}
4274: 	if (StringUtil::Equals(value, "CTE")) {
4275: 		return PhysicalOperatorType::CTE;
4276: 	}
4277: 	if (StringUtil::Equals(value, "INSERT")) {
4278: 		return PhysicalOperatorType::INSERT;
4279: 	}
4280: 	if (StringUtil::Equals(value, "BATCH_INSERT")) {
4281: 		return PhysicalOperatorType::BATCH_INSERT;
4282: 	}
4283: 	if (StringUtil::Equals(value, "DELETE_OPERATOR")) {
4284: 		return PhysicalOperatorType::DELETE_OPERATOR;
4285: 	}
4286: 	if (StringUtil::Equals(value, "UPDATE")) {
4287: 		return PhysicalOperatorType::UPDATE;
4288: 	}
4289: 	if (StringUtil::Equals(value, "CREATE_TABLE")) {
4290: 		return PhysicalOperatorType::CREATE_TABLE;
4291: 	}
4292: 	if (StringUtil::Equals(value, "CREATE_TABLE_AS")) {
4293: 		return PhysicalOperatorType::CREATE_TABLE_AS;
4294: 	}
4295: 	if (StringUtil::Equals(value, "BATCH_CREATE_TABLE_AS")) {
4296: 		return PhysicalOperatorType::BATCH_CREATE_TABLE_AS;
4297: 	}
4298: 	if (StringUtil::Equals(value, "CREATE_INDEX")) {
4299: 		return PhysicalOperatorType::CREATE_INDEX;
4300: 	}
4301: 	if (StringUtil::Equals(value, "ALTER")) {
4302: 		return PhysicalOperatorType::ALTER;
4303: 	}
4304: 	if (StringUtil::Equals(value, "CREATE_SEQUENCE")) {
4305: 		return PhysicalOperatorType::CREATE_SEQUENCE;
4306: 	}
4307: 	if (StringUtil::Equals(value, "CREATE_VIEW")) {
4308: 		return PhysicalOperatorType::CREATE_VIEW;
4309: 	}
4310: 	if (StringUtil::Equals(value, "CREATE_SCHEMA")) {
4311: 		return PhysicalOperatorType::CREATE_SCHEMA;
4312: 	}
4313: 	if (StringUtil::Equals(value, "CREATE_MACRO")) {
4314: 		return PhysicalOperatorType::CREATE_MACRO;
4315: 	}
4316: 	if (StringUtil::Equals(value, "DROP")) {
4317: 		return PhysicalOperatorType::DROP;
4318: 	}
4319: 	if (StringUtil::Equals(value, "PRAGMA")) {
4320: 		return PhysicalOperatorType::PRAGMA;
4321: 	}
4322: 	if (StringUtil::Equals(value, "TRANSACTION")) {
4323: 		return PhysicalOperatorType::TRANSACTION;
4324: 	}
4325: 	if (StringUtil::Equals(value, "CREATE_TYPE")) {
4326: 		return PhysicalOperatorType::CREATE_TYPE;
4327: 	}
4328: 	if (StringUtil::Equals(value, "ATTACH")) {
4329: 		return PhysicalOperatorType::ATTACH;
4330: 	}
4331: 	if (StringUtil::Equals(value, "DETACH")) {
4332: 		return PhysicalOperatorType::DETACH;
4333: 	}
4334: 	if (StringUtil::Equals(value, "EXPLAIN")) {
4335: 		return PhysicalOperatorType::EXPLAIN;
4336: 	}
4337: 	if (StringUtil::Equals(value, "EXPLAIN_ANALYZE")) {
4338: 		return PhysicalOperatorType::EXPLAIN_ANALYZE;
4339: 	}
4340: 	if (StringUtil::Equals(value, "EMPTY_RESULT")) {
4341: 		return PhysicalOperatorType::EMPTY_RESULT;
4342: 	}
4343: 	if (StringUtil::Equals(value, "EXECUTE")) {
4344: 		return PhysicalOperatorType::EXECUTE;
4345: 	}
4346: 	if (StringUtil::Equals(value, "PREPARE")) {
4347: 		return PhysicalOperatorType::PREPARE;
4348: 	}
4349: 	if (StringUtil::Equals(value, "VACUUM")) {
4350: 		return PhysicalOperatorType::VACUUM;
4351: 	}
4352: 	if (StringUtil::Equals(value, "EXPORT")) {
4353: 		return PhysicalOperatorType::EXPORT;
4354: 	}
4355: 	if (StringUtil::Equals(value, "SET")) {
4356: 		return PhysicalOperatorType::SET;
4357: 	}
4358: 	if (StringUtil::Equals(value, "LOAD")) {
4359: 		return PhysicalOperatorType::LOAD;
4360: 	}
4361: 	if (StringUtil::Equals(value, "INOUT_FUNCTION")) {
4362: 		return PhysicalOperatorType::INOUT_FUNCTION;
4363: 	}
4364: 	if (StringUtil::Equals(value, "RESULT_COLLECTOR")) {
4365: 		return PhysicalOperatorType::RESULT_COLLECTOR;
4366: 	}
4367: 	if (StringUtil::Equals(value, "RESET")) {
4368: 		return PhysicalOperatorType::RESET;
4369: 	}
4370: 	if (StringUtil::Equals(value, "EXTENSION")) {
4371: 		return PhysicalOperatorType::EXTENSION;
4372: 	}
4373: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4374: }
4375: 
4376: template<>
4377: const char* EnumUtil::ToChars<PhysicalType>(PhysicalType value) {
4378: 	switch(value) {
4379: 	case PhysicalType::BOOL:
4380: 		return "BOOL";
4381: 	case PhysicalType::UINT8:
4382: 		return "UINT8";
4383: 	case PhysicalType::INT8:
4384: 		return "INT8";
4385: 	case PhysicalType::UINT16:
4386: 		return "UINT16";
4387: 	case PhysicalType::INT16:
4388: 		return "INT16";
4389: 	case PhysicalType::UINT32:
4390: 		return "UINT32";
4391: 	case PhysicalType::INT32:
4392: 		return "INT32";
4393: 	case PhysicalType::UINT64:
4394: 		return "UINT64";
4395: 	case PhysicalType::INT64:
4396: 		return "INT64";
4397: 	case PhysicalType::FLOAT:
4398: 		return "FLOAT";
4399: 	case PhysicalType::DOUBLE:
4400: 		return "DOUBLE";
4401: 	case PhysicalType::INTERVAL:
4402: 		return "INTERVAL";
4403: 	case PhysicalType::LIST:
4404: 		return "LIST";
4405: 	case PhysicalType::STRUCT:
4406: 		return "STRUCT";
4407: 	case PhysicalType::VARCHAR:
4408: 		return "VARCHAR";
4409: 	case PhysicalType::INT128:
4410: 		return "INT128";
4411: 	case PhysicalType::UNKNOWN:
4412: 		return "UNKNOWN";
4413: 	case PhysicalType::BIT:
4414: 		return "BIT";
4415: 	case PhysicalType::INVALID:
4416: 		return "INVALID";
4417: 	default:
4418: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4419: 	}
4420: }
4421: 
4422: template<>
4423: PhysicalType EnumUtil::FromString<PhysicalType>(const char *value) {
4424: 	if (StringUtil::Equals(value, "BOOL")) {
4425: 		return PhysicalType::BOOL;
4426: 	}
4427: 	if (StringUtil::Equals(value, "UINT8")) {
4428: 		return PhysicalType::UINT8;
4429: 	}
4430: 	if (StringUtil::Equals(value, "INT8")) {
4431: 		return PhysicalType::INT8;
4432: 	}
4433: 	if (StringUtil::Equals(value, "UINT16")) {
4434: 		return PhysicalType::UINT16;
4435: 	}
4436: 	if (StringUtil::Equals(value, "INT16")) {
4437: 		return PhysicalType::INT16;
4438: 	}
4439: 	if (StringUtil::Equals(value, "UINT32")) {
4440: 		return PhysicalType::UINT32;
4441: 	}
4442: 	if (StringUtil::Equals(value, "INT32")) {
4443: 		return PhysicalType::INT32;
4444: 	}
4445: 	if (StringUtil::Equals(value, "UINT64")) {
4446: 		return PhysicalType::UINT64;
4447: 	}
4448: 	if (StringUtil::Equals(value, "INT64")) {
4449: 		return PhysicalType::INT64;
4450: 	}
4451: 	if (StringUtil::Equals(value, "FLOAT")) {
4452: 		return PhysicalType::FLOAT;
4453: 	}
4454: 	if (StringUtil::Equals(value, "DOUBLE")) {
4455: 		return PhysicalType::DOUBLE;
4456: 	}
4457: 	if (StringUtil::Equals(value, "INTERVAL")) {
4458: 		return PhysicalType::INTERVAL;
4459: 	}
4460: 	if (StringUtil::Equals(value, "LIST")) {
4461: 		return PhysicalType::LIST;
4462: 	}
4463: 	if (StringUtil::Equals(value, "STRUCT")) {
4464: 		return PhysicalType::STRUCT;
4465: 	}
4466: 	if (StringUtil::Equals(value, "VARCHAR")) {
4467: 		return PhysicalType::VARCHAR;
4468: 	}
4469: 	if (StringUtil::Equals(value, "INT128")) {
4470: 		return PhysicalType::INT128;
4471: 	}
4472: 	if (StringUtil::Equals(value, "UNKNOWN")) {
4473: 		return PhysicalType::UNKNOWN;
4474: 	}
4475: 	if (StringUtil::Equals(value, "BIT")) {
4476: 		return PhysicalType::BIT;
4477: 	}
4478: 	if (StringUtil::Equals(value, "INVALID")) {
4479: 		return PhysicalType::INVALID;
4480: 	}
4481: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4482: }
4483: 
4484: template<>
4485: const char* EnumUtil::ToChars<PragmaType>(PragmaType value) {
4486: 	switch(value) {
4487: 	case PragmaType::PRAGMA_STATEMENT:
4488: 		return "PRAGMA_STATEMENT";
4489: 	case PragmaType::PRAGMA_CALL:
4490: 		return "PRAGMA_CALL";
4491: 	default:
4492: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4493: 	}
4494: }
4495: 
4496: template<>
4497: PragmaType EnumUtil::FromString<PragmaType>(const char *value) {
4498: 	if (StringUtil::Equals(value, "PRAGMA_STATEMENT")) {
4499: 		return PragmaType::PRAGMA_STATEMENT;
4500: 	}
4501: 	if (StringUtil::Equals(value, "PRAGMA_CALL")) {
4502: 		return PragmaType::PRAGMA_CALL;
4503: 	}
4504: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4505: }
4506: 
4507: template<>
4508: const char* EnumUtil::ToChars<PreparedParamType>(PreparedParamType value) {
4509: 	switch(value) {
4510: 	case PreparedParamType::AUTO_INCREMENT:
4511: 		return "AUTO_INCREMENT";
4512: 	case PreparedParamType::POSITIONAL:
4513: 		return "POSITIONAL";
4514: 	case PreparedParamType::NAMED:
4515: 		return "NAMED";
4516: 	case PreparedParamType::INVALID:
4517: 		return "INVALID";
4518: 	default:
4519: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4520: 	}
4521: }
4522: 
4523: template<>
4524: PreparedParamType EnumUtil::FromString<PreparedParamType>(const char *value) {
4525: 	if (StringUtil::Equals(value, "AUTO_INCREMENT")) {
4526: 		return PreparedParamType::AUTO_INCREMENT;
4527: 	}
4528: 	if (StringUtil::Equals(value, "POSITIONAL")) {
4529: 		return PreparedParamType::POSITIONAL;
4530: 	}
4531: 	if (StringUtil::Equals(value, "NAMED")) {
4532: 		return PreparedParamType::NAMED;
4533: 	}
4534: 	if (StringUtil::Equals(value, "INVALID")) {
4535: 		return PreparedParamType::INVALID;
4536: 	}
4537: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4538: }
4539: 
4540: template<>
4541: const char* EnumUtil::ToChars<ProfilerPrintFormat>(ProfilerPrintFormat value) {
4542: 	switch(value) {
4543: 	case ProfilerPrintFormat::QUERY_TREE:
4544: 		return "QUERY_TREE";
4545: 	case ProfilerPrintFormat::JSON:
4546: 		return "JSON";
4547: 	case ProfilerPrintFormat::QUERY_TREE_OPTIMIZER:
4548: 		return "QUERY_TREE_OPTIMIZER";
4549: 	default:
4550: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4551: 	}
4552: }
4553: 
4554: template<>
4555: ProfilerPrintFormat EnumUtil::FromString<ProfilerPrintFormat>(const char *value) {
4556: 	if (StringUtil::Equals(value, "QUERY_TREE")) {
4557: 		return ProfilerPrintFormat::QUERY_TREE;
4558: 	}
4559: 	if (StringUtil::Equals(value, "JSON")) {
4560: 		return ProfilerPrintFormat::JSON;
4561: 	}
4562: 	if (StringUtil::Equals(value, "QUERY_TREE_OPTIMIZER")) {
4563: 		return ProfilerPrintFormat::QUERY_TREE_OPTIMIZER;
4564: 	}
4565: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4566: }
4567: 
4568: template<>
4569: const char* EnumUtil::ToChars<QueryNodeType>(QueryNodeType value) {
4570: 	switch(value) {
4571: 	case QueryNodeType::SELECT_NODE:
4572: 		return "SELECT_NODE";
4573: 	case QueryNodeType::SET_OPERATION_NODE:
4574: 		return "SET_OPERATION_NODE";
4575: 	case QueryNodeType::BOUND_SUBQUERY_NODE:
4576: 		return "BOUND_SUBQUERY_NODE";
4577: 	case QueryNodeType::RECURSIVE_CTE_NODE:
4578: 		return "RECURSIVE_CTE_NODE";
4579: 	case QueryNodeType::CTE_NODE:
4580: 		return "CTE_NODE";
4581: 	default:
4582: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4583: 	}
4584: }
4585: 
4586: template<>
4587: QueryNodeType EnumUtil::FromString<QueryNodeType>(const char *value) {
4588: 	if (StringUtil::Equals(value, "SELECT_NODE")) {
4589: 		return QueryNodeType::SELECT_NODE;
4590: 	}
4591: 	if (StringUtil::Equals(value, "SET_OPERATION_NODE")) {
4592: 		return QueryNodeType::SET_OPERATION_NODE;
4593: 	}
4594: 	if (StringUtil::Equals(value, "BOUND_SUBQUERY_NODE")) {
4595: 		return QueryNodeType::BOUND_SUBQUERY_NODE;
4596: 	}
4597: 	if (StringUtil::Equals(value, "RECURSIVE_CTE_NODE")) {
4598: 		return QueryNodeType::RECURSIVE_CTE_NODE;
4599: 	}
4600: 	if (StringUtil::Equals(value, "CTE_NODE")) {
4601: 		return QueryNodeType::CTE_NODE;
4602: 	}
4603: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4604: }
4605: 
4606: template<>
4607: const char* EnumUtil::ToChars<QueryResultType>(QueryResultType value) {
4608: 	switch(value) {
4609: 	case QueryResultType::MATERIALIZED_RESULT:
4610: 		return "MATERIALIZED_RESULT";
4611: 	case QueryResultType::STREAM_RESULT:
4612: 		return "STREAM_RESULT";
4613: 	case QueryResultType::PENDING_RESULT:
4614: 		return "PENDING_RESULT";
4615: 	default:
4616: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4617: 	}
4618: }
4619: 
4620: template<>
4621: QueryResultType EnumUtil::FromString<QueryResultType>(const char *value) {
4622: 	if (StringUtil::Equals(value, "MATERIALIZED_RESULT")) {
4623: 		return QueryResultType::MATERIALIZED_RESULT;
4624: 	}
4625: 	if (StringUtil::Equals(value, "STREAM_RESULT")) {
4626: 		return QueryResultType::STREAM_RESULT;
4627: 	}
4628: 	if (StringUtil::Equals(value, "PENDING_RESULT")) {
4629: 		return QueryResultType::PENDING_RESULT;
4630: 	}
4631: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4632: }
4633: 
4634: template<>
4635: const char* EnumUtil::ToChars<QuoteRule>(QuoteRule value) {
4636: 	switch(value) {
4637: 	case QuoteRule::QUOTES_RFC:
4638: 		return "QUOTES_RFC";
4639: 	case QuoteRule::QUOTES_OTHER:
4640: 		return "QUOTES_OTHER";
4641: 	case QuoteRule::NO_QUOTES:
4642: 		return "NO_QUOTES";
4643: 	default:
4644: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4645: 	}
4646: }
4647: 
4648: template<>
4649: QuoteRule EnumUtil::FromString<QuoteRule>(const char *value) {
4650: 	if (StringUtil::Equals(value, "QUOTES_RFC")) {
4651: 		return QuoteRule::QUOTES_RFC;
4652: 	}
4653: 	if (StringUtil::Equals(value, "QUOTES_OTHER")) {
4654: 		return QuoteRule::QUOTES_OTHER;
4655: 	}
4656: 	if (StringUtil::Equals(value, "NO_QUOTES")) {
4657: 		return QuoteRule::NO_QUOTES;
4658: 	}
4659: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4660: }
4661: 
4662: template<>
4663: const char* EnumUtil::ToChars<RelationType>(RelationType value) {
4664: 	switch(value) {
4665: 	case RelationType::INVALID_RELATION:
4666: 		return "INVALID_RELATION";
4667: 	case RelationType::TABLE_RELATION:
4668: 		return "TABLE_RELATION";
4669: 	case RelationType::PROJECTION_RELATION:
4670: 		return "PROJECTION_RELATION";
4671: 	case RelationType::FILTER_RELATION:
4672: 		return "FILTER_RELATION";
4673: 	case RelationType::EXPLAIN_RELATION:
4674: 		return "EXPLAIN_RELATION";
4675: 	case RelationType::CROSS_PRODUCT_RELATION:
4676: 		return "CROSS_PRODUCT_RELATION";
4677: 	case RelationType::JOIN_RELATION:
4678: 		return "JOIN_RELATION";
4679: 	case RelationType::AGGREGATE_RELATION:
4680: 		return "AGGREGATE_RELATION";
4681: 	case RelationType::SET_OPERATION_RELATION:
4682: 		return "SET_OPERATION_RELATION";
4683: 	case RelationType::DISTINCT_RELATION:
4684: 		return "DISTINCT_RELATION";
4685: 	case RelationType::LIMIT_RELATION:
4686: 		return "LIMIT_RELATION";
4687: 	case RelationType::ORDER_RELATION:
4688: 		return "ORDER_RELATION";
4689: 	case RelationType::CREATE_VIEW_RELATION:
4690: 		return "CREATE_VIEW_RELATION";
4691: 	case RelationType::CREATE_TABLE_RELATION:
4692: 		return "CREATE_TABLE_RELATION";
4693: 	case RelationType::INSERT_RELATION:
4694: 		return "INSERT_RELATION";
4695: 	case RelationType::VALUE_LIST_RELATION:
4696: 		return "VALUE_LIST_RELATION";
4697: 	case RelationType::DELETE_RELATION:
4698: 		return "DELETE_RELATION";
4699: 	case RelationType::UPDATE_RELATION:
4700: 		return "UPDATE_RELATION";
4701: 	case RelationType::WRITE_CSV_RELATION:
4702: 		return "WRITE_CSV_RELATION";
4703: 	case RelationType::WRITE_PARQUET_RELATION:
4704: 		return "WRITE_PARQUET_RELATION";
4705: 	case RelationType::READ_CSV_RELATION:
4706: 		return "READ_CSV_RELATION";
4707: 	case RelationType::SUBQUERY_RELATION:
4708: 		return "SUBQUERY_RELATION";
4709: 	case RelationType::TABLE_FUNCTION_RELATION:
4710: 		return "TABLE_FUNCTION_RELATION";
4711: 	case RelationType::VIEW_RELATION:
4712: 		return "VIEW_RELATION";
4713: 	case RelationType::QUERY_RELATION:
4714: 		return "QUERY_RELATION";
4715: 	default:
4716: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4717: 	}
4718: }
4719: 
4720: template<>
4721: RelationType EnumUtil::FromString<RelationType>(const char *value) {
4722: 	if (StringUtil::Equals(value, "INVALID_RELATION")) {
4723: 		return RelationType::INVALID_RELATION;
4724: 	}
4725: 	if (StringUtil::Equals(value, "TABLE_RELATION")) {
4726: 		return RelationType::TABLE_RELATION;
4727: 	}
4728: 	if (StringUtil::Equals(value, "PROJECTION_RELATION")) {
4729: 		return RelationType::PROJECTION_RELATION;
4730: 	}
4731: 	if (StringUtil::Equals(value, "FILTER_RELATION")) {
4732: 		return RelationType::FILTER_RELATION;
4733: 	}
4734: 	if (StringUtil::Equals(value, "EXPLAIN_RELATION")) {
4735: 		return RelationType::EXPLAIN_RELATION;
4736: 	}
4737: 	if (StringUtil::Equals(value, "CROSS_PRODUCT_RELATION")) {
4738: 		return RelationType::CROSS_PRODUCT_RELATION;
4739: 	}
4740: 	if (StringUtil::Equals(value, "JOIN_RELATION")) {
4741: 		return RelationType::JOIN_RELATION;
4742: 	}
4743: 	if (StringUtil::Equals(value, "AGGREGATE_RELATION")) {
4744: 		return RelationType::AGGREGATE_RELATION;
4745: 	}
4746: 	if (StringUtil::Equals(value, "SET_OPERATION_RELATION")) {
4747: 		return RelationType::SET_OPERATION_RELATION;
4748: 	}
4749: 	if (StringUtil::Equals(value, "DISTINCT_RELATION")) {
4750: 		return RelationType::DISTINCT_RELATION;
4751: 	}
4752: 	if (StringUtil::Equals(value, "LIMIT_RELATION")) {
4753: 		return RelationType::LIMIT_RELATION;
4754: 	}
4755: 	if (StringUtil::Equals(value, "ORDER_RELATION")) {
4756: 		return RelationType::ORDER_RELATION;
4757: 	}
4758: 	if (StringUtil::Equals(value, "CREATE_VIEW_RELATION")) {
4759: 		return RelationType::CREATE_VIEW_RELATION;
4760: 	}
4761: 	if (StringUtil::Equals(value, "CREATE_TABLE_RELATION")) {
4762: 		return RelationType::CREATE_TABLE_RELATION;
4763: 	}
4764: 	if (StringUtil::Equals(value, "INSERT_RELATION")) {
4765: 		return RelationType::INSERT_RELATION;
4766: 	}
4767: 	if (StringUtil::Equals(value, "VALUE_LIST_RELATION")) {
4768: 		return RelationType::VALUE_LIST_RELATION;
4769: 	}
4770: 	if (StringUtil::Equals(value, "DELETE_RELATION")) {
4771: 		return RelationType::DELETE_RELATION;
4772: 	}
4773: 	if (StringUtil::Equals(value, "UPDATE_RELATION")) {
4774: 		return RelationType::UPDATE_RELATION;
4775: 	}
4776: 	if (StringUtil::Equals(value, "WRITE_CSV_RELATION")) {
4777: 		return RelationType::WRITE_CSV_RELATION;
4778: 	}
4779: 	if (StringUtil::Equals(value, "WRITE_PARQUET_RELATION")) {
4780: 		return RelationType::WRITE_PARQUET_RELATION;
4781: 	}
4782: 	if (StringUtil::Equals(value, "READ_CSV_RELATION")) {
4783: 		return RelationType::READ_CSV_RELATION;
4784: 	}
4785: 	if (StringUtil::Equals(value, "SUBQUERY_RELATION")) {
4786: 		return RelationType::SUBQUERY_RELATION;
4787: 	}
4788: 	if (StringUtil::Equals(value, "TABLE_FUNCTION_RELATION")) {
4789: 		return RelationType::TABLE_FUNCTION_RELATION;
4790: 	}
4791: 	if (StringUtil::Equals(value, "VIEW_RELATION")) {
4792: 		return RelationType::VIEW_RELATION;
4793: 	}
4794: 	if (StringUtil::Equals(value, "QUERY_RELATION")) {
4795: 		return RelationType::QUERY_RELATION;
4796: 	}
4797: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4798: }
4799: 
4800: template<>
4801: const char* EnumUtil::ToChars<ResultModifierType>(ResultModifierType value) {
4802: 	switch(value) {
4803: 	case ResultModifierType::LIMIT_MODIFIER:
4804: 		return "LIMIT_MODIFIER";
4805: 	case ResultModifierType::ORDER_MODIFIER:
4806: 		return "ORDER_MODIFIER";
4807: 	case ResultModifierType::DISTINCT_MODIFIER:
4808: 		return "DISTINCT_MODIFIER";
4809: 	case ResultModifierType::LIMIT_PERCENT_MODIFIER:
4810: 		return "LIMIT_PERCENT_MODIFIER";
4811: 	default:
4812: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4813: 	}
4814: }
4815: 
4816: template<>
4817: ResultModifierType EnumUtil::FromString<ResultModifierType>(const char *value) {
4818: 	if (StringUtil::Equals(value, "LIMIT_MODIFIER")) {
4819: 		return ResultModifierType::LIMIT_MODIFIER;
4820: 	}
4821: 	if (StringUtil::Equals(value, "ORDER_MODIFIER")) {
4822: 		return ResultModifierType::ORDER_MODIFIER;
4823: 	}
4824: 	if (StringUtil::Equals(value, "DISTINCT_MODIFIER")) {
4825: 		return ResultModifierType::DISTINCT_MODIFIER;
4826: 	}
4827: 	if (StringUtil::Equals(value, "LIMIT_PERCENT_MODIFIER")) {
4828: 		return ResultModifierType::LIMIT_PERCENT_MODIFIER;
4829: 	}
4830: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4831: }
4832: 
4833: template<>
4834: const char* EnumUtil::ToChars<SampleMethod>(SampleMethod value) {
4835: 	switch(value) {
4836: 	case SampleMethod::SYSTEM_SAMPLE:
4837: 		return "System";
4838: 	case SampleMethod::BERNOULLI_SAMPLE:
4839: 		return "Bernoulli";
4840: 	case SampleMethod::RESERVOIR_SAMPLE:
4841: 		return "Reservoir";
4842: 	default:
4843: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4844: 	}
4845: }
4846: 
4847: template<>
4848: SampleMethod EnumUtil::FromString<SampleMethod>(const char *value) {
4849: 	if (StringUtil::Equals(value, "System")) {
4850: 		return SampleMethod::SYSTEM_SAMPLE;
4851: 	}
4852: 	if (StringUtil::Equals(value, "Bernoulli")) {
4853: 		return SampleMethod::BERNOULLI_SAMPLE;
4854: 	}
4855: 	if (StringUtil::Equals(value, "Reservoir")) {
4856: 		return SampleMethod::RESERVOIR_SAMPLE;
4857: 	}
4858: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4859: }
4860: 
4861: template<>
4862: const char* EnumUtil::ToChars<SequenceInfo>(SequenceInfo value) {
4863: 	switch(value) {
4864: 	case SequenceInfo::SEQ_START:
4865: 		return "SEQ_START";
4866: 	case SequenceInfo::SEQ_INC:
4867: 		return "SEQ_INC";
4868: 	case SequenceInfo::SEQ_MIN:
4869: 		return "SEQ_MIN";
4870: 	case SequenceInfo::SEQ_MAX:
4871: 		return "SEQ_MAX";
4872: 	case SequenceInfo::SEQ_CYCLE:
4873: 		return "SEQ_CYCLE";
4874: 	case SequenceInfo::SEQ_OWN:
4875: 		return "SEQ_OWN";
4876: 	default:
4877: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4878: 	}
4879: }
4880: 
4881: template<>
4882: SequenceInfo EnumUtil::FromString<SequenceInfo>(const char *value) {
4883: 	if (StringUtil::Equals(value, "SEQ_START")) {
4884: 		return SequenceInfo::SEQ_START;
4885: 	}
4886: 	if (StringUtil::Equals(value, "SEQ_INC")) {
4887: 		return SequenceInfo::SEQ_INC;
4888: 	}
4889: 	if (StringUtil::Equals(value, "SEQ_MIN")) {
4890: 		return SequenceInfo::SEQ_MIN;
4891: 	}
4892: 	if (StringUtil::Equals(value, "SEQ_MAX")) {
4893: 		return SequenceInfo::SEQ_MAX;
4894: 	}
4895: 	if (StringUtil::Equals(value, "SEQ_CYCLE")) {
4896: 		return SequenceInfo::SEQ_CYCLE;
4897: 	}
4898: 	if (StringUtil::Equals(value, "SEQ_OWN")) {
4899: 		return SequenceInfo::SEQ_OWN;
4900: 	}
4901: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4902: }
4903: 
4904: template<>
4905: const char* EnumUtil::ToChars<SetOperationType>(SetOperationType value) {
4906: 	switch(value) {
4907: 	case SetOperationType::NONE:
4908: 		return "NONE";
4909: 	case SetOperationType::UNION:
4910: 		return "UNION";
4911: 	case SetOperationType::EXCEPT:
4912: 		return "EXCEPT";
4913: 	case SetOperationType::INTERSECT:
4914: 		return "INTERSECT";
4915: 	case SetOperationType::UNION_BY_NAME:
4916: 		return "UNION_BY_NAME";
4917: 	default:
4918: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4919: 	}
4920: }
4921: 
4922: template<>
4923: SetOperationType EnumUtil::FromString<SetOperationType>(const char *value) {
4924: 	if (StringUtil::Equals(value, "NONE")) {
4925: 		return SetOperationType::NONE;
4926: 	}
4927: 	if (StringUtil::Equals(value, "UNION")) {
4928: 		return SetOperationType::UNION;
4929: 	}
4930: 	if (StringUtil::Equals(value, "EXCEPT")) {
4931: 		return SetOperationType::EXCEPT;
4932: 	}
4933: 	if (StringUtil::Equals(value, "INTERSECT")) {
4934: 		return SetOperationType::INTERSECT;
4935: 	}
4936: 	if (StringUtil::Equals(value, "UNION_BY_NAME")) {
4937: 		return SetOperationType::UNION_BY_NAME;
4938: 	}
4939: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4940: }
4941: 
4942: template<>
4943: const char* EnumUtil::ToChars<SetScope>(SetScope value) {
4944: 	switch(value) {
4945: 	case SetScope::AUTOMATIC:
4946: 		return "AUTOMATIC";
4947: 	case SetScope::LOCAL:
4948: 		return "LOCAL";
4949: 	case SetScope::SESSION:
4950: 		return "SESSION";
4951: 	case SetScope::GLOBAL:
4952: 		return "GLOBAL";
4953: 	default:
4954: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4955: 	}
4956: }
4957: 
4958: template<>
4959: SetScope EnumUtil::FromString<SetScope>(const char *value) {
4960: 	if (StringUtil::Equals(value, "AUTOMATIC")) {
4961: 		return SetScope::AUTOMATIC;
4962: 	}
4963: 	if (StringUtil::Equals(value, "LOCAL")) {
4964: 		return SetScope::LOCAL;
4965: 	}
4966: 	if (StringUtil::Equals(value, "SESSION")) {
4967: 		return SetScope::SESSION;
4968: 	}
4969: 	if (StringUtil::Equals(value, "GLOBAL")) {
4970: 		return SetScope::GLOBAL;
4971: 	}
4972: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4973: }
4974: 
4975: template<>
4976: const char* EnumUtil::ToChars<SetType>(SetType value) {
4977: 	switch(value) {
4978: 	case SetType::SET:
4979: 		return "SET";
4980: 	case SetType::RESET:
4981: 		return "RESET";
4982: 	default:
4983: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4984: 	}
4985: }
4986: 
4987: template<>
4988: SetType EnumUtil::FromString<SetType>(const char *value) {
4989: 	if (StringUtil::Equals(value, "SET")) {
4990: 		return SetType::SET;
4991: 	}
4992: 	if (StringUtil::Equals(value, "RESET")) {
4993: 		return SetType::RESET;
4994: 	}
4995: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4996: }
4997: 
4998: template<>
4999: const char* EnumUtil::ToChars<SimplifiedTokenType>(SimplifiedTokenType value) {
5000: 	switch(value) {
5001: 	case SimplifiedTokenType::SIMPLIFIED_TOKEN_IDENTIFIER:
5002: 		return "SIMPLIFIED_TOKEN_IDENTIFIER";
5003: 	case SimplifiedTokenType::SIMPLIFIED_TOKEN_NUMERIC_CONSTANT:
5004: 		return "SIMPLIFIED_TOKEN_NUMERIC_CONSTANT";
5005: 	case SimplifiedTokenType::SIMPLIFIED_TOKEN_STRING_CONSTANT:
5006: 		return "SIMPLIFIED_TOKEN_STRING_CONSTANT";
5007: 	case SimplifiedTokenType::SIMPLIFIED_TOKEN_OPERATOR:
5008: 		return "SIMPLIFIED_TOKEN_OPERATOR";
5009: 	case SimplifiedTokenType::SIMPLIFIED_TOKEN_KEYWORD:
5010: 		return "SIMPLIFIED_TOKEN_KEYWORD";
5011: 	case SimplifiedTokenType::SIMPLIFIED_TOKEN_COMMENT:
5012: 		return "SIMPLIFIED_TOKEN_COMMENT";
5013: 	default:
5014: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5015: 	}
5016: }
5017: 
5018: template<>
5019: SimplifiedTokenType EnumUtil::FromString<SimplifiedTokenType>(const char *value) {
5020: 	if (StringUtil::Equals(value, "SIMPLIFIED_TOKEN_IDENTIFIER")) {
5021: 		return SimplifiedTokenType::SIMPLIFIED_TOKEN_IDENTIFIER;
5022: 	}
5023: 	if (StringUtil::Equals(value, "SIMPLIFIED_TOKEN_NUMERIC_CONSTANT")) {
5024: 		return SimplifiedTokenType::SIMPLIFIED_TOKEN_NUMERIC_CONSTANT;
5025: 	}
5026: 	if (StringUtil::Equals(value, "SIMPLIFIED_TOKEN_STRING_CONSTANT")) {
5027: 		return SimplifiedTokenType::SIMPLIFIED_TOKEN_STRING_CONSTANT;
5028: 	}
5029: 	if (StringUtil::Equals(value, "SIMPLIFIED_TOKEN_OPERATOR")) {
5030: 		return SimplifiedTokenType::SIMPLIFIED_TOKEN_OPERATOR;
5031: 	}
5032: 	if (StringUtil::Equals(value, "SIMPLIFIED_TOKEN_KEYWORD")) {
5033: 		return SimplifiedTokenType::SIMPLIFIED_TOKEN_KEYWORD;
5034: 	}
5035: 	if (StringUtil::Equals(value, "SIMPLIFIED_TOKEN_COMMENT")) {
5036: 		return SimplifiedTokenType::SIMPLIFIED_TOKEN_COMMENT;
5037: 	}
5038: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5039: }
5040: 
5041: template<>
5042: const char* EnumUtil::ToChars<SinkCombineResultType>(SinkCombineResultType value) {
5043: 	switch(value) {
5044: 	case SinkCombineResultType::FINISHED:
5045: 		return "FINISHED";
5046: 	case SinkCombineResultType::BLOCKED:
5047: 		return "BLOCKED";
5048: 	default:
5049: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5050: 	}
5051: }
5052: 
5053: template<>
5054: SinkCombineResultType EnumUtil::FromString<SinkCombineResultType>(const char *value) {
5055: 	if (StringUtil::Equals(value, "FINISHED")) {
5056: 		return SinkCombineResultType::FINISHED;
5057: 	}
5058: 	if (StringUtil::Equals(value, "BLOCKED")) {
5059: 		return SinkCombineResultType::BLOCKED;
5060: 	}
5061: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5062: }
5063: 
5064: template<>
5065: const char* EnumUtil::ToChars<SinkFinalizeType>(SinkFinalizeType value) {
5066: 	switch(value) {
5067: 	case SinkFinalizeType::READY:
5068: 		return "READY";
5069: 	case SinkFinalizeType::NO_OUTPUT_POSSIBLE:
5070: 		return "NO_OUTPUT_POSSIBLE";
5071: 	case SinkFinalizeType::BLOCKED:
5072: 		return "BLOCKED";
5073: 	default:
5074: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5075: 	}
5076: }
5077: 
5078: template<>
5079: SinkFinalizeType EnumUtil::FromString<SinkFinalizeType>(const char *value) {
5080: 	if (StringUtil::Equals(value, "READY")) {
5081: 		return SinkFinalizeType::READY;
5082: 	}
5083: 	if (StringUtil::Equals(value, "NO_OUTPUT_POSSIBLE")) {
5084: 		return SinkFinalizeType::NO_OUTPUT_POSSIBLE;
5085: 	}
5086: 	if (StringUtil::Equals(value, "BLOCKED")) {
5087: 		return SinkFinalizeType::BLOCKED;
5088: 	}
5089: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5090: }
5091: 
5092: template<>
5093: const char* EnumUtil::ToChars<SinkResultType>(SinkResultType value) {
5094: 	switch(value) {
5095: 	case SinkResultType::NEED_MORE_INPUT:
5096: 		return "NEED_MORE_INPUT";
5097: 	case SinkResultType::FINISHED:
5098: 		return "FINISHED";
5099: 	case SinkResultType::BLOCKED:
5100: 		return "BLOCKED";
5101: 	default:
5102: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5103: 	}
5104: }
5105: 
5106: template<>
5107: SinkResultType EnumUtil::FromString<SinkResultType>(const char *value) {
5108: 	if (StringUtil::Equals(value, "NEED_MORE_INPUT")) {
5109: 		return SinkResultType::NEED_MORE_INPUT;
5110: 	}
5111: 	if (StringUtil::Equals(value, "FINISHED")) {
5112: 		return SinkResultType::FINISHED;
5113: 	}
5114: 	if (StringUtil::Equals(value, "BLOCKED")) {
5115: 		return SinkResultType::BLOCKED;
5116: 	}
5117: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5118: }
5119: 
5120: template<>
5121: const char* EnumUtil::ToChars<SourceResultType>(SourceResultType value) {
5122: 	switch(value) {
5123: 	case SourceResultType::HAVE_MORE_OUTPUT:
5124: 		return "HAVE_MORE_OUTPUT";
5125: 	case SourceResultType::FINISHED:
5126: 		return "FINISHED";
5127: 	case SourceResultType::BLOCKED:
5128: 		return "BLOCKED";
5129: 	default:
5130: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5131: 	}
5132: }
5133: 
5134: template<>
5135: SourceResultType EnumUtil::FromString<SourceResultType>(const char *value) {
5136: 	if (StringUtil::Equals(value, "HAVE_MORE_OUTPUT")) {
5137: 		return SourceResultType::HAVE_MORE_OUTPUT;
5138: 	}
5139: 	if (StringUtil::Equals(value, "FINISHED")) {
5140: 		return SourceResultType::FINISHED;
5141: 	}
5142: 	if (StringUtil::Equals(value, "BLOCKED")) {
5143: 		return SourceResultType::BLOCKED;
5144: 	}
5145: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5146: }
5147: 
5148: template<>
5149: const char* EnumUtil::ToChars<StatementReturnType>(StatementReturnType value) {
5150: 	switch(value) {
5151: 	case StatementReturnType::QUERY_RESULT:
5152: 		return "QUERY_RESULT";
5153: 	case StatementReturnType::CHANGED_ROWS:
5154: 		return "CHANGED_ROWS";
5155: 	case StatementReturnType::NOTHING:
5156: 		return "NOTHING";
5157: 	default:
5158: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5159: 	}
5160: }
5161: 
5162: template<>
5163: StatementReturnType EnumUtil::FromString<StatementReturnType>(const char *value) {
5164: 	if (StringUtil::Equals(value, "QUERY_RESULT")) {
5165: 		return StatementReturnType::QUERY_RESULT;
5166: 	}
5167: 	if (StringUtil::Equals(value, "CHANGED_ROWS")) {
5168: 		return StatementReturnType::CHANGED_ROWS;
5169: 	}
5170: 	if (StringUtil::Equals(value, "NOTHING")) {
5171: 		return StatementReturnType::NOTHING;
5172: 	}
5173: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5174: }
5175: 
5176: template<>
5177: const char* EnumUtil::ToChars<StatementType>(StatementType value) {
5178: 	switch(value) {
5179: 	case StatementType::INVALID_STATEMENT:
5180: 		return "INVALID_STATEMENT";
5181: 	case StatementType::SELECT_STATEMENT:
5182: 		return "SELECT_STATEMENT";
5183: 	case StatementType::INSERT_STATEMENT:
5184: 		return "INSERT_STATEMENT";
5185: 	case StatementType::UPDATE_STATEMENT:
5186: 		return "UPDATE_STATEMENT";
5187: 	case StatementType::CREATE_STATEMENT:
5188: 		return "CREATE_STATEMENT";
5189: 	case StatementType::DELETE_STATEMENT:
5190: 		return "DELETE_STATEMENT";
5191: 	case StatementType::PREPARE_STATEMENT:
5192: 		return "PREPARE_STATEMENT";
5193: 	case StatementType::EXECUTE_STATEMENT:
5194: 		return "EXECUTE_STATEMENT";
5195: 	case StatementType::ALTER_STATEMENT:
5196: 		return "ALTER_STATEMENT";
5197: 	case StatementType::TRANSACTION_STATEMENT:
5198: 		return "TRANSACTION_STATEMENT";
5199: 	case StatementType::COPY_STATEMENT:
5200: 		return "COPY_STATEMENT";
5201: 	case StatementType::ANALYZE_STATEMENT:
5202: 		return "ANALYZE_STATEMENT";
5203: 	case StatementType::VARIABLE_SET_STATEMENT:
5204: 		return "VARIABLE_SET_STATEMENT";
5205: 	case StatementType::CREATE_FUNC_STATEMENT:
5206: 		return "CREATE_FUNC_STATEMENT";
5207: 	case StatementType::EXPLAIN_STATEMENT:
5208: 		return "EXPLAIN_STATEMENT";
5209: 	case StatementType::DROP_STATEMENT:
5210: 		return "DROP_STATEMENT";
5211: 	case StatementType::EXPORT_STATEMENT:
5212: 		return "EXPORT_STATEMENT";
5213: 	case StatementType::PRAGMA_STATEMENT:
5214: 		return "PRAGMA_STATEMENT";
5215: 	case StatementType::SHOW_STATEMENT:
5216: 		return "SHOW_STATEMENT";
5217: 	case StatementType::VACUUM_STATEMENT:
5218: 		return "VACUUM_STATEMENT";
5219: 	case StatementType::CALL_STATEMENT:
5220: 		return "CALL_STATEMENT";
5221: 	case StatementType::SET_STATEMENT:
5222: 		return "SET_STATEMENT";
5223: 	case StatementType::LOAD_STATEMENT:
5224: 		return "LOAD_STATEMENT";
5225: 	case StatementType::RELATION_STATEMENT:
5226: 		return "RELATION_STATEMENT";
5227: 	case StatementType::EXTENSION_STATEMENT:
5228: 		return "EXTENSION_STATEMENT";
5229: 	case StatementType::LOGICAL_PLAN_STATEMENT:
5230: 		return "LOGICAL_PLAN_STATEMENT";
5231: 	case StatementType::ATTACH_STATEMENT:
5232: 		return "ATTACH_STATEMENT";
5233: 	case StatementType::DETACH_STATEMENT:
5234: 		return "DETACH_STATEMENT";
5235: 	case StatementType::MULTI_STATEMENT:
5236: 		return "MULTI_STATEMENT";
5237: 	default:
5238: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5239: 	}
5240: }
5241: 
5242: template<>
5243: StatementType EnumUtil::FromString<StatementType>(const char *value) {
5244: 	if (StringUtil::Equals(value, "INVALID_STATEMENT")) {
5245: 		return StatementType::INVALID_STATEMENT;
5246: 	}
5247: 	if (StringUtil::Equals(value, "SELECT_STATEMENT")) {
5248: 		return StatementType::SELECT_STATEMENT;
5249: 	}
5250: 	if (StringUtil::Equals(value, "INSERT_STATEMENT")) {
5251: 		return StatementType::INSERT_STATEMENT;
5252: 	}
5253: 	if (StringUtil::Equals(value, "UPDATE_STATEMENT")) {
5254: 		return StatementType::UPDATE_STATEMENT;
5255: 	}
5256: 	if (StringUtil::Equals(value, "CREATE_STATEMENT")) {
5257: 		return StatementType::CREATE_STATEMENT;
5258: 	}
5259: 	if (StringUtil::Equals(value, "DELETE_STATEMENT")) {
5260: 		return StatementType::DELETE_STATEMENT;
5261: 	}
5262: 	if (StringUtil::Equals(value, "PREPARE_STATEMENT")) {
5263: 		return StatementType::PREPARE_STATEMENT;
5264: 	}
5265: 	if (StringUtil::Equals(value, "EXECUTE_STATEMENT")) {
5266: 		return StatementType::EXECUTE_STATEMENT;
5267: 	}
5268: 	if (StringUtil::Equals(value, "ALTER_STATEMENT")) {
5269: 		return StatementType::ALTER_STATEMENT;
5270: 	}
5271: 	if (StringUtil::Equals(value, "TRANSACTION_STATEMENT")) {
5272: 		return StatementType::TRANSACTION_STATEMENT;
5273: 	}
5274: 	if (StringUtil::Equals(value, "COPY_STATEMENT")) {
5275: 		return StatementType::COPY_STATEMENT;
5276: 	}
5277: 	if (StringUtil::Equals(value, "ANALYZE_STATEMENT")) {
5278: 		return StatementType::ANALYZE_STATEMENT;
5279: 	}
5280: 	if (StringUtil::Equals(value, "VARIABLE_SET_STATEMENT")) {
5281: 		return StatementType::VARIABLE_SET_STATEMENT;
5282: 	}
5283: 	if (StringUtil::Equals(value, "CREATE_FUNC_STATEMENT")) {
5284: 		return StatementType::CREATE_FUNC_STATEMENT;
5285: 	}
5286: 	if (StringUtil::Equals(value, "EXPLAIN_STATEMENT")) {
5287: 		return StatementType::EXPLAIN_STATEMENT;
5288: 	}
5289: 	if (StringUtil::Equals(value, "DROP_STATEMENT")) {
5290: 		return StatementType::DROP_STATEMENT;
5291: 	}
5292: 	if (StringUtil::Equals(value, "EXPORT_STATEMENT")) {
5293: 		return StatementType::EXPORT_STATEMENT;
5294: 	}
5295: 	if (StringUtil::Equals(value, "PRAGMA_STATEMENT")) {
5296: 		return StatementType::PRAGMA_STATEMENT;
5297: 	}
5298: 	if (StringUtil::Equals(value, "SHOW_STATEMENT")) {
5299: 		return StatementType::SHOW_STATEMENT;
5300: 	}
5301: 	if (StringUtil::Equals(value, "VACUUM_STATEMENT")) {
5302: 		return StatementType::VACUUM_STATEMENT;
5303: 	}
5304: 	if (StringUtil::Equals(value, "CALL_STATEMENT")) {
5305: 		return StatementType::CALL_STATEMENT;
5306: 	}
5307: 	if (StringUtil::Equals(value, "SET_STATEMENT")) {
5308: 		return StatementType::SET_STATEMENT;
5309: 	}
5310: 	if (StringUtil::Equals(value, "LOAD_STATEMENT")) {
5311: 		return StatementType::LOAD_STATEMENT;
5312: 	}
5313: 	if (StringUtil::Equals(value, "RELATION_STATEMENT")) {
5314: 		return StatementType::RELATION_STATEMENT;
5315: 	}
5316: 	if (StringUtil::Equals(value, "EXTENSION_STATEMENT")) {
5317: 		return StatementType::EXTENSION_STATEMENT;
5318: 	}
5319: 	if (StringUtil::Equals(value, "LOGICAL_PLAN_STATEMENT")) {
5320: 		return StatementType::LOGICAL_PLAN_STATEMENT;
5321: 	}
5322: 	if (StringUtil::Equals(value, "ATTACH_STATEMENT")) {
5323: 		return StatementType::ATTACH_STATEMENT;
5324: 	}
5325: 	if (StringUtil::Equals(value, "DETACH_STATEMENT")) {
5326: 		return StatementType::DETACH_STATEMENT;
5327: 	}
5328: 	if (StringUtil::Equals(value, "MULTI_STATEMENT")) {
5329: 		return StatementType::MULTI_STATEMENT;
5330: 	}
5331: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5332: }
5333: 
5334: template<>
5335: const char* EnumUtil::ToChars<StatisticsType>(StatisticsType value) {
5336: 	switch(value) {
5337: 	case StatisticsType::NUMERIC_STATS:
5338: 		return "NUMERIC_STATS";
5339: 	case StatisticsType::STRING_STATS:
5340: 		return "STRING_STATS";
5341: 	case StatisticsType::LIST_STATS:
5342: 		return "LIST_STATS";
5343: 	case StatisticsType::STRUCT_STATS:
5344: 		return "STRUCT_STATS";
5345: 	case StatisticsType::BASE_STATS:
5346: 		return "BASE_STATS";
5347: 	default:
5348: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5349: 	}
5350: }
5351: 
5352: template<>
5353: StatisticsType EnumUtil::FromString<StatisticsType>(const char *value) {
5354: 	if (StringUtil::Equals(value, "NUMERIC_STATS")) {
5355: 		return StatisticsType::NUMERIC_STATS;
5356: 	}
5357: 	if (StringUtil::Equals(value, "STRING_STATS")) {
5358: 		return StatisticsType::STRING_STATS;
5359: 	}
5360: 	if (StringUtil::Equals(value, "LIST_STATS")) {
5361: 		return StatisticsType::LIST_STATS;
5362: 	}
5363: 	if (StringUtil::Equals(value, "STRUCT_STATS")) {
5364: 		return StatisticsType::STRUCT_STATS;
5365: 	}
5366: 	if (StringUtil::Equals(value, "BASE_STATS")) {
5367: 		return StatisticsType::BASE_STATS;
5368: 	}
5369: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5370: }
5371: 
5372: template<>
5373: const char* EnumUtil::ToChars<StatsInfo>(StatsInfo value) {
5374: 	switch(value) {
5375: 	case StatsInfo::CAN_HAVE_NULL_VALUES:
5376: 		return "CAN_HAVE_NULL_VALUES";
5377: 	case StatsInfo::CANNOT_HAVE_NULL_VALUES:
5378: 		return "CANNOT_HAVE_NULL_VALUES";
5379: 	case StatsInfo::CAN_HAVE_VALID_VALUES:
5380: 		return "CAN_HAVE_VALID_VALUES";
5381: 	case StatsInfo::CANNOT_HAVE_VALID_VALUES:
5382: 		return "CANNOT_HAVE_VALID_VALUES";
5383: 	case StatsInfo::CAN_HAVE_NULL_AND_VALID_VALUES:
5384: 		return "CAN_HAVE_NULL_AND_VALID_VALUES";
5385: 	default:
5386: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5387: 	}
5388: }
5389: 
5390: template<>
5391: StatsInfo EnumUtil::FromString<StatsInfo>(const char *value) {
5392: 	if (StringUtil::Equals(value, "CAN_HAVE_NULL_VALUES")) {
5393: 		return StatsInfo::CAN_HAVE_NULL_VALUES;
5394: 	}
5395: 	if (StringUtil::Equals(value, "CANNOT_HAVE_NULL_VALUES")) {
5396: 		return StatsInfo::CANNOT_HAVE_NULL_VALUES;
5397: 	}
5398: 	if (StringUtil::Equals(value, "CAN_HAVE_VALID_VALUES")) {
5399: 		return StatsInfo::CAN_HAVE_VALID_VALUES;
5400: 	}
5401: 	if (StringUtil::Equals(value, "CANNOT_HAVE_VALID_VALUES")) {
5402: 		return StatsInfo::CANNOT_HAVE_VALID_VALUES;
5403: 	}
5404: 	if (StringUtil::Equals(value, "CAN_HAVE_NULL_AND_VALID_VALUES")) {
5405: 		return StatsInfo::CAN_HAVE_NULL_AND_VALID_VALUES;
5406: 	}
5407: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5408: }
5409: 
5410: template<>
5411: const char* EnumUtil::ToChars<StrTimeSpecifier>(StrTimeSpecifier value) {
5412: 	switch(value) {
5413: 	case StrTimeSpecifier::ABBREVIATED_WEEKDAY_NAME:
5414: 		return "ABBREVIATED_WEEKDAY_NAME";
5415: 	case StrTimeSpecifier::FULL_WEEKDAY_NAME:
5416: 		return "FULL_WEEKDAY_NAME";
5417: 	case StrTimeSpecifier::WEEKDAY_DECIMAL:
5418: 		return "WEEKDAY_DECIMAL";
5419: 	case StrTimeSpecifier::DAY_OF_MONTH_PADDED:
5420: 		return "DAY_OF_MONTH_PADDED";
5421: 	case StrTimeSpecifier::DAY_OF_MONTH:
5422: 		return "DAY_OF_MONTH";
5423: 	case StrTimeSpecifier::ABBREVIATED_MONTH_NAME:
5424: 		return "ABBREVIATED_MONTH_NAME";
5425: 	case StrTimeSpecifier::FULL_MONTH_NAME:
5426: 		return "FULL_MONTH_NAME";
5427: 	case StrTimeSpecifier::MONTH_DECIMAL_PADDED:
5428: 		return "MONTH_DECIMAL_PADDED";
5429: 	case StrTimeSpecifier::MONTH_DECIMAL:
5430: 		return "MONTH_DECIMAL";
5431: 	case StrTimeSpecifier::YEAR_WITHOUT_CENTURY_PADDED:
5432: 		return "YEAR_WITHOUT_CENTURY_PADDED";
5433: 	case StrTimeSpecifier::YEAR_WITHOUT_CENTURY:
5434: 		return "YEAR_WITHOUT_CENTURY";
5435: 	case StrTimeSpecifier::YEAR_DECIMAL:
5436: 		return "YEAR_DECIMAL";
5437: 	case StrTimeSpecifier::HOUR_24_PADDED:
5438: 		return "HOUR_24_PADDED";
5439: 	case StrTimeSpecifier::HOUR_24_DECIMAL:
5440: 		return "HOUR_24_DECIMAL";
5441: 	case StrTimeSpecifier::HOUR_12_PADDED:
5442: 		return "HOUR_12_PADDED";
5443: 	case StrTimeSpecifier::HOUR_12_DECIMAL:
5444: 		return "HOUR_12_DECIMAL";
5445: 	case StrTimeSpecifier::AM_PM:
5446: 		return "AM_PM";
5447: 	case StrTimeSpecifier::MINUTE_PADDED:
5448: 		return "MINUTE_PADDED";
5449: 	case StrTimeSpecifier::MINUTE_DECIMAL:
5450: 		return "MINUTE_DECIMAL";
5451: 	case StrTimeSpecifier::SECOND_PADDED:
5452: 		return "SECOND_PADDED";
5453: 	case StrTimeSpecifier::SECOND_DECIMAL:
5454: 		return "SECOND_DECIMAL";
5455: 	case StrTimeSpecifier::MICROSECOND_PADDED:
5456: 		return "MICROSECOND_PADDED";
5457: 	case StrTimeSpecifier::MILLISECOND_PADDED:
5458: 		return "MILLISECOND_PADDED";
5459: 	case StrTimeSpecifier::UTC_OFFSET:
5460: 		return "UTC_OFFSET";
5461: 	case StrTimeSpecifier::TZ_NAME:
5462: 		return "TZ_NAME";
5463: 	case StrTimeSpecifier::DAY_OF_YEAR_PADDED:
5464: 		return "DAY_OF_YEAR_PADDED";
5465: 	case StrTimeSpecifier::DAY_OF_YEAR_DECIMAL:
5466: 		return "DAY_OF_YEAR_DECIMAL";
5467: 	case StrTimeSpecifier::WEEK_NUMBER_PADDED_SUN_FIRST:
5468: 		return "WEEK_NUMBER_PADDED_SUN_FIRST";
5469: 	case StrTimeSpecifier::WEEK_NUMBER_PADDED_MON_FIRST:
5470: 		return "WEEK_NUMBER_PADDED_MON_FIRST";
5471: 	case StrTimeSpecifier::LOCALE_APPROPRIATE_DATE_AND_TIME:
5472: 		return "LOCALE_APPROPRIATE_DATE_AND_TIME";
5473: 	case StrTimeSpecifier::LOCALE_APPROPRIATE_DATE:
5474: 		return "LOCALE_APPROPRIATE_DATE";
5475: 	case StrTimeSpecifier::LOCALE_APPROPRIATE_TIME:
5476: 		return "LOCALE_APPROPRIATE_TIME";
5477: 	default:
5478: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5479: 	}
5480: }
5481: 
5482: template<>
5483: StrTimeSpecifier EnumUtil::FromString<StrTimeSpecifier>(const char *value) {
5484: 	if (StringUtil::Equals(value, "ABBREVIATED_WEEKDAY_NAME")) {
5485: 		return StrTimeSpecifier::ABBREVIATED_WEEKDAY_NAME;
5486: 	}
5487: 	if (StringUtil::Equals(value, "FULL_WEEKDAY_NAME")) {
5488: 		return StrTimeSpecifier::FULL_WEEKDAY_NAME;
5489: 	}
5490: 	if (StringUtil::Equals(value, "WEEKDAY_DECIMAL")) {
5491: 		return StrTimeSpecifier::WEEKDAY_DECIMAL;
5492: 	}
5493: 	if (StringUtil::Equals(value, "DAY_OF_MONTH_PADDED")) {
5494: 		return StrTimeSpecifier::DAY_OF_MONTH_PADDED;
5495: 	}
5496: 	if (StringUtil::Equals(value, "DAY_OF_MONTH")) {
5497: 		return StrTimeSpecifier::DAY_OF_MONTH;
5498: 	}
5499: 	if (StringUtil::Equals(value, "ABBREVIATED_MONTH_NAME")) {
5500: 		return StrTimeSpecifier::ABBREVIATED_MONTH_NAME;
5501: 	}
5502: 	if (StringUtil::Equals(value, "FULL_MONTH_NAME")) {
5503: 		return StrTimeSpecifier::FULL_MONTH_NAME;
5504: 	}
5505: 	if (StringUtil::Equals(value, "MONTH_DECIMAL_PADDED")) {
5506: 		return StrTimeSpecifier::MONTH_DECIMAL_PADDED;
5507: 	}
5508: 	if (StringUtil::Equals(value, "MONTH_DECIMAL")) {
5509: 		return StrTimeSpecifier::MONTH_DECIMAL;
5510: 	}
5511: 	if (StringUtil::Equals(value, "YEAR_WITHOUT_CENTURY_PADDED")) {
5512: 		return StrTimeSpecifier::YEAR_WITHOUT_CENTURY_PADDED;
5513: 	}
5514: 	if (StringUtil::Equals(value, "YEAR_WITHOUT_CENTURY")) {
5515: 		return StrTimeSpecifier::YEAR_WITHOUT_CENTURY;
5516: 	}
5517: 	if (StringUtil::Equals(value, "YEAR_DECIMAL")) {
5518: 		return StrTimeSpecifier::YEAR_DECIMAL;
5519: 	}
5520: 	if (StringUtil::Equals(value, "HOUR_24_PADDED")) {
5521: 		return StrTimeSpecifier::HOUR_24_PADDED;
5522: 	}
5523: 	if (StringUtil::Equals(value, "HOUR_24_DECIMAL")) {
5524: 		return StrTimeSpecifier::HOUR_24_DECIMAL;
5525: 	}
5526: 	if (StringUtil::Equals(value, "HOUR_12_PADDED")) {
5527: 		return StrTimeSpecifier::HOUR_12_PADDED;
5528: 	}
5529: 	if (StringUtil::Equals(value, "HOUR_12_DECIMAL")) {
5530: 		return StrTimeSpecifier::HOUR_12_DECIMAL;
5531: 	}
5532: 	if (StringUtil::Equals(value, "AM_PM")) {
5533: 		return StrTimeSpecifier::AM_PM;
5534: 	}
5535: 	if (StringUtil::Equals(value, "MINUTE_PADDED")) {
5536: 		return StrTimeSpecifier::MINUTE_PADDED;
5537: 	}
5538: 	if (StringUtil::Equals(value, "MINUTE_DECIMAL")) {
5539: 		return StrTimeSpecifier::MINUTE_DECIMAL;
5540: 	}
5541: 	if (StringUtil::Equals(value, "SECOND_PADDED")) {
5542: 		return StrTimeSpecifier::SECOND_PADDED;
5543: 	}
5544: 	if (StringUtil::Equals(value, "SECOND_DECIMAL")) {
5545: 		return StrTimeSpecifier::SECOND_DECIMAL;
5546: 	}
5547: 	if (StringUtil::Equals(value, "MICROSECOND_PADDED")) {
5548: 		return StrTimeSpecifier::MICROSECOND_PADDED;
5549: 	}
5550: 	if (StringUtil::Equals(value, "MILLISECOND_PADDED")) {
5551: 		return StrTimeSpecifier::MILLISECOND_PADDED;
5552: 	}
5553: 	if (StringUtil::Equals(value, "UTC_OFFSET")) {
5554: 		return StrTimeSpecifier::UTC_OFFSET;
5555: 	}
5556: 	if (StringUtil::Equals(value, "TZ_NAME")) {
5557: 		return StrTimeSpecifier::TZ_NAME;
5558: 	}
5559: 	if (StringUtil::Equals(value, "DAY_OF_YEAR_PADDED")) {
5560: 		return StrTimeSpecifier::DAY_OF_YEAR_PADDED;
5561: 	}
5562: 	if (StringUtil::Equals(value, "DAY_OF_YEAR_DECIMAL")) {
5563: 		return StrTimeSpecifier::DAY_OF_YEAR_DECIMAL;
5564: 	}
5565: 	if (StringUtil::Equals(value, "WEEK_NUMBER_PADDED_SUN_FIRST")) {
5566: 		return StrTimeSpecifier::WEEK_NUMBER_PADDED_SUN_FIRST;
5567: 	}
5568: 	if (StringUtil::Equals(value, "WEEK_NUMBER_PADDED_MON_FIRST")) {
5569: 		return StrTimeSpecifier::WEEK_NUMBER_PADDED_MON_FIRST;
5570: 	}
5571: 	if (StringUtil::Equals(value, "LOCALE_APPROPRIATE_DATE_AND_TIME")) {
5572: 		return StrTimeSpecifier::LOCALE_APPROPRIATE_DATE_AND_TIME;
5573: 	}
5574: 	if (StringUtil::Equals(value, "LOCALE_APPROPRIATE_DATE")) {
5575: 		return StrTimeSpecifier::LOCALE_APPROPRIATE_DATE;
5576: 	}
5577: 	if (StringUtil::Equals(value, "LOCALE_APPROPRIATE_TIME")) {
5578: 		return StrTimeSpecifier::LOCALE_APPROPRIATE_TIME;
5579: 	}
5580: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5581: }
5582: 
5583: template<>
5584: const char* EnumUtil::ToChars<SubqueryType>(SubqueryType value) {
5585: 	switch(value) {
5586: 	case SubqueryType::INVALID:
5587: 		return "INVALID";
5588: 	case SubqueryType::SCALAR:
5589: 		return "SCALAR";
5590: 	case SubqueryType::EXISTS:
5591: 		return "EXISTS";
5592: 	case SubqueryType::NOT_EXISTS:
5593: 		return "NOT_EXISTS";
5594: 	case SubqueryType::ANY:
5595: 		return "ANY";
5596: 	default:
5597: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5598: 	}
5599: }
5600: 
5601: template<>
5602: SubqueryType EnumUtil::FromString<SubqueryType>(const char *value) {
5603: 	if (StringUtil::Equals(value, "INVALID")) {
5604: 		return SubqueryType::INVALID;
5605: 	}
5606: 	if (StringUtil::Equals(value, "SCALAR")) {
5607: 		return SubqueryType::SCALAR;
5608: 	}
5609: 	if (StringUtil::Equals(value, "EXISTS")) {
5610: 		return SubqueryType::EXISTS;
5611: 	}
5612: 	if (StringUtil::Equals(value, "NOT_EXISTS")) {
5613: 		return SubqueryType::NOT_EXISTS;
5614: 	}
5615: 	if (StringUtil::Equals(value, "ANY")) {
5616: 		return SubqueryType::ANY;
5617: 	}
5618: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5619: }
5620: 
5621: template<>
5622: const char* EnumUtil::ToChars<TableColumnType>(TableColumnType value) {
5623: 	switch(value) {
5624: 	case TableColumnType::STANDARD:
5625: 		return "STANDARD";
5626: 	case TableColumnType::GENERATED:
5627: 		return "GENERATED";
5628: 	default:
5629: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5630: 	}
5631: }
5632: 
5633: template<>
5634: TableColumnType EnumUtil::FromString<TableColumnType>(const char *value) {
5635: 	if (StringUtil::Equals(value, "STANDARD")) {
5636: 		return TableColumnType::STANDARD;
5637: 	}
5638: 	if (StringUtil::Equals(value, "GENERATED")) {
5639: 		return TableColumnType::GENERATED;
5640: 	}
5641: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5642: }
5643: 
5644: template<>
5645: const char* EnumUtil::ToChars<TableFilterType>(TableFilterType value) {
5646: 	switch(value) {
5647: 	case TableFilterType::CONSTANT_COMPARISON:
5648: 		return "CONSTANT_COMPARISON";
5649: 	case TableFilterType::IS_NULL:
5650: 		return "IS_NULL";
5651: 	case TableFilterType::IS_NOT_NULL:
5652: 		return "IS_NOT_NULL";
5653: 	case TableFilterType::CONJUNCTION_OR:
5654: 		return "CONJUNCTION_OR";
5655: 	case TableFilterType::CONJUNCTION_AND:
5656: 		return "CONJUNCTION_AND";
5657: 	default:
5658: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5659: 	}
5660: }
5661: 
5662: template<>
5663: TableFilterType EnumUtil::FromString<TableFilterType>(const char *value) {
5664: 	if (StringUtil::Equals(value, "CONSTANT_COMPARISON")) {
5665: 		return TableFilterType::CONSTANT_COMPARISON;
5666: 	}
5667: 	if (StringUtil::Equals(value, "IS_NULL")) {
5668: 		return TableFilterType::IS_NULL;
5669: 	}
5670: 	if (StringUtil::Equals(value, "IS_NOT_NULL")) {
5671: 		return TableFilterType::IS_NOT_NULL;
5672: 	}
5673: 	if (StringUtil::Equals(value, "CONJUNCTION_OR")) {
5674: 		return TableFilterType::CONJUNCTION_OR;
5675: 	}
5676: 	if (StringUtil::Equals(value, "CONJUNCTION_AND")) {
5677: 		return TableFilterType::CONJUNCTION_AND;
5678: 	}
5679: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5680: }
5681: 
5682: template<>
5683: const char* EnumUtil::ToChars<TableReferenceType>(TableReferenceType value) {
5684: 	switch(value) {
5685: 	case TableReferenceType::INVALID:
5686: 		return "INVALID";
5687: 	case TableReferenceType::BASE_TABLE:
5688: 		return "BASE_TABLE";
5689: 	case TableReferenceType::SUBQUERY:
5690: 		return "SUBQUERY";
5691: 	case TableReferenceType::JOIN:
5692: 		return "JOIN";
5693: 	case TableReferenceType::TABLE_FUNCTION:
5694: 		return "TABLE_FUNCTION";
5695: 	case TableReferenceType::EXPRESSION_LIST:
5696: 		return "EXPRESSION_LIST";
5697: 	case TableReferenceType::CTE:
5698: 		return "CTE";
5699: 	case TableReferenceType::EMPTY:
5700: 		return "EMPTY";
5701: 	case TableReferenceType::PIVOT:
5702: 		return "PIVOT";
5703: 	default:
5704: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5705: 	}
5706: }
5707: 
5708: template<>
5709: TableReferenceType EnumUtil::FromString<TableReferenceType>(const char *value) {
5710: 	if (StringUtil::Equals(value, "INVALID")) {
5711: 		return TableReferenceType::INVALID;
5712: 	}
5713: 	if (StringUtil::Equals(value, "BASE_TABLE")) {
5714: 		return TableReferenceType::BASE_TABLE;
5715: 	}
5716: 	if (StringUtil::Equals(value, "SUBQUERY")) {
5717: 		return TableReferenceType::SUBQUERY;
5718: 	}
5719: 	if (StringUtil::Equals(value, "JOIN")) {
5720: 		return TableReferenceType::JOIN;
5721: 	}
5722: 	if (StringUtil::Equals(value, "TABLE_FUNCTION")) {
5723: 		return TableReferenceType::TABLE_FUNCTION;
5724: 	}
5725: 	if (StringUtil::Equals(value, "EXPRESSION_LIST")) {
5726: 		return TableReferenceType::EXPRESSION_LIST;
5727: 	}
5728: 	if (StringUtil::Equals(value, "CTE")) {
5729: 		return TableReferenceType::CTE;
5730: 	}
5731: 	if (StringUtil::Equals(value, "EMPTY")) {
5732: 		return TableReferenceType::EMPTY;
5733: 	}
5734: 	if (StringUtil::Equals(value, "PIVOT")) {
5735: 		return TableReferenceType::PIVOT;
5736: 	}
5737: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5738: }
5739: 
5740: template<>
5741: const char* EnumUtil::ToChars<TableScanType>(TableScanType value) {
5742: 	switch(value) {
5743: 	case TableScanType::TABLE_SCAN_REGULAR:
5744: 		return "TABLE_SCAN_REGULAR";
5745: 	case TableScanType::TABLE_SCAN_COMMITTED_ROWS:
5746: 		return "TABLE_SCAN_COMMITTED_ROWS";
5747: 	case TableScanType::TABLE_SCAN_COMMITTED_ROWS_DISALLOW_UPDATES:
5748: 		return "TABLE_SCAN_COMMITTED_ROWS_DISALLOW_UPDATES";
5749: 	case TableScanType::TABLE_SCAN_COMMITTED_ROWS_OMIT_PERMANENTLY_DELETED:
5750: 		return "TABLE_SCAN_COMMITTED_ROWS_OMIT_PERMANENTLY_DELETED";
5751: 	default:
5752: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5753: 	}
5754: }
5755: 
5756: template<>
5757: TableScanType EnumUtil::FromString<TableScanType>(const char *value) {
5758: 	if (StringUtil::Equals(value, "TABLE_SCAN_REGULAR")) {
5759: 		return TableScanType::TABLE_SCAN_REGULAR;
5760: 	}
5761: 	if (StringUtil::Equals(value, "TABLE_SCAN_COMMITTED_ROWS")) {
5762: 		return TableScanType::TABLE_SCAN_COMMITTED_ROWS;
5763: 	}
5764: 	if (StringUtil::Equals(value, "TABLE_SCAN_COMMITTED_ROWS_DISALLOW_UPDATES")) {
5765: 		return TableScanType::TABLE_SCAN_COMMITTED_ROWS_DISALLOW_UPDATES;
5766: 	}
5767: 	if (StringUtil::Equals(value, "TABLE_SCAN_COMMITTED_ROWS_OMIT_PERMANENTLY_DELETED")) {
5768: 		return TableScanType::TABLE_SCAN_COMMITTED_ROWS_OMIT_PERMANENTLY_DELETED;
5769: 	}
5770: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5771: }
5772: 
5773: template<>
5774: const char* EnumUtil::ToChars<TaskExecutionMode>(TaskExecutionMode value) {
5775: 	switch(value) {
5776: 	case TaskExecutionMode::PROCESS_ALL:
5777: 		return "PROCESS_ALL";
5778: 	case TaskExecutionMode::PROCESS_PARTIAL:
5779: 		return "PROCESS_PARTIAL";
5780: 	default:
5781: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5782: 	}
5783: }
5784: 
5785: template<>
5786: TaskExecutionMode EnumUtil::FromString<TaskExecutionMode>(const char *value) {
5787: 	if (StringUtil::Equals(value, "PROCESS_ALL")) {
5788: 		return TaskExecutionMode::PROCESS_ALL;
5789: 	}
5790: 	if (StringUtil::Equals(value, "PROCESS_PARTIAL")) {
5791: 		return TaskExecutionMode::PROCESS_PARTIAL;
5792: 	}
5793: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5794: }
5795: 
5796: template<>
5797: const char* EnumUtil::ToChars<TaskExecutionResult>(TaskExecutionResult value) {
5798: 	switch(value) {
5799: 	case TaskExecutionResult::TASK_FINISHED:
5800: 		return "TASK_FINISHED";
5801: 	case TaskExecutionResult::TASK_NOT_FINISHED:
5802: 		return "TASK_NOT_FINISHED";
5803: 	case TaskExecutionResult::TASK_ERROR:
5804: 		return "TASK_ERROR";
5805: 	case TaskExecutionResult::TASK_BLOCKED:
5806: 		return "TASK_BLOCKED";
5807: 	default:
5808: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5809: 	}
5810: }
5811: 
5812: template<>
5813: TaskExecutionResult EnumUtil::FromString<TaskExecutionResult>(const char *value) {
5814: 	if (StringUtil::Equals(value, "TASK_FINISHED")) {
5815: 		return TaskExecutionResult::TASK_FINISHED;
5816: 	}
5817: 	if (StringUtil::Equals(value, "TASK_NOT_FINISHED")) {
5818: 		return TaskExecutionResult::TASK_NOT_FINISHED;
5819: 	}
5820: 	if (StringUtil::Equals(value, "TASK_ERROR")) {
5821: 		return TaskExecutionResult::TASK_ERROR;
5822: 	}
5823: 	if (StringUtil::Equals(value, "TASK_BLOCKED")) {
5824: 		return TaskExecutionResult::TASK_BLOCKED;
5825: 	}
5826: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5827: }
5828: 
5829: template<>
5830: const char* EnumUtil::ToChars<TimestampCastResult>(TimestampCastResult value) {
5831: 	switch(value) {
5832: 	case TimestampCastResult::SUCCESS:
5833: 		return "SUCCESS";
5834: 	case TimestampCastResult::ERROR_INCORRECT_FORMAT:
5835: 		return "ERROR_INCORRECT_FORMAT";
5836: 	case TimestampCastResult::ERROR_NON_UTC_TIMEZONE:
5837: 		return "ERROR_NON_UTC_TIMEZONE";
5838: 	default:
5839: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5840: 	}
5841: }
5842: 
5843: template<>
5844: TimestampCastResult EnumUtil::FromString<TimestampCastResult>(const char *value) {
5845: 	if (StringUtil::Equals(value, "SUCCESS")) {
5846: 		return TimestampCastResult::SUCCESS;
5847: 	}
5848: 	if (StringUtil::Equals(value, "ERROR_INCORRECT_FORMAT")) {
5849: 		return TimestampCastResult::ERROR_INCORRECT_FORMAT;
5850: 	}
5851: 	if (StringUtil::Equals(value, "ERROR_NON_UTC_TIMEZONE")) {
5852: 		return TimestampCastResult::ERROR_NON_UTC_TIMEZONE;
5853: 	}
5854: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5855: }
5856: 
5857: template<>
5858: const char* EnumUtil::ToChars<TransactionType>(TransactionType value) {
5859: 	switch(value) {
5860: 	case TransactionType::INVALID:
5861: 		return "INVALID";
5862: 	case TransactionType::BEGIN_TRANSACTION:
5863: 		return "BEGIN_TRANSACTION";
5864: 	case TransactionType::COMMIT:
5865: 		return "COMMIT";
5866: 	case TransactionType::ROLLBACK:
5867: 		return "ROLLBACK";
5868: 	default:
5869: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5870: 	}
5871: }
5872: 
5873: template<>
5874: TransactionType EnumUtil::FromString<TransactionType>(const char *value) {
5875: 	if (StringUtil::Equals(value, "INVALID")) {
5876: 		return TransactionType::INVALID;
5877: 	}
5878: 	if (StringUtil::Equals(value, "BEGIN_TRANSACTION")) {
5879: 		return TransactionType::BEGIN_TRANSACTION;
5880: 	}
5881: 	if (StringUtil::Equals(value, "COMMIT")) {
5882: 		return TransactionType::COMMIT;
5883: 	}
5884: 	if (StringUtil::Equals(value, "ROLLBACK")) {
5885: 		return TransactionType::ROLLBACK;
5886: 	}
5887: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5888: }
5889: 
5890: template<>
5891: const char* EnumUtil::ToChars<TupleDataPinProperties>(TupleDataPinProperties value) {
5892: 	switch(value) {
5893: 	case TupleDataPinProperties::INVALID:
5894: 		return "INVALID";
5895: 	case TupleDataPinProperties::KEEP_EVERYTHING_PINNED:
5896: 		return "KEEP_EVERYTHING_PINNED";
5897: 	case TupleDataPinProperties::UNPIN_AFTER_DONE:
5898: 		return "UNPIN_AFTER_DONE";
5899: 	case TupleDataPinProperties::DESTROY_AFTER_DONE:
5900: 		return "DESTROY_AFTER_DONE";
5901: 	case TupleDataPinProperties::ALREADY_PINNED:
5902: 		return "ALREADY_PINNED";
5903: 	default:
5904: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5905: 	}
5906: }
5907: 
5908: template<>
5909: TupleDataPinProperties EnumUtil::FromString<TupleDataPinProperties>(const char *value) {
5910: 	if (StringUtil::Equals(value, "INVALID")) {
5911: 		return TupleDataPinProperties::INVALID;
5912: 	}
5913: 	if (StringUtil::Equals(value, "KEEP_EVERYTHING_PINNED")) {
5914: 		return TupleDataPinProperties::KEEP_EVERYTHING_PINNED;
5915: 	}
5916: 	if (StringUtil::Equals(value, "UNPIN_AFTER_DONE")) {
5917: 		return TupleDataPinProperties::UNPIN_AFTER_DONE;
5918: 	}
5919: 	if (StringUtil::Equals(value, "DESTROY_AFTER_DONE")) {
5920: 		return TupleDataPinProperties::DESTROY_AFTER_DONE;
5921: 	}
5922: 	if (StringUtil::Equals(value, "ALREADY_PINNED")) {
5923: 		return TupleDataPinProperties::ALREADY_PINNED;
5924: 	}
5925: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5926: }
5927: 
5928: template<>
5929: const char* EnumUtil::ToChars<UndoFlags>(UndoFlags value) {
5930: 	switch(value) {
5931: 	case UndoFlags::EMPTY_ENTRY:
5932: 		return "EMPTY_ENTRY";
5933: 	case UndoFlags::CATALOG_ENTRY:
5934: 		return "CATALOG_ENTRY";
5935: 	case UndoFlags::INSERT_TUPLE:
5936: 		return "INSERT_TUPLE";
5937: 	case UndoFlags::DELETE_TUPLE:
5938: 		return "DELETE_TUPLE";
5939: 	case UndoFlags::UPDATE_TUPLE:
5940: 		return "UPDATE_TUPLE";
5941: 	default:
5942: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5943: 	}
5944: }
5945: 
5946: template<>
5947: UndoFlags EnumUtil::FromString<UndoFlags>(const char *value) {
5948: 	if (StringUtil::Equals(value, "EMPTY_ENTRY")) {
5949: 		return UndoFlags::EMPTY_ENTRY;
5950: 	}
5951: 	if (StringUtil::Equals(value, "CATALOG_ENTRY")) {
5952: 		return UndoFlags::CATALOG_ENTRY;
5953: 	}
5954: 	if (StringUtil::Equals(value, "INSERT_TUPLE")) {
5955: 		return UndoFlags::INSERT_TUPLE;
5956: 	}
5957: 	if (StringUtil::Equals(value, "DELETE_TUPLE")) {
5958: 		return UndoFlags::DELETE_TUPLE;
5959: 	}
5960: 	if (StringUtil::Equals(value, "UPDATE_TUPLE")) {
5961: 		return UndoFlags::UPDATE_TUPLE;
5962: 	}
5963: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5964: }
5965: 
5966: template<>
5967: const char* EnumUtil::ToChars<UnionInvalidReason>(UnionInvalidReason value) {
5968: 	switch(value) {
5969: 	case UnionInvalidReason::VALID:
5970: 		return "VALID";
5971: 	case UnionInvalidReason::TAG_OUT_OF_RANGE:
5972: 		return "TAG_OUT_OF_RANGE";
5973: 	case UnionInvalidReason::NO_MEMBERS:
5974: 		return "NO_MEMBERS";
5975: 	case UnionInvalidReason::VALIDITY_OVERLAP:
5976: 		return "VALIDITY_OVERLAP";
5977: 	case UnionInvalidReason::TAG_MISMATCH:
5978: 		return "TAG_MISMATCH";
5979: 	default:
5980: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5981: 	}
5982: }
5983: 
5984: template<>
5985: UnionInvalidReason EnumUtil::FromString<UnionInvalidReason>(const char *value) {
5986: 	if (StringUtil::Equals(value, "VALID")) {
5987: 		return UnionInvalidReason::VALID;
5988: 	}
5989: 	if (StringUtil::Equals(value, "TAG_OUT_OF_RANGE")) {
5990: 		return UnionInvalidReason::TAG_OUT_OF_RANGE;
5991: 	}
5992: 	if (StringUtil::Equals(value, "NO_MEMBERS")) {
5993: 		return UnionInvalidReason::NO_MEMBERS;
5994: 	}
5995: 	if (StringUtil::Equals(value, "VALIDITY_OVERLAP")) {
5996: 		return UnionInvalidReason::VALIDITY_OVERLAP;
5997: 	}
5998: 	if (StringUtil::Equals(value, "TAG_MISMATCH")) {
5999: 		return UnionInvalidReason::TAG_MISMATCH;
6000: 	}
6001: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6002: }
6003: 
6004: template<>
6005: const char* EnumUtil::ToChars<VectorAuxiliaryDataType>(VectorAuxiliaryDataType value) {
6006: 	switch(value) {
6007: 	case VectorAuxiliaryDataType::ARROW_AUXILIARY:
6008: 		return "ARROW_AUXILIARY";
6009: 	default:
6010: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6011: 	}
6012: }
6013: 
6014: template<>
6015: VectorAuxiliaryDataType EnumUtil::FromString<VectorAuxiliaryDataType>(const char *value) {
6016: 	if (StringUtil::Equals(value, "ARROW_AUXILIARY")) {
6017: 		return VectorAuxiliaryDataType::ARROW_AUXILIARY;
6018: 	}
6019: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6020: }
6021: 
6022: template<>
6023: const char* EnumUtil::ToChars<VectorBufferType>(VectorBufferType value) {
6024: 	switch(value) {
6025: 	case VectorBufferType::STANDARD_BUFFER:
6026: 		return "STANDARD_BUFFER";
6027: 	case VectorBufferType::DICTIONARY_BUFFER:
6028: 		return "DICTIONARY_BUFFER";
6029: 	case VectorBufferType::VECTOR_CHILD_BUFFER:
6030: 		return "VECTOR_CHILD_BUFFER";
6031: 	case VectorBufferType::STRING_BUFFER:
6032: 		return "STRING_BUFFER";
6033: 	case VectorBufferType::FSST_BUFFER:
6034: 		return "FSST_BUFFER";
6035: 	case VectorBufferType::STRUCT_BUFFER:
6036: 		return "STRUCT_BUFFER";
6037: 	case VectorBufferType::LIST_BUFFER:
6038: 		return "LIST_BUFFER";
6039: 	case VectorBufferType::MANAGED_BUFFER:
6040: 		return "MANAGED_BUFFER";
6041: 	case VectorBufferType::OPAQUE_BUFFER:
6042: 		return "OPAQUE_BUFFER";
6043: 	default:
6044: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6045: 	}
6046: }
6047: 
6048: template<>
6049: VectorBufferType EnumUtil::FromString<VectorBufferType>(const char *value) {
6050: 	if (StringUtil::Equals(value, "STANDARD_BUFFER")) {
6051: 		return VectorBufferType::STANDARD_BUFFER;
6052: 	}
6053: 	if (StringUtil::Equals(value, "DICTIONARY_BUFFER")) {
6054: 		return VectorBufferType::DICTIONARY_BUFFER;
6055: 	}
6056: 	if (StringUtil::Equals(value, "VECTOR_CHILD_BUFFER")) {
6057: 		return VectorBufferType::VECTOR_CHILD_BUFFER;
6058: 	}
6059: 	if (StringUtil::Equals(value, "STRING_BUFFER")) {
6060: 		return VectorBufferType::STRING_BUFFER;
6061: 	}
6062: 	if (StringUtil::Equals(value, "FSST_BUFFER")) {
6063: 		return VectorBufferType::FSST_BUFFER;
6064: 	}
6065: 	if (StringUtil::Equals(value, "STRUCT_BUFFER")) {
6066: 		return VectorBufferType::STRUCT_BUFFER;
6067: 	}
6068: 	if (StringUtil::Equals(value, "LIST_BUFFER")) {
6069: 		return VectorBufferType::LIST_BUFFER;
6070: 	}
6071: 	if (StringUtil::Equals(value, "MANAGED_BUFFER")) {
6072: 		return VectorBufferType::MANAGED_BUFFER;
6073: 	}
6074: 	if (StringUtil::Equals(value, "OPAQUE_BUFFER")) {
6075: 		return VectorBufferType::OPAQUE_BUFFER;
6076: 	}
6077: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6078: }
6079: 
6080: template<>
6081: const char* EnumUtil::ToChars<VectorType>(VectorType value) {
6082: 	switch(value) {
6083: 	case VectorType::FLAT_VECTOR:
6084: 		return "FLAT_VECTOR";
6085: 	case VectorType::FSST_VECTOR:
6086: 		return "FSST_VECTOR";
6087: 	case VectorType::CONSTANT_VECTOR:
6088: 		return "CONSTANT_VECTOR";
6089: 	case VectorType::DICTIONARY_VECTOR:
6090: 		return "DICTIONARY_VECTOR";
6091: 	case VectorType::SEQUENCE_VECTOR:
6092: 		return "SEQUENCE_VECTOR";
6093: 	default:
6094: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6095: 	}
6096: }
6097: 
6098: template<>
6099: VectorType EnumUtil::FromString<VectorType>(const char *value) {
6100: 	if (StringUtil::Equals(value, "FLAT_VECTOR")) {
6101: 		return VectorType::FLAT_VECTOR;
6102: 	}
6103: 	if (StringUtil::Equals(value, "FSST_VECTOR")) {
6104: 		return VectorType::FSST_VECTOR;
6105: 	}
6106: 	if (StringUtil::Equals(value, "CONSTANT_VECTOR")) {
6107: 		return VectorType::CONSTANT_VECTOR;
6108: 	}
6109: 	if (StringUtil::Equals(value, "DICTIONARY_VECTOR")) {
6110: 		return VectorType::DICTIONARY_VECTOR;
6111: 	}
6112: 	if (StringUtil::Equals(value, "SEQUENCE_VECTOR")) {
6113: 		return VectorType::SEQUENCE_VECTOR;
6114: 	}
6115: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6116: }
6117: 
6118: template<>
6119: const char* EnumUtil::ToChars<VerificationType>(VerificationType value) {
6120: 	switch(value) {
6121: 	case VerificationType::ORIGINAL:
6122: 		return "ORIGINAL";
6123: 	case VerificationType::COPIED:
6124: 		return "COPIED";
6125: 	case VerificationType::DESERIALIZED:
6126: 		return "DESERIALIZED";
6127: 	case VerificationType::PARSED:
6128: 		return "PARSED";
6129: 	case VerificationType::UNOPTIMIZED:
6130: 		return "UNOPTIMIZED";
6131: 	case VerificationType::NO_OPERATOR_CACHING:
6132: 		return "NO_OPERATOR_CACHING";
6133: 	case VerificationType::PREPARED:
6134: 		return "PREPARED";
6135: 	case VerificationType::EXTERNAL:
6136: 		return "EXTERNAL";
6137: 	case VerificationType::INVALID:
6138: 		return "INVALID";
6139: 	default:
6140: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6141: 	}
6142: }
6143: 
6144: template<>
6145: VerificationType EnumUtil::FromString<VerificationType>(const char *value) {
6146: 	if (StringUtil::Equals(value, "ORIGINAL")) {
6147: 		return VerificationType::ORIGINAL;
6148: 	}
6149: 	if (StringUtil::Equals(value, "COPIED")) {
6150: 		return VerificationType::COPIED;
6151: 	}
6152: 	if (StringUtil::Equals(value, "DESERIALIZED")) {
6153: 		return VerificationType::DESERIALIZED;
6154: 	}
6155: 	if (StringUtil::Equals(value, "PARSED")) {
6156: 		return VerificationType::PARSED;
6157: 	}
6158: 	if (StringUtil::Equals(value, "UNOPTIMIZED")) {
6159: 		return VerificationType::UNOPTIMIZED;
6160: 	}
6161: 	if (StringUtil::Equals(value, "NO_OPERATOR_CACHING")) {
6162: 		return VerificationType::NO_OPERATOR_CACHING;
6163: 	}
6164: 	if (StringUtil::Equals(value, "PREPARED")) {
6165: 		return VerificationType::PREPARED;
6166: 	}
6167: 	if (StringUtil::Equals(value, "EXTERNAL")) {
6168: 		return VerificationType::EXTERNAL;
6169: 	}
6170: 	if (StringUtil::Equals(value, "INVALID")) {
6171: 		return VerificationType::INVALID;
6172: 	}
6173: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6174: }
6175: 
6176: template<>
6177: const char* EnumUtil::ToChars<VerifyExistenceType>(VerifyExistenceType value) {
6178: 	switch(value) {
6179: 	case VerifyExistenceType::APPEND:
6180: 		return "APPEND";
6181: 	case VerifyExistenceType::APPEND_FK:
6182: 		return "APPEND_FK";
6183: 	case VerifyExistenceType::DELETE_FK:
6184: 		return "DELETE_FK";
6185: 	default:
6186: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6187: 	}
6188: }
6189: 
6190: template<>
6191: VerifyExistenceType EnumUtil::FromString<VerifyExistenceType>(const char *value) {
6192: 	if (StringUtil::Equals(value, "APPEND")) {
6193: 		return VerifyExistenceType::APPEND;
6194: 	}
6195: 	if (StringUtil::Equals(value, "APPEND_FK")) {
6196: 		return VerifyExistenceType::APPEND_FK;
6197: 	}
6198: 	if (StringUtil::Equals(value, "DELETE_FK")) {
6199: 		return VerifyExistenceType::DELETE_FK;
6200: 	}
6201: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6202: }
6203: 
6204: template<>
6205: const char* EnumUtil::ToChars<WALType>(WALType value) {
6206: 	switch(value) {
6207: 	case WALType::INVALID:
6208: 		return "INVALID";
6209: 	case WALType::CREATE_TABLE:
6210: 		return "CREATE_TABLE";
6211: 	case WALType::DROP_TABLE:
6212: 		return "DROP_TABLE";
6213: 	case WALType::CREATE_SCHEMA:
6214: 		return "CREATE_SCHEMA";
6215: 	case WALType::DROP_SCHEMA:
6216: 		return "DROP_SCHEMA";
6217: 	case WALType::CREATE_VIEW:
6218: 		return "CREATE_VIEW";
6219: 	case WALType::DROP_VIEW:
6220: 		return "DROP_VIEW";
6221: 	case WALType::CREATE_SEQUENCE:
6222: 		return "CREATE_SEQUENCE";
6223: 	case WALType::DROP_SEQUENCE:
6224: 		return "DROP_SEQUENCE";
6225: 	case WALType::SEQUENCE_VALUE:
6226: 		return "SEQUENCE_VALUE";
6227: 	case WALType::CREATE_MACRO:
6228: 		return "CREATE_MACRO";
6229: 	case WALType::DROP_MACRO:
6230: 		return "DROP_MACRO";
6231: 	case WALType::CREATE_TYPE:
6232: 		return "CREATE_TYPE";
6233: 	case WALType::DROP_TYPE:
6234: 		return "DROP_TYPE";
6235: 	case WALType::ALTER_INFO:
6236: 		return "ALTER_INFO";
6237: 	case WALType::CREATE_TABLE_MACRO:
6238: 		return "CREATE_TABLE_MACRO";
6239: 	case WALType::DROP_TABLE_MACRO:
6240: 		return "DROP_TABLE_MACRO";
6241: 	case WALType::CREATE_INDEX:
6242: 		return "CREATE_INDEX";
6243: 	case WALType::DROP_INDEX:
6244: 		return "DROP_INDEX";
6245: 	case WALType::USE_TABLE:
6246: 		return "USE_TABLE";
6247: 	case WALType::INSERT_TUPLE:
6248: 		return "INSERT_TUPLE";
6249: 	case WALType::DELETE_TUPLE:
6250: 		return "DELETE_TUPLE";
6251: 	case WALType::UPDATE_TUPLE:
6252: 		return "UPDATE_TUPLE";
6253: 	case WALType::CHECKPOINT:
6254: 		return "CHECKPOINT";
6255: 	case WALType::WAL_FLUSH:
6256: 		return "WAL_FLUSH";
6257: 	default:
6258: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6259: 	}
6260: }
6261: 
6262: template<>
6263: WALType EnumUtil::FromString<WALType>(const char *value) {
6264: 	if (StringUtil::Equals(value, "INVALID")) {
6265: 		return WALType::INVALID;
6266: 	}
6267: 	if (StringUtil::Equals(value, "CREATE_TABLE")) {
6268: 		return WALType::CREATE_TABLE;
6269: 	}
6270: 	if (StringUtil::Equals(value, "DROP_TABLE")) {
6271: 		return WALType::DROP_TABLE;
6272: 	}
6273: 	if (StringUtil::Equals(value, "CREATE_SCHEMA")) {
6274: 		return WALType::CREATE_SCHEMA;
6275: 	}
6276: 	if (StringUtil::Equals(value, "DROP_SCHEMA")) {
6277: 		return WALType::DROP_SCHEMA;
6278: 	}
6279: 	if (StringUtil::Equals(value, "CREATE_VIEW")) {
6280: 		return WALType::CREATE_VIEW;
6281: 	}
6282: 	if (StringUtil::Equals(value, "DROP_VIEW")) {
6283: 		return WALType::DROP_VIEW;
6284: 	}
6285: 	if (StringUtil::Equals(value, "CREATE_SEQUENCE")) {
6286: 		return WALType::CREATE_SEQUENCE;
6287: 	}
6288: 	if (StringUtil::Equals(value, "DROP_SEQUENCE")) {
6289: 		return WALType::DROP_SEQUENCE;
6290: 	}
6291: 	if (StringUtil::Equals(value, "SEQUENCE_VALUE")) {
6292: 		return WALType::SEQUENCE_VALUE;
6293: 	}
6294: 	if (StringUtil::Equals(value, "CREATE_MACRO")) {
6295: 		return WALType::CREATE_MACRO;
6296: 	}
6297: 	if (StringUtil::Equals(value, "DROP_MACRO")) {
6298: 		return WALType::DROP_MACRO;
6299: 	}
6300: 	if (StringUtil::Equals(value, "CREATE_TYPE")) {
6301: 		return WALType::CREATE_TYPE;
6302: 	}
6303: 	if (StringUtil::Equals(value, "DROP_TYPE")) {
6304: 		return WALType::DROP_TYPE;
6305: 	}
6306: 	if (StringUtil::Equals(value, "ALTER_INFO")) {
6307: 		return WALType::ALTER_INFO;
6308: 	}
6309: 	if (StringUtil::Equals(value, "CREATE_TABLE_MACRO")) {
6310: 		return WALType::CREATE_TABLE_MACRO;
6311: 	}
6312: 	if (StringUtil::Equals(value, "DROP_TABLE_MACRO")) {
6313: 		return WALType::DROP_TABLE_MACRO;
6314: 	}
6315: 	if (StringUtil::Equals(value, "CREATE_INDEX")) {
6316: 		return WALType::CREATE_INDEX;
6317: 	}
6318: 	if (StringUtil::Equals(value, "DROP_INDEX")) {
6319: 		return WALType::DROP_INDEX;
6320: 	}
6321: 	if (StringUtil::Equals(value, "USE_TABLE")) {
6322: 		return WALType::USE_TABLE;
6323: 	}
6324: 	if (StringUtil::Equals(value, "INSERT_TUPLE")) {
6325: 		return WALType::INSERT_TUPLE;
6326: 	}
6327: 	if (StringUtil::Equals(value, "DELETE_TUPLE")) {
6328: 		return WALType::DELETE_TUPLE;
6329: 	}
6330: 	if (StringUtil::Equals(value, "UPDATE_TUPLE")) {
6331: 		return WALType::UPDATE_TUPLE;
6332: 	}
6333: 	if (StringUtil::Equals(value, "CHECKPOINT")) {
6334: 		return WALType::CHECKPOINT;
6335: 	}
6336: 	if (StringUtil::Equals(value, "WAL_FLUSH")) {
6337: 		return WALType::WAL_FLUSH;
6338: 	}
6339: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6340: }
6341: 
6342: template<>
6343: const char* EnumUtil::ToChars<WindowAggregationMode>(WindowAggregationMode value) {
6344: 	switch(value) {
6345: 	case WindowAggregationMode::WINDOW:
6346: 		return "WINDOW";
6347: 	case WindowAggregationMode::COMBINE:
6348: 		return "COMBINE";
6349: 	case WindowAggregationMode::SEPARATE:
6350: 		return "SEPARATE";
6351: 	default:
6352: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6353: 	}
6354: }
6355: 
6356: template<>
6357: WindowAggregationMode EnumUtil::FromString<WindowAggregationMode>(const char *value) {
6358: 	if (StringUtil::Equals(value, "WINDOW")) {
6359: 		return WindowAggregationMode::WINDOW;
6360: 	}
6361: 	if (StringUtil::Equals(value, "COMBINE")) {
6362: 		return WindowAggregationMode::COMBINE;
6363: 	}
6364: 	if (StringUtil::Equals(value, "SEPARATE")) {
6365: 		return WindowAggregationMode::SEPARATE;
6366: 	}
6367: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6368: }
6369: 
6370: template<>
6371: const char* EnumUtil::ToChars<WindowBoundary>(WindowBoundary value) {
6372: 	switch(value) {
6373: 	case WindowBoundary::INVALID:
6374: 		return "INVALID";
6375: 	case WindowBoundary::UNBOUNDED_PRECEDING:
6376: 		return "UNBOUNDED_PRECEDING";
6377: 	case WindowBoundary::UNBOUNDED_FOLLOWING:
6378: 		return "UNBOUNDED_FOLLOWING";
6379: 	case WindowBoundary::CURRENT_ROW_RANGE:
6380: 		return "CURRENT_ROW_RANGE";
6381: 	case WindowBoundary::CURRENT_ROW_ROWS:
6382: 		return "CURRENT_ROW_ROWS";
6383: 	case WindowBoundary::EXPR_PRECEDING_ROWS:
6384: 		return "EXPR_PRECEDING_ROWS";
6385: 	case WindowBoundary::EXPR_FOLLOWING_ROWS:
6386: 		return "EXPR_FOLLOWING_ROWS";
6387: 	case WindowBoundary::EXPR_PRECEDING_RANGE:
6388: 		return "EXPR_PRECEDING_RANGE";
6389: 	case WindowBoundary::EXPR_FOLLOWING_RANGE:
6390: 		return "EXPR_FOLLOWING_RANGE";
6391: 	default:
6392: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6393: 	}
6394: }
6395: 
6396: template<>
6397: WindowBoundary EnumUtil::FromString<WindowBoundary>(const char *value) {
6398: 	if (StringUtil::Equals(value, "INVALID")) {
6399: 		return WindowBoundary::INVALID;
6400: 	}
6401: 	if (StringUtil::Equals(value, "UNBOUNDED_PRECEDING")) {
6402: 		return WindowBoundary::UNBOUNDED_PRECEDING;
6403: 	}
6404: 	if (StringUtil::Equals(value, "UNBOUNDED_FOLLOWING")) {
6405: 		return WindowBoundary::UNBOUNDED_FOLLOWING;
6406: 	}
6407: 	if (StringUtil::Equals(value, "CURRENT_ROW_RANGE")) {
6408: 		return WindowBoundary::CURRENT_ROW_RANGE;
6409: 	}
6410: 	if (StringUtil::Equals(value, "CURRENT_ROW_ROWS")) {
6411: 		return WindowBoundary::CURRENT_ROW_ROWS;
6412: 	}
6413: 	if (StringUtil::Equals(value, "EXPR_PRECEDING_ROWS")) {
6414: 		return WindowBoundary::EXPR_PRECEDING_ROWS;
6415: 	}
6416: 	if (StringUtil::Equals(value, "EXPR_FOLLOWING_ROWS")) {
6417: 		return WindowBoundary::EXPR_FOLLOWING_ROWS;
6418: 	}
6419: 	if (StringUtil::Equals(value, "EXPR_PRECEDING_RANGE")) {
6420: 		return WindowBoundary::EXPR_PRECEDING_RANGE;
6421: 	}
6422: 	if (StringUtil::Equals(value, "EXPR_FOLLOWING_RANGE")) {
6423: 		return WindowBoundary::EXPR_FOLLOWING_RANGE;
6424: 	}
6425: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6426: }
6427: 
6428: }
6429: 
[end of src/common/enum_util.cpp]
[start of src/core_functions/scalar/date/date_part.cpp]
1: #include "duckdb/core_functions/scalar/date_functions.hpp"
2: #include "duckdb/common/case_insensitive_map.hpp"
3: #include "duckdb/common/enums/date_part_specifier.hpp"
4: #include "duckdb/common/exception.hpp"
5: #include "duckdb/common/string_util.hpp"
6: #include "duckdb/common/enum_util.hpp"
7: #include "duckdb/common/types/date.hpp"
8: #include "duckdb/common/types/timestamp.hpp"
9: #include "duckdb/common/vector_operations/vector_operations.hpp"
10: #include "duckdb/execution/expression_executor.hpp"
11: #include "duckdb/function/scalar/nested_functions.hpp"
12: #include "duckdb/planner/expression/bound_function_expression.hpp"
13: 
14: namespace duckdb {
15: 
16: DatePartSpecifier GetDateTypePartSpecifier(const string &specifier, LogicalType &type) {
17: 	const auto part = GetDatePartSpecifier(specifier);
18: 	switch (type.id()) {
19: 	case LogicalType::TIMESTAMP:
20: 	case LogicalType::TIMESTAMP_TZ:
21: 		return part;
22: 	case LogicalType::DATE:
23: 		switch (part) {
24: 		case DatePartSpecifier::YEAR:
25: 		case DatePartSpecifier::MONTH:
26: 		case DatePartSpecifier::DAY:
27: 		case DatePartSpecifier::DECADE:
28: 		case DatePartSpecifier::CENTURY:
29: 		case DatePartSpecifier::MILLENNIUM:
30: 		case DatePartSpecifier::DOW:
31: 		case DatePartSpecifier::ISODOW:
32: 		case DatePartSpecifier::ISOYEAR:
33: 		case DatePartSpecifier::WEEK:
34: 		case DatePartSpecifier::QUARTER:
35: 		case DatePartSpecifier::DOY:
36: 		case DatePartSpecifier::YEARWEEK:
37: 		case DatePartSpecifier::ERA:
38: 		case DatePartSpecifier::JULIAN_DAY:
39: 			return part;
40: 		default:
41: 			break;
42: 		}
43: 		break;
44: 	case LogicalType::TIME:
45: 		switch (part) {
46: 		case DatePartSpecifier::MICROSECONDS:
47: 		case DatePartSpecifier::MILLISECONDS:
48: 		case DatePartSpecifier::SECOND:
49: 		case DatePartSpecifier::MINUTE:
50: 		case DatePartSpecifier::HOUR:
51: 		case DatePartSpecifier::EPOCH:
52: 		case DatePartSpecifier::TIMEZONE:
53: 		case DatePartSpecifier::TIMEZONE_HOUR:
54: 		case DatePartSpecifier::TIMEZONE_MINUTE:
55: 			return part;
56: 		default:
57: 			break;
58: 		}
59: 		break;
60: 	case LogicalType::INTERVAL:
61: 		switch (part) {
62: 		case DatePartSpecifier::YEAR:
63: 		case DatePartSpecifier::MONTH:
64: 		case DatePartSpecifier::DAY:
65: 		case DatePartSpecifier::DECADE:
66: 		case DatePartSpecifier::CENTURY:
67: 		case DatePartSpecifier::QUARTER:
68: 		case DatePartSpecifier::MILLENNIUM:
69: 		case DatePartSpecifier::MICROSECONDS:
70: 		case DatePartSpecifier::MILLISECONDS:
71: 		case DatePartSpecifier::SECOND:
72: 		case DatePartSpecifier::MINUTE:
73: 		case DatePartSpecifier::HOUR:
74: 		case DatePartSpecifier::EPOCH:
75: 			return part;
76: 		default:
77: 			break;
78: 		}
79: 		break;
80: 	default:
81: 		break;
82: 	}
83: 
84: 	throw NotImplementedException("\"%s\" units \"%s\" not recognized", EnumUtil::ToString(type.id()), specifier);
85: }
86: 
87: template <int64_t MIN, int64_t MAX>
88: static unique_ptr<BaseStatistics> PropagateSimpleDatePartStatistics(vector<BaseStatistics> &child_stats) {
89: 	// we can always propagate simple date part statistics
90: 	// since the min and max can never exceed these bounds
91: 	auto result = NumericStats::CreateEmpty(LogicalType::BIGINT);
92: 	result.CopyValidity(child_stats[0]);
93: 	NumericStats::SetMin(result, Value::BIGINT(MIN));
94: 	NumericStats::SetMax(result, Value::BIGINT(MAX));
95: 	return result.ToUnique();
96: }
97: 
98: struct DatePart {
99: 	template <class T, class OP, class TR = int64_t>
100: 	static unique_ptr<BaseStatistics> PropagateDatePartStatistics(vector<BaseStatistics> &child_stats,
101: 	                                                              const LogicalType &stats_type = LogicalType::BIGINT) {
102: 		// we can only propagate complex date part stats if the child has stats
103: 		auto &nstats = child_stats[0];
104: 		if (!NumericStats::HasMinMax(nstats)) {
105: 			return nullptr;
106: 		}
107: 		// run the operator on both the min and the max, this gives us the [min, max] bound
108: 		auto min = NumericStats::GetMin<T>(nstats);
109: 		auto max = NumericStats::GetMax<T>(nstats);
110: 		if (min > max) {
111: 			return nullptr;
112: 		}
113: 		// Infinities prevent us from computing generic ranges
114: 		if (!Value::IsFinite(min) || !Value::IsFinite(max)) {
115: 			return nullptr;
116: 		}
117: 		TR min_part = OP::template Operation<T, TR>(min);
118: 		TR max_part = OP::template Operation<T, TR>(max);
119: 		auto result = NumericStats::CreateEmpty(stats_type);
120: 		NumericStats::SetMin(result, Value(min_part));
121: 		NumericStats::SetMax(result, Value(max_part));
122: 		result.CopyValidity(child_stats[0]);
123: 		return result.ToUnique();
124: 	}
125: 
126: 	template <typename OP>
127: 	struct PartOperator {
128: 		template <class TA, class TR>
129: 		static inline TR Operation(TA input, ValidityMask &mask, idx_t idx, void *dataptr) {
130: 			if (Value::IsFinite(input)) {
131: 				return OP::template Operation<TA, TR>(input);
132: 			} else {
133: 				mask.SetInvalid(idx);
134: 				return TR();
135: 			}
136: 		}
137: 	};
138: 
139: 	template <class TA, class TR, class OP>
140: 	static void UnaryFunction(DataChunk &input, ExpressionState &state, Vector &result) {
141: 		D_ASSERT(input.ColumnCount() >= 1);
142: 		using IOP = PartOperator<OP>;
143: 		UnaryExecutor::GenericExecute<TA, TR, IOP>(input.data[0], result, input.size(), nullptr, true);
144: 	}
145: 
146: 	struct YearOperator {
147: 		template <class TA, class TR>
148: 		static inline TR Operation(TA input) {
149: 			return Date::ExtractYear(input);
150: 		}
151: 
152: 		template <class T>
153: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
154: 			return PropagateDatePartStatistics<T, YearOperator>(input.child_stats);
155: 		}
156: 	};
157: 
158: 	struct MonthOperator {
159: 		template <class TA, class TR>
160: 		static inline TR Operation(TA input) {
161: 			return Date::ExtractMonth(input);
162: 		}
163: 
164: 		template <class T>
165: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
166: 			// min/max of month operator is [1, 12]
167: 			return PropagateSimpleDatePartStatistics<1, 12>(input.child_stats);
168: 		}
169: 	};
170: 
171: 	struct DayOperator {
172: 		template <class TA, class TR>
173: 		static inline TR Operation(TA input) {
174: 			return Date::ExtractDay(input);
175: 		}
176: 
177: 		template <class T>
178: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
179: 			// min/max of day operator is [1, 31]
180: 			return PropagateSimpleDatePartStatistics<1, 31>(input.child_stats);
181: 		}
182: 	};
183: 
184: 	struct DecadeOperator {
185: 		// From the PG docs: "The year field divided by 10"
186: 		template <typename TR>
187: 		static inline TR DecadeFromYear(TR yyyy) {
188: 			return yyyy / 10;
189: 		}
190: 
191: 		template <class TA, class TR>
192: 		static inline TR Operation(TA input) {
193: 			return DecadeFromYear(YearOperator::Operation<TA, TR>(input));
194: 		}
195: 
196: 		template <class T>
197: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
198: 			return PropagateDatePartStatistics<T, DecadeOperator>(input.child_stats);
199: 		}
200: 	};
201: 
202: 	struct CenturyOperator {
203: 		// From the PG docs:
204: 		// "The first century starts at 0001-01-01 00:00:00 AD, although they did not know it at the time.
205: 		// This definition applies to all Gregorian calendar countries.
206: 		// There is no century number 0, you go from -1 century to 1 century.
207: 		// If you disagree with this, please write your complaint to: Pope, Cathedral Saint-Peter of Roma, Vatican."
208: 		// (To be fair, His Holiness had nothing to do with this -
209: 		// it was the lack of zero in the counting systems of the time...)
210: 		template <typename TR>
211: 		static inline TR CenturyFromYear(TR yyyy) {
212: 			if (yyyy > 0) {
213: 				return ((yyyy - 1) / 100) + 1;
214: 			} else {
215: 				return (yyyy / 100) - 1;
216: 			}
217: 		}
218: 
219: 		template <class TA, class TR>
220: 		static inline TR Operation(TA input) {
221: 			return CenturyFromYear(YearOperator::Operation<TA, TR>(input));
222: 		}
223: 
224: 		template <class T>
225: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
226: 			return PropagateDatePartStatistics<T, CenturyOperator>(input.child_stats);
227: 		}
228: 	};
229: 
230: 	struct MillenniumOperator {
231: 		// See the century comment
232: 		template <typename TR>
233: 		static inline TR MillenniumFromYear(TR yyyy) {
234: 			if (yyyy > 0) {
235: 				return ((yyyy - 1) / 1000) + 1;
236: 			} else {
237: 				return (yyyy / 1000) - 1;
238: 			}
239: 		}
240: 
241: 		template <class TA, class TR>
242: 		static inline TR Operation(TA input) {
243: 			return MillenniumFromYear<TR>(YearOperator::Operation<TA, TR>(input));
244: 		}
245: 
246: 		template <class T>
247: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
248: 			return PropagateDatePartStatistics<T, MillenniumOperator>(input.child_stats);
249: 		}
250: 	};
251: 
252: 	struct QuarterOperator {
253: 		template <class TR>
254: 		static inline TR QuarterFromMonth(TR mm) {
255: 			return (mm - 1) / Interval::MONTHS_PER_QUARTER + 1;
256: 		}
257: 
258: 		template <class TA, class TR>
259: 		static inline TR Operation(TA input) {
260: 			return QuarterFromMonth(Date::ExtractMonth(input));
261: 		}
262: 
263: 		template <class T>
264: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
265: 			// min/max of quarter operator is [1, 4]
266: 			return PropagateSimpleDatePartStatistics<1, 4>(input.child_stats);
267: 		}
268: 	};
269: 
270: 	struct DayOfWeekOperator {
271: 		template <class TR>
272: 		static inline TR DayOfWeekFromISO(TR isodow) {
273: 			// day of the week (Sunday = 0, Saturday = 6)
274: 			// turn sunday into 0 by doing mod 7
275: 			return isodow % 7;
276: 		}
277: 
278: 		template <class TA, class TR>
279: 		static inline TR Operation(TA input) {
280: 			return DayOfWeekFromISO(Date::ExtractISODayOfTheWeek(input));
281: 		}
282: 
283: 		template <class T>
284: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
285: 			return PropagateSimpleDatePartStatistics<0, 6>(input.child_stats);
286: 		}
287: 	};
288: 
289: 	struct ISODayOfWeekOperator {
290: 		template <class TA, class TR>
291: 		static inline TR Operation(TA input) {
292: 			// isodow (Monday = 1, Sunday = 7)
293: 			return Date::ExtractISODayOfTheWeek(input);
294: 		}
295: 
296: 		template <class T>
297: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
298: 			return PropagateSimpleDatePartStatistics<1, 7>(input.child_stats);
299: 		}
300: 	};
301: 
302: 	struct DayOfYearOperator {
303: 		template <class TA, class TR>
304: 		static inline TR Operation(TA input) {
305: 			return Date::ExtractDayOfTheYear(input);
306: 		}
307: 
308: 		template <class T>
309: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
310: 			return PropagateSimpleDatePartStatistics<1, 366>(input.child_stats);
311: 		}
312: 	};
313: 
314: 	struct WeekOperator {
315: 		template <class TA, class TR>
316: 		static inline TR Operation(TA input) {
317: 			return Date::ExtractISOWeekNumber(input);
318: 		}
319: 
320: 		template <class T>
321: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
322: 			return PropagateSimpleDatePartStatistics<1, 54>(input.child_stats);
323: 		}
324: 	};
325: 
326: 	struct ISOYearOperator {
327: 		template <class TA, class TR>
328: 		static inline TR Operation(TA input) {
329: 			return Date::ExtractISOYearNumber(input);
330: 		}
331: 
332: 		template <class T>
333: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
334: 			return PropagateDatePartStatistics<T, ISOYearOperator>(input.child_stats);
335: 		}
336: 	};
337: 
338: 	struct YearWeekOperator {
339: 		template <class TR>
340: 		static inline TR YearWeekFromParts(TR yyyy, TR ww) {
341: 			return yyyy * 100 + ((yyyy > 0) ? ww : -ww);
342: 		}
343: 
344: 		template <class TA, class TR>
345: 		static inline TR Operation(TA input) {
346: 			int32_t yyyy, ww;
347: 			Date::ExtractISOYearWeek(input, yyyy, ww);
348: 			return YearWeekFromParts(yyyy, ww);
349: 		}
350: 
351: 		template <class T>
352: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
353: 			return PropagateDatePartStatistics<T, YearWeekOperator>(input.child_stats);
354: 		}
355: 	};
356: 
357: 	struct EpochNanosecondsOperator {
358: 		template <class TA, class TR>
359: 		static inline TR Operation(TA input) {
360: 			return input.micros * Interval::NANOS_PER_MICRO;
361: 		}
362: 
363: 		template <class T>
364: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
365: 			return PropagateDatePartStatistics<T, EpochNanosecondsOperator>(input.child_stats);
366: 		}
367: 	};
368: 
369: 	struct EpochMicrosecondsOperator {
370: 		template <class TA, class TR>
371: 		static inline TR Operation(TA input) {
372: 			return input.micros;
373: 		}
374: 
375: 		template <class T>
376: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
377: 			return PropagateDatePartStatistics<T, EpochMicrosecondsOperator>(input.child_stats);
378: 		}
379: 	};
380: 
381: 	struct EpochMillisOperator {
382: 		template <class TA, class TR>
383: 		static inline TR Operation(TA input) {
384: 			return input.micros / Interval::MICROS_PER_MSEC;
385: 		}
386: 
387: 		template <class T>
388: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
389: 			return PropagateDatePartStatistics<T, EpochMillisOperator>(input.child_stats);
390: 		}
391: 
392: 		static void Inverse(DataChunk &input, ExpressionState &state, Vector &result) {
393: 			D_ASSERT(input.ColumnCount() == 1);
394: 
395: 			UnaryExecutor::Execute<int64_t, timestamp_t>(input.data[0], result, input.size(),
396: 			                                             [&](int64_t input) { return Timestamp::FromEpochMs(input); });
397: 		}
398: 	};
399: 
400: 	struct MicrosecondsOperator {
401: 		template <class TA, class TR>
402: 		static inline TR Operation(TA input) {
403: 			return 0;
404: 		}
405: 
406: 		template <class T>
407: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
408: 			return PropagateSimpleDatePartStatistics<0, 60000000>(input.child_stats);
409: 		}
410: 	};
411: 
412: 	struct MillisecondsOperator {
413: 		template <class TA, class TR>
414: 		static inline TR Operation(TA input) {
415: 			return 0;
416: 		}
417: 
418: 		template <class T>
419: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
420: 			return PropagateSimpleDatePartStatistics<0, 60000>(input.child_stats);
421: 		}
422: 	};
423: 
424: 	struct SecondsOperator {
425: 		template <class TA, class TR>
426: 		static inline TR Operation(TA input) {
427: 			return 0;
428: 		}
429: 
430: 		template <class T>
431: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
432: 			return PropagateSimpleDatePartStatistics<0, 60>(input.child_stats);
433: 		}
434: 	};
435: 
436: 	struct MinutesOperator {
437: 		template <class TA, class TR>
438: 		static inline TR Operation(TA input) {
439: 			return 0;
440: 		}
441: 
442: 		template <class T>
443: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
444: 			return PropagateSimpleDatePartStatistics<0, 60>(input.child_stats);
445: 		}
446: 	};
447: 
448: 	struct HoursOperator {
449: 		template <class TA, class TR>
450: 		static inline TR Operation(TA input) {
451: 			return 0;
452: 		}
453: 
454: 		template <class T>
455: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
456: 			return PropagateSimpleDatePartStatistics<0, 24>(input.child_stats);
457: 		}
458: 	};
459: 
460: 	struct EpochOperator {
461: 		template <class TA, class TR>
462: 		static inline TR Operation(TA input) {
463: 			return Date::Epoch(input);
464: 		}
465: 
466: 		template <class T>
467: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
468: 			return PropagateDatePartStatistics<T, EpochOperator>(input.child_stats);
469: 		}
470: 	};
471: 
472: 	struct EraOperator {
473: 		template <class TR>
474: 		static inline TR EraFromYear(TR yyyy) {
475: 			return yyyy > 0 ? 1 : 0;
476: 		}
477: 
478: 		template <class TA, class TR>
479: 		static inline TR Operation(TA input) {
480: 			return EraFromYear(Date::ExtractYear(input));
481: 		}
482: 
483: 		template <class T>
484: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
485: 			return PropagateSimpleDatePartStatistics<0, 1>(input.child_stats);
486: 		}
487: 	};
488: 
489: 	struct TimezoneOperator {
490: 		template <class TA, class TR>
491: 		static inline TR Operation(TA input) {
492: 			// Regular timestamps are UTC.
493: 			return 0;
494: 		}
495: 
496: 		template <class T>
497: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
498: 			return PropagateSimpleDatePartStatistics<0, 0>(input.child_stats);
499: 		}
500: 	};
501: 
502: 	struct JulianDayOperator {
503: 		template <class TA, class TR>
504: 		static inline TR Operation(TA input) {
505: 			return Timestamp::GetJulianDay(input);
506: 		}
507: 
508: 		template <class T>
509: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {
510: 			return PropagateDatePartStatistics<T, JulianDayOperator, double>(input.child_stats, LogicalType::DOUBLE);
511: 		}
512: 	};
513: 
514: 	// These are all zero and have the same restrictions
515: 	using TimezoneHourOperator = TimezoneOperator;
516: 	using TimezoneMinuteOperator = TimezoneOperator;
517: 
518: 	struct StructOperator {
519: 		using part_codes_t = vector<DatePartSpecifier>;
520: 		using part_mask_t = uint64_t;
521: 
522: 		enum MaskBits : uint8_t {
523: 			YMD = 1 << 0,
524: 			DOW = 1 << 1,
525: 			DOY = 1 << 2,
526: 			EPOCH = 1 << 3,
527: 			TIME = 1 << 4,
528: 			ZONE = 1 << 5,
529: 			ISO = 1 << 6,
530: 			JD = 1 << 7
531: 		};
532: 
533: 		static part_mask_t GetMask(const part_codes_t &part_codes) {
534: 			part_mask_t mask = 0;
535: 			for (const auto &part_code : part_codes) {
536: 				switch (part_code) {
537: 				case DatePartSpecifier::YEAR:
538: 				case DatePartSpecifier::MONTH:
539: 				case DatePartSpecifier::DAY:
540: 				case DatePartSpecifier::DECADE:
541: 				case DatePartSpecifier::CENTURY:
542: 				case DatePartSpecifier::MILLENNIUM:
543: 				case DatePartSpecifier::QUARTER:
544: 				case DatePartSpecifier::ERA:
545: 					mask |= YMD;
546: 					break;
547: 				case DatePartSpecifier::YEARWEEK:
548: 				case DatePartSpecifier::WEEK:
549: 				case DatePartSpecifier::ISOYEAR:
550: 					mask |= ISO;
551: 					break;
552: 				case DatePartSpecifier::DOW:
553: 				case DatePartSpecifier::ISODOW:
554: 					mask |= DOW;
555: 					break;
556: 				case DatePartSpecifier::DOY:
557: 					mask |= DOY;
558: 					break;
559: 				case DatePartSpecifier::EPOCH:
560: 					mask |= EPOCH;
561: 					break;
562: 				case DatePartSpecifier::JULIAN_DAY:
563: 					mask |= JD;
564: 					break;
565: 				case DatePartSpecifier::MICROSECONDS:
566: 				case DatePartSpecifier::MILLISECONDS:
567: 				case DatePartSpecifier::SECOND:
568: 				case DatePartSpecifier::MINUTE:
569: 				case DatePartSpecifier::HOUR:
570: 					mask |= TIME;
571: 					break;
572: 				case DatePartSpecifier::TIMEZONE:
573: 				case DatePartSpecifier::TIMEZONE_HOUR:
574: 				case DatePartSpecifier::TIMEZONE_MINUTE:
575: 					mask |= ZONE;
576: 					break;
577: 				}
578: 			}
579: 			return mask;
580: 		}
581: 
582: 		template <typename P>
583: 		static inline P HasPartValue(vector<P> part_values, DatePartSpecifier part) {
584: 			static const auto BEGIN_DOUBLE = size_t(DatePartSpecifier::JULIAN_DAY);
585: 			auto idx = size_t(part);
586: 			if (IsBigintDatepart(part)) {
587: 				return part_values[idx];
588: 			} else {
589: 				return part_values[idx - BEGIN_DOUBLE];
590: 			}
591: 		}
592: 
593: 		using bigint_vec = vector<int64_t *>;
594: 		using double_vec = vector<double *>;
595: 
596: 		template <class TA>
597: 		static inline void Operation(bigint_vec &bigint_values, double_vec &double_values, const TA &input,
598: 		                             const idx_t idx, const part_mask_t mask) {
599: 			int64_t *bigint_data;
600: 			// YMD calculations
601: 			int32_t yyyy = 1970;
602: 			int32_t mm = 0;
603: 			int32_t dd = 1;
604: 			if (mask & YMD) {
605: 				Date::Convert(input, yyyy, mm, dd);
606: 				bigint_data = HasPartValue(bigint_values, DatePartSpecifier::YEAR);
607: 				if (bigint_data) {
608: 					bigint_data[idx] = yyyy;
609: 				}
610: 				bigint_data = HasPartValue(bigint_values, DatePartSpecifier::MONTH);
611: 				if (bigint_data) {
612: 					bigint_data[idx] = mm;
613: 				}
614: 				bigint_data = HasPartValue(bigint_values, DatePartSpecifier::DAY);
615: 				if (bigint_data) {
616: 					bigint_data[idx] = dd;
617: 				}
618: 				bigint_data = HasPartValue(bigint_values, DatePartSpecifier::DECADE);
619: 				if (bigint_data) {
620: 					bigint_data[idx] = DecadeOperator::DecadeFromYear(yyyy);
621: 				}
622: 				bigint_data = HasPartValue(bigint_values, DatePartSpecifier::CENTURY);
623: 				if (bigint_data) {
624: 					bigint_data[idx] = CenturyOperator::CenturyFromYear(yyyy);
625: 				}
626: 				bigint_data = HasPartValue(bigint_values, DatePartSpecifier::MILLENNIUM);
627: 				if (bigint_data) {
628: 					bigint_data[idx] = MillenniumOperator::MillenniumFromYear(yyyy);
629: 				}
630: 				bigint_data = HasPartValue(bigint_values, DatePartSpecifier::QUARTER);
631: 				if (bigint_data) {
632: 					bigint_data[idx] = QuarterOperator::QuarterFromMonth(mm);
633: 				}
634: 				bigint_data = HasPartValue(bigint_values, DatePartSpecifier::ERA);
635: 				if (bigint_data) {
636: 					bigint_data[idx] = EraOperator::EraFromYear(yyyy);
637: 				}
638: 			}
639: 
640: 			// Week calculations
641: 			if (mask & DOW) {
642: 				auto isodow = Date::ExtractISODayOfTheWeek(input);
643: 				bigint_data = HasPartValue(bigint_values, DatePartSpecifier::DOW);
644: 				if (bigint_data) {
645: 					bigint_data[idx] = DayOfWeekOperator::DayOfWeekFromISO(isodow);
646: 				}
647: 				bigint_data = HasPartValue(bigint_values, DatePartSpecifier::ISODOW);
648: 				if (bigint_data) {
649: 					bigint_data[idx] = isodow;
650: 				}
651: 			}
652: 
653: 			// ISO calculations
654: 			if (mask & ISO) {
655: 				int32_t ww = 0;
656: 				int32_t iyyy = 0;
657: 				Date::ExtractISOYearWeek(input, iyyy, ww);
658: 				bigint_data = HasPartValue(bigint_values, DatePartSpecifier::WEEK);
659: 				if (bigint_data) {
660: 					bigint_data[idx] = ww;
661: 				}
662: 				bigint_data = HasPartValue(bigint_values, DatePartSpecifier::ISOYEAR);
663: 				if (bigint_data) {
664: 					bigint_data[idx] = iyyy;
665: 				}
666: 				bigint_data = HasPartValue(bigint_values, DatePartSpecifier::YEARWEEK);
667: 				if (bigint_data) {
668: 					bigint_data[idx] = YearWeekOperator::YearWeekFromParts(iyyy, ww);
669: 				}
670: 			}
671: 
672: 			if (mask & EPOCH) {
673: 				bigint_data = HasPartValue(bigint_values, DatePartSpecifier::EPOCH);
674: 				if (bigint_data) {
675: 					bigint_data[idx] = Date::Epoch(input);
676: 				}
677: 			}
678: 			if (mask & DOY) {
679: 				bigint_data = HasPartValue(bigint_values, DatePartSpecifier::DOY);
680: 				if (bigint_data) {
681: 					bigint_data[idx] = Date::ExtractDayOfTheYear(input);
682: 				}
683: 			}
684: 			if (mask & JD) {
685: 				auto double_data = HasPartValue(double_values, DatePartSpecifier::JULIAN_DAY);
686: 				if (double_data) {
687: 					double_data[idx] = Date::ExtractJulianDay(input);
688: 				}
689: 			}
690: 		}
691: 	};
692: };
693: 
694: template <class T>
695: static void LastYearFunction(DataChunk &args, ExpressionState &state, Vector &result) {
696: 	int32_t last_year = 0;
697: 	UnaryExecutor::ExecuteWithNulls<T, int64_t>(args.data[0], result, args.size(),
698: 	                                            [&](T input, ValidityMask &mask, idx_t idx) {
699: 		                                            if (Value::IsFinite(input)) {
700: 			                                            return Date::ExtractYear(input, &last_year);
701: 		                                            } else {
702: 			                                            mask.SetInvalid(idx);
703: 			                                            return 0;
704: 		                                            }
705: 	                                            });
706: }
707: 
708: template <>
709: int64_t DatePart::YearOperator::Operation(timestamp_t input) {
710: 	return YearOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
711: }
712: 
713: template <>
714: int64_t DatePart::YearOperator::Operation(interval_t input) {
715: 	return input.months / Interval::MONTHS_PER_YEAR;
716: }
717: 
718: template <>
719: int64_t DatePart::YearOperator::Operation(dtime_t input) {
720: 	throw NotImplementedException("\"time\" units \"year\" not recognized");
721: }
722: 
723: template <>
724: int64_t DatePart::MonthOperator::Operation(timestamp_t input) {
725: 	return MonthOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
726: }
727: 
728: template <>
729: int64_t DatePart::MonthOperator::Operation(interval_t input) {
730: 	return input.months % Interval::MONTHS_PER_YEAR;
731: }
732: 
733: template <>
734: int64_t DatePart::MonthOperator::Operation(dtime_t input) {
735: 	throw NotImplementedException("\"time\" units \"month\" not recognized");
736: }
737: 
738: template <>
739: int64_t DatePart::DayOperator::Operation(timestamp_t input) {
740: 	return DayOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
741: }
742: 
743: template <>
744: int64_t DatePart::DayOperator::Operation(interval_t input) {
745: 	return input.days;
746: }
747: 
748: template <>
749: int64_t DatePart::DayOperator::Operation(dtime_t input) {
750: 	throw NotImplementedException("\"time\" units \"day\" not recognized");
751: }
752: 
753: template <>
754: int64_t DatePart::DecadeOperator::Operation(interval_t input) {
755: 	return input.months / Interval::MONTHS_PER_DECADE;
756: }
757: 
758: template <>
759: int64_t DatePart::DecadeOperator::Operation(dtime_t input) {
760: 	throw NotImplementedException("\"time\" units \"decade\" not recognized");
761: }
762: 
763: template <>
764: int64_t DatePart::CenturyOperator::Operation(interval_t input) {
765: 	return input.months / Interval::MONTHS_PER_CENTURY;
766: }
767: 
768: template <>
769: int64_t DatePart::CenturyOperator::Operation(dtime_t input) {
770: 	throw NotImplementedException("\"time\" units \"century\" not recognized");
771: }
772: 
773: template <>
774: int64_t DatePart::MillenniumOperator::Operation(interval_t input) {
775: 	return input.months / Interval::MONTHS_PER_MILLENIUM;
776: }
777: 
778: template <>
779: int64_t DatePart::MillenniumOperator::Operation(dtime_t input) {
780: 	throw NotImplementedException("\"time\" units \"millennium\" not recognized");
781: }
782: 
783: template <>
784: int64_t DatePart::QuarterOperator::Operation(timestamp_t input) {
785: 	return QuarterOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
786: }
787: 
788: template <>
789: int64_t DatePart::QuarterOperator::Operation(interval_t input) {
790: 	return MonthOperator::Operation<interval_t, int64_t>(input) / Interval::MONTHS_PER_QUARTER + 1;
791: }
792: 
793: template <>
794: int64_t DatePart::QuarterOperator::Operation(dtime_t input) {
795: 	throw NotImplementedException("\"time\" units \"quarter\" not recognized");
796: }
797: 
798: template <>
799: int64_t DatePart::DayOfWeekOperator::Operation(timestamp_t input) {
800: 	return DayOfWeekOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
801: }
802: 
803: template <>
804: int64_t DatePart::DayOfWeekOperator::Operation(interval_t input) {
805: 	throw NotImplementedException("interval units \"dow\" not recognized");
806: }
807: 
808: template <>
809: int64_t DatePart::DayOfWeekOperator::Operation(dtime_t input) {
810: 	throw NotImplementedException("\"time\" units \"dow\" not recognized");
811: }
812: 
813: template <>
814: int64_t DatePart::ISODayOfWeekOperator::Operation(timestamp_t input) {
815: 	return ISODayOfWeekOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
816: }
817: 
818: template <>
819: int64_t DatePart::ISODayOfWeekOperator::Operation(interval_t input) {
820: 	throw NotImplementedException("interval units \"isodow\" not recognized");
821: }
822: 
823: template <>
824: int64_t DatePart::ISODayOfWeekOperator::Operation(dtime_t input) {
825: 	throw NotImplementedException("\"time\" units \"isodow\" not recognized");
826: }
827: 
828: template <>
829: int64_t DatePart::DayOfYearOperator::Operation(timestamp_t input) {
830: 	return DayOfYearOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
831: }
832: 
833: template <>
834: int64_t DatePart::DayOfYearOperator::Operation(interval_t input) {
835: 	throw NotImplementedException("interval units \"doy\" not recognized");
836: }
837: 
838: template <>
839: int64_t DatePart::DayOfYearOperator::Operation(dtime_t input) {
840: 	throw NotImplementedException("\"time\" units \"doy\" not recognized");
841: }
842: 
843: template <>
844: int64_t DatePart::WeekOperator::Operation(timestamp_t input) {
845: 	return WeekOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
846: }
847: 
848: template <>
849: int64_t DatePart::WeekOperator::Operation(interval_t input) {
850: 	throw NotImplementedException("interval units \"week\" not recognized");
851: }
852: 
853: template <>
854: int64_t DatePart::WeekOperator::Operation(dtime_t input) {
855: 	throw NotImplementedException("\"time\" units \"week\" not recognized");
856: }
857: 
858: template <>
859: int64_t DatePart::ISOYearOperator::Operation(timestamp_t input) {
860: 	return ISOYearOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
861: }
862: 
863: template <>
864: int64_t DatePart::ISOYearOperator::Operation(interval_t input) {
865: 	throw NotImplementedException("interval units \"isoyear\" not recognized");
866: }
867: 
868: template <>
869: int64_t DatePart::ISOYearOperator::Operation(dtime_t input) {
870: 	throw NotImplementedException("\"time\" units \"isoyear\" not recognized");
871: }
872: 
873: template <>
874: int64_t DatePart::YearWeekOperator::Operation(timestamp_t input) {
875: 	return YearWeekOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
876: }
877: 
878: template <>
879: int64_t DatePart::YearWeekOperator::Operation(interval_t input) {
880: 	const auto yyyy = YearOperator::Operation<interval_t, int64_t>(input);
881: 	const auto ww = WeekOperator::Operation<interval_t, int64_t>(input);
882: 	return YearWeekOperator::YearWeekFromParts<int64_t>(yyyy, ww);
883: }
884: 
885: template <>
886: int64_t DatePart::YearWeekOperator::Operation(dtime_t input) {
887: 	throw NotImplementedException("\"time\" units \"yearweek\" not recognized");
888: }
889: 
890: template <>
891: int64_t DatePart::EpochNanosecondsOperator::Operation(timestamp_t input) {
892: 	return Timestamp::GetEpochNanoSeconds(input);
893: }
894: 
895: template <>
896: int64_t DatePart::EpochNanosecondsOperator::Operation(date_t input) {
897: 	return Date::EpochNanoseconds(input);
898: }
899: 
900: template <>
901: int64_t DatePart::EpochNanosecondsOperator::Operation(interval_t input) {
902: 	return Interval::GetNanoseconds(input);
903: }
904: 
905: template <>
906: int64_t DatePart::EpochMicrosecondsOperator::Operation(timestamp_t input) {
907: 	return Timestamp::GetEpochMicroSeconds(input);
908: }
909: 
910: template <>
911: int64_t DatePart::EpochMicrosecondsOperator::Operation(date_t input) {
912: 	return Date::EpochMicroseconds(input);
913: }
914: 
915: template <>
916: int64_t DatePart::EpochMicrosecondsOperator::Operation(interval_t input) {
917: 	return Interval::GetMicro(input);
918: }
919: 
920: template <>
921: int64_t DatePart::EpochMillisOperator::Operation(timestamp_t input) {
922: 	return Timestamp::GetEpochMs(input);
923: }
924: 
925: template <>
926: int64_t DatePart::EpochMillisOperator::Operation(date_t input) {
927: 	return Date::EpochMilliseconds(input);
928: }
929: 
930: template <>
931: int64_t DatePart::EpochMillisOperator::Operation(interval_t input) {
932: 	return Interval::GetMilli(input);
933: }
934: 
935: template <>
936: int64_t DatePart::MicrosecondsOperator::Operation(timestamp_t input) {
937: 	auto time = Timestamp::GetTime(input);
938: 	// remove everything but the second & microsecond part
939: 	return time.micros % Interval::MICROS_PER_MINUTE;
940: }
941: 
942: template <>
943: int64_t DatePart::MicrosecondsOperator::Operation(interval_t input) {
944: 	// remove everything but the second & microsecond part
945: 	return input.micros % Interval::MICROS_PER_MINUTE;
946: }
947: 
948: template <>
949: int64_t DatePart::MicrosecondsOperator::Operation(dtime_t input) {
950: 	// remove everything but the second & microsecond part
951: 	return input.micros % Interval::MICROS_PER_MINUTE;
952: }
953: 
954: template <>
955: int64_t DatePart::MillisecondsOperator::Operation(timestamp_t input) {
956: 	return MicrosecondsOperator::Operation<timestamp_t, int64_t>(input) / Interval::MICROS_PER_MSEC;
957: }
958: 
959: template <>
960: int64_t DatePart::MillisecondsOperator::Operation(interval_t input) {
961: 	return MicrosecondsOperator::Operation<interval_t, int64_t>(input) / Interval::MICROS_PER_MSEC;
962: }
963: 
964: template <>
965: int64_t DatePart::MillisecondsOperator::Operation(dtime_t input) {
966: 	return MicrosecondsOperator::Operation<dtime_t, int64_t>(input) / Interval::MICROS_PER_MSEC;
967: }
968: 
969: template <>
970: int64_t DatePart::SecondsOperator::Operation(timestamp_t input) {
971: 	return MicrosecondsOperator::Operation<timestamp_t, int64_t>(input) / Interval::MICROS_PER_SEC;
972: }
973: 
974: template <>
975: int64_t DatePart::SecondsOperator::Operation(interval_t input) {
976: 	return MicrosecondsOperator::Operation<interval_t, int64_t>(input) / Interval::MICROS_PER_SEC;
977: }
978: 
979: template <>
980: int64_t DatePart::SecondsOperator::Operation(dtime_t input) {
981: 	return MicrosecondsOperator::Operation<dtime_t, int64_t>(input) / Interval::MICROS_PER_SEC;
982: }
983: 
984: template <>
985: int64_t DatePart::MinutesOperator::Operation(timestamp_t input) {
986: 	auto time = Timestamp::GetTime(input);
987: 	// remove the hour part, and truncate to minutes
988: 	return (time.micros % Interval::MICROS_PER_HOUR) / Interval::MICROS_PER_MINUTE;
989: }
990: 
991: template <>
992: int64_t DatePart::MinutesOperator::Operation(interval_t input) {
993: 	// remove the hour part, and truncate to minutes
994: 	return (input.micros % Interval::MICROS_PER_HOUR) / Interval::MICROS_PER_MINUTE;
995: }
996: 
997: template <>
998: int64_t DatePart::MinutesOperator::Operation(dtime_t input) {
999: 	// remove the hour part, and truncate to minutes
1000: 	return (input.micros % Interval::MICROS_PER_HOUR) / Interval::MICROS_PER_MINUTE;
1001: }
1002: 
1003: template <>
1004: int64_t DatePart::HoursOperator::Operation(timestamp_t input) {
1005: 	return Timestamp::GetTime(input).micros / Interval::MICROS_PER_HOUR;
1006: }
1007: 
1008: template <>
1009: int64_t DatePart::HoursOperator::Operation(interval_t input) {
1010: 	return input.micros / Interval::MICROS_PER_HOUR;
1011: }
1012: 
1013: template <>
1014: int64_t DatePart::HoursOperator::Operation(dtime_t input) {
1015: 	return input.micros / Interval::MICROS_PER_HOUR;
1016: }
1017: 
1018: template <>
1019: int64_t DatePart::EpochOperator::Operation(timestamp_t input) {
1020: 	return Timestamp::GetEpochSeconds(input);
1021: }
1022: 
1023: template <>
1024: int64_t DatePart::EpochOperator::Operation(interval_t input) {
1025: 	int64_t interval_years = input.months / Interval::MONTHS_PER_YEAR;
1026: 	int64_t interval_days;
1027: 	interval_days = Interval::DAYS_PER_YEAR * interval_years;
1028: 	interval_days += Interval::DAYS_PER_MONTH * (input.months % Interval::MONTHS_PER_YEAR);
1029: 	interval_days += input.days;
1030: 	int64_t interval_epoch;
1031: 	interval_epoch = interval_days * Interval::SECS_PER_DAY;
1032: 	// we add 0.25 days per year to sort of account for leap days
1033: 	interval_epoch += interval_years * (Interval::SECS_PER_DAY / 4);
1034: 	interval_epoch += input.micros / Interval::MICROS_PER_SEC;
1035: 	return interval_epoch;
1036: }
1037: 
1038: template <>
1039: int64_t DatePart::EpochOperator::Operation(dtime_t input) {
1040: 	return input.micros / Interval::MICROS_PER_SEC;
1041: }
1042: 
1043: template <>
1044: unique_ptr<BaseStatistics> DatePart::EpochOperator::PropagateStatistics<dtime_t>(ClientContext &context,
1045:                                                                                  FunctionStatisticsInput &input) {
1046: 	// time seconds range over a single day
1047: 	return PropagateSimpleDatePartStatistics<0, 86400>(input.child_stats);
1048: }
1049: 
1050: template <>
1051: int64_t DatePart::EraOperator::Operation(timestamp_t input) {
1052: 	return EraOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
1053: }
1054: 
1055: template <>
1056: int64_t DatePart::EraOperator::Operation(interval_t input) {
1057: 	throw NotImplementedException("interval units \"era\" not recognized");
1058: }
1059: 
1060: template <>
1061: int64_t DatePart::EraOperator::Operation(dtime_t input) {
1062: 	throw NotImplementedException("\"time\" units \"era\" not recognized");
1063: }
1064: 
1065: template <>
1066: int64_t DatePart::TimezoneOperator::Operation(date_t input) {
1067: 	throw NotImplementedException("\"date\" units \"timezone\" not recognized");
1068: }
1069: 
1070: template <>
1071: int64_t DatePart::TimezoneOperator::Operation(interval_t input) {
1072: 	throw NotImplementedException("\"interval\" units \"timezone\" not recognized");
1073: }
1074: 
1075: template <>
1076: int64_t DatePart::TimezoneOperator::Operation(dtime_t input) {
1077: 	return 0;
1078: }
1079: 
1080: template <>
1081: double DatePart::JulianDayOperator::Operation(date_t input) {
1082: 	return Date::ExtractJulianDay(input);
1083: }
1084: 
1085: template <>
1086: double DatePart::JulianDayOperator::Operation(interval_t input) {
1087: 	throw NotImplementedException("interval units \"julian\" not recognized");
1088: }
1089: 
1090: template <>
1091: double DatePart::JulianDayOperator::Operation(dtime_t input) {
1092: 	throw NotImplementedException("\"time\" units \"julian\" not recognized");
1093: }
1094: 
1095: template <>
1096: void DatePart::StructOperator::Operation(bigint_vec &bigint_values, double_vec &double_values, const dtime_t &input,
1097:                                          const idx_t idx, const part_mask_t mask) {
1098: 	int64_t *part_data;
1099: 	if (mask & TIME) {
1100: 		const auto micros = MicrosecondsOperator::Operation<dtime_t, int64_t>(input);
1101: 		part_data = HasPartValue(bigint_values, DatePartSpecifier::MICROSECONDS);
1102: 		if (part_data) {
1103: 			part_data[idx] = micros;
1104: 		}
1105: 		part_data = HasPartValue(bigint_values, DatePartSpecifier::MILLISECONDS);
1106: 		if (part_data) {
1107: 			part_data[idx] = micros / Interval::MICROS_PER_MSEC;
1108: 		}
1109: 		part_data = HasPartValue(bigint_values, DatePartSpecifier::SECOND);
1110: 		if (part_data) {
1111: 			part_data[idx] = micros / Interval::MICROS_PER_SEC;
1112: 		}
1113: 		part_data = HasPartValue(bigint_values, DatePartSpecifier::MINUTE);
1114: 		if (part_data) {
1115: 			part_data[idx] = MinutesOperator::Operation<dtime_t, int64_t>(input);
1116: 		}
1117: 		part_data = HasPartValue(bigint_values, DatePartSpecifier::HOUR);
1118: 		if (part_data) {
1119: 			part_data[idx] = HoursOperator::Operation<dtime_t, int64_t>(input);
1120: 		}
1121: 	}
1122: 
1123: 	if (mask & EPOCH) {
1124: 		part_data = HasPartValue(bigint_values, DatePartSpecifier::EPOCH);
1125: 		if (part_data) {
1126: 			part_data[idx] = EpochOperator::Operation<dtime_t, int64_t>(input);
1127: 			;
1128: 		}
1129: 	}
1130: 
1131: 	if (mask & ZONE) {
1132: 		part_data = HasPartValue(bigint_values, DatePartSpecifier::TIMEZONE);
1133: 		if (part_data) {
1134: 			part_data[idx] = 0;
1135: 		}
1136: 		part_data = HasPartValue(bigint_values, DatePartSpecifier::TIMEZONE_HOUR);
1137: 		if (part_data) {
1138: 			part_data[idx] = 0;
1139: 		}
1140: 		part_data = HasPartValue(bigint_values, DatePartSpecifier::TIMEZONE_MINUTE);
1141: 		if (part_data) {
1142: 			part_data[idx] = 0;
1143: 		}
1144: 	}
1145: }
1146: 
1147: template <>
1148: void DatePart::StructOperator::Operation(bigint_vec &bigint_values, double_vec &double_values, const timestamp_t &input,
1149:                                          const idx_t idx, const part_mask_t mask) {
1150: 	date_t d;
1151: 	dtime_t t;
1152: 	Timestamp::Convert(input, d, t);
1153: 
1154: 	// Both define epoch, and the correct value is the sum.
1155: 	// So mask it out and compute it separately.
1156: 	Operation(bigint_values, double_values, d, idx, mask & ~EPOCH);
1157: 	Operation(bigint_values, double_values, t, idx, mask & ~EPOCH);
1158: 
1159: 	if (mask & EPOCH) {
1160: 		auto part_data = HasPartValue(bigint_values, DatePartSpecifier::EPOCH);
1161: 		if (part_data) {
1162: 			part_data[idx] = EpochOperator::Operation<timestamp_t, int64_t>(input);
1163: 		}
1164: 	}
1165: 
1166: 	if (mask & JD) {
1167: 		auto part_data = HasPartValue(double_values, DatePartSpecifier::JULIAN_DAY);
1168: 		if (part_data) {
1169: 			part_data[idx] = JulianDayOperator::Operation<timestamp_t, double>(input);
1170: 		}
1171: 	}
1172: }
1173: 
1174: template <>
1175: void DatePart::StructOperator::Operation(bigint_vec &bigint_values, double_vec &double_values, const interval_t &input,
1176:                                          const idx_t idx, const part_mask_t mask) {
1177: 	int64_t *part_data;
1178: 	if (mask & YMD) {
1179: 		const auto mm = input.months % Interval::MONTHS_PER_YEAR;
1180: 		part_data = HasPartValue(bigint_values, DatePartSpecifier::YEAR);
1181: 		if (part_data) {
1182: 			part_data[idx] = input.months / Interval::MONTHS_PER_YEAR;
1183: 		}
1184: 		part_data = HasPartValue(bigint_values, DatePartSpecifier::MONTH);
1185: 		if (part_data) {
1186: 			part_data[idx] = mm;
1187: 		}
1188: 		part_data = HasPartValue(bigint_values, DatePartSpecifier::DAY);
1189: 		if (part_data) {
1190: 			part_data[idx] = input.days;
1191: 		}
1192: 		part_data = HasPartValue(bigint_values, DatePartSpecifier::DECADE);
1193: 		if (part_data) {
1194: 			part_data[idx] = input.months / Interval::MONTHS_PER_DECADE;
1195: 		}
1196: 		part_data = HasPartValue(bigint_values, DatePartSpecifier::CENTURY);
1197: 		if (part_data) {
1198: 			part_data[idx] = input.months / Interval::MONTHS_PER_CENTURY;
1199: 		}
1200: 		part_data = HasPartValue(bigint_values, DatePartSpecifier::MILLENNIUM);
1201: 		if (part_data) {
1202: 			part_data[idx] = input.months / Interval::MONTHS_PER_MILLENIUM;
1203: 		}
1204: 		part_data = HasPartValue(bigint_values, DatePartSpecifier::QUARTER);
1205: 		if (part_data) {
1206: 			part_data[idx] = mm / Interval::MONTHS_PER_QUARTER + 1;
1207: 		}
1208: 	}
1209: 
1210: 	if (mask & TIME) {
1211: 		const auto micros = MicrosecondsOperator::Operation<interval_t, int64_t>(input);
1212: 		part_data = HasPartValue(bigint_values, DatePartSpecifier::MICROSECONDS);
1213: 		if (part_data) {
1214: 			part_data[idx] = micros;
1215: 		}
1216: 		part_data = HasPartValue(bigint_values, DatePartSpecifier::MILLISECONDS);
1217: 		if (part_data) {
1218: 			part_data[idx] = micros / Interval::MICROS_PER_MSEC;
1219: 		}
1220: 		part_data = HasPartValue(bigint_values, DatePartSpecifier::SECOND);
1221: 		if (part_data) {
1222: 			part_data[idx] = micros / Interval::MICROS_PER_SEC;
1223: 		}
1224: 		part_data = HasPartValue(bigint_values, DatePartSpecifier::MINUTE);
1225: 		if (part_data) {
1226: 			part_data[idx] = MinutesOperator::Operation<interval_t, int64_t>(input);
1227: 		}
1228: 		part_data = HasPartValue(bigint_values, DatePartSpecifier::HOUR);
1229: 		if (part_data) {
1230: 			part_data[idx] = HoursOperator::Operation<interval_t, int64_t>(input);
1231: 		}
1232: 	}
1233: 
1234: 	if (mask & EPOCH) {
1235: 		part_data = HasPartValue(bigint_values, DatePartSpecifier::EPOCH);
1236: 		if (part_data) {
1237: 			part_data[idx] = EpochOperator::Operation<interval_t, int64_t>(input);
1238: 		}
1239: 	}
1240: }
1241: 
1242: template <typename T>
1243: static int64_t ExtractElement(DatePartSpecifier type, T element) {
1244: 	switch (type) {
1245: 	case DatePartSpecifier::YEAR:
1246: 		return DatePart::YearOperator::template Operation<T, int64_t>(element);
1247: 	case DatePartSpecifier::MONTH:
1248: 		return DatePart::MonthOperator::template Operation<T, int64_t>(element);
1249: 	case DatePartSpecifier::DAY:
1250: 		return DatePart::DayOperator::template Operation<T, int64_t>(element);
1251: 	case DatePartSpecifier::DECADE:
1252: 		return DatePart::DecadeOperator::template Operation<T, int64_t>(element);
1253: 	case DatePartSpecifier::CENTURY:
1254: 		return DatePart::CenturyOperator::template Operation<T, int64_t>(element);
1255: 	case DatePartSpecifier::MILLENNIUM:
1256: 		return DatePart::MillenniumOperator::template Operation<T, int64_t>(element);
1257: 	case DatePartSpecifier::QUARTER:
1258: 		return DatePart::QuarterOperator::template Operation<T, int64_t>(element);
1259: 	case DatePartSpecifier::DOW:
1260: 		return DatePart::DayOfWeekOperator::template Operation<T, int64_t>(element);
1261: 	case DatePartSpecifier::ISODOW:
1262: 		return DatePart::ISODayOfWeekOperator::template Operation<T, int64_t>(element);
1263: 	case DatePartSpecifier::DOY:
1264: 		return DatePart::DayOfYearOperator::template Operation<T, int64_t>(element);
1265: 	case DatePartSpecifier::WEEK:
1266: 		return DatePart::WeekOperator::template Operation<T, int64_t>(element);
1267: 	case DatePartSpecifier::ISOYEAR:
1268: 		return DatePart::ISOYearOperator::template Operation<T, int64_t>(element);
1269: 	case DatePartSpecifier::YEARWEEK:
1270: 		return DatePart::YearWeekOperator::template Operation<T, int64_t>(element);
1271: 	case DatePartSpecifier::EPOCH:
1272: 		return DatePart::EpochOperator::template Operation<T, int64_t>(element);
1273: 	case DatePartSpecifier::MICROSECONDS:
1274: 		return DatePart::MicrosecondsOperator::template Operation<T, int64_t>(element);
1275: 	case DatePartSpecifier::MILLISECONDS:
1276: 		return DatePart::MillisecondsOperator::template Operation<T, int64_t>(element);
1277: 	case DatePartSpecifier::SECOND:
1278: 		return DatePart::SecondsOperator::template Operation<T, int64_t>(element);
1279: 	case DatePartSpecifier::MINUTE:
1280: 		return DatePart::MinutesOperator::template Operation<T, int64_t>(element);
1281: 	case DatePartSpecifier::HOUR:
1282: 		return DatePart::HoursOperator::template Operation<T, int64_t>(element);
1283: 	case DatePartSpecifier::ERA:
1284: 		return DatePart::EraOperator::template Operation<T, int64_t>(element);
1285: 	case DatePartSpecifier::TIMEZONE:
1286: 	case DatePartSpecifier::TIMEZONE_HOUR:
1287: 	case DatePartSpecifier::TIMEZONE_MINUTE:
1288: 		return DatePart::TimezoneOperator::template Operation<T, int64_t>(element);
1289: 	default:
1290: 		throw NotImplementedException("Specifier type not implemented for DATEPART");
1291: 	}
1292: }
1293: 
1294: template <typename T>
1295: static void DatePartFunction(DataChunk &args, ExpressionState &state, Vector &result) {
1296: 	D_ASSERT(args.ColumnCount() == 2);
1297: 	auto &spec_arg = args.data[0];
1298: 	auto &date_arg = args.data[1];
1299: 
1300: 	BinaryExecutor::ExecuteWithNulls<string_t, T, int64_t>(
1301: 	    spec_arg, date_arg, result, args.size(), [&](string_t specifier, T date, ValidityMask &mask, idx_t idx) {
1302: 		    if (Value::IsFinite(date)) {
1303: 			    return ExtractElement<T>(GetDatePartSpecifier(specifier.GetString()), date);
1304: 		    } else {
1305: 			    mask.SetInvalid(idx);
1306: 			    return int64_t(0);
1307: 		    }
1308: 	    });
1309: }
1310: 
1311: static unique_ptr<FunctionData> DatePartBind(ClientContext &context, ScalarFunction &bound_function,
1312:                                              vector<unique_ptr<Expression>> &arguments) {
1313: 	//	If we are only looking for Julian Days for timestamps,
1314: 	//	then return doubles.
1315: 	if (arguments[0]->HasParameter() || !arguments[0]->IsFoldable()) {
1316: 		return nullptr;
1317: 	}
1318: 
1319: 	Value part_value = ExpressionExecutor::EvaluateScalar(context, *arguments[0]);
1320: 	if (part_value.IsNull()) {
1321: 		return nullptr;
1322: 	}
1323: 	const auto part_name = part_value.ToString();
1324: 	switch (GetDatePartSpecifier(part_name)) {
1325: 	case DatePartSpecifier::JULIAN_DAY:
1326: 		arguments.erase(arguments.begin());
1327: 		bound_function.arguments.erase(bound_function.arguments.begin());
1328: 		bound_function.name = "julian";
1329: 		bound_function.return_type = LogicalType::DOUBLE;
1330: 		switch (arguments[0]->return_type.id()) {
1331: 		case LogicalType::TIMESTAMP:
1332: 			bound_function.function = DatePart::UnaryFunction<timestamp_t, double, DatePart::JulianDayOperator>;
1333: 			bound_function.statistics = DatePart::JulianDayOperator::template PropagateStatistics<timestamp_t>;
1334: 			break;
1335: 		case LogicalType::DATE:
1336: 			bound_function.function = DatePart::UnaryFunction<date_t, double, DatePart::JulianDayOperator>;
1337: 			bound_function.statistics = DatePart::JulianDayOperator::template PropagateStatistics<date_t>;
1338: 			break;
1339: 		default:
1340: 			throw BinderException("%s can only take DATE or TIMESTAMP arguments", bound_function.name);
1341: 		}
1342: 		break;
1343: 	default:
1344: 		break;
1345: 	}
1346: 
1347: 	return nullptr;
1348: }
1349: 
1350: ScalarFunctionSet GetGenericDatePartFunction(scalar_function_t date_func, scalar_function_t ts_func,
1351:                                              scalar_function_t interval_func, function_statistics_t date_stats,
1352:                                              function_statistics_t ts_stats) {
1353: 	ScalarFunctionSet operator_set;
1354: 	operator_set.AddFunction(
1355: 	    ScalarFunction({LogicalType::DATE}, LogicalType::BIGINT, std::move(date_func), nullptr, nullptr, date_stats));
1356: 	operator_set.AddFunction(
1357: 	    ScalarFunction({LogicalType::TIMESTAMP}, LogicalType::BIGINT, std::move(ts_func), nullptr, nullptr, ts_stats));
1358: 	operator_set.AddFunction(ScalarFunction({LogicalType::INTERVAL}, LogicalType::BIGINT, std::move(interval_func)));
1359: 	return operator_set;
1360: }
1361: 
1362: template <class OP>
1363: static ScalarFunctionSet GetDatePartFunction() {
1364: 	return GetGenericDatePartFunction(
1365: 	    DatePart::UnaryFunction<date_t, int64_t, OP>, DatePart::UnaryFunction<timestamp_t, int64_t, OP>,
1366: 	    ScalarFunction::UnaryFunction<interval_t, int64_t, OP>, OP::template PropagateStatistics<date_t>,
1367: 	    OP::template PropagateStatistics<timestamp_t>);
1368: }
1369: 
1370: ScalarFunctionSet GetGenericTimePartFunction(scalar_function_t date_func, scalar_function_t ts_func,
1371:                                              scalar_function_t interval_func, scalar_function_t time_func,
1372:                                              function_statistics_t date_stats, function_statistics_t ts_stats,
1373:                                              function_statistics_t time_stats) {
1374: 	ScalarFunctionSet operator_set;
1375: 	operator_set.AddFunction(
1376: 	    ScalarFunction({LogicalType::DATE}, LogicalType::BIGINT, std::move(date_func), nullptr, nullptr, date_stats));
1377: 	operator_set.AddFunction(
1378: 	    ScalarFunction({LogicalType::TIMESTAMP}, LogicalType::BIGINT, std::move(ts_func), nullptr, nullptr, ts_stats));
1379: 	operator_set.AddFunction(ScalarFunction({LogicalType::INTERVAL}, LogicalType::BIGINT, std::move(interval_func)));
1380: 	operator_set.AddFunction(
1381: 	    ScalarFunction({LogicalType::TIME}, LogicalType::BIGINT, std::move(time_func), nullptr, nullptr, time_stats));
1382: 	return operator_set;
1383: }
1384: 
1385: template <class OP>
1386: static ScalarFunctionSet GetTimePartFunction() {
1387: 	return GetGenericTimePartFunction(
1388: 	    DatePart::UnaryFunction<date_t, int64_t, OP>, DatePart::UnaryFunction<timestamp_t, int64_t, OP>,
1389: 	    ScalarFunction::UnaryFunction<interval_t, int64_t, OP>, ScalarFunction::UnaryFunction<dtime_t, int64_t, OP>,
1390: 	    OP::template PropagateStatistics<date_t>, OP::template PropagateStatistics<timestamp_t>,
1391: 	    OP::template PropagateStatistics<dtime_t>);
1392: }
1393: 
1394: struct LastDayOperator {
1395: 	template <class TA, class TR>
1396: 	static inline TR Operation(TA input) {
1397: 		int32_t yyyy, mm, dd;
1398: 		Date::Convert(input, yyyy, mm, dd);
1399: 		yyyy += (mm / 12);
1400: 		mm %= 12;
1401: 		++mm;
1402: 		return Date::FromDate(yyyy, mm, 1) - 1;
1403: 	}
1404: };
1405: 
1406: template <>
1407: date_t LastDayOperator::Operation(timestamp_t input) {
1408: 	return LastDayOperator::Operation<date_t, date_t>(Timestamp::GetDate(input));
1409: }
1410: 
1411: struct MonthNameOperator {
1412: 	template <class TA, class TR>
1413: 	static inline TR Operation(TA input) {
1414: 		return Date::MONTH_NAMES[DatePart::MonthOperator::Operation<TA, int64_t>(input) - 1];
1415: 	}
1416: };
1417: 
1418: struct DayNameOperator {
1419: 	template <class TA, class TR>
1420: 	static inline TR Operation(TA input) {
1421: 		return Date::DAY_NAMES[DatePart::DayOfWeekOperator::Operation<TA, int64_t>(input)];
1422: 	}
1423: };
1424: 
1425: struct StructDatePart {
1426: 	using part_codes_t = vector<DatePartSpecifier>;
1427: 
1428: 	static const auto BEGIN_BIGINT = size_t(DatePartSpecifier::YEAR);
1429: 	static const auto BEGIN_DOUBLE = size_t(DatePartSpecifier::JULIAN_DAY);
1430: 	static const auto BEGIN_INVALID = size_t(DatePartSpecifier::JULIAN_DAY) + 1;
1431: 
1432: 	struct BindData : public VariableReturnBindData {
1433: 		part_codes_t part_codes;
1434: 
1435: 		explicit BindData(const LogicalType &stype, const part_codes_t &part_codes_p)
1436: 		    : VariableReturnBindData(stype), part_codes(part_codes_p) {
1437: 		}
1438: 
1439: 		unique_ptr<FunctionData> Copy() const override {
1440: 			return make_uniq<BindData>(stype, part_codes);
1441: 		}
1442: 	};
1443: 
1444: 	static unique_ptr<FunctionData> Bind(ClientContext &context, ScalarFunction &bound_function,
1445: 	                                     vector<unique_ptr<Expression>> &arguments) {
1446: 		// collect names and deconflict, construct return type
1447: 		if (arguments[0]->HasParameter()) {
1448: 			throw ParameterNotResolvedException();
1449: 		}
1450: 		if (!arguments[0]->IsFoldable()) {
1451: 			throw BinderException("%s can only take constant lists of part names", bound_function.name);
1452: 		}
1453: 
1454: 		case_insensitive_set_t name_collision_set;
1455: 		child_list_t<LogicalType> struct_children;
1456: 		part_codes_t part_codes;
1457: 
1458: 		Value parts_list = ExpressionExecutor::EvaluateScalar(context, *arguments[0]);
1459: 		if (parts_list.type().id() == LogicalTypeId::LIST) {
1460: 			auto &list_children = ListValue::GetChildren(parts_list);
1461: 			if (list_children.empty()) {
1462: 				throw BinderException("%s requires non-empty lists of part names", bound_function.name);
1463: 			}
1464: 			for (const auto &part_value : list_children) {
1465: 				if (part_value.IsNull()) {
1466: 					throw BinderException("NULL struct entry name in %s", bound_function.name);
1467: 				}
1468: 				const auto part_name = part_value.ToString();
1469: 				const auto part_code = GetDateTypePartSpecifier(part_name, arguments[1]->return_type);
1470: 				if (name_collision_set.find(part_name) != name_collision_set.end()) {
1471: 					throw BinderException("Duplicate struct entry name \"%s\" in %s", part_name, bound_function.name);
1472: 				}
1473: 				name_collision_set.insert(part_name);
1474: 				part_codes.emplace_back(part_code);
1475: 				const auto part_type = IsBigintDatepart(part_code) ? LogicalType::BIGINT : LogicalType::DOUBLE;
1476: 				struct_children.emplace_back(make_pair(part_name, part_type));
1477: 			}
1478: 		} else {
1479: 			throw BinderException("%s can only take constant lists of part names", bound_function.name);
1480: 		}
1481: 
1482: 		Function::EraseArgument(bound_function, arguments, 0);
1483: 		bound_function.return_type = LogicalType::STRUCT(struct_children);
1484: 		return make_uniq<BindData>(bound_function.return_type, part_codes);
1485: 	}
1486: 
1487: 	template <typename INPUT_TYPE>
1488: 	static void Function(DataChunk &args, ExpressionState &state, Vector &result) {
1489: 		auto &func_expr = state.expr.Cast<BoundFunctionExpression>();
1490: 		auto &info = func_expr.bind_info->Cast<BindData>();
1491: 		D_ASSERT(args.ColumnCount() == 1);
1492: 
1493: 		const auto count = args.size();
1494: 		Vector &input = args.data[0];
1495: 		DatePart::StructOperator::bigint_vec bigint_values(size_t(BEGIN_DOUBLE), nullptr);
1496: 		DatePart::StructOperator::double_vec double_values(BEGIN_INVALID - size_t(BEGIN_DOUBLE), nullptr);
1497: 		const auto part_mask = DatePart::StructOperator::GetMask(info.part_codes);
1498: 
1499: 		auto &child_entries = StructVector::GetEntries(result);
1500: 
1501: 		// The first computer of a part "owns" it
1502: 		// and other requestors just reference the owner
1503: 		vector<size_t> owners(int(DatePartSpecifier::JULIAN_DAY) + 1, child_entries.size());
1504: 		for (size_t col = 0; col < child_entries.size(); ++col) {
1505: 			const auto part_index = size_t(info.part_codes[col]);
1506: 			if (owners[part_index] == child_entries.size()) {
1507: 				owners[part_index] = col;
1508: 			}
1509: 		}
1510: 
1511: 		if (input.GetVectorType() == VectorType::CONSTANT_VECTOR) {
1512: 			result.SetVectorType(VectorType::CONSTANT_VECTOR);
1513: 
1514: 			if (ConstantVector::IsNull(input)) {
1515: 				ConstantVector::SetNull(result, true);
1516: 			} else {
1517: 				ConstantVector::SetNull(result, false);
1518: 				for (size_t col = 0; col < child_entries.size(); ++col) {
1519: 					auto &child_entry = child_entries[col];
1520: 					ConstantVector::SetNull(*child_entry, false);
1521: 					const auto part_index = size_t(info.part_codes[col]);
1522: 					if (owners[part_index] == col) {
1523: 						if (IsBigintDatepart(info.part_codes[col])) {
1524: 							bigint_values[part_index - BEGIN_BIGINT] = ConstantVector::GetData<int64_t>(*child_entry);
1525: 						} else {
1526: 							double_values[part_index - BEGIN_DOUBLE] = ConstantVector::GetData<double>(*child_entry);
1527: 						}
1528: 					}
1529: 				}
1530: 				auto tdata = ConstantVector::GetData<INPUT_TYPE>(input);
1531: 				if (Value::IsFinite(tdata[0])) {
1532: 					DatePart::StructOperator::Operation(bigint_values, double_values, tdata[0], 0, part_mask);
1533: 				} else {
1534: 					for (auto &child_entry : child_entries) {
1535: 						ConstantVector::SetNull(*child_entry, true);
1536: 					}
1537: 				}
1538: 			}
1539: 		} else {
1540: 			UnifiedVectorFormat rdata;
1541: 			input.ToUnifiedFormat(count, rdata);
1542: 
1543: 			const auto &arg_valid = rdata.validity;
1544: 			auto tdata = UnifiedVectorFormat::GetData<INPUT_TYPE>(rdata);
1545: 
1546: 			// Start with a valid flat vector
1547: 			result.SetVectorType(VectorType::FLAT_VECTOR);
1548: 			auto &res_valid = FlatVector::Validity(result);
1549: 			if (res_valid.GetData()) {
1550: 				res_valid.SetAllValid(count);
1551: 			}
1552: 
1553: 			// Start with valid children
1554: 			for (size_t col = 0; col < child_entries.size(); ++col) {
1555: 				auto &child_entry = child_entries[col];
1556: 				child_entry->SetVectorType(VectorType::FLAT_VECTOR);
1557: 				auto &child_validity = FlatVector::Validity(*child_entry);
1558: 				if (child_validity.GetData()) {
1559: 					child_validity.SetAllValid(count);
1560: 				}
1561: 
1562: 				// Pre-multiplex
1563: 				const auto part_index = size_t(info.part_codes[col]);
1564: 				if (owners[part_index] == col) {
1565: 					if (IsBigintDatepart(info.part_codes[col])) {
1566: 						bigint_values[part_index - BEGIN_BIGINT] = FlatVector::GetData<int64_t>(*child_entry);
1567: 					} else {
1568: 						double_values[part_index - BEGIN_DOUBLE] = FlatVector::GetData<double>(*child_entry);
1569: 					}
1570: 				}
1571: 			}
1572: 
1573: 			for (idx_t i = 0; i < count; ++i) {
1574: 				const auto idx = rdata.sel->get_index(i);
1575: 				if (arg_valid.RowIsValid(idx)) {
1576: 					if (Value::IsFinite(tdata[idx])) {
1577: 						DatePart::StructOperator::Operation(bigint_values, double_values, tdata[idx], i, part_mask);
1578: 					} else {
1579: 						for (auto &child_entry : child_entries) {
1580: 							FlatVector::Validity(*child_entry).SetInvalid(i);
1581: 						}
1582: 					}
1583: 				} else {
1584: 					res_valid.SetInvalid(i);
1585: 					for (auto &child_entry : child_entries) {
1586: 						FlatVector::Validity(*child_entry).SetInvalid(i);
1587: 					}
1588: 				}
1589: 			}
1590: 		}
1591: 
1592: 		// Reference any duplicate parts
1593: 		for (size_t col = 0; col < child_entries.size(); ++col) {
1594: 			const auto part_index = size_t(info.part_codes[col]);
1595: 			const auto owner = owners[part_index];
1596: 			if (owner != col) {
1597: 				child_entries[col]->Reference(*child_entries[owner]);
1598: 			}
1599: 		}
1600: 
1601: 		result.Verify(count);
1602: 	}
1603: 
1604: 	static void SerializeFunction(Serializer &serializer, const optional_ptr<FunctionData> bind_data_p,
1605: 	                              const ScalarFunction &function) {
1606: 		D_ASSERT(bind_data_p);
1607: 		auto &info = bind_data_p->Cast<BindData>();
1608: 		serializer.WriteProperty(100, "stype", info.stype);
1609: 		serializer.WriteProperty(101, "part_codes", info.part_codes);
1610: 	}
1611: 
1612: 	static unique_ptr<FunctionData> DeserializeFunction(Deserializer &deserializer, ScalarFunction &bound_function) {
1613: 		auto stype = deserializer.ReadProperty<LogicalType>(100, "stype");
1614: 		auto part_codes = deserializer.ReadProperty<vector<DatePartSpecifier>>(101, "part_codes");
1615: 		return make_uniq<BindData>(std::move(stype), std::move(part_codes));
1616: 	}
1617: 
1618: 	template <typename INPUT_TYPE>
1619: 	static ScalarFunction GetFunction(const LogicalType &temporal_type) {
1620: 		auto part_type = LogicalType::LIST(LogicalType::VARCHAR);
1621: 		auto result_type = LogicalType::STRUCT({});
1622: 		ScalarFunction result({part_type, temporal_type}, result_type, Function<INPUT_TYPE>, Bind);
1623: 		result.serialize = SerializeFunction;
1624: 		result.deserialize = DeserializeFunction;
1625: 		return result;
1626: 	}
1627: };
1628: 
1629: ScalarFunctionSet YearFun::GetFunctions() {
1630: 	return GetGenericDatePartFunction(LastYearFunction<date_t>, LastYearFunction<timestamp_t>,
1631: 	                                  ScalarFunction::UnaryFunction<interval_t, int64_t, DatePart::YearOperator>,
1632: 	                                  DatePart::YearOperator::PropagateStatistics<date_t>,
1633: 	                                  DatePart::YearOperator::PropagateStatistics<timestamp_t>);
1634: }
1635: 
1636: ScalarFunctionSet MonthFun::GetFunctions() {
1637: 	return GetDatePartFunction<DatePart::MonthOperator>();
1638: }
1639: 
1640: ScalarFunctionSet DayFun::GetFunctions() {
1641: 	return GetDatePartFunction<DatePart::DayOperator>();
1642: }
1643: 
1644: ScalarFunctionSet DecadeFun::GetFunctions() {
1645: 	return GetDatePartFunction<DatePart::DecadeOperator>();
1646: }
1647: 
1648: ScalarFunctionSet CenturyFun::GetFunctions() {
1649: 	return GetDatePartFunction<DatePart::CenturyOperator>();
1650: }
1651: 
1652: ScalarFunctionSet MillenniumFun::GetFunctions() {
1653: 	return GetDatePartFunction<DatePart::MillenniumOperator>();
1654: }
1655: 
1656: ScalarFunctionSet QuarterFun::GetFunctions() {
1657: 	return GetDatePartFunction<DatePart::QuarterOperator>();
1658: }
1659: 
1660: ScalarFunctionSet DayOfWeekFun::GetFunctions() {
1661: 	return GetDatePartFunction<DatePart::DayOfWeekOperator>();
1662: }
1663: 
1664: ScalarFunctionSet ISODayOfWeekFun::GetFunctions() {
1665: 	return GetDatePartFunction<DatePart::ISODayOfWeekOperator>();
1666: }
1667: 
1668: ScalarFunctionSet DayOfYearFun::GetFunctions() {
1669: 	return GetDatePartFunction<DatePart::DayOfYearOperator>();
1670: }
1671: 
1672: ScalarFunctionSet WeekFun::GetFunctions() {
1673: 	return GetDatePartFunction<DatePart::WeekOperator>();
1674: }
1675: 
1676: ScalarFunctionSet ISOYearFun::GetFunctions() {
1677: 	return GetDatePartFunction<DatePart::ISOYearOperator>();
1678: }
1679: 
1680: ScalarFunctionSet EraFun::GetFunctions() {
1681: 	return GetDatePartFunction<DatePart::EraOperator>();
1682: }
1683: 
1684: ScalarFunctionSet TimezoneFun::GetFunctions() {
1685: 	return GetDatePartFunction<DatePart::TimezoneOperator>();
1686: }
1687: 
1688: ScalarFunctionSet TimezoneHourFun::GetFunctions() {
1689: 	return GetDatePartFunction<DatePart::TimezoneHourOperator>();
1690: }
1691: 
1692: ScalarFunctionSet TimezoneMinuteFun::GetFunctions() {
1693: 	return GetDatePartFunction<DatePart::TimezoneMinuteOperator>();
1694: }
1695: 
1696: ScalarFunctionSet EpochFun::GetFunctions() {
1697: 	return GetTimePartFunction<DatePart::EpochOperator>();
1698: }
1699: 
1700: ScalarFunctionSet EpochNsFun::GetFunctions() {
1701: 	using OP = DatePart::EpochNanosecondsOperator;
1702: 	auto operator_set = GetTimePartFunction<OP>();
1703: 
1704: 	//	TIMESTAMP WITH TIME ZONE has the same representation as TIMESTAMP so no need to defer to ICU
1705: 	auto tstz_func = DatePart::UnaryFunction<timestamp_t, int64_t, OP>;
1706: 	auto tstz_stats = OP::template PropagateStatistics<timestamp_t>;
1707: 	operator_set.AddFunction(
1708: 	    ScalarFunction({LogicalType::TIMESTAMP_TZ}, LogicalType::BIGINT, tstz_func, nullptr, nullptr, tstz_stats));
1709: 	return operator_set;
1710: }
1711: 
1712: ScalarFunctionSet EpochUsFun::GetFunctions() {
1713: 	using OP = DatePart::EpochMicrosecondsOperator;
1714: 	auto operator_set = GetTimePartFunction<OP>();
1715: 
1716: 	//	TIMESTAMP WITH TIME ZONE has the same representation as TIMESTAMP so no need to defer to ICU
1717: 	auto tstz_func = DatePart::UnaryFunction<timestamp_t, int64_t, OP>;
1718: 	auto tstz_stats = OP::template PropagateStatistics<timestamp_t>;
1719: 	operator_set.AddFunction(
1720: 	    ScalarFunction({LogicalType::TIMESTAMP_TZ}, LogicalType::BIGINT, tstz_func, nullptr, nullptr, tstz_stats));
1721: 	return operator_set;
1722: }
1723: 
1724: ScalarFunctionSet EpochMsFun::GetFunctions() {
1725: 	using OP = DatePart::EpochMillisOperator;
1726: 	auto operator_set = GetTimePartFunction<OP>();
1727: 
1728: 	//	TIMESTAMP WITH TIME ZONE has the same representation as TIMESTAMP so no need to defer to ICU
1729: 	auto tstz_func = DatePart::UnaryFunction<timestamp_t, int64_t, OP>;
1730: 	auto tstz_stats = OP::template PropagateStatistics<timestamp_t>;
1731: 	operator_set.AddFunction(
1732: 	    ScalarFunction({LogicalType::TIMESTAMP_TZ}, LogicalType::BIGINT, tstz_func, nullptr, nullptr, tstz_stats));
1733: 
1734: 	//	Legacy inverse BIGINT => TIMESTAMP
1735: 	operator_set.AddFunction(
1736: 	    ScalarFunction({LogicalType::BIGINT}, LogicalType::TIMESTAMP, DatePart::EpochMillisOperator::Inverse));
1737: 
1738: 	return operator_set;
1739: }
1740: 
1741: ScalarFunctionSet MicrosecondsFun::GetFunctions() {
1742: 	return GetTimePartFunction<DatePart::MicrosecondsOperator>();
1743: }
1744: 
1745: ScalarFunctionSet MillisecondsFun::GetFunctions() {
1746: 	return GetTimePartFunction<DatePart::MillisecondsOperator>();
1747: }
1748: 
1749: ScalarFunctionSet SecondsFun::GetFunctions() {
1750: 	return GetTimePartFunction<DatePart::SecondsOperator>();
1751: }
1752: 
1753: ScalarFunctionSet MinutesFun::GetFunctions() {
1754: 	return GetTimePartFunction<DatePart::MinutesOperator>();
1755: }
1756: 
1757: ScalarFunctionSet HoursFun::GetFunctions() {
1758: 	return GetTimePartFunction<DatePart::HoursOperator>();
1759: }
1760: 
1761: ScalarFunctionSet YearWeekFun::GetFunctions() {
1762: 	return GetDatePartFunction<DatePart::YearWeekOperator>();
1763: }
1764: 
1765: ScalarFunctionSet DayOfMonthFun::GetFunctions() {
1766: 	return GetDatePartFunction<DatePart::DayOperator>();
1767: }
1768: 
1769: ScalarFunctionSet WeekDayFun::GetFunctions() {
1770: 	return GetDatePartFunction<DatePart::DayOfWeekOperator>();
1771: }
1772: 
1773: ScalarFunctionSet WeekOfYearFun::GetFunctions() {
1774: 	return GetDatePartFunction<DatePart::WeekOperator>();
1775: }
1776: 
1777: ScalarFunctionSet LastDayFun::GetFunctions() {
1778: 	ScalarFunctionSet last_day;
1779: 	last_day.AddFunction(ScalarFunction({LogicalType::DATE}, LogicalType::DATE,
1780: 	                                    DatePart::UnaryFunction<date_t, date_t, LastDayOperator>));
1781: 	last_day.AddFunction(ScalarFunction({LogicalType::TIMESTAMP}, LogicalType::DATE,
1782: 	                                    DatePart::UnaryFunction<timestamp_t, date_t, LastDayOperator>));
1783: 	return last_day;
1784: }
1785: 
1786: ScalarFunctionSet MonthNameFun::GetFunctions() {
1787: 	ScalarFunctionSet monthname;
1788: 	monthname.AddFunction(ScalarFunction({LogicalType::DATE}, LogicalType::VARCHAR,
1789: 	                                     DatePart::UnaryFunction<date_t, string_t, MonthNameOperator>));
1790: 	monthname.AddFunction(ScalarFunction({LogicalType::TIMESTAMP}, LogicalType::VARCHAR,
1791: 	                                     DatePart::UnaryFunction<timestamp_t, string_t, MonthNameOperator>));
1792: 	return monthname;
1793: }
1794: 
1795: ScalarFunctionSet DayNameFun::GetFunctions() {
1796: 	ScalarFunctionSet dayname;
1797: 	dayname.AddFunction(ScalarFunction({LogicalType::DATE}, LogicalType::VARCHAR,
1798: 	                                   DatePart::UnaryFunction<date_t, string_t, DayNameOperator>));
1799: 	dayname.AddFunction(ScalarFunction({LogicalType::TIMESTAMP}, LogicalType::VARCHAR,
1800: 	                                   DatePart::UnaryFunction<timestamp_t, string_t, DayNameOperator>));
1801: 	return dayname;
1802: }
1803: 
1804: ScalarFunctionSet JulianDayFun::GetFunctions() {
1805: 	using OP = DatePart::JulianDayOperator;
1806: 
1807: 	ScalarFunctionSet operator_set;
1808: 	auto date_func = DatePart::UnaryFunction<date_t, double, OP>;
1809: 	auto date_stats = OP::template PropagateStatistics<date_t>;
1810: 	operator_set.AddFunction(
1811: 	    ScalarFunction({LogicalType::DATE}, LogicalType::DOUBLE, date_func, nullptr, nullptr, date_stats));
1812: 	auto ts_func = DatePart::UnaryFunction<timestamp_t, double, OP>;
1813: 	auto ts_stats = OP::template PropagateStatistics<timestamp_t>;
1814: 	operator_set.AddFunction(
1815: 	    ScalarFunction({LogicalType::TIMESTAMP}, LogicalType::DOUBLE, ts_func, nullptr, nullptr, ts_stats));
1816: 
1817: 	return operator_set;
1818: }
1819: 
1820: ScalarFunctionSet DatePartFun::GetFunctions() {
1821: 	ScalarFunctionSet date_part;
1822: 	date_part.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::DATE}, LogicalType::BIGINT,
1823: 	                                     DatePartFunction<date_t>, DatePartBind));
1824: 	date_part.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::TIMESTAMP}, LogicalType::BIGINT,
1825: 	                                     DatePartFunction<timestamp_t>, DatePartBind));
1826: 	date_part.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::TIME}, LogicalType::BIGINT,
1827: 	                                     DatePartFunction<dtime_t>, DatePartBind));
1828: 	date_part.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::INTERVAL}, LogicalType::BIGINT,
1829: 	                                     DatePartFunction<interval_t>, DatePartBind));
1830: 
1831: 	// struct variants
1832: 	date_part.AddFunction(StructDatePart::GetFunction<date_t>(LogicalType::DATE));
1833: 	date_part.AddFunction(StructDatePart::GetFunction<timestamp_t>(LogicalType::TIMESTAMP));
1834: 	date_part.AddFunction(StructDatePart::GetFunction<dtime_t>(LogicalType::TIME));
1835: 	date_part.AddFunction(StructDatePart::GetFunction<interval_t>(LogicalType::INTERVAL));
1836: 
1837: 	return date_part;
1838: }
1839: 
1840: } // namespace duckdb
[end of src/core_functions/scalar/date/date_part.cpp]
[start of src/include/duckdb/common/enums/date_part_specifier.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/enums/date_part_specifier.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/constants.hpp"
12: 
13: namespace duckdb {
14: 
15: enum class DatePartSpecifier : uint8_t {
16: 	//	BIGINT values
17: 	YEAR,
18: 	MONTH,
19: 	DAY,
20: 	DECADE,
21: 	CENTURY,
22: 	MILLENNIUM,
23: 	MICROSECONDS,
24: 	MILLISECONDS,
25: 	SECOND,
26: 	MINUTE,
27: 	HOUR,
28: 	EPOCH,
29: 	DOW,
30: 	ISODOW,
31: 	WEEK,
32: 	ISOYEAR,
33: 	QUARTER,
34: 	DOY,
35: 	YEARWEEK,
36: 	ERA,
37: 	TIMEZONE,
38: 	TIMEZONE_HOUR,
39: 	TIMEZONE_MINUTE,
40: 
41: 	//	DOUBLE values
42: 	JULIAN_DAY
43: };
44: 
45: inline bool IsBigintDatepart(DatePartSpecifier part_code) {
46: 	return size_t(part_code) < size_t(DatePartSpecifier::JULIAN_DAY);
47: }
48: 
49: DUCKDB_API bool TryGetDatePartSpecifier(const string &specifier, DatePartSpecifier &result);
50: DUCKDB_API DatePartSpecifier GetDatePartSpecifier(const string &specifier);
51: 
52: } // namespace duckdb
[end of src/include/duckdb/common/enums/date_part_specifier.hpp]
[start of src/optimizer/rule/date_part_simplification.cpp]
1: #include "duckdb/optimizer/rule/date_part_simplification.hpp"
2: 
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/planner/expression/bound_constant_expression.hpp"
5: #include "duckdb/planner/expression/bound_function_expression.hpp"
6: #include "duckdb/optimizer/matcher/expression_matcher.hpp"
7: #include "duckdb/optimizer/expression_rewriter.hpp"
8: #include "duckdb/common/enums/date_part_specifier.hpp"
9: #include "duckdb/function/function.hpp"
10: #include "duckdb/function/function_binder.hpp"
11: 
12: namespace duckdb {
13: 
14: DatePartSimplificationRule::DatePartSimplificationRule(ExpressionRewriter &rewriter) : Rule(rewriter) {
15: 	auto func = make_uniq<FunctionExpressionMatcher>();
16: 	func->function = make_uniq<SpecificFunctionMatcher>("date_part");
17: 	func->matchers.push_back(make_uniq<ConstantExpressionMatcher>());
18: 	func->matchers.push_back(make_uniq<ExpressionMatcher>());
19: 	func->policy = SetMatcher::Policy::ORDERED;
20: 	root = std::move(func);
21: }
22: 
23: unique_ptr<Expression> DatePartSimplificationRule::Apply(LogicalOperator &op, vector<reference<Expression>> &bindings,
24:                                                          bool &changes_made, bool is_root) {
25: 	auto &date_part = bindings[0].get().Cast<BoundFunctionExpression>();
26: 	auto &constant_expr = bindings[1].get().Cast<BoundConstantExpression>();
27: 	auto &constant = constant_expr.value;
28: 
29: 	if (constant.IsNull()) {
30: 		// NULL specifier: return constant NULL
31: 		return make_uniq<BoundConstantExpression>(Value(date_part.return_type));
32: 	}
33: 	// otherwise check the specifier
34: 	auto specifier = GetDatePartSpecifier(StringValue::Get(constant));
35: 	string new_function_name;
36: 	switch (specifier) {
37: 	case DatePartSpecifier::YEAR:
38: 		new_function_name = "year";
39: 		break;
40: 	case DatePartSpecifier::MONTH:
41: 		new_function_name = "month";
42: 		break;
43: 	case DatePartSpecifier::DAY:
44: 		new_function_name = "day";
45: 		break;
46: 	case DatePartSpecifier::DECADE:
47: 		new_function_name = "decade";
48: 		break;
49: 	case DatePartSpecifier::CENTURY:
50: 		new_function_name = "century";
51: 		break;
52: 	case DatePartSpecifier::MILLENNIUM:
53: 		new_function_name = "millennium";
54: 		break;
55: 	case DatePartSpecifier::QUARTER:
56: 		new_function_name = "quarter";
57: 		break;
58: 	case DatePartSpecifier::WEEK:
59: 		new_function_name = "week";
60: 		break;
61: 	case DatePartSpecifier::YEARWEEK:
62: 		new_function_name = "yearweek";
63: 		break;
64: 	case DatePartSpecifier::DOW:
65: 		new_function_name = "dayofweek";
66: 		break;
67: 	case DatePartSpecifier::ISODOW:
68: 		new_function_name = "isodow";
69: 		break;
70: 	case DatePartSpecifier::DOY:
71: 		new_function_name = "dayofyear";
72: 		break;
73: 	case DatePartSpecifier::EPOCH:
74: 		new_function_name = "epoch";
75: 		break;
76: 	case DatePartSpecifier::MICROSECONDS:
77: 		new_function_name = "microsecond";
78: 		break;
79: 	case DatePartSpecifier::MILLISECONDS:
80: 		new_function_name = "millisecond";
81: 		break;
82: 	case DatePartSpecifier::SECOND:
83: 		new_function_name = "second";
84: 		break;
85: 	case DatePartSpecifier::MINUTE:
86: 		new_function_name = "minute";
87: 		break;
88: 	case DatePartSpecifier::HOUR:
89: 		new_function_name = "hour";
90: 		break;
91: 	default:
92: 		return nullptr;
93: 	}
94: 	// found a replacement function: bind it
95: 	vector<unique_ptr<Expression>> children;
96: 	children.push_back(std::move(date_part.children[1]));
97: 
98: 	string error;
99: 	FunctionBinder binder(rewriter.context);
100: 	auto function = binder.BindScalarFunction(DEFAULT_SCHEMA, new_function_name, std::move(children), error, false);
101: 	if (!function) {
102: 		throw BinderException(error);
103: 	}
104: 	return function;
105: }
106: 
107: } // namespace duckdb
[end of src/optimizer/rule/date_part_simplification.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: