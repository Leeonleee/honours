You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
PIVOT accepts an ORDER BY clause which is ignored
### What happens?

PIVOT accepts an ORDER BY clause which is ignored

`PIVOT Cities ON Year USING SUM(Population) GROUP BY country ORDER BY country desc`
`PIVOT Cities ON Year USING SUM(Population) GROUP BY country ORDER BY country desc`

return identical results: the "order by" is ignored. It's not in the syntax on https://duckdb.org/docs/sql/statements/pivot.html, but I wrote this out of habit: an "order by" following a "group by" is common practice. 

I'd be happy with a syntax error.

### To Reproduce


```
CREATE TABLE Cities(Country VARCHAR, Name VARCHAR, Year INT, Population INT);
INSERT INTO Cities VALUES ('NL', 'Amsterdam', 2000, 1005);
INSERT INTO Cities VALUES ('NL', 'Amsterdam', 2010, 1065);
INSERT INTO Cities VALUES ('NL', 'Amsterdam', 2020, 1158);
INSERT INTO Cities VALUES ('US', 'Seattle', 2000, 564);
INSERT INTO Cities VALUES ('US', 'Seattle', 2010, 608);
INSERT INTO Cities VALUES ('US', 'Seattle', 2020, 738);
INSERT INTO Cities VALUES ('US', 'New York City', 2000, 8015);
INSERT INTO Cities VALUES ('US', 'New York City', 2010, 8175);
INSERT INTO Cities VALUES ('US', 'New York City', 2020, 8772);
FROM Cities;
PIVOT Cities ON Year USING SUM(Population) GROUP BY country ORDER BY country desc
```


### OS:

Windows

### DuckDB Version:

0.7.2.dev1734

### DuckDB Client:

Python

### Full Name:

Paul Timmins

### Affiliation:

Iqmo

### Have you tried this on the latest `master` branch?

- [X] I agree

### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?

- [X] I agree
PIVOT accepts an ORDER BY clause which is ignored
### What happens?

PIVOT accepts an ORDER BY clause which is ignored

`PIVOT Cities ON Year USING SUM(Population) GROUP BY country ORDER BY country desc`
`PIVOT Cities ON Year USING SUM(Population) GROUP BY country ORDER BY country desc`

return identical results: the "order by" is ignored. It's not in the syntax on https://duckdb.org/docs/sql/statements/pivot.html, but I wrote this out of habit: an "order by" following a "group by" is common practice. 

I'd be happy with a syntax error.

### To Reproduce


```
CREATE TABLE Cities(Country VARCHAR, Name VARCHAR, Year INT, Population INT);
INSERT INTO Cities VALUES ('NL', 'Amsterdam', 2000, 1005);
INSERT INTO Cities VALUES ('NL', 'Amsterdam', 2010, 1065);
INSERT INTO Cities VALUES ('NL', 'Amsterdam', 2020, 1158);
INSERT INTO Cities VALUES ('US', 'Seattle', 2000, 564);
INSERT INTO Cities VALUES ('US', 'Seattle', 2010, 608);
INSERT INTO Cities VALUES ('US', 'Seattle', 2020, 738);
INSERT INTO Cities VALUES ('US', 'New York City', 2000, 8015);
INSERT INTO Cities VALUES ('US', 'New York City', 2010, 8175);
INSERT INTO Cities VALUES ('US', 'New York City', 2020, 8772);
FROM Cities;
PIVOT Cities ON Year USING SUM(Population) GROUP BY country ORDER BY country desc
```


### OS:

Windows

### DuckDB Version:

0.7.2.dev1734

### DuckDB Client:

Python

### Full Name:

Paul Timmins

### Affiliation:

Iqmo

### Have you tried this on the latest `master` branch?

- [X] I agree

### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?

- [X] I agree

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=master" alt="Github Actions Badge">
9:   </a>
10:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
11:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
12:   </a>
13:   <a href="https://discord.gg/tcvwpjfnZx">
14:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
15:   </a>
16:   <a href="https://github.com/duckdb/duckdb/releases/">
17:     <img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release">
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The detail of benchmarks is in our [Benchmark Guide](benchmark/README.md).
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
[end of README.md]
[start of src/include/duckdb/parser/transformer.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/parser/transformer.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/constants.hpp"
12: #include "duckdb/common/enums/expression_type.hpp"
13: #include "duckdb/common/types.hpp"
14: #include "duckdb/common/unordered_map.hpp"
15: #include "duckdb/parser/qualified_name.hpp"
16: #include "duckdb/parser/tokens.hpp"
17: #include "duckdb/parser/parsed_data/create_info.hpp"
18: #include "duckdb/parser/group_by_node.hpp"
19: #include "duckdb/parser/query_node.hpp"
20: #include "duckdb/common/case_insensitive_map.hpp"
21: 
22: #include "pg_definitions.hpp"
23: #include "nodes/parsenodes.hpp"
24: #include "nodes/primnodes.hpp"
25: 
26: namespace duckdb {
27: 
28: class ColumnDefinition;
29: class StackChecker;
30: struct OrderByNode;
31: struct CopyInfo;
32: struct CommonTableExpressionInfo;
33: struct GroupingExpressionMap;
34: class OnConflictInfo;
35: class UpdateSetInfo;
36: struct ParserOptions;
37: struct PivotColumn;
38: 
39: //! The transformer class is responsible for transforming the internal Postgres
40: //! parser representation into the DuckDB representation
41: class Transformer {
42: 	friend class StackChecker;
43: 
44: 	struct CreatePivotEntry {
45: 		string enum_name;
46: 		unique_ptr<SelectNode> base;
47: 		unique_ptr<ParsedExpression> column;
48: 	};
49: 
50: public:
51: 	explicit Transformer(ParserOptions &options);
52: 	explicit Transformer(Transformer &parent);
53: 	~Transformer();
54: 
55: 	//! Transforms a Postgres parse tree into a set of SQL Statements
56: 	bool TransformParseTree(duckdb_libpgquery::PGList *tree, vector<unique_ptr<SQLStatement>> &statements);
57: 	string NodetypeToString(duckdb_libpgquery::PGNodeTag type);
58: 
59: 	idx_t ParamCount() const;
60: 
61: private:
62: 	optional_ptr<Transformer> parent;
63: 	//! Parser options
64: 	ParserOptions &options;
65: 	//! The current prepared statement parameter index
66: 	idx_t prepared_statement_parameter_index = 0;
67: 	//! Map from named parameter to parameter index;
68: 	case_insensitive_map_t<idx_t> named_param_map;
69: 	//! Holds window expressions defined by name. We need those when transforming the expressions referring to them.
70: 	unordered_map<string, duckdb_libpgquery::PGWindowDef *> window_clauses;
71: 	//! The set of pivot entries to create
72: 	vector<unique_ptr<CreatePivotEntry>> pivot_entries;
73: 	//! Sets of stored CTEs, if any
74: 	vector<CommonTableExpressionMap *> stored_cte_map;
75: 	//! Whether or not we are currently binding a window definition
76: 	bool in_window_definition = false;
77: 
78: 	void Clear();
79: 	bool InWindowDefinition();
80: 
81: 	Transformer &RootTransformer();
82: 	const Transformer &RootTransformer() const;
83: 	void SetParamCount(idx_t new_count);
84: 	void SetNamedParam(const string &name, int32_t index);
85: 	bool GetNamedParam(const string &name, int32_t &index);
86: 	bool HasNamedParameters() const;
87: 
88: 	void AddPivotEntry(string enum_name, unique_ptr<SelectNode> source, unique_ptr<ParsedExpression> column);
89: 	unique_ptr<SQLStatement> GenerateCreateEnumStmt(unique_ptr<CreatePivotEntry> entry);
90: 	bool HasPivotEntries();
91: 	idx_t PivotEntryCount();
92: 	void ExtractCTEsRecursive(CommonTableExpressionMap &cte_map);
93: 
94: private:
95: 	//! Transforms a Postgres statement into a single SQL statement
96: 	unique_ptr<SQLStatement> TransformStatement(duckdb_libpgquery::PGNode *stmt);
97: 	//! Transforms a Postgres statement into a single SQL statement
98: 	unique_ptr<SQLStatement> TransformStatementInternal(duckdb_libpgquery::PGNode *stmt);
99: 	//===--------------------------------------------------------------------===//
100: 	// Statement transformation
101: 	//===--------------------------------------------------------------------===//
102: 	//! Transform a Postgres duckdb_libpgquery::T_PGSelectStmt node into a SelectStatement
103: 	unique_ptr<SelectStatement> TransformSelect(duckdb_libpgquery::PGNode *node, bool isSelect = true);
104: 	//! Transform a Postgres T_AlterStmt node into a AlterStatement
105: 	unique_ptr<AlterStatement> TransformAlter(duckdb_libpgquery::PGNode *node);
106: 	//! Transform a Postgres duckdb_libpgquery::T_PGRenameStmt node into a RenameStatement
107: 	unique_ptr<AlterStatement> TransformRename(duckdb_libpgquery::PGNode *node);
108: 	//! Transform a Postgres duckdb_libpgquery::T_PGCreateStmt node into a CreateStatement
109: 	unique_ptr<CreateStatement> TransformCreateTable(duckdb_libpgquery::PGNode *node);
110: 	//! Transform a Postgres duckdb_libpgquery::T_PGCreateStmt node into a CreateStatement
111: 	unique_ptr<CreateStatement> TransformCreateTableAs(duckdb_libpgquery::PGNode *node);
112: 	//! Transform a Postgres node into a CreateStatement
113: 	unique_ptr<CreateStatement> TransformCreateSchema(duckdb_libpgquery::PGNode *node);
114: 	//! Transform a Postgres duckdb_libpgquery::T_PGCreateSeqStmt node into a CreateStatement
115: 	unique_ptr<CreateStatement> TransformCreateSequence(duckdb_libpgquery::PGNode *node);
116: 	//! Transform a Postgres duckdb_libpgquery::T_PGViewStmt node into a CreateStatement
117: 	unique_ptr<CreateStatement> TransformCreateView(duckdb_libpgquery::PGNode *node);
118: 	//! Transform a Postgres duckdb_libpgquery::T_PGIndexStmt node into CreateStatement
119: 	unique_ptr<CreateStatement> TransformCreateIndex(duckdb_libpgquery::PGNode *node);
120: 	//! Transform a Postgres duckdb_libpgquery::T_PGCreateFunctionStmt node into CreateStatement
121: 	unique_ptr<CreateStatement> TransformCreateFunction(duckdb_libpgquery::PGNode *node);
122: 	//! Transform a Postgres duckdb_libpgquery::T_PGCreateTypeStmt node into CreateStatement
123: 	unique_ptr<CreateStatement> TransformCreateType(duckdb_libpgquery::PGNode *node);
124: 	//! Transform a Postgres duckdb_libpgquery::T_PGCreateDatabaseStmt node into a CreateStatement
125: 	unique_ptr<CreateStatement> TransformCreateDatabase(duckdb_libpgquery::PGNode *node);
126: 	//! Transform a Postgres duckdb_libpgquery::T_PGAlterSeqStmt node into CreateStatement
127: 	unique_ptr<AlterStatement> TransformAlterSequence(duckdb_libpgquery::PGNode *node);
128: 	//! Transform a Postgres duckdb_libpgquery::T_PGDropStmt node into a Drop[Table,Schema]Statement
129: 	unique_ptr<SQLStatement> TransformDrop(duckdb_libpgquery::PGNode *node);
130: 	//! Transform a Postgres duckdb_libpgquery::T_PGInsertStmt node into a InsertStatement
131: 	unique_ptr<InsertStatement> TransformInsert(duckdb_libpgquery::PGNode *node);
132: 
133: 	//! Transform a Postgres duckdb_libpgquery::T_PGOnConflictClause node into a OnConflictInfo
134: 	unique_ptr<OnConflictInfo> TransformOnConflictClause(duckdb_libpgquery::PGOnConflictClause *node,
135: 	                                                     const string &relname);
136: 	//! Transform a ON CONFLICT shorthand into a OnConflictInfo
137: 	unique_ptr<OnConflictInfo> DummyOnConflictClause(duckdb_libpgquery::PGOnConflictActionAlias type,
138: 	                                                 const string &relname);
139: 	//! Transform a Postgres duckdb_libpgquery::T_PGCopyStmt node into a CopyStatement
140: 	unique_ptr<CopyStatement> TransformCopy(duckdb_libpgquery::PGNode *node);
141: 	void TransformCopyOptions(CopyInfo &info, duckdb_libpgquery::PGList *options);
142: 	//! Transform a Postgres duckdb_libpgquery::T_PGTransactionStmt node into a TransactionStatement
143: 	unique_ptr<TransactionStatement> TransformTransaction(duckdb_libpgquery::PGNode *node);
144: 	//! Transform a Postgres T_DeleteStatement node into a DeleteStatement
145: 	unique_ptr<DeleteStatement> TransformDelete(duckdb_libpgquery::PGNode *node);
146: 	//! Transform a Postgres duckdb_libpgquery::T_PGUpdateStmt node into a UpdateStatement
147: 	unique_ptr<UpdateStatement> TransformUpdate(duckdb_libpgquery::PGNode *node);
148: 	//! Transform a Postgres duckdb_libpgquery::T_PGPragmaStmt node into a PragmaStatement
149: 	unique_ptr<SQLStatement> TransformPragma(duckdb_libpgquery::PGNode *node);
150: 	//! Transform a Postgres duckdb_libpgquery::T_PGExportStmt node into a ExportStatement
151: 	unique_ptr<ExportStatement> TransformExport(duckdb_libpgquery::PGNode *node);
152: 	//! Transform a Postgres duckdb_libpgquery::T_PGImportStmt node into a PragmaStatement
153: 	unique_ptr<PragmaStatement> TransformImport(duckdb_libpgquery::PGNode *node);
154: 	unique_ptr<ExplainStatement> TransformExplain(duckdb_libpgquery::PGNode *node);
155: 	unique_ptr<SQLStatement> TransformVacuum(duckdb_libpgquery::PGNode *node);
156: 	unique_ptr<SQLStatement> TransformShow(duckdb_libpgquery::PGNode *node);
157: 	unique_ptr<ShowStatement> TransformShowSelect(duckdb_libpgquery::PGNode *node);
158: 	unique_ptr<AttachStatement> TransformAttach(duckdb_libpgquery::PGNode *node);
159: 	unique_ptr<DetachStatement> TransformDetach(duckdb_libpgquery::PGNode *node);
160: 	unique_ptr<SetStatement> TransformUse(duckdb_libpgquery::PGNode *node);
161: 
162: 	unique_ptr<PrepareStatement> TransformPrepare(duckdb_libpgquery::PGNode *node);
163: 	unique_ptr<ExecuteStatement> TransformExecute(duckdb_libpgquery::PGNode *node);
164: 	unique_ptr<CallStatement> TransformCall(duckdb_libpgquery::PGNode *node);
165: 	unique_ptr<DropStatement> TransformDeallocate(duckdb_libpgquery::PGNode *node);
166: 	unique_ptr<QueryNode> TransformPivotStatement(duckdb_libpgquery::PGSelectStmt *stmt);
167: 	unique_ptr<SQLStatement> CreatePivotStatement(unique_ptr<SQLStatement> statement);
168: 	PivotColumn TransformPivotColumn(duckdb_libpgquery::PGPivot *pivot);
169: 	vector<PivotColumn> TransformPivotList(duckdb_libpgquery::PGList *list);
170: 
171: 	//===--------------------------------------------------------------------===//
172: 	// SetStatement Transform
173: 	//===--------------------------------------------------------------------===//
174: 	unique_ptr<SetStatement> TransformSet(duckdb_libpgquery::PGNode *node);
175: 	unique_ptr<SetStatement> TransformSetVariable(duckdb_libpgquery::PGVariableSetStmt *stmt);
176: 	unique_ptr<SetStatement> TransformResetVariable(duckdb_libpgquery::PGVariableSetStmt *stmt);
177: 
178: 	unique_ptr<SQLStatement> TransformCheckpoint(duckdb_libpgquery::PGNode *node);
179: 	unique_ptr<LoadStatement> TransformLoad(duckdb_libpgquery::PGNode *node);
180: 
181: 	//===--------------------------------------------------------------------===//
182: 	// Query Node Transform
183: 	//===--------------------------------------------------------------------===//
184: 	//! Transform a Postgres duckdb_libpgquery::T_PGSelectStmt node into a QueryNode
185: 	unique_ptr<QueryNode> TransformSelectNode(duckdb_libpgquery::PGSelectStmt *node);
186: 	unique_ptr<QueryNode> TransformSelectInternal(duckdb_libpgquery::PGSelectStmt *node);
187: 
188: 	//===--------------------------------------------------------------------===//
189: 	// Expression Transform
190: 	//===--------------------------------------------------------------------===//
191: 	//! Transform a Postgres boolean expression into an Expression
192: 	unique_ptr<ParsedExpression> TransformBoolExpr(duckdb_libpgquery::PGBoolExpr *root);
193: 	//! Transform a Postgres case expression into an Expression
194: 	unique_ptr<ParsedExpression> TransformCase(duckdb_libpgquery::PGCaseExpr *root);
195: 	//! Transform a Postgres type cast into an Expression
196: 	unique_ptr<ParsedExpression> TransformTypeCast(duckdb_libpgquery::PGTypeCast *root);
197: 	//! Transform a Postgres coalesce into an Expression
198: 	unique_ptr<ParsedExpression> TransformCoalesce(duckdb_libpgquery::PGAExpr *root);
199: 	//! Transform a Postgres column reference into an Expression
200: 	unique_ptr<ParsedExpression> TransformColumnRef(duckdb_libpgquery::PGColumnRef *root);
201: 	//! Transform a Postgres constant value into an Expression
202: 	unique_ptr<ConstantExpression> TransformValue(duckdb_libpgquery::PGValue val);
203: 	//! Transform a Postgres operator into an Expression
204: 	unique_ptr<ParsedExpression> TransformAExpr(duckdb_libpgquery::PGAExpr *root);
205: 	unique_ptr<ParsedExpression> TransformAExprInternal(duckdb_libpgquery::PGAExpr *root);
206: 	//! Transform a Postgres abstract expression into an Expression
207: 	unique_ptr<ParsedExpression> TransformExpression(duckdb_libpgquery::PGNode *node);
208: 	//! Transform a Postgres function call into an Expression
209: 	unique_ptr<ParsedExpression> TransformFuncCall(duckdb_libpgquery::PGFuncCall *root);
210: 	//! Transform a Postgres boolean expression into an Expression
211: 	unique_ptr<ParsedExpression> TransformInterval(duckdb_libpgquery::PGIntervalConstant *root);
212: 	//! Transform a Postgres lambda node [e.g. (x, y) -> x + y] into a lambda expression
213: 	unique_ptr<ParsedExpression> TransformLambda(duckdb_libpgquery::PGLambdaFunction *node);
214: 	//! Transform a Postgres array access node (e.g. x[1] or x[1:3])
215: 	unique_ptr<ParsedExpression> TransformArrayAccess(duckdb_libpgquery::PGAIndirection *node);
216: 	//! Transform a positional reference (e.g. #1)
217: 	unique_ptr<ParsedExpression> TransformPositionalReference(duckdb_libpgquery::PGPositionalReference *node);
218: 	unique_ptr<ParsedExpression> TransformStarExpression(duckdb_libpgquery::PGNode *node);
219: 	unique_ptr<ParsedExpression> TransformBooleanTest(duckdb_libpgquery::PGBooleanTest *node);
220: 
221: 	//! Transform a Postgres constant value into an Expression
222: 	unique_ptr<ParsedExpression> TransformConstant(duckdb_libpgquery::PGAConst *c);
223: 	unique_ptr<ParsedExpression> TransformGroupingFunction(duckdb_libpgquery::PGGroupingFunc *n);
224: 	unique_ptr<ParsedExpression> TransformResTarget(duckdb_libpgquery::PGResTarget *root);
225: 	unique_ptr<ParsedExpression> TransformNullTest(duckdb_libpgquery::PGNullTest *root);
226: 	unique_ptr<ParsedExpression> TransformParamRef(duckdb_libpgquery::PGParamRef *node);
227: 	unique_ptr<ParsedExpression> TransformNamedArg(duckdb_libpgquery::PGNamedArgExpr *root);
228: 
229: 	unique_ptr<ParsedExpression> TransformSQLValueFunction(duckdb_libpgquery::PGSQLValueFunction *node);
230: 
231: 	unique_ptr<ParsedExpression> TransformSubquery(duckdb_libpgquery::PGSubLink *root);
232: 	//===--------------------------------------------------------------------===//
233: 	// Constraints transform
234: 	//===--------------------------------------------------------------------===//
235: 	unique_ptr<Constraint> TransformConstraint(duckdb_libpgquery::PGListCell *cell);
236: 
237: 	unique_ptr<Constraint> TransformConstraint(duckdb_libpgquery::PGListCell *cell, ColumnDefinition &column,
238: 	                                           idx_t index);
239: 
240: 	//===--------------------------------------------------------------------===//
241: 	// Update transform
242: 	//===--------------------------------------------------------------------===//
243: 	unique_ptr<UpdateSetInfo> TransformUpdateSetInfo(duckdb_libpgquery::PGList *target_list,
244: 	                                                 duckdb_libpgquery::PGNode *where_clause);
245: 
246: 	//===--------------------------------------------------------------------===//
247: 	// Index transform
248: 	//===--------------------------------------------------------------------===//
249: 	vector<unique_ptr<ParsedExpression>> TransformIndexParameters(duckdb_libpgquery::PGList *list,
250: 	                                                              const string &relation_name);
251: 
252: 	//===--------------------------------------------------------------------===//
253: 	// Collation transform
254: 	//===--------------------------------------------------------------------===//
255: 	unique_ptr<ParsedExpression> TransformCollateExpr(duckdb_libpgquery::PGCollateClause *collate);
256: 
257: 	string TransformCollation(duckdb_libpgquery::PGCollateClause *collate);
258: 
259: 	ColumnDefinition TransformColumnDefinition(duckdb_libpgquery::PGColumnDef *cdef);
260: 	//===--------------------------------------------------------------------===//
261: 	// Helpers
262: 	//===--------------------------------------------------------------------===//
263: 	OnCreateConflict TransformOnConflict(duckdb_libpgquery::PGOnCreateConflict conflict);
264: 	string TransformAlias(duckdb_libpgquery::PGAlias *root, vector<string> &column_name_alias);
265: 	vector<string> TransformStringList(duckdb_libpgquery::PGList *list);
266: 	void TransformCTE(duckdb_libpgquery::PGWithClause *de_with_clause, CommonTableExpressionMap &cte_map);
267: 	unique_ptr<SelectStatement> TransformRecursiveCTE(duckdb_libpgquery::PGCommonTableExpr *node,
268: 	                                                  CommonTableExpressionInfo &info);
269: 
270: 	unique_ptr<ParsedExpression> TransformUnaryOperator(const string &op, unique_ptr<ParsedExpression> child);
271: 	unique_ptr<ParsedExpression> TransformBinaryOperator(string op, unique_ptr<ParsedExpression> left,
272: 	                                                     unique_ptr<ParsedExpression> right);
273: 	//===--------------------------------------------------------------------===//
274: 	// TableRef transform
275: 	//===--------------------------------------------------------------------===//
276: 	//! Transform a Postgres node into a TableRef
277: 	unique_ptr<TableRef> TransformTableRefNode(duckdb_libpgquery::PGNode *node);
278: 	//! Transform a Postgres FROM clause into a TableRef
279: 	unique_ptr<TableRef> TransformFrom(duckdb_libpgquery::PGList *root);
280: 	//! Transform a Postgres table reference into a TableRef
281: 	unique_ptr<TableRef> TransformRangeVar(duckdb_libpgquery::PGRangeVar *root);
282: 	//! Transform a Postgres table-producing function into a TableRef
283: 	unique_ptr<TableRef> TransformRangeFunction(duckdb_libpgquery::PGRangeFunction *root);
284: 	//! Transform a Postgres join node into a TableRef
285: 	unique_ptr<TableRef> TransformJoin(duckdb_libpgquery::PGJoinExpr *root);
286: 	//! Transform a Postgres pivot node into a TableRef
287: 	unique_ptr<TableRef> TransformPivot(duckdb_libpgquery::PGPivotExpr *root);
288: 	//! Transform a table producing subquery into a TableRef
289: 	unique_ptr<TableRef> TransformRangeSubselect(duckdb_libpgquery::PGRangeSubselect *root);
290: 	//! Transform a VALUES list into a set of expressions
291: 	unique_ptr<TableRef> TransformValuesList(duckdb_libpgquery::PGList *list);
292: 
293: 	//! Transform a range var into a (schema) qualified name
294: 	QualifiedName TransformQualifiedName(duckdb_libpgquery::PGRangeVar *root);
295: 
296: 	//! Transform a Postgres TypeName string into a LogicalType
297: 	LogicalType TransformTypeName(duckdb_libpgquery::PGTypeName *name);
298: 
299: 	//! Transform a Postgres GROUP BY expression into a list of Expression
300: 	bool TransformGroupBy(duckdb_libpgquery::PGList *group, SelectNode &result);
301: 	void TransformGroupByNode(duckdb_libpgquery::PGNode *n, GroupingExpressionMap &map, SelectNode &result,
302: 	                          vector<GroupingSet> &result_sets);
303: 	void AddGroupByExpression(unique_ptr<ParsedExpression> expression, GroupingExpressionMap &map, GroupByNode &result,
304: 	                          vector<idx_t> &result_set);
305: 	void TransformGroupByExpression(duckdb_libpgquery::PGNode *n, GroupingExpressionMap &map, GroupByNode &result,
306: 	                                vector<idx_t> &result_set);
307: 	//! Transform a Postgres ORDER BY expression into an OrderByDescription
308: 	bool TransformOrderBy(duckdb_libpgquery::PGList *order, vector<OrderByNode> &result);
309: 
310: 	//! Transform a Postgres SELECT clause into a list of Expressions
311: 	void TransformExpressionList(duckdb_libpgquery::PGList &list, vector<unique_ptr<ParsedExpression>> &result);
312: 
313: 	//! Transform a Postgres PARTITION BY/ORDER BY specification into lists of expressions
314: 	void TransformWindowDef(duckdb_libpgquery::PGWindowDef *window_spec, WindowExpression *expr);
315: 	//! Transform a Postgres window frame specification into frame expressions
316: 	void TransformWindowFrame(duckdb_libpgquery::PGWindowDef *window_spec, WindowExpression *expr);
317: 
318: 	unique_ptr<SampleOptions> TransformSampleOptions(duckdb_libpgquery::PGNode *options);
319: 	//! Returns true if an expression is only a star (i.e. "*", without any other decorators)
320: 	bool ExpressionIsEmptyStar(ParsedExpression &expr);
321: 
322: private:
323: 	//! Current stack depth
324: 	idx_t stack_depth;
325: 
326: 	void InitializeStackCheck();
327: 	StackChecker StackCheck(idx_t extra_stack = 1);
328: };
329: 
330: class StackChecker {
331: public:
332: 	StackChecker(Transformer &transformer, idx_t stack_usage);
333: 	~StackChecker();
334: 	StackChecker(StackChecker &&) noexcept;
335: 	StackChecker(const StackChecker &) = delete;
336: 
337: private:
338: 	Transformer &transformer;
339: 	idx_t stack_usage;
340: };
341: 
342: vector<string> ReadPgListToString(duckdb_libpgquery::PGList *column_list);
343: 
344: } // namespace duckdb
[end of src/include/duckdb/parser/transformer.hpp]
[start of src/parser/transform/statement/transform_pivot_stmt.cpp]
1: #include "duckdb/parser/transformer.hpp"
2: #include "duckdb/parser/tableref/pivotref.hpp"
3: #include "duckdb/parser/parsed_data/create_type_info.hpp"
4: #include "duckdb/parser/statement/create_statement.hpp"
5: #include "duckdb/parser/statement/select_statement.hpp"
6: #include "duckdb/parser/expression/columnref_expression.hpp"
7: #include "duckdb/parser/expression/star_expression.hpp"
8: #include "duckdb/parser/query_node/select_node.hpp"
9: #include "duckdb/parser/statement/multi_statement.hpp"
10: #include "duckdb/parser/statement/drop_statement.hpp"
11: #include "duckdb/parser/parsed_data/drop_info.hpp"
12: #include "duckdb/parser/expression/cast_expression.hpp"
13: #include "duckdb/parser/expression/constant_expression.hpp"
14: #include "duckdb/parser/expression/operator_expression.hpp"
15: #include "duckdb/parser/expression/function_expression.hpp"
16: #include "duckdb/parser/result_modifier.hpp"
17: #include "duckdb/parser/tableref/subqueryref.hpp"
18: 
19: namespace duckdb {
20: 
21: void Transformer::AddPivotEntry(string enum_name, unique_ptr<SelectNode> base, unique_ptr<ParsedExpression> column) {
22: 	if (parent) {
23: 		parent->AddPivotEntry(std::move(enum_name), std::move(base), std::move(column));
24: 		return;
25: 	}
26: 	auto result = make_uniq<CreatePivotEntry>();
27: 	result->enum_name = std::move(enum_name);
28: 	result->base = std::move(base);
29: 	result->column = std::move(column);
30: 
31: 	pivot_entries.push_back(std::move(result));
32: }
33: 
34: bool Transformer::HasPivotEntries() {
35: 	if (parent) {
36: 		return parent->HasPivotEntries();
37: 	}
38: 	return !pivot_entries.empty();
39: }
40: 
41: idx_t Transformer::PivotEntryCount() {
42: 	if (parent) {
43: 		return parent->PivotEntryCount();
44: 	}
45: 	return pivot_entries.size();
46: }
47: 
48: unique_ptr<SQLStatement> Transformer::GenerateCreateEnumStmt(unique_ptr<CreatePivotEntry> entry) {
49: 	auto result = make_uniq<CreateStatement>();
50: 	auto info = make_uniq<CreateTypeInfo>();
51: 
52: 	info->temporary = true;
53: 	info->internal = false;
54: 	info->catalog = INVALID_CATALOG;
55: 	info->schema = INVALID_SCHEMA;
56: 	info->name = std::move(entry->enum_name);
57: 	info->on_conflict = OnCreateConflict::REPLACE_ON_CONFLICT;
58: 
59: 	// generate the query that will result in the enum creation
60: 	auto select_node = std::move(entry->base);
61: 	auto columnref = entry->column->Copy();
62: 	auto cast = make_uniq<CastExpression>(LogicalType::VARCHAR, std::move(columnref));
63: 	select_node->select_list.push_back(std::move(cast));
64: 
65: 	auto is_not_null = make_uniq<OperatorExpression>(ExpressionType::OPERATOR_IS_NOT_NULL, std::move(entry->column));
66: 	select_node->where_clause = std::move(is_not_null);
67: 
68: 	// order by the column
69: 	select_node->modifiers.push_back(make_uniq<DistinctModifier>());
70: 	auto modifier = make_uniq<OrderModifier>();
71: 	modifier->orders.emplace_back(OrderType::ASCENDING, OrderByNullType::ORDER_DEFAULT,
72: 	                              make_uniq<ConstantExpression>(Value::INTEGER(1)));
73: 	select_node->modifiers.push_back(std::move(modifier));
74: 
75: 	auto select = make_uniq<SelectStatement>();
76: 	select->node = std::move(select_node);
77: 	info->query = std::move(select);
78: 	info->type = LogicalType::INVALID;
79: 
80: 	result->info = std::move(info);
81: 	return std::move(result);
82: }
83: 
84: // unique_ptr<SQLStatement> GenerateDropEnumStmt(string enum_name) {
85: //	auto result = make_uniq<DropStatement>();
86: //	result->info->if_exists = true;
87: //	result->info->schema = INVALID_SCHEMA;
88: //	result->info->catalog = INVALID_CATALOG;
89: //	result->info->name = std::move(enum_name);
90: //	result->info->type = CatalogType::TYPE_ENTRY;
91: //	return std::move(result);
92: //}
93: 
94: unique_ptr<SQLStatement> Transformer::CreatePivotStatement(unique_ptr<SQLStatement> statement) {
95: 	auto result = make_uniq<MultiStatement>();
96: 	for (auto &pivot : pivot_entries) {
97: 		result->statements.push_back(GenerateCreateEnumStmt(std::move(pivot)));
98: 	}
99: 	result->statements.push_back(std::move(statement));
100: 	// FIXME: drop the types again!?
101: 	//	for(auto &pivot : pivot_entries) {
102: 	//		result->statements.push_back(GenerateDropEnumStmt(std::move(pivot->enum_name)));
103: 	//	}
104: 	return std::move(result);
105: }
106: 
107: unique_ptr<QueryNode> Transformer::TransformPivotStatement(duckdb_libpgquery::PGSelectStmt *stmt) {
108: 	auto pivot = stmt->pivot;
109: 	auto source = TransformTableRefNode(pivot->source);
110: 
111: 	auto select_node = make_uniq<SelectNode>();
112: 	// handle the CTEs
113: 	if (stmt->withClause) {
114: 		TransformCTE(reinterpret_cast<duckdb_libpgquery::PGWithClause *>(stmt->withClause), select_node->cte_map);
115: 	}
116: 	if (!pivot->columns) {
117: 		// no pivot columns - not actually a pivot
118: 		select_node->from_table = std::move(source);
119: 		if (pivot->groups) {
120: 			auto groups = TransformStringList(pivot->groups);
121: 			GroupingSet set;
122: 			for (idx_t gr = 0; gr < groups.size(); gr++) {
123: 				auto &group = groups[gr];
124: 				auto colref = make_uniq<ColumnRefExpression>(group);
125: 				select_node->select_list.push_back(colref->Copy());
126: 				select_node->groups.group_expressions.push_back(std::move(colref));
127: 				set.insert(gr);
128: 			}
129: 			select_node->groups.grouping_sets.push_back(std::move(set));
130: 		}
131: 		if (pivot->aggrs) {
132: 			TransformExpressionList(*pivot->aggrs, select_node->select_list);
133: 		}
134: 		return std::move(select_node);
135: 	}
136: 
137: 	// generate CREATE TYPE statements for each of the columns that do not have an IN list
138: 	auto columns = TransformPivotList(pivot->columns);
139: 	auto pivot_idx = PivotEntryCount();
140: 	for (idx_t c = 0; c < columns.size(); c++) {
141: 		auto &col = columns[c];
142: 		if (!col.pivot_enum.empty() || !col.entries.empty()) {
143: 			continue;
144: 		}
145: 		if (col.pivot_expressions.size() != 1) {
146: 			throw InternalException("PIVOT statement with multiple names in pivot entry!?");
147: 		}
148: 		auto enum_name = "__pivot_enum_" + std::to_string(pivot_idx) + "_" + std::to_string(c);
149: 
150: 		auto new_select = make_uniq<SelectNode>();
151: 		ExtractCTEsRecursive(new_select->cte_map);
152: 		new_select->from_table = source->Copy();
153: 		AddPivotEntry(enum_name, std::move(new_select), col.pivot_expressions[0]->Copy());
154: 		col.pivot_enum = enum_name;
155: 	}
156: 
157: 	// generate the actual query, including the pivot
158: 	select_node->select_list.push_back(make_uniq<StarExpression>());
159: 
160: 	auto pivot_ref = make_uniq<PivotRef>();
161: 	pivot_ref->source = std::move(source);
162: 	if (pivot->unpivots) {
163: 		pivot_ref->unpivot_names = TransformStringList(pivot->unpivots);
164: 	} else {
165: 		if (pivot->aggrs) {
166: 			TransformExpressionList(*pivot->aggrs, pivot_ref->aggregates);
167: 		} else {
168: 			// pivot but no aggregates specified - push a count star
169: 			vector<unique_ptr<ParsedExpression>> children;
170: 			auto function = make_uniq<FunctionExpression>("count_star", std::move(children));
171: 			pivot_ref->aggregates.push_back(std::move(function));
172: 		}
173: 	}
174: 	if (pivot->groups) {
175: 		pivot_ref->groups = TransformStringList(pivot->groups);
176: 	}
177: 	pivot_ref->pivots = std::move(columns);
178: 	select_node->from_table = std::move(pivot_ref);
179: 	return std::move(select_node);
180: }
181: 
182: } // namespace duckdb
[end of src/parser/transform/statement/transform_pivot_stmt.cpp]
[start of src/parser/transform/statement/transform_select_node.cpp]
1: #include "duckdb/common/exception.hpp"
2: #include "duckdb/common/string_util.hpp"
3: #include "duckdb/parser/expression/star_expression.hpp"
4: #include "duckdb/parser/query_node/select_node.hpp"
5: #include "duckdb/parser/query_node/set_operation_node.hpp"
6: #include "duckdb/parser/statement/select_statement.hpp"
7: #include "duckdb/parser/transformer.hpp"
8: 
9: namespace duckdb {
10: 
11: unique_ptr<QueryNode> Transformer::TransformSelectInternal(duckdb_libpgquery::PGSelectStmt *stmt) {
12: 	D_ASSERT(stmt->type == duckdb_libpgquery::T_PGSelectStmt);
13: 	auto stack_checker = StackCheck();
14: 
15: 	unique_ptr<QueryNode> node;
16: 
17: 	switch (stmt->op) {
18: 	case duckdb_libpgquery::PG_SETOP_NONE: {
19: 		node = make_uniq<SelectNode>();
20: 		auto &result = node->Cast<SelectNode>();
21: 		if (stmt->withClause) {
22: 			TransformCTE(reinterpret_cast<duckdb_libpgquery::PGWithClause *>(stmt->withClause), node->cte_map);
23: 		}
24: 		if (stmt->windowClause) {
25: 			for (auto window_ele = stmt->windowClause->head; window_ele != nullptr; window_ele = window_ele->next) {
26: 				auto window_def = reinterpret_cast<duckdb_libpgquery::PGWindowDef *>(window_ele->data.ptr_value);
27: 				D_ASSERT(window_def);
28: 				D_ASSERT(window_def->name);
29: 				string window_name(window_def->name);
30: 				auto it = window_clauses.find(window_name);
31: 				if (it != window_clauses.end()) {
32: 					throw ParserException("window \"%s\" is already defined", window_name);
33: 				}
34: 				window_clauses[window_name] = window_def;
35: 			}
36: 		}
37: 
38: 		// checks distinct clause
39: 		if (stmt->distinctClause != nullptr) {
40: 			auto modifier = make_uniq<DistinctModifier>();
41: 			// checks distinct on clause
42: 			auto target = reinterpret_cast<duckdb_libpgquery::PGNode *>(stmt->distinctClause->head->data.ptr_value);
43: 			if (target) {
44: 				//  add the columns defined in the ON clause to the select list
45: 				TransformExpressionList(*stmt->distinctClause, modifier->distinct_on_targets);
46: 			}
47: 			result.modifiers.push_back(std::move(modifier));
48: 		}
49: 
50: 		// do this early so the value lists also have a `FROM`
51: 		if (stmt->valuesLists) {
52: 			// VALUES list, create an ExpressionList
53: 			D_ASSERT(!stmt->fromClause);
54: 			result.from_table = TransformValuesList(stmt->valuesLists);
55: 			result.select_list.push_back(make_uniq<StarExpression>());
56: 		} else {
57: 			if (!stmt->targetList) {
58: 				throw ParserException("SELECT clause without selection list");
59: 			}
60: 			// select list
61: 			TransformExpressionList(*stmt->targetList, result.select_list);
62: 			result.from_table = TransformFrom(stmt->fromClause);
63: 		}
64: 
65: 		// where
66: 		result.where_clause = TransformExpression(stmt->whereClause);
67: 		// group by
68: 		TransformGroupBy(stmt->groupClause, result);
69: 		// having
70: 		result.having = TransformExpression(stmt->havingClause);
71: 		// qualify
72: 		result.qualify = TransformExpression(stmt->qualifyClause);
73: 		// sample
74: 		result.sample = TransformSampleOptions(stmt->sampleOptions);
75: 		break;
76: 	}
77: 	case duckdb_libpgquery::PG_SETOP_UNION:
78: 	case duckdb_libpgquery::PG_SETOP_EXCEPT:
79: 	case duckdb_libpgquery::PG_SETOP_INTERSECT:
80: 	case duckdb_libpgquery::PG_SETOP_UNION_BY_NAME: {
81: 		node = make_uniq<SetOperationNode>();
82: 		auto &result = node->Cast<SetOperationNode>();
83: 		if (stmt->withClause) {
84: 			TransformCTE(reinterpret_cast<duckdb_libpgquery::PGWithClause *>(stmt->withClause), node->cte_map);
85: 		}
86: 		result.left = TransformSelectNode(stmt->larg);
87: 		result.right = TransformSelectNode(stmt->rarg);
88: 		if (!result.left || !result.right) {
89: 			throw Exception("Failed to transform setop children.");
90: 		}
91: 
92: 		bool select_distinct = true;
93: 		switch (stmt->op) {
94: 		case duckdb_libpgquery::PG_SETOP_UNION:
95: 			select_distinct = !stmt->all;
96: 			result.setop_type = SetOperationType::UNION;
97: 			break;
98: 		case duckdb_libpgquery::PG_SETOP_EXCEPT:
99: 			result.setop_type = SetOperationType::EXCEPT;
100: 			break;
101: 		case duckdb_libpgquery::PG_SETOP_INTERSECT:
102: 			result.setop_type = SetOperationType::INTERSECT;
103: 			break;
104: 		case duckdb_libpgquery::PG_SETOP_UNION_BY_NAME:
105: 			select_distinct = !stmt->all;
106: 			result.setop_type = SetOperationType::UNION_BY_NAME;
107: 			break;
108: 		default:
109: 			throw Exception("Unexpected setop type");
110: 		}
111: 		if (select_distinct) {
112: 			result.modifiers.push_back(make_uniq<DistinctModifier>());
113: 		}
114: 		if (stmt->sampleOptions) {
115: 			throw ParserException("SAMPLE clause is only allowed in regular SELECT statements");
116: 		}
117: 		break;
118: 	}
119: 	default:
120: 		throw NotImplementedException("Statement type %d not implemented!", stmt->op);
121: 	}
122: 	// transform the common properties
123: 	// both the set operations and the regular select can have an ORDER BY/LIMIT attached to them
124: 	vector<OrderByNode> orders;
125: 	TransformOrderBy(stmt->sortClause, orders);
126: 	if (!orders.empty()) {
127: 		auto order_modifier = make_uniq<OrderModifier>();
128: 		order_modifier->orders = std::move(orders);
129: 		node->modifiers.push_back(std::move(order_modifier));
130: 	}
131: 	if (stmt->limitCount || stmt->limitOffset) {
132: 		if (stmt->limitCount && stmt->limitCount->type == duckdb_libpgquery::T_PGLimitPercent) {
133: 			auto limit_percent_modifier = make_uniq<LimitPercentModifier>();
134: 			auto expr_node = reinterpret_cast<duckdb_libpgquery::PGLimitPercent *>(stmt->limitCount)->limit_percent;
135: 			limit_percent_modifier->limit = TransformExpression(expr_node);
136: 			if (stmt->limitOffset) {
137: 				limit_percent_modifier->offset = TransformExpression(stmt->limitOffset);
138: 			}
139: 			node->modifiers.push_back(std::move(limit_percent_modifier));
140: 		} else {
141: 			auto limit_modifier = make_uniq<LimitModifier>();
142: 			if (stmt->limitCount) {
143: 				limit_modifier->limit = TransformExpression(stmt->limitCount);
144: 			}
145: 			if (stmt->limitOffset) {
146: 				limit_modifier->offset = TransformExpression(stmt->limitOffset);
147: 			}
148: 			node->modifiers.push_back(std::move(limit_modifier));
149: 		}
150: 	}
151: 	return node;
152: }
153: 
154: } // namespace duckdb
[end of src/parser/transform/statement/transform_select_node.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: