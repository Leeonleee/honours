You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
False CSE elimination for quantile window functions
### What happens?

QUANTILE window functions are recognized as the same but they're not. The [CSE elimination](https://github.com/duckdb/duckdb/blob/25617f3135b5867819f32da06e9c846e3788644c/src/execution/physical_plan/plan_window.cpp#L101) seems to miss some information for functions with `bind_info`. 

### To Reproduce

```python
import duckdb

df = duckdb.query("""
    select
        quantile(x, 0.3) over() as q3,
        quantile(x, 0.7) over() as q7
    from generate_series(1, 10) as tbl(x)
""").df()
print(df)
```
The above code produces:
```
   q3  q7
0   3   3
1   3   3
2   3   3
3   3   3
4   3   3
5   3   3
6   3   3
7   3   3
8   3   3
9   3   3
```
But `q7` should be `7`.

Adding
```c++
if (bind_info.get() != other.bind_info.get()) {
	if (!bind_info || !other.bind_info || !bind_info->Equals(*other.bind_info)) {
		return false;
	}
}
```
to the [`BoundWindowExpression::Equals(const BaseExpression &other_p)`](https://github.com/duckdb/duckdb/blob/25617f3135b5867819f32da06e9c846e3788644c/src/planner/expression/bound_window_expression.cpp#L44) function appears to fix this problem.

### OS:

Ubuntu 22.04.2 LTS, aarch64

### DuckDB Version:

0.9.3.dev2108

### DuckDB Client:

Python

### Full Name:

Mark

### Affiliation:

bq

### Have you tried this on the latest `main` branch?

I have tested with a main build

### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/logo-dl/DuckDB_Logo-stacked.svg" height="120">
3: </div>
4: <br>
5: 
6: 
7: 
8: 
9: <p align="center">
10:   <a href="https://github.com/duckdb/duckdb/actions">
11:     <img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge">
12:   </a>
13:   <a href="https://discord.gg/tcvwpjfnZx">
14:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
15:   </a>
16:   <a href="https://github.com/duckdb/duckdb/releases/">
17:     <img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release">
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The detail of benchmarks is in our [Benchmark Guide](benchmark/README.md).
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
[end of README.md]
[start of src/planner/expression/bound_window_expression.cpp]
1: #include "duckdb/planner/expression/bound_window_expression.hpp"
2: #include "duckdb/parser/expression/window_expression.hpp"
3: 
4: #include "duckdb/common/string_util.hpp"
5: #include "duckdb/function/aggregate_function.hpp"
6: #include "duckdb/function/function_serialization.hpp"
7: #include "duckdb/catalog/catalog_entry/aggregate_function_catalog_entry.hpp"
8: 
9: namespace duckdb {
10: 
11: BoundWindowExpression::BoundWindowExpression(ExpressionType type, LogicalType return_type,
12:                                              unique_ptr<AggregateFunction> aggregate,
13:                                              unique_ptr<FunctionData> bind_info)
14:     : Expression(type, ExpressionClass::BOUND_WINDOW, std::move(return_type)), aggregate(std::move(aggregate)),
15:       bind_info(std::move(bind_info)), ignore_nulls(false), distinct(false) {
16: }
17: 
18: string BoundWindowExpression::ToString() const {
19: 	string function_name = aggregate.get() ? aggregate->name : ExpressionTypeToString(type);
20: 	return WindowExpression::ToString<BoundWindowExpression, Expression, BoundOrderByNode>(*this, string(),
21: 	                                                                                       function_name);
22: }
23: 
24: bool BoundWindowExpression::Equals(const BaseExpression &other_p) const {
25: 	if (!Expression::Equals(other_p)) {
26: 		return false;
27: 	}
28: 	auto &other = other_p.Cast<BoundWindowExpression>();
29: 
30: 	if (ignore_nulls != other.ignore_nulls) {
31: 		return false;
32: 	}
33: 	if (distinct != other.distinct) {
34: 		return false;
35: 	}
36: 	if (start != other.start || end != other.end) {
37: 		return false;
38: 	}
39: 	if (exclude_clause != other.exclude_clause) {
40: 		return false;
41: 	}
42: 
43: 	// If there are aggregates, check they are equal
44: 	if (aggregate.get() != other.aggregate.get()) {
45: 		if (!aggregate || !other.aggregate || *aggregate != *other.aggregate) {
46: 			return false;
47: 		}
48: 	}
49: 	// check if the child expressions are equivalent
50: 	if (!Expression::ListEquals(children, other.children)) {
51: 		return false;
52: 	}
53: 	// check if the filter expressions are equivalent
54: 	if (!Expression::Equals(filter_expr, other.filter_expr)) {
55: 		return false;
56: 	}
57: 
58: 	// check if the framing expressions are equivalent
59: 	if (!Expression::Equals(start_expr, other.start_expr) || !Expression::Equals(end_expr, other.end_expr) ||
60: 	    !Expression::Equals(offset_expr, other.offset_expr) || !Expression::Equals(default_expr, other.default_expr)) {
61: 		return false;
62: 	}
63: 
64: 	return KeysAreCompatible(other);
65: }
66: 
67: bool BoundWindowExpression::PartitionsAreEquivalent(const BoundWindowExpression &other) const {
68: 	// Partitions are not order sensitive.
69: 	if (partitions.size() != other.partitions.size()) {
70: 		return false;
71: 	}
72: 	// TODO: Should partitions be an expression_set_t?
73: 	expression_set_t others;
74: 	for (const auto &partition : other.partitions) {
75: 		others.insert(*partition);
76: 	}
77: 	for (const auto &partition : partitions) {
78: 		if (!others.count(*partition)) {
79: 			return false;
80: 		}
81: 	}
82: 	return true;
83: }
84: 
85: idx_t BoundWindowExpression::GetSharedOrders(const BoundWindowExpression &other) const {
86: 	const auto overlap = MinValue<idx_t>(orders.size(), other.orders.size());
87: 
88: 	idx_t result = 0;
89: 	for (; result < overlap; ++result) {
90: 		if (!orders[result].Equals(other.orders[result])) {
91: 			return false;
92: 		}
93: 	}
94: 
95: 	return result;
96: }
97: 
98: bool BoundWindowExpression::KeysAreCompatible(const BoundWindowExpression &other) const {
99: 	if (!PartitionsAreEquivalent(other)) {
100: 		return false;
101: 	}
102: 	// check if the orderings are equivalent
103: 	if (orders.size() != other.orders.size()) {
104: 		return false;
105: 	}
106: 	for (idx_t i = 0; i < orders.size(); i++) {
107: 		if (!orders[i].Equals(other.orders[i])) {
108: 			return false;
109: 		}
110: 	}
111: 	return true;
112: }
113: 
114: unique_ptr<Expression> BoundWindowExpression::Copy() {
115: 	auto new_window = make_uniq<BoundWindowExpression>(type, return_type, nullptr, nullptr);
116: 	new_window->CopyProperties(*this);
117: 
118: 	if (aggregate) {
119: 		new_window->aggregate = make_uniq<AggregateFunction>(*aggregate);
120: 	}
121: 	if (bind_info) {
122: 		new_window->bind_info = bind_info->Copy();
123: 	}
124: 	for (auto &child : children) {
125: 		new_window->children.push_back(child->Copy());
126: 	}
127: 	for (auto &e : partitions) {
128: 		new_window->partitions.push_back(e->Copy());
129: 	}
130: 	for (auto &ps : partitions_stats) {
131: 		if (ps) {
132: 			new_window->partitions_stats.push_back(ps->ToUnique());
133: 		} else {
134: 			new_window->partitions_stats.push_back(nullptr);
135: 		}
136: 	}
137: 	for (auto &o : orders) {
138: 		new_window->orders.emplace_back(o.type, o.null_order, o.expression->Copy());
139: 	}
140: 
141: 	new_window->filter_expr = filter_expr ? filter_expr->Copy() : nullptr;
142: 
143: 	new_window->start = start;
144: 	new_window->end = end;
145: 	new_window->exclude_clause = exclude_clause;
146: 	new_window->start_expr = start_expr ? start_expr->Copy() : nullptr;
147: 	new_window->end_expr = end_expr ? end_expr->Copy() : nullptr;
148: 	new_window->offset_expr = offset_expr ? offset_expr->Copy() : nullptr;
149: 	new_window->default_expr = default_expr ? default_expr->Copy() : nullptr;
150: 	new_window->ignore_nulls = ignore_nulls;
151: 	new_window->distinct = distinct;
152: 
153: 	for (auto &es : expr_stats) {
154: 		if (es) {
155: 			new_window->expr_stats.push_back(es->ToUnique());
156: 		} else {
157: 			new_window->expr_stats.push_back(nullptr);
158: 		}
159: 	}
160: 	return std::move(new_window);
161: }
162: 
163: void BoundWindowExpression::Serialize(Serializer &serializer) const {
164: 	Expression::Serialize(serializer);
165: 	serializer.WriteProperty(200, "return_type", return_type);
166: 	serializer.WriteProperty(201, "children", children);
167: 	if (type == ExpressionType::WINDOW_AGGREGATE) {
168: 		D_ASSERT(aggregate);
169: 		FunctionSerializer::Serialize(serializer, *aggregate, bind_info.get());
170: 	}
171: 	serializer.WriteProperty(202, "partitions", partitions);
172: 	serializer.WriteProperty(203, "orders", orders);
173: 	serializer.WritePropertyWithDefault(204, "filters", filter_expr, unique_ptr<Expression>());
174: 	serializer.WriteProperty(205, "ignore_nulls", ignore_nulls);
175: 	serializer.WriteProperty(206, "start", start);
176: 	serializer.WriteProperty(207, "end", end);
177: 	serializer.WritePropertyWithDefault(208, "start_expr", start_expr, unique_ptr<Expression>());
178: 	serializer.WritePropertyWithDefault(209, "end_expr", end_expr, unique_ptr<Expression>());
179: 	serializer.WritePropertyWithDefault(210, "offset_expr", offset_expr, unique_ptr<Expression>());
180: 	serializer.WritePropertyWithDefault(211, "default_expr", default_expr, unique_ptr<Expression>());
181: 	serializer.WriteProperty(212, "exclude_clause", exclude_clause);
182: 	serializer.WriteProperty(213, "distinct", distinct);
183: }
184: 
185: unique_ptr<Expression> BoundWindowExpression::Deserialize(Deserializer &deserializer) {
186: 	auto expression_type = deserializer.Get<ExpressionType>();
187: 	auto return_type = deserializer.ReadProperty<LogicalType>(200, "return_type");
188: 	auto children = deserializer.ReadProperty<vector<unique_ptr<Expression>>>(201, "children");
189: 	unique_ptr<AggregateFunction> aggregate;
190: 	unique_ptr<FunctionData> bind_info;
191: 	if (expression_type == ExpressionType::WINDOW_AGGREGATE) {
192: 		auto entry = FunctionSerializer::Deserialize<AggregateFunction, AggregateFunctionCatalogEntry>(
193: 		    deserializer, CatalogType::AGGREGATE_FUNCTION_ENTRY, children, return_type);
194: 		aggregate = make_uniq<AggregateFunction>(std::move(entry.first));
195: 		bind_info = std::move(entry.second);
196: 	}
197: 	auto result =
198: 	    make_uniq<BoundWindowExpression>(expression_type, return_type, std::move(aggregate), std::move(bind_info));
199: 	result->children = std::move(children);
200: 	deserializer.ReadProperty(202, "partitions", result->partitions);
201: 	deserializer.ReadProperty(203, "orders", result->orders);
202: 	deserializer.ReadPropertyWithDefault(204, "filters", result->filter_expr, unique_ptr<Expression>());
203: 	deserializer.ReadProperty(205, "ignore_nulls", result->ignore_nulls);
204: 	deserializer.ReadProperty(206, "start", result->start);
205: 	deserializer.ReadProperty(207, "end", result->end);
206: 	deserializer.ReadPropertyWithDefault(208, "start_expr", result->start_expr, unique_ptr<Expression>());
207: 	deserializer.ReadPropertyWithDefault(209, "end_expr", result->end_expr, unique_ptr<Expression>());
208: 	deserializer.ReadPropertyWithDefault(210, "offset_expr", result->offset_expr, unique_ptr<Expression>());
209: 	deserializer.ReadPropertyWithDefault(211, "default_expr", result->default_expr, unique_ptr<Expression>());
210: 	deserializer.ReadProperty(212, "exclude_clause", result->exclude_clause);
211: 	deserializer.ReadProperty(213, "distinct", result->distinct);
212: 	return std::move(result);
213: }
214: 
215: } // namespace duckdb
[end of src/planner/expression/bound_window_expression.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: