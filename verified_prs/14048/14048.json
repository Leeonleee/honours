{
  "repo": "duckdb/duckdb",
  "pull_number": 14048,
  "instance_id": "duckdb__duckdb-14048",
  "issue_numbers": [
    "13064",
    "13604"
  ],
  "base_commit": "a6441ee6ff24166222e99c379fb1e2edf1a8caf5",
  "patch": "diff --git a/src/catalog/catalog.cpp b/src/catalog/catalog.cpp\nindex 9bbcb1f4825f..1adb05c5953a 100644\n--- a/src/catalog/catalog.cpp\n+++ b/src/catalog/catalog.cpp\n@@ -367,9 +367,10 @@ SchemaCatalogEntry &Catalog::GetSchema(CatalogTransaction transaction, const str\n //===--------------------------------------------------------------------===//\n // Lookup\n //===--------------------------------------------------------------------===//\n-SimilarCatalogEntry Catalog::SimilarEntryInSchemas(ClientContext &context, const string &entry_name, CatalogType type,\n-                                                   const reference_set_t<SchemaCatalogEntry> &schemas) {\n-\tSimilarCatalogEntry result;\n+vector<SimilarCatalogEntry> Catalog::SimilarEntriesInSchemas(ClientContext &context, const string &entry_name,\n+                                                             CatalogType type,\n+                                                             const reference_set_t<SchemaCatalogEntry> &schemas) {\n+\tvector<SimilarCatalogEntry> results;\n \tfor (auto schema_ref : schemas) {\n \t\tauto &schema = schema_ref.get();\n \t\tauto transaction = schema.catalog.GetCatalogTransaction(context);\n@@ -378,12 +379,16 @@ SimilarCatalogEntry Catalog::SimilarEntryInSchemas(ClientContext &context, const\n \t\t\t// no similar entry found\n \t\t\tcontinue;\n \t\t}\n-\t\tif (!result.Found() || result.score < entry.score) {\n-\t\t\tresult = entry;\n-\t\t\tresult.schema = &schema;\n+\t\tif (results.empty() || results[0].score <= entry.score) {\n+\t\t\tif (!results.empty() && results[0].score < entry.score) {\n+\t\t\t\tresults.clear();\n+\t\t\t}\n+\n+\t\t\tresults.push_back(entry);\n+\t\t\tresults.back().schema = &schema;\n \t\t}\n \t}\n-\treturn result;\n+\treturn results;\n }\n \n vector<CatalogSearchEntry> GetCatalogEntries(CatalogEntryRetriever &retriever, const string &catalog,\n@@ -588,7 +593,7 @@ CatalogException Catalog::CreateMissingEntryException(CatalogEntryRetriever &ret\n                                                       const reference_set_t<SchemaCatalogEntry> &schemas,\n                                                       QueryErrorContext error_context) {\n \tauto &context = retriever.GetContext();\n-\tauto entry = SimilarEntryInSchemas(context, entry_name, type, schemas);\n+\tauto entries = SimilarEntriesInSchemas(context, entry_name, type, schemas);\n \n \treference_set_t<SchemaCatalogEntry> unseen_schemas;\n \tauto &db_manager = DatabaseManager::Get(context);\n@@ -668,20 +673,36 @@ CatalogException Catalog::CreateMissingEntryException(CatalogEntryRetriever &ret\n \t// entries in other schemas get a penalty\n \t// however, if there is an exact match in another schema, we will always show it\n \tstatic constexpr const double UNSEEN_PENALTY = 0.2;\n-\tauto unseen_entry = SimilarEntryInSchemas(context, entry_name, type, unseen_schemas);\n-\tstring did_you_mean;\n-\tif (unseen_entry.Found() && (unseen_entry.score == 1.0 || unseen_entry.score - UNSEEN_PENALTY > entry.score)) {\n+\tauto unseen_entries = SimilarEntriesInSchemas(context, entry_name, type, unseen_schemas);\n+\tvector<string> suggestions;\n+\tif (!unseen_entries.empty() && (unseen_entries[0].score == 1.0 || unseen_entries[0].score - UNSEEN_PENALTY >\n+\t                                                                      (entries.empty() ? 0.0 : entries[0].score))) {\n \t\t// the closest matching entry requires qualification as it is not in the default search path\n \t\t// check how to minimally qualify this entry\n-\t\tauto catalog_name = unseen_entry.schema->catalog.GetName();\n-\t\tauto schema_name = unseen_entry.schema->name;\n-\t\tbool qualify_database;\n-\t\tbool qualify_schema;\n-\t\tFindMinimalQualification(retriever, catalog_name, schema_name, qualify_database, qualify_schema);\n-\t\tdid_you_mean = unseen_entry.GetQualifiedName(qualify_database, qualify_schema);\n-\t} else if (entry.Found()) {\n-\t\tdid_you_mean = entry.name;\n+\t\tfor (auto &unseen_entry : unseen_entries) {\n+\t\t\tauto catalog_name = unseen_entry.schema->catalog.GetName();\n+\t\t\tauto schema_name = unseen_entry.schema->name;\n+\t\t\tbool qualify_database;\n+\t\t\tbool qualify_schema;\n+\t\t\tFindMinimalQualification(retriever, catalog_name, schema_name, qualify_database, qualify_schema);\n+\t\t\tsuggestions.push_back(unseen_entry.GetQualifiedName(qualify_database, qualify_schema));\n+\t\t}\n+\t} else if (!entries.empty()) {\n+\t\tfor (auto &entry : entries) {\n+\t\t\tsuggestions.push_back(entry.name);\n+\t\t}\n+\t}\n+\n+\tstring did_you_mean;\n+\tstd::sort(suggestions.begin(), suggestions.end());\n+\tif (suggestions.size() > 2) {\n+\t\tauto last = suggestions.back();\n+\t\tsuggestions.pop_back();\n+\t\tdid_you_mean = StringUtil::Join(suggestions, \", \") + \", or \" + last;\n+\t} else {\n+\t\tdid_you_mean = StringUtil::Join(suggestions, \" or \");\n \t}\n+\n \treturn CatalogException::MissingEntry(type, entry_name, did_you_mean, error_context);\n }\n \ndiff --git a/src/include/duckdb/catalog/catalog.hpp b/src/include/duckdb/catalog/catalog.hpp\nindex 2bf7fad6e3c2..5460199c07c1 100644\n--- a/src/include/duckdb/catalog/catalog.hpp\n+++ b/src/include/duckdb/catalog/catalog.hpp\n@@ -370,8 +370,9 @@ class Catalog {\n \t                                                    QueryErrorContext error_context);\n \n \t//! Return the close entry name, the distance and the belonging schema.\n-\tstatic SimilarCatalogEntry SimilarEntryInSchemas(ClientContext &context, const string &entry_name, CatalogType type,\n-\t                                                 const reference_set_t<SchemaCatalogEntry> &schemas);\n+\tstatic vector<SimilarCatalogEntry> SimilarEntriesInSchemas(ClientContext &context, const string &entry_name,\n+\t                                                           CatalogType type,\n+\t                                                           const reference_set_t<SchemaCatalogEntry> &schemas);\n \n \tvirtual void DropSchema(ClientContext &context, DropInfo &info) = 0;\n \n",
  "test_patch": "diff --git a/test/sql/catalog/did_you_mean.test b/test/sql/catalog/did_you_mean.test\nindex bac86754556f..92d25f7f20ab 100644\n--- a/test/sql/catalog/did_you_mean.test\n+++ b/test/sql/catalog/did_you_mean.test\n@@ -22,3 +22,35 @@ statement error\n SELECT * FROM bye;\n ----\n Did you mean \"test.bye\n+\n+statement ok\n+CREATE SCHEMA a;\n+CREATE TABLE a.foo(name text);\n+\n+statement error\n+SELECT * FROM foo;\n+----\n+Did you mean \"a.foo\"?\n+\n+statement ok\n+CREATE SCHEMA b;\n+CREATE TABLE b.foo(name text);\n+\n+statement error\n+SELECT * FROM foo;\n+----\n+Did you mean \"a.foo or b.foo\"?\n+\n+statement ok\n+CREATE SCHEMA c;\n+CREATE TABLE c.foo(name text);\n+\n+statement error\n+SELECT * FROM foo;\n+----\n+Did you mean \"a.foo, b.foo, or c.foo\"?\n+\n+statement error\n+SELECT * FROM a.fooo;\n+----\n+Did you mean \"foo\"?\n",
  "problem_statement": "Add tests for sha1 function\nThis is a followup to #13020 that adds some basic tests for the new `sha1` function, modeled after the existing tests for `sha512`.\nCatalog Errors only offer one suggestion when multiple suggestions are returned with the same score\n### What happens?\n\nConsider the case where there are multiple schemas with the same matching score for a Catalog error.\r\n\r\n```sql\r\ncreate schema a;\r\ncreate schema b;\r\ncreate table a.foo(name text);\r\ncreate table b.foo(name text);\r\nselect * from foo;\r\n```\r\n\r\n```\r\nCatalog Error: Table with name foo does not exist!\r\nDid you mean \"b.foo\"?\r\nLINE 1: select * from foo;\r\n```\r\n\r\nThere is an equally qualified match in schema `a`, but Catalog Error just presents the last match.\r\n\r\nHere is the relevant snippet of code.\r\n\r\nhttps://github.com/duckdb/duckdb/blob/45787e5f9f8bdb9dce97890c1ac7a7eb2dc3a49f/src/catalog/catalog.cpp#L639-L654\r\n\r\nI'd suggest that the code should be changed to present all suggestions that have the same score so that the a user that has tables in multiple schemas with the same name can make the appropriate choice.\r\n\r\nThanks,\r\n\r\nRusty\n\n### To Reproduce\n\n```sql\r\ncreate schema a;\r\ncreate schema b;\r\ncreate table a.foo(name text);\r\ncreate table b.foo(name text);\r\nselect * from foo;\r\n```\r\n\n\n### OS:\n\nMac OS X\n\n### DuckDB Version:\n\n1.0.0\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nRusty Conover\n\n### Affiliation:\n\nself\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "Thanks\n",
  "created_at": "2024-09-20T09:27:35Z",
  "modified_files": [
    "src/catalog/catalog.cpp",
    "src/include/duckdb/catalog/catalog.hpp"
  ],
  "modified_test_files": [
    "test/sql/catalog/did_you_mean.test"
  ]
}