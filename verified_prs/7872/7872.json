{
  "repo": "duckdb/duckdb",
  "pull_number": 7872,
  "instance_id": "duckdb__duckdb-7872",
  "issue_numbers": [
    "7391"
  ],
  "base_commit": "f198a863cacc778d9c3bacd2cdaac0acda31d173",
  "patch": "diff --git a/src/execution/operator/projection/physical_tableinout_function.cpp b/src/execution/operator/projection/physical_tableinout_function.cpp\nindex e18ea873db1d..d32094f7e2e0 100644\n--- a/src/execution/operator/projection/physical_tableinout_function.cpp\n+++ b/src/execution/operator/projection/physical_tableinout_function.cpp\n@@ -70,6 +70,7 @@ OperatorResultType PhysicalTableInOutFunction::Execute(ExecutionContext &context\n \t\t\treturn OperatorResultType::NEED_MORE_INPUT;\n \t\t}\n \t\t// we are processing a new row: fetch the data for the current row\n+\t\tstate.input_chunk.Reset();\n \t\tD_ASSERT(input.ColumnCount() == state.input_chunk.ColumnCount());\n \t\t// set up the input data to the table in-out function\n \t\tfor (idx_t col_idx = 0; col_idx < input.ColumnCount(); col_idx++) {\ndiff --git a/src/execution/operator/projection/physical_unnest.cpp b/src/execution/operator/projection/physical_unnest.cpp\nindex 93be4538981e..cdd5988e4c9c 100644\n--- a/src/execution/operator/projection/physical_unnest.cpp\n+++ b/src/execution/operator/projection/physical_unnest.cpp\n@@ -65,8 +65,8 @@ void UnnestOperatorState::SetLongestListLength() {\n \t\tif (vector_data.validity.RowIsValid(current_idx)) {\n \n \t\t\t// check if this list is longer\n-\t\t\tauto list_data = UnifiedVectorFormat::GetData<list_entry_t>(vector_data);\n-\t\t\tauto list_entry = list_data[current_idx];\n+\t\t\tauto list_data_entries = UnifiedVectorFormat::GetData<list_entry_t>(vector_data);\n+\t\t\tauto list_entry = list_data_entries[current_idx];\n \t\t\tif (list_entry.length > longest_list_length) {\n \t\t\t\tlongest_list_length = list_entry.length;\n \t\t\t}\n@@ -259,6 +259,11 @@ OperatorResultType PhysicalUnnest::ExecuteInternal(ExecutionContext &context, Da\n \tauto &state = state_p.Cast<UnnestOperatorState>();\n \n \tdo {\n+\t\t// reset validities, if previous loop iteration contained UNNEST(NULL)\n+\t\tif (include_input) {\n+\t\t\tchunk.Reset();\n+\t\t}\n+\n \t\t// prepare the input data by executing any expressions and getting the\n \t\t// UnifiedVectorFormat of each LIST vector (list_vector_data) and its child vector (list_child_data)\n \t\tif (state.first_fetch) {\n@@ -271,7 +276,7 @@ OperatorResultType PhysicalUnnest::ExecuteInternal(ExecutionContext &context, Da\n \t\t\treturn OperatorResultType::NEED_MORE_INPUT;\n \t\t}\n \n-\t\t// each UNNEST in the select_list contains a list (or NULL) for this row, find longest list\n+\t\t// each UNNEST in the select_list contains a list (or NULL) for this row, find the longest list\n \t\t// because this length determines how many times we need to repeat for the current row\n \t\tif (state.longest_list_length == DConstants::INVALID_INDEX) {\n \t\t\tstate.SetLongestListLength();\n",
  "test_patch": "diff --git a/test/sql/types/list/unnest_null_empty.test b/test/sql/types/list/unnest_null_empty.test\nindex 891331f47fe5..89baf223750d 100644\n--- a/test/sql/types/list/unnest_null_empty.test\n+++ b/test/sql/types/list/unnest_null_empty.test\n@@ -53,3 +53,77 @@ Elvis\tNULL\t1\n Elvis\tNULL\tNULL\n Elvis\tNULL\tNULL\n Mark\tNULL\t1\n+\n+# related to issue 7391\n+\n+query III\n+WITH t AS (\n+\tSELECT 1 AS r, ARRAY[1, 2, 3] AS a\n+\tUNION SELECT 2 AS r, ARRAY[4] AS a\n+\tUNION SELECT 3 AS r, NULL AS a)\n+SELECT r, a, UNNEST(a) AS n\n+FROM t\n+ORDER BY r, n;\n+----\n+1\t[1, 2, 3]\t1\n+1\t[1, 2, 3]\t2\n+1\t[1, 2, 3]\t3\n+2\t[4]\t4\n+\n+query II\n+WITH t AS (\n+\tSELECT 1 AS r, ARRAY[1, 2, 3] AS a\n+\tUNION SELECT 2 AS r, ARRAY[4] AS a\n+\tUNION SELECT 3 AS r, NULL AS a)\n+SELECT r, a.value\n+FROM t, (SELECT UNNEST(a)) AS a(value)\n+ORDER BY r, a.value\n+----\n+1\t1\n+1\t2\n+1\t3\n+2\t4\n+\n+query II\n+WITH t AS (\n+\tSELECT 1 AS r, ARRAY[1, 2, 3] AS a\n+\tUNION SELECT 2 AS r, ARRAY[4] AS a\n+\tUNION SELECT 3 AS r, NULL AS a)\n+SELECT r, a.value\n+FROM t, UNNEST(a) AS a(value)\n+ORDER BY r, a.value\n+----\n+1\t1\n+1\t2\n+1\t3\n+2\t4\n+\n+statement ok\n+CREATE TABLE t AS SELECT 5 AS r, ARRAY[1, 2, 3] AS a;\n+\n+statement ok\n+INSERT INTO t VALUES (6, [4]), (7, NULL);\n+\n+query II\n+SELECT r, a.value\n+FROM t, UNNEST(a) AS a(value)\n+ORDER BY r, a.value\n+----\n+5\t1\n+5\t2\n+5\t3\n+6\t4\n+\n+query II\n+WITH t AS (\n+\tSELECT 5 AS r, ARRAY[1, 2, 3] AS a\n+\tUNION SELECT 6 AS r, ARRAY[4] AS a\n+\tUNION SELECT 7 AS r, NULL AS a)\n+SELECT r, a.value\n+FROM t, UNNEST(a) AS a(value)\n+ORDER BY r, a.value\n+----\n+5\t1\n+5\t2\n+5\t3\n+6\t4\n",
  "problem_statement": "LEFT JOIN UNNEST() requires an ON clause\n### What happens?\n\nSometimes you want to UNNEST with a LEFT JOIN.  Currently you have to provide an ON clause in order to do this.  I have a hacky workaround that I would like to remove.\r\n\r\n\n\n### To Reproduce\n\n```\r\nwith t as (\r\n  select \r\n    1 as r, \r\n    [\r\n      {n:1},\r\n      {n:2}\r\n    ] as s\r\n  union   select \r\n    2 as r, \r\n    [\r\n      {n:3},\r\n      {n:4}\r\n    ] as s\r\n     \r\n)\r\nselect r, s1.s.n from t\r\nLEFT JOIN UNNEST(s) as s1(s)\r\n```\n\n### OS:\n\nlinux\n\n### DuckDB Version:\n\ncurrent\n\n### DuckDB Client:\n\nweb shell\n\n### Full Name:\n\nlloyd tabb\n\n### Affiliation:\n\ngoogle\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "Here are the basic permutation I think are interesting.  Assume a table with two columns, a scalar and an array.\r\n\r\n```\r\nwith t as (\r\n  SELECT 1 as r, ARRAY[1,2,3] as a\r\n  UNION SELECT 2 as r, ARRAY[4] as a\r\n  UNION SELECT 3 as r, NULL as a\r\n)\r\nSELECT r, a.value\r\nFROM t \r\n, UNNEST(a) as a(value)\r\n```\r\nReturns no results.  UNNEST(NULL) basically eats everything.  Maybe this is should be an error.  (I think it is in BigQuery).\r\n\r\nThe Query below is  an inner join and eliminates row where r=4.\r\n```\r\nwith t as (\r\n  SELECT 1 as r, ARRAY[1,2,3] as a\r\n  UNION SELECT 2 as r, ARRAY[4] as a\r\n  UNION SELECT 4 as r, [] as a\r\n)\r\nSELECT r, a.value\r\nFROM t \r\n, UNNEST(a) as a(value)\r\n```\r\n\r\n```\r\n{\"r\":1,\"value\":3}\r\n{\"r\":2,\"value\":4}\r\n{\"r\":1,\"value\":2}\r\n{\"r\":1,\"value\":1}\r\n```\r\n\r\nWe get an error without an ON clause but the behaviour is a left join (the r=4 is retained) \r\n```\r\nwith t as (\r\n  SELECT 1 as r, ARRAY[1,2,3] as a\r\n  UNION SELECT 2 as r, ARRAY[4] as a\r\n  UNION SELECT 4 as r, [] as a\r\n)\r\nSELECT r, a.value\r\nFROM t \r\nLEFT JOIN UNNEST(a) as a(value) \r\n   ON a.value is NULL or a.value IS NOT NULL\r\n```\r\n\r\nr | value\r\n-- | --\r\n2 | 4\r\n1 | 3\r\n1 | 2\r\n1 | 1\r\n4 | NULL\r\n\r\n\r\n\r\n",
  "created_at": "2023-06-08T06:45:14Z",
  "modified_files": [
    "src/execution/operator/projection/physical_tableinout_function.cpp",
    "src/execution/operator/projection/physical_unnest.cpp"
  ],
  "modified_test_files": [
    "test/sql/types/list/unnest_null_empty.test"
  ]
}