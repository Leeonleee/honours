{
  "repo": "duckdb/duckdb",
  "pull_number": 5007,
  "instance_id": "duckdb__duckdb-5007",
  "issue_numbers": [
    "5005"
  ],
  "base_commit": "c2ca23eef98ca91fdf73ff29129bc7816bd73ff3",
  "patch": "diff --git a/src/planner/binder/expression/bind_columnref_expression.cpp b/src/planner/binder/expression/bind_columnref_expression.cpp\nindex 47917d8ae599..3b2d9b9f688f 100644\n--- a/src/planner/binder/expression/bind_columnref_expression.cpp\n+++ b/src/planner/binder/expression/bind_columnref_expression.cpp\n@@ -117,6 +117,21 @@ void ExpressionBinder::QualifyColumnNames(Binder &binder, unique_ptr<ParsedExpre\n \n unique_ptr<ParsedExpression> ExpressionBinder::CreateStructExtract(unique_ptr<ParsedExpression> base,\n                                                                    string field_name) {\n+\n+\t// we need to transform the struct extract if it is inside a lambda expression\n+\t// because we cannot bind to an existing table, so we remove the dummy table also\n+\tif (lambda_bindings && base->type == ExpressionType::COLUMN_REF) {\n+\t\tauto &lambda_column_ref = (ColumnRefExpression &)*base;\n+\t\tD_ASSERT(!lambda_column_ref.column_names.empty());\n+\n+\t\tif (lambda_column_ref.column_names[0].find(DummyBinding::DUMMY_NAME) != string::npos) {\n+\t\t\tD_ASSERT(lambda_column_ref.column_names.size() == 2);\n+\t\t\tauto lambda_param_name = lambda_column_ref.column_names.back();\n+\t\t\tlambda_column_ref.column_names.clear();\n+\t\t\tlambda_column_ref.column_names.push_back(lambda_param_name);\n+\t\t}\n+\t}\n+\n \tvector<unique_ptr<ParsedExpression>> children;\n \tchildren.push_back(move(base));\n \tchildren.push_back(make_unique_base<ParsedExpression, ConstantExpression>(Value(move(field_name))));\n@@ -243,7 +258,8 @@ BindResult ExpressionBinder::BindExpression(ColumnRefExpression &colref_p, idx_t\n \tif (!expr) {\n \t\treturn BindResult(binder.FormatError(colref_p, error_message));\n \t}\n-\t//! Generated column returns generated expression\n+\n+\t// a generated column returns a generated expression, a struct on a column returns a struct extract\n \tif (expr->type != ExpressionType::COLUMN_REF) {\n \t\tauto alias = expr->alias;\n \t\tauto result = BindExpression(&expr, depth);\n@@ -252,6 +268,7 @@ BindResult ExpressionBinder::BindExpression(ColumnRefExpression &colref_p, idx_t\n \t\t}\n \t\treturn result;\n \t}\n+\n \tauto &colref = (ColumnRefExpression &)*expr;\n \tD_ASSERT(colref.IsQualified());\n \tauto &table_name = colref.GetTableName();\n",
  "test_patch": "diff --git a/test/sql/function/list/lambdas/transform.test b/test/sql/function/list/lambdas/transform.test\nindex aa084fe19143..5c2ac4bb4ed4 100644\n--- a/test/sql/function/list/lambdas/transform.test\n+++ b/test/sql/function/list/lambdas/transform.test\n@@ -179,6 +179,33 @@ True\n True\n True\n \n+# test structs (issue #5005)\n+\n+query I\n+SELECT list_transform([{'a': 1}], x -> x.a);\n+----\n+[1]\n+\n+query I\n+SELECT list_transform([{'a': [1, 2, 3]}], x -> x.a[2]);\n+----\n+[2]\n+\n+query I\n+SELECT list_transform([{'b' : {'a': 1}}], x -> x.b.a);\n+----\n+[1]\n+\n+query I\n+SELECT list_transform([{'b' : {'a': 42, 'b': 43}}], x -> x.b.b);\n+----\n+[43]\n+\n+query I\n+SELECT list_transform([{'b' : {'a': [{'c': 77}], 'b': 43}}], x -> x.b.a[1].c);\n+----\n+[77]\n+\n # test correlated subqueries\n \n statement ok\n",
  "problem_statement": "Lambda functions do not work with lists of structs in `list_transform`\n### What happens?\n\nAttempting to use a lambda function over a list of structs in `list_transform` fails with the following error:\r\n\r\n```\r\nError: Binder Error: Referenced table \"0_macro_parametersx\" not found!\r\n```\r\n\r\nUsing regular macros works as expected, it's only the lambda functions (and only when the type of the list is a struct, not when it is a primitive type) that seem to be impacted by this.\n\n### To Reproduce\n\nSELECT list_transform([{'a': 1}], x -> x.a);\n\n### OS:\n\nOS X\n\n### DuckDB Version:\n\nv0.5.1 7c111322d\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nJosh Wills\n\n### Affiliation:\n\nWeaveGrid\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "",
  "created_at": "2022-10-17T11:23:16Z",
  "modified_files": [
    "src/planner/binder/expression/bind_columnref_expression.cpp"
  ],
  "modified_test_files": [
    "test/sql/function/list/lambdas/transform.test"
  ]
}