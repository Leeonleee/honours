--- a/src/storage/single_file_block_manager.cpp
+++ b/src/storage/single_file_block_manager.cpp
@@
-void SingleFileBlockManager::LoadFreeList() {
-	if (options.read_only) {
-		// no need to load free list for read only db
-		return;
-	}
-	if (free_list_id == INVALID_BLOCK) {
-		// no free list
-		return;
-	}
+void SingleFileBlockManager::LoadFreeList() {
+	// We also load the free list in read-only mode. While in that mode we will
+	// never write the free list back to disk, loading it allows PRAGMA commands
+	// (e.g., PRAGMA database_size) and other introspection utilities to report
+	// the correct number of used and free blocks. Reading the free list is
+	// entirely safe, as it does not modify any on-disk state.
+
+	if (free_list_id == INVALID_BLOCK) {
+		// no free list
+		return;
+	}
@@
-	auto multi_use_blocks_count = reader.Read<uint64_t>();
-	multi_use_blocks.clear();
-	for (idx_t i = 0; i < multi_use_blocks_count; i++) {
-		auto block_id = reader.Read<block_id_t>();
-		auto usage_count = reader.Read<uint32_t>();
-		multi_use_blocks[block_id] = usage_count;
-	}
+	auto multi_use_blocks_count = reader.Read<uint64_t>();
+	multi_use_blocks.clear();
+	for (idx_t i = 0; i < multi_use_blocks_count; i++) {
+		auto block_id = reader.Read<block_id_t>();
+		auto usage_count = reader.Read<uint32_t>();
+		multi_use_blocks[block_id] = usage_count;
+	}
 }
 
 bool SingleFileBlockManager::IsRootBlock(block_id_t root) {
 	return root == meta_block;
 }
